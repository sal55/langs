/*
Toy C compiler for Windows.

This code is placed in the Public Domain.

Generated C code (not original non-C sources); build with gcc or tcc.

Bart C. 2017-2023
*/

#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

typedef signed char         i8;
typedef short              i16;
typedef int                i32;
typedef long long          i64;

typedef unsigned char       u8;
typedef unsigned short     u16;
typedef unsigned int       u32;
typedef unsigned long long u64;

typedef unsigned char     byte;

typedef float              r32;
typedef double             r64;

extern r64 sqrt(r64);
extern r64 fabs(r64);

typedef struct {void* ptr; u64 length;} Slice;

#define NULL ((void*)0)

#ifndef CALLBACK
#define CALLBACK
#endif

i64 m$llabs(i64 a){ return (a>=0?a:-a);}
#define m$infinity (1.0/0.0)


/* Forward Struct Declarations */
struct cc_decls$tokenrec;
struct cc_decls$mparamrec;
struct cc_decls$caserec;
struct cc_decls$paramrec;
struct cc_decls$attribrec;
struct cc_decls$fieldrec;
struct cc_decls$strec;
struct cc_decls$unitrec;
struct cc_decls$modulerec;
struct cc_decls$dllprocrec;
struct cc_decls$procrec;
struct cc_genasm$genrealtable$fprec;
struct cc_lex$stackinforec;
struct cc_libmcl$opndrec;
struct cc_libmcl$mclrec;
struct cc_parse$readdeclspec$declrec;
struct aa_decls$fwdrec;
struct aa_decls$opndrec;
struct aa_decls$strec;
struct aa_decls$relocrec;
struct aa_decls$dbuffer;
struct aa_decls$modulerec;
struct aa_decls$stlistrec;
struct aa_lib$mclrec;
struct aa_mcxdecls$mcxreloc;
struct aa_mcxdecls$librec;
struct aa_objdecls$imagefileheader;
struct aa_objdecls$imagedir;
struct aa_objdecls$optionalheader;
struct aa_objdecls$imagesectionheader;
struct aa_objdecls$imagesymbol;
struct aa_objdecls$importdirrec;
struct aa_objdecls$coffrelocrec;
struct aa_objdecls$auxsectionrec;
struct aa_objdecls$sectionrec;
struct aa_objdecls$importrec;
struct aa_objdecls$exportrec;
struct aa_objdecls$dllrec;
struct aa_objdecls$exportdirrec;
struct aa_writeexe$basereloc;
struct msysc$procinforec;
struct msysc$fmtrec;
struct mlib$strbuffer;
struct mwindows$rsystemtime;
struct mwindows$input_record;
struct mwindows$rspoint;
struct mwindows$rsrect;
struct mwindows$rpoint;
struct mwindows$rconsole;
struct mwindows$rstartupinfo;
struct mwindows$rprocess_information;
struct mwindows$rwndclassex;
struct mwindows$rmsg;

/* Struct Definitions */
struct cc_decls$tokenrec {
    union {
        i64 value;
        r64 xvalue;
        u64 uvalue;
        u8 *  svalue;
        struct cc_decls$strec *  symptr;
    };
    struct cc_decls$tokenrec* nexttoken;
    union {
        struct {
            byte subcode;
            byte flags;
        };
        u16 subcodex;
    };
    byte symbol;
    byte fileno;
    u32 lineno;
    i32 length;
    union {
        i32 numberoffset;
        i16 paramno;
        i16 pasteno;
    };
};

struct cc_decls$mparamrec {
    struct cc_decls$strec *  def;
    struct cc_decls$mparamrec* nextmparam;
};

struct cc_decls$caserec {
    struct cc_decls$caserec* nextcase;
    i64 value;
};

struct cc_decls$paramrec {
    struct cc_decls$strec *  def;
    struct cc_decls$paramrec* nextparam;
    i32 mode;
    i16 nparams;
    i16 flags;
};

struct cc_decls$attribrec {
    byte ax_static;
    byte ax_equals;
    byte ax_varparams;
    byte ax_used;
    byte ax_forward;
    byte ax_frame;
    byte ax_autovar;
    byte ax_nparams;
    byte ax_callback;
    byte ax_moduleno;
    byte ax_loop;
    union {
        byte ax_align;
        byte ax_dllindex;
        byte ax_extmodno;
        byte ax_flmacro;
    };
};

struct cc_decls$fieldrec {
    struct cc_decls$strec *  def;
    struct cc_decls$strec *  gendef;
    struct cc_decls$fieldrec* nextfield;
    i64 offset;
};

struct cc_decls$strec {
    u8 *  name;
    struct cc_decls$strec* owner;
    struct cc_decls$strec* deflist;
    struct cc_decls$strec* deflistx;
    struct cc_decls$strec* nextdef;
    struct cc_decls$strec* nextdupl;
    struct cc_decls$strec* prevdupl;
    union {
        void *  mclcode;
        void *  opnd;
    };
    union {
        struct cc_decls$paramrec *  nextparam;
        struct cc_decls$unitrec *  callchain;
        struct cc_decls$strec* nextmacro;
        struct cc_decls$fieldrec *  nextfield;
    };
    union {
        struct cc_decls$unitrec *  code;
        struct cc_decls$tokenrec *  tokenlist;
    };
    union {
        struct cc_decls$paramrec *  paramlist;
        struct cc_decls$mparamrec *  mparamlist;
        u8 *  macrovalue;
    };
    union {
        void *  address;
        i64 offset;
        byte oldsymbol;
    };
    u32 lineno;
    i32 index;
    union {
        struct {
            u16 blockno;
            u16 namespace;
        };
        u32 nsblock;
    };
    i16 subcode;
    u16 mode;
    byte namelen;
    byte symbol;
    byte nameid;
    byte scope;
    struct cc_decls$attribrec attribs;
};

struct cc_decls$unitrec {
    union {
        struct cc_decls$strec *  def;
        i64 value;
        u64 uvalue;
        r64 xvalue;
        u8 *  svalue;
        u16 *  wsvalue;
        struct cc_decls$strec *  labeldef;
        struct cc_decls$caserec *  nextcase;
        i32 ptrscale;
        i32 offset;
    };
    struct cc_decls$unitrec* nextunit;
    struct cc_decls$unitrec* a;
    struct cc_decls$unitrec* b;
    struct cc_decls$unitrec* c;
    i32 tag;
    u32 lineno;
    union {
        i32 opcode;
        i32 index;
        u32 uindex;
        i32 slength;
        i32 wslength;
        i32 alength;
        i32 scale;
        i32 aparams;
        i32 count;
    };
    i32 mode;
    byte simple;
    byte fileno;
    union {
        byte callconv;
        byte convmem;
        byte isstrconst;
    };
    union {
        byte strarray;
        byte convtomem;
    };
    byte iswstrconst;
    byte spare1;
    u16 spare2;
};

struct cc_decls$modulerec {
    u8 *  name;
    struct cc_decls$strec *  stmodule;
    i64 fileno;
    u8 *  asmstr;
    u8 *  mhdrstr;
    byte importmap[2000];
};

struct cc_decls$dllprocrec {
    u8 *  name;
    void (*address)(void);
    i64 dllindex;
};

struct cc_decls$procrec {
    struct cc_decls$strec *  def;
    struct cc_decls$procrec* nextproc;
};

struct cc_genasm$genrealtable$fprec {
    union {
        r64 x64;
        i64 ix64;
    };
    union {
        r32 x32;
        i32 ix32;
    };
};

struct cc_lex$stackinforec {
    u8 *  startptr;
    u8 *  sptr;
    i32 lineno;
    i32 fileno;
};

struct cc_libmcl$opndrec {
    struct cc_decls$strec *  def;
    union {
        i64 value;
        r64 xvalue;
        u8 *  svalue;
        u16 *  wsvalue;
    };
    i32 size;
    union {
        i32 index;
        i32 slength;
        i32 wslength;
    };
    byte mode;
    byte reg;
    byte regix;
    byte valtype;
    byte scale;
    byte isglobal;
    byte isfloat;
    byte s3;
};

struct cc_libmcl$mclrec {
    struct cc_libmcl$mclrec* nextmcl;
    struct cc_libmcl$opndrec *  a;
    struct cc_libmcl$opndrec *  b;
    byte opcode;
    byte cond;
    byte fileno;
    byte spare;
    i32 lineno;
};

struct cc_parse$readdeclspec$declrec {
    i32 typeno;
    byte isconst;
    byte isvolatile;
    byte isrestrict;
    byte linkage;
    byte isinline;
    byte isshort;
    byte islong;
    byte isllong;
    byte issigned;
    byte isunsigned;
    byte isusertype;
};

struct aa_decls$fwdrec {
    struct aa_decls$fwdrec* nextfwd;
    i32 offset;
    i16 reltype;
    i16 seg;
};

struct aa_decls$opndrec {
    struct aa_decls$strec *  labeldef;
    union {
        i64 value;
        r64 xvalue;
        u8 *  svalue;
    };
    byte mode;
    byte size;
    byte reg;
    byte regix;
    byte scale;
    byte addrsize;
    byte valtype;
    byte spare2;
};

struct aa_decls$strec {
    u8 *  name;
    struct aa_decls$fwdrec *  fwdrefs;
    struct aa_decls$opndrec *  expr;
    i32 offset;
    i32 stindex;
    i32 importindex;
    byte symbol;
    byte ksymbol;
    byte subcode;
    byte regsize;
    byte scope;
    byte reftype;
    byte segment;
    byte namelen;
    struct aa_decls$strec* basedef;
    struct aa_decls$strec* nextdef;
    struct aa_decls$strec* nextdupl;
    i32 moduleno;
    u32 htindex;
    u32 htfirstindex;
    u32 impindex;
    u32 expindex;
    byte spare[40];
};

struct aa_decls$relocrec {
    struct aa_decls$relocrec* nextreloc;
    i64 reloctype;
    i64 offset;
    i64 stindex;
};

struct aa_decls$dbuffer {
    byte *  pstart;
    union {
        byte *  pcurr;
        u16 *  pcurr16;
        u32 *  pcurr32;
        u64 *  pcurr64;
    };
    byte *  pend;
    i64 alloc;
};

struct aa_decls$modulerec {
    u8 *  filename;
    u8 *  name;
    u8 *  source;
};

struct aa_decls$stlistrec {
    struct aa_decls$strec *  def;
    struct aa_decls$stlistrec* nextitem;
};

struct aa_lib$mclrec {
    struct aa_lib$mclrec* nextmcl;
    struct aa_decls$opndrec *  a;
    struct aa_decls$opndrec *  b;
    u16 opcode;
    u16 c;
    u32 lineno;
};

struct aa_mcxdecls$mcxreloc {
    u32 offset;
    union {
        u16 stindex;
        byte targetsegment;
    };
    byte segment;
    byte reloctype;
};

struct aa_mcxdecls$librec {
    u8 *  version;
    i64 codesize;
    i64 idatasize;
    i64 zdatasize;
    i64 nrelocs;
    i64 ndlllibs;
    i64 nlibs;
    i64 nimports;
    i64 nexports;
    byte *  codeptr;
    byte *  idataptr;
    struct aa_mcxdecls$mcxreloc (*reloctable)[];
    u8 *(*dllnames)[];
    u8 *(*libnames)[];
    u8 *(*importnames)[];
    u8 *(*exports)[];
    byte (*exportsegs)[];
    u64 (*exportoffsets)[];
    u64 entryoffset;
    byte *  zdataptr;
    i64 codexsize;
    u64 (*exportaddr)[];
    i16 (*importxreftable)[];
    u8 *  filespec;
    u8 *  libname;
    byte *  entryaddr;
    i64 libno;
};

struct aa_objdecls$imagefileheader {
    u16 machine;
    u16 nsections;
    u32 timedatestamp;
    u32 symtaboffset;
    u32 nsymbols;
    u16 optheadersize;
    u16 characteristics;
};

struct aa_objdecls$imagedir {
    u32 virtualaddr;
    u32 size;
};

struct aa_objdecls$optionalheader {
    u16 magic;
    byte majorlv;
    byte minorlv;
    u32 codesize;
    u32 idatasize;
    u32 zdatasize;
    u32 entrypoint;
    u32 codebase;
    u64 imagebase;
    u32 sectionalignment;
    u32 filealignment;
    u16 majorosv;
    u16 minorosv;
    u16 majorimagev;
    u16 minorimagev;
    u16 majorssv;
    u16 minorssv;
    u32 win32version;
    u32 imagesize;
    u32 headerssize;
    u32 checksum;
    u16 subsystem;
    u16 dllcharacteristics;
    u64 stackreserve;
    u64 stackcommit;
    u64 heapreserve;
    u64 heapcommit;
    u32 loaderflags;
    u32 rvadims;
    struct aa_objdecls$imagedir exporttable;
    struct aa_objdecls$imagedir importtable;
    struct aa_objdecls$imagedir resourcetable;
    struct aa_objdecls$imagedir exceptiontable;
    struct aa_objdecls$imagedir certtable;
    struct aa_objdecls$imagedir basereloctable;
    struct aa_objdecls$imagedir debug;
    struct aa_objdecls$imagedir architecture;
    struct aa_objdecls$imagedir globalptr;
    struct aa_objdecls$imagedir tlstable;
    struct aa_objdecls$imagedir loadconfigtable;
    struct aa_objdecls$imagedir boundimport;
    struct aa_objdecls$imagedir iat;
    struct aa_objdecls$imagedir delayimportdescr;
    struct aa_objdecls$imagedir clrheader;
    struct aa_objdecls$imagedir reserved;
};

struct aa_objdecls$imagesectionheader {
    u8 name[8];
    union {
        u32 physical_address;
        u32 virtual_size;
    };
    u32 virtual_address;
    u32 rawdata_size;
    u32 rawdata_offset;
    u32 relocations_ptr;
    u32 linenos_offset;
    u16 nrelocs;
    u16 nlinenos;
    u32 characteristics;
};

struct aa_objdecls$imagesymbol {
    union {
        u8 shortname[8];
        struct {
            u32 shortx;
            u32 longx;
        };
        u64 longname;
    };
    u32 value;
    i16 sectionno;
    u16 symtype;
    byte storageclass;
    byte nauxsymbols;
};

struct aa_objdecls$importdirrec {
    u32 implookuprva;
    u32 timedatestamp;
    u32 fwdchain;
    u32 namerva;
    u32 impaddressrva;
};

struct aa_objdecls$coffrelocrec {
    i32 virtualaddr;
    i32 stindex;
    i16 reloctype;
};

struct aa_objdecls$auxsectionrec {
    i32 length;
    i16 nrelocs;
    i16 nlines;
    i32 checksum;
    i16 sectionno;
    i32 dummy;
};

struct aa_objdecls$sectionrec {
    union {
        struct aa_decls$dbuffer *  data;
        byte *  bytedata;
    };
    u8 *  name;
    i64 segtype;
    i64 rawsize;
    i64 rawoffset;
    i64 virtsize;
    i64 virtoffset;
    struct aa_decls$relocrec *  relocs;
    i64 nrelocs;
};

struct aa_objdecls$importrec {
    struct aa_decls$strec *  def;
    i64 libno;
    u8 *  name;
    i64 hintnameoffset;
    i64 iatoffset;
    i64 thunkoffset;
};

struct aa_objdecls$exportrec {
    struct aa_decls$strec *  def;
    u8 *  name;
};

struct aa_objdecls$dllrec {
    u8 *  name;
    i64 nprocs;
    i64 nametableoffset;
    i64 addrtableoffset;
    i64 dllnameoffset;
    i64 dllextraoffset;
};

struct aa_objdecls$exportdirrec {
    u32 exportflags;
    u32 timedatestamp;
    u16 majorversion;
    u16 minorversion;
    u32 namerva;
    u32 ordinalbase;
    u32 naddrtable;
    u32 nnamepointers;
    u32 expaddressrva;
    u32 namepointerrva;
    u32 ordtablerva;
};

struct aa_writeexe$basereloc {
    struct aa_writeexe$basereloc* nextitem;
    u32 address;
    i32 reloctype;
};

struct msysc$procinforec {
    u16 fnindex;
    byte rettype;
    byte nparams;
    byte paramlist[12];
};

struct msysc$fmtrec {
    byte minwidth;
    i8 precision;
    byte base;
    u8 quotechar;
    u8 padchar;
    u8 realfmt;
    u8 plus;
    u8 sepchar;
    u8 lettercase;
    u8 justify;
    u8 suffix;
    u8 usigned;
    u8 charmode;
    u8 heapmode;
    u8 param;
    byte spare;
};

struct mlib$strbuffer {
    u8 *  strptr;
    i32 length;
    i32 allocated;
};

struct mwindows$rsystemtime {
    u16 year;
    u16 month;
    u16 dayofweek;
    u16 day;
    u16 hour;
    u16 minute;
    u16 second;
    u16 milliseconds;
};

#pragma pack(8)
struct mwindows$input_record {
    u16 eventtype;
    u32 keydown;
    u16 repeatcount;
    u16 virtualkeycode;
    u16 virtualscancode;
    union {
        u16 unicodechar;
        byte asciichar;
    };
    u32 controlkeystate;
};
#pragma pack(1)

struct mwindows$rspoint {
    i16 x;
    i16 y;
};

struct mwindows$rsrect {
    i16 leftx;
    i16 top;
    i16 rightx;
    i16 bottom;
};

struct mwindows$rpoint {
    i32 x;
    i32 y;
};

struct mwindows$rconsole {
    struct mwindows$rspoint size;
    struct mwindows$rspoint pos;
    u16 attributes;
    struct mwindows$rsrect window;
    struct mwindows$rspoint maxwindowsize;
};

struct mwindows$rstartupinfo {
    u32 size;
    u32 dummy1;
    u8 *  reserved;
    u8 *  desktop;
    u8 *  title;
    u32 x;
    u32 y;
    u32 xsize;
    u32 ysize;
    u32 xcountchars;
    u32 ycountchars;
    u32 fillattribute;
    u32 flags;
    u16 showwindow;
    u16 reserved2;
    u32 dummy2;
    void *  reserved4;
    void *  stdinput;
    void *  stdoutput;
    void *  stderror;
};

struct mwindows$rprocess_information {
    void *  process;
    void *  thread;
    u32 processid;
    u32 threadid;
};

struct mwindows$rwndclassex {
    u32 size;
    u32 style;
    void (*wndproc)(void);
    i32 clsextra;
    i32 wndextra;
    void *  instance;
    void *  icon;
    void *  cursor;
    void *  background;
    u8 *  menuname;
    u8 *  classname;
    void *  iconsm;
};

struct mwindows$rmsg {
    void *  hwnd;
    u32 message;
    u32 dummy1;
    u64 wparam;
    u64 lparam;
    u32 time;
    u32 dummy2;
    struct mwindows$rpoint pt;
};


/* PROCDECLS */
int main(int, char**, char**);
static void cc_cli$compilemodules(i64 a,i64 b,i64 pass);
static void cc_cli$debugcompile(void);
static void cc_cli$do_loadmodule(i64 n);
static void cc_cli$do_preprocess(i64 n);
static void cc_cli$do_parsemodule(i64 n);
static void cc_cli$do_genmcl(i64 n);
static void cc_cli$do_genasm(i64 n);
static void cc_cli$do_runprog(void);
static i64 cc_cli$loadmainmodule(u8 *filespec);
static i64 cc_cli$addmodule(u8 *modulename,i64 fileno,i64 id);
static void cc_cli$initlogfile(void);
static void cc_cli$closelogfile(void);
static void cc_cli$initdata(void);
static void cc_cli$initsearchdirs(void);
static void cc_cli$showsearchdirs(void);
static void cc_cli$showast(i64 n);
static void cc_cli$showstflat(u8 *caption);
static void cc_cli$showsttree(u8 *caption,i64 n);
static void cc_cli$showmcl(u8 *caption,i64 n);
static void cc_cli$showasm(i64 n);
static void cc_cli$showfiles(void);
static void cc_cli$starttiming(void);
static void cc_cli$showtiming(void);
void cc_cli$showlps(u8 *caption,i64 t);
static void cc_cli$getinputoptions(void);
static void cc_cli$do_option(i64 sw,u8 *value);
static void cc_cli$showincludepaths(void);
static void cc_cli$showhelp(void);
static void cc_cli$showextrainfo(void);
static void cc_cli$showcaption(void);
static void cc_cli$do_genlink(void);
static void cc_cli$resetcompiler(void);
static i64 cc_cli$addnewmodules(void);
static void cc_cli$writeatfile(void);
void cc_cli$start(void);
void cc_decls$start(void);
void cc_blockmcl$do_stmt(struct cc_decls$unitrec *p);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_expr(struct cc_decls$unitrec *p,i64 reg,i64 am);
static void cc_blockmcl$loneexpr(struct cc_decls$unitrec *p);
static void cc_blockmcl$do_assign(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_assign(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static i64 cc_blockmcl$saveexpr(struct cc_decls$unitrec *a,i64 reg);
static i64 cc_blockmcl$fsaveexpr(struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$restoreexpr(i64 tx,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$frestoreexpr(i64 tx,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$getlvalueopnd(struct cc_decls$unitrec *a,i64 reg);
static void cc_blockmcl$storeopnd(struct cc_libmcl$opndrec *ax,struct cc_libmcl$opndrec *bx);
static void cc_blockmcl$pushexpr(struct cc_decls$unitrec *a,i64 reg);
static void cc_blockmcl$fpushexpr(struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_const(struct cc_decls$unitrec *p,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_constant(struct cc_decls$strec *d,i64 reg);
static void cc_blockmcl$do_labeldef(struct cc_decls$strec *d);
static void cc_blockmcl$do_goto(struct cc_decls$strec *d);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_add(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_fadd(i64 opc,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$loadexpr(struct cc_decls$unitrec *a,i64 reg,i64 isassign);
static struct cc_libmcl$opndrec *cc_blockmcl$evalexpr(struct cc_decls$unitrec *p,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$evaladdr(struct cc_decls$unitrec *p,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$evalptr(struct cc_decls$unitrec *p,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$floadexpr(struct cc_decls$unitrec *a,i64 xreg);
static struct cc_libmcl$opndrec *cc_blockmcl$fevalexpr(struct cc_decls$unitrec *p,i64 xreg);
static void cc_blockmcl$do_if(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,struct cc_decls$unitrec *c);
static void cc_blockmcl$genjumpcond(i64 opc,struct cc_decls$unitrec *p,i64 lab,i64 reg);
static void cc_blockmcl$gcomparejump(i64 jumpopc,struct cc_decls$unitrec *p,struct cc_decls$unitrec *lhs,struct cc_decls$unitrec *rhs,i64 lab,i64 reg);
static i64 cc_blockmcl$reversecond(i64 op);
static void cc_blockmcl$do_preincr(struct cc_decls$unitrec *a,i64 addop,i64 incrop);
static i64 cc_blockmcl$reversemclcond(i64 cond);
static void cc_blockmcl$do_while(struct cc_decls$unitrec *pcond,struct cc_decls$unitrec *pbody);
static void cc_blockmcl$do_while1(struct cc_decls$unitrec *pbody);
static void cc_blockmcl$stacklooplabels(i64 a,i64 b);
static void cc_blockmcl$do_dowhile(struct cc_decls$unitrec *pbody,struct cc_decls$unitrec *pcond);
static void cc_blockmcl$do_for(struct cc_decls$unitrec *pinit,struct cc_decls$unitrec *pbody);
static i64 cc_blockmcl$pushffparams(struct cc_decls$unitrec *p,i64 variadic);
static void cc_blockmcl$pushoneparam(struct cc_decls$unitrec *q,i64 variadic);
static void cc_blockmcl$pushfloatparam(struct cc_decls$unitrec *q);
static void cc_blockmcl$loadfloatparam(struct cc_decls$unitrec *q,i64 regoffset,i64 iscomplex);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_call(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static void cc_blockmcl$do_return(struct cc_decls$unitrec *a);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_sub(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_mul(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_div(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_shl(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_iand(i64 opc,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_preincrx(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_postincrx(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$makeindexopnd(struct cc_decls$unitrec *a,struct cc_decls$unitrec *index,i64 scale,i64 size,i64 offset,i64 reg);
static void cc_blockmcl$mulreg(i64 reg,i64 x);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_ptr(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,i64 reg,i64 am);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_addptr(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg,i64 am);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_subptr(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg,i64 am);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_convert(struct cc_decls$unitrec *a,i64 t,i64 opc,i64 reg);
static void cc_blockmcl$do_decl(struct cc_decls$strec *d);
static struct cc_libmcl$opndrec *cc_blockmcl$do_assignblock(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_widen(struct cc_decls$unitrec *a,i64 m,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_neg(struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_fneg(struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_inot(struct cc_decls$unitrec *a,i64 reg);
static void cc_blockmcl$do_switch(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_rem(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_ifx(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,struct cc_decls$unitrec *c,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_addto(i64 opc,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_faddto(i64 opc,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_eq(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static void cc_blockmcl$do_exprlist(struct cc_decls$unitrec *a);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_exprlist(struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_shlto(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_multo(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_notl(struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_istruel(struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_andorl(struct cc_decls$unitrec *p,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_sqrt(struct cc_decls$unitrec *a,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_scale(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_divto(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_name(struct cc_decls$unitrec *p,i64 reg,i64 am);
static void cc_blockmcl$divreg(i64 reg,i64 x);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_addrof(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,i64 reg,i64 am);
static struct cc_libmcl$opndrec *cc_blockmcl$dx_dot(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg,i64 am);
static void cc_blockmcl$loadviaptr(struct cc_libmcl$opndrec *w,struct cc_libmcl$opndrec *ptropnd,i64 sgned);
void cc_blockmcl$start(void);
void cc_export$writemheader(u8 *infile);
static void cc_export$showmacroseq(struct cc_decls$tokenrec *tk);
static void cc_export$mmstr(u8 *s);
static void cc_export$mmleftstr(u8 *s,i64 n);
static void cc_export$mmstrln(u8 *s);
static void cc_export$mmint(i64 a);
static void cc_export$mmline(void);
static void cc_export$writefunction(struct cc_decls$strec *d);
static void cc_export$mmmode(i64 m,i64 expand);
static void cc_export$writerecord(i64 m,i64 rectype,i64 level);
static void cc_export$writefnptr(i64 m);
static u8 *cc_export$fixname(u8 *name);
void cc_export$start(void);
i64 cc_genasm$codegen_writeasm(i64 moduleno,u8 *outfile);
void cc_genasm$inita64(void);
void cc_genasm$terma64(void);
static void cc_genasm$writetoasm(struct cc_libmcl$mclrec *m);
void cc_genasm$mcltoa64(struct cc_libmcl$mclrec *m);
static void cc_genasm$passthru(i64 opc);
static void cc_genasm$convmcl(void);
static void cc_genasm$do_changeop(i64 opc);
static void cc_genasm$do_comment(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_blank(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_end(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_label(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_labelname(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_mov(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_push(struct cc_libmcl$opndrec *a);
static void cc_genasm$do_pop(struct cc_libmcl$opndrec *a);
static void cc_genasm$do_lea(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_cmovcc(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b,i64 cond);
static void cc_genasm$do_fmov(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_iwiden(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_uwiden(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_inarrow(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_unarrow(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_call(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_ret(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_retn(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_jmp(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_jmpcc(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b,i64 cond);
static void cc_genasm$do_exch(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_add(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_sub(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_imul(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_idiv(struct cc_libmcl$opndrec *a);
static void cc_genasm$do_irem(struct cc_libmcl$opndrec *a);
static void cc_genasm$do_urem(struct cc_libmcl$opndrec *a);
static void cc_genasm$do_and(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_or(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_xor(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_test(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_cmp(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_shl(i64 opc,struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_neg(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_not(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_inc(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_dec(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_setcc(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b,i64 cond);
static void cc_genasm$do_fneg(struct cc_libmcl$opndrec *a);
static void cc_genasm$do_fabs(struct cc_libmcl$opndrec *a);
static void cc_genasm$do_fsqrt(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_ufix(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_ifix(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_ufloat(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_ifloat(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_db(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_dw(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_dd(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_dq(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_align(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_segment(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$do_assem(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static void cc_genasm$strmclasm(struct cc_libmcl$mclrec *mcl);
void cc_genasm$stropndx(struct cc_libmcl$opndrec *a,i64 sizeprefix,i64 debug);
static void cc_genasm$strmclx(struct cc_libmcl$mclrec *mcl);
static u8 *cc_genasm$fgetregnamex(i64 reg);
u8 *cc_genasm$getstringname(i64 n);
u8 *cc_genasm$getwstringname(i64 n);
u8 *cc_genasm$getrealname(i64 n);
u8 *cc_genasm$getsrealname(i64 n);
u8 *cc_genasm$getdintname(i64 n);
i64 cc_genasm$getstringindex(u8 *s,i64 length);
i64 cc_genasm$getwstringindex(u16 *s,i64 length);
static i64 cc_genasm$getrealindex(r64 x);
static i64 cc_genasm$getdintindex(i64 x);
static void cc_genasm$strvaluex(struct cc_libmcl$opndrec *a);
static void cc_genasm$convertimm(struct cc_libmcl$opndrec *a,i64 sx);
static void cc_genasm$genstringtable(void);
static void cc_genasm$genwstringtable(void);
static void cc_genasm$do_defstr(u8 *s,i64 length);
static void cc_genasm$do_defwstr(u16 *s,i64 length);
static void cc_genasm$genrealtable(void);
static void cc_genasm$gendinttable(void);
static void cc_genasm$writefabs(void);
static void cc_genasm$domclseq(struct cc_libmcl$mclrec *m);
static void cc_genasm$asmstr(u8 *s);
static void cc_genasm$asmstrln(u8 *s);
static void cc_genasm$asmline(void);
static void cc_genasm$asmln(void);
static void cc_genasm$asmint(i64 a);
static void cc_genasm$asmchar(i64 c);
static void cc_genasm$asmterm(void);
static void cc_genasm$initasmline(void);
static u8 *cc_genasm$getregnamex(i64 reg,i64 size);
static void cc_genasm$genstring(u8 *s,i64 length);
static void cc_genasm$genwstring(u16 *s,i64 length);
static void cc_genasm$extendrealtable(void);
static void cc_genasm$extenddinttable(void);
static void cc_genasm$extendstringtable(void);
void cc_genasm$start(void);
i64 cc_genmcl$codegen_mcl(i64 n);
static void cc_genmcl$genprocdef(struct cc_decls$strec *p);
static i64 cc_genmcl$checkblockreturn(struct cc_decls$unitrec *p);
static void cc_genmcl$dolabel(struct cc_decls$strec *d);
static void cc_genmcl$dolabel_fn(struct cc_decls$strec *d,i64 dollar);
static void cc_genmcl$dostaticvar(struct cc_decls$strec *d);
static void cc_genmcl$dostaticvar_fn(struct cc_decls$strec *d);
static void cc_genmcl$genprocentry(i64 fbytes,i64 pbytes);
static void cc_genmcl$genidata(struct cc_decls$unitrec *p,i64 doterm,i64 am,i64 offset);
static void cc_genmcl$genmainprelude(void);
void cc_genmcl$start(void);
u8 *cc_headers$findheader(u8 *name);
void cc_headers$writeheaders(void);
void cc_headers$checkbcclib(void);
u8 *cc_headers$getbcclib(void);
i64 cc_headers$isheaderfile(u8 *file);
void cc_headers$start(void);
void cc_lex$lex_preprocess_only(u8 *infile,i64 showtokens,i64 nn,i64 toconsole);
void cc_lex$lexreadtoken(void);
static void cc_lex$readrealnumber(u8 *pstart,u8 *intstart,i64 intlen,i64 base);
static i64 cc_lex$readexponent(i64 *badexpon);
static void cc_lex$lxerror(u8 *mess);
void cc_lex$printsymbol(struct cc_decls$tokenrec *lp);
void cc_lex$lexsetup(void);
void cc_lex$printstrn(u8 *s,i64 length,void *f);
static u8 *cc_lex$scannumber(i64 base);
static i64 cc_lex$lookup(void);
u64 cc_lex$gethashvalue(u8 *s,i64 length);
static void cc_lex$inithashtable(void);
static void cc_lex$fillhashtable(void);
static i64 cc_lex$dolexdirective(void);
static i64 cc_lex$getlexdirective(void);
void cc_lex$startlex(u8 *caption,i64 fileno);
void cc_lex$endlex(void);
void cc_lex$ps(u8 *caption);
void cc_lex$psnext(u8 *caption);
i64 cc_lex$gethashtablesize(void);
static void cc_lex$readlinecomment(void);
static void cc_lex$readblockcomment(void);
static void cc_lex$readhex(u8 *pstart);
static void cc_lex$readbinary(u8 *pstart);
static void cc_lex$readoctal(u8 *pstart);
static void cc_lex$readdecimal(u8 *pstart);
static i64 cc_lex$checknumbersuffix(void);
static void cc_lex$stacksourcefile(u8 *file,i64 syshdr);
static void cc_lex$unstacksourcefile(void);
static i64 cc_lex$getsourcefile(u8 *file,i64 syshdr);
void cc_lex$lex(void);
static void cc_lex$shownumberstr(struct cc_decls$tokenrec *l,void *f);
struct cc_decls$strec *cc_lex$addnamestr(u8 *name);
static void cc_lex$lxreadstring(i64 termchar,i64 fwide);
static void cc_lex$addlisttoken(struct cc_decls$tokenrec **ulist,struct cc_decls$tokenrec **ulistx,struct cc_decls$tokenrec *p);
static void cc_lex$addlisttoken_copy(struct cc_decls$tokenrec **ulist,struct cc_decls$tokenrec **ulistx,struct cc_decls$tokenrec *q);
static void cc_lex$addlist_nextlx(struct cc_decls$tokenrec **ulist,struct cc_decls$tokenrec **ulistx);
static void cc_lex$addlisttoken_seq(struct cc_decls$tokenrec **ulist,struct cc_decls$tokenrec **ulistx,struct cc_decls$tokenrec *seq);
static void cc_lex$addlistmparam(struct cc_decls$mparamrec **ulist,struct cc_decls$mparamrec **ulistx,struct cc_decls$mparamrec *p);
static void cc_lex$dodefine(void);
static void cc_lex$readalphanumeric(u8 *pstart);
static i64 cc_lex$inmacrostack(struct cc_decls$strec *d,struct cc_decls$tokenrec *macrostack);
static void cc_lex$showtokens(u8 *caption,struct cc_decls$tokenrec *tk);
static void cc_lex$lexa(struct cc_decls$tokenrec **tk);
static void cc_lex$lexm(void);
static i64 cc_lex$peeklb(void);
static i64 cc_lex$peektk(struct cc_decls$tokenrec *tk);
static struct cc_decls$tokenrec *cc_lex$expandobjmacro(struct cc_decls$strec *m,struct cc_decls$tokenrec *macrostack,struct cc_decls$tokenrec **tksource,i64 frombaselevel);
static struct cc_decls$tokenrec *cc_lex$expandfnmacro(struct cc_decls$strec *m,struct cc_decls$tokenrec *macrostack,struct cc_decls$tokenrec **tksource,i64 frombaselevel,i64 *endlineno);
static struct cc_decls$tokenrec *cc_lex$scantokenseq(struct cc_decls$tokenrec *tk,struct cc_decls$tokenrec *macrostack,i64 *expanded);
static i64 cc_lex$readmacrocall(struct cc_decls$strec *d,struct cc_decls$tokenrec *(*args)[],struct cc_decls$tokenrec **tksource);
static struct cc_decls$tokenrec *cc_lex$substituteargs(struct cc_decls$strec *m,struct cc_decls$tokenrec *(*args)[],struct cc_decls$tokenrec *(*expargs)[],i64 nargs,struct cc_decls$tokenrec *macrostack);
static u8 *cc_lex$strtoken(struct cc_decls$tokenrec *lp,i64 *length);
static u8 *cc_lex$strstring(u8 *s,i64 length,i64 *newlength,i64 quotechar);
void cc_lex$emittoken(struct cc_decls$tokenrec *lp,struct mlib$strbuffer *dest,i64 forcespace);
void cc_lex$showtoken(struct cc_decls$tokenrec *lp);
static void cc_lex$stringify(struct cc_decls$tokenrec *seq,struct cc_decls$tokenrec *dest);
static void cc_lex$pastetokens(struct cc_decls$tokenrec *tk,struct cc_decls$tokenrec **tknext);
static i64 cc_lex$getifexpr(void);
static i64 cc_lex$evalcondexpr(i64 *sx);
static i64 cc_lex$evalorexpr(i64 *sx);
static i64 cc_lex$evalandexpr(i64 *sx);
static i64 cc_lex$evaliorexpr(i64 *sx);
static i64 cc_lex$evalixorexpr(i64 *sx);
static i64 cc_lex$evaliandexpr(i64 *sx);
static i64 cc_lex$evaleqexpr(i64 *sx);
static i64 cc_lex$evalcmpexpr(i64 *sx);
static i64 cc_lex$evalshiftexpr(i64 *sx);
static i64 cc_lex$evaladdexpr(i64 *sx);
static i64 cc_lex$evalmulexpr(i64 *sx);
static i64 cc_lex$evalunaryexpr(i64 *sx);
static i64 cc_lex$evalterm(i64 *sx);
static i64 cc_lex$getifdef(void);
static i64 cc_lex$skipcode(void);
static void cc_lex$freetokens(struct cc_decls$tokenrec *tk);
void cc_lex$fastreadtoken(void);
static struct cc_decls$tokenrec *cc_lex$alloctoken(void);
static struct cc_decls$tokenrec *cc_lex$alloctokenz(void);
static void cc_lex$expandpredefmacro(i64 pdmcode,struct cc_decls$tokenrec *tk,i64 lineno);
static void cc_lex$dopragmadir(void);
static i64 cc_lex$needspace(i64 a,i64 b);
void cc_lex$dospecialinclude(void);
static void cc_lex$addautomodule(u8 *headername,i64 fileno);
static void cc_lex$setnumberoffset(i64 offset);
static void cc_lex$setfileno(i64 fileno);
static void cc_lex$setfilenox(struct cc_decls$tokenrec *tk,i64 fileno);
static i64 cc_lex$getfileno(void);
static i64 cc_lex$getfilenox(struct cc_decls$tokenrec *tk);
static i64 cc_lex$getnumberoffsetx(struct cc_decls$tokenrec *tk);
void cc_lex$freehashtable(void);
static void cc_lex$freestentry(struct cc_decls$strec *d);
static void cc_lex$regenlookup(struct cc_decls$strec *d);
static void cc_lex$printhashtable(u8 *caption);
static void cc_lex$newhashtable(void);
static void cc_lex$old_readrealnumber(u8 *pstart,u8 *intstart,i64 intlen,i64 base);
i64 cc_lex$issimpleconstmacro(struct cc_decls$strec *m);
void cc_lex$start(void);
static struct cc_decls$strec *cc_lib$newstrec(void);
void cc_lib$initcclib(void);
void cc_lib$printst(void *f,struct cc_decls$strec *p,i64 level);
static void cc_lib$printstrec(void *f,struct cc_decls$strec *p,i64 level);
void cc_lib$printstflat(void *f);
struct cc_decls$unitrec *cc_lib$createname(struct cc_decls$strec *p);
struct cc_decls$unitrec *cc_lib$createunit0(i64 tag);
struct cc_decls$unitrec *cc_lib$createunit1(i64 tag,struct cc_decls$unitrec *p);
struct cc_decls$unitrec *cc_lib$createunit2(i64 tag,struct cc_decls$unitrec *p,struct cc_decls$unitrec *q);
struct cc_decls$unitrec *cc_lib$createunit3(i64 tag,struct cc_decls$unitrec *p,struct cc_decls$unitrec *q,struct cc_decls$unitrec *r);
struct cc_decls$unitrec *cc_lib$createconstunit(u64 a,i64 t);
struct cc_decls$unitrec *cc_lib$createstringconstunit(u8 *s,i64 length);
struct cc_decls$unitrec *cc_lib$createwstringconstunit(u16 *s,i64 length);
i64 cc_lib$getoptocode(i64 opc);
i64 cc_lib$getconstvalue(struct cc_decls$unitrec *p,i64 id);
u8 *cc_lib$nextautotype(void);
i64 cc_lib$createconstmode(i64 m);
i64 cc_lib$createrefmode(i64 m);
i64 cc_lib$createprocmode(i64 m,struct cc_decls$paramrec *pm);
i64 cc_lib$createarraymode(i64 m,i64 length);
i64 cc_lib$createenummode(struct cc_decls$strec *e);
i64 cc_lib$createstructmode(struct cc_decls$strec *s,i64 smode);
void cc_lib$setnameptr(struct cc_decls$unitrec *p);
void cc_lib$printcode_all(void *f,u8 *caption);
void cc_lib$printcode(void *f,u8 *caption,i64 n);
void cc_lib$printunit(void *dev,struct cc_decls$unitrec *p,i64 level,u8 *prefix);
static void cc_lib$printunitlist(void *dev,struct cc_decls$unitrec *p,i64 level,u8 *prefix);
static u8 *cc_lib$getprefix(i64 level,u8 *prefix,struct cc_decls$unitrec *p);
u8 *cc_lib$getdottedname(struct cc_decls$strec *p);
static u8 *cc_lib$getlineinfok(void);
struct cc_decls$strec *cc_lib$getautofieldname(void);
void cc_lib$convertstring(u8 *s,u8 *t,i64 length);
struct mlib$strbuffer *cc_lib$strexpr(struct cc_decls$unitrec *p);
static void cc_lib$jeval(struct mlib$strbuffer *dest,struct cc_decls$unitrec *p);
u8 *cc_lib$getopcjname(i64 opc);
u8 *cc_lib$strmode(i64 m,i64 expand);
u8 *cc_lib$strmode2(i64 m,i64 expand);
void cc_lib$istrmode(i64 m,i64 expand,u8 *dest);
i64 cc_lib$countunits(struct cc_decls$unitrec *p);
static void cc_lib$purgesymbol(struct cc_decls$strec *p,struct cc_decls$strec *prev,i64 del);
void cc_lib$purgesymbollist(struct cc_decls$strec *p,i64 ismodule,i64 del);
void cc_lib$purgeprocs(struct cc_decls$strec *p,i64 del);
void cc_lib$purgeproc(struct cc_decls$strec *p,i64 del);
void cc_lib$printmodelist(void *f);
u8 *cc_lib$typename(i64 m);
struct cc_decls$unitrec *cc_lib$allocunitrec(void);
static i64 cc_lib$copymode(i64 m);
static i64 cc_lib$createnewmode(i64 m);
void cc_lib$addlistunit(struct cc_decls$unitrec **ulist,struct cc_decls$unitrec **ulistx,struct cc_decls$unitrec *p);
void cc_lib$addlistdef(struct cc_decls$strec **ulist,struct cc_decls$strec **ulistx,struct cc_decls$strec *p);
void cc_lib$addlistparam(struct cc_decls$paramrec **ulist,struct cc_decls$paramrec **ulistx,struct cc_decls$paramrec *p);
void cc_lib$checksymbol(i64 symbol);
void cc_lib$skipsymbol(i64 symbol);
void cc_lib$inittypetables(void);
struct cc_decls$strec *cc_lib$createdupldef(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 id);
struct cc_decls$strec *cc_lib$createnewmoduledef(struct cc_decls$strec *owner,struct cc_decls$strec *symptr);
struct cc_decls$strec *cc_lib$createnewproc(struct cc_decls$strec *owner,struct cc_decls$strec *symptr);
struct cc_decls$strec *cc_lib$resolvename(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 ns,i64 blockno);
struct cc_decls$strec *cc_lib$resolvelabel(struct cc_decls$strec *owner,struct cc_decls$strec *symptr);
struct cc_decls$strec *cc_lib$checkdupl(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 ns,i64 blockno);
struct cc_decls$strec *cc_lib$checkdupl_inproc(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 ns,i64 blockno);
i64 cc_lib$getalignment(i64 m);
i64 cc_lib$isexported(struct cc_decls$strec *d);
i64 cc_lib$isimported(struct cc_decls$strec *d);
i64 cc_lib$isstructunion(i64 m);
u8 *cc_lib$getstname(struct cc_decls$strec *d);
i64 cc_lib$isrealcc(i64 m);
i64 cc_lib$isintcc(i64 m);
void cc_lib$start(void);
void cc_libmcl$mclinit(void);
i64 cc_libmcl$gettargetdata(i64 f64);
void cc_libmcl$initmcdest(void);
void cc_libmcl$genmc(i64 opcode,struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
void cc_libmcl$genmc_cond(i64 opcode,i64 cond,struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
struct cc_libmcl$mclrec *cc_libmcl$lastmc(void);
void cc_libmcl$genmcstr(i64 opcode,u8 *s);
static struct cc_libmcl$opndrec *cc_libmcl$newopnd(void);
struct cc_libmcl$opndrec *cc_libmcl$duplopnd(struct cc_libmcl$opndrec *a);
struct cc_libmcl$opndrec *cc_libmcl$genxreg(i64 xreg,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$genindex(i64 areg,i64 ireg,i64 scale,i64 offset,i64 size,i64 labno,struct cc_decls$strec *def);
static void cc_libmcl$writemclblock(struct cc_libmcl$mclrec *m);
struct mlib$strbuffer *cc_libmcl$writemclcode(u8 *caption,i64 nmodule);
void cc_libmcl$gencomment(u8 *s);
struct cc_libmcl$opndrec *cc_libmcl$genstrimm(u8 *s,i64 length);
struct cc_libmcl$opndrec *cc_libmcl$genwstrimm(u16 *s,i64 length);
struct cc_libmcl$opndrec *cc_libmcl$genname(u8 *s);
static void cc_libmcl$writemcl(i64 index,struct cc_libmcl$mclrec *mcl);
u8 *cc_libmcl$strmcl(struct cc_libmcl$mclrec *mcl);
u8 *cc_libmcl$stropnd(struct cc_libmcl$opndrec *a,i64 sizeprefix,i64 debug);
u8 *cc_libmcl$strvalue(struct cc_libmcl$opndrec *a);
void cc_libmcl$setsegment(i64 seg,i64 align);
u8 *cc_libmcl$getprocname(struct cc_decls$strec *d);
i64 cc_libmcl$widenstr(u8 *s,i64 w);
void cc_libmcl$genassem(u8 *s);
u8 *cc_libmcl$strlabel(i64 n);
struct cc_libmcl$opndrec *cc_libmcl$makeindirect(struct cc_libmcl$opndrec *a,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$applyoffset(struct cc_libmcl$opndrec *a,i64 offset,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$applysize(struct cc_libmcl$opndrec *a,i64 size);
i64 cc_libmcl$isframe(struct cc_decls$strec *d);
void cc_libmcl$genreturn(i64 fbytes,i64 pbytes);
u8 *cc_libmcl$getsizeprefix(i64 size,i64 enable);
i64 cc_libmcl$needsizeprefix(i64 opcode,struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
struct cc_libmcl$opndrec *cc_libmcl$changeopndsize(struct cc_libmcl$opndrec *a,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$genint(i64 x,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$genreal(r64 x,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$genimm(struct cc_decls$unitrec *p,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$genlabel(i64 x,i64 isglobal);
struct cc_libmcl$opndrec *cc_libmcl$genmem_u(struct cc_decls$unitrec *p,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$genmem_d(struct cc_decls$strec *d,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$genmemaddr_u(struct cc_decls$unitrec *p);
struct cc_libmcl$opndrec *cc_libmcl$genmemaddr_d(struct cc_decls$strec *d);
struct cc_libmcl$opndrec *cc_libmcl$genreg(i64 reg,i64 size);
struct cc_libmcl$opndrec *cc_libmcl$genireg(i64 reg,i64 size);
i64 cc_libmcl$getopndsize_u(struct cc_decls$unitrec *p);
i64 cc_libmcl$getopndsize_d(struct cc_decls$strec *d);
i64 cc_libmcl$getmclcond(i64 opc,i64 m);
u8 *cc_libmcl$getfullname(struct cc_decls$strec *d);
i64 cc_libmcl$roundsizetg(i64 size);
i64 cc_libmcl$iscallbackfn(struct cc_decls$strec *p);
u8 *cc_libmcl$getregname(i64 reg,i64 size);
u8 *cc_libmcl$getblockname(i64 reg,i64 size);
u8 *cc_libmcl$fgetregname(i64 reg,i64 size);
i64 cc_libmcl$issimple(struct cc_decls$unitrec *p);
static i64 cc_libmcl$issimple0(struct cc_decls$unitrec *p,i64 level);
i64 cc_libmcl$issimplepm(struct cc_decls$unitrec *p);
i64 cc_libmcl$getaregs(struct cc_libmcl$opndrec *ax);
i64 cc_libmcl$getlregs(struct cc_libmcl$opndrec *ax);
i64 cc_libmcl$isintconst(struct cc_decls$unitrec *p);
i64 cc_libmcl$_getnextreg(struct cc_libmcl$opndrec *ax,i64 reg);
i64 cc_libmcl$getnextreg(struct cc_libmcl$opndrec *ax,i64 r);
i64 cc_libmcl$ispoweroftwo(i64 x);
static i64 cc_libmcl$sameoperand(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b);
static struct cc_libmcl$mclrec *cc_libmcl$findlastmcl(void);
void cc_libmcl$genmsource(i64 lineno);
i64 cc_libmcl$roundto(i64 a,i64 n);
void cc_libmcl$pushstack(i64 n);
void cc_libmcl$pushstackfp(i64 n);
void cc_libmcl$popstack(i64 n);
i64 cc_libmcl$definelabel(void);
i64 cc_libmcl$createfwdlabel(void);
void cc_libmcl$definefwdlabel(i64 lab);
void cc_libmcl$genjumpl(i64 lab);
void cc_libmcl$setalign(i64 align);
i64 cc_libmcl$gettypecat(struct cc_decls$unitrec *a);
void cc_libmcl$doblockcall(i64 size);
struct cc_libmcl$opndrec *cc_libmcl$getblockreg(i64 size);
void cc_libmcl$copyretvalue(i64 size);
void cc_libmcl$enterproc(u8 *name);
void cc_libmcl$leaveproc(u8 *name);
void cc_libmcl$start(void);
static void cc_parse$readmodule(void);
i64 cc_parse$parsemodule(i64 n);
static i64 cc_parse$readdeclspec(struct cc_decls$strec *owner,i64 *linkage);
static i64 cc_parse$istypestarter(void);
static i64 cc_parse$istypestarter_next(void);
static struct cc_decls$unitrec *cc_parse$readexpression(void);
static struct cc_decls$unitrec *cc_parse$readassignexpr(void);
static struct cc_decls$unitrec *cc_parse$readcondexpr(void);
static struct cc_decls$unitrec *cc_parse$readorlexpr(void);
static struct cc_decls$unitrec *cc_parse$readandlexpr(void);
static struct cc_decls$unitrec *cc_parse$readiorexpr(void);
static struct cc_decls$unitrec *cc_parse$readixorexpr(void);
static struct cc_decls$unitrec *cc_parse$readiandexpr(void);
static struct cc_decls$unitrec *cc_parse$readeqexpr(void);
static struct cc_decls$unitrec *cc_parse$readrelexpr(void);
static struct cc_decls$unitrec *cc_parse$readshiftexpr(void);
static struct cc_decls$unitrec *cc_parse$readaddexpr(void);
static struct cc_decls$unitrec *cc_parse$readmulexpr(void);
static struct cc_decls$unitrec *cc_parse$readterm(void);
static struct cc_decls$unitrec *cc_parse$readexprlist(struct cc_decls$unitrec *p);
static struct cc_decls$strec *cc_parse$readmodulevar(struct cc_decls$strec *d,i64 m,i64 linkage);
static struct cc_decls$strec *cc_parse$readframevar(struct cc_decls$strec *d,i64 m,i64 linkage);
static i64 cc_parse$readtype(struct cc_decls$strec *owner,struct cc_decls$strec **d,i64 m,struct cc_decls$paramrec **pm);
static void cc_parse$readnamedtype(struct cc_decls$strec *owner,struct cc_decls$strec **d,i64 (*modtype)[],void *(*modvalue)[],i64 *nmodifiers);
static i64 cc_parse$readconstintexpr(void);
static struct cc_decls$unitrec *cc_parse$readinitexpr(struct cc_decls$strec *owner,i64 m);
static struct cc_decls$unitrec *cc_parse$readinitexpr2(struct cc_decls$strec *owner,i64 m,i64 istop);
static void cc_parse$pushblock(void);
static void cc_parse$popblock(void);
static struct cc_decls$unitrec *cc_parse$readcompoundstmt(i64 params);
static struct cc_decls$unitrec *cc_parse$readblock(i64 ifelse);
static struct cc_decls$unitrec *cc_parse$readstatement(void);
static struct cc_decls$unitrec *cc_parse$readifstmt(void);
static struct cc_decls$unitrec *cc_parse$readforstmt(void);
static struct cc_decls$unitrec *cc_parse$readwhilestmt(void);
static struct cc_decls$unitrec *cc_parse$readdostmt(void);
static struct cc_decls$unitrec *cc_parse$readreturnstmt(void);
static struct cc_decls$unitrec *cc_parse$readgotostmt(void);
static struct cc_decls$unitrec *cc_parse$readswitchstmt(void);
static struct cc_decls$unitrec *cc_parse$readcaselabel(void);
static struct cc_decls$unitrec *cc_parse$readexprstmt(void);
static struct cc_decls$unitrec *cc_parse$readcond(void);
static i64 cc_parse$isusertype(struct cc_decls$strec *owner);
static struct cc_decls$unitrec *cc_parse$readlocaldecl(void);
static struct cc_decls$strec *cc_parse$createtypedef(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 mode);
static struct cc_decls$paramrec *cc_parse$readparams(struct cc_decls$strec *owner);
static i64 cc_parse$readcasttype(struct cc_decls$strec **d,i64 allowname,struct cc_decls$paramrec **pm,i64 m,i64 *mbase);
static struct cc_decls$strec *cc_parse$readfunction(struct cc_decls$strec *d,i64 m,i64 linkage,struct cc_decls$paramrec *pm,i64 *wasdef);
static struct cc_decls$strec *cc_parse$getbasesymbol(struct cc_decls$strec *e);
static void cc_parse$readfunctionbody(struct cc_decls$strec *f);
static struct cc_decls$unitrec *cc_parse$createnegop(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createabsop(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createsqrtop(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createinotop(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createptrop(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createincrop(i64 opc,struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createlengthofop(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createaddrofop(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createaddop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y);
static struct cc_decls$unitrec *cc_parse$createsubop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y);
static struct cc_decls$unitrec *cc_parse$createmulop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y);
static struct cc_decls$unitrec *cc_parse$createdivop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y);
static struct cc_decls$unitrec *cc_parse$createremop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y);
static void cc_parse$insertunit(struct cc_decls$unitrec *p,i64 tag);
static struct cc_decls$unitrec *cc_parse$eval_add(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t);
static struct cc_decls$unitrec *cc_parse$eval_sub(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t);
static struct cc_decls$unitrec *cc_parse$eval_mul(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t);
static struct cc_decls$unitrec *cc_parse$eval_div(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t);
static struct cc_decls$unitrec *cc_parse$eval_rem(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t);
static i64 cc_parse$eval_convert(struct cc_decls$unitrec *p,i64 t,i64 opc);
static void cc_parse$coercecond(struct cc_decls$unitrec *p);
static void cc_parse$coercebasetype(struct cc_decls$unitrec *p);
static void cc_parse$checklvalue(struct cc_decls$unitrec *p,i64 assign);
static struct cc_decls$unitrec *cc_parse$createcall(struct cc_decls$unitrec *p,struct cc_decls$unitrec *q);
static struct cc_decls$unitrec *cc_parse$arraytopointer(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$createindexop(struct cc_decls$unitrec *p,struct cc_decls$unitrec *q);
static i64 cc_parse$readstructdecl(struct cc_decls$strec *owner);
static i64 cc_parse$checkpointertypes(i64 s,i64 t,i64 hard);
static i64 cc_parse$comparemode(i64 s,i64 t);
static i64 cc_parse$readenumdecl(struct cc_decls$strec *owner);
static void cc_parse$readenumnames(struct cc_decls$strec *owner);
static struct cc_decls$unitrec *cc_parse$createdotop(i64 opc,struct cc_decls$unitrec *p,struct cc_decls$strec *d);
static struct cc_decls$unitrec *cc_parse$mulunit(struct cc_decls$unitrec *p,i64 elemtype);
static struct cc_decls$unitrec *cc_parse$divunit(struct cc_decls$unitrec *p,i64 elemtype);
static struct cc_decls$unitrec *cc_parse$createassignopref(i64 opc,struct cc_decls$unitrec *p,struct cc_decls$unitrec *q);
static void cc_parse$addnewfield(struct cc_decls$fieldrec **flist,struct cc_decls$strec *d,i64 offset);
static void cc_parse$pushloop(i64 looptype);
static void cc_parse$poploop(void);
static void cc_parse$addcasevalue(i64 value);
static i64 cc_parse$roundoffset(i64 offset,i64 alignment);
static void cc_parse$fixmemopnd(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$docast(struct cc_decls$unitrec *p,i64 t,i64 hard,i64 inplace);
static struct cc_decls$unitrec *cc_parse$coercemode(struct cc_decls$unitrec *p,i64 t);
static void cc_parse$coercemode_inplace(struct cc_decls$unitrec *p,i64 t);
static void cc_parse$dostaticassert(void);
static struct cc_decls$unitrec *cc_parse$createsizeofop(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$readgeneric(void);
static void cc_parse$readstructinfosym(void);
static i64 cc_parse$getmemmode(struct cc_decls$unitrec *p);
static struct cc_decls$unitrec *cc_parse$readstrinclude(void);
void cc_parse$start(void);
static void cc_support$stopcompiler(u8 *filename,i64 lineno);
void cc_support$mcerror(u8 *mess);
void cc_support$serror(u8 *mess);
void cc_support$serror_gen(u8 *mess);
void cc_support$serror_ss(u8 *mess,u8 *a,u8 *b);
void cc_support$serror_s(u8 *mess,u8 *a);
void cc_support$terror_gen(u8 *mess);
void cc_support$terror(u8 *mess);
void cc_support$terror_s(u8 *mess,u8 *a);
void cc_support$terror_ss(u8 *mess,u8 *a,u8 *b);
void cc_support$gerror_gen(u8 *mess,struct cc_decls$unitrec *p);
void cc_support$gerror(u8 *mess,struct cc_decls$unitrec *p);
void cc_support$gerror_s(u8 *mess,u8 *s,struct cc_decls$unitrec *p);
void cc_support$nxerror(u8 *mess,struct cc_decls$unitrec *p);
i64 cc_support$testelem(byte (*p)[],i64 n);
void cc_support$setelem(byte (*p)[],i64 n);
i64 cc_support$nextpoweroftwo(i64 x);
void cc_support$loaderror(u8 *mess,u8 *mess2);
i64 cc_support$loadfromstdin(u8 *file);
i64 cc_support$loadsourcefile(u8 *file,u8 *shortfile);
static u8 *cc_support$splicelines(u8 *s);
i64 cc_support$loadbuiltin(u8 *shortfile,u8 *hdrtext);
static void cc_support$gs_copytostr(struct mlib$strbuffer *source,u8 *s);
void cc_support$gs_additem(struct mlib$strbuffer *dest,u8 *s);
static i64 cc_support$isalphanum(i64 c);
static void cc_support$showmacrolineno(void);
void cc_support$start(void);
void cc_tables$start(void);
i64 cc_assembler$assembler(u8 *outputfile,u8 *(*asmfiles)[],u8 *(*dllfiles)[],i64 nasmfiles,i64 ndllfiles,i64 fobj,i64 fcaption,u8 *(*assemsources)[],u8 *entrypointname,i64 fgendll);
static void cc_assembler$loadsourcefiles(u8 *(*assemsources)[]);
static void cc_assembler$parsemodules(void);
static void cc_assembler$fixopnd(struct aa_decls$opndrec *a);
static void cc_assembler$initall(void);
static void cc_assembler$loaderror(u8 *mess);
static void cc_assembler$loaderror_s(u8 *mess,u8 *s);
static void cc_assembler$addmodule(u8 *name);
static void cc_assembler$addsearchlib(u8 *name);
static struct aa_decls$strec *cc_assembler$getemptyst(struct aa_decls$strec *d);
static struct aa_decls$strec *cc_assembler$findduplname(struct aa_decls$strec *d);
static void cc_assembler$adddupl(struct aa_decls$strec *d);
static void cc_assembler$scanglobals(void);
static void cc_assembler$resethashtable(void);
void cc_assembler$start(void);
void aa_decls$start(void);
u8 *aa_disasm$decodeinstr(byte **cptr,byte *baseaddr);
static void aa_disasm$decodetwobyteinstr(void);
static void aa_disasm$decodeaddr(i64 w);
static i64 aa_disasm$readbyte(void);
static i64 aa_disasm$readsbyte(void);
static u64 aa_disasm$readword16(void);
static i64 aa_disasm$readint16(void);
static u64 aa_disasm$readword32(void);
static i64 aa_disasm$readint32(void);
static i64 aa_disasm$readint64(void);
static i64 aa_disasm$getreg(i64 regcode,i64 upper);
u8 *aa_disasm$strreg(i64 reg,i64 opsize);
static u8 *aa_disasm$strfreg(i64 freg);
static void aa_disasm$printaddrmode(i64 xmm);
static void aa_disasm$genstr(u8 *s);
static void aa_disasm$genintd(i64 a);
static void aa_disasm$genhex(i64 a);
static i64 aa_disasm$readimm(void);
static i64 aa_disasm$readimm8(void);
static u8 *aa_disasm$strxmm(i64 reg);
static u8 *aa_disasm$strmmx(i64 reg);
static void aa_disasm$decode8087(i64 ttt);
static void aa_disasm$do87arith(u8 *opcstr,i64 ttt,i64 freg);
static void aa_disasm$do87mem(u8 *opcstr,i64 mf);
static void aa_disasm$getsil(i64 *reg);
static void aa_disasm$getsilx(i64 *reg);
void aa_disasm$start(void);
void aa_genss$genss(void);
static void aa_genss$doinstr(struct aa_lib$mclrec *m,i64 index);
static void aa_genss$genbyte(i64 x);
static void aa_genss$genword(i64 x);
static void aa_genss$gendword(i64 x);
static void aa_genss$genqword(i64 x);
static void aa_genss$genopnd(struct aa_decls$opndrec *a,i64 size);
static void aa_genss$addrelocitem(i64 reloctype,struct aa_decls$strec *d);
static i64 aa_genss$getstindex(struct aa_decls$strec *d);
static void aa_genss$genrel32(struct aa_decls$opndrec *a);
static void aa_genss$genabs32(struct aa_decls$opndrec *a);
static void aa_genss$genabs64(struct aa_decls$opndrec *a);
static i64 aa_genss$getrel32(struct aa_decls$strec *d,i64 offset);
static void aa_genss$dofwdrefs(struct aa_decls$strec *d);
static void aa_genss$genrex(void);
static i64 aa_genss$isbytesized(i64 x);
static i64 aa_genss$isdwordsized(i64 x);
static void aa_genss$do_push(struct aa_decls$opndrec *a);
static void aa_genss$do_pop(struct aa_decls$opndrec *a);
static void aa_genss$do_inc(struct aa_decls$opndrec *a,i64 code);
static void aa_genss$do_neg(struct aa_decls$opndrec *a,i64 code);
static void aa_genss$genamode(struct aa_decls$opndrec *a,i64 am);
static i64 aa_genss$makemodrm(i64 mode,i64 opc,i64 rm);
static void aa_genss$setopsize(struct aa_decls$opndrec *a);
static i64 aa_genss$getdispsize(struct aa_decls$opndrec *a,i64 mand);
static void aa_genss$genrmbyte(i64 mode,i64 opc,i64 rm);
static i64 aa_genss$makeam(i64 m,i64 s,i64 d);
static void aa_genss$do_lea(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_movsx(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 opc);
static void aa_genss$checkhighreg(struct aa_decls$opndrec *a);
static void aa_genss$do_exch(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_movsxd(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_imul2(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_shift(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 code);
static void aa_genss$do_test(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_loop(struct aa_decls$opndrec *a,i64 opc);
static void aa_genss$do_jcxz(struct aa_decls$opndrec *a,i64 opsize);
static void aa_genss$do_setcc(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_arithxmm(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 prefix,i64 opc);
static void aa_genss$do_logicxmm(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 opc,i64 size);
static void aa_genss$do_convertfloat(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 prefix);
static void aa_genss$do_fix(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 prefix,i64 opc);
static void aa_genss$do_float(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 prefix);
static void aa_genss$do_call(struct aa_decls$opndrec *a);
static void aa_genss$do_jmp(struct aa_decls$opndrec *a,struct aa_lib$mclrec *m);
static i64 aa_genss$getcurrdatalen(i64 id);
static void aa_genss$do_cmovcc(struct aa_decls$opndrec *c,struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_fmem(struct aa_decls$opndrec *a,i64 freal,i64 code);
static i64 aa_genss$getr32bits(r64 x);
static void aa_genss$genrel8(struct aa_decls$opndrec *a);
static i64 aa_genss$checkshortjump(struct aa_lib$mclrec *m,struct aa_decls$strec *d);
static struct aa_decls$fwdrec *aa_genss$addfwdref(struct aa_decls$fwdrec *p,i64 offset,i64 reltype,i64 seg);
static void aa_genss$switchseg(i64 newseg);
static void aa_genss$do_popcnt(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_bsf(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 opc);
static void aa_genss$extendsymboltable(void);
static void aa_genss$do_pcmpistri(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 c,i64 opc);
static void aa_genss$genxrm(i64 opcode,i64 code,struct aa_decls$opndrec *b);
static void aa_genss$genrrm(i64 opcode,struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static i64 aa_genss$getregcode(i64 reg,i64 mask,i64 isxreg);
static void aa_genss$checkimmrange(i64 value,i64 size);
static i64 aa_genss$newgenrm(i64 reg,i64 opc,struct aa_decls$opndrec *b,i64 isxreg);
static void aa_genss$do_mov(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
static void aa_genss$do_arith(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 code);
static void aa_genss$do_movxmm(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 size);
static void aa_genss$checksize(struct aa_decls$opndrec *a,i64 size1,i64 size2);
void aa_genss$start(void);
void aa_lex$lex(void);
void aa_lex$initlex(void);
static void aa_lex$readreal(u8 (*s)[],i64 slen,i64 intlen,i64 exponseen);
static void aa_lex$readnumber(i64 c);
static void aa_lex$readbinary(void);
static void aa_lex$readhex(void);
void aa_lex$ps(u8 *caption);
void aa_lex$printsymbol(void *dev);
static void aa_lex$clearhashtable(void);
static void aa_lex$inithashtable(void);
static void aa_lex$addreservedword(u8 *name,i64 symbol,i64 subcode);
void aa_lex$printhashtable(void *devx,u8 *caption);
static i64 aa_lex$lookuplex(u8 *name,i64 length);
void aa_lex$initsourcefile(u8 *source);
struct aa_decls$strec *aa_lex$addnamestr(u8 *name);
void aa_lex$lxerror(u8 *m);
i64 aa_lex$gethashvalue(u8 *s);
void aa_lex$skiptoeol(void);
static u8 *aa_lex$makestring(u8 *p,i64 length);
void aa_lex$start(void);
void aa_lib$initlib(void);
void aa_lib$genmc(i64 opcode,struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
void aa_lib$genmcstr(i64 opcode,u8 *s);
static struct aa_decls$opndrec *aa_lib$newopnd(i64 mode);
struct aa_decls$opndrec *aa_lib$genxreg(i64 xreg);
struct aa_decls$opndrec *aa_lib$genindex(i64 areg,i64 ireg,i64 scale,struct aa_decls$opndrec *x,i64 size,i64 addrsize);
struct mlib$strbuffer *aa_lib$writemclblock(void);
void aa_lib$gencomment(u8 *s);
struct aa_decls$opndrec *aa_lib$genstrimm(u8 *s);
static u8 *aa_lib$getsizetag(i64 size);
static void aa_lib$writemcl(i64 index,struct aa_lib$mclrec *mcl);
u8 *aa_lib$strmcl(struct aa_lib$mclrec *mcl);
u8 *aa_lib$stropnd(struct aa_decls$opndrec *a,i64 sizeprefix);
static u8 *aa_lib$strdef(struct aa_decls$strec *def);
void aa_lib$setsegment(i64 seg);
static u8 *aa_lib$getsizeprefix(i64 size,i64 enable);
static i64 aa_lib$needsizeprefix(i64 opcode,struct aa_decls$opndrec *a,struct aa_decls$opndrec *b);
struct aa_decls$opndrec *aa_lib$genimm_expr(struct aa_decls$strec *d,i64 value,i64 t,i64 size);
struct aa_decls$opndrec *aa_lib$genint(i64 x,i64 size);
struct aa_decls$opndrec *aa_lib$genlab(struct aa_decls$strec *d,i64 size);
struct aa_decls$opndrec *aa_lib$genmem(struct aa_decls$strec *d,i64 size);
struct aa_decls$opndrec *aa_lib$genreg0(i64 reg,i64 size);
u8 *aa_lib$getfullname(struct aa_decls$strec *d);
u8 *aa_lib$getregname(i64 reg,i64 size);
u8 *aa_lib$xgetregname(i64 reg);
void aa_lib$printst(void *f);
void aa_lib$printstrec(void *f,struct aa_decls$strec *d);
void aa_lib$adddef(struct aa_decls$strec *d);
void aa_lib$addimport(struct aa_decls$strec *d);
void aa_lib$createlabel(struct aa_decls$strec *symptr,i64 symbol);
void aa_lib$createnamedconst(struct aa_decls$strec *symptr,struct aa_decls$opndrec *expr);
void aa_lib$createregalias(struct aa_decls$strec *symptr,i64 regindex,i64 regsize);
void aa_lib$createxregalias(struct aa_decls$strec *symptr,i64 regindex);
void aa_lib$gerror(u8 *mess);
void aa_lib$serror(u8 *mess);
void aa_lib$serror_s(u8 *mess,u8 *param);
static u8 *aa_lib$inttostr(i64 a);
static u8 *aa_lib$realtostr(r64 a);
struct aa_decls$dbuffer *aa_lib$buffercreate(i64 size);
static void aa_lib$bufferexpand(struct aa_decls$dbuffer *a);
void aa_lib$buffercheck(struct aa_decls$dbuffer *a,i64 n);
i64 aa_lib$bufferlength(struct aa_decls$dbuffer *a);
void *aa_lib$bufferelemptr(struct aa_decls$dbuffer *a,i64 offset);
void aa_lib$addbyte(struct aa_decls$dbuffer *a,i64 x);
void aa_lib$addword(struct aa_decls$dbuffer *a,i64 x);
void aa_lib$adddword(struct aa_decls$dbuffer *a,i64 x);
void aa_lib$addqword(struct aa_decls$dbuffer *a,i64 x);
void aa_lib$printmodulesymbols(void *f);
void aa_lib$printimportsymbols(void *f);
void aa_lib$printdupltable(void *f);
void aa_lib$start(void);
void aa_mcxdecls$start(void);
void aa_objdecls$start(void);
void aa_parse$readmodule(i64 moduleno);
void aa_parse$checkundefined(void);
static void aa_parse$checksymbol(i64 symbol);
static void aa_parse$readinstr(void);
static void aa_parse$readcondinstr(i64 opc);
static struct aa_decls$opndrec *aa_parse$readoperand(void);
static struct aa_decls$opndrec *aa_parse$readexpression(void);
static void aa_parse$readterm(void);
static void aa_parse$readreg(i64 *reg,i64 *regsize,i64 *scale);
static struct aa_decls$opndrec *aa_parse$readaddrmode(i64 size);
void aa_parse$start(void);
void aa_tables$start(void);
void aa_writeexe$writeexe(u8 *outfile,i64 dodll);
void aa_writeexe$genexe(u8 *entrypoint,u8 *outfile,i64 dodll);
static void aa_writeexe$loadlibs(void);
void aa_writeexe$initsectiontable(void);
static u8 *aa_writeexe$extractlibname(u8 *name,i64 *libno,i64 moduleno);
static void aa_writeexe$scanst(void);
static void aa_writeexe$relocdata(struct aa_objdecls$sectionrec *s);
static void aa_writeexe$getbaserelocs(struct aa_objdecls$sectionrec *s);
static void aa_writeexe$writerecordx(void *r,i64 length);
static void aa_writeexe$writedosstub(void);
static void aa_writeexe$writepesig(void);
static void aa_writeexe$writepadding(i64 offset);
static void aa_writeexe$writefileheader(void);
static void aa_writeexe$writeoptheader(void);
static void aa_writeexe$writesectionheader(struct aa_objdecls$sectionrec *s);
static void aa_writeexe$writesectiondata(struct aa_objdecls$sectionrec *s);
static void aa_writeexe$getoffsets(void);
static i64 aa_writeexe$getsectionno(i64 segment);
static void aa_writeexe$writeexporttable(byte *pstart);
static i64 aa_writeexe$getexporttablesize(void);
static void aa_writeexe$newbasereloc(i64 addr,i64 reltype);
static void aa_writeexe$scanbaserelocs(void);
static void aa_writeexe$writebasereloctable(byte *pstart);
static void aa_writeexe$sortexports(i64 (*sortindex)[]);
void aa_writeexe$start(void);
void aa_writeobj$writess(u8 *outfile);
static void aa_writeobj$writerecord(void *r,i64 length);
static void aa_writeobj$writerelocs(struct aa_decls$relocrec *r,i64 nrelocs);
static void aa_writeobj$writedata(struct aa_decls$dbuffer *data);
static void aa_writeobj$writesymboltable(void);
static void aa_writeobj$writestringtable(void);
static struct aa_objdecls$imagesymbol *aa_writeobj$makesymbol(u8 *name,i64 namelen,i64 value,i64 sectionno,i64 symtype,i64 storage,i64 naux);
static void aa_writeobj$addsymbol(struct aa_objdecls$imagesymbol *r);
static void aa_writeobj$initsymboltable(u8 *filename);
static struct aa_objdecls$imagesymbol *aa_writeobj$strtoaux(u8 *s);
static struct aa_objdecls$auxsectionrec *aa_writeobj$sectiontoaux(struct aa_decls$dbuffer *data,i64 nrelocs);
static i64 aa_writeobj$addstringentry(u8 *s,i64 length);
static void aa_writeobj$convertsymboltable(void);
static void aa_writeobj$writecoff(u8 *outfile);
void aa_writeobj$start(void);
void msysc$m_init(i64 nargs,u8 *(*args)[],u8 *(*envstrings)[]);
i64 msysc$m_getdotindex(u64 a,i64 i);
u64 msysc$m_setdotindex(u64 a,i64 i,i64 x);
i64 msysc$m_getdotslice(u64 a,i64 i,i64 j);
u64 msysc$m_setdotslice(u64 a,i64 i,i64 j,u64 x);
i64 msysc$m_get_nprocs(void);
i64 msysc$m_get_nexports(void);
u8 *msysc$m_get_procname(i64 n);
void *msysc$m_get_procaddr(i64 n);
void *msysc$m_get_procexport(i64 n);
static void msysc$pushio(void);
void msysc$m_print_startfile(void *dev);
void msysc$m_print_startstr(u8 *s);
void msysc$m_print_startptr(u8 **p);
void msysc$m_print_startcon(void);
void msysc$m_print_setfmt(u8 *format);
void msysc$m_print_end(void);
void msysc$m_print_ptr(void *a,u8 *fmtstyle);
void msysc$m_print_i64(i64 a,u8 *fmtstyle);
void msysc$m_print_u64(u64 a,u8 *fmtstyle);
void msysc$m_print_r64(r64 x,u8 *fmtstyle);
void msysc$m_print_r32(r32 x,u8 *fmtstyle);
void msysc$m_print_c8(i64 a,u8 *fmtstyle);
void msysc$m_print_str(u8 *s,u8 *fmtstyle);
void msysc$m_print_newline(void);
void msysc$m_print_nogap(void);
void msysc$m_print_space(void);
void msysc$printstr(u8 *s);
void msysc$printstr_n(u8 *s,i64 n);
void msysc$printstrn_app(u8 *s,i64 length,void *f);
static u8 *msysc$makezstring(u8 *s,i64 n,u8 *local);
static void msysc$freezstring(u8 *t,i64 n);
static void msysc$printchar(i64 ch);
void msysc$nextfmtchars(i64 lastx);
void msysc$strtofmt(u8 *s,i64 slen,struct msysc$fmtrec *fmt);
static i64 msysc$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt);
static i64 msysc$expandstr(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt);
static i64 msysc$u64tostr(u64 aa,u8 *s,u64 base,i64 sep);
static i64 msysc$i64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt);
static i64 msysc$u64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt);
static i64 msysc$i64mintostr(u8 *s,i64 base,i64 sep);
static i64 msysc$strtostrfmt(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt);
static void msysc$tostr_i64(i64 a,struct msysc$fmtrec *fmt);
static void msysc$tostr_u64(u64 a,struct msysc$fmtrec *fmt);
static void msysc$tostr_r64(r64 x,struct msysc$fmtrec *fmt);
static void msysc$tostr_str(u8 *s,struct msysc$fmtrec *fmt);
static struct msysc$fmtrec *msysc$getfmt(u8 *fmtstyle);
u8 *msysc$strint(i64 a,u8 *fmtstyle);
void msysc$getstrint(i64 a,u8 *dest);
u8 *msysc$strword(u64 a,u8 *fmtstyle);
u8 *msysc$strreal(r64 a,u8 *fmtstyle);
static u8 *msysc$getstr(u8 *s,struct msysc$fmtrec *fmt);
static void msysc$initreadbuffer(void);
void msysc$m_read_conline(void);
void msysc$m_read_fileline(void *f);
void msysc$m_read_strline(u8 *s);
static u8 *msysc$readitem(i64 *itemlength);
i64 msysc$strtoint(u8 *s,i64 length,i64 base);
i64 msysc$m_read_i64(i64 fmt);
r64 msysc$m_read_r64(i64 fmt);
void msysc$m_read_str(u8 *dest,i64 destlen,i64 fmt);
void msysc$readstr(u8 *dest,i64 fmt,i64 destlen);
void msysc$rereadln(void);
void msysc$reread(void);
i64 msysc$valint(u8 *s,i64 fmt);
r64 msysc$valreal(u8 *s);
static void msysc$iconvlcn(u8 *s,i64 n);
static void msysc$iconvucn(u8 *s,i64 n);
static void msysc$convlcstring(u8 *s);
static void msysc$convucstring(u8 *s);
i64 msysc$m_power_i64(i64 n,i64 a);
void msysc$m_intoverflow(void);
void msysc$m_dotindex(u64 i,u64 a);
void msysc$m_dotslice(u64 j,u64 i,u64 a);
void msysc$m_popdotindex(u64 i,u64 *p,u64 x);
void msysc$m_popdotslice(u64 j,u64 i,u64 *p,u64 x);
i64 msysc$m_imin(i64 a,i64 b);
i64 msysc$m_imax(i64 a,i64 b);
r64 msysc$m_sign(r64 x);
r64 msysc$m_tp_i64tor64(i64 a);
i64 msysc$m_tp_r64toi64(r64 x);
i64 msysc$m_tp_reftoi64(void *p);
void *msysc$m_tp_i64toref(i64 a);
void msysc$start(void);
void *mlib$pcm_alloc(i64 n);
void mlib$pcm_free(void *p,i64 n);
void mlib$pcm_freeac(void *p,i64 alloc);
void mlib$pcm_clearmem(void *p,i64 n);
void mlib$pcm_init(void);
i64 mlib$pcm_getac(i64 size);
void *mlib$pcm_newblock(i64 itemsize);
i64 mlib$pcm_round(i64 n);
void *mlib$pcm_allocz(i64 n);
u8 *mlib$pcm_copyheapstring(u8 *s);
u8 *mlib$pcm_copyheapstringn(u8 *s,i64 n);
u8 *mlib$pcm_copyheapblock(u8 *s,i64 length);
void *mlib$allocmem(i64 n);
void *mlib$reallocmem(void *p,i64 n);
void mlib$abortprogram(u8 *s);
i64 mlib$getfilesize(void *handlex);
void mlib$readrandom(void *handlex,byte *mem,i64 offset,i64 size);
i64 mlib$writerandom(void *handlex,byte *mem,i64 offset,i64 size);
i64 mlib$setfilepos(void *file,i64 offset);
i64 mlib$getfilepos(void *file);
byte *mlib$readfile(u8 *filename);
i64 mlib$writefile(u8 *filename,byte *data,i64 size);
i64 mlib$checkfile(u8 *file);
void mlib$readlinen(void *handlex,u8 *buffer,i64 size);
void mlib$iconvlcn(u8 *s,i64 n);
void mlib$iconvucn(u8 *s,i64 n);
u8 *mlib$convlcstring(u8 *s);
u8 *mlib$convucstring(u8 *s);
u8 *mlib$changeext(u8 *s,u8 *newext);
u8 *mlib$extractext(u8 *s,i64 period);
u8 *mlib$extractpath(u8 *s);
u8 *mlib$extractfile(u8 *s);
u8 *mlib$extractbasefile(u8 *s);
u8 *mlib$addext(u8 *s,u8 *newext);
void *mlib$pcm_alloc32(void);
void mlib$pcm_free32(void *p);
void mlib$outbyte(void *f,i64 x);
void mlib$outword16(void *f,u64 x);
void mlib$outword32(void *f,u64 x);
void mlib$outword64(void *f,u64 x);
void mlib$outstring(void *f,u8 *s);
void mlib$outblock(void *f,void *p,i64 n);
i64 mlib$myeof(void *f);
void mlib$strbuffer_add(struct mlib$strbuffer *dest,u8 *s,i64 n);
void mlib$gs_init(struct mlib$strbuffer *dest);
void mlib$gs_free(struct mlib$strbuffer *dest);
void mlib$gs_str(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_char(struct mlib$strbuffer *dest,i64 c);
void mlib$gs_strn(struct mlib$strbuffer *dest,u8 *s,i64 length);
void mlib$gs_strvar(struct mlib$strbuffer *dest,struct mlib$strbuffer *s);
void mlib$gs_strint(struct mlib$strbuffer *dest,i64 a);
void mlib$gs_strln(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_strsp(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_line(struct mlib$strbuffer *dest);
i64 mlib$gs_getcol(struct mlib$strbuffer *dest);
void mlib$gs_leftstr(struct mlib$strbuffer *dest,u8 *s,i64 w,i64 padch);
void mlib$gs_leftint(struct mlib$strbuffer *dest,i64 a,i64 w,i64 padch);
void mlib$gs_padto(struct mlib$strbuffer *dest,i64 col,i64 ch);
void mlib$gs_println(struct mlib$strbuffer *dest,void *f);
i64 mlib$nextcmdparamnew(i64 *paramno,u8 **name,u8 **value,u8 *defext);
static i64 mlib$readnextfileitem(u8 **fileptr,u8 **item);
void mlib$ipadstr(u8 *s,i64 width,u8 *padchar);
u8 *mlib$padstr(u8 *s,i64 width,u8 *padchar);
u8 *mlib$chr(i64 c);
i64 mlib$cmpstring(u8 *s,u8 *t);
i64 mlib$cmpstringn(u8 *s,u8 *t,i64 n);
i64 mlib$eqstring(u8 *s,u8 *t);
i64 mlib$cmpbytes(void *p,void *q,i64 n);
i64 mlib$eqbytes(void *p,void *q,i64 n);
void mlib$mseed(u64 a,u64 b);
u64 mlib$mrandom(void);
i64 mlib$mrandomp(void);
i64 mlib$mrandomint(i64 n);
i64 mlib$mrandomrange(i64 a,i64 b);
r64 mlib$mrandomreal(void);
r64 mlib$mrandomreal1(void);
u8 *mlib$readline(void);
void *mlib$findfunction(u8 *name);
i64 mlib$roundtoblock(i64 n,i64 align);
void *mlib$pcm_allocnfz(i64 n);
void mlib$start(void);
extern void *malloc(u64 $1);
extern void *realloc(void *$1,u64 $2);
extern void free(void *$1);
extern void memset(void *$1,i32 $2,u64 $3);
extern void memcpy(void *$1,void *$2,u64 $3);
extern void memmove(void *$1,void *$2,u64 $3);
extern i32 clock(void);
extern i32 ftell(void *$1);
extern i32 fseek(void *$1,i32 $2,i32 $3);
extern u64 fread(void *$1,u64 $2,u64 $3,void *$4);
extern u64 fwrite(void *$1,u64 $2,u64 $3,void *$4);
extern i32 getc(void *$1);
extern i32 ungetc(i32 $1,void *$2);
extern void *fopen(u8 *a,u8 *b);
extern i32 fclose(void *$1);
extern u8 *fgets(u8 *$1,i64 $2,void *$3);
extern i32 remove(u8 *$1);
extern i32 rename(u8 *$1,u8 *$2);
extern i32 getchar(void);
extern void putchar(i32 $1);
extern void setbuf(void *$1,byte *$2);
extern i64 strlen(u8 *$1);
extern u8 *strcpy(u8 *$1,u8 *$2);
extern i32 strcmp(u8 *$1,u8 *$2);
extern i32 strncmp(u8 *$1,u8 *$2,u64 $3);
extern u64 strncpy(u8 *$1,u8 *$2,u64 $3);
extern i32 memcmp(void *$1,void *$2,u64 $3);
extern u8 *strcat(u8 *$1,u8 *$2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u8 *strstr(u8 *$1,u8 *$2);
extern i64 atol(u8 *$1);
extern i32 atoi(u8 *$1);
extern r64 strtod(u8 *$1,u8 **$2);
extern u8 *_strdup(u8 *$1);
extern i32 puts(u8 *$1);
extern i32 printf(u8 *$1,...);
extern i32 sprintf(u8 *$1,u8 *$2,...);
extern i32 sscanf(u8 *$1,u8 *$2,...);
extern i32 scanf(u8 *$1,...);
extern i32 rand(void);
extern void srand(u32 $1);
extern i32 system(u8 *$1);
extern i32 fgetc(void *$1);
extern i32 fputc(i32 $1,void *$2);
extern i32 fprintf(void *$1,u8 *$2,...);
extern i32 fputs(u8 *$1,void *$2);
extern i32 feof(void *$1);
extern i32 getch(void);
extern i32 _getch(void);
extern i32 kbhit(void);
extern i32 _mkdir(u8 *$1);
extern i32 mkdir(u8 *$1);
extern u8 *strchr(u8 *$1,i32 $2);
extern i32 _setmode(i32 $1,i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1,r64 $2);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern i64 llabs(i64 $1);
extern void qsort(void *$1,u64 $2,u64 $3,void (*$4)(void));
extern i32 __getmainargs(i32 *$1,void *$2,void *$3,i64 $4,void *$5);
void mclib$start(void);
extern void *GetStdHandle(u32 $1);
extern i64 GetConsoleScreenBufferInfo(void *$1,void *$2);
extern i64 SetConsoleCtrlHandler(void (*$1)(void),i64 $2);
extern i64 SetConsoleMode(void *$1,u32 $2);
extern i64 CreateProcessA(u8 *$1,u8 *$2,void *$3,void *$4,i64 $5,u32 $6,void *$7,u8 *$8,void *$9,void *$10);
extern u32 GetLastError(void);
extern u32 WaitForSingleObject(void *$1,u32 $2);
extern i64 GetExitCodeProcess(void *$1,void *$2);
extern i64 CloseHandle(void *$1);
extern i64 GetNumberOfConsoleInputEvents(void *$1,void *$2);
extern i64 FlushConsoleInputBuffer(void *$1);
extern void *LoadLibraryA(u8 *$1);
extern void *GetProcAddress(void *$1,u8 *$2);
extern void *LoadCursorA(void *$1,u8 *$2);
extern u32 RegisterClassExA(void *$1);
extern i64 DefWindowProcA(void *$1,u32 $2,u64 $3,u64 $4);
extern i64 ReadConsoleInputA(void *$1,void *$2,u32 $3,void *$4);
extern void Sleep(u32 $1);
extern u32 GetModuleFileNameA(void *$1,u8 *$2,u32 $3);
extern void ExitProcess(u32 $1);
extern void PostQuitMessage(i32 $1);
extern void MessageBoxA(i32 x,u8 *message,u8 *caption,i32 y);
extern u32 QueryPerformanceCounter(i64 *$1);
extern u32 QueryPerformanceFrequency(i64 *$1);
extern void *CreateFileA(u8 *$1,u32 $2,u32 $3,void *$4,u32 $5,u32 $6,void *$7);
extern u32 GetFileTime(void *$1,void *$2,void *$3,void *$4);
extern void GetSystemTime(struct mwindows$rsystemtime *$1);
extern void GetLocalTime(struct mwindows$rsystemtime *$1);
extern u64 GetTickCount64(void);
extern u32 PeekMessageA(void *$1,void **$2,u32 $3,u32 $4,u32 $5);
extern u8 *GetCommandLineA(void);
extern void *VirtualAlloc(void *$1,u32 $2,u32 $3,u32 $4);
extern u32 VirtualProtect(void *$1,u32 $2,u32 $3,u32 *$4);
void mwindows$os_init(void);
i64 mwindows$os_execwait(u8 *cmdline,i64 newconsole,u8 *workdir);
i64 mwindows$os_execcmd(u8 *cmdline,i64 newconsole);
i64 mwindows$os_getch(void);
i64 mwindows$os_kbhit(void);
u64 mwindows$os_getdllinst(u8 *name);
void *mwindows$os_getdllprocaddr(i64 hinst,u8 *name);
void mwindows$os_initwindows(void);
void mwindows$os_gxregisterclass(u8 *classname);
i64 mwindows$mainwndproc(void *hwnd,u32 message,u64 wparam,u64 lparam);
void mwindows$os_setmesshandler(void *addr);
i64 mwindows$os_getchx(void);
u8 *mwindows$os_getos(void);
i64 mwindows$os_gethostsize(void);
i64 mwindows$os_shellexec(u8 *opc,u8 *file);
void mwindows$os_sleep(i64 a);
void *mwindows$os_getstdin(void);
void *mwindows$os_getstdout(void);
u8 *mwindows$os_gethostname(void);
u8 *mwindows$os_getmpath(void);
i64 mwindows$os_clock(void);
i64 mwindows$os_ticks(void);
i64 mwindows$os_hptimer(void);
i64 mwindows$os_iswindows(void);
void mwindows$os_getsystime(struct mwindows$rsystemtime *tm);
void mwindows$os_peek(void);
byte *mwindows$os_allocexecmem(i64 n);
void mwindows$start(void);
u64 mwindllc$os_calldllfunction(void (*fnaddr)(void),i64 retcode,i64 nargs,i64 (*args)[],byte (*argcodes)[]);
u64 mwindllc$os_pushargs(u64 (*args)[],i64 nargs,i64 nextra,void (*fnaddr)(void),i64 isfloat);
static i64 mwindllc$calldll_cint(void (*fnaddr)(void),i64 (*params)[],i64 nparams);
static i64 mwindllc$calldll_creal(void (*fnaddr)(void),i64 (*params)[],i64 nparams);
void mwindllc$os_dummycall(r64 a,r64 b,r64 c,r64 d);
void mwindllc$start(void);

/* VARS */
static u8 *  cc_cli$modenames[4] = {(byte*)"preprocess_mode",(byte*)"compile_mode",(byte*)"link_mode",(byte*)"run_mode"};
static i64 cc_cli$cc_mode;
static u8 *  cc_cli$linkoption;
static u8 *  cc_cli$destfilename;
static u8 *  cc_cli$destfileext;
static byte cc_cli$fdebugcompiler;
static byte cc_cli$fshowpaths;
static byte cc_cli$fshowheaders;
static byte cc_cli$fwriteheaders;
static byte cc_cli$fgetlib;
static byte cc_cli$fshowinfo;
static byte cc_cli$fstdin;
static byte cc_cli$fstdout;
static byte cc_cli$fmheaders;
static byte cc_cli$fshowlog;
static byte cc_cli$fatfile;
static byte cc_cli$fshowtiming;
static byte cc_cli$fbcclib;
static byte cc_cli$fgendll;
static u8 *  cc_cli$entrypointname;
static u8 *  cc_cli$optionnames[35] = {
    (byte*)"e",
    (byte*)"c",
    (byte*)"s",
    (byte*)"obj",
    (byte*)"exe",
    (byte*)"dll",
    (byte*)"run",
    (byte*)"paths",
    (byte*)"headers",
    (byte*)"stdin",
    (byte*)"stdout",
    (byte*)"i",
    (byte*)"includes",
    (byte*)"time",
    (byte*)"v",
    (byte*)"v2",
    (byte*)"q",
    (byte*)"h",
    (byte*)"help",
    (byte*)"info",
    (byte*)"ext",
    (byte*)"writeheaders",
    (byte*)"old",
    (byte*)"getlib",
    (byte*)"mheaders",
    (byte*)"qheaders",
    (byte*)"auto",
    (byte*)"out",
    (byte*)"at",
    (byte*)"debug",
    (byte*)"bcclib",
    (byte*)"callback",
    (byte*)"entry",
    (byte*)"splicing",
    (byte*)"source"
};
static i64 cc_cli$totallines = (i64)0;
static i64 cc_cli$nstringobjects = (i64)0;
static u8 *  cc_cli$extraparams[128];
static u8 *  cc_cli$extravalues[128];
static i64 cc_cli$nextraparams = (i64)0;
static i64 cc_cli$progstart;
static i64 cc_cli$progend;
static i64 cc_decls$ntypes;
static i64 cc_decls$ntypesreset;
static struct cc_decls$strec *  cc_decls$ttnamedef[10000];
static i64 cc_decls$ttbasetype[10000];
static i64 cc_decls$ttlength[10000];
static byte cc_decls$ttconst[10000];
static byte cc_decls$ttrestrict[10000];
static byte cc_decls$ttvolatile[10000];
static i64 cc_decls$ttusertype[10000];
static i64 cc_decls$tttarget[10000];
static i64 cc_decls$ttreftype[10000];
static i64 cc_decls$ttconsttype[10000];
static i64 cc_decls$ttsize[10000];
static i64 cc_decls$ttbitwidth[10000];
static byte cc_decls$ttisref[10000];
static struct cc_decls$paramrec *  cc_decls$ttparams[10000];
static struct cc_decls$strec *  cc_decls$tttypedef[10000];
static i64 cc_decls$trefchar;
static i64 cc_decls$trefwchar;
static struct cc_decls$modulerec cc_decls$moduletable[2001];
static u8 *  cc_decls$inputfiles[2001];
static u8 *  cc_decls$libfiles[201];
static u8 *  cc_decls$sourcefilenames[2001];
static u8 *  cc_decls$sourcefilepaths[2001];
static u8 *  cc_decls$sourcefiletext[2001];
static i32 cc_decls$sourcefilesizes[2001];
static u8 *  cc_decls$automodulenames[2001];
static i64 cc_decls$nmodules;
static i64 cc_decls$nautomodules;
static i64 cc_decls$nsourcefiles;
static i64 cc_decls$ninputfiles;
static i64 cc_decls$nlibfiles;
static i64 cc_decls$currmoduleno;
static struct cc_decls$modulerec *  cc_decls$currmodule;
static u8 *  cc_decls$searchdirs[20];
static i64 cc_decls$nsearchdirs = (i64)0;
static u8 *  cc_decls$includepaths[20];
static i64 cc_decls$nincludepaths = (i64)0;
static struct cc_decls$strec *  cc_decls$stprogram;
static struct cc_decls$strec *  cc_decls$stmodule;
static void *  cc_decls$logdev;
static i64 cc_decls$logdest = (i64)0;
static i64 cc_decls$optflag = (i64)0;
static struct cc_decls$unitrec *  cc_decls$nullunit;
static i64 cc_decls$fverbose = (i64)0;
static i64 cc_decls$fquiet = (i64)0;
static i64 cc_decls$fshownames = (i64)0;
static i64 cc_decls$fshowincludes = (i64)0;
static i64 cc_decls$fautomodules = (i64)0;
static i64 cc_decls$fmodern = (i64)1;
static i64 cc_decls$foptimise = (i64)0;
static i64 cc_decls$wintarget = (i64)1;
static i64 cc_decls$lintarget = (i64)0;
static i64 cc_decls$nostarget = (i64)0;
static i64 cc_decls$clineno = (i64)0;
static i64 cc_decls$cfileno = (i64)0;
static i64 cc_decls$fastasm = (i64)0;
static i64 cc_decls$fcallback = (i64)0;
static i64 cc_decls$flinesplicing = (i64)0;
static struct cc_decls$tokenrec cc_decls$lx;
static struct cc_decls$tokenrec cc_decls$nextlx;
static i64 cc_decls$debug = (i64)0;
static i64 cc_decls$hstsize = (i64)65536;
static i64 cc_decls$hstmask;
static struct cc_decls$strec *(*cc_decls$hashtable)[];
static i32 cc_decls$blockowner[2101];
static i32 cc_decls$blockcounts[2101];
static i32 cc_decls$blockstack[101];
static i64 cc_decls$currblockno;
static i64 cc_decls$nextblockno;
static i64 cc_decls$blocklevel;
static struct cc_decls$strec *  cc_decls$currproc;
static i64 cc_decls$labelno = (i64)0;
static i64 cc_decls$dointheaders = (i64)1;
static u8 *  cc_decls$dheaderfile = 0;
static i64 cc_decls$structpadding = (i64)1;
static i64 cc_decls$callbackflag = (i64)0;
static i64 cc_decls$slineno;
static i64 cc_decls$sfileno;
static u8 *  cc_decls$oemname = (byte*)"BCC";
static u8 *  cc_decls$mclstr;
static i64 cc_decls$mclstrlen;
static i64 cc_decls$nlookups;
static i64 cc_decls$nclashes;
static i64 cc_decls$nmixed;
static i64 cc_decls$nallprocs;
static i64 cc_blockmcl$naddto;
static i64 cc_blockmcl$naddtox;
static i64 cc_blockmcl$continuestack[64];
static i64 cc_blockmcl$breakstack[64];
static i64 cc_blockmcl$loopindex;
static i64 (*cc_blockmcl$sw_labeltable)[];
static i64 (*cc_blockmcl$sw_valuetable)[];
static i64 cc_blockmcl$sw_lower;
static i64 cc_blockmcl$sw_ncases;
static byte cc_blockmcl$sw_defaultseen;
static i64 cc_blockmcl$sw_defaultlabel;
static i64 cc_blockmcl$sw_breaklabel;
static i64 cc_blockmcl$maxreg = (i64)0;
static struct mlib$strbuffer cc_export$mmbuffer;
static struct mlib$strbuffer *  cc_export$mm = &cc_export$mmbuffer;
static struct cc_libmcl$mclrec *  cc_genasm$currmcl;
static u16 *  cc_genasm$wstringtable[1024];
static i64 cc_genasm$wstringlentable[1024];
static u8 *(*cc_genasm$stringtable)[];
static i64 (*cc_genasm$stringlentable)[];
static r64 (*cc_genasm$realtable)[];
static i64 (*cc_genasm$dinttable)[];
static i64 cc_genasm$stringtablesize;
static i64 cc_genasm$realtablesize;
static i64 cc_genasm$dinttablesize;
static i64 cc_genasm$nwstrings = (i64)0;
static i64 cc_genasm$nstrings = (i64)0;
static i64 cc_genasm$nreals = (i64)0;
static i64 cc_genasm$ndints = (i64)0;
static u8 *  cc_genasm$asmstart;
static u8 *  cc_genasm$asmptr;
static u8 *  cc_genasm$asmend;
static u8 cc_genasm$asmbuffer[20000];
static u8 *  cc_headers$bcclibstr = 
(byte*)";\tbcc support library\r\n\r\n;Offsets in buffer:\r\nkreturn\t= 0\r\nkstack\t= 8\r\nkframe\t= 16\r\n\r\n\tsegment code\r\n$mccsetjmp::\r\n\r\n;on entry to setjmp:\r\n;Dstack\t\tpoints to return address\r\n;D10\t\tpoints to address of buffer to store restore info\r\n;Caller will have subtracted 32 from Dstack, and will add it again on return\r\n\r\n; Store current state\r\n\r\n\tmov [D10+kstack],Dstack\r\n\tmov [D10+kframe],Dframe\r\n\tmov D0,[Dstack]\t\t\t; return address\r\n\tmov [D10+kreturn],D0\r\n\r\n\tmov\tA0,0\r\n\tret\r\n\r\n$mcclongjmp::\r\n\r\n;on entry to longjmp:\r\n;Dstack\t\tpoints to return address\r\n;D10\t\tpoints to address of buffer containing store restore info\r\n;D11\t\thas return value to use\r\n;Caller will have subtracted 32 from Dstack, and will add it again on return\r\n\r\n; Restore state as it was on call to setjmp\r\n\r\n\r\n\tmov Dstack,[D10+kstack]\t\t; restore stack value\r\n\tmov Dframe,[D10+kframe]\t\t; restore frame ptr\r\n\r\n\tmov D0,[D10+kreturn]\t\t; stored return address\r\n\tmov [Dstack+0],D0\t\t\t; replace return address, as it will return elsewhere\r\n\tmov A0,A11\t\t\t\t\t; return value (from 'setjmp', as it will be)\r\n\r\n\tret\r\n\r\n;Float routines for unsigned\r\n;Input passed in D10\r\n;Output in XMM15\r\n\r\nm$ufloat_r64u32::\r\n\tmov D10,D10\t\t\t\t\t; clear top half (already done if value just moved there)\r\n\tcvtsi2sd XMM15,D10\r\n\tret\r\n\r\nm$ufloat_r32u32::\r\n\tmov D10,D10\r\n\tcvtsi2ss XMM15,D10\r\n\tret\r\n\r\nm$ufloat_r64u64::\r\n\tcmp D10,0\r\n\tjl fl1\r\n;number is positive, so can treat like i64\r\n\tcvtsi2sd XMM15,D10\r\n\tret\r\nfl1:\t\t\t\t\t\t;negative value\r\n\tand D10,[mask63]\t\t;clear top bit (subtract 2**63)\r\n\tcvtsi2sd XMM15,D10\r\n\taddsd XMM15,[offset64]\t;(add 2**63 back to result)\r\n\tret\r\n\r\nm$ufloat_r32u64::\r\n\tcmp D10,0\r\n\tjl fl2\r\n;number is positive, so can treat like i64\r\n\tcvtsi2ss XMM15,D10\r\n\tret\r\nfl2:\t\t\t\t\t\t;negative value\r\n\tand D10,[mask63]\t\t;clear top bit (subtract 2**63)\r\n\tcvtsi2ss XMM15,D10\r\n\taddss XMM15,[offset32]\t;(add 2**63 back to result)\r\n\tret\r\n\r\n\tsegment idata\r\nmask63:\r\n\tdq 0x7fffffffffffffff\r\noffset64:\r\n\tdq 9223372036854775808.0\t\t! 2**63 as r64\r\noffset32:\r\n\tdd 9223372036854775808.0\t\t; 2**63 as r32\r\n\r\n\tsegment code\r\n__rdtsc::\r\n!\trdtsc\r\n\tmov eax,eax\r\n\tshl rdx,32\r\n\tor rax,rdx\r\n\tret\r\n\r\n\tsegment zdata\r\ncallbackstack:\r\n\tresb 576\t\t\t!8-level stack\r\n;\tresb 5'120'000\r\n\r\nncallbacks:\r\n\tresb 4\r\n\r\nsegment code\r\n\r\nm$pushcallback::\r\n\tinc dword [ncallbacks]\r\n\tmov A2,[ncallbacks]\r\n\tshl A2,6\t\t\t\t\t!8x8 bytes is size per entry\r\n\tlea D2,[A2+callbackstack]\r\n\r\n\tmov [D2],rbx\r\n\tmov [D2+8],rsi\r\n\tmov [D2+16],rdi\r\n\r\n\tmov [D2+24],r12\r\n\tmov [D2+32],r13\r\n\tmov [D2+40],r14\r\n\tmov [D2+48],r15\r\n\tret\r\n\r\nm$popcallback::\r\n\tmov A2,[ncallbacks]\r\n\tshl A2,6\t\t\t\t\t!8x8 bytes is size per entry\r\n\tlea D2,[A2+callbackstack]\r\n\r\n\tmov rbx,[D2]\r\n\tmov rsi,[D2+8]\r\n\tmov rdi,[D2+16]\r\n\r\n\tmov r12,[D2+24]\r\n\tmov r13,[D2+32]\r\n\tmov r14,[D2+40]\r\n\tmov r15,[D2+48]\r\n\tdec dword [ncallbacks]\r\n\tret\r\n\r\n\r\n";
static u8 *  cc_headers$h_assert = (byte*)"/* Header assert.h */\r\n\r\n//#define assert(x) 0\r\n#define assert(x)\r\n";
static u8 *  cc_headers$h_ctype = (byte*)"/* Header ctype.h */\r\n\r\nint tolower(int);\r\nint toupper(int);\r\nint isalpha(int);\r\nint isdigit(int);\r\nint isspace(int);\r\nint isalnum(int);\r\nint isupper(int);\r\nint islower(int);\r\n\r\nint isxdigit(int);\r\nint iscntrl(int);\r\nint isgraph(int);\r\nint ispunct(int);\r\nint isprint(int);\r\nint __isascii(int);\r\n#define isascii __isascii\r\n\r\nint __toascii(int);\r\n#define toascii __toascii\r\n";
static u8 *  cc_headers$h_errno = (byte*)"/* Header errno.h */\r\n\r\n#ifndef $errno\r\n#define $errno\r\n\r\nextern int* _errno(void);\r\n#define errno (*_errno())\r\n\r\n#define EPERM 1\r\n#define ENOENT 2\r\n#define ESRCH 3\r\n#define EINTR 4\r\n#define EIO 5\r\n#define ENXIO 6\r\n#define E2BIG 7\r\n#define ENOEXEC 8\r\n#define EBADF 9\r\n#define ECHILD 10\r\n#define EAGAIN 11\r\n#define ENOMEM 12\r\n#define EACCES 13\r\n#define EFAULT 14\r\n#define ENOTBLK 15\r\n#define EBUSY 16\r\n#define EEXIST 17\r\n#define EXDEV 18\r\n#define ENODEV 19\r\n#define ENOTDIR 20\r\n#define EISDIR 21\r\n#define EINVAL 22\r\n#define ENFILE 23\r\n#define EMFILE 24\r\n#define ENOTTY 25\r\n#define ETXTBSY 26\r\n#define EFBIG 27\r\n#define ENOSPC 28\r\n#define ESPIPE 29\r\n#define EROFS 30\r\n#define EMLINK 31\r\n#define EPIPE 32\r\n#define EDOM 33\r\n#define ERANGE 34\r\n#define ENOMSG 35\r\n#define EIDRM 36\r\n#define ECHRNG 37\r\n#define EL2NSYNC 38\r\n#define EL3HLT 39\r\n#define EL3RST 40\r\n#define ELNRNG 41\r\n#define EUNATCH 42\r\n#define ENOCSI 43\r\n#define EL2HLT 44\r\n#define EDEADLK 45\r\n#define ENOLCK 46\r\n#define EBADE 50\r\n#define EBADR 51\r\n#define EXFULL 52\r\n#define ENOANO 53\r\n#define EBADRQC 54\r\n#define EBADSLT 55\r\n#define EDEADLOCK 56\r\n#define EBFONT 57\r\n#define ENOSTR 60\r\n#define ENODATA 61\r\n#define ETIME 62\r\n#define ENOSR 63\r\n#define ENONET 64\r\n#define ENOPKG 65\r\n#define EREMOTE 66\r\n#define ENOLINK 67\r\n#define EADV 68\r\n#define ESRMNT 69\r\n#define ECOMM 70\r\n#define EPROTO 71\r\n#define EMULTIHOP 74\r\n#define ELBIN 75\r\n#define EOVERFLOW 76\r\n#define EBADMSG 77\r\n#define ENOTUNIQ 80\r\n#define EBADFD 81\r\n#define EREMCHG 82\r\n#define ELIBACC 83\r\n#define ELIBBAD 84\r\n#define ELIBSCN 85\r\n#define ELIBMAX 86\r\n#define ELIBEXEC 87\r\n#define ENOSYS 88\r\n#define ENMFILE 89\r\n#define ENOTEMPTY 90\r\n#define ENAMETOOLONG 91\r\n#define EILSEQ 92\r\n#define __ELASTERROR 2000\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_fenv = (byte*)"/* Header fenv.h */\r\n\r\nint feclearexcept(int);\r\nint fetestexcept(int);\r\n\r\n#define FE_INVALID 1\r\n#define FE_DENORMAL 2\r\n#define FE_INEXACT 32\r\n#define FE_DIVBYZERO 4 \r\n#define FE_OVERFLOW 8\r\n#define FE_UNDERFLOW 16\r\n#define FE_STACKFAULT 64\r\n#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)\r\n";
static u8 *  cc_headers$h_float = (byte*)"/* Header float.h */\r\n\r\n//#define DBL_MAX_10_EXP 308\r\n//#define DBL_MANT_DIG 53\r\n\r\n#define FLT_RADIX 2\r\n\r\n#define FLT_DIG 6\r\n#define FLT_MIN_EXP -125\r\n#define FLT_MIN 1.17549435E-38F // decimal constant\r\n#define FLT_MIN 0X1P-126F // hex constant\r\n#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant\r\n#define FLT_TRUE_MIN 0X1P-149F // hex constant\r\n#define FLT_HAS_SUBNORM 1\r\n#define FLT_MIN_10_EXP -37\r\n#define FLT_MAX_EXP +128\r\n#define FLT_MAX 3.40282347E+38F // decimal constant\r\n#define FLT_MAX 0X1.fffffeP127F // hex constant\r\n#define FLT_MAX_10_EXP +38\r\n#define FLT_EPSILON 1.19209290e-07F\r\n#define FLT_MANT_DIG 23\r\n\r\n#define DBL_MANT_DIG 53\r\n#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant\r\n//#define DBL_EPSILON 0X1P-52 // hex constant\r\n#define DBL_DECIMAL_DIG 17\r\n#define DBL_DIG 15\r\n#define DBL_MIN_EXP -1021\r\n#define DBL_MIN 2.2250738585072014E-308 // decimal constant\r\n//#define DBL_MIN 0X1P-1022 // hex constant\r\n#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant\r\n//#define DBL_TRUE_MIN 0X1P-1074 // hex constant\r\n#define DBL_HAS_SUBNORM 1\r\n#define DBL_MIN_10_EXP -307\r\n#define DBL_MAX_EXP +1024\r\n#define DBL_MAX 1.7976931348623157E+308 // decimal constant\r\n//#define DBL_MAX 0X1.fffffffffffffP1023 // h\r\n#define DBL_MAX_10_EXP +308\r\n\r\n#define LDBL_MIN DBL_MIN\r\n#define LDBL_MAX DBL_MAX\r\n#define LDBL_EPSILON 2.2204460492503131E-16\r\n#define LDBL_MANT_DIG 53\r\n#define LDBL_MIN_EXP -1021\r\n#define LDBL_MAX_EXP +1024\r\n\r\nint     _isnan(double);\r\n#define isnan _isnan\r\n";
static u8 *  cc_headers$h_inttypes = (byte*)"/* Header inttypes.h */\r\n\r\n#include <stdint.h>\r\n\r\n/* fprintf macros for signed types */\r\n#define PRId8 \"d\"\r\n#define PRId16 \"d\"\r\n#define PRId32 \"d\"\r\n#define PRId64 \"I64d\"\r\n\r\n#define PRIdLEAST8 \"d\"\r\n#define PRIdLEAST16 \"d\"\r\n#define PRIdLEAST32 \"d\"\r\n#define PRIdLEAST64 \"I64d\"\r\n\r\n#define PRIdFAST8 \"d\"\r\n#define PRIdFAST16 \"d\"\r\n#define PRIdFAST32 \"d\"\r\n#define PRIdFAST64 \"I64d\"\r\n\r\n#define PRIdMAX \"I64d\"\r\n\r\n#define PRIi8 \"i\"\r\n#define PRIi16 \"i\"\r\n#define PRIi32 \"i\"\r\n#define PRIi64 \"I64i\"\r\n\r\n#define PRIiLEAST8 \"i\"\r\n#define PRIiLEAST16 \"i\"\r\n#define PRIiLEAST32 \"i\"\r\n#define PRIiLEAST64 \"I64i\"\r\n\r\n#define PRIiFAST8 \"i\"\r\n#define PRIiFAST16 \"i\"\r\n#define PRIiFAST32 \"i\"\r\n#define PRIiFAST64 \"I64i\"\r\n\r\n#define PRIiMAX \"I64i\"\r\n\r\n#define PRIo8 \"o\"\r\n#define PRIo16 \"o\"\r\n#define PRIo32 \"o\"\r\n#define PRIo64 \"I64o\"\r\n\r\n#define PRIoLEAST8 \"o\"\r\n#define PRIoLEAST16 \"o\"\r\n#define PRIoLEAST32 \"o\"\r\n#define PRIoLEAST64 \"I64o\"\r\n\r\n#define PRIoFAST8 \"o\"\r\n#define PRIoFAST16 \"o\"\r\n#define PRIoFAST32 \"o\"\r\n#define PRIoFAST64 \"I64o\"\r\n\r\n#define PRIoMAX \"I64o\"\r\n\r\n/* fprintf macros for unsigned types */\r\n#define PRIu8 \"u\"\r\n#define PRIu16 \"u\"\r\n#define PRIu32 \"u\"\r\n#define PRIu64 \"I64u\"\r\n\r\n\r\n#define PRIuLEAST8 \"u\"\r\n#define PRIuLEAST16 \"u\"\r\n#define PRIuLEAST32 \"u\"\r\n#define PRIuLEAST64 \"I64u\"\r\n\r\n#define PRIuFAST8 \"u\"\r\n#define PRIuFAST16 \"u\"\r\n#define PRIuFAST32 \"u\"\r\n#define PRIuFAST64 \"I64u\"\r\n\r\n#define PRIuMAX \"I64u\"\r\n\r\n#define PRIx8 \"x\"\r\n#define PRIx16 \"x\"\r\n#define PRIx32 \"x\"\r\n#define PRIx64 \"I64x\"\r\n\r\n#define PRIxLEAST8 \"x\"\r\n#define PRIxLEAST16 \"x\"\r\n#define PRIxLEAST32 \"x\"\r\n#define PRIxLEAST64 \"I64x\"\r\n\r\n#define PRIxFAST8 \"x\"\r\n#define PRIxFAST16 \"x\"\r\n#define PRIxFAST32 \"x\"\r\n#define PRIxFAST64 \"I64x\"\r\n\r\n#define PRIxMAX \"I64x\"\r\n\r\n#define PRIX8 \"X\"\r\n#define PRIX16 \"X\"\r\n#define PRIX32 \"X\"\r\n#define PRIX64 \"I64X\"\r\n\r\n#define PRIXLEAST8 \"X\"\r\n#define PRIXLEAST16 \"X\"\r\n#define PRIXLEAST32 \"X\"\r\n#define PRIXLEAST64 \"I64X\"\r\n\r\n#define PRIXFAST8 \"X\"\r\n#define PRIXFAST16 \"X\"\r\n#define PRIXFAST32 \"X\"\r\n#define PRIXFAST64 \"I64X\"\r\n\r\n#define PRIXMAX \"I64X\"\r\n\r\n";
static u8 *  cc_headers$h_stdint = (byte*)"/* Header stdint.h */\r\n\r\n#ifndef $stdint\r\n#define $stdint\r\n\r\ntypedef signed char int8_t;\r\ntypedef short int16_t;\r\ntypedef int int32_t;\r\ntypedef long long int int64_t;\r\n\r\ntypedef unsigned char uint8_t;\r\ntypedef unsigned short uint16_t;\r\ntypedef unsigned int uint32_t;\r\ntypedef unsigned long long int uint64_t;\r\n\r\ntypedef long long int intptr_t;\r\ntypedef unsigned long long int uintptr_t;\r\ntypedef long long intmax_t;\r\ntypedef unsigned long long uintmax_t;\r\n\r\ntypedef char int_least8_t;\r\ntypedef unsigned char uint_least8_t;\r\ntypedef short int_least16_t;\r\ntypedef unsigned short uint_least16_t;\r\ntypedef int int_least32_t;\r\ntypedef unsigned int uint_least32_t;\r\ntypedef long long int_least64_t;\r\ntypedef unsigned long long uint_least64_t;\r\n\r\n#define INTMAX_C(a) (a##LL)\r\n#define UINTMAX_C(a) (a##ULL)\r\n\r\ntypedef char int_fast8_t;\r\ntypedef unsigned char uint_fast8_t;\r\ntypedef short int_fast16_t;\r\ntypedef unsigned short uint_fast16_t;\r\ntypedef int int_fast32_t;\r\ntypedef unsigned int uint_fast32_t;\r\ntypedef long long int_fast64_t;\r\ntypedef unsigned long long uint_fast64_t;\r\n\r\n\r\n#define INT8_MIN -128\r\n#define INT8_MAX 127\r\n#define INT16_MIN -32768\r\n#define INT16_MAX 32767\r\n#define INT32_MIN 0x80000000\r\n#define INT32_MAX 0x7FFFFFFF\r\n#define INT64_MIN 0x8000000000000000\r\n#define INT64_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define UINT8_MAX 255\r\n#define UINT16_MAX 65535\r\n#define UINT32_MAX 0xFFFFFFFF\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define INTPTR_MIN 0x8000000000000000\r\n#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF\r\n#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n#define SIZE_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define PTRDIFF_MIN 0x8000000000000000\r\n#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define WCHAR_MIN 0\r\n#define WCHAR_MAX 65535\r\n\r\n#define WINT_MIN 0\r\n#define WINT_MAX 65535\r\n\r\n#define UINT64_C(x) (x##ull)\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_limits = (byte*)"/* Header limits.h */\n\n#define CHAR_BIT 8\n\n#define CHAR_MIN 0\n#define CHAR_MAX 255\n\n#define UCHAR_MIN 0\n#define UCHAR_MAX 255\n\n#define SCHAR_MIN -128\n#define SCHAR_MAX 127\n\n#define SHRT_MIN -32768\n#define SHRT_MAX 32767\n\n#define USHRT_MIN 0\n#define USHRT_MAX 65535\n\n#define INT_MIN -2147483648\n#define INT_MAX  2147483647\n\n#define UINT_MIN 0\n#define UINT_MAX 4294967295\n\n#define LONG_MIN -2147483648\n#define LONG_MAX  2147483647\n\n#define ULONG_MIN 0\n#define ULONG_MAX 4294967295\n\n#define LLONG_MIN -9223372036854775808LL\n#define LLONG_MAX  9223372036854775807LL\n\n#define ULLONG_MIN 0\n#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL\n\n#define SIZE_MAX ULLONG_MAX\n";
static u8 *  cc_headers$h_locale = (byte*)"/* Header locale.h */\r\n\r\n#ifndef $locale\r\n#define $locale\r\n\r\n#define LC_ALL 0\r\n#define LC_COLLATE 1\r\n#define LC_CTYPE 2\r\n#define LC_MONETARY 3\r\n#define LC_NUMERIC 4\r\n#define LC_TIME 5\r\n\r\nstruct lconv {\r\n\tchar *decimal_point;\r\n\tchar *thousands_sep;\r\n\tchar *grouping;\r\n\tchar *int_curr_symbol;\r\n\tchar *currency_symbol;\r\n\tchar *mon_decimal_point;\r\n\tchar *mon_thousands_sep;\r\n\tchar *mon_grouping;\r\n\tchar *positive_sign;\r\n\tchar *negative_sign;\r\n\tchar int_frac_digits;\r\n\tchar frac_digits;\r\n\tchar p_cs_precedes;\r\n\tchar p_sep_by_space;\r\n\tchar n_cs_precedes;\r\n\tchar n_sep_by_space;\r\n\tchar p_sign_posn;\r\n\tchar n_sign_posn;\r\n};\r\nchar *setlocale(int category, const char *locale);\r\n\r\nstruct lconv *localeconv(void);\r\n\r\nchar * setlocale(int,const char *);\r\n#endif\r\n";
static u8 *  cc_headers$h__ansi = (byte*)"/* Header _ansi.h */\r\n";
static u8 *  cc_headers$h_math = 
(byte*)"/* Header math.h */\n\n#define HUGE_VAL 1.7976931348623156e+308\n\ndouble floor(double);\ndouble ceil(double);\ndouble sqrt(double);\ndouble sin(double);\ndouble cos(double);\ndouble tan(double);\ndouble fmod(double,double);\ndouble asin(double);\ndouble acos(double);\ndouble atan(double);\ndouble log(double);\ndouble log10(double);\ndouble exp(double);\ndouble modf(double,double*);\ndouble atan2(double,double);\ndouble pow(double,double);\ndouble fabs(double);\ndouble sinh(double);\ndouble cosh(double);\ndouble tanh(double);\ndouble frexp(double,int*);\ndouble ldexp(double,int);\nint isnan(double);\n\n#define ldexpl ldexp\n\nfloat sinf(float);\nfloat cosf(float);\nfloat tanf(float);\n\nfloat sqrtf(float);\nfloat acosf(float);\nfloat atan2f(float,float);\nfloat ceilf(float);\n\ndouble acosh (double);\nlong double acoshl(long double);\nlong double acoshl(long double);\nfloat acoshf(float);\n\ndouble asinh (double);\nlong double asinhl(long double);\nlong double sinhl(long double);\nfloat asinhf(float);\n\ndouble atanh(double);\nlong double atanhl(long double);\nfloat atanhf(float);\n\nlong double expm1l(long double);\ndouble expm1(double);\nfloat expm1f(float);\ndouble _expm1i(int);\n\ndouble cbrt(double);\nlong double cbrtl(long double);\nfloat cbrtf(float);\n\ndouble trunc(double x);\nlong double truncl(long double);\nfloat truncf(float);\n\ndouble round(double);\nfloat roundf(float);\nlong double roundl(long double);\ndouble _roundi(int);\n\nlong double fminl(long double,long double);\nfloat fminf(float ,float);\ndouble fmin(double,double);\n\n//float fabsf(float);\n#define fabsf fabs\n\ndouble lgamma (double);\nlong double lgammal(long double);\nfloat lgammaf(float);\n\nlong double tgammal(long double);\ndouble tgamma(double);\nfloat tgammaf(float);\n\ndouble log1p(double);\nlong double log1pl(long double);\nfloat log1pf(float);\n\nlong double log10l(long double);\nfloat log10f(float);\ndouble _log10i(int);\ndouble log10(double);\n\ndouble erf(double);\nlong double erfl(long double);\nfloat erff(float);\n\ndouble hypot (double, double);\ndouble _hypot(double,double);\nlong double hypotl(long double,long double);\nfloat hypotf(float,float);\n\ndouble nextafter (double, double);\nlong double nextafterl(long double,long double);\nfloat nextafterf(float,float);\n\ndouble nexttoward(double,long double);\nlong double nexttowardl(long double,long double);\nfloat nexttowardf(float,long double);\n\ndouble erfc(double);\nlong double erfcl(long double);\nfloat erfcf(float);\n\nint _finite(double);\n#define finite _finite\n\nfloat floorf(float);\n\ndouble _copysign(double,double);\n#define copysign _copysign\n\nlong double fmaxl(long double,long double);\ndouble fmax(double,double);\nfloat fmaxf(float,float);\nfloat fmodf(float,float);\n\n//long double exp2l(long double);\ndouble exp2(double);\nfloat exp2f(float);\n\n//double log2(double);\n#define log2(x) (log(x)*1.442695041)\n\n#define M_PI 3.1415926535897932384625433\n#define M_PI_2 (M_PI/2.0)\n#define M_2_PI 0.63661977236758134308\n\nint isinf(double);\n\nint _finite(double);\n\n#define isfinite _finite\n\nint isfinitef(float);\nint isfinitel(long double);\n\n";
static u8 *  cc_headers$h_setjmp = (byte*)"/* Header setjmp.h */\r\n\r\n\r\n#ifndef $setjmp\r\n#define $setjmp 1\r\n\r\ntypedef int jmp_buf[128];\r\n\r\n//void longjmp(char*, int);\r\n\r\n//void $mcclongjmp(char*, int);\r\nvoid $mcclongjmp(jmp_buf, int);\r\n\r\n//int $mccsetjmp(char*);\r\nint $mccsetjmp(jmp_buf);\r\n\r\n\r\n//int\t_setjmp(char*);\r\n//int\tsetjmp(char*);\r\n\r\n#define setjmp $mccsetjmp\r\n#define longjmp $mcclongjmp\r\n\r\n#endif\r\n\r\n";
static u8 *  cc_headers$h_signal = (byte*)"/* Header signal.h */\r\n\r\n#define SIGINT    2\r\n#define SIGILL    4\r\n#define SIGFPE    8\r\n#define SIGSEGV  11\r\n#define SIGTERM  15\r\n#define SIGBREAK 21\r\n#define SIGABRT  22\r\n\r\n#define SIG_DFL (void (*)(int))0\r\n#define SIG_IGN (void (*)(int))1\r\n#define SIG_SGE (void (*)(int))3\r\n#define SIG_ACK (void (*)(int))4\r\n\r\n#define SIG_ERR (void (*)(int))-1\r\n\r\nextern void (*signal(int, void (*)(int)))(int);\r\n\r\nextern int raise(int);\r\n\r\n\r\ntypedef int sig_atomic_t;\r\n";
static u8 *  cc_headers$h_stdarg = (byte*)"/* Header stdarg.h */\r\n\r\n#ifndef $STDARG\r\n #define $STDARG\r\n\r\n//coded for x64 target as used by mcc (with first four params also on stack)\r\n\r\n typedef char *\tva_list;\r\n #define va_start(ap,v) ap=((va_list)&v+8)\r\n #define va_arg(ap,t) *(t*)((ap+=8)-8)\r\n #define va_copy(dest,src) (dest=src)\r\n #define va_end(ap)\t( ap = (va_list)0 )\r\n#endif\r\n";
static u8 *  cc_headers$h_stdbool = (byte*)"/* Header stdbool.h */\r\n\r\n#define bool unsigned char\r\n#define true 1\r\n#define false 0\r\n\r\n\r\n";
static u8 *  cc_headers$h_stddef = (byte*)"/* Header stddef.h */\r\n\r\n#ifndef $stddef\r\n#define $stddef\r\n\r\ntypedef signed long long int ssize_t;\r\ntypedef unsigned long long int size_t;\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\n#define NULL ((void*)0)\r\n\r\n#define offsetof(a,b) (size_t) &( ((a*)0) -> b)\r\n\r\ntypedef long long int ptrdiff_t;\r\n\r\n#endif // stddef\r\n";
static u8 *  cc_headers$h_stdio = 
(byte*)"/* Header stdio.h */\r\n\r\n#ifndef $stdio\r\n#define $stdio 1\r\n\r\n#define __attribute__(x)\r\n\r\n#ifndef $valist\r\n\ttypedef char* va_list;\r\n\t#define $valist\r\n#endif\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long long int fpos_t;\r\n\r\n#define SEEK_SET 0\r\n#define SEEK_CUR 1\r\n#define SEEK_END 2\r\n\r\n#define\tSTDIN_FILENO\t0\r\n#define\tSTDOUT_FILENO\t1\r\n#define\tSTDERR_FILENO\t2\r\n\r\n#define EOF (-1)\r\n#define FILENAME_MAX 260\r\n\r\n#define L_tmpnam 10\r\n\r\ntypedef struct {\r\n\tchar *_ptr;\r\n\tint   _cnt;\r\n\tchar *_base;\r\n\tint   _flag;\r\n\tint   _file;\r\n\tint   _charbuf;\r\n\tint   _bufsiz;\r\n\tchar *_tmpfname;\r\n} FILE;\r\n\r\nextern char* __iob_func(void);\r\n\r\n#define stdin ((FILE*)(__iob_func()))\r\n#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))\r\n#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))\r\n\r\n#define _IOREAD 0x0001\r\n#define _IOWRT 0x0002\r\n\r\n#define _IOFBF 0x0000\r\n#define _IOLBF 0x0040\r\n#define _IONBF 0x0004\r\n\r\n#define _IOMYBUF 0x0008\r\n#define _IOEOF 0x0010\r\n#define _IOERR 0x0020\r\n#define _IOSTRG 0x0040\r\n#define _IORW 0x0080\r\n\r\n#define BUFSIZ 512\r\n\r\nFILE* fopen(const char*, const char*);\r\nint fclose(FILE*);\r\nlong ftell(FILE*);\r\nlong long int _ftelli64(FILE*);\r\nint fseek(FILE*,long,int);\r\nint _fseeki64(FILE*,long long int,int);\r\n\r\nsize_t fread(void*, size_t, size_t, FILE*);\r\nsize_t fwrite(const void*, size_t, size_t, FILE*);\r\nint remove(const char*);\r\nint rename(const char *,const char *);\r\nFILE* freopen(const char*, const char*, FILE*);\r\nFILE* _wfopen(const wchar_t*,const wchar_t *);\r\n\r\nint printf(const char*, ...);\r\nint sprintf(char*,const char*, ...);\r\nint fprintf(FILE*,const char*, ...);\r\nint sscanf(const char*, const char*, ...);\r\nint scanf(const char*, ...);\r\nint fscanf(FILE *,const char *, ...);\r\nint _snprintf(char *,size_t,const char*,...);\r\n#define snprintf _snprintf\r\nint _vsnprintf(char*, size_t, const char*, va_list);\r\nint vsnprintf(char*,size_t,const char*,va_list);\r\nint vsprintf(char*, const char*, va_list);\r\nint _wremove(const wchar_t*);\r\nint _wrename(const wchar_t*,const wchar_t*);\r\n\r\ntypedef char* va_list;\r\n\r\nint vfprintf(FILE*, const char*, va_list);\r\nint vprintf(const char*, va_list);\r\n\r\nint puts(const char*);\r\nchar* fgets(char*, int, FILE*);\r\nint fputs(const char*, FILE*);\r\nint fgetc(FILE*);\r\nint fputc(int, FILE*);\r\nint ungetc(int, FILE*);\r\nint getchar(void);\r\nint putchar(int);\r\nint fflush(FILE *);\r\nint getc(FILE *);\r\nint putc(int, FILE *);\r\n\r\nint feof(FILE*);\r\nint ferror(FILE*);\r\nvoid clearerr(FILE*);\r\n\r\nint fileno(FILE*);\r\nint _fileno(FILE*);\r\nint setvbuf(FILE*,char*,int,size_t);\r\nFILE* _popen(const char*, const char*);\r\nint _pclose(FILE*);\r\nint _unlink(const char *);\r\n#define unlink _unlink;\r\nFILE* _fdopen(int, const char *);\r\n#define fdopen _fdopen\r\nint fgetpos(FILE*, fpos_t*);\r\nint fsetpos(FILE*, const fpos_t*);\r\nvoid perror(char*);\r\nvoid setbuf(FILE*, char*);\r\n\r\nvoid rewind(FILE*);\r\n\r\nFILE* tmpfile(void);\r\n\r\nchar* tmpnam(char*);\r\nwchar_t getwc(FILE *);\r\n\r\nextern void* _wenviron;\r\n\r\n#endif\r\n\r\n";
static u8 *  cc_headers$h_stdlib = (byte*)"/* Header stdlib.h */\n\n#ifndef $stdlib\n#define $stdlib 1\n\n#include <stddef.h>\n\n#define EXIT_FAILURE 1\n#define EXIT_SUCCESS 0\n\n#define RAND_MAX 32767\n\nvoid* malloc(size_t);\nvoid* realloc(void*, size_t);\nvoid* calloc(size_t, size_t);\n\nvoid free(void*);\n\nvoid exit(int);\n\nint system(const char*);\nint _wsystem(const wchar_t*);\n\nint abs(int);\nlong labs(long);\nlong long llabs(long);\nint rand(void);\nvoid srand(unsigned int);\nint atoi(const char*);\nlong atol(const char*);\nlong long atoll(const char*);\nlong long atoi64(const char*);\ndouble atof(const char *);\nint\tatexit(void (*)(void));\nchar *_itoa(int,char *,int);\n\n#define itoa _itoa\n\nvoid qsort(void*, size_t, size_t, int (*)(void*, void*));\n\ntypedef struct {\n\tlong long int quot;\n\tlong long int rem;\n} lldiv_t;\n\nlldiv_t lldiv(long long int, long long int);\n\nchar* getenv(const char*);\nwchar_t* _wgetenv(const wchar_t*);\nint _wputenv(const wchar_t*);\n\n\ndouble strtod(const char*, char**);\n\n//float strtof(const char *, char**);\n#define strtof strtod\n\nlong double strtold(const char*, char**);\nvoid abort(void);\nlong int strtol(const char*, char**, int);\n\nlong double strtold(const char *,char **);\n\nlong long int _strtoi64(const char *,char **,int);\n#define strtoll _strtoi64\n\nunsigned long long int _strtoui64(const char *,char **,int);\n\nunsigned long long int _strtoui64(const char*, char**, int);\n#define strtoull _strtoui64\nunsigned long strtoul(const char*, char**, int);\n\nsize_t _msize(void *);\n#define msize _msize\n\nvoid* bsearch(const void *,const void *, size_t, size_t,\n\t\tint (*_compar)(const void *,const void *));\n\n\n#endif\n";
static u8 *  cc_headers$h__syslist = (byte*)"/* Header _syslist.h */\r\n";
static u8 *  cc_headers$h_string = (byte*)"/* Header string.h */\r\n\r\n#include <stddef.h>\r\n\r\nvoid* memcpy(void*, const void*, size_t);\r\nvoid* memmove(const void*, const void*, size_t);\r\nvoid* memset(void*, int, size_t);\r\nint memcmp(const void*, const void*, size_t);\r\nvoid* memchr(const void *, int, size_t);\r\n\r\nsize_t strlen(const char*);\r\nchar* strcpy(char*, const char*);\r\nchar* strncpy(char*, const char*, size_t);\r\nchar* strcat(char*, const char*);\r\nint strcmp(const char*, const char*);\r\nint strncmp(const char*, const char*, size_t);\r\nchar* strchr(const char*, int);\r\nchar* strstr(const char*, const char*);\r\nchar* strrchr(const char*, int);\r\nint _stricmp(const char*, const char*);\r\n#define stricmp _stricmp\r\n\r\nint _strnicmp(const char*, const char*, size_t);\r\n#define strnicmp _strnicmp\r\nchar* strncat(char*, const char*, size_t);\r\nchar* strtok(char*, const char*);\r\n\r\nsize_t strcspn(const char*, const char*);\r\nsize_t strspn(const char*, const char*);\r\nint strcoll(const char *, const char *);\r\n\r\nunsigned long strtoul(const char*, char**, int);\r\n\r\nchar* strerror(int);\r\nchar* strpbrk(const char*, const char*);\r\nsize_t strxfrm(char*, const char *, size_t);\r\n\r\nchar* _strupr(char*);\r\nchar* _strlwr(char*);\r\n#define strupr _strupr\r\n#define strlwr _strlwr\r\n\r\nchar*strnupr(char*,size_t);\r\nchar*strnlwr(char*,size_t);\r\nint strtrim(char*);\r\nchar*strrev(char*);\r\n\r\nchar* _strdup(const char*);\r\n#define strdup _strdup\r\n\r\nint _wcsicmp(const wchar_t *,const wchar_t *);\r\n\r\nwchar_t *wcspbrk(const wchar_t*,const wchar_t*);\r\n\r\nsize_t wcslen(const wchar_t*);\r\n";
static u8 *  cc_headers$h_time = (byte*)"/* Header time.h */\r\n\r\n#ifndef $time\r\n#define $time\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long clock_t;\r\nclock_t clock(void);\r\n\r\n//typedef long time_t;\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\ntypedef long long int time_t;\r\n#endif\r\n\r\nstruct tm\r\n{\r\n  int\ttm_sec;\r\n  int\ttm_min;\r\n  int\ttm_hour;\r\n  int\ttm_mday;\r\n  int\ttm_mon;\r\n  int\ttm_year;\r\n  int\ttm_wday;\r\n  int\ttm_yday;\r\n  int\ttm_isdst;\r\n};\r\n\r\n//struct tm *localtime(time_t*);\r\nstruct tm* _localtime32(time_t*);\r\n#define localtime _localtime32\r\n\r\ntime_t _time64(time_t *_timer);\r\n#define time _time64\r\n\r\n#define CLOCKS_PER_SEC 1000\r\n\r\nstruct tm *gmtime(const time_t*);\r\nsize_t strftime(char *, size_t, const char *, const struct tm *);\r\ntime_t mktime(struct tm *);\r\ndouble difftime(time_t, time_t);\r\n\r\nchar* asctime(const struct tm*);\r\n//char* ctime(const time_t *_time);\r\nchar* _ctime64(const time_t *_time);\r\n#define ctime _ctime64\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_utime = (byte*)"/* utime.h header */\r\n\r\n#include <sys/utime.h>\r\n";
static u8 *  cc_headers$h_unistd = (byte*)"/* unistd.h header */\r\n\r\nunsigned int _sleep(unsigned int);\r\n#define sleep _sleep\r\n\r\n#define alarm(x) {puts(\"ALARM\"); exit(1);}\r\n\r\nint _write(int,void*,unsigned int);\r\n#define write _write\r\n\r\nint _close(int);\r\n#define close _close\r\n";
static u8 *  cc_headers$h_safelib = (byte*)"/* Header safelib.h */\r\n";
static u8 *  cc_headers$h_wchar = (byte*)"/* Header wchar.h */\r\n\r\n#include <stddef.h>\r\n\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wint_t;\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\nsize_t wcslen(const wchar_t*);\r\nwchar_t* wcscpy(wchar_t*,const wchar_t*);\r\n//wchar_t* _wgetenv(constwchar_t*);\r\nwchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);\r\nwchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);\r\n\r\nwchar_t* wcschr(wchar_t*,wchar_t);\r\nwchar_t* wcsstr(const wchar_t*,const wchar_t*);\r\n\r\n\r\nint wcscmp(const wchar_t*,const wchar_t*);\r\ntypedef long _off_t;\r\n";
static u8 *  cc_headers$h_wctype = (byte*)"/* Header wctype.h */\r\n";
static u8 *  cc_headers$h_systypes = (byte*)"/* types.h */\r\n#ifndef $systypes\r\n#define $systypes 1\r\n\r\ntypedef long int off_t;\r\ntypedef long int ino_t;\r\ntypedef unsigned int dev_t;\r\n\r\ntypedef long long time_t;\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_sysstat = 
(byte*)"/* stat.h */\r\n\r\n#ifndef $sysstat\r\n#define $sysstat\r\n\r\n#include <stddef.h>\r\n\r\nstruct _stat {\r\n\tunsigned int\tst_dev;\r\n\tunsigned short\tst_ino;\r\n\tunsigned short\tst_mode;\r\n\tshort\t\t\tst_nlink;\r\n\tshort\t\t\tst_uid;\r\n\tshort\t\t\tst_gid;\r\n\tunsigned long\tst_rdev;\r\n\tunsigned int\tst_size;\r\n\tunsigned long long int\tst_atime;\r\n\tunsigned long long int\tst_mtime;\r\n\tunsigned long long int\tst_ctime;\r\n};\r\n\r\n#define stat _stat\r\n#define _stati64 _stat\r\n\r\n#define _S_IFMT 0xF000\r\n#define _S_IFDIR 0x4000\r\n#define _S_IFCHR 0x2000\r\n#define _S_IFIFO 0x1000\r\n#define _S_IFREG 0x8000\r\n#define _S_IREAD 0x0100\r\n#define _S_IWRITE 0x0080\r\n#define _S_IEXEC 0x0040\r\n\r\n#define S_IFMT 0xF000\r\n#define S_IFDIR 0x4000\r\n#define S_IFCHR 0x2000\r\n#define S_IFIFO 0x1000\r\n#define S_IFREG 0x8000\r\n#define S_IREAD 0x0100\r\n#define S_IWRITE 0x0080\r\n#define S_IEXEC 0x0040\r\n\r\n#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)\r\n#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)\r\n#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)\r\n#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)\r\n\r\n\r\n#define\t_S_IRWXU\t(_S_IREAD | _S_IWRITE | _S_IEXEC)\r\n#define\t_S_IXUSR\t_S_IEXEC\r\n#define\t_S_IWUSR\t_S_IWRITE\r\n\r\n#define\tS_IRWXU\t\t_S_IRWXU\r\n#define\tS_IXUSR\t\t_S_IXUSR\r\n#define\tS_IWUSR\t\t_S_IWUSR\r\n#define\tS_IRUSR\t\t_S_IRUSR\r\n#define\t_S_IRUSR\t_S_IREAD\r\n\r\n#define S_IRGRP    (S_IRUSR >> 3)\r\n#define S_IWGRP    (S_IWUSR >> 3)\r\n#define S_IXGRP    (S_IXUSR >> 3)\r\n#define S_IRWXG    (S_IRWXU >> 3)\r\n\r\n#define S_IROTH    (S_IRGRP >> 3)\r\n#define S_IWOTH    (S_IWGRP >> 3)\r\n#define S_IXOTH    (S_IXGRP >> 3)\r\n#define S_IRWXO    (S_IRWXG >> 3)\r\n\r\n//#define\tS_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\r\n//#define\tS_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\r\n//#define\tS_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\r\n#define\tS_IFBLK\t0x3000\t/* Block: Is this ever set under w32? */\r\n#define\tS_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\r\n#define\tS_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\r\n\r\n\r\n\r\nint stat(const char *, struct stat*);\r\n\r\nint _fstati64(int, struct stat*);\r\n\r\nint fstat(int, struct stat *);\r\n#define _fstat fstat\r\n\r\nint _wstati64(const wchar_t,struct _stati64 *buffer);  \r\n\r\n\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_systimeb = (byte*)"/* timeb.h */\r\n\r\n#ifndef $timeb\r\n#define $timeb\r\n\r\n#include <time.h>\r\n\r\nstruct _timeb {\r\n\ttime_t time;\r\n\tunsigned short millitm;\r\n\tshort timezone;\r\n\tshort dstflag;\r\n};\r\n#define timeb _timeb\r\n\r\nvoid _ftime64(struct _timeb*);\r\n#define _ftime _ftime64\r\n#define ftime _ftime64\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_sysutime = (byte*)"/* sys/utime.h header */\r\n\r\n#ifndef $utime\r\n#define $utime\r\n\r\nstruct _utimbuf {\r\n\tlong actime;\r\n\tlong modtime;\r\n};\r\n\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_memory = (byte*)"#include <malloc.h>\r\n";
static u8 *  cc_headers$h_windows = 
(byte*)"#ifndef $windows\n#define $windows 1\n#include <stdarg.h>\n#include <stddef.h>\n\n#define FALSE 0\n#define TRUE 1\n\ntypedef int BOOL;\ntypedef BOOL *PBOOL;\n#define FAR\n#define NEAR\n#define Int32x32To64(a,b)(((long long)((long)(a))) *((long long)((long)(b))))\n\n\n#define DECLARE_HANDLE(n) typedef HANDLE n\n#define _WINBASE_\n#define WINBASEAPI\ntypedef int WINBOOL;\ntypedef unsigned short UINT16;\ntypedef unsigned short ATOM;\ntypedef unsigned char BOOLEAN;\ntypedef unsigned char BYTE;\ntypedef unsigned long CALTYPE;\ntypedef unsigned long CALID;\ntypedef unsigned long long *PULONGLONG;\ntypedef long long LONG64;\ntypedef char CCHAR;\ntypedef char CHAR;\ntypedef unsigned long COLORREF;\n#define CONST const\ntypedef unsigned long DWORD;\n\ntypedef unsigned long ULONG_PTR;\ntypedef ULONG_PTR *PULONG_PTR;\ntypedef ULONG_PTR DWORD_PTR;\ntypedef long long int LONGLONG;\ntypedef unsigned long long UINT_PTR;\ntypedef ULONG_PTR SIZE_T;\ntypedef SIZE_T *PSIZE_T;\ntypedef unsigned long long int DWORDLONG,*PDWORDLONG;\ntypedef float FLOAT;\ntypedef void *HANDLE;\ntypedef long SCODE,*PSCODE;\ntypedef double DOUBLE;\ntypedef HANDLE GLOBALHANDLE;\ntypedef HANDLE HSTMT;\ntypedef HANDLE HDBC;\ntypedef HANDLE HENV;\ntypedef HANDLE LOCALHANDLE;\ntypedef HANDLE HTASK;\ntypedef HANDLE HACCEL;\ntypedef HANDLE HBITMAP;\ntypedef HANDLE HBRUSH;\ntypedef HANDLE HCOLORSPACE;\ntypedef HANDLE HCONV;\ntypedef HANDLE HCONVLIST;\ntypedef HANDLE HCURSOR;\ntypedef HANDLE HDC;\ntypedef HANDLE HDDEDATA;\ntypedef HANDLE HDESK;\ntypedef HANDLE HWINEVENTHOOK;\ntypedef HANDLE HDWP;\ntypedef HANDLE HENHMETAFILE;\ntypedef int HFILE;\ntypedef HANDLE HFONT;\ntypedef HANDLE HGDIOBJ;\ntypedef HANDLE HGLOBAL;\ntypedef HANDLE HGLRC;\ntypedef HANDLE HHOOK;\ntypedef HANDLE HICON;\ntypedef HANDLE HIMAGELIST;\ntypedef HANDLE HINSTANCE;\ntypedef HANDLE HKEY,*PHKEY;\ntypedef HANDLE HKL;\ntypedef HANDLE HLOCAL;\ntypedef HANDLE HMENU;\ntypedef HANDLE HMETAFILE;\ntypedef HANDLE HMODULE;\ntypedef HANDLE HPALETTE;\ntypedef HANDLE HPEN;\ntypedef long HRESULT;\n#define _HRESULT_DEFINED\n#define SNDMSG SendMessage\ntypedef HANDLE HRGN;\ntypedef HANDLE HRSRC;\ntypedef HANDLE HSZ;\ntypedef HANDLE HWINSTA;\ntypedef HANDLE HWND;\ntypedef int INT;\ntypedef unsigned short LANGID;\ntypedef DWORD LCID;\n#define _LCID_DEFINED\ntypedef DWORD LCTYPE;\ntypedef enum _SYSTEM_POWER_STATE { PowerSystemUnspecified=0,PowerSystemWorking=1,\n\tPowerSystemSleeping1 =2,PowerSystemSleeping2=3,PowerSystemSleeping3=4,\n\tPowerSystemHibernate=5,PowerSystemShutdown=6,PowerSystemMaximum=7\n} SYSTEM_POWER_STATE,*PSYSTEM_POWER_STATE;\n#define POWER_SYSTEM_MAXIMUM 7\ntypedef enum { PowerActionNone=0,PowerActionReserved,PowerActionSleep,PowerActionHibernate,\n\tPowerActionShutdown,PowerActionShutdownReset,PowerActionShutdownOff,PowerActionWarmEject\n} POWER_ACTION, *PPOWER_ACTION;\ntypedef enum _DEVICE_POWER_STATE { PowerDeviceUnspecified=0,PowerDeviceD0,PowerDeviceD1,\n\tPowerDeviceD2,PowerDeviceD3,PowerDeviceMaximum\n} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;\n#define ES_SYSTEM_REQUIRED\t0x1\n#define ES_DISPLAY_REQUIRED\t0x2\n#define ES_USER_PRESENT\t0x4\n#define ES_CONTINUOUS\t0x80000000\ntypedef DWORD EXECUTION_STATE;\ntypedef long LONG;\ntypedef long long USN;\ntypedef unsigned long long ULONGLONG;\ntypedef long LPARAM;\ntypedef BOOL *LPBOOL;\ntypedef BYTE *LPBYTE;\ntypedef CONST BYTE *LPCBYTE;\ntypedef CONST CHAR *LPCCH;\ntypedef CHAR *LPCH;\ntypedef COLORREF *LPCOLORREF;\ntypedef const char *LPCSTR;\ntypedef unsigned short * LPCOLESTR;\n#define OLESTR(str) L##str\ntypedef unsigned char UCHAR;\ntypedef signed char SCHAR;\ntypedef long int SDWORD;\ntypedef short int SWORD;\ntypedef unsigned long int UDWORD;\ntypedef unsigned short int UWORD;\ntypedef unsigned long ULONG;\ntypedef unsigned short USHORT;\n//#endif\ntypedef signed short RETCODE;\n#define STDAPI\n#define STDAPICALLTYPE\n#define STDAPIVCALLTYPE\n#define STDMETHODCALLTYPE\n#define STDAPI_(type) type\n#define APIPRIVATE\n//#endif /* rc_invoked */\n#define CONTROL_C_EXIT STATUS_CONTROL_C_EXIT\n#define WC_LINK L\"Syslink\"\n#define WC_SCROLLBARA \"ScrollBar\"\n#define WC_SCROLLBARW L\"ScrollBar\"\n#define WC_IPADDRESSW\tL\"SysIPAddress32\"\n#define WC_IPADDRESSA\t\"SysIPAddress32\"\n#define WC_NATIVEFONTCTLW\tL\"NativeFontCtl\"\n#define WC_NATIVEFONTCTLA\t\"NativeFontCtl\"\n#define WC_COMBOBOXEXW\tL\"ComboBoxEx32\"\n#define WC_COMBOBOXEXA\t\"ComboBoxEx32\"\n#define WC_BUTTONA \"Button\"\n#define WC_BUTTONW L\"Button\"\n#define WC_STATICA \"Static\"\n#define WC_STATICW L\"Static\"\n#define WC_EDITA \"Edit\"\n#define WC_EDITW L\"Edit\"\n#define WC_LISTBOXA \"ListBox\"\n#define WC_LISTBOXW L\"ListBox\"\n#define WC_COMBOBOXA \"ComboBox\"\n#define WC_COMBOBOXW L\"ComboBox\"\n#define SB_GETUNICODEFORMAT\tCCM_GETUNICODEFORMAT\n#define SB_SETUNICODEFORMAT\tCCM_SETUNICODEFORMAT\n#define TB_GETUNICODEFORMAT CCM_GETUNICODEFORMAT\n#define TB_SETUNICODEFORMAT CCM_SETUNICODEFORMAT\n#define TC_NORMAL 0\n#define TC_HARDERR 1\n#define TC_GP_TRAP 2\n#define TC_SIGNAL 3\n#ifdef UNICODE\n#define WC_EDIT WC_EDITW\n#define WC_BUTTON WC_BUTTONW\ntypedef const unsigned short *LPCTSTR;\ntypedef unsigned short *LPTCH;\ntypedef unsigned short *LPTSTR;\ntypedef unsigned short *PTBYTE;\ntypedef unsigned short *PTCH;\ntypedef unsigned short *PTCHAR;\ntypedef unsigned short *PTSTR;\ntypedef unsigned short TBYTE;\ntypedef unsigned short TCHAR;\ntypedef unsigned short BCHAR;\n#define WC_STATIC WC_STATICW\n#define WC_LISTBOX WC_LISTBOXW\n#define WC_COMBOBOX WC_COMBOBOXW\n#define ANYSIZE_ARRAY 1\n#define TEXT(quote) L##quote\n#define SERVICES_ACTIVE_DATABASE\tSERVICES_ACTIVE_DATABASEW\n#define SERVICES_FAILED_DATABASE\tSERVICES_FAILED_DATABASEW\n#define SC_GROUP_IDENTIFIER\tSC_GROUP_IDENTIFIERW\n#define HDM_GETITEM HDM_GETITEMW\n#define HDM_INSERTITEM HDM_INSERTITEMW\n#define HDM_SETITEM HDM_SETITEMW\n#define HDM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT\n#define HDM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT\n#define ACM_OPEN ACM_OPENW\n#define HDN_BEGINTRACK HDN_BEGINTRACKW\n#define HDN_DIVIDERDBLCLICK HDN_DIVIDERDBLCLICKW\n#define HDN_ENDTRACK HDN_ENDTRACKW\n#define HDN_ITEMCHANGED HDN_ITEMCHANGEDW\n#define HDN_ITEMCHANGING HDN_ITEMCHANGINGW\n#define HDN_ITEMCLICK HDN_ITEMCLICKW\n#define HDN_ITEMDBLCLICK HDN_ITEMDBLCLICKW\n#define HDN_GETDISPINFO\tHDN_GETDISPINFOW\n#define HDN_TRACK HDN_TRACKW\n#define WC_COMBOBOXEX\tWC_COMBOBOXEXW\n#define WC_IPADDRESS\tWC_IPADDRESSW\n#define WC_SCROLLBAR\tWC_SCROLLBARW\n#define GetSystemWindowsDirectory GetSystemWindowsDirectoryW\n#define IPN_FIELDCHANGED\t(IPN_FIRST - 0)\n#define MAKEIPRANGE(low, high)\t((LPARAM)(WORD)(((BYTE)(high) << 8) + (BYTE)(low)))\n#define MAKEIPADDRESS(b1,b2,b3,b4)\t((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))\n#define FIRST_IPADDRESS(x)\t((x>>24) & 0xff)\n#define SECOND_IPADDRESS(x)\t((x>>16) & 0xff)\n#define THIRD_IPADDRESS(x)\t((x>>8) & 0xff)\n#define FOURTH_IPADDRESS(x)\t(x & 0xff)\n#define LVM_EDITLABEL LVM_EDITLABELW\n#define\tLVM_FINDITEM\tLVM_FINDITEMW\n#define\tLVM_GETCOLUMN\tLVM_GETCOLUMNW\n#define\tLVM_GETITEMTEXT\tLVM_GETITEMTEXTW\n#define\tLVM_GETSTRINGWIDTH\tLVM_GETSTRINGWIDTHW\n#define\tLVM_INSERTCOLUMN\tLVM_INSERTCOLUMNW\n#define\tLVM_SETCOLUMN\tLVM_SETCOLUMNW\n#define\tLVM_SETITEMTEXT\tLVM_SETITEMTEXTW\n#define\tLVM_EDITLABEL\tLVM_EDITLABELW\n#define\tLVM_GETBKIMAGE\tLVM_GETBKIMAGEW\n#define\tLVM_GETISEARCHSTRING\tLVM_GETISEARCHSTRINGW\n#define\tLVM_GETITEM\tLVM_GETITEMW\n#define\tLVM_INSERTITEM\tLVM_INSERTITEMW\n#define\tLVM_SETBKIMAGE\tLVM_SETBKIMAGEW\n#define\tLVM_SETITEM\tLVM_SETITEMW\n#define LVN_BEGINLABELEDIT LVN_BEGINLABELEDITW\n#define LVN_ENDLABELEDIT LVN_ENDLABELEDITW\n#define LVN_GETDISPINFO LVN_GETDISPINFOW\n#define LVN_SETDISPINFO LVN_SETDISPINFOW\n#define LVN_ODFNDITEM LVN_ODFINDITEMW\n#define LVN_HOTTRACK\t(LVN_FIRST+21)\n#define PSM_SETFINISHTEXT PSM_SETFINISHTEXTW\n#define PSM_SETTITLE PSM_SETTITLEW\n#define SB_GETTEXT SB_GETTEXTW\n#define SB_GETTEXTLENGTH SB_GETTEXTLENGTHW\n#define SB_SETTEXT SB_SETTEXTW\n#define TB_ADDSTRING TB_ADDSTRINGW\n#define TB_GETBUTTONTEXT TB_GETBUTTONTEXTW\n#define TB_SAVERESTORE TB_SAVERESTOREW\n#define TBBUTTONINFO TBBUTTONINFOW\n#define LPTBBUTTONINFO LPTBBUTTONINFOW\n#define DESKTOPENUMPROC DESKTOPENUMPROCW\n#define TBN_GETBUTTONINFO TBN_GETBUTTONINFOW\n#define TBN_GETDISPINFO\tTBN_GETDISPINFOW\n#define TCM_GETITEM TCM_GETITEM\n#define TCM_INSERTITEM TCM_INSERTITEMW\n#define TCM_SETITEM TCM_SETITEMW\n#define TTM_ADDTOOL TTM_ADDTOOLW\n#define TTM_DELTOOL TTM_DELTOOLW\n#define TTM_ENUMTOOLS TTM_ENUMTOOLSW\n#define TTM_GETCURRENTTOOL TTM_GETCURRENTTOOLW\n#define TTM_GETTEXT TTM_GETTEXTW\n#define TTM_GETTOOLINFO TTM_GETTOOLINFOW\n#define TTM_HITTEST TTM_HITTESTW\n#define TTM_NEWTOOLRECT TTM_NEWTOOLRECTW\n#define TTM_SETTOOLINFO TTM_SETTOOLINFOW\n#define TTM_UPDATETIPTEXT TTM_UPDATETIPTEXTW\n#define TTN_NEEDTEXT TTN_NEEDTEXTW\n#define TTN_GETDISPINFO\tTTN_GETDISPINFOW\n#define TVM_EDITLABEL TVM_EDITLABELW\n#define TVM_GETISEARCHSTRING TVM_GETISEARCHSTRINGW\n#define TVM_GETITEM TVM_GETITEMW\n#define TVM_INSERTITEM TVM_INSERTITEMW\n#define TVM_SETITEM TVM_SETITEMW\n#define TVN_BEGINDRAG TVN_BEGINDRAGW\n#define TVN_BEGINLABELEDIT TVN_BEGINLABELEDITW\n#define TVN_BEGINRDRAG TVN_BEGINRDRAGW\n#define TVN_DELETEITEM TVN_DELETEITEMW\n#define TVN_ENDLABELEDIT TVN_ENDLABELEDITW\n#define TVN_GETDISPINFO TVN_GETDISPINFOW\n#define TVN_ITEMEXPANDED TVN_ITEMEXPANDEDW\n#define TVN_ITEMEXPANDING TVN_ITEMEXPANDINGW\n#define TVN_SELCHANGED TVN_SELCHANGEDW\n#define TVN_SELCHANGING TVN_SELCHANGINGW\n#define TVN_SETDISPINFO TVN_SETDISPINFOW\n#define ANIMATE_CLASS ANIMATE_CLASSW\n#define HOTKEY_CLASS HOTKEY_CLASSW\n#define PROGRESS_CLASS PROGRESS_CLASSW\n#define STATUSCLASSNAME STATUSCLASSNAMEW\n#define REBARCLASSNAME REBARCLASSNAMEW\n#define REBARBANDINFO REBARBANDINFOW\n#define TOOLBARCLASSNAME TOOLBARCLASSNAMEW\n#define TOOLTIPS_CLASS TOOLTIPS_CLASSW\n#define TRACKBAR_CLASS TRACKBAR_CLASSW\n#define UPDOWN_CLASS UPDOWN_CLASSW\n#define WC_HEADER WC_HEADERW\n#define WC_NATIVEFONTCTL\tWC_NATIVEFONTCTLA\n#define WC_LISTVIEW WC_LISTVIEWW\n#define WC_TABCONTROL WC_TABCONTROLW\n#define WC_TREEVIEW WC_TREEVIEWW\n#define LPSTR_TEXTCALLBACK LPSTR_TEXTCALLBACKW\n#define RB_INSERTBAND\tRB_INSERTBANDW\n#define RB_SETBANDINFO\tRB_SETBANDINFOW\n#define LPREBARBANDINFO\tLPREBARBANDINFOW\n#define NMLVDISPINFO NMLVDISPINFOW\n#define LVN_GETINFOTIP\tLVN_GETINFOTIPW\n#define NMLVGETINFOTIP\tNMLVGETINFOTIPW\n#define LPNMLVGETINFOTIP\tLPNMLVGETINFOTIPW\n#define LVFINDINFO\tLVFINDINFOW\n#define NMCBEDRAGBEGIN NMCBEDRAGBEGINW\n#define LPNMCBEDRAGBEGIN LPNMCBEDRAGBEGINW\n#define PNMCBEDRAGBEGIN PNMCBEDRAGBEGINW\n#define NMCBEENDEDIT NMCBEENDEDITW\n#define LPNMCBEENDEDIT LPNMCBEENDEDITW\n#define PNMCBEENDEDIT PNMCBEENDEDITW\n#define LPLVITEM\tLPLVITEMW\n#define LPLVCOLUMN\tLPLVCOLUMNW\n#define PGET_MODULE_HANDLE_EX PGET_MODULE_HANDLE_EXW\n#else\ntypedef const char *LPCTSTR;\ntypedef char *LPTCH;\ntypedef char *LPTSTR;\ntypedef unsigned char *PTBYTE;\ntypedef char *PTCH;\ntypedef char *PTCHAR;\ntypedef char *PTSTR;\ntypedef unsigned char TBYTE;\ntypedef char TCHAR;\ntypedef BYTE BCHAR;\n#define WC_EDIT WC_EDITA\n#define WC_BUTTON WC_BUTTONA\n#define WC_STATIC WC_STATICA\n#define WC_LISTBOX WC_LISTBOXA\n#define WC_COMBOBOX WC_COMBOBOXW\n#define TEXT(quote) quote\n#define SERVICES_ACTIVE_DATABASE\tSERVICES_ACTIVE_DATABASEA\n#define SERVICES_FAILED_DATABASE\tSERVICES_FAILED_DATABASEA\n#define SC_GROUP_IDENTIFIER\tSC_GROUP_IDENTIFIERA\n#define WC_COMBOBOXEX\tWC_COMBOBOXEXA\n#define WC_NATIVEFONTCTL\tWC_NATIVEFONTCTLA\n#define WC_IPADDRESS\tWC_IPADDRESSA\n#define WC_SCROLLBAR\tWC_SCROLLBARA\n#define GetSystemWindowsDirectory GetSystemWindowsDirectoryA\n#define HDN_GETDISPINFO\tHDN_GETDISPINFOA\n#define HDM_GETITEM HDM_GETITEMA\n#define HDM_INSERTITEM HDM_INSERTITEMA\n#define HDM_SETITEM HDM_SETITEMA\n#define ACM_OPEN ACM_OPENA\n#define HDN_BEGINTRACK HDN_BEGINTRACKA\n#define HDN_DIVIDERDBLCLICK HDN_DIVIDERDBLCLICKA\n#define HDN_ENDTRACK HDN_ENDTRACKA\n#define HDN_ITEMCHANGED HDN_ITEMCHANGEDA\n#define HDN_ITEMCHANGING HDN_ITEMCHANGINGA\n#define HDN_ITEMCLICK HDN_ITEMCLICKA\n#define HDN_ITEMDBLCLICK HDN_ITEMDBLCLICKA\n#define HDN_TRACK HDN_TRACKA\n#define\tLVM_FINDITEM\tLVM_FINDITEMA\n#define\tLVM_GETCOLUMN\tLVM_GETCOLUMNA\n#define\tLVM_GETITEMTEXT\tLVM_GETITEMTEXTA\n#define\tLVM_GETSTRINGWIDTH\tLVM_GETSTRINGWIDTHA\n#define\tLVM_INSERTCOLUMN\tLVM_INSERTCOLUMNA\n#define\tLVM_SETCOLUMN\tLVM_SETCOLUMNA\n#define\tLVM_SETITEMTEXT\tLVM_SETITEMTEXTA\n#define\tLVM_EDITLABEL\tLVM_EDITLABELA\n#define\tLVM_GETBKIMAGE\tLVM_GETBKIMAGEA\n#define\tLVM_GETISEARCHSTRING\tLVM_GETISEARCHSTRINGA\n#define\tLVM_GETITEM\tLVM_GETITEMA\n#define\tLVM_INSERTITEM\tLVM_INSERTITEMA\n#define\tLVM_SETBKIMAGE\tLVM_SETBKIMAGEA\n#define\tLVM_SETITEM\tLVM_SETITEMA\n#define LVN_BEGINLABELEDIT LVN_BEGINLABELEDITA\n#define LVN_ENDLABELEDIT LVN_ENDLABELEDITA\n#define LVN_GETDISPINFO LVN_GETDISPINFOA\n#define LVN_SETDISPINFO LVN_SETDISPINFOA\n#define LVN_ODFINDITEM LVN_ODFINDITEMA\n#define PSM_SETFINISHTEXT PSM_SETFINISHTEXTA\n#define PSM_SETTITLE PSM_SETTITLEA\n#define SB_GETTEXT SB_GETTEXTA\n#define SB_GETTEXTLENGTH SB_GETTEXTLENGTHA\n#define SB_SETTEXT SB_SETTEXTA\n#define TB_ADDSTRING TB_ADDSTRINGA\n#define TB_GETBUTTONTEXT TB_GETBUTTONTEXTA\n#define TB_SAVERESTORE TB_SAVERESTOREA\n#define TB_GETBUTTONINFO\tTB_GETBUTTONINFOA\n#define TB_SETBUTTONINFO\tTB_SETBUTTONINFOA\n#define TBBUTTONINFO TBBUTTONINFOA\n#define LPTBBUTTONINFO LPTBBUTTONINFOA\n#define DESKTOPENUMPROC DESKTOPENUMPROCA\n#define TBN_GETBUTTONINFO TBN_GETBUTTONINFOA\n#define TBN_GETDISPINFO TBN_GETDISPINFOA\n#define TCM_GETITEM TCM_GETITEMA\n#define TCM_INSERTITEM TCM_INSERTITEMA\n#define TCM_SETITEM TCM_SETITEMA\n#define TTM_ADDTOOL TTM_ADDTOOLA\n#define TTM_DELTOOL TTM_DELTOOLA\n#define TTM_ENUMTOOLS TTM_ENUMTOOLSA\n#define TTM_GETCURRENTTOOL TTM_GETCURRENTTOOLA\n#define TTM_GETTEXT TTM_GETTEXTA\n#define TTM_GETTOOLINFO TTM_GETTOOLINFOA\n#define TTM_HITTEST TTM_HITTESTA\n#define TTM_NEWTOOLRECT TTM_NEWTOOLRECTA\n#define TTM_SETTOOLINFO TTM_SETTOOLINFOA\n#define TTM_UPDATETIPTEXT TTM_UPDATETIPTEXTA\n#define TTN_NEEDTEXT TTN_NEEDTEXTA\n#define TTN_GETDISPINFO\tTTN_GETDISPINFOA\n#define TVM_EDITLABEL TVM_EDITLABELA\n#define TVM_GETISEARCHSTRING TVM_GETISEARCHSTRINGA\n#define TVM_GETITEM TVM_GETITEMA\n#define TVM_INSERTITEM TVM_INSERTITEMA\n#define TVM_SETITEM TVM_SETITEMA\n#define TVN_BEGINDRAG TVN_BEGINDRAGA\n#define TVN_BEGINLABELEDIT TVN_BEGINLABELEDITA\n#define TVN_BEGINRDRAG TVN_BEGINRDRAGA\n#define TVN_DELETEITEM TVN_DELETEITEMA\n#define TVN_ENDLABELEDIT TVN_ENDLABELEDITA\n#define TVN_GETDISPINFO TVN_GETDISPINFOA\n#define TVN_ITEMEXPANDED TVN_ITEMEXPANDEDA\n#define TVN_ITEMEXPANDING TVN_ITEMEXPANDINGA\n#define TVN_SELCHANGED TVN_SELCHANGEDA\n#define TVN_SELCHANGING TVN_SELCHANGINGA\n#define TVN_SETDISPINFO TVN_SETDISPINFOA\n#define ANIMATE_CLASS ANIMATE_CLASSA\n#define HOTKEY_CLASS HOTKEY_CLASSA\n#define PROGRESS_CLASS PROGRESS_CLASSA\n#define STATUSCLASSNAME STATUSCLASSNAMEA\n#define REBARCLASSNAME REBARCLASSNAMEA\n#define REBARBANDINFO REBARBANDINFOA\n#define TOOLBARCLASSNAME TOOLBARCLASSNAMEA\n#define TOOLTIPS_CLASS TOOLTIPS_CLASSA\n#define TRACKBAR_CLASS TRACKBAR_CLASSA\n#define UPDOWN_CLASS UPDOWN_CLASSA\n#define WC_HEADER WC_HEADERA\n#define WC_LISTVIEW WC_LISTVIEWA\n#define WC_TABCONTROL WC_TABCONTROLA\n#define WC_TREEVIEW WC_TREEVIEWA\n#define LPSTR_TEXTCALLBACK LPSTR_TEXTCALLBACKA\n#define RB_INSERTBAND\tRB_INSERTBANDA\n#define RB_SETBANDINFO\tRB_SETBANDINFOA\n#define LPREBARBANDINFO LPREBARBANDINFOA\n#define NMLDISPINFO NMLDISPINFOA\n#define LVN_GETINFOTIP\tLVN_GETINFOTIPA\n#define NMLVGETINFOTIP\tNMLVGETINFOTIPA\n#define LPNMLVGETINFOTIP\tLPNMLVGETINFOTIPA\n#define LVFINDINFO LVFINDINFOA\n#define NMCBEDRAGBEGIN NMCBEDRAGBEGINA\n#define NMLVDISPINFO NMLVDISPINFOA\n#define LPNMCBEDRAGBEGIN LPNMCBEDRAGBEGINA\n#define PNMCBEDRAGBEGIN PNMCBEDRAGBEGINA\n#define NMCBEENDEDIT NMCBEENDEDITA\n#define LPNMCBEENDEDIT LPNMCBEENDEDITA\n#define PNMCBEENDEDIT PNMCBEENDEDITA\n#define LPLVITEM\tLPLVITEMA\n#define LPLVCOLUMN\tLPLVCOLUMNA\n#define PGET_MODULE_HANDLE_EX PGET_MODULE_HANDLE_EXA\n#endif // UNICODE\n\n//#ifndef RC_INVOKED\ntypedef const unsigned short *LPCWCH;\ntypedef const unsigned short *LPCWSTR;\ntypedef DWORD *LPDWORD;\ntypedef HANDLE *LPHANDLE;\ntypedef int *LPINT;\ntypedef long *LPLONG;\ntypedef char *LPSTR;\ntypedef long LRESULT;\ntypedef void *LPVOID;\ntypedef const void *LPCVOID;\ntypedef unsigned short *LPWCH;\ntypedef unsigned short *LPWORD;\ntypedef unsigned short *LPWSTR;\ntypedef unsigned short *PWSTR;\ntypedef unsigned short *NWPSTR;\ntypedef BOOL *PWINBOOL;\ntypedef BYTE *PBOOLEAN;\ntypedef BYTE *PBYTE;\ntypedef const CHAR *PCCH;\ntypedef CHAR *PCH;\ntypedef CHAR *PCHAR;\ntypedef const char *PCSTR;\ntypedef const unsigned short *PCWCH;\ntypedef const unsigned short *PCWSTR;\ntypedef DWORD *PDWORD;\ntypedef float *PFLOAT;\ntypedef HANDLE *PHANDLE;\ntypedef int *PINT;\ntypedef long *PLONG;\ntypedef short *PSHORT;\ntypedef char *PSTR;\ntypedef char *PSZ;\ntypedef unsigned char *PUCHAR;\ntypedef unsigned int *PUINT;\ntypedef unsigned long *PULONG;\ntypedef unsigned short *PUSHORT;\ntypedef void *PVOID;\ntypedef unsigned short *PWCH;\ntypedef unsigned short *PWCHAR;\ntypedef unsigned short *PWORD;\ntypedef short SHORT;\ntypedef unsigned int UINT;\n#define VOID void\ntypedef unsigned short WCHAR;\ntypedef unsigned short WORD;\ntypedef unsigned int WPARAM;\n#define CDECL\n#define CALLBACK\n#define PASCAL\n#define WINAPI\t\n#define NTAPI\t\n#define WINGDIAPI \n#define WINAPIV\n#define APIENTRY\t\n#define IPM_CLEARADDRESS\t(WM_USER+100)\n#define IPM_SETADDRESS\t(WM_USER+101)\n#define IPM_GETADDRESS\t(WM_USER+102)\n#define IPM_SETRANGE\t(WM_USER+103)\n#define IPM_SETFOCUS\t(WM_USER+104)\n#define IPM_ISBLANK\t(WM_USER+105)\ntypedef enum _ACL_INFORMATION_CLASS {\n\tAclRevisionInformation = 1,AclSizeInformation\n} ACL_INFORMATION_CLASS;\ntypedef enum _SECURITY_IMPERSONATION_LEVEL {\n\tSecurityAnonymous,SecurityIdentification, SecurityImpersonation,\n\tSecurityDelegation\n} SECURITY_IMPERSONATION_LEVEL;\ntypedef enum _SID_NAME_USE {\n\tSidTypeUser = 1,SidTypeGroup, SidTypeDomain, SidTypeAlias,\n\tSidTypeWellKnownGroup,SidTypeDeletedAccount, SidTypeInvalid,\n\tSidTypeUnknown\n} SID_NAME_USE,*PSID_NAME_USE;\ntypedef enum _TOKEN_INFORMATION_CLASS {\n\tTokenUser = 1,TokenGroups, TokenPrivileges, TokenOwner,\n\tTokenPrimaryGroup,TokenDefaultDacl, TokenSource, TokenType,\n\tTokenImpersonationLevel,TokenStatistics\n} TOKEN_INFORMATION_CLASS;\ntypedef enum tagTOKEN_TYPE {\n\tTokenPrimary = 1,TokenImpersonation\n} TOKEN_TYPE;\ntypedef enum { LT_DONT_CARE, LT_LOWEST_LATENCY } LATENCY_TIME;\n//#endif RC_INVOKED\n\n#define FORWARD_WM_NOTIFY(h,id,hdr,fn) (void)(fn)((h),WM_NOTIFY,(WPARAM)(id),(LPARAM)(hdr))\n#define GetBValue(rgb) ((BYTE) ((rgb) >> 16))\n#define GetGValue(rgb) ((BYTE) (((WORD) (rgb)) >> 8))\n#define GetRValue(rgb) ((BYTE) (rgb))\n#define RGB(r,g,b) ((DWORD)(((BYTE)(r)|((WORD)(g) << 8))|(((DWORD)(BYTE)(b)) << 16)))\n#define HANDLE_WM_NOTIFY(h,wP,lP,fn) (fn)((h),(int)(wP),(NMHDR *)(lP))\n#define HIBYTE(w) ((BYTE) (((WORD) (w) >> 8) & 0xFF))\n#define HIWORD(l) ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))\n#define LOBYTE(w) (((BYTE) (w)) & 0xFF)\n#define LOWORD(l) (((WORD) (l)) & 0xFFFF)\n#define MAKELONG(a,b) ((LONG) (((WORD) (a)) | ((DWORD) ((WORD) (b))) << 16))\n#define MAKEWORD(a,b) ((WORD) (((BYTE) (a)) | ((WORD) ((BYTE) (b))) << 8))\n#define INDEXTOOVERLAYMASK(i) ((i) << 8)\n#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)\n#define MAXINTATOM 0xC000\n#define INVALID_ATOM ((ATOM)0)\n#define MAKEINTATOM(i) (LPTSTR) ((DWORD) ((WORD) (i)))\n#define MAKEINTRESOURCE(i) (LPTSTR) ((DWORD) ((WORD) (i)))\n#define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16)==0)\n#define MAKELANGID(p,s) ((((WORD) (s)) << 10) | (WORD) (p))\n#define PRIMARYLANGID(lgid) ((WORD )(lgid) & 0x3ff)\n#define SUBLANGID(lgid) ((WORD )(lgid) >> 10)\n#define LANGIDFROMLCID(lcid) ((WORD) (lcid))\n#define SORTIDFROMLCID(lcid) ((WORD )((((DWORD)(lcid)) & 0xFFFFF) >> 16))\n#define MAKELCID(lgid,srtid) ((DWORD)((((DWORD)((WORD)(srtid))) << 16)|((DWORD)((WORD)(lgid)))))\n#define MAKELPARAM(l,h) ((LPARAM) MAKELONG(l,h))\n#define MAKELRESULT(l,h) ((LRESULT) MAKELONG(l,h))\n#define MAKEPOINTS(l) (*((POINTS *) & (l)))\n#define MAKEROP4(fore,back) (DWORD)((((back) << 8) & 0xFF000000) | (fore))\n#define MAKEWPARAM(l,h)\t((WPARAM) MAKELONG(l,h))\n#define PALETTEINDEX(i) ((COLORREF) (0x01000000 | (DWORD) (WORD) (i)))\n#define PALETTERGB(r,g,b) (0x02000000 | RGB(r,g,b))\n#define POINTSTOPOINT(pt,pts) {(pt).x = (LONG)(SHORT) LOWORD(*(LONG*)&pts); (pt).y = (LONG)(SHORT) HIWORD(*(LONG*)&pts);}\n#define POINTTOPOINTS(pt) (MAKELONG((short) ((pt).x),(short) ((pt).y)))\n#define INDEXTOOVERLAYMASK(i) ((i) << 8)\n\ntypedef int (CALLBACK *BFFCALLBACK) (HWND,UINT,LPARAM,LPARAM);\ntypedef UINT (CALLBACK *LPCCHOOKPROC) (HWND,UINT,WPARAM,LPARAM);\ntypedef UINT (CALLBACK *LPCFHOOKPROC) (HWND,UINT,WPARAM,LPARAM);\ntypedef DWORD (CALLBACK *PTHREAD_START_ROUTINE) (LPVOID);\ntypedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;\ntypedef UINT (CALLBACK *LPFRHOOKPROC) (HWND,UINT,WPARAM,LPARAM);\ntypedef UINT (CALLBACK *LPOFNHOOKPROC) (HWND,UINT,WPARAM,LPARAM);\ntypedef UINT (CALLBACK *LPPRINTHOOKPROC) (HWND,UINT,WPARAM,LPARAM);\ntypedef UINT (CALLBACK *LPSETUPHOOKPROC) (HWND,UINT,WPARAM,LPARAM);\ntypedef BOOL (CALLBACK *DLGPROC) (HWND,UINT,WPARAM,LPARAM);\ntypedef int (CALLBACK *PFNPROPSHEETCALLBACK) (HWND,UINT,LPARAM);\ntypedef VOID (CALLBACK *LPSERVICE_MAIN_FUNCTION) (DWORD,LPTSTR);\ntypedef int (CALLBACK *PFNTVCOMPARE) (LPARAM,LPARAM,LPARAM);\ntypedef LRESULT (CALLBACK *WNDPROC) (HWND,UINT,WPARAM,LPARAM);\ntypedef int (CALLBACK *FARPROC)(void);\ntypedef int (WINAPI *PROC)(void);\ntypedef BOOL (CALLBACK *WNDENUMPROC)(HWND,LPARAM);\ntypedef BOOL (CALLBACK *ENUMRESTYPEPROCA) (HANDLE,LPSTR,LONG);\ntypedef BOOL (CALLBACK *ENUMRESTYPEPROCW) (HANDLE,LPWSTR,LONG);\ntypedef BOOL (CALLBACK *ENUMRESNAMEPROC) (HANDLE,LPCTSTR,LPTSTR,LONG);\ntypedef BOOL (CALLBACK *ENUMRESLANGPROC) (HANDLE,LPCTSTR,LPCTSTR,WORD,LONG);\ntypedef BOOL (CALLBACK *ENUMWINDOWSPROC) (HWND,LPARAM);\ntypedef BOOL (CALLBACK *ENUMWINDOWSTATIONPROC) (LPTSTR,LPARAM);\ntypedef VOID (CALLBACK *SENDASYNCPROC) (HWND,UINT,DWORD,LRESULT);\ntypedef VOID (CALLBACK *TIMERPROC) (HWND,UINT,UINT,DWORD);\ntypedef BOOL (CALLBACK *GRAYSTRINGPROC)(HDC,LPARAM,int);\ntypedef BOOL (CALLBACK *DRAWSTATEPROC) (HDC,LPARAM,WPARAM,int,int);\ntypedef BOOL (CALLBACK *PROPENUMPROCEX) (HWND,LPCTSTR,HANDLE,DWORD);\ntypedef BOOL (CALLBACK *PROPENUMPROC) (HWND,LPCTSTR,HANDLE);\ntypedef LRESULT (CALLBACK *HOOKPROC) (int,WPARAM,LPARAM);\ntypedef VOID (CALLBACK *ENUMOBJECTSPROC) (LPVOID,LPARAM);\ntypedef VOID (CALLBACK *LINEDDAPROC) (int,int,LPARAM);\ntypedef BOOL (CALLBACK *ABORTPROC) (HDC,int);\ntypedef UINT (CALLBACK *LPPAGEPAINTHOOK) (HWND,UINT,WPARAM,LPARAM);\ntypedef UINT (CALLBACK *LPPAGESETUPHOOK) (HWND,UINT,WPARAM,LPARAM);\ntypedef int (CALLBACK *ICMENUMPROC) (LPTSTR,LPARAM);\ntypedef LONG (*EDITWORDBREAKPROCEX) (char *,LONG,BYTE,INT);\ntypedef int (CALLBACK *PFNLVCOMPARE) (LPARAM,LPARAM,LPARAM);\ntypedef BOOL (CALLBACK *LOCALE_ENUMPROC) (LPTSTR);\ntypedef BOOL (CALLBACK *CODEPAGE_ENUMPROC) (LPTSTR);\ntypedef BOOL (CALLBACK *DATEFMT_ENUMPROC) (LPTSTR);\ntypedef BOOL (CALLBACK *TIMEFMT_ENUMPROC) (LPTSTR);\ntypedef BOOL (CALLBACK *CALINFO_ENUMPROC) (LPTSTR);\ntypedef BOOL (CALLBACK *PHANDLER_ROUTINE) (DWORD);\ntypedef UINT (CALLBACK *PFNGETPROFILEPATH) (LPCTSTR,LPSTR,UINT);\ntypedef UINT (CALLBACK *PFNRECONCILEPROFILE) (LPCTSTR,LPCTSTR,DWORD);\ntypedef BOOL (CALLBACK *PFNPROCESSPOLICIES) (HWND,LPCTSTR,LPCTSTR,LPCTSTR,DWORD);\ntypedef BOOL (CALLBACK* NAMEENUMPROCA)(LPSTR,LPARAM);\ntypedef BOOL (CALLBACK* NAMEENUMPROCW)(LPWSTR,LPARAM);\ntypedef NAMEENUMPROCA WINSTAENUMPROCA;\ntypedef NAMEENUMPROCA DESKTOPENUMPROCA;\ntypedef NAMEENUMPROCW WINSTAENUMPROCW;\ntypedef NAMEENUMPROCW DESKTOPENUMPROCW;\n\n#define SECURITY_NULL_SID_AUTHORITY\t{0,0,0,0,0,0}\n#define SECURITY_WORLD_SID_AUTHORITY\t{0,0,0,0,0,1}\n#define SECURITY_LOCAL_SID_AUTHORITY\t{0,0,0,0,0,2}\n#define SECURITY_CREATOR_SID_AUTHORITY\t{0,0,0,0,0,3}\n#define SECURITY_NON_UNIQUE_AUTHORITY\t{0,0,0,0,0,4}\n#define SECURITY_NT_AUTHORITY\t{0,0,0,0,0,5}\n#define SE_CREATE_TOKEN_NAME\tTEXT(\"SeCreateTokenPrivilege\")\n#define SE_ASSIGNPRIMARYTOKEN_NAME\tTEXT(\"SeAssignPrimaryTokenPrivilege\")\n#define SE_LOCK_MEMORY_NAME\tTEXT(\"SeLockMemoryPrivilege\")\n#define SE_INCREASE_QUOTA_NAME\tTEXT(\"SeIncreaseQuotaPrivilege\")\n#define SE_UNSOLICITED_INPUT_NAME\tTEXT(\"SeUnsolicitedInputPrivilege\")\n#define SE_MACHINE_ACCOUNT_NAME\tTEXT(\"SeMachineAccountPrivilege\")\n#define SE_TCB_NAME\tTEXT(\"SeTcbPrivilege\")\n#define SE_SECURITY_NAME\tTEXT(\"SeSecurityPrivilege\")\n#define SE_TAKE_OWNERSHIP_NAME\tTEXT(\"SeTakeOwnershipPrivilege\")\n#define SE_LOAD_DRIVER_NAME\tTEXT(\"SeLoadDriverPrivilege\")\n#define SE_SYSTEM_PROFILE_NAME\tTEXT(\"SeSystemProfilePrivilege\")\n#define SE_SYSTEMTIME_NAME\tTEXT(\"SeSystemtimePrivilege\")\n#define SE_PROF_SINGLE_PROCESS_NAME\tTEXT(\"SeProfileSingleProcessPrivilege\")\n#define SE_INC_BASE_PRIORITY_NAME\tTEXT(\"SeIncreaseBasePriorityPrivilege\")\n#define SE_CREATE_PAGEFILE_NAME\tTEXT(\"SeCreatePagefilePrivilege\")\n#define SE_CREATE_PERMANENT_NAME\tTEXT(\"SeCreatePermanentPrivilege\")\n#define SE_BACKUP_NAME\tTEXT(\"SeBackupPrivilege\")\n#define SE_RESTORE_NAME\tTEXT(\"SeRestorePrivilege\")\n#define SE_SHUTDOWN_NAME\tTEXT(\"SeShutdownPrivilege\")\n#define SE_DEBUG_NAME\tTEXT(\"SeDebugPrivilege\")\n#define SE_AUDIT_NAME\tTEXT(\"SeAuditPrivilege\")\n#define SE_SYSTEM_ENVIRONMENT_NAME\tTEXT(\"SeSystemEnvironmentPrivilege\")\n#define SE_CHANGE_NOTIFY_NAME\tTEXT(\"SeChangeNotifyPrivilege\")\n#define SE_REMOTE_SHUTDOWN_NAME\tTEXT(\"SeRemoteShutdownPrivilege\")\n#define SERVICES_ACTIVE_DATABASEW\tL\"ServicesActive\"\n#define SERVICES_FAILED_DATABASEW\tL\"ServicesFailed\"\n#define SERVICES_ACTIVE_DATABASEA\t\"ServicesActive\"\n#define SERVICES_FAILED_DATABASEA\t\"ServicesFailed\"\n#define SC_GROUP_IDENTIFIERW\tL'+'\n#define SC_GROUP_IDENTIFIERA\t'+'\n/* Messages.h WIN32 message definitions */\n#define ACM_OPENW\t1127\n#define ACM_OPENA\t1124\n#define ACM_PLAY\t1125\n#define ACM_STOP\t1126\n#define ACN_START\t1\n#define ACN_STOP\t2\n#define BM_CLICK\t245\n#define BM_GETCHECK\t240\n#define BM_GETIMAGE\t246\n#define BM_GETSTATE\t242\n#define BM_SETCHECK\t241\n#define BM_SETIMAGE\t247\n#define BM_SETSTATE\t243\n#define BM_SETSTYLE\t244\n#define BN_CLICKED\t0\n#define BN_DBLCLK\t5\n#define BN_DISABLE\t4\n#define BN_DOUBLECLICKED\t5\n#define BN_HILITE\t2\n#define BN_KILLFOCUS\t7\n#define BN_PAINT\t1\n#define BN_PUSHED\t2\n#define BN_SETFOCUS\t6\n#define BN_UNHILITE\t3\n#define BN_UNPUSHED\t3\n#define CB_ADDSTRING\t323\n#define CB_DELETESTRING\t324\n#define CB_DIR\t325\n#define CB_FINDSTRING\t332\n#define CB_FINDSTRINGEXACT\t344\n#define CB_GETCOUNT\t326\n#define CB_GETCURSEL\t327\n#define CB_GETDROPPEDCONTROLRECT\t338\n#define CB_GETDROPPEDSTATE\t343\n#define CB_GETDROPPEDWIDTH\t351\n#define CB_GETEDITSEL\t320\n#define CB_GETEXTENDEDUI\t342\n#define CB_GETHORIZONTALEXTENT\t349\n#define CB_GETITEMDATA\t336\n#define CB_GETITEMHEIGHT\t340\n#define CB_GETLBTEXT\t328\n#define CB_GETLBTEXTLEN\t329\n#define CB_GETLOCALE\t346\n#define CB_GETTOPINDEX\t347\n#define CB_INITSTORAGE\t353\n#define CB_INSERTSTRING\t330\n#define CB_LIMITTEXT\t321\n#define CB_RESETCONTENT\t331\n#define CB_SELECTSTRING\t333\n#define CB_SETCURSEL\t334\n#define CB_SETDROPPEDWIDTH\t352\n#define CB_SETEDITSEL\t322\n#define CB_SETEXTENDEDUI\t341\n#define CB_SETHORIZONTALEXTENT\t350\n#define CB_SETITEMDATA\t337\n#define CB_SETITEMHEIGHT\t339\n#define CB_SETLOCALE\t345\n#define CB_SETTOPINDEX\t348\n#define CB_SHOWDROPDOWN\t335\n#define CBN_CLOSEUP\t8\n#define CBN_DBLCLK\t2\n#define CBN_DROPDOWN\t7\n#define CBN_EDITCHANGE\t5\n#define CBN_EDITUPDATE\t6\n#define CBN_ERRSPACE\t(-1)\n#define CBN_KILLFOCUS\t4\n#define CBN_SELCHANGE\t1\n#define CBN_SELENDCANCEL\t10\n#define CBN_SELENDOK\t9\n#define CBN_SETFOCUS\t3\n#define DL_BEGINDRAG\t1157\n#define DL_CANCELDRAG\t1160\n#define DL_DRAGGING\t1158\n#define DL_DROPPED\t1159\n#define DRAGLISTMSGSTRING\tTEXT(\"commctrl_DragListMsg\")\n#define DM_GETDEFID\t1024\n#define DM_REPOSITION\t1026\n#define DM_SETDEFID\t1025\n#define EM_SETCUEBANNER (ECM_FIRST+1)\n#define EM_GETCUEBANNER (ECM_FIRST + 2)\n#define EM_SHOWBALLOONTIP (ECM_FIRST + 3)\n#define EM_HIDEBALLOONTIP (ECM_FIRST+4)\n#define EM_CANPASTE\t1074\n#define EM_CANUNDO\t198\n#define EM_CHARFROMPOS\t215\n#define EM_DISPLAYBAND\t1075\n#define EM_EMPTYUNDOBUFFER\t205\n#define EM_EXGETSEL\t1076\n#define EM_EXLIMITTEXT\t1077\n#define EM_EXLINEFROMCHAR\t1078\n#define EM_EXSETSEL\t1079\n#define EM_FINDTEXT\t1080\n#define EM_FINDTEXTEX\t1103\n#define EM_FINDWORDBREAK\t1100\n#define EM_FMTLINES\t200\n#define EM_FORMATRANGE\t1081\n#define EM_GETCHARFORMAT\t1082\n#define EM_GETEVENTMASK\t1083\n#define EM_GETFIRSTVISIBLELINE\t206\n#define EM_GETHANDLE\t189\n#define EM_GETLIMITTEXT\t213\n#define EM_GETLINE\t196\n#define EM_GETLINECOUNT\t186\n#define EM_GETMARGINS\t212\n#define EM_GETMODIFY\t184\n#define EM_GETIMECOLOR\t1129\n#define EM_GETIMEOPTIONS\t1131\n#define EM_GETOPTIONS\t1102\n#define EM_GETOLEINTERFACE\t1084\n#define EM_GETPARAFORMAT\t1085\n#define EM_GETPASSWORDCHAR\t210\n#define EM_GETPUNCTUATION\t1125\n#define EM_GETRECT\t178\n#define EM_GETSEL\t176\n#define EM_GETSELTEXT\t1086\n#define EM_GETTEXTRANGE\t1099\n#define EM_GETTHUMB\t190\n#define EM_GETWORDBREAKPROC\t209\n#define EM_GETWORDBREAKPROCEX\t1104\n#define EM_GETWORDWRAPMODE\t1127\n#define EM_HIDESELECTION\t1087\n#define EM_LIMITTEXT\t197\n#define EM_LINEFROMCHAR\t201\n#define EM_LINEINDEX\t187\n#define EM_LINELENGTH\t193\n#define EM_LINESCROLL\t182\n#define EM_PASTESPECIAL\t1088\n#define EM_POSFROMCHAR\t214\n#define EM_REPLACESEL\t194\n#define EM_REQUESTRESIZE\t1089\n#define EM_SCROLL\t181\n#define EM_SCROLLCARET\t183\n#define EM_SELECTIONTYPE\t1090\n#define EM_SETBKGNDCOLOR\t1091\n#define EM_SETCHARFORMAT\t1092\n#define EM_SETEVENTMASK\t1093\n#define EM_SETHANDLE\t188\n#define EM_SETIMECOLOR\t1128\n#define EM_SETIMEOPTIONS\t1130\n#define EM_SETLIMITTEXT\t197\n#define EM_SETMARGINS\t211\n#define EM_SETMODIFY\t185\n#define EM_SETOLECALLBACK\t1094\n#define EM_SETOPTIONS\t1101\n#define EM_SETPARAFORMAT\t1095\n#define EM_SETPASSWORDCHAR\t204\n#define EM_SETPUNCTUATION\t1124\n#define EM_SETREADONLY\t207\n#define EM_SETRECT\t179\n#define EM_SETRECTNP\t180\n#define EM_SETSEL\t177\n#define EM_SETTABSTOPS\t203\n#define EM_SETTARGETDEVICE\t1096\n#define EM_SETWORDBREAKPROC\t208\n#define EM_SETWORDBREAKPROCEX\t1105\n#define EM_SETWORDWRAPMODE\t1126\n#define EM_STREAMIN\t1097\n#define EM_STREAMOUT\t1098\n#define EM_UNDO\t199\n#define EN_CHANGE\t768\n#define EN_CORRECTTEXT\t1797\n#define EN_DROPFILES\t1795\n#define EN_ERRSPACE\t1280\n#define EN_HSCROLL\t1537\n#define EN_IMECHANGE\t1799\n#define EN_KILLFOCUS\t512\n#define EN_MAXTEXT\t1281\n#define EN_MSGFILTER\t1792\n#define EN_OLEOPFAILED\t1801\n#define EN_PROTECTED\t1796\n#define EN_REQUESTRESIZE\t1793\n#define EN_SAVECLIPBOARD\t1800\n#define EN_SELCHANGE\t1794\n#define EN_SETFOCUS\t256\n#define EN_STOPNOUNDO\t1798\n#define EN_UPDATE\t1024\n#define EN_VSCROLL\t1538\n#define HDM_FIRST\t0x1200\n#define HDM_DELETEITEM\t4610\n#define HDM_GETITEMW\t4619\n#define HDM_INSERTITEMW\t4618\n#define HDM_SETITEMW\t4620\n#define HDM_GETITEMA\t4611\n#define HDM_INSERTITEMA\t4609\n#define HDM_SETITEMA\t4612\n#define HDM_GETITEMCOUNT\t4608\n#define HDM_HITTEST\t4614\n#define HDM_LAYOUT\t4613\n#define HDM_SETBITMAPMARGIN (HDM_FIRST + 20)\n#define Header_SetBitmapMargin(hwnd, iWidth) (int)SNDMSG((hwnd), HDM_SETBITMAPMARGIN, (WPARAM)(iWidth), 0)\n#define HDM_GETBITMAPMARGIN (HDM_FIRST + 21)\n#define Header_GetBitmapMargin(hwnd) (int)SNDMSG((hwnd), HDM_GETBITMAPMARGIN, 0, 0)\n#define HDM_SETFILTERCHANGETIMEOUT (HDM_FIRST+22)\n#define Header_SetFilterChangeTimeout(hwnd, i) (int)SNDMSG((hwnd), HDM_SETFILTERCHANGETIMEOUT, 0, (LPARAM)(i))\n#define HDM_EDITFILTER\t(HDM_FIRST+23)\n#define Header_EditFilter(h,i,f) (int)SNDMSG((h),HDM_EDITFILTER,(WPARAM)(i),MAKELPARAM(f,0))\n#define HDM_CLEARFILTER\t(HDM_FIRST+24)\n#define Header_ClearFilter(h,i) (int)SNDMSG((h), HDM_CLEARFILTER, (WPARAM)(i),0)\n#define Header_ClearAllFilters(hwnd) (int)SNDMSG((hwnd), HDM_CLEARFILTER, (WPARAM)-1, 0)\n#define HDM_GETITEMRECT\t(HDM_FIRST+7)\n#define Header_GetItemRect(h,I,lprc) (BOOL)SendMessage((h), HDM_GETITEMRECT, (WPARAM)(I),(LPARAM)(lprc))\n#define HDM_SETIMAGELIST\t(HDM_FIRST+8)\n#define Header_SetImageList(h,himl) (HIMAGELIST)SendMessage((h),HDM_SETIMAGELIST,0,(LPARAM)(himl))\n#define HDM_GETIMAGELIST\t(HDM_FIRST+9)\n#define Header_GetImageList(h) (HIMAGELIST)SendMessage((h),HDM_GETIMAGELIST,0,0)\n#define HDM_ORDERTOINDEX\t(HDM_FIRST+15)\n#define Header_OrderToIndex(hwnd, i) (int)SendMessage((hwnd), HDM_ORDERTOINDEX, (WPARAM)(i), 0)\n#define HDM_CREATEDRAGIMAGE\t(HDM_FIRST+16)\n#define Header_CreateDragImage(h,i) (HIMAGELIST)SendMessage((h),HDM_CREATEDRAGIMAGE,(WPARAM)(i),0)\n#define HDM_GETORDERARRAY\t(HDM_FIRST+17)\n#define Header_GetOrderArray(h,C,i) (BOOL)SendMessage((h),HDM_GETORDERARRAY,(WPARAM)(C),(LPARAM)(i))\n#define HDM_SETORDERARRAY\t(HDM_FIRST+18)\n#define Header_SetOrderArray(h,C,lpi) (BOOL)SendMessage((h), HDM_SETORDERARRAY, (WPARAM)(C),(LPARAM)(lpi))\n#define HDM_SETHOTDIVIDER\t(HDM_FIRST+19)\n#define Header_SetHotDivider(h,P,dw) (int)SendMessage((h),HDM_SETHOTDIVIDER,(WPARAM)(P),(LPARAM)(dw))\n#define HDN_BEGINTRACKW\t(-326)\n#define HDN_DIVIDERDBLCLICKW\t(-325)\n#define HDN_ENDTRACKW\t(-327)\n#define HDN_ITEMCHANGEDW\t(-321)\n#define HDN_ITEMCHANGINGW\t(-320)\n#define HDN_ITEMCLICKW\t(-322)\n#define HDN_ITEMDBLCLICKW\t(-323)\n#define HDN_TRACKW\t(-328)\n#define HDN_BEGINTRACKA\t(-306)\n#define HDN_DIVIDERDBLCLICKA\t(-305)\n#define HDN_ENDTRACKA\t(-307)\n#define HDN_ITEMCHANGEDA\t(-301)\n#define HDN_ITEMCHANGINGA\t(-300)\n#define HDN_ITEMCLICKA\t(-302)\n#define HDN_ITEMDBLCLICKA\t(-303)\n#define HDN_TRACKA\t(-308)\n#define HDN_GETDISPINFOA\t(HDN_FIRST-9)\n#define HDN_GETDISPINFOW\t(HDN_FIRST-29)\n#define HDN_BEGINDRAG\t(HDN_FIRST-10)\n#define HDN_ENDDRAG\t(HDN_FIRST-11)\n#define HDN_FILTERCHANGE (HDN_FIRST-12)\n#define HDN_FILTERBTNCLICK (HDN_FIRST-13)\n#define HD_NOTIFYA NMHEADERA\n#define HD_NOTIFYW NMHEADERW\n#define HKM_GETHOTKEY\t1026\n#define HKM_SETHOTKEY\t1025\n#define HKM_SETRULES\t1027\n#define LB_ADDFILE\t406\n#define LB_ADDSTRING\t384\n#define LB_DELETESTRING\t386\n#define LB_DIR\t397\n#define LB_FINDSTRING\t399\n#define LB_FINDSTRINGEXACT\t418\n#define LB_GETANCHORINDEX\t413\n#define LB_GETCARETINDEX\t415\n#define LB_GETCOUNT\t395\n#define LB_GETCURSEL\t392\n#define LB_GETHORIZONTALEXTENT\t403\n#define LB_GETITEMDATA\t409\n#define LB_GETITEMHEIGHT\t417\n#define LB_GETITEMRECT\t408\n#define LB_GETLOCALE\t422\n#define LB_GETSEL\t391\n#define LB_GETSELCOUNT\t400\n#define LB_GETSELITEMS\t401\n#define LB_GETTEXT\t393\n#define LB_GETTEXTLEN\t394\n#define LB_GETTOPINDEX\t398\n#define LB_INITSTORAGE\t424\n#define LB_INSERTSTRING\t385\n#define LB_ITEMFROMPOINT\t425\n#define LB_RESETCONTENT\t388\n#define LB_SELECTSTRING\t396\n#define LB_SELITEMRANGE\t411\n#define LB_SELITEMRANGEEX\t387\n#define LB_SETANCHORINDEX\t412\n#define LB_SETCARETINDEX\t414\n#define LB_SETCOLUMNWIDTH\t405\n#define LB_SETCOUNT\t423\n#define LB_SETCURSEL\t390\n#define LB_SETHORIZONTALEXTENT\t404\n#define LB_SETITEMDATA\t410\n#define LB_SETITEMHEIGHT\t416\n#define LB_SETLOCALE\t421\n#define LB_SETSEL\t389\n#define LB_SETTABSTOPS\t402\n#define LB_SETTOPINDEX\t407\n#define LBN_DBLCLK\t2\n#define LBN_ERRSPACE\t(-2)\n#define LBN_KILLFOCUS\t5\n#define LBN_SELCANCEL\t3\n#define LBN_SELCHANGE\t1\n#define LBN_SETFOCUS\t4\n#define LVM_FIRST\t0x1000\n#define\tLVM_APPROXIMATEVIEWRECT\t(LVM_FIRST+64)\n#define\tLVM_ARRANGE\t(LVM_FIRST+22)\n#define\tLVM_CANCELEDITLABEL\t(LVM_FIRST+179)\n#define\tLVM_CREATEDRAGIMAGE\t(LVM_FIRST+33)\n#define\tLVM_DELETEALLITEMS\t(LVM_FIRST+9)\n#define\tLVM_DELETECOLUMN\t(LVM_FIRST+28)\n#define\tLVM_DELETEITEM\t(LVM_FIRST+8)\n#define\tLVM_EDITLABELA\t(LVM_FIRST+23)\n#define\tLVM_EDITLABELW\t(LVM_FIRST+118)\n#define\tLVM_ENABLEGROUPVIEW\t(LVM_FIRST+157)\n#define\tLVM_ENSUREVISIBLE\t(LVM_FIRST+19)\n#define\tLVM_FINDITEMA\t(LVM_FIRST+13)\n#define\tLVM_FINDITEMW\t(LVM_FIRST+83)\n#define\tLVM_GETBKCOLOR\t(LVM_FIRST+0)\n#define\tLVM_GETBKIMAGEA\t(LVM_FIRST+69)\n#define\tLVM_GETBKIMAGEW\t(LVM_FIRST+139)\n#define\tLVM_GETCALLBACKMASK\t(LVM_FIRST+10)\n#define\tLVM_GETCOLUMNA\t(LVM_FIRST+25)\n#define\tLVM_GETCOLUMNORDERARRAY\t(LVM_FIRST+59)\n#define\tLVM_GETCOLUMNW\t(LVM_FIRST+95)\n#define\tLVM_GETCOLUMNWIDTH\t(LVM_FIRST+29)\n#define\tLVM_GETCOUNTPERPAGE\t(LVM_FIRST+40)\n#define\tLVM_GETEDITCONTROL\t(LVM_FIRST+24)\n#define\tLVM_GETEXTENDEDLISTVIEWSTYLE\t(LVM_FIRST+55)\n#define\tLVM_GETGROUPINFO\t(LVM_FIRST+149)\n#define\tLVM_GETGROUPMETRICS\t(LVM_FIRST+156)\n#define\tLVM_GETHEADER\t(LVM_FIRST+31)\n#define\tLVM_GETHOTCURSOR\t(LVM_FIRST+63)\n#define\tLVM_GETHOTITEM\t(LVM_FIRST+61)\n#define\tLVM_GETHOVERTIME\t(LVM_FIRST+72)\n#define\tLVM_GETIMAGELIST\t(LVM_FIRST+2)\n#define\tLVM_GETINSERTMARK\t(LVM_FIRST+167)\n#define\tLVM_GETINSERTMARKCOLOR\t(LVM_FIRST+171)\n#define\tLVM_GETINSERTMARKRECT\t(LVM_FIRST+169)\n#define\tLVM_GETISEARCHSTRINGA\t(LVM_FIRST+52)\n#define\tLVM_GETISEARCHSTRINGW\t(LVM_FIRST+117)\n#define\tLVM_GETITEMA\t(LVM_FIRST+5)\n#define\tLVM_GETITEMCOUNT\t(LVM_FIRST+4)\n#define\tLVM_GETITEMPOSITION\t(LVM_FIRST+16)\n#define\tLVM_GETITEMRECT\t(LVM_FIRST+14)\n#define\tLVM_GETITEMSPACING\t(LVM_FIRST+51)\n#define\tLVM_GETITEMSTATE\t(LVM_FIRST+44)\n#define\tLVM_GETITEMTEXTA\t(LVM_FIRST+45)\n#define\tLVM_GETITEMTEXTW\t(LVM_FIRST+115)\n#define\tLVM_GETITEMW\t(LVM_FIRST+75)\n#define\tLVM_GETNEXTITEM\t(LVM_FIRST+12)\n#define\tLVM_GETNUMBEROFWORKAREAS\t(LVM_FIRST+73)\n#define\tLVM_GETORIGIN\t(LVM_FIRST+41)\n#define\tLVM_GETOUTLINECOLOR\t(LVM_FIRST+176)\n#define\tLVM_GETSELECTEDCOLUMN\t(LVM_FIRST+174)\n#define\tLVM_GETSELECTEDCOUNT\t(LVM_FIRST+50)\n#define\tLVM_GETSELECTIONMARK\t(LVM_FIRST+66)\n#define\tLVM_GETSTRINGWIDTHA\t(LVM_FIRST+17)\n#define\tLVM_GETSTRINGWIDTHW\t(LVM_FIRST+87)\n#define\tLVM_GETSUBITEMRECT\t(LVM_FIRST+56)\n#define\tLVM_GETTEXTBKCOLOR\t(LVM_FIRST+37)\n#define\tLVM_GETTEXTCOLOR\t(LVM_FIRST+35)\n#define\tLVM_GETTILEINFO\t(LVM_FIRST+165)\n#define\tLVM_GETTILEVIEWINFO\t(LVM_FIRST+163)\n#define\tLVM_GETTOOLTIPS\t(LVM_FIRST+78)\n#define\tLVM_GETTOPINDEX\t(LVM_FIRST+39)\n#define\tLVM_GETVIEW\t(LVM_FIRST+143)\n#define\tLVM_GETVIEWRECT\t(LVM_FIRST+34)\n#define\tLVM_GETWORKAREAS\t(LVM_FIRST+70)\n#define\tLVM_HASGROUP\t(LVM_FIRST+161)\n#define\tLVM_HITTEST\t(LVM_FIRST+18)\n#define\tLVM_INSERTCOLUMNA\t(LVM_FIRST+27)\n#define\tLVM_INSERTCOLUMNW\t(LVM_FIRST+97)\n#define\tLVM_INSERTGROUP\t(LVM_FIRST+145)\n#define\tLVM_INSERTGROUPSORTED\t(LVM_FIRST+159)\n#define\tLVM_INSERTITEMA\t(LVM_FIRST+7)\n#define\tLVM_INSERTITEMW\t(LVM_FIRST+77)\n#define\tLVM_INSERTMARKHITTEST\t(LVM_FIRST+168)\n#define\tLVM_ISGROUPVIEWENABLED\t(LVM_FIRST+175)\n#define\tLVM_MAPIDTOINDEX\t(LVM_FIRST+181)\n#define\tLVM_MAPINDEXTOID\t(LVM_FIRST+180)\n#define\tLVM_MOVEGROUP\t(LVM_FIRST+151)\n#define\tLVM_MOVEITEMTOGROUP\t(LVM_FIRST+154)\n#define\tLVM_REDRAWITEMS\t(LVM_FIRST+21)\n#define\tLVM_REMOVEALLGROUPS\t(LVM_FIRST+160)\n#define\tLVM_REMOVEGROUP\t(LVM_FIRST+150)\n#define\tLVM_SCROLL\t(LVM_FIRST+20)\n#define\tLVM_SETBKCOLOR\t(LVM_FIRST+1)\n#define\tLVM_SETBKIMAGEA\t(LVM_FIRST+68)\n#define\tLVM_SETBKIMAGEW\t(LVM_FIRST+138)\n#define\tLVM_SETCALLBACKMASK\t(LVM_FIRST+11)\n#define\tLVM_SETCOLUMNA\t(LVM_FIRST+26)\n#define\tLVM_SETCOLUMNORDERARRAY\t(LVM_FIRST+58)\n#define\tLVM_SETCOLUMNW\t(LVM_FIRST+96)\n#define\tLVM_SETCOLUMNWIDTH\t(LVM_FIRST+30)\n#define\tLVM_SETEXTENDEDLISTVIEWSTYLE\t(LVM_FIRST+54)\n#define\tLVM_SETGROUPINFO\t(LVM_FIRST+147)\n#define\tLVM_SETGROUPMETRICS\t(LVM_FIRST+155)\n#define\tLVM_SETHOTCURSOR\t(LVM_FIRST+62)\n#define\tLVM_SETHOTITEM\t(LVM_FIRST+60)\n#define\tLVM_SETHOVERTIME\t(LVM_FIRST+71)\n#define\tLVM_SETICONSPACING\t(LVM_FIRST+53)\n#define\tLVM_SETIMAGELIST\t(LVM_FIRST+3)\n#define\tLVM_SETINFOTIP\t(LVM_FIRST+173)\n#define\tLVM_SETINSERTMARK\t(LVM_FIRST+166)\n#define\tLVM_SETINSERTMARKCOLOR\t(LVM_FIRST+170)\n#define\tLVM_SETITEMA\t(LVM_FIRST+6)\n#define\tLVM_SETITEMCOUNT\t(LVM_FIRST+47)\n#define\tLVM_SETITEMPOSITION\t(LVM_FIRST+15)\n#define\tLVM_SETITEMPOSITION32\t(LVM_FIRST+49)\n#define\tLVM_SETITEMSTATE\t(LVM_FIRST+43)\n#define\tLVM_SETITEMTEXTA\t(LVM_FIRST+46)\n#define\tLVM_SETITEMTEXTW\t(LVM_FIRST+116)\n#define\tLVM_SETITEMW\t(LVM_FIRST+76)\n#define\tLVM_SETOUTLINECOLOR\t(LVM_FIRST+177)\n#define\tLVM_SETSELECTEDCOLUMN\t(LVM_FIRST+140)\n#define\tLVM_SETSELECTIONMARK\t(LVM_FIRST+67)\n#define\tLVM_SETTEXTBKCOLOR\t(LVM_FIRST+38)\n#define\tLVM_SETTEXTCOLOR\t(LVM_FIRST+36)\n#define\tLVM_SETTILEINFO\t(LVM_FIRST+164)\n#define\tLVM_SETTILEVIEWINFO\t(LVM_FIRST+162)\n#define\tLVM_SETTILEWIDTH\t(LVM_FIRST+141)\n#define\tLVM_SETTOOLTIPS\t(LVM_FIRST+74)\n#define\tLVM_SETVIEW\t(LVM_FIRST+142)\n#define\tLVM_SETWORKAREAS\t(LVM_FIRST+65)\n#define\tLVM_SORTGROUPS\t(LVM_FIRST+158)\n#define\tLVM_SORTITEMS\t(LVM_FIRST+48)\n#define\tLVM_SORTITEMSEX\t(LVM_FIRST+81)\n#define\tLVM_SUBITEMHITTEST\t(LVM_FIRST+57)\n#define\tLVM_UPDATE\t(LVM_FIRST+42)\n#define LVM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT\n#define LVM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT\n#define LVN_BEGINDRAG\t(-109)\n#define LVN_BEGINRDRAG\t(-111)\n#define LVN_COLUMNCLICK\t(-108)\n#define LVN_DELETEALLITEMS\t(-104)\n#define LVN_DELETEITEM\t(-103)\n#define LVN_BEGINLABELEDITW\t(-175)\n#define LVN_ENDLABELEDITW\t(-176)\n#define LVN_GETDISPINFOW\t(-177)\n#define LVN_SETDISPINFOW\t(-178)\n#define LVN_BEGINLABELEDITA\t(-105)\n#define LVN_ENDLABELEDITA\t(-106)\n#define LVN_GETDISPINFOA\t(-150)\n#define LVN_SETDISPINFOA\t(-151)\n#define LVN_INSERTITEM\t(-102)\n#define LVN_ITEMCHANGED\t(-101)\n#define LVN_ITEMCHANGING\t(-100)\n#define LVN_KEYDOWN\t(-155)\n#define LVN_ODCACHEHINT (-113)\n#define LVN_ODFINDITEMA (-152)\n#define LVN_ODFINDITEMW (-179)\n#define LVN_ODSTATECHANGED (-115)\n#define LVN_ITEMACTIVATE\t(LVN_FIRST-14)\n#define LV_MAX_WORKAREAS\t16\n#define LV_VIEW_ICON\t0\n#define LV_VIEW_DETAILS\t1\n#define LV_VIEW_SMALLICON\t2\n#define LV_VIEW_LIST\t3\n#define LV_VIEW_TILE\t4\n#define LV_VIEW_MAX\t4\n#define LVGF_NONE 0\n#define LVGF_HEADER\t1\n#define LVGF_FOOTER\t2\n#define LVGF_STATE\t4\n#define LVGF_ALIGN\t8\n#define LVGF_GROUPID\t0x10\n#define LVGS_NORMAL\t0\n#define LVGS_COLLAPSED\t1\n#define LVGS_HIDDEN\t2\n#define LVGA_HEADER_LEFT 1\n#define LVGA_HEADER_CENTER 2\n#define LVGA_HEADER_RIGHT 4\n#define LVGA_FOOTER_LEFT 8\n#define LVGA_FOOTER_CENTER 16\n#define LVGA_FOOTER_RIGHT 32\n#define LVGMF_NONE 0\n#define LVGMF_BORDERSIZE 1\n#define LVGMF_BORDERCOLOR 2\n#define LVGMF_TEXTCOLOR 4\n#define LVTVIF_AUTOSIZE 0\n#define LVTVIF_FIXEDWIDTH 1\n#define LVTVIF_FIXEDHEIGHT 2\n#define LVTVIF_FIXEDSIZE 3\n#define LVTVIM_TILESIZE 1\n#define LVTVIM_COLUMNS 2\n#define LVTVIM_LABELMARGIN 4\n#define LVIM_AFTER 1\n#define LVM_SETWORKAREAS\t(LVM_FIRST+65)\n#define LVM_GETWORKAREAS\t(LVM_FIRST+70)\n#define LVM_GETNUMBEROFWORKAREAS\t(LVM_FIRST+73)\n#define LVM_GETSELECTIONMARK\t(LVM_FIRST+66)\n#define LVM_SETSELECTIONMARK\t(LVM_FIRST+67)\n#define LVM_SETHOVERTIME\t(LVM_FIRST+71)\n#define LVM_GETHOVERTIME\t(LVM_FIRST+72)\n#define LVM_SETTOOLTIPS\t(LVM_FIRST+74)\n#define LVM_GETTOOLTIPS\t(LVM_FIRST+78)\n#define LVM_SORTITEMSEX\t(LVM_FIRST+81)\n#define LVBKIF_SOURCE_NONE\t0\n#define LVBKIF_SOURCE_HBITMAP\t1\n#define LVBKIF_SOURCE_URL\t2\n#define LVBKIF_SOURCE_MASK\t3\n#define LVBKIF_STYLE_NORMAL\t0\n#define LVBKIF_STYLE_TILE\t16\n#define LVBKIF_STYLE_MASK\t16\n#define LVBKIF_FLAG_TILEOFFSET\t0x00000100\n#define LVBKIF_TYPE_WATERMARK\t0x10000000\n#define LVM_SETBKIMAGEA\t\t(LVM_FIRST+68)\n#define LVM_SETBKIMAGEW\t\t(LVM_FIRST+138)\n#define LVM_GETBKIMAGEA\t\t(LVM_FIRST+69)\n#define LVM_GETBKIMAGEW\t\t(LVM_FIRST+139)\n#define LVKF_ALT\t1\n#define LVKF_CONTROL\t2\n#define LVKF_SHIFT\t4\n\n#ifdef UNICODE\n#define ENUMRESTYPEPROC\tENUMRESTYPEPROCW\n#define LVBKIMAGE\tLVBKIMAGEW\n#define LPLVBKIMAGE\tLPLVBKIMAGEW\n#define LVM_SETBKIMAGE\tLVM_SETBKIMAGEW\n#define LVM_GETBKIMAGE\tLVM_GETBKIMAGEW\n#define GetWindowModuleFileName GetWindowModuleFileNameW\n#define NMTOOLBAR\tNMTOOLBARW\n#define LPNMTOOLBAR\tLPNMTOOLBARW\n#define TCITEMHEADER\tTCITEMHEADERW\n#define LPTCITEMHEADER\tLPTCITEMHEADERW\n#else\n#define ENUMRESTYPEPROC\tENUMRESTYPEPROCA\n#define LVBKIMAGE\tLVBKIMAGEA\n#define LPLVBKIMAGE\tLPLVBKIMAGEA\n#define LVM_SETBKIMAGE\tLVM_SETBKIMAGEA\n#define LVM_GETBKIMAGE\tLVM_GETBKIMAGEA\n#define GetWindowModuleFileName GetWindowModuleFileNameA\n#define NMTOOLBAR\tNMTOOLBARA\n#define LPNMTOOLBAR\tLPNMTOOLBARA\n#define TCITEMHEADER\tTCITEMHEADERA\n#define LPTCITEMHEADER\tLPTCITEMHEADERA\n#endif\n\n#define NM_CLICK\t(-2)\n#define NM_DBLCLK\t(-3)\n#define NM_KILLFOCUS\t(-8)\n#define NM_OUTOFMEMORY\t(-1)\n#define NM_RCLICK\t(-5)\n#define NM_RDBLCLK\t(-6)\n#define NM_RETURN\t(-4)\n#define NM_SETFOCUS\t(-7)\n#define NM_KILLFOCUS\t(-8)\n#define NM_CUSTOMDRAW\t(-12)\n#define NM_HOVER\t(-13)\n#define NM_NCHITTEST\t(-14)\n#define NM_KEYDOWN\t(-15)\n#define NM_RELEASEDCAPTURE (-16)\n#define NM_SETCURSOR\t(-17)\n#define NM_CHAR\t\t(-18)\n#define NM_TOOLTIPSCREATED (-19)\n#define NM_LDOWN\t(-20)\n#define NM_THEMECHANGED (-22)\n#define NM_RDOWN\t(-21)\n#define NM_FIRST\t0\n#define NM_UPDOWN\tNMUPDOWN\n#define LPNM_UPDOWN\tLPNMUPDOWN\n#define PBM_DELTAPOS\t1027\n#define PBM_SETPOS\t1026\n#define PBM_SETRANGE\t1025\n#define PBM_SETSTEP\t1028\n#define PBM_STEPIT\t1029\n#define PSM_ADDPAGE\t1127\n#define PSM_APPLY\t1134\n#define PSM_CANCELTOCLOSE\t1131\n#define PSM_CHANGED\t1128\n#define PSM_GETTABCONTROL\t1140\n#define PSM_GETCURRENTPAGEHWND\t1142\n#define PSM_ISDIALOGMESSAGE\t1141\n#define PSM_PRESSBUTTON\t1137\n#define PSM_QUERYSIBLINGS\t1132\n#define PSM_REBOOTSYSTEM\t1130\n#define PSM_REMOVEPAGE\t1126\n#define PSM_RESTARTWINDOWS\t1129\n#define PSM_SETCURSEL\t1125\n#define PSM_SETCURSELID\t1138\n#define PSM_SETFINISHTEXTW\t1145\n#define PSM_SETTITLEW\t1144\n#define PSM_SETFINISHTEXTA\t1139\n#define PSM_SETTITLEA\t1135\n#define PSM_SETWIZBUTTONS\t1136\n#define PSM_UNCHANGED\t1133\n#define PSN_APPLY\t(-202)\n#define PSN_HELP\t(-205)\n#define PSN_KILLACTIVE\t(-201)\n#define PSN_QUERYCANCEL\t(-209)\n#define PSN_RESET\t(-203)\n#define PSN_SETACTIVE\t(-200)\n#define PSN_WIZBACK\t(-206)\n#define PSN_WIZFINISH\t(-208)\n#define PSN_WIZNEXT\t(-207)\n#define SB_GETBORDERS\t1031\n#define SB_GETPARTS\t1030\n#define SB_GETRECT\t1034\n#define SB_GETTEXTW\t1037\n#define SB_GETTEXTLENGTHW\t1036\n#define SB_SETTEXTW\t1035\n#define SB_GETTEXTA\t1026\n#define SB_GETTEXTLENGTHA\t1027\n#define SB_SETTEXTA\t1025\n#define SB_SETMINHEIGHT\t1032\n#define SB_SETPARTS\t1028\n#define SB_SIMPLE\t1033\n#define SBM_ENABLE_ARROWS\t228\n#define SBM_GETPOS\t225\n#define SBM_GETRANGE\t227\n#define SBM_GETSCROLLINFO\t234\n#define SBM_SETPOS\t224\n#define SBM_SETRANGE\t226\n#define SBM_SETRANGEREDRAW\t230\n#define SBM_SETSCROLLINFO\t233\n#define STM_GETICON\t369\n#define STM_GETIMAGE\t371\n#define STM_SETICON\t368\n#define STM_SETIMAGE\t370\n#define STN_CLICKED\t0\n#define STN_DBLCLK\t1\n#define STN_DISABLE\t3\n#define STN_ENABLE\t2\n#define TB_ADDBITMAP\t1043\n#define TB_ADDBUTTONS\t1044\n#define TB_AUTOSIZE\t1057\n#define TB_BUTTONCOUNT\t1048\n#define TB_BUTTONSTRUCTSIZE\t1054\n#define TB_CHANGEBITMAP\t1067\n#define TB_CHECKBUTTON\t1026\n#define TB_COMMANDTOINDEX\t1049\n#define TB_CUSTOMIZE\t1051\n#define TB_DELETEBUTTON\t1046\n#define TB_ENABLEBUTTON\t1025\n#define TB_GETBITMAP\t1068\n#define TB_GETBITMAPFLAGS\t1065\n#define TB_GETBUTTON\t1047\n#define TB_ADDSTRINGW\t1101\n#define TB_GETBUTTONTEXTW\t1099\n#define TB_SAVERESTOREW\t1100\n#define TB_ADDSTRINGA\t1052\n#define TB_GETBUTTONTEXTA\t1069\n#define TB_SAVERESTOREA\t1050\n#define TB_GETITEMRECT\t1053\n#define TB_GETROWS\t1064\n#define TB_GETSTATE\t1042\n#define TB_GETTOOLTIPS\t1059\n#define TB_HIDEBUTTON\t1028\n#define TB_INDETERMINATE\t1029\n#define TB_INSERTBUTTON\t1045\n#define TB_INSERTBUTTONW\t(WM_USER+67)\n#define TB_ADDBUTTONSW\t(WM_USER+68)\n#define TB_HITTEST\t(WM_USER+69)\n#define TB_ISBUTTONCHECKED\t1034\n#define TB_ISBUTTONENABLED\t1033\n#define TB_ISBUTTONHIDDEN\t1036\n#define TB_ISBUTTONINDETERMINATE\t1037\n#define TB_ISBUTTONPRESSED\t1035\n#define TB_PRESSBUTTON\t1027\n#define TB_SETBITMAPSIZE\t1056\n#define TB_SETBUTTONSIZE\t1055\n#define TB_SETCMDID\t1066\n#define TB_SETPARENT\t1061\n#define TB_SETROWS\t1063\n#define TB_SETSTATE\t1041\n#define TB_SETTOOLTIPS\t1060\n#define TB_HITTEST\t(WM_USER+69)\n#define TB_REPLACEBITMAP (WM_USER+46)\n#define TB_SETINDENT\t(WM_USER+47)\n#define TB_SETIMAGELIST\t(WM_USER+48)\n#define TB_GETIMAGELIST\t(WM_USER+49)\n#define TB_LOADIMAGES\t(WM_USER+50)\n#define TB_GETRECT\t(WM_USER+51)\n#define TB_SETHOTIMAGELIST\t(WM_USER+52)\n#define TB_GETHOTIMAGELIST\t(WM_USER+53)\n#define TB_SETDISABLEDIMAGELIST (WM_USER+54)\n#define TB_GETDISABLEDIMAGELIST\t(WM_USER+55)\n#define TB_SETSTYLE\t(WM_USER+56)\n#define TB_GETSTYLE\t(WM_USER+57)\n#define TB_GETBUTTONSIZE\t(WM_USER+58)\n#define TB_SETBUTTONWIDTH\t(WM_USER+59)\n#define TB_SETMAXTEXTROWS\t(WM_USER+60)\n#define TB_GETTEXTROWS\t(WM_USER+61)\n#define TB_GETINSERTMARK\t(WM_USER+79)\n#define TB_SETINSERTMARK\t(WM_USER+80)\n#define TB_INSERTMARKHITTEST\t(WM_USER+81)\n#define TB_MOVEBUTTON\t\t(WM_USER+82)\n#define TB_GETMAXSIZE\t\t(WM_USER+83)\n#define TB_SETEXTENDEDSTYLE\t(WM_USER+84)\n#define TB_GETEXTENDEDSTYLE\t(WM_USER+85)\n#define TB_GETPADDING\t\t(WM_USER+86)\n#define TB_SETPADDING\t\t(WM_USER+87)\n#define TB_SETINSERTMARKCOLOR\t(WM_USER+88)\n#define TB_GETINSERTMARKCOLOR\t(WM_USER+89)\n#define TB_SETCOLORSCHEME\tCCM_SETCOLORSCHEME\n#define TB_GETCOLORSCHEME\tCCM_GETCOLORSCHEME\n#define TB_SETUNICODEFORMAT\tCCM_SETUNICODEFORMAT\n#define TB_GETUNICODEFORMAT\tCCM_GETUNICODEFORMAT\n#define TB_MAPACCELERATORW\t(WM_USER+90)\n#define TB_ADDBUTTONSA\t\t(WM_USER + 20)\n#define TB_INSERTBUTTONA\t(WM_USER + 21)\n#define TB_GETOBJECT\t\t(WM_USER + 62)\n#define TB_GETHOTITEM\t\t(WM_USER + 71)\n#define TB_SETHOTITEM\t\t(WM_USER + 72)\n#define TB_SETANCHORHIGHLIGHT\t(WM_USER + 73)\n#define TB_GETANCHORHIGHLIGHT\t(WM_USER + 74)\n#define TB_GETBUTTONINFOW\t(WM_USER + 63)\n#define TB_SETBUTTONINFOW\t(WM_USER + 64)\n#define TB_SETDRAWTEXTFLAGS\t(WM_USER + 70)\n#define TB_GETSTRINGW\t\t(WM_USER + 91)\n#define TB_GETSTRINGA\t\t(WM_USER + 92)\n#define TB_GETMETRICS\t\t(WM_USER + 101)\n#define TB_SETMETRICS\t\t(WM_USER + 102)\n#define TB_SETWINDOWTHEME     CCM_SETWINDOWTHEME\n#define TBNF_IMAGE\t1\n#define TBNF_TEXT\t2\n#define TBNF_DI_SETITEM 0x10000000\n#define HICF_OTHER\t0\n#define HICF_MOUSE\t1\n#define HICF_ARROWKEYS\t2\n#define HICF_ACCELERATOR 4\n#define HICF_DUPACCEL\t8\n#define HICF_ENTERING\t0x10\n#define HICF_LEAVING\t0x20\n#define HICF_RESELECT\t0x40\n#define HICF_LMOUSE\t0x80\n#define HICF_TOGGLEDROPDOWN 0x100\n#define WMN_FIRST\t(0U-1000U)\n#define WMN_LAST\t(0U-1200U)\n#define BCN_FIRST\t(0U-1250U)\n#define BCN_HOTITEMCHANGE (BCN_FIRST + 0x0001)\n#define BCN_LAST\t(0U-1350U)\n#define BST_HOT 0x0200\n#define MSGF_COMMCTRL_BEGINDRAG\t0x4200\n#define CDIS_SHOWKEYBOARDCUES\t0x0200\n#define MSGF_COMMCTRL_SIZEHEADER\t0x4201\n#define MSGF_COMMCTRL_DRAGSELECT\t0x4202\n#define MSGF_COMMCTRL_TOOLBARCUST\t0x4203\n\n#ifdef UNICODE\n#define TB_GETSTRING TB_GETSTRINGW\n#define TB_MAPACCELERATOR\tTB_MAPACCELERATORW\n#else\n#define TB_GETSTRING TB_GETSTRINGA\n#define TB_MAPACCELERATOR\tTB_MAPACCELERATORA\n#endif\n\n#define TBMF_PAD 1\n#define TBMF_BARPAD 2\n#define TBMF_BUTTONSPACING 4\n#define TBBF_LARGE\t1\n#define TBIF_IMAGE\t1\n#define TBIF_TEXT\t2\n#define TBIF_STATE\t4\n#define TBIF_STYLE\t8\n#define TBIF_LPARAM\t16\n#define TBIF_COMMAND\t32\n#define TBIF_SIZE\t64\n#define TBIF_BYINDEX\t0x80000000\n#define PGS_VERT\t0\n#define PGS_HORZ\t1\n#define PGS_AUTOSCROLL\t2\n#define PGS_DRAGNDROP\t4\n#define PGF_INVISIBLE\t0\n#define PGF_NORMAL\t1\n#define PGF_GRAYED\t2\n#define PGF_DEPRESSED\t4\n#define PGF_HOT\t8\n#define PGB_TOPORLEFT\t0\n#define PGB_BOTTOMORRIGHT 1\n#define PGM_SETCHILD\t(PGM_FIRST+1)\n#define Pager_SetChild(h,C) (void)SendMsg((h),PGM_SETCHILD,0,(LPARAM)(C))\n#define PGM_RECALCSIZE\t(PGM_FIRST+2)\n#define Pager_RecalcSize(hwnd) (void)SendMessage((hwnd),PGM_RECALCSIZE,0,0)\n#define PGM_FORWARDMOUSE\t(PGM_FIRST+3)\n#define Pager_ForwardMouse(hwnd,F) (void)SendMessage((hwnd), PGM_FORWARDMOUSE, (WPARAM)(F),0)\n#define PGM_SETBKCOLOR\t(PGM_FIRST+4)\n#define Pager_SetBkColor(h,c) (COLORREF)SendMessage((h),PGM_SETBKCOLOR,0,(LPARAM)(c))\n#define PGM_GETBKCOLOR\t(PGM_FIRST+5)\n#define Pager_GetBkColor(h) (COLORREF)SendMessage((h),PGM_GETBKCOLOR,0,0)\n#define PGM_SETBORDER\t(PGM_FIRST+6)\n#define Pager_SetBorder(h,B) (int)SNDMSG((h),PGM_SETBORDER,0,(LPARAM)(B))\n#define PGM_GETBORDER\t(PGM_FIRST+7)\n#define Pager_GetBorder(hwnd) (int)SNDMSG((hwnd),PGM_GETBORDER,0,0)\n#define PGM_SETPOS\t(PGM_FIRST+8)\n#define Pager_SetPos(hwnd, iPos) (int)SNDMSG((hwnd),PGM_SETPOS,0,(LPARAM)(iPos))\n#define PGM_GETPOS\t(PGM_FIRST+9)\n#define Pager_GetPos(hwnd) (int)SNDMSG((hwnd),PGM_GETPOS,0,0)\n#define PGM_SETBUTTONSIZE\t(PGM_FIRST+10)\n#define Pager_SetButtonSize(hwnd, iSize) (int)SNDMSG((hwnd), PGM_SETBUTTONSIZE, 0, (LPARAM)(iSize))\n#define PGM_GETBUTTONSIZE\t(PGM_FIRST+11)\n#define Pager_GetButtonSize(hwnd) (int)SNDMSG((hwnd),PGM_GETBUTTONSIZE, 0,0)\n#define PGM_GETBUTTONSTATE\t(PGM_FIRST+12)\n#define Pager_GetButtonState(hwnd, iButton) (DWORD)SNDMSG((hwnd), PGM_GETBUTTONSTATE, 0, (LPARAM)(iButton))\n#define PGM_GETDROPTARGET\tCCM_GETDROPTARGET\n#define Pager_GetDropTarget(h,t) (void)SNDMSG((h),PGM_GETDROPTARGET,0,(LPARAM)(t))\n#define PGN_SCROLL\t(PGN_FIRST-1)\n#define PGN_CALCSIZE\t(PGN_FIRST-2)\n#define PGF_CALCWIDTH\t1\n#define PGF_CALCHEIGHT\t2\n#define PGF_SCROLLUP\t1\n#define PGF_SCROLLDOWN\t2\n#define PGF_SCROLLLEFT\t4\n#define PGF_SCROLLRIGHT\t8\n#define PGK_SHIFT\t1\n#define PGK_CONTROL\t2\n#define PGK_MENU\t4\n#define TBM_CLEARSEL\t1043\n#define TBM_CLEARTICS\t1033\n#define TBM_GETCHANNELRECT\t1050\n#define TBM_GETLINESIZE\t1048\n#define TBM_GETNUMTICS\t1040\n#define TBM_GETPAGESIZE\t1046\n#define TBM_GETPOS\t1024\n#define TBM_GETPTICS\t1038\n#define TBM_GETRANGEMAX\t1026\n#define TBM_GETRANGEMIN\t1025\n#define TBM_GETSELEND\t1042\n#define TBM_GETSELSTART\t1041\n#define TBM_GETTHUMBLENGTH\t1052\n#define TBM_GETTHUMBRECT\t1049\n#define TBM_GETTIC\t1027\n#define TBM_GETTICPOS\t1039\n#define TBM_SETLINESIZE\t1047\n#define TBM_SETPAGESIZE\t1045\n#define TBM_SETPOS\t1029\n#define TBM_SETRANGE\t1030\n#define TBM_SETRANGEMAX\t1032\n#define TBM_SETRANGEMIN\t1031\n#define TBM_SETSEL\t1034\n#define TBM_SETSELEND\t1036\n#define TBM_SETSELSTART\t1035\n#define TBM_SETTHUMBLENGTH\t1051\n#define TBM_SETTIC\t1028\n#define TBM_SETTICFREQ\t1044\n#define TBM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT\n#define TBM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT\n#define\tTBN_FIRST\t(-700U)\n#define TBN_BEGINADJUST\t(-703U)\n#define TBN_BEGINDRAG\t(-701U)\n#define TBN_CUSTHELP\t(-709U)\n#define TBN_ENDADJUST\t(-704U)\n#define TBN_ENDDRAG\t(-702U)\n#define TBN_GETBUTTONINFOW\t(-720U)\n#define TBN_GETBUTTONINFOA\t(-700U)\n#define TBN_QUERYDELETE\t(-707U)\n#define TBN_QUERYINSERT\t(-706U)\n#define TBN_RESET\t(-705U)\n#define TBN_TOOLBARCHANGE\t(-708U)\n#define TBN_GETDISPINFOA\t(TBN_FIRST-16)\n#define TBN_GETDISPINFOW\t(TBN_FIRST-17)\n#define TBN_HOTITEMCHANGE\t(TBN_FIRST - 13)\n#define TBN_DRAGOUT\t(TBN_FIRST - 14)\n#define TBN_DELETINGBUTTON\t(TBN_FIRST - 15)\n#define TBN_GETINFOTIPA\t(TBN_FIRST - 18)\n#define TBN_GETINFOTIPW\t(TBN_FIRST - 19)\n#define TBN_RESTORE\t(TBN_FIRST - 21)\n#define TBN_SAVE\t(TBN_FIRST - 22)\n#define TBN_INITCUSTOMIZE\t(TBN_FIRST - 23)\n#define TBN_DROPDOWN\t(TBN_FIRST-10)\n#define TBN_GETOBJECT\t(TBN_FIRST-12)\n#define TBNRF_HIDEHELP\t1\n#define TBNRF_ENDCUSTOMIZE\t2\n#define TBDDRET_DEFAULT\t0\n#define TBDDRET_NODEFAULT\t1\n#define TBDDRET_TREATPRESSED\t2\n#define TBN_LAST\t(-720U)\n#define TCM_FIRST\t0x1300\n#define TCM_ADJUSTRECT\t4904\n#define TCM_DELETEALLITEMS\t4873\n#define TCM_DELETEITEM\t4872\n#define TCM_GETCURFOCUS\t4911\n#define TCM_GETCURSEL\t4875\n#define TCM_GETIMAGELIST\t4866\n#define TCM_GETITEMW\t4924\n#define TCM_INSERTITEMW\t4926\n#define TCM_SETITEMW\t4925\n#define TCM_GETITEMA\t4869\n#define TCM_INSERTITEMA\t4871\n#define TCM_SETITEMA\t4870\n#define TCM_GETITEMCOUNT\t4868\n#define TCM_GETITEMRECT\t4874\n#define TCM_GETROWCOUNT\t4908\n#define TCM_GETTOOLTIPS\t4909\n#define TCM_HITTEST\t4877\n#define TCM_REMOVEIMAGE\t4906\n#define TCM_SETCURFOCUS\t4912\n#define TCM_SETCURSEL\t4876\n#define TCM_SETIMAGELIST\t4867\n#define TCM_SETITEMEXTRA\t4878\n#define TCM_SETITEMSIZE\t4905\n#define TCM_SETPADDING\t4907\n#define TCM_SETTOOLTIPS\t4910\n#define TCM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT\n#define TCM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT\n#define TCM_SETMINTABWIDTH\t(TCM_FIRST+49)\n#define TCM_DESELECTALL\t(TCM_FIRST+50)\n#define TCM_HIGHLIGHTITEM\t(TCM_FIRST+51)\n#define TCM_SETEXTENDEDSTYLE\t(TCM_FIRST+52)\n#define TCM_GETEXTENDEDSTYLE\t(TCM_FIRST+53)\n#define TCM_SETUNICODEFORMAT\tCCM_SETUNICODEFORMAT\n#define TCM_GETUNICODEFORMAT\tCCM_GETUNICODEFORMAT\n#define TCN_KEYDOWN\t(-550)\n#define TCN_SELCHANGE\t(-551)\n#define TCN_SELCHANGING\t(-552)\n#define TCN_GETOBJECT\t(TCN_FIRST-3)\n#define TTM_ACTIVATE\t1025\n#define TTM_ADDTOOLW\t1074\n#define TTM_DELTOOLW\t1075\n#define TTM_ENUMTOOLSW\t1082\n#define TTM_GETCURRENTTOOLW\t1083\n#define TTM_SETWINDOWTHEME\tCCM_SETWINDOWTHEME\n#define TTM_GETTEXTW\t1080\n#define TTM_GETTOOLINFOW\t1077\n#define TTM_HITTESTW\t1079\n#define TTM_NEWTOOLRECTW\t1076\n#define TTM_SETTOOLINFOW\t1078\n#define TTM_UPDATETIPTEXTW\t1081\n#define TTM_ADDTOOLA\t1028\n#define TTM_DELTOOLA\t1029\n#define TTM_ENUMTOOLSA\t1038\n#define TTM_GETCURRENTTOOLA\t1039\n#define TTM_GETTEXTA\t1035\n#define TTM_GETTOOLINFOA\t1032\n#define TTM_HITTESTA\t1034\n#define TTM_NEWTOOLRECTA\t1030\n#define TTM_SETTOOLINFOA\t1033\n#define TTM_UPDATETIPTEXTA\t1036\n#define TTM_GETTOOLCOUNT\t1037\n#define TTM_RELAYEVENT\t1031\n#define TTM_SETDELAYTIME\t1027\n#define TTM_WINDOWFROMPOINT\t1040\n#define\tTTM_POP (WM_USER+28)\n#define TTM_SETMARGIN\t(WM_USER+26)\n#define TTM_GETMARGIN\t(WM_USER+27)\n#define TTM_GETMAXTIPWIDTH\t(WM_USER+25)\n#define TTM_SETMAXTIPWIDTH\t(WM_USER+24)\n#define TTM_TRACKACTIVATE\t(WM_USER+17)\n#define TTM_TRACKPOSITION\t(WM_USER+18)\n#define TTM_SETTIPBKCOLOR\t(WM_USER+19)\n#define TTM_SETTIPTEXTCOLOR\t(WM_USER+20)\n#define TTM_GETDELAYTIME\t(WM_USER+21)\n#define TTM_GETTIPBKCOLOR\t(WM_USER+22)\n#define TTM_GETTIPTEXTCOLOR\t(WM_USER+23)\n#define TTM_GETBUBBLESIZE\t(WM_USER + 30)\n#define TTM_ADJUSTRECT\t(WM_USER+31)\n#define TTM_SETTITLEA\t(WM_USER+32)\n#define TTM_SETTITLEW\t(WM_USER+33)\n#define TTM_POPUP\t(WM_USER + 34)\n#define TTM_GETTITLE\t(WM_USER + 35)\n#define TTN_GETDISPINFOA\t(TTN_FIRST-0)\n#define TTN_GETDISPINFOW\t(TTN_FIRST-10)\n#define TTN_SHOW\t(TTN_FIRST-1)\n#define TTN_POP\t(TTN_FIRST - 2)\n#define TTN_NEEDTEXTW\t(-530)\n#define TTN_NEEDTEXTA\t(-520)\n#define TVM_FIRST\t0x1100\n#define TV_FIRST\t0x1100\n#define TVM_INSERTITEMA\t(TV_FIRST)\n#define TVM_INSERTITEMW\t(TV_FIRST+50)\n#define TVM_GETTOOLTIPS\t(TV_FIRST+25)\n#define TVM_SETTOOLTIPS\t(TV_FIRST+24)\n#define TVM_SETITEMHEIGHT\t(TV_FIRST + 27)\n#define TVM_GETITEMHEIGHT\t(TV_FIRST + 28)\n#define TVM_SETBKCOLOR\t(TV_FIRST + 29)\n#define TVM_SETTEXTCOLOR\t(TV_FIRST + 30)\n#define TVM_GETBKCOLOR\t(TV_FIRST + 31)\n#define TVM_GETTEXTCOLOR\t(TV_FIRST + 32)\n#define TVM_SETSCROLLTIME\t(TV_FIRST + 33)\n#define TVM_GETSCROLLTIME\t(TV_FIRST + 34)\n#define TVM_SETINSERTMARKCOLOR\t(TV_FIRST + 37)\n#define TVM_GETINSERTMARKCOLOR\t(TV_FIRST + 38)\n#define TVM_CREATEDRAGIMAGE\t4370\n#define TVM_DELETEITEM\t4353\n#define TVM_ENDEDITLABELNOW\t4374\n#define TVM_ENSUREVISIBLE\t4372\n#define TVM_EXPAND\t4354\n#define TVM_GETCOUNT\t4357\n#define TVM_GETEDITCONTROL\t4367\n#define TVM_GETIMAGELIST\t4360\n#define TVM_GETINDENT\t4358\n#define TVM_GETITEMSTATE\t(TV_FIRST+39)\n#define TVM_SETLINECOLOR\t(TV_FIRST+40)\n#define TVM_GETLINECOLOR\t(TV_FIRST+41)\n#define TVM_GETITEMRECT\t4356\n#define TVM_GETNEXTITEM\t4362\n#define TVM_GETVISIBLECOUNT\t4368\n#define TVM_HITTEST\t4369\n#define TVM_EDITLABELW\t4417\n#define TVM_GETISEARCHSTRINGW\t4416\n#define TVM_GETITEMW\t4414\n#define TVM_SETITEMW\t4415\n#define TVM_EDITLABELA\t4366\n#define TVM_GETISEARCHSTRINGA\t4375\n#define TVM_GETITEMA\t4364\n#define TVM_SETITEMA\t4365\n#define TVM_SELECTITEM\t4363\n#define TVM_SETIMAGELIST\t4361\n#define TVM_SETINDENT\t4359\n#define TVM_SORTCHILDREN\t4371\n#define TVM_SORTCHILDRENCB\t4373\n#define TVM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT\n#define TVM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT\n#define TVN_KEYDOWN\t(-412)\n#define TVN_BEGINDRAGW\t(-456)\n#define TVN_BEGINLABELEDITW\t(-459)\n#define TVN_BEGINRDRAGW\t(-457)\n#define TVN_DELETEITEMW\t(-458)\n#define TVN_ENDLABELEDITW\t(-460)\n#define TVN_GETDISPINFOW\t(-452)\n#define TVN_ITEMEXPANDEDW\t(-455)\n#define TVN_ITEMEXPANDINGW\t(-454)\n#define TVN_SELCHANGEDW\t(-451)\n#define TVN_SELCHANGINGW\t(-450)\n#define TVN_SETDISPINFOW\t(-453)\n#define TVN_BEGINDRAGA\t(-407)\n#define TVN_BEGINLABELEDITA\t(-410)\n#define TVN_BEGINRDRAGA\t(-408)\n#define TVN_DELETEITEMA\t(-409)\n#define TVN_ENDLABELEDITA\t(-411)\n#define TVN_GETDISPINFOA\t(-403)\n#define TVN_ITEMEXPANDEDA\t(-406)\n#define TVN_ITEMEXPANDINGA\t(-405)\n#define TVN_SELCHANGEDA\t(-402)\n#define TVN_SELCHANGINGA\t(-401)\n#define TVN_SETDISPINFOA\t(-404)\n#define UDM_GETACCEL\t1132\n#define UDM_GETBASE\t1134\n#define UDM_GETBUDDY\t1130\n#define UDM_GETPOS\t1128\n#define UDM_GETRANGE\t1126\n#define UDM_SETACCEL\t1131\n#define UDM_SETBASE\t1133\n#define UDM_SETBUDDY\t1129\n#define UDM_SETPOS\t1127\n#define UDM_SETRANGE\t1125\n#define UDM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT\n#define UDM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT\n#define UDN_DELTAPOS\t(-722)\n\n#define WM_NULL\t0\n#define WM_APP\t0x8000\n#define WM_ACTIVATE\t6\n#define WM_ACTIVATEAPP\t28\n#define WM_ASKCBFORMATNAME\t780\n#define WM_CANCELJOURNAL\t75\n#define WM_CANCELMODE\t31\n#define WM_CAPTURECHANGED\t533\n#define WM_CHANGECBCHAIN\t781\n#define WM_CHAR\t258\n#define WM_CHARTOITEM\t47\n#define WM_CHILDACTIVATE\t34\n#define WM_CHOOSEFONT_GETLOGFONT\t1025\n#define WM_CHOOSEFONT_SETLOGFONT\t1125\n#define WM_CHOOSEFONT_SETFLAGS\t1126\n#define WM_CLEAR\t771\n#define WM_CLOSE\t16\n#define WM_COMMAND\t273\n#define WM_COMPACTING\t65\n#define WM_COMPAREITEM\t57\n#define WM_CONTEXTMENU\t123\n#define WM_COPY\t769\n#define WM_COPYDATA\t74\n#define WM_CREATE\t1\n#define WM_CTLCOLORBTN\t309\n#define WM_CTLCOLORDLG\t310\n#define WM_CTLCOLOREDIT\t307\n#define WM_CTLCOLORLISTBOX\t308\n#define WM_CTLCOLORMSGBOX\t306\n#define WM_CTLCOLORSCROLLBAR\t311\n#define WM_CTLCOLORSTATIC\t312\n#define WM_CUT\t768\n#define WM_DEADCHAR\t259\n#define WM_DELETEITEM\t45\n#define WM_DESTROY\t2\n#define WM_DESTROYCLIPBOARD\t775\n#define WM_DEVICECHANGE\t537\n#define WM_DEVMODECHANGE\t27\n#define WM_DISPLAYCHANGE\t126\n#define WM_DRAWCLIPBOARD\t776\n#define WM_DRAWITEM\t43\n#define WM_DROPFILES\t563\n#define WM_ENABLE\t10\n#define WM_ENDSESSION\t22\n#define WM_ENTERIDLE\t289\n#define WM_ENTERMENULOOP\t529\n#define WM_ENTERSIZEMOVE\t561\n#define WM_ERASEBKGND\t20\n#define WM_EXITMENULOOP\t530\n#define WM_EXITSIZEMOVE\t562\n#define WM_FONTCHANGE\t29\n#define WM_GETDLGCODE\t135\n#define WM_GETFONT\t49\n#define WM_GETHOTKEY\t51\n#define WM_GETICON\t127\n#define WM_GETMINMAXINFO\t36\n#define WM_GETTEXT\t13\n#define WM_GETTEXTLENGTH\t14\n#define WM_HELP\t83\n#define WM_HOTKEY\t786\n#define WM_HSCROLL\t276\n#define WM_HSCROLLCLIPBOARD\t782\n#define WM_ICONERASEBKGND\t39\n#define WM_IME_CHAR\t646\n#define WM_IME_COMPOSITION\t271\n#define WM_IME_COMPOSITIONFULL\t644\n#define WM_IME_CONTROL\t643\n#define WM_IME_ENDCOMPOSITION\t270\n#define WM_IME_KEYDOWN\t656\n#define WM_IME_KEYUP\t657\n#define WM_IME_NOTIFY\t642\n#define WM_IME_SELECT\t645\n#define WM_IME_SETCONTEXT\t641\n#define WM_IME_STARTCOMPOSITION\t269\n#define WM_INITDIALOG\t272\n#define WM_INITMENU\t278\n#define WM_INITMENUPOPUP\t279\n#define WM_INPUTLANGCHANGE\t81\n#define WM_INPUTLANGCHANGEREQUEST\t80\n#define WM_INPUT 0xff\n#define WM_KEYDOWN\t256\n#define WM_KEYUP\t257\n#define WM_KILLFOCUS\t8\n#define WM_LBUTTONDBLCLK\t515\n#define WM_LBUTTONDOWN\t513\n#define WM_LBUTTONUP\t514\n#define WM_MBUTTONDBLCLK\t521\n#define WM_MBUTTONDOWN\t519\n#define WM_MBUTTONUP\t520\n#define WM_MDIACTIVATE\t546\n#define WM_MDICASCADE\t551\n#define WM_MDICREATE\t544\n#define WM_MDIDESTROY\t545\n#define WM_MDIGETACTIVE\t553\n#define WM_MDIICONARRANGE\t552\n#define WM_MDIMAXIMIZE\t549\n#define WM_MDINEXT\t548\n#define WM_MDIREFRESHMENU\t564\n#define WM_MDIRESTORE\t547\n#define WM_MDISETMENU\t560\n#define WM_MDITILE\t550\n#define WM_MEASUREITEM\t44\n#define WM_MENUCHAR\t288\n#define WM_MENUSELECT\t287\n#define WM_MENURBUTTONUP 0x0122\n#define WM_MENUDRAG\t0x0123\n#define WM_MENUGETOBJECT 0x0124\n#define WM_UNINITMENUPOPUP 0x0125\n#define WM_MENUCOMMAND\t0x0126\n#define WM_CHANGEUISTATE 0x0127\n#define WM_UPDATEUISTATE 0x0128\n#define WM_QUERYUISTATE\t0x0129\n#define UIS_SET\t1\n#define UIS_CLEAR\t2\n#define UIS_INITIALIZE 3\n#define WM_MOUSEACTIVATE\t33\n#define WM_MOUSEMOVE\t512\n#define WM_MOUSEHOVER\t0x2a1\n#define WM_MOUSELEAVE\t0x2a3\n#define WM_MOUSEWHEEL\t0x20A\n#define WM_MOVE\t3\n#define WM_MOVING\t534\n#define WM_NCACTIVATE\t134\n#define WM_NCCALCSIZE\t131\n#define WM_NCCREATE\t129\n#define WM_NCDESTROY\t130\n#define WM_NCHITTEST\t132\n#define WM_NCLBUTTONDBLCLK\t163\n#define WM_NCLBUTTONDOWN\t161\n#define WM_NCLBUTTONUP\t162\n#define WM_NCMBUTTONDBLCLK\t169\n#define WM_NCMBUTTONDOWN\t167\n#define WM_NCMBUTTONUP\t168\n#define WM_NCMOUSEMOVE\t160\n#define WM_NCPAINT\t133\n#define WM_NCRBUTTONDBLCLK\t166\n#define WM_NCRBUTTONDOWN\t164\n#define WM_NCRBUTTONUP\t165\n#define WM_NEXTDLGCTL\t40\n#define WM_NOTIFY\t78\n#define WM_NOTIFYFORMAT\t85\n#define WM_PAINT\t15\n#define WM_PAINTCLIPBOARD\t777\n#define WM_PAINTICON\t38\n#define WM_PALETTECHANGED\t785\n#define WM_PALETTEISCHANGING\t784\n#define WM_PARENTNOTIFY\t528\n#define WM_PASTE\t770\n#define WM_PENWINFIRST\t896\n#define WM_SYNCPAINT\t0x0088\n#define WM_AFXFIRST\t0x0360\n#define WM_AFXLAST\t0x037F\n#define WM_HANDHELDFIRST 0x0358\n#define WM_HANDHELDLAST 0x035F\n#define WM_PENWINLAST\t911\n#define WM_POWER\t72\n#define WM_POWERBROADCAST\t536\n#define WM_PRINT\t791\n#define WM_PRINTCLIENT\t792\n#define WM_PSD_ENVSTAMPRECT\t1029\n#define WM_PSD_FULLPAGERECT\t1025\n#define WM_PSD_GREEKTEXTRECT\t1028\n#define WM_PSD_MARGINRECT\t1027\n#define WM_PSD_MINMARGINRECT\t1026\n#define WM_PSD_PAGESETUPDLG\t1024\n#define WM_PSD_YAFULLPAGERECT\t1030\n#define WM_QUERYDRAGICON\t55\n#define WM_QUERYENDSESSION\t17\n#define WM_QUERYNEWPALETTE\t783\n#define WM_QUERYOPEN\t19\n#define WM_QUEUESYNC\t35\n#define WM_QUIT\t18\n#define WM_RBUTTONDBLCLK\t518\n#define WM_RBUTTONDOWN\t516\n#define WM_RBUTTONUP\t517\n#define WM_RENDERALLFORMATS\t774\n#define WM_RENDERFORMAT\t773\n#define WM_SETCURSOR\t32\n#define WM_SETFOCUS\t7\n#define WM_SETFONT\t48\n#define WM_SETHOTKEY\t50\n#define WM_SETICON\t128\n#define WM_SETREDRAW\t11\n#define WM_SETTEXT\t12\n#define WM_SETTINGCHANGE\t26\n#define WM_SHOWWINDOW\t24\n#define WM_SIZE\t5\n#define WM_SIZECLIPBOARD\t779\n#define WM_SIZING\t532\n#define WM_SPOOLERSTATUS\t42\n#define WM_STYLECHANGED\t125\n#define WM_STYLECHANGING\t124\n#define WM_SYSCHAR\t262\n#define WM_SYSCOLORCHANGE\t21\n#define WM_SYSCOMMAND\t274\n#define WM_SYSDEADCHAR\t263\n#define WM_SYSKEYDOWN\t260\n#define WM_SYSKEYUP\t261\n#define WM_TCARD\t82\n#define WM_TIMECHANGE\t30\n#define WM_TIMER\t275\n#define WM_UNDO\t772\n#define WM_USER\t1024\n#define WM_USERCHANGED\t84\n#define WM_VKEYTOITEM\t46\n#define WM_VSCROLL\t277\n#define WM_VSCROLLCLIPBOARD\t778\n#define WM_WINDOWPOSCHANGED\t71\n#define WM_WINDOWPOSCHANGING\t70\n#define WM_XBUTTONDOWN\t0x020B\n#define WM_XBUTTONUP\t0x020C\n#define WM_XBUTTONDBLCLK\t0x020D\n#define WM_WININICHANGE\t26\n#define WM_KEYFIRST\t256\n#define WM_KEYLAST\t264\n#define WM_MOUSEFIRST\t512\n#define WM_MOUSELAST 0x020D\n#define WM_NEXTMENU\t0x0213\n#define WM_CHANGEUISTATE\t0x0127\n#define WM_UPDATEUISTATE\t0x0128\n#define WM_QUERYUISTATE\t0x0129\n#define WM_WTSSESSION_CHANGE 0x02B1\n#define WM_LBTRACKPOINT\t0x0131\n#define WM_GETOBJECT 0x003D\n#define WM_COMMNOTIFY 0x0044\n#define WM_TABLET_FIRST\t0x02c0\n#define WM_TABLET_LAST\t0x02df\n#define WM_IME_REQUEST\t0x0288\n#define WM_IME_KEYLAST 0x010F\n#define WM_NCMOUSEHOVER\t0x02A0\n#define WM_NCMOUSELEAVE 0x02A2\n\n#define COMCTL32_VERSION 6\n#define CCM_SETVERSION (CCM_FIRST+0x7)\n#define CCM_GETVERSION (CCM_FIRST+0x8)\n#define CCM_SETNOTIFYWINDOW (CCM_FIRST+0x9)\n#define CCM_SETWINDOWTHEME    (CCM_FIRST + 0xb)\n#define CCM_DPISCALE        (CCM_FIRST + 0xc)\n#define INFOTIPSIZE\t1024\n#define PGM_FIRST\t0x1400\n#define CCM_FIRST\t0x2000\n#define CCM_LAST\t(CCM_FIRST + 0x200)\n#define CCM_SETBKCOLOR\t(CCM_FIRST + 1)\n#define CCM_SETCOLORSCHEME\t(CCM_FIRST + 2)\n#define CCM_GETCOLORSCHEME\t(CCM_FIRST + 3)\n#define CCM_GETDROPTARGET\t(CCM_FIRST + 4)\n#define CCM_SETUNICODEFORMAT\t(CCM_FIRST + 5)\n#define CCM_GETUNICODEFORMAT\t(CCM_FIRST + 6)\n#define CBEM_INSERTITEMA\t(WM_USER+1)\n#define CBEM_SETIMAGELIST\t(WM_USER+2)\n#define CBEM_GETIMAGELIST\t(WM_USER+3)\n#define CBEM_GETITEMA\t\t(WM_USER+4)\n#define CBEM_SETITEMA\t\t(WM_USER+5)\n#define CBEM_DELETEITEM\tCB_DELETESTRING\n#define CBEM_GETCOMBOCONTROL\t(WM_USER+6)\n#define CBEM_GETEDITCONTROL\t(WM_USER+7)\n#define CBEM_SETEXSTYLE\t\t(WM_USER+8)\n#define CBEM_SETEXTENDEDSTYLE\t(WM_USER+14)\n#define CBEM_GETEXSTYLE\t\t(WM_USER+9)\n#define CBEM_GETEXTENDEDSTYLE\t(WM_USER+9)\n#define CBEM_SETUNICODEFORMAT\tCCM_SETUNICODEFORMAT\n#define CBEM_GETUNICODEFORMAT\tCCM_GETUNICODEFORMAT\n#define CBEM_HASEDITCHANGED\t(WM_USER+10)\n#define CBEM_INSERTITEMW\t(WM_USER+11)\n#define CBEM_SETITEMW\t(WM_USER+12)\n#define CBEM_GETITEMW\t(WM_USER+13)\n/* Defines.h WIN32 definitions */\n#undef MAX_PATH\n#define MAX_PATH\t260\n#define UNICODE_NULL ((WCHAR)0)\n#define LF_FACESIZE\t32\n#define LF_FULLFACESIZE\t64\n#define ELF_VENDOR_SIZE\t4\n#define SECURITY_STATIC_TRACKING\t0\n#define SECURITY_DYNAMIC_TRACKING\t1\n#define MAX_DEFAULTCHAR\t2\n#define MAX_LEADBYTES\t12\n#define EXCEPTION_MAXIMUM_PARAMETERS\t15\n#define CCHDEVICENAME\t32\n#define CCHFORMNAME\t32\n#define MENU_TEXT_LEN\t40\n#define MAX_LANA\t254\n#define NCBNAMSZ\t16\n#define NETBIOS_NAME_LEN\t16\n#define OFS_MAXPATHNAME\t128\n#define MAX_TAB_STOPS\t32\n#define ANYSIZE_ARRAY\t1\n#define FILE_BEGIN\t0\n#define FILE_CURRENT\t1\n#define FILE_END\t2\n#define OF_READ\t0\n#define OF_READWRITE\t2\n#define OF_WRITE\t1\n#define OF_SHARE_COMPAT\t0\n#define OF_SHARE_DENY_NONE\t64\n#define OF_SHARE_DENY_READ\t48\n#define OF_SHARE_DENY_WRITE\t32\n#define OF_SHARE_EXCLUSIVE\t16\n#define OF_CANCEL\t2048\n#define OF_CREATE\t4096\n#define OF_DELETE\t512\n#define OF_EXIST\t16384\n#define OF_PARSE\t256\n#define OF_PROMPT\t8192\n#define OF_REOPEN\t32768\n#define OF_VERIFY\t1024\n#define HKL_NEXT\t1\n#define HKL_PREV\t0\n#define KLF_REORDER\t8\n#define KLF_UNLOADPREVIOUS\t4\n#define KLF_ACTIVATE\t1\n#define KLF_NOTELLSHELL\t128\n#define KLF_REPLACELANG\t16\n#define KLF_SUBSTITUTE_OK\t2\n#define MF_BITMAP\t4\n#define MF_CHECKED\t8\n#define MF_DISABLED\t2\n#define MF_ENABLED\t0\n#define MF_GRAYED\t1\n#define MF_MENUBARBREAK\t32\n#define MF_MENUBREAK\t64\n#define MF_OWNERDRAW\t256\n#define MF_POPUP\t16\n#define MF_SEPARATOR\t0x800\n#define MF_STRING\t0\n#define MF_UNCHECKED\t0\n#define MF_DEFAULT\t4096\n#define MF_SYSMENU\t0x2000\n#define MF_HELP\t\t0x4000\n#define MF_END\t128\n#define MF_RIGHTJUSTIFY 0x4000\n#define MF_MOUSESELECT 0x8000\n#define BLACKNESS\t0x42\n#define NOTSRCERASE\t0x1100A6\n#define NOTSRCCOPY\t0x330008\n#define SRCERASE\t0x440328\n#define DSTINVERT\t0x550009\n#define PATINVERT\t0x5A0049\n#define SRCINVERT\t0x660046\n#define SRCAND\t0x8800C6\n#define MERGEPAINT\t0xBB0226\n#define MERGECOPY\t0xC000CA\n#define SRCCOPY\t0xCC0020\n#define SRCPAINT\t0xEE0086\n#define PATCOPY\t0xF00021\n#define PATPAINT\t0xFB0A09\n#define WHITENESS\t0xFF0062\n#define NOMIRRORBITMAP\t0x80000000\n#define CAPTUREBLT\t0x40000000\n#define R2_BLACK\t1\n#define R2_COPYPEN\t13\n#define R2_MASKNOTPEN\t3\n#define R2_MASKPEN\t9\n#define R2_MASKPENNOT\t5\n#define R2_MERGENOTPEN\t12\n#define R2_MERGEPEN\t15\n#define R2_MERGEPENNOT\t14\n#define R2_NOP\t11\n#define R2_NOT\t6\n#define R2_NOTCOPYPEN\t4\n#define R2_NOTMASKPEN\t8\n#define R2_NOTMERGEPEN\t2\n#define R2_NOTXORPEN\t10\n#define R2_WHITE\t16\n#define R2_XORPEN\t7\n#define R2_LAST\t\t16\n#define BSF_FLUSHDISK\t4\n#define BSF_FORCEIFHUNG\t32\n#define BSF_IGNORECURRENTTASK\t2\n#define BSF_NOHANG\t8\n#define BSF_POSTMESSAGE\t16\n#define BSF_QUERY\t1\n#define BSM_ALLCOMPONENTS\t0\n#define BSM_APPLICATIONS\t8\n#define BSM_INSTALLABLEDRIVERS\t4\n#define BSM_NETDRIVER\t2\n#define BSM_VXDS\t1\n#define BROADCAST_QUERY_DENY\t1112363332\n#define NMPWAIT_NOWAIT\t1\n#define NMPWAIT_WAIT_FOREVER\t(-1)\n#define NMPWAIT_USE_DEFAULT_WAIT\t0\n#define MDITILE_SKIPDISABLED\t2\n#define MDITILE_HORIZONTAL\t1\n#define MDITILE_VERTICAL\t0\n#define HCBT_ACTIVATE\t5\n#define HCBT_CLICKSKIPPED\t6\n#define HCBT_CREATEWND\t3\n#define HCBT_DESTROYWND\t4\n#define HCBT_KEYSKIPPED\t7\n#define HCBT_MINMAX\t1\n#define HCBT_MOVESIZE\t0\n#define HCBT_QS\t2\n#define HCBT_SETFOCUS\t9\n#define HCBT_SYSCOMMAND\t8\n#define DM_BITSPERPEL\t0x40000\n#define DM_PELSWIDTH\t0x80000\n#define DM_PELSHEIGHT\t0x100000\n#define DM_DISPLAYFLAGS\t0x200000\n#define DM_DISPLAYFREQUENCY 0x400000\n#define CDS_UPDATEREGISTRY\t1\n#define CDS_TEST\t2\n#define CDS_GLOBAL\t8\n#define CDS_FULLSCREEN\t4\n#define CDS_SETPRIMARY\t16\n#define CDS_VIDEOPARAMETERS 32\n#define CDS_RESET\t0x40000000\n#define CDS_NORESET\t0x10000000\n#define DISP_CHANGE_SUCCESSFUL\t0\n#define DISP_CHANGE_RESTART\t1\n#define DISP_CHANGE_BADPARAM     (-5)\n#define DISP_CHANGE_BADFLAGS\t(-4)\n#define DISP_CHANGE_FAILED\t(-1)\n#define DISP_CHANGE_BADMODE\t(-2)\n#define DISP_CHANGE_NOTUPDATED\t(-3)\n#define BST_CHECKED\t1\n#define BST_INDETERMINATE\t2\n#define BST_UNCHECKED\t0\n#define BST_FOCUS\t8\n#define BST_PUSHED\t4\n#define MF_BYCOMMAND\t0\n#define MF_BYPOSITION\t0x400\n#define MF_UNCHECKED\t0\n#define MF_HILITE\t128\n#define MF_UNHILITE\t0\n#define CWP_ALL\t0\n#define CWP_SKIPINVISIBLE\t1\n#define CWP_SKIPDISABLED\t2\n#define CWP_SKIPTRANSPARENT\t4\n#define CE_BREAK\t16\n#define CE_DNS\t2048\n#define CE_FRAME\t8\n#define CE_IOE\t1024\n#define CE_MODE\t32768\n#define CE_OOP\t4096\n#define CE_OVERRUN\t2\n#define CE_PTO\t512\n#define CE_RXOVER\t1\n#define CE_RXPARITY\t4\n#define CE_TXFULL\t256\n#define RGN_AND\t1\n#define RGN_COPY\t5\n#define RGN_DIFF\t4\n#define RGN_OR\t2\n#define RGN_XOR\t3\n#define NULLREGION\t1\n#define SIMPLEREGION\t2\n#define COMPLEXREGION\t3\n#define ERROR\t0\n#define RGN_ERROR\tERROR\n#define RGN_MIN\tRGN_AND\n#define RGN_MAX\tRGN_COPY\n#define LOCALE_SYSTEM_DEFAULT\t0x800\n#define LOCALE_USER_DEFAULT\t0x400\n#define NORM_IGNORECASE\t1\n#define NORM_IGNOREKANATYPE\t65536\n#define NORM_IGNORENONSPACE\t2\n#define NORM_IGNORESYMBOLS\t4\n#define NORM_IGNOREWIDTH\t131072\n#define SORT_STRINGSORT\t4096\n#define LCMAP_BYTEREV\t2048\n#define LCMAP_FULLWIDTH\t8388608\n#define LCMAP_HALFWIDTH\t4194304\n#define LCMAP_HIRAGANA\t1048576\n#define LCMAP_KATAKANA\t2097152\n#define LCMAP_LOWERCASE\t256\n#define LCMAP_SORTKEY\t1024\n#define LCMAP_UPPERCASE\t512\n#define DBG_CONTINUE ((DWORD)0x10002)\n#define DBG_TERMINATE_THREAD ((DWORD)0x40010003)\n#define DBG_TERMINATE_PROCESS ((DWORD)0x40010004)\n#define DBG_CONTROL_C ((DWORD)0x40010005)\n#define DBG_CONTROL_BREAK ((DWORD)0x40010008)\n#define DBG_EXCEPTION_NOT_HANDLED ((DWORD)0x80010001)\n#define IMAGE_BITMAP\t0\n#define IMAGE_CURSOR\t2\n#define IMAGE_ENHMETAFILE\t1\n#define IMAGE_ICON\t1\n#define LR_COPYDELETEORG\t8\n#define LR_COPYRETURNORG\t4\n#define LR_MONOCHROME\t1\n#define LR_DEFAULTSIZE\t64\n#define DF_ALLOWOTHERACCOUNTHOOK\t1\n#define DESKTOP_CREATEMENU\t4\n#define DESKTOP_CREATEWINDOW\t2\n#define DESKTOP_ENUMERATE\t64\n#define DESKTOP_HOOKCONTROL\t8\n#define DESKTOP_JOURNALPLAYBACK\t32\n#define DESKTOP_JOURNALRECORD\t16\n#define DESKTOP_READOBJECTS\t1\n#define DESKTOP_SWITCHDESKTOP\t256\n#define DESKTOP_WRITEOBJECTS\t128\n#define WSF_VISIBLE\t1\n#define CBM_INIT\t4\n#define DIB_PAL_COLORS\t1\n#define DIB_RGB_COLORS\t0\n#define GENERIC_READ\t0x80000000\n#define GENERIC_WRITE\t0x40000000\n#define FILE_SHARE_READ\t1\n#define FILE_SHARE_WRITE\t2\n#define FILE_SHARE_DELETE 4\n#define CONSOLE_TEXTMODE_BUFFER\t1\n#define CREATE_NEW\t1\n#define CREATE_ALWAYS\t2\n#define OPEN_EXISTING\t3\n#define OPEN_ALWAYS\t4\n#define TRUNCATE_EXISTING\t5\n#define FILE_ATTRIBUTE_ARCHIVE\t32\n#define FILE_ATTRIBUTE_COMPRESSED\t2048\n#define FILE_ATTRIBUTE_NORMAL\t128\n#define FILE_ATTRIBUTE_DIRECTORY\t16\n#define FILE_ATTRIBUTE_HIDDEN\t2\n#define FILE_ATTRIBUTE_READONLY\t1\n#define FILE_ATTRIBUTE_SYSTEM\t4\n#define FILE_ATTRIBUTE_TEMPORARY\t256\n#define FILE_ATTRIBUTE_SPARSE_FILE 0x200\n#define FILE_ATTRIBUTE_REPARSE_POINT 0x400\n#define FILE_ATTRIBUTE_OFFLINE 0x1000\n#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 0x00002000\n#define FILE_ATTRIBUTE_ENCRYPTED 0x4000\n#define FILE_FLAG_WRITE_THROUGH\t0x80000000\n#define FILE_FLAG_OVERLAPPED\t1073741824\n#define FILE_FLAG_NO_BUFFERING\t536870912\n#define FILE_FLAG_RANDOM_ACCESS\t268435456\n#define FILE_FLAG_SEQUENTIAL_SCAN\t134217728\n#define FILE_FLAG_DELETE_ON_CLOSE\t67108864\n#define FILE_FLAG_BACKUP_SEMANTICS\t33554432\n#define FILE_FLAG_POSIX_SEMANTICS\t16777216\n#define FILE_FLAG_OPEN_REPARSE_POINT\t0x200000\n#define FILE_FLAG_OPEN_NO_RECALL\t0x100000\n#define FILE_FLAG_FIRST_PIPE_INSTANCE\t0x00080000\n#define SECURITY_ANONYMOUS\t0\n#define SECURITY_IDENTIFICATION\t65536\n#define SECURITY_IMPERSONATION\t131072\n#define SECURITY_DELEGATION\t196608\n#define SECURITY_CONTEXT_TRACKING\t262144\n#define SECURITY_EFFECTIVE_ONLY\t524288\n#define SECURITY_SQOS_PRESENT\t1048576\n#define PAGE_READONLY\t2\n#define PAGE_READWRITE\t4\n#define PAGE_WRITECOPY\t8\n#define SEC_COMMIT\t134217728\n#define SEC_IMAGE\t16777216\n#define SEC_NOCACHE\t268435456\n#define SEC_RESERVE\t67108864\n#define MEM_COMMIT\t4096\n#define MEM_RESERVE\t8192\n#define MEM_TOP_DOWN\t1048576\n#define PAGE_EXECUTE\t16\n#define PAGE_EXECUTE_READ\t32\n#define PAGE_EXECUTE_READWRITE\t64\n#define PAGE_GUARD\t256\n#define PAGE_NOACCESS\t1\n#define PAGE_NOCACHE\t512\n#define MEM_COMMIT\t4096\n#define MEM_FREE\t65536\n#define MEM_RESERVE\t8192\n#define MEM_IMAGE\t16777216\n#define MEM_MAPPED\t262144\n#define MEM_PRIVATE\t131072\n#define MEM_DECOMMIT\t16384\n#define MEM_RELEASE\t32768\n#define WRITE_WATCH_FLAG_RESET 1\n#define FILE_READ_DATA\t1\n#define FILE_LIST_DIRECTORY\t1\n#define FILE_WRITE_DATA\t2\n#define FILE_ADD_FILE\t2\n#define FILE_APPEND_DATA\t4\n#define FILE_ADD_SUBDIRECTORY\t4\n#define FILE_CREATE_PIPE_INSTANCE 4\n#define FILE_READ_EA\t8\n#define FILE_WRITE_EA\t0x10\n#define FILE_EXECUTE\t0x20\n#define FILE_TRAVERSE\t0x0020\n#define FILE_DELETE_CHILD\t0x0040\n#define FILE_READ_ATTRIBUTES\t0x0080\n#define FILE_WRITE_ATTRIBUTES\t0x100\n#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x1FF)\n#define FILE_GENERIC_READ (STANDARD_RIGHTS_READ|FILE_READ_DATA| FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONIZE)\n#define FILE_GENERIC_WRITE (STANDARD_RIGHTS_WRITE|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONIZE)\n#define FILE_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE|FILE_READ_ATTRIBUTES|FILE_EXECUTE|SYNCHRONIZE)\n#define PAGE_EXECUTE_WRITECOPY\t128\n#define EXCEPTION_GUARD_PAGE\t0x80000001\n#define SECTION_EXTEND_SIZE\t16\n#define SECTION_MAP_READ\t4\n#define SECTION_MAP_WRITE\t2\n#define SECTION_QUERY\t1\n#define SECTION_ALL_ACCESS\t0xf001f\n#define FW_DONTCARE\t0\n#define FW_THIN\t100\n#define FW_EXTRALIGHT\t200\n#define FW_LIGHT\t300\n#define FW_NORMAL\t400\n#define FW_REGULAR\t400\n#define FW_MEDIUM\t500\n#define FW_SEMIBOLD\t600\n#define FW_BOLD\t700\n#define FW_EXTRABOLD\t800\n#define FW_HEAVY\t900\n#define CLEARTYPE_QUALITY 5\n#define ANSI_CHARSET\t0\n#define DEFAULT_CHARSET\t1\n#define SYMBOL_CHARSET\t2\n#define SHIFTJIS_CHARSET\t128\n#define HANGEUL_CHARSET\t129\n#define GB2312_CHARSET\t134\n#define CHINESEBIG5_CHARSET\t136\n#define GREEK_CHARSET\t161\n#define TURKISH_CHARSET\t162\n#define HEBREW_CHARSET\t177\n#define ARABIC_CHARSET\t178\n#define BALTIC_CHARSET\t186\n#define RUSSIAN_CHARSET\t204\n#define THAI_CHARSET\t222\n#define EASTEUROPE_CHARSET\t238\n#define OEM_CHARSET\t255\n#define OUT_DEFAULT_PRECIS\t0\n#define OUT_STRING_PRECIS\t1\n#define OUT_CHARACTER_PRECIS\t2\n#define OUT_STROKE_PRECIS\t3\n#define OUT_TT_PRECIS\t4\n#define OUT_DEVICE_PRECIS\t5\n#define OUT_RASTER_PRECIS\t6\n#define OUT_TT_ONLY_PRECIS\t7\n#define OUT_OUTLINE_PRECIS\t8\n#define CLIP_DEFAULT_PRECIS\t0\n#define CLIP_CHARACTER_PRECIS\t1\n#define CLIP_STROKE_PRECIS\t2\n#define CLIP_MASK\t15\n#define CLIP_LH_ANGLES\t16\n#define CLIP_TT_ALWAYS\t32\n#define CLIP_EMBEDDED\t128\n#define DEFAULT_QUALITY\t0\n#define DRAFT_QUALITY\t1\n#define PROOF_QUALITY\t2\n#define NONANTIALIASED_QUALITY\t3\n#define ANTIALIASED_QUALITY\t4\n#define DEFAULT_PITCH\t0\n#define FIXED_PITCH\t1\n#define VARIABLE_PITCH\t2\n#define FF_DECORATIVE\t80\n#define FF_DONTCARE\t0\n#define FF_MODERN\t48\n#define FF_ROMAN\t16\n#define FF_SCRIPT\t64\n#define FF_SWISS\t32\n#define HS_BDIAGONAL\t3\n#define HS_CROSS\t4\n#define HS_DIAGCROSS\t5\n#define HS_FDIAGONAL\t2\n#define HS_HORIZONTAL\t0\n#define HS_VERTICAL\t1\n#define LR_DEFAULTCOLOR\t0\n#define LR_LOADREALSIZE\t128\n#define LR_MONOCHROME\t1\n#define LR_COPYRETURNORG 4\n#define LR_COPYDELETEORG 8\n#define LR_LOADFROMFILE\t16\n#define LR_LOADTRANSPARENT 32\n#define LR_DEFAULTSIZE\t64\n#define LR_VGACOLOR\t0x80\n#define LR_LOADMAP3DCOLORS 0x1000\n#define LR_CREATEDIBSECTION 0x2000\n#define LR_COPYFROMRESOURCE 0x4000\n#define LR_SHARED\t0x8000\n#define MAILSLOT_WAIT_FOREVER\t0xffffffff\n#define MAILSLOT_NO_MESSAGE\t0xffffffff\n#define CMB_MASKED\t2\n#define PIPE_ACCESS_DUPLEX\t3\n#define PIPE_ACCESS_INBOUND\t1\n#define PIPE_ACCESS_OUTBOUND\t2\n#define WRITE_DAC\t0x40000\n#define WRITE_OWNER\t0x80000\n#define ACCESS_SYSTEM_SECURITY\t0x1000000\n#define PIPE_TYPE_BYTE\t0\n#define PIPE_TYPE_MESSAGE\t4\n#define PIPE_READMODE_BYTE\t0\n#define PIPE_READMODE_MESSAGE\t2\n#define PIPE_WAIT\t0\n#define PIPE_NOWAIT\t1\n#define PIPE_UNLIMITED_INSTANCES 255\n#define PROGRESS_CONTINUE 0\n#define PROGRESS_CANCEL\t1\n#define PROGRESS_STOP\t2\n#define PROGRESS_QUIET\t3\n#define CALLBACK_CHUNK_FINISHED 0\n#define CALLBACK_STREAM_SWITCH\t1\n#define COPY_FILE_FAIL_IF_EXISTS 1\n#define COPY_FILE_RESTARTABLE\t2\n#define COPY_FILE_OPEN_SOURCE_FOR_WRITE 4\n#define COPY_FILE_ALLOW_DECRYPTED_DESTINATION 8\n#define REPLACEFILE_WRITE_THROUGH 1\n#define REPLACEFILE_IGNORE_MERGE_ERRORS 2\n#define PS_GEOMETRIC\t65536\n#define PS_COSMETIC\t0\n#define PS_ALTERNATE\t8\n#define PS_SOLID\t0\n#define PS_DASH\t1\n#define PS_DOT\t2\n#define PS_DASHDOT\t3\n#define PS_DASHDOTDOT\t4\n#define PS_NULL\t5\n#define PS_USERSTYLE\t7\n#define PS_INSIDEFRAME\t6\n#define PS_ENDCAP_ROUND\t0\n#define PS_ENDCAP_SQUARE\t256\n#define PS_ENDCAP_FLAT\t512\n#define PS_JOIN_BEVEL\t4096\n#define PS_JOIN_MITER\t8192\n#define PS_JOIN_ROUND\t0\n#define PS_STYLE_MASK\t15\n#define PS_ENDCAP_MASK\t3840\n#define PS_TYPE_MASK\t983040\n#define ALTERNATE\t1\n#define WINDING\t2\n#define POLYFILL_LAST\t2\n#define LAYOUT_RTL\t1\n#define LAYOUT_BTT\t2\n#define LAYOUT_VBH\t4\n#define LAYOUT_BITMAPORIENTATIONPRESERVED\t8\n#define LAYOUT_ORIENTATIONMASK\t(LAYOUT_RTL|LAYOUT_BTT|LAYOUT_VBH)\n#define CREATE_NEW_CONSOLE\t16\n#define CREATE_NEW_PROCESS_GROUP\t512\n#define CREATE_SEPARATE_WOW_VDM\t2048\n#define CREATE_SUSPENDED\t4\n#define CREATE_UNICODE_ENVIRONMENT\t1024\n#define CREATE_BREAKAWAY_FROM_JOB 0x01000000\n#define CREATE_PRESERVE_CODE_AUTHZ_LEVEL 0x02000000\n#define CREATE_DEFAULT_ERROR_MODE 0x04000000\n#define CREATE_NO_WINDOW 0x08000000\n#define CREATE_SHARED_WOW_VDM 0x00001000\n#define CREATE_FORCEDOS 0x00002000\n#define PROFILE_USER 0x10000000\n#define PROFILE_KERNEL 0x20000000\n#define PROFILE_SERVER 0x40000000\n#define DEBUG_PROCESS\t1\n#define DEBUG_ONLY_THIS_PROCESS\t2\n#define DETACHED_PROCESS\t8\n#define HIGH_PRIORITY_CLASS\t128\n#define IDLE_PRIORITY_CLASS\t64\n#define NORMAL_PRIORITY_CLASS\t32\n#define REALTIME_PRIORITY_CLASS\t256\n#define BELOW_NORMAL_PRIORITY_CLASS 0x04000\n#define ABOVE_NORMAL_PRIORITY_CLASS 0x08000\n#define DELETE\t0x10000\n#define READ_CONTROL\t0x20000\n#define GENERIC_EXECUTE\t0x20000000\n#define SERVICE_WIN32_OWN_PROCESS\t16\n#define SERVICE_WIN32_SHARE_PROCESS\t32\n#define SERVICE_KERNEL_DRIVER\t1\n#define SERVICE_FILE_SYSTEM_DRIVER\t2\n#define SERVICE_INTERACTIVE_PROCESS\t256\n#define SERVICE_BOOT_START\t0\n#define SERVICE_SYSTEM_START\t1\n#define SERVICE_AUTO_START\t2\n#define SERVICE_DEMAND_START\t3\n#define SERVICE_DISABLED\t4\n#define SERVICE_ERROR_IGNORE\t0\n#define SERVICE_ERROR_NORMAL\t1\n#define SERVICE_ERROR_SEVERE\t2\n#define SERVICE_ERROR_CRITICAL\t3\n#define TAPE_FIXED_PARTITIONS\t0\n#define TAPE_INITIATOR_PARTITIONS\t2\n#define TAPE_SELECT_PARTITIONS\t1\n#define TAPE_FILEMARKS\t1\n#define TAPE_LONG_FILEMARKS\t3\n#define TAPE_SETMARKS\t0\n#define TAPE_SHORT_FILEMARKS\t2\n#define CW_USEDEFAULT\t0x80000000\n#define WS_BORDER\t0x800000\n#define WS_CAPTION\t0xc00000\n#define WS_CHILD\t0x40000000\n#define WS_CHILDWINDOW\t0x40000000\n#define WS_CLIPCHILDREN\t0x2000000\n#define WS_CLIPSIBLINGS\t0x4000000\n#define WS_DISABLED\t0x8000000\n#define WS_DLGFRAME\t0x400000\n#define WS_GROUP\t0x20000\n#define WS_HSCROLL\t0x100000\n#define WS_ICONIC\t0x20000000\n#define WS_MAXIMIZE\t0x1000000\n#define WS_MAXIMIZEBOX\t0x10000\n#define WS_MINIMIZE\t0x20000000\n#define WS_MINIMIZEBOX\t0x20000\n#define WS_OVERLAPPED\t0\n#define WS_OVERLAPPEDWINDOW\t0xcf0000\n#define WS_POPUP\t0x80000000\n#define WS_POPUPWINDOW\t0x80880000\n#define WS_SIZEBOX\t0x40000\n#define WS_SYSMENU\t0x80000\n#define WS_TABSTOP\t0x10000\n#define WS_THICKFRAME\t0x40000\n#define WS_TILED\t0\n#define WS_TILEDWINDOW\t0xcf0000\n#define WS_VISIBLE\t0x10000000\n#define WS_VSCROLL\t0x200000\n#define MDIS_ALLCHILDSTYLES\t1\n#define BS_3STATE\t5\n#define BS_AUTO3STATE\t6\n#define BS_AUTOCHECKBOX\t3\n#define BS_AUTORADIOBUTTON\t9\n#define BS_BITMAP\t128\n#define BS_BOTTOM\t0x800\n#define BS_CENTER\t0x300\n#define BS_CHECKBOX\t2\n#define BS_DEFPUSHBUTTON\t1\n#define BS_GROUPBOX\t7\n#define BS_ICON\t64\n#define BS_LEFT\t256\n#define BS_LEFTTEXT\t32\n#define BS_MULTILINE\t0x2000\n#define BS_NOTIFY\t0x4000\n#define BS_OWNERDRAW\t0xb\n#define BS_PUSHBUTTON\t0\n#define BS_PUSHBOX\t10\n#define BS_PUSHLIKE\t4096\n#define BS_RADIOBUTTON\t4\n#define BS_RIGHT\t512\n#define BS_RIGHTBUTTON\t32\n#define BS_TEXT\t0\n#define BS_TOP\t0x400\n#define BS_USERBUTTON\t8\n#define BS_VCENTER\t0xc00\n#define BS_FLAT\t0x8000\n#define BUTTON_IMAGELIST_ALIGN_LEFT\t0\n#define BUTTON_IMAGELIST_ALIGN_RIGHT\t1\n#define BUTTON_IMAGELIST_ALIGN_TOP\t2\n#define BUTTON_IMAGELIST_ALIGN_BOTTOM\t3\n#define BUTTON_IMAGELIST_ALIGN_CENTER\t4\n#define CBS_AUTOHSCROLL\t64\n#define CBS_DISABLENOSCROLL\t0x800\n#define CBS_DROPDOWN\t2\n#define CBS_DROPDOWNLIST\t3\n#define CBS_HASSTRINGS\t512\n#define CBS_LOWERCASE\t0x4000\n#define CBS_NOINTEGRALHEIGHT\t0x400\n#define CBS_OEMCONVERT\t128\n#define CBS_OWNERDRAWFIXED\t16\n#define CBS_OWNERDRAWVARIABLE\t32\n#define CBS_SIMPLE\t1\n#define CBS_SORT\t256\n#define CBS_UPPERCASE\t0x2000\n#define ES_AUTOHSCROLL\t128\n#define ES_AUTOVSCROLL\t64\n#define ES_CENTER\t1\n#define ES_LEFT\t0\n#define ES_LOWERCASE\t16\n#define ES_MULTILINE\t4\n#define ES_NOHIDESEL\t256\n#define ES_NUMBER\t0x2000\n#define ES_OEMCONVERT\t0x400\n#define ES_PASSWORD\t32\n#define ES_READONLY\t0x800\n#define ES_RIGHT\t2\n#define ES_UPPERCASE\t8\n#define ES_WANTRETURN\t4096\n#define LBS_DISABLENOSCROLL\t4096\n#define LBS_EXTENDEDSEL\t0x800\n#define LBS_HASSTRINGS\t64\n#define LBS_MULTICOLUMN\t512\n#define LBS_MULTIPLESEL\t8\n#define LBS_NODATA\t0x2000\n#define LBS_NOINTEGRALHEIGHT\t256\n#define LBS_NOREDRAW\t4\n#define LBS_NOSEL\t0x4000\n#define LBS_NOTIFY\t1\n#define LBS_OWNERDRAWFIXED\t16\n#define LBS_OWNERDRAWVARIABLE\t32\n#define LBS_SORT\t2\n#define LBS_STANDARD\t0xa00003\n#define LBS_USETABSTOPS\t128\n#define LBS_WANTKEYBOARDINPUT\t0x400\n#define SBS_BOTTOMALIGN\t4\n#define SBS_HORZ\t0\n#define SBS_LEFTALIGN\t2\n#define SBS_RIGHTALIGN\t4\n#define SBS_SIZEBOX\t8\n#define SBS_SIZEBOXBOTTOMRIGHTALIGN\t4\n#define SBS_SIZEBOXTOPLEFTALIGN\t2\n#define SBS_SIZEGRIP\t16\n#define SBS_TOPALIGN\t2\n#define SBS_VERT\t1\n#define SS_BITMAP\t0xe\n#define SS_BLACKFRAME\t7\n#define SS_BLACKRECT\t4\n#define SS_CENTER\t1\n#define SS_CENTERIMAGE\t512\n#define SS_ENHMETAFILE\t0xf\n#define SS_ETCHEDFRAME\t0x12\n#define SS_ETCHEDHORZ\t16\n#define SS_ETCHEDVERT\t0x11\n#define SS_GRAYFRAME\t8\n#define SS_GRAYRECT\t5\n#define SS_ICON\t3\n#define SS_LEFT\t0\n#define SS_LEFTNOWORDWRAP\t0xc\n#define SS_TYPEMASK\t0x1f\n#define SS_ENDELLIPSIS\t0x4000\n#define SS_PATHELLIPSIS\t0x8000\n#define SS_WORDELLIPSIS\t0xC000\n#define SS_ELLIPSISMASK\t0xC000\n#define SS_REALSIZECONTROL\t0x40\n#define SS_NOPREFIX\t128\n#define SS_NOTIFY\t256\n#define SS_OWNERDRAW\t0xd\n#define SS_REALSIZEIMAGE\t0x800\n#define SS_RIGHT\t2\n#define SS_RIGHTJUST\t0x400\n#define SS_SIMPLE\t11\n#define SS_SUNKEN\t4096\n#define SS_WHITEFRAME\t9\n#define SS_WHITERECT\t6\n#define SS_USERITEM 10\n#define DS_3DLOOK\t4\n#define DS_ABSALIGN\t1\n#define DS_CENTER\t0x800\n#define DS_CENTERMOUSE\t4096\n#define DS_CONTEXTHELP\t0x2000\n#define DS_CONTROL\t0x400\n#define DS_FIXEDSYS\t8\n#define DS_LOCALEDIT\t32\n#define DS_MODALFRAME\t128\n#define DS_NOFAILCREATE\t16\n#define DS_NOIDLEMSG\t256\n#define DS_SETFONT\t64\n#define DS_SETFOREGROUND\t512\n#define DS_SYSMODAL\t2\n#define DS_FIXEDSYS\t8\n#define DS_SHELLFONT\t(DS_SETFONT|DS_FIXEDSYS)\n#define WS_EX_ACCEPTFILES\t16\n#define WS_EX_APPWINDOW\t0x40000\n#define WS_EX_CLIENTEDGE\t512\n#define WS_EX_CONTEXTHELP\t0x400\n#define WS_EX_CONTROLPARENT\t0x10000\n#define WS_EX_DLGMODALFRAME\t1\n#define WS_EX_LEFT\t0\n#define WS_EX_LEFTSCROLLBAR\t0x4000\n#define WS_EX_LTRREADING\t0\n#define WS_EX_MDICHILD\t64\n#define WS_EX_NOPARENTNOTIFY\t4\n#define WS_EX_OVERLAPPEDWINDOW\t0x300\n#define WS_EX_PALETTEWINDOW\t0x188\n#define WS_EX_RIGHT\t0x1000\n#define WS_EX_RIGHTSCROLLBAR\t0\n#define WS_EX_RTLREADING\t0x2000\n#define WS_EX_STATICEDGE\t0x20000\n#define WS_EX_TOOLWINDOW\t128\n#define WS_EX_TOPMOST\t8\n#define WS_EX_TRANSPARENT\t32\n#define WS_EX_WINDOWEDGE\t256\n#define WS_EX_LAYERED\t0x080000\n#define WINSTA_ACCESSCLIPBOARD\t4\n#define WINSTA_ACCESSGLOBALATOMS\t32\n#define WINSTA_CREATEDESKTOP\t8\n#define WINSTA_ENUMDESKTOPS\t1\n#define WINSTA_ENUMERATE\t256\n#define WINSTA_EXITWINDOWS\t64\n#define WINSTA_READATTRIBUTES\t2\n#define WINSTA_READSCREEN\t512\n#define WINSTA_WRITEATTRIBUTES\t16\n#define WH_CALLWNDPROC\t4\n#define WH_CALLWNDPROCRET\t12\n#define WH_KEYBOARD_LL\t13\n#define WH_MOUSE_LL\t14\n#define WH_MAX 14\n#define WH_MINHOOK WH_MIN\n#define WH_MAXHOOK WH_MAX\n#define HC_ACTION 0\n#define HC_GETNEXT 1\n#define HC_ACTION\t0\n#define HC_GETNEXT\t1\n#define HC_SKIP\t2\n#define HC_NOREMOVE\t3\n#define HC_NOREM\tHC_NOREMOVE\n#define HC_SYSMODALON\t4\n#define HC_SYSMODALOFF\t5\n#define HCBT_MOVESIZE\t0\n#define HCBT_MINMAX\t1\n#define HCBT_QS\t2\n#define HCBT_CREATEWND\t3\n#define HCBT_DESTROYWND\t4\n#define HCBT_ACTIVATE\t5\n#define HCBT_CLICKSKIPPED\t6\n#define HCBT_KEYSKIPPED\t7\n#define HCBT_SYSCOMMAND\t8\n#define HCBT_SETFOCUS\t9\n#define HC_SYSMODALON\t4\n#define WH_CBT\t5\n#define WH_DEBUG\t9\n#define WH_GETMESSAGE\t3\n#define WH_JOURNALPLAYBACK\t1\n#define WH_JOURNALRECORD\t0\n#define WH_KEYBOARD\t2\n#define WH_MOUSE\t7\n#define WH_MSGFILTER\t(-1)\n#define WH_SHELL\t10\n#define WH_SYSMSGFILTER\t6\n#define WH_MIN (-1)\n#define WH_FOREGROUNDIDLE\t11\n#define DDD_RAW_TARGET_PATH\t1\n#define DDD_REMOVE_DEFINITION\t2\n#define DDD_EXACT_MATCH_ON_REMOVE\t4\n#define DDD_NO_BROADCAST_SYSTEM 8\n#define DDD_LUID_BROADCAST_DRIVE 16\n#define DC_BINNAMES\t12\n#define DC_BINS\t6\n#define DC_COPIES\t18\n#define DC_DRIVER\t11\n#define DC_DATATYPE_PRODUCED\t21\n#define DC_DUPLEX\t7\n#define DC_EMF_COMPLIANT\t20\n#define DC_ENUMRESOLUTIONS\t13\n#define DC_EXTRA\t9\n#define DC_FIELDS\t1\n#define DC_FILEDEPENDENCIES\t14\n#define DC_MAXEXTENT\t5\n#define DC_MINEXTENT\t4\n#define DC_ORIENTATION\t17\n#define DC_PAPERNAMES\t16\n#define DC_PAPERS\t2\n#define DC_PAPERSIZE\t3\n#define DC_SIZE\t8\n#define DC_TRUETYPE\t15\n#define DCTT_BITMAP\t1\n#define DCTT_DOWNLOAD\t2\n#define DCTT_SUBDEV\t4\n#define DC_VERSION\t10\n#define DC_BINADJUST\t19\n#define DC_EMF_COMPLIANT\t20\n#define DC_DATATYPE_PRODUCED\t21\n#define DDL_ARCHIVE\t32\n#define DDL_DIRECTORY\t16\n#define DDL_DRIVES\t16384\n#define DDL_EXCLUSIVE\t32768\n#define DDL_HIDDEN\t2\n#define DDL_READONLY\t1\n#define DDL_READWRITE\t0\n#define DDL_SYSTEM\t4\n#define DDL_POSTMSGS\t8192\n#define DLL_PROCESS_ATTACH\t1\n#define DLL_THREAD_ATTACH\t2\n#define DLL_PROCESS_DETACH\t0\n#define DLL_THREAD_DETACH\t3\n#define DM_IN_BUFFER\t8\n#define DM_MODIFY\t8\n#define DM_IN_PROMPT\t4\n#define DM_PROMPT\t4\n#define DM_OUT_BUFFER\t2\n#define DM_COPY\t2\n#define DM_UPDATE\t1\n#define IDANI_OPEN\t1\n#define IDANI_CLOSE\t2\n#define DC_ACTIVE\t1\n#define DC_SMALLCAP\t2\n#define DC_ICON\t4\n#define DC_TEXT\t8\n#define DC_INBUTTON\t16\n#define DC_GRADIENT\t32\n#define BDR_RAISEDINNER\t4\n#define BDR_SUNKENINNER\t8\n#define BDR_RAISEDOUTER\t1\n#define BDR_SUNKENOUTER\t2\n#define BDR_OUTER\t(BDR_RAISEDOUTER|BDR_SUNKENOUTER)\n#define BDR_INNER\t(BDR_RAISEDINNER|BDR_SUNKENINNER)\n#define BDR_RAISED\t(BDR_RAISEDOUTER|BDR_RAISEDINNER)\n#define BDR_SUNKEN\t(BDR_SUNKENOUTER|BDR_SUNKENINNER)\n#define EDGE_BUMP\t9\n#define EDGE_ETCHED\t6\n#define EDGE_RAISED\t5\n#define EDGE_SUNKEN\t10\n#define BF_ADJUST\t8192\n#define BF_BOTTOM\t8\n#define BF_BOTTOMLEFT\t9\n#define BF_BOTTOMRIGHT\t12\n#define BF_DIAGONAL\t16\n#define BF_DIAGONAL_ENDBOTTOMLEFT\t25\n#define BF_DIAGONAL_ENDBOTTOMRIGHT\t28\n#define BF_DIAGONAL_ENDTOPLEFT\t19\n#define BF_DIAGONAL_ENDTOPRIGHT\t22\n#define BF_FLAT\t16384\n#define BF_LEFT\t1\n#define BF_MIDDLE\t2048\n#define BF_MONO\t32768\n#define BF_RECT\t15\n#define BF_RIGHT\t4\n#define BF_SOFT\t4096\n#define BF_TOP\t2\n#define BF_TOPLEFT\t3\n#define BF_TOPRIGHT\t6\n#define DFC_BUTTON\t4\n#define DFC_CAPTION\t1\n#define DFC_MENU\t2\n#define DFC_SCROLL\t3\n#define DFCS_BUTTON3STATE\t8\n#define DFCS_BUTTONCHECK\t0\n#define DFCS_BUTTONPUSH\t16\n#define DFCS_BUTTONRADIO\t4\n#define DFCS_BUTTONRADIOIMAGE\t1\n#define DFCS_BUTTONRADIOMASK\t2\n#define DFCS_CAPTIONCLOSE\t0\n#define DFCS_CAPTIONHELP\t4\n#define DFCS_CAPTIONMAX\t2\n#define DFCS_CAPTIONMIN\t1\n#define DFCS_CAPTIONRESTORE\t3\n#define DFCS_MENUARROW\t0\n#define DFCS_MENUBULLET\t2\n#define DFCS_MENUCHECK\t1\n#define DFCS_SCROLLCOMBOBOX\t5\n#define DFCS_SCROLLDOWN\t1\n#define DFCS_SCROLLLEFT\t2\n#define DFCS_SCROLLRIGHT\t3\n#define DFCS_SCROLLSIZEGRIP\t8\n#define DFCS_SCROLLUP\t0\n#define DFCS_ADJUSTRECT\t8192\n#define DFCS_CHECKED\t1024\n#define DFCS_FLAT\t16384\n#define DFCS_INACTIVE\t256\n#define DFCS_MONO\t32768\n#define DFCS_PUSHED\t512\n#define DI_COMPAT\t4\n#define DI_DEFAULTSIZE\t8\n#define DI_IMAGE\t2\n#define DI_MASK\t1\n#define DI_NORMAL\t3\n#define DST_BITMAP\t4\n#define DST_COMPLEX\t0\n#define DST_ICON\t3\n#define DST_PREFIXTEXT\t2\n#define DST_TEXT\t1\n#define DSS_NORMAL\t0\n#define DSS_UNION\t16\n#define DSS_DISABLED\t32\n#define DSS_MONO\t128\n#define SBT_NOBORDERS\t256\n#define SBT_OWNERDRAW\t4096\n#define SBT_POPOUT\t512\n#define SBT_RTLREADING\t1024\n#define SBT_TOOLTIPS\t0x800\n#define SB_SIMPLEID\t0x00ff\n#define DT_BOTTOM\t8\n#define DT_CALCRECT\t1024\n#define DT_CENTER\t1\n#define DT_EDITCONTROL\t8192\n#define DT_END_ELLIPSIS\t32768\n#define DT_PATH_ELLIPSIS\t16384\n#define DT_EXPANDTABS\t64\n#define DT_EXTERNALLEADING\t512\n#define DT_LEFT\t0\n#define DT_MODIFYSTRING\t65536\n#define DT_NOCLIP\t256\n#define DT_NOPREFIX\t2048\n#define DT_RIGHT\t2\n#define DT_RTLREADING\t131072\n#define DT_SINGLELINE\t32\n#define DT_TABSTOP\t128\n#define DT_TOP\t0\n#define DT_VCENTER\t4\n#define DT_WORDBREAK\t16\n#define DT_INTERNAL\t4096\n#define DT_WORD_ELLIPSIS\t0x40000\n#define DT_NOFULLWIDTHCHARBREAK\t0x80000\n#define DT_HIDEPREFIX\t0x100000\n#define DT_PREFIXONLY\t0x200000\n#define DUPLICATE_CLOSE_SOURCE\t1\n#define DUPLICATE_SAME_ACCESS\t2\n#define FILE_MAP_ALL_ACCESS\t0xf001f\n#define FILE_MAP_READ\t4\n#define FILE_MAP_WRITE\t2\n#define FILE_MAP_COPY\t1\n#define MUTEX_ALL_ACCESS\t0x1f0001\n#define MUTEX_MODIFY_STATE\t1\n#define SYNCHRONIZE\t0x100000\n#define SEMAPHORE_ALL_ACCESS\t0x1f0003\n#define SEMAPHORE_MODIFY_STATE\t2\n#define S_NORMAL 0\n#define S_LEGATO 1\n#define S_STACCATO 2\n#define S_PERIOD512 0\n#define S_PERIOD1024 1\n#define S_PERIOD2048 2\n#define S_PERIODVOICE 3\n#define S_SERDVNA (-1)\n#define S_SEROFM (-2)\n#define S_SERMACT (-3)\n#define S_SERQFUL (-4)\n#define S_SERBDNT (-5)\n#define S_SERDLN (-6)\n#define S_SERDCC (-7)\n#define S_SERDTP (-8)\n#define S_SERDV  (-9)\n#define S_SERDMD (-10)\n#define S_SERDSH (-11)\n#define S_SERDPT (-12)\n#define S_SERDFQ (-13)\n#define S_SERDDR (-14)\n#define S_SERDSR (-15)\n#define S_SERDST (-16)\n#define S_WHITE512 4\n#define S_WHITE1024 5\n#define S_WHITE2048 6\n#define S_WHITEVOICE 7\n#define EVENT_ALL_ACCESS\t0x1f0003\n#define EVENT_MODIFY_STATE\t2\n#define KEY_ALL_ACCESS\t0xf003f\n#define KEY_CREATE_LINK\t32\n#define KEY_CREATE_SUB_KEY\t4\n#define KEY_ENUMERATE_SUB_KEYS\t8\n#define KEY_EXECUTE\t0x20019\n#define KEY_NOTIFY\t16\n#define KEY_QUERY_VALUE\t1\n#define KEY_READ\t0x20019\n#define KEY_SET_VALUE\t2\n#define KEY_WRITE\t0x20006\n#define PROCESS_ALL_ACCESS\t0x1f0fff\n#define PROCESS_CREATE_PROCESS\t128\n#define PROCESS_CREATE_THREAD\t2\n#define PROCESS_DUP_HANDLE\t64\n#define PROCESS_QUERY_INFORMATION\t1024\n#define PROCESS_SET_INFORMATION\t512\n#define PROCESS_TERMINATE\t1\n#define PROCESS_VM_OPERATION\t8\n#define PROCESS_VM_READ\t16\n#define PROCESS_VM_WRITE\t32\n#define THREAD_ALL_ACCESS\t0x1f03ff\n#define THREAD_DIRECT_IMPERSONATION\t512\n#define THREAD_GET_CONTEXT\t8\n#define THREAD_IMPERSONATE\t256\n#define THREAD_QUERY_INFORMATION\t64\n#define THREAD_SET_CONTEXT\t16\n#define THREAD_SET_INFORMATION\t32\n#define THREAD_SET_THREAD_TOKEN\t128\n#define THREAD_SUSPEND_RESUME\t2\n#define THREAD_TERMINATE\t1\n#define WB_ISDELIMITER\t2\n#define WB_LEFT\t0\n#define WB_RIGHT\t1\n#define SB_BOTH\t3\n#define SB_CTL\t2\n#define SB_HORZ\t0\n#define SB_VERT\t1\n#define ESB_DISABLE_BOTH\t3\n#define ESB_DISABLE_DOWN\t2\n#define ESB_DISABLE_LEFT\t1\n#define ESB_DISABLE_LTUP\t1\n#define ESB_DISABLE_RIGHT\t2\n#define ESB_DISABLE_RTDN\t2\n#define ESB_DISABLE_UP\t1\n#define ESB_ENABLE_BOTH\t0\n#define SB_LINEUP\t0\n#define SB_LINEDOWN\t1\n#define SB_LINELEFT\t0\n#define SB_LINERIGHT\t1\n#define SB_PAGEUP\t2\n#define SB_PAGEDOWN\t3\n#define SB_PAGELEFT\t2\n#define SB_PAGERIGHT\t3\n#define SB_THUMBPOSITION\t4\n#define SB_THUMBTRACK\t5\n#define SB_ENDSCROLL\t8\n#define SB_LEFT\t6\n#define SB_RIGHT\t7\n#define SB_BOTTOM\t7\n#define SB_TOP\t6\n#define ENUM_ALL_CALENDARS\t0xffffffff\n#define DATE_SHORTDATE\t1\n#define DATE_LONGDATE\t2\n#define SERVICE_ACTIVE\t1\n#define SERVICE_INACTIVE\t2\n#define DEVICE_FONTTYPE\t2\n#define RASTER_FONTTYPE\t1\n#define TRUETYPE_FONTTYPE\t4\n#define OBJ_BRUSH\t2\n#define OBJ_PEN\t1\n#define OBJ_PAL\t5\n#define OBJ_FONT\t6\n#define OBJ_BITMAP\t7\n#define OBJ_EXTPEN\t11\n#define OBJ_REGION\t8\n#define OBJ_DC\t3\n#define OBJ_MEMDC\t10\n#define OBJ_METAFILE\t9\n#define OBJ_METADC\t4\n#define OBJ_ENHMETAFILE\t13\n#define OBJ_COLORSPACE\t14\n#define OBJ_ENHMETADC\t12\n#define IPPROTO_TCP\t6\n#define IPPROTO_UDP\t17\n#define RT_ACCELERATOR\tMAKEINTRESOURCE(9)\n#define RT_BITMAP\tMAKEINTRESOURCE(2)\n#define RT_DIALOG\tMAKEINTRESOURCE(5)\n#define RT_FONT\tMAKEINTRESOURCE(8)\n#define RT_FONTDIR\tMAKEINTRESOURCE(7)\n#define RT_MENU\tMAKEINTRESOURCE(4)\n#define RT_RCDATA\tMAKEINTRESOURCE(0xa)\n#define RT_STRING\tMAKEINTRESOURCE(0x6)\n#define RT_MESSAGETABLE\tMAKEINTRESOURCE(0xb)\n#define RT_CURSOR\tMAKEINTRESOURCE(1)\n#define RT_GROUP_CURSOR\tMAKEINTRESOURCE(0xc)\n#define RT_ICON\tMAKEINTRESOURCE(3)\n#define RT_GROUP_ICON\tMAKEINTRESOURCE(0xe)\n#define RT_VERSION\tMAKEINTRESOURCE(16)\n#define RT_VXD\t\tMAKEINTRESOURCE(20)\n#define RT_ANICURSOR\tMAKEINTRESOURCE(21)\n#define RT_ANIICON\tMAKEINTRESOURCE(22)\n#define RT_HTML\t\tMAKEINTRESOURCE(23)\n#define RT_DLGINCLUDE MAKEINTRESOURCE(0x11)\n#define RT_PLUGPLAY\tMAKEINTRESOURCE(19)\n#define RT_HTML\tMAKEINTRESOURCE(23)\n#define SERVICE_WIN32\t48\n#define SERVICE_DRIVER\t11\n#define CP_INSTALLED\t1\n#define CP_SUPPORTED\t2\n#define LCID_INSTALLED\t1\n#define LCID_SUPPORTED\t2\n#define TAPE_ERASE_LONG\t1\n#define TAPE_ERASE_SHORT\t0\n#define PR_JOBSTATUS\t0\n#define SP_NOTREPORTED\t0x4000\n#define SP_ERROR\t(-1)\n#define SP_OUTOFDISK\t(-4)\n#define SP_OUTOFMEMORY\t(-5)\n#define SP_USERABORT\t(-3)\n#define SP_APPABORT\t(-2)\n#define PHYSICALWIDTH\t110\n#define PHYSICALHEIGHT\t111\n#define PHYSICALOFFSETX\t112\n#define PHYSICALOFFSETY\t113\n#define SCALINGFACTORX\t114\n#define SCALINGFACTORY\t115\n#define QUERYESCSUPPORT\t8\n#define ABORTDOC\t2\n#define ENDDOC\t11\n#define GETPHYSPAGESIZE\t12\n#define GETPRINTINGOFFSET\t13\n#define GETSCALINGFACTOR\t14\n#define NEWFRAME\t1\n#define NEXTBAND\t3\n#define PASSTHROUGH\t19\n#define SETABORTPROC\t9\n#define STARTDOC\t10\n#define SETCOLORTABLE\t4\n#define GETCOLORTABLE\t5\n#define FLUSHOUTPUT\t6\n#define DRAFTMODE\t7\n#define MFCOMMENT\t15\n#define GETPENWIDTH\t16\n#define SETCOPYCOUNT\t17\n#define SELECTPAPERSOURCE\t18\n#define DEVICEDATA\t19\n#define GETTECHNOLGY\t20\n#define GETTECHNOLOGY\t20\n#define SETLINECAP\t21\n#define SETLINEJOIN\t22\n#define SETMITERLIMIT\t23\n#define BANDINFO\t24\n#define DRAWPATTERNRECT\t25\n#define GETVECTORPENSIZE\t26\n#define GETVECTORBRUSHSIZE\t27\n#define ENABLEDUPLEX\t28\n#define GETSETPAPERBINS\t29\n#define GETSETPRINTORIENT\t30\n#define ENUMPAPERBINS\t31\n#define SETDIBSCALING\t32\n#define EPSPRINTING\t33\n#define ENUMPAPERMETRICS\t34\n#define GETSETPAPERMETRICS\t35\n#define POSTSCRIPT_DATA\t37\n#define POSTSCRIPT_IGNORE\t38\n#define MOUSETRAILS\t39\n#define GETDEVICEUNITS\t42\n#define GETEXTENDEDTEXTMETRICS\t256\n#define GETEXTENTTABLE\t257\n#define GETPAIRKERNTABLE\t258\n#define GETTRACKKERNTABLE\t259\n#define EXTTEXTOUT\t512\n#define GETFACENAME\t513\n#define DOWNLOADFACE\t514\n#define ENABLERELATIVEWIDTHS\t768\n#define ENABLEPAIRKERNING\t769\n#define SETKERNTRACK\t770\n#define SETALLJUSTVALUES\t771\n#define SETCHARSET\t772\n#define STRETCHBLT\t2048\n#define METAFILE_DRIVER\t2049\n#define GETSETSCREENPARAMS\t3072\n#define QUERYDIBSUPPORT\t3073\n#define BEGIN_PATH\t4096\n#define CLIP_TO_PATH\t4097\n#define END_PATH\t4098\n#define EXT_DEVICE_CAPS\t4099\n#define RESTORE_CTM\t4100\n#define SAVE_CTM\t4101\n#define SET_ARC_DIRECTION\t4102\n#define SET_BACKGROUND_COLOR\t4103\n#define SET_POLY_MODE\t4104\n#define SET_SCREEN_ANGLE\t4105\n#define SET_SPREAD\t4106\n#define TRANSFORM_CTM\t4107\n#define SET_CLIP_BOX\t4108\n#define SET_BOUNDS\t4109\n#define SET_MIRROR_MODE\t4110\n#define OPENCHANNEL\t4110\n#define DOWNLOADHEADER\t4111\n#define CLOSECHANNEL\t4112\n#define POSTSCRIPT_PASSTHROUGH\t4115\n#define ENCAPSULATED_POSTSCRIPT\t4116\n#define POSTSCRIPT_IDENTIFY\t4117\n#define POSTSCRIPT_INJECTION\t4118\n#define CHECKJPEGFORMAT\t4119\n#define CHECKPNGFORMAT\t4120\n#define GET_PS_FEATURESETTING\t4121\n#define SPCLPASSTHROUGH2\t4568\n#define PSIDENT_GDICENTRIC\t0\n#define PSIDENT_PSCENTRIC\t1\n#define PSINJECT_BEGINSTREAM\t1\n#define PSINJECT_PSADOBE\t2\n#define PSINJECT_PAGESATEND\t3\n#define PSINJECT_PAGES\t4\n#define PSINJECT_DOCNEEDEDRES\t5\n#define PSINJECT_DOCSUPPLIEDRES\t6\n#define PSINJECT_PAGEORDER\t7\n#define PSINJECT_ORIENTATION\t8\n#define PSINJECT_BOUNDINGBOX\t9\n#define PSINJECT_DOCUMENTPROCESSCOLORS\t10\n#define PSINJECT_COMMENTS\t11\n#define PSINJECT_BEGINDEFAULTS\t12\n#define PSINJECT_ENDDEFAULTS\t13\n#define PSINJECT_BEGINPROLOG\t14\n#define PSINJECT_ENDPROLOG\t15\n#define PSINJECT_BEGINSETUP\t16\n#define PSINJECT_ENDSETUP\t17\n#define PSINJECT_TRAILER\t18\n#define PSINJECT_EOF\t19\n#define PSINJECT_ENDSTREAM\t20\n#define PSINJECT_DOCUMENTPROCESSCOLORSATEND 21\n#define PSINJECT_PAGENUMBER\t100\n#define PSINJECT_BEGINPAGESETUP\t101\n#define PSINJECT_ENDPAGESETUP\t102\n#define PSINJECT_PAGETRAILER\t103\n#define PSINJECT_PLATECOLOR\t104\n#define PSINJECT_SHOWPAGE\t105\n#define PSINJECT_PAGEBBOX\t106\n#define PSINJECT_ENDPAGECOMMENTS 107\n#define PSINJECT_VMSAVE\t200\n#define PSINJECT_VMRESTORE\t201\n#define FEATURESETTING_NUP\t0\n#define FEATURESETTING_OUTPUT\t1\n#define FEATURESETTING_PSLEVEL\t2\n#define FEATURESETTING_CUSTPAPER 3\n#define FEATURESETTING_MIRROR\t4\n#define FEATURESETTING_NEGATIVE\t5\n#define FEATURESETTING_PROTOCOL\t6\n#define PSPROTOCOL_ASCII\t0\n#define PSPROTOCOL_BCP\t1\n#define PSPROTOCOL_TBCP\t2\n#define PSPROTOCOL_BINARY\t3\n#define CLRDTR\t6\n#define CLRRTS\t4\n#define SETDTR\t5\n#define SETRTS\t3\n#define SETXOFF\t1\n#define SETXON\t2\n#define RESETDEV 7\n#define SETBREAK\t8\n#define CLRBREAK\t9\n#define EWX_FORCE\t4\n#define EWX_LOGOFF\t0\n#define EWX_POWEROFF\t8\n#define EWX_REBOOT\t2\n#define EWX_SHUTDOWN\t1\n#define FLOODFILLBORDER\t0\n#define FLOODFILLSURFACE\t1\n#define ETO_CLIPPED\t4\n#define ETO_GLYPH_INDEX\t16\n#define ETO_OPAQUE\t2\n#define ETO_RTLREADING\t128\n#define ETO_PDY\t0x2000\n#define ETO_NUMERICSLOCAL\t0x0400\n#define ETO_NUMERICSLATIN\t0x0800\n#define ETO_IGNORELANGUAGE\t0x1000\n#define ASPECT_FILTERING\t1\n#define FOREGROUND_BLUE\t1\n#define FOREGROUND_GREEN\t2\n#define FOREGROUND_RED\t4\n#define FOREGROUND_INTENSITY\t8\n#define BACKGROUND_BLUE\t16\n#define BACKGROUND_GREEN\t32\n#define BACKGROUND_RED\t64\n#define BACKGROUND_INTENSITY\t128\n#define FILE_NOTIFY_CHANGE_FILE_NAME\t1\n#define FILE_NOTIFY_CHANGE_DIR_NAME\t2\n#define FILE_NOTIFY_CHANGE_ATTRIBUTES\t4\n#define FILE_NOTIFY_CHANGE_SIZE\t8\n#define FILE_NOTIFY_CHANGE_LAST_WRITE\t16\n#define FILE_NOTIFY_CHANGE_LAST_ACCESS 0x20\n#define FILE_NOTIFY_CHANGE_CREATION 0x40\n#define FILE_NOTIFY_CHANGE_SECURITY 256\n#define FILE_ACTION_ADDED 1\n#define FILE_ACTION_REMOVED 2\n#define FILE_ACTION_MODIFIED\t3\n#define FILE_ACTION_RENAMED_OLD_NAME\t4\n#define FILE_ACTION_RENAMED_NEW_NAME\t5\n#define FILE_CASE_SENSITIVE_SEARCH\t1\n#define FILE_CASE_PRESERVED_NAMES\t2\n#define FILE_UNICODE_ON_DISK\t4\n#define FILE_PERSISTENT_ACLS\t8\n#define FILE_FILE_COMPRESSION\t16\n#define FILE_VOLUME_QUOTAS\t32\n#define FILE_SUPPORTS_SPARSE_FILES\t0x40\n#define FILE_SUPPORTS_REPARSE_POINTS\t0x80\n#define FILE_SUPPORTS_REMOTE_STORAGE\t0x100\n#define FILE_VOLUME_IS_COMPRESSED\t0x08000\n#define FILE_SUPPORTS_OBJECT_IDS\t0x10000\n#define FILE_SUPPORTS_ENCRYPTION\t0x20000\n#define MAP_FOLDCZONE\t16\n#define MAP_FOLDDIGITS\t128\n#define MAP_PRECOMPOSED\t32\n#define MAP_COMPOSITE\t64\n#define HC_ACTION\t0\n#define FORMAT_MESSAGE_ALLOCATE_BUFFER\t256\n#define FORMAT_MESSAGE_IGNORE_INSERTS\t512\n#define FORMAT_MESSAGE_FROM_STRING\t1024\n#define FORMAT_MESSAGE_FROM_HMODULE\t2048\n#define FORMAT_MESSAGE_FROM_SYSTEM\t4096\n#define FORMAT_MESSAGE_ARGUMENT_ARRAY\t8192\n#define FORMAT_MESSAGE_MAX_WIDTH_MASK\t255\n#define GDICOMMENT_WINDOWS_METAFILE\t(-2147483647)\n#define GDICOMMENT_BEGINGROUP\t2\n#define GDICOMMENT_ENDGROUP\t3\n#define GDICOMMENT_MULTIFORMATS\t1073741828\n#define GDICOMMENT_IDENTIFIER\t1128875079\n#define CTRL_C_EVENT\t0\n#define CTRL_BREAK_EVENT\t1\n#define CTRL_CLOSE_EVENT\t2\n#define CTRL_LOGOFF_EVENT\t5\n#define CTRL_SHUTDOWN_EVENT\t6\n#define AD_COUNTERCLOCKWISE\t1\n#define AD_CLOCKWISE\t2\n#define SCS_32BIT_BINARY\t0\n#define SCS_DOS_BINARY\t1\n#define SCS_OS216_BINARY\t5\n#define SCS_PIF_BINARY\t3\n#define SCS_POSIX_BINARY\t4\n#define SCS_WOW_BINARY\t2\n#define SCS_OS216_BINARY 5\n#define SCS_64BIT_BINARY 6\n#define DCB_DISABLE\t8\n#define DCB_ENABLE\t4\n#define DCB_RESET\t1\n#define DCB_SET\t3\n#define DCB_ACCUMULATE\t2\n#define DCB_DIRTY\tDCB_ACCUMULATE\n#define GCP_DBCS\t1\n#define GCP_ERROR\t0x8000\n#define GCP_CLASSIN\t0x80000\n#define GCP_DIACRITIC\t256\n#define GCP_DISPLAYZWG\t0x400000\n#define GCP_GLYPHSHAPE\t16\n#define GCP_JUSTIFY\t0x10000\n#define GCP_JUSTIFYIN\t0x200000\n#define GCP_KASHIDA\t1024\n#define GCP_LIGATE\t32\n#define GCP_MAXEXTENT\t0x100000\n#define GCP_NEUTRALOVERRIDE\t0x2000000\n#define GCP_NUMERICOVERRIDE\t0x1000000\n#define GCP_NUMERICSLATIN\t0x4000000\n#define GCP_NUMERICSLOCAL\t0x8000000\n#define GCP_REORDER\t2\n#define GCP_SYMSWAPOFF\t0x800000\n#define GCP_USEKERNING\t8\n#define FLI_GLYPHS\t0x40000\n#define FLI_MASK\t0x103b\n#define GCW_ATOM\t(-32)\n#define GCL_CBCLSEXTRA\t(-20)\n#define GCL_CBWNDEXTRA\t(-18)\n#define GCL_HBRBACKGROUND\t(-10)\n#define GCL_HCURSOR\t(-12)\n#define GCL_HICON\t(-14)\n#define GCL_HICONSM\t(-34)\n#define GCL_HMODULE\t(-16)\n#define GCL_MENUNAME\t(-8)\n#define GCL_STYLE\t(-26)\n#define GCL_WNDPROC\t(-24)\n#define GCLP_MENUNAME\t(-8)\n#define GCLP_HBRBACKGROUND\t(-10)\n#define GCLP_HCURSOR\t(-12)\n#define GCLP_HICON\t(-14)\n#define GCLP_HMODULE\t(-16)\n#define GCLP_WNDPROC\t(-24)\n#define GCLP_HICONSM\t(-34)\n#define CF_BITMAP\t2\n#define CF_DIB\t8\n#define CF_PALETTE\t9\n#define CF_ENHMETAFILE\t14\n#define CF_METAFILEPICT\t3\n#define CF_OEMTEXT\t7\n#define CF_TEXT\t1\n#define CF_UNICODETEXT\t13\n#define CF_DIF\t5\n#define CF_DSPBITMAP\t130\n#define CF_DSPENHMETAFILE\t142\n#define CF_DSPMETAFILEPICT\t131\n#define CF_DSPTEXT\t129\n#define CF_GDIOBJFIRST\t768\n#define CF_GDIOBJLAST\t1023\n#define CF_HDROP\t15\n#define CF_LOCALE\t16\n#define CF_OWNERDISPLAY\t128\n#define CF_PENDATA\t10\n#define CF_PRIVATEFIRST\t512\n#define CF_PRIVATELAST\t767\n#define CF_RIFF\t11\n#define CF_SYLK\t4\n#define CF_WAVE\t12\n#define CF_TIFF\t6\n#define EV_BREAK\t64\n#define EV_CTS\t8\n#define EV_DSR\t16\n#define EV_ERR\t128\n#define EV_EVENT1\t2048\n#define EV_EVENT2\t4096\n#define EV_PERR\t512\n#define EV_RING\t256\n#define EV_RLSD\t32\n#define EV_RX80FULL\t1024\n#define EV_RXCHAR\t1\n#define EV_RXFLAG\t2\n#define EV_TXEMPTY\t4\n#define MS_CTS_ON\t16\n#define MS_DSR_ON\t32\n#define MS_RING_ON\t64\n#define MS_RLSD_ON\t128\n#define MAX_COMPUTERNAME_LENGTH\t15\n#define ENABLE_LINE_INPUT\t2\n#define ENABLE_ECHO_INPUT\t4\n#define ENABLE_PROCESSED_INPUT\t1\n#define ENABLE_WINDOW_INPUT\t8\n#define ENABLE_MOUSE_INPUT\t16\n#define ENABLE_PROCESSED_OUTPUT\t1\n#define ENABLE_WRAP_AT_EOL_OUTPUT\t2\n#define CP_ACP\t0\n#define CP_MACCP\t2\n#define CP_OEMCP\t1\n#define CP_THREAD_ACP 3\n#define CP_SYMBOL 42\n#define CP_UTF7 65000\n#define CP_UTF8 65001\n#define DATE_SHORTDATE\t1\n#define DATE_LONGDATE\t2\n#define DATE_USE_ALT_CALENDAR\t4\n#define DCX_WINDOW\t1\n#define DCX_CACHE\t2\n#define DCX_PARENTCLIP\t32\n#define DCX_CLIPSIBLINGS\t16\n#define DCX_CLIPCHILDREN\t8\n#define DCX_NORESETATTRS\t4\n#define DCX_LOCKWINDOWUPDATE\t0x400\n#define DCX_EXCLUDERGN\t64\n#define DCX_INTERSECTRGN\t128\n#define DCX_VALIDATE\t0x200000\n#define DRIVERVERSION\t0\n#define TECHNOLOGY\t2\n#define DT_PLOTTER\t0\n#define DT_RASDISPLAY\t1\n#define DT_RASPRINTER\t2\n#define DT_RASCAMERA\t3\n#define DT_CHARSTREAM\t4\n#define DT_METAFILE\t5\n#define DT_DISPFILE\t6\n#define HORZSIZE\t4\n#define VERTSIZE\t6\n#define HORZRES\t8\n#define VERTRES\t10\n#define LOGPIXELSX\t88\n#define LOGPIXELSY\t90\n#define BITSPIXEL\t12\n#define PLANES\t14\n#define NUMBRUSHES\t16\n#define NUMPENS\t18\n#define NUMFONTS\t22\n#define NUMCOLORS\t24\n#define\tNUMMARKERS\t20\n#define ASPECTX\t40\n#define ASPECTY\t42\n#define ASPECTXY\t44\n#define PDEVICESIZE\t26\n#define CLIPCAPS\t36\n#define SIZEPALETTE\t104\n#define NUMRESERVED\t106\n#define COLORRES\t108\n#define VREFRESH\t116\n#define DESKTOPHORZRES\t118\n#define DESKTOPVERTRES\t117\n#define BLTALIGNMENT\t119\n#define RASTERCAPS\t38\n#define RC_BANDING\t2\n#define RC_BITBLT\t1\n#define RC_BITMAP64\t8\n#define RC_DI_BITMAP\t128\n#define RC_DIBTODEV\t512\n#define RC_FLOODFILL\t4096\n#define RC_GDI20_OUTPUT\t16\n#define RC_PALETTE\t256\n#define RC_SCALING\t4\n#define RC_STRETCHBLT\t2048\n#define RC_STRETCHDIB\t8192\n#define RC_DEVBITS\t0x8000\n#define RC_OP_DX_OUTPUT\t0x4000\n#define CURVECAPS\t28\n#define CC_NONE\t0\n#define CC_CIRCLES\t1\n#define CC_PIE\t2\n#define CC_CHORD\t4\n#define CC_ELLIPSES\t8\n#define CC_WIDE\t16\n#define CC_STYLED\t32\n#define CC_WIDESTYLED\t64\n#define CC_INTERIORS\t128\n#define CC_ROUNDRECT\t256\n#define LINECAPS\t30\n#define LC_NONE\t0\n#define LC_POLYLINE\t2\n#define LC_MARKER\t4\n#define LC_POLYMARKER\t8\n#define LC_WIDE\t16\n#define LC_STYLED\t32\n#define LC_WIDESTYLED\t64\n#define LC_INTERIORS\t128\n#define POLYGONALCAPS\t32\n#define RC_BANDING\t2\n#define RC_BIGFONT\t1024\n#define RC_BITBLT\t1\n#define RC_BITMAP64\t8\n#define RC_DEVBITS\t0x8000\n#define RC_DI_BITMAP\t128\n#define RC_GDI20_OUTPUT\t16\n#define RC_GDI20_STATE\t32\n#define RC_NONE\t0\n#define RC_OP_DX_OUTPUT\t0x4000\n#define RC_PALETTE\t256\n#define RC_SAVEBITMAP\t64\n#define RC_SCALING\t4\n#define PC_NONE\t0\n#define PC_POLYGON\t1\n#define PC_POLYPOLYGON\t256\n#define PC_PATHS\t512\n#define PC_RECTANGLE\t2\n#define PC_WINDPOLYGON\t4\n#define PC_SCANLINE\t8\n#define PC_TRAPEZOID\t4\n#define PC_WIDE\t16\n#define PC_STYLED\t32\n#define PC_WIDESTYLED\t64\n#define PC_INTERIORS\t128\n#define TEXTCAPS\t34\n#define TC_OP_CHARACTER\t1\n#define TC_OP_STROKE\t2\n#define TC_CP_STROKE\t4\n#define TC_CR_90\t8\n#define TC_CR_ANY\t16\n#define TC_SF_X_YINDEP\t32\n#define TC_SA_DOUBLE\t64\n#define TC_SA_INTEGER\t128\n#define TC_SA_CONTIN\t256\n#define TC_EA_DOUBLE\t512\n#define TC_IA_ABLE\t1024\n#define TC_UA_ABLE\t2048\n#define TC_SO_ABLE\t4096\n#define TC_RA_ABLE\t8192\n#define TC_VA_ABLE\t16384\n#define TC_RESERVED\t32768\n#define TC_SCROLLBLT\t65536\n#define PC_PATHS\t512\n#define CP_NONE\t0\n#define CP_RECTANGLE\t1\n#define CP_REGION\t2\n#define DRIVE_REMOVABLE\t2\n#define DRIVE_FIXED\t3\n#define DRIVE_REMOTE\t4\n#define DRIVE_CDROM\t5\n#define DRIVE_RAMDISK\t6\n#define DRIVE_UNKNOWN\t0\n#define DRIVE_NO_ROOT_DIR\t1\n#define EXCEPTION_ACCESS_VIOLATION\t0xc0000005\n#define EXCEPTION_BREAKPOINT\t0x80000003\n#define EXCEPTION_DATATYPE_MISALIGNMENT\t0x80000002\n#define EXCEPTION_SINGLE_STEP\t0x80000004\n#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED\t0xc000008c\n#define EXCEPTION_FLT_DENORMAL_OPERAND\t0xc000008d\n#define EXCEPTION_FLT_DIVIDE_BY_ZERO\t0xc000008e\n#define EXCEPTION_FLT_INEXACT_RESULT\t0xc000008f\n#define EXCEPTION_FLT_INVALID_OPERATION\t0xc0000090\n#define EXCEPTION_FLT_OVERFLOW\t0xc0000091\n#define EXCEPTION_FLT_STACK_CHECK\t0xc0000092\n#define EXCEPTION_FLT_UNDERFLOW\t0xc0000093\n#define EXCEPTION_INT_DIVIDE_BY_ZERO\t0xc0000094\n#define EXCEPTION_INT_OVERFLOW\t0xc0000095\n#define EXCEPTION_PRIV_INSTRUCTION\t0xc0000096\n#define EXCEPTION_IN_PAGE_ERROR\t\t0xC0000025\n#define EXCEPTION_ILLEGAL_INSTRUCTION     STATUS_ILLEGAL_INSTRUCTION\n#define EXCEPTION_INVALID_HANDLE        STATUS_INVALID_HANDLE\n#define EXCEPTION_NONCONTINUABLE_EXCEPTION\t0xc0000025\n#define EXCEPTION_NONCONTINUABLE\t1\n#define EXCEPTION_STACK_OVERFLOW\t0xc00000fd\n#define EXCEPTION_INVALID_DISPOSITION\t0xc0000026\n#define EXCEPTION_POSSIBLE_DEADLOCK 0xC0000194L\n#define CS_ENABLE 1\n#define CS_DISABLE 2\n#define CS_DELETE_TRANSFORM 3\n#define LCS_SIGNATURE 'PSOC'\n#define LCS_sRGB 'sRGB'\n#define LCS_WINDOWS_COLOR_SPACE 'Win '\n#define LCS_CALIBRATED_RGB\t0\n#define LCS_DEVICE_RGB\t1\n#define LCS_DEVICE_CMYK\t2\n#define LCS_GM_BUSINESS\t1\n#define LCS_GM_GRAPHICS\t2\n#define LCS_GM_IMAGES\t4\n#define ICM_ADDPROFILE\t1\n#define ICM_DELETEPROFILE\t2\n#define ICM_QUERYPROFILE\t3\n#define ICM_SETDEFAULTPROFILE\t4\n#define ICM_REGISTERICMATCHER\t5\n#define ICM_UNREGISTERICMATCHER 6\n#define ICM_QUERYMATCH\t7\n#define CM_OUT_OF_GAMUT\t255\n#define CM_IN_GAMUT\t0\n#define FILE_TYPE_UNKNOWN\t0\n#define FILE_TYPE_DISK\t1\n#define FILE_TYPE_CHAR\t2\n#define FILE_TYPE_PIPE\t3\n#define FILE_TYPE_REMOTE 0x8000\n#define GGO_BITMAP\t1\n#define GGO_NATIVE\t2\n#define GGO_METRICS\t0\n#define GGO_GRAY2_BITMAP\t4\n#define GGO_GRAY4_BITMAP\t5\n#define GGO_GRAY8_BITMAP\t6\n#define GDI_ERROR\t0xffffffff\n#define HGDI_ERROR (LongToHandle(0xFFFFFFFFL))\n#define GM_COMPATIBLE\t1\n#define GM_ADVANCED\t2\n\n//#if(WINVER >= 0x0500)\n#define WS_EX_NOINHERITLAYOUT  0x00100000L\n#define WS_EX_LAYOUTRTL      0x00400000L\n//#endif\n\n//#if(_WIN32_WINNT >= 0x0501)\n#define WS_EX_COMPOSITED     0x02000000L\n//#endif\n//#if(_WIN32_WINNT >= 0x0500)\n#define WS_EX_NOACTIVATE     0x08000000L\n//#endif\n#define HANDLE_FLAG_INHERIT\t1\n#define HANDLE_FLAG_PROTECT_FROM_CLOSE\t2\n#define IE_BADID  (-1)\n#define IE_OPEN   (-2)\n#define IE_NOPEN  (-3)\n#define IE_MEMORY (-4)\n#define IE_DEFAULT (-5)\n#define IE_HARDWARE (-10)\n#define IE_BYTESIZE (-11)\n#define IE_BAUDRATE (-12)\n#define IDC_HAND\tMAKEINTRESOURCE(32649)\n#define IDC_ARROW\tMAKEINTRESOURCE(32512)\n#define IDC_IBEAM\tMAKEINTRESOURCE(32513)\n#define IDC_WAIT\tMAKEINTRESOURCE(32514)\n#define IDC_CROSS\tMAKEINTRESOURCE(32515)\n#define IDC_UPARROW\tMAKEINTRESOURCE(32516)\n#define IDC_SIZENWSE\tMAKEINTRESOURCE(32642)\n#define IDC_SIZENESW\tMAKEINTRESOURCE(32643)\n#define IDC_SIZEWE\tMAKEINTRESOURCE(32644)\n#define IDC_SIZENS\tMAKEINTRESOURCE(32645)\n#define IDC_SIZEALL\tMAKEINTRESOURCE(32646)\n#define IDC_ICON\tMAKEINTRESOURCE(32641)\n#define IDC_SIZE\tMAKEINTRESOURCE(32640)\n#define IDC_NO\tMAKEINTRESOURCE(32648)\n#define IDC_APPSTARTING\tMAKEINTRESOURCE(32650)\n#define IDC_HELP\tMAKEINTRESOURCE(32651)\n#define IDI_APPLICATION\tMAKEINTRESOURCE(32512)\n#define IDI_HAND\tMAKEINTRESOURCE(32513)\n#define IDI_QUESTION\tMAKEINTRESOURCE(32514)\n#define IDI_EXCLAMATION\tMAKEINTRESOURCE(32515)\n#define IDI_ASTERISK\tMAKEINTRESOURCE(32516)\n#define IDI_WINLOGO\tMAKEINTRESOURCE(32517)\n#define IDI_WARNING\tIDI_EXCLAMATION\n#define IDI_ERROR\tIDI_HAND\n#define IDI_INFORMATION IDI_ASTERISK\n#define MM_ANISOTROPIC\t8\n#define MM_HIENGLISH\t5\n#define MM_HIMETRIC\t3\n#define MM_ISOTROPIC\t7\n#define MM_LOENGLISH\t4\n#define MM_LOMETRIC\t2\n#define MM_TEXT\t1\n#define MM_TWIPS\t6\n#define GMDI_GOINTOPOPUPS\t2\n#define GMDI_USEDISABLED\t1\n#define PM_NOREMOVE\t0\n#define PM_REMOVE\t1\n#define PM_NOYIELD\t2\n#define PIPE_NOWAIT\t1\n#define PIPE_READMODE_MESSAGE\t2\n#define PIPE_CLIENT_END\t0\n#define PIPE_SERVER_END\t1\n#define GW_HWNDNEXT\t2\n#define GW_HWNDPREV\t3\n#define GW_CHILD\t5\n#define GW_HWNDFIRST\t0\n#define GW_HWNDLAST\t1\n#define GW_OWNER\t4\n#define GetNextWindow(HWND,cmd) GetWindow(HWND,cmd)\n#define PT_MOVETO\t6\n#define PT_LINETO\t2\n#define PT_BEZIERTO\t4\n#define PT_CLOSEFIGURE\t1\n#define SHUTDOWN_NORETRY\t1\n#define QS_ALLEVENTS\t191\n#define QS_ALLINPUT\t255\n#define QS_HOTKEY\t128\n#define QS_INPUT\t7\n#define QS_KEY\t1\n#define QS_MOUSE\t6\n#define QS_MOUSEBUTTON\t4\n#define QS_MOUSEMOVE\t2\n#define QS_PAINT\t32\n#define QS_POSTMESSAGE\t8\n#define QS_SENDMESSAGE\t64\n#define QS_TIMER\t16\n#define SIF_TRACKPOS\t16\n#define SIF_PAGE\t2\n#define SIF_POS\t4\n#define SIF_RANGE\t1\n#define SIF_DISABLENOSCROLL\t8\n#define SIF_ALL\t(SIF_RANGE|SIF_PAGE|SIF_POS|SIF_TRACKPOS)\n//#ifndef __stdio_h__\n#define STD_INPUT_HANDLE\t(DWORD)(0xfffffff6)\n#define STD_OUTPUT_HANDLE\t(DWORD)(0xfffffff5)\n#define STD_ERROR_HANDLE\t(DWORD)(0xfffffff4)\n//#endif\n#define INVALID_HANDLE_VALUE\t(HANDLE)(0xffffffff)\n#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)\n#define INVALID_SET_FILE_POINTER ((DWORD)-1)\n#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)\n#define BLACK_BRUSH\t4\n#define DKGRAY_BRUSH\t3\n#define GRAY_BRUSH\t2\n#define HOLLOW_BRUSH\t5\n#define LTGRAY_BRUSH\t1\n#define NULL_BRUSH\t5\n#define WHITE_BRUSH\t0\n#define BLACK_PEN\t7\n#define NULL_PEN\t8\n#define WHITE_PEN\t6\n#define ANSI_FIXED_FONT\t11\n#define ANSI_VAR_FONT\t12\n#define DEVICE_DEFAULT_FONT\t14\n#define DEFAULT_GUI_FONT\t17\n#define OEM_FIXED_FONT\t10\n#define SYSTEM_FONT\t13\n#define SYSTEM_FIXED_FONT\t16\n\n//#if(WINVER >= 0x0400)\n#define DEFAULT_GUI_FONT\t17\n//#endif\n#define DC_BRUSH        18\n#define DC_PEN         19\n//#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)\n#define STOCK_LAST       19\n//#elif (WINVER >= 0x0400)\n//#define STOCK_LAST       17\n//#else\n//#define STOCK_LAST       16\n//#endif\n\n#define DEFAULT_PALETTE\t15\n#define CT_CTYPE1\t1\n#define CT_CTYPE2\t2\n#define CT_CTYPE3\t4\n#define C1_UPPER\t1\n#define C1_LOWER\t2\n#define C1_DIGIT\t4\n#define C1_SPACE\t8\n#define C1_PUNCT\t16\n#define C1_CNTRL\t32\n#define C1_BLANK\t64\n#define C1_XDIGIT\t128\n#define C1_ALPHA\t256\n#define C2_LEFTTORIGHT\t1\n#define C2_RIGHTTOLEFT\t2\n#define C2_EUROPENUMBER\t3\n#define C2_EUROPESEPARATOR\t4\n#define C2_EUROPETERMINATOR\t5\n#define C2_ARABICNUMBER\t6\n#define C2_COMMONSEPARATOR\t7\n#define C2_BLOCKSEPARATOR\t8\n#define C2_SEGMENTSEPARATOR\t9\n#define C2_WHITESPACE\t10\n#define C2_OTHERNEUTRAL\t11\n#define C2_NOTAPPLICABLE\t0\n#define C3_NONSPACING\t1\n#define C3_DIACRITIC\t2\n#define C3_VOWELMARK\t4\n#define C3_SYMBOL\t8\n#define C3_KATAKANA\t16\n#define C3_HIRAGANA\t32\n#define C3_HALFWIDTH\t64\n#define C3_FULLWIDTH\t128\n#define C3_IDEOGRAPH\t256\n#define C3_KASHIDA\t512\n#define C3_ALPHA\t32768\n#define C3_NOTAPPLICABLE\t0\n#define COLOR_HOTLIGHT\t26\n#define COLOR_GRADIENTACTIVECAPTION 27\n#define COLOR_GRADIENTINACTIVECAPTION 28\n#define COLOR_MENUHILIGHT\t29\n#define COLOR_MENUBAR\t30\n#define COLOR_3DDKSHADOW\t21\n#define COLOR_3DFACE\t15\n#define COLOR_3DHILIGHT\t20\n#define COLOR_3DHIGHLIGHT\t20\n#define COLOR_3DLIGHT\t22\n#define COLOR_BTNHILIGHT\t20\n#define COLOR_3DSHADOW\t16\n#define COLOR_ACTIVEBORDER\t10\n#define COLOR_ACTIVECAPTION\t2\n#define COLOR_APPWORKSPACE\t12\n#define COLOR_BACKGROUND\t1\n#define COLOR_DESKTOP\t1\n#define COLOR_BTNFACE\t15\n#define COLOR_BTNHIGHLIGHT\t20\n#define COLOR_BTNSHADOW\t16\n#define COLOR_BTNTEXT\t18\n#define COLOR_CAPTIONTEXT\t9\n#define COLOR_GRAYTEXT\t17\n#define COLOR_HIGHLIGHT\t13\n#define COLOR_HIGHLIGHTTEXT\t14\n#define COLOR_INACTIVEBORDER\t11\n#define COLOR_INACTIVECAPTION\t3\n#define COLOR_INACTIVECAPTIONTEXT\t19\n#define COLOR_INFOBK\t24\n#define COLOR_INFOTEXT\t23\n#define COLOR_MENU\t4\n#define COLOR_MENUTEXT\t7\n#define COLOR_SCROLLBAR\t0\n#define COLOR_WINDOW\t5\n#define COLOR_WINDOWFRAME\t6\n#define COLOR_WINDOWTEXT\t8\n#define CTLCOLOR_MSGBOX 0\n#define CTLCOLOR_EDIT 1\n#define CTLCOLOR_LISTBOX 2\n#define CTLCOLOR_BTN 3\n#define CTLCOLOR_DLG 4\n#define CTLCOLOR_SCROLLBAR 5\n#define CTLCOLOR_STATIC 6\n#define CTLCOLOR_MAX 7\n#define\tSM_CXSCREEN\t0\n#define\tSM_CYSCREEN\t1\n#define\tSM_CXVSCROLL\t2\n#define\tSM_CYHSCROLL\t3\n#define\tSM_CYCAPTION\t4\n#define\tSM_CXBORDER\t5\n#define\tSM_CYBORDER\t6\n#define\tSM_CXDLGFRAME\t7\n#define\tSM_CYDLGFRAME\t8\n#define\tSM_CYVTHUMB\t9\n#define\tSM_CXHTHUMB\t10\n#define\tSM_CXICON\t11\n#define\tSM_CYICON\t12\n#define\tSM_CXCURSOR\t13\n#define\tSM_CYCURSOR\t14\n#define\tSM_CYMENU\t15\n#define\tSM_CXFULLSCREEN\t16\n#define\tSM_CYFULLSCREEN\t17\n#define\tSM_CYKANJIWINDOW\t18\n#define\tSM_MOUSEPRESENT\t19\n#define\tSM_CYVSCROLL\t20\n#define\tSM_CXHSCROLL\t21\n#define\tSM_DEBUG\t22\n#define\tSM_SWAPBUTTON\t23\n#define\tSM_RESERVED1\t24\n#define\tSM_RESERVED2\t25\n#define\tSM_RESERVED3\t26\n#define\tSM_RESERVED4\t27\n#define\tSM_CXMIN\t28\n#define\tSM_CYMIN\t29\n#define\tSM_CXSIZE\t30\n#define\tSM_CYSIZE\t31\n#define\tSM_CXFRAME\t32\n#define\tSM_CYFRAME\t33\n#define\tSM_CXMINTRACK\t34\n#define\tSM_CYMINTRACK\t35\n#define\tSM_CXDOUBLECLK\t36\n#define\tSM_CYDOUBLECLK\t37\n#define\tSM_CXICONSPACING\t38\n#define\tSM_CYICONSPACING\t39\n#define\tSM_MENUDROPALIGNMENT\t40\n#define\tSM_PENWINDOWS\t41\n#define\tSM_DBCSENABLED\t42\n#define\tSM_CMOUSEBUTTONS\t43\n#define\tSM_CXFIXEDFRAME\tSM_CXDLGFRAME\n#define\tSM_CYFIXEDFRAME\tSM_CYDLGFRAME\n#define\tSM_CXSIZEFRAME\tSM_CXFRAME\n#define\tSM_CYSIZEFRAME\tSM_CYFRAME\n#define\tSM_SECURE\t44\n#define\tSM_CXEDGE\t45\n#define\tSM_CYEDGE\t46\n#define\tSM_CXMINSPACING\t47\n#define\tSM_CYMINSPACING\t48\n#define\tSM_CXSMICON\t49\n#define\tSM_CYSMICON\t50\n#define\tSM_CYSMCAPTION\t51\n#define\tSM_CXSMSIZE\t52\n#define\tSM_CYSMSIZE\t53\n#define\tSM_CXMENUSIZE\t54\n#define\tSM_CYMENUSIZE\t55\n#define\tSM_ARRANGE\t56\n#define\tSM_CXMINIMIZED\t57\n#define\tSM_CYMINIMIZED\t58\n#define\tSM_CXMAXTRACK\t59\n#define\tSM_CYMAXTRACK\t60\n#define\tSM_CXMAXIMIZED\t61\n#define\tSM_CYMAXIMIZED\t62\n#define\tSM_NETWORK\t63\n#define\tSM_CLEANBOOT\t67\n#define\tSM_CXDRAG\t68\n#define\tSM_CYDRAG\t69\n#define\tSM_SHOWSOUNDS\t70\n#define\tSM_CXMENUCHECK\t71\n#define\tSM_CYMENUCHECK\t72\n#define\tSM_SLOWMACHINE\t73\n#define\tSM_MIDEASTENABLED\t74\n#define\tSM_MOUSEWHEELPRESENT\t75\n#define\tSM_XVIRTUALSCREEN\t76\n#define\tSM_YVIRTUALSCREEN\t77\n#define\tSM_CXVIRTUALSCREEN\t78\n#define\tSM_CYVIRTUALSCREEN\t79\n#define\tSM_CMONITORS\t80\n#define\tSM_SAMEDISPLAYFORMAT\t81\n#define\tSM_CMETRICS\t76\n#define ARW_BOTTOMLEFT\t0\n#define ARW_BOTTOMRIGHT\t1\n#define ARW_HIDE\t8\n#define ARW_TOPLEFT\t2\n#define ARW_TOPRIGHT\t3\n#define ARW_DOWN\t4\n#define ARW_LEFT\t0\n#define ARW_RIGHT\t0\n#define ARW_UP\t4\n#define SYSPAL_NOSTATIC\t2\n#define SYSPAL_STATIC\t1\n#define SYSPAL_ERROR\t0\n#define GET_TAPE_MEDIA_INFORMATION\t0\n#define GET_TAPE_DRIVE_INFORMATION\t1\n#define SET_TAPE_MEDIA_INFORMATION\t0\n#define SET_TAPE_DRIVE_INFORMATION\t1\n#define TAPE_ABSOLUTE_POSITION\t0\n#define TAPE_LOGICAL_POSITION\t1\n#define TA_BASELINE\t24\n#define TA_BOTTOM\t8\n#define TA_TOP\t0\n#define TA_CENTER\t6\n#define TA_LEFT\t0\n#define TA_RIGHT\t2\n#define TA_RTLREADING\t256\n#define TA_MASK\t(TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)\n#define TA_NOUPDATECP\t0\n#define TA_UPDATECP\t1\n#define VTA_BASELINE\t24\n#define VTA_CENTER\t6\n#define VTA_LEFT\tTA_BOTTOM\n#define VTA_RIGHT\tTA_TOP\n#define VTA_BOTTOM\tTA_RIGHT\n#define VTA_TOP\tTA_LEFT\n#define THREAD_PRIORITY_ABOVE_NORMAL\t1\n#define THREAD_PRIORITY_BELOW_NORMAL\t(-1)\n#define THREAD_PRIORITY_HIGHEST\t2\n#define THREAD_PRIORITY_IDLE\t(-15)\n#define THREAD_PRIORITY_LOWEST\t(-2)\n#define THREAD_PRIORITY_NORMAL\t0\n#define THREAD_PRIORITY_TIME_CRITICAL\t15\n#define THREAD_PRIORITY_ERROR_RETURN\t2147483647\n#define TLS_MINIMUM_AVAILABLE\t64\n#define TIME_NOMINUTESORSECONDS\t1\n#define TIME_NOSECONDS\t2\n#define TIME_NOTIMEMARKER\t4\n#define TIME_FORCE24HOURFORMAT\t8\n#define TIME_ZONE_ID_UNKNOWN\t0\n#define TIME_ZONE_ID_STANDARD\t1\n#define TIME_ZONE_ID_DAYLIGHT\t2\n#define UOI_FLAGS\t1\n#define UOI_NAME\t2\n#define UOI_TYPE\t3\n#define FS_CASE_IS_PRESERVED\t2\n#define FS_CASE_SENSITIVE\t1\n#define FS_UNICODE_STORED_ON_DISK\t4\n#define FS_PERSISTENT_ACLS\t8\n#define FS_FILE_COMPRESSION\t16\n#define FS_VOL_IS_COMPRESSED\t32768\n#define FS_FILE_ENCRYPTION FILE_SUPPORTS_ENCRYPTION\n#define GWL_EXSTYLE\t(-20)\n#define GWL_STYLE\t(-16)\n#define GWL_WNDPROC\t(-4)\n#define GWL_HINSTANCE\t(-6)\n#define GWL_HWNDPARENT\t(-8)\n#define GWL_ID\t(-12)\n#define GWL_USERDATA\t(-21)\n#define GWLP_WNDPROC\t(-4)\n#define GWLP_HINSTANCE\t(-6)\n#define GWLP_HWNDPARENT\t(-8)\n#define GWLP_USERDATA\t(-21)\n#define GWLP_ID\t(-12)\n#define DWL_DLGPROC\t4\n#define DWL_MSGRESULT\t0\n#define DWL_USER\t8\n#define DWLP_MSGRESULT\t0\n#define DWLP_DLGPROC\tDWLP_MSGRESULT+sizeof(LRESULT)\n#define DWLP_USER\tDWLP_DLGPROC+sizeof(DLGPROC)\n#define GMEM_FIXED\t0\n#define GMEM_MOVEABLE\t2\n#define GMEM_MODIFY 128\n#define GMEM_VALID_FLAGS 0x7F72\n#define GPTR\t64\n#define GHND\t66\n#define GMEM_DDESHARE\t8192\n#define GMEM_DISCARDABLE\t256\n#define GMEM_LOWER\t4096\n#define GMEM_NOCOMPACT\t16\n#define GMEM_NODISCARD\t32\n#define GMEM_NOT_BANKED\t4096\n#define GMEM_NOTIFY\t16384\n#define GMEM_SHARE\t8192\n#define GMEM_ZEROINIT\t64\n#define GMEM_DISCARDED\t16384\n#define GMEM_INVALID_HANDLE\t32768\n#define GMEM_LOCKCOUNT\t255\n#define GlobalLRUNewest(h) ((HANDLE)(h))\n#define GlobalLRUOldest(h) ((HANDLE)(h))\n#define HEAP_GENERATE_EXCEPTIONS\t4\n#define HEAP_NO_SERIALIZE\t1\n#define HEAP_ZERO_MEMORY\t8\n#define STATUS_WAIT_0\t0\n#define STATUS_ABANDONED_WAIT_0\t0x80\n#define STATUS_USER_APC\t0xC0\n#define STATUS_TIMEOUT\t0x102\n#define STATUS_PENDING\t0x103\n#define STATUS_SEGMENT_NOTIFICATION\t0x40000005\n#define STATUS_GUARD_PAGE_VIOLATION\t0x80000001\n#define STATUS_DATATYPE_MISALIGNMENT\t0x80000002\n#define STATUS_BREAKPOINT\t0x80000003\n#define STATUS_SINGLE_STEP\t0x80000004\n#define STATUS_ACCESS_VIOLATION\t0xC0000005\n#define STATUS_IN_PAGE_ERROR\t0xC0000006\n#define STATUS_NO_MEMORY\t0xC0000017\n#define STATUS_ILLEGAL_INSTRUCTION\t0xC000001D\n#define STATUS_NONCONTINUABLE_EXCEPTION\t0xC0000025\n#define STATUS_INVALID_DISPOSITION\t0xC0000026\n#define STATUS_ARRAY_BOUNDS_EXCEEDED\t0xC000008C\n#define STATUS_FLOAT_DENORMAL_OPERAND\t0xC000008D\n#define STATUS_FLOAT_DIVIDE_BY_ZERO\t0xC000008E\n#define STATUS_FLOAT_INEXACT_RESULT\t0xC000008F\n#define STATUS_FLOAT_INVALID_OPERATION\t0xC0000090\n#define STATUS_FLOAT_OVERFLOW\t0xC0000091\n#define STATUS_FLOAT_STACK_CHECK\t0xC0000092\n#define STATUS_FLOAT_UNDERFLOW\t0xC0000093\n#define STATUS_INTEGER_DIVIDE_BY_ZERO\t0xC0000094\n#define STATUS_INTEGER_OVERFLOW\t0xC0000095\n#define STATUS_PRIVILEGED_INSTRUCTION\t0xC0000096\n#define STATUS_STACK_OVERFLOW\t0xC00000FD\n#define STATUS_CONTROL_C_EXIT\t0xC000013A\n#define STATUS_INVALID_HANDLE ((DWORD)0xC0000008L)\n#define STATUS_POSSIBLE_DEADLOCK 0xC0000194L\n#define ILC_COLOR\t0\n#define ILC_COLOR4\t4\n#define ILC_COLOR8\t8\n#define ILC_COLOR16\t16\n#define ILC_COLOR24\t24\n#define ILC_COLOR32\t32\n#define ILC_COLORDDB\t254\n#define ILC_MASK\t1\n#define ILC_MIRROR\t0x00002000\n#define ILC_PERITEMMIRROR\t0x00008000\n#define ILC_PALETTE\t2048\n#define ILD_BLEND25\t2\n#define ILD_BLEND50\t4\n#define ILD_SELECTED\t4\n#define ILD_BLEND\t4\n#define ILD_FOCUS\t2\n#define ILD_MASK\t16\n#define ILD_NORMAL\t0\n#define ILD_TRANSPARENT\t1\n#define ILD_IMAGE\t0x00000020\n#define ILD_ROP\t0x040\n#define ILD_BLEND25 2\n#define ILD_BLEND50 4\n#define ILD_OVERLAYMASK 0x0F00\n#define INDEXTOOVERLAYMASK(i)\t((i) << 8)\n#define ILD_PRESERVEALPHA 0x1000\n#define ILD_SCALE\t0x00002000\n#define ILD_DPISCALE\t0x00004000\n#define ILS_NORMAL\t0\n#define ILS_GLOW\t1\n#define ILS_SHADOW\t2\n#define ILS_SATURATE\t4\n#define ILS_ALPHA\t8\n#define ILCF_MOVE\t0\n#define ILCF_SWAP\t1\n#define CLR_NONE\t0xffffffff\n#define CLR_INVALID\tCLR_NONE\n#define CLR_DEFAULT\t0xff000000\n#define LR_DEFAULTCOLOR\t0\n#define LR_LOADFROMFILE\t16\n#define LR_LOADTRANSPARENT\t32\n#define LR_MONOCHROME\t1\n#define IME_CONFIG_GENERAL\t1\n#define IME_CONFIG_REGISTERWORD\t2\n#define IME_CONFIG_SELECTDICTIONARY\t3\n#define GCL_CONVERSION\t1\n#define GCL_REVERSECONVERSION\t2\n#define GCL_REVERSE_LENGTH\t3\n#define CPS_CANCEL\t4\n#define CPS_COMPLETE\t1\n#define CPS_CONVERT\t2\n#define CPS_REVERT\t3\n#define SECURITY_DESCRIPTOR_REVISION\t1\n#define SECURITY_DESCRIPTOR_REVISION1\t1\n#define IS_TEXT_UNICODE_ASCII16\t1\n#define IS_TEXT_UNICODE_REVERSE_ASCII16\t16\n#define IS_TEXT_UNICODE_STATISTICS\t2\n#define IS_TEXT_UNICODE_REVERSE_STATISTICS\t32\n#define IS_TEXT_UNICODE_CONTROLS\t4\n#define IS_TEXT_UNICODE_REVERSE_CONTROLS\t64\n#define IS_TEXT_UNICODE_SIGNATURE\t8\n#define IS_TEXT_UNICODE_REVERSE_SIGNATURE\t128\n#define IS_TEXT_UNICODE_ILLEGAL_CHARS\t256\n#define IS_TEXT_UNICODE_ODD_LENGTH\t512\n#define IS_TEXT_UNICODE_NULL_BYTES\t4096\n#define IS_TEXT_UNICODE_UNICODE_MASK\t15\n#define IS_TEXT_UNICODE_REVERSE_MASK\t240\n#define IS_TEXT_UNICODE_NOT_UNICODE_MASK\t3840\n#define IS_TEXT_UNICODE_NOT_ASCII_MASK\t61440\n#define HC_GETNEXT\t1\n#define HC_SKIP\t2\n#define HC_SYSMODALOFF\t5\n#define HC_SYSMODALON\t4\n#define HC_NOREMOVE\t3\n#define KEYEVENTF_EXTENDEDKEY\t1\n#define KEYEVENTF_KEYUP\t2\n#define OBM_BTNCORNERS\t32758\n#define OBM_BTSIZE\t32761\n#define OBM_CHECK\t32760\n#define OBM_CHECKBOXES\t32759\n#define OBM_CLOSE\t32754\n#define OBM_COMBO\t32738\n#define OBM_DNARROW\t32752\n#define OBM_DNARROWD\t32742\n#define OBM_DNARROWI\t32736\n#define OBM_LFARROW\t32750\n#define OBM_LFARROWI\t32734\n#define OBM_LFARROWD\t32740\n#define OBM_MNARROW\t32739\n#define OBM_OLD_CLOSE\t32767\n#define OBM_OLD_DNARROW\t32764\n#define OBM_OLD_LFARROW\t32762\n#define OBM_OLD_REDUCE\t32757\n#define OBM_OLD_RESTORE\t32755\n#define OBM_OLD_RGARROW\t32763\n#define OBM_OLD_UPARROW\t32765\n#define OBM_OLD_ZOOM\t32756\n#define OBM_REDUCE\t32749\n#define OBM_REDUCED\t32746\n#define OBM_RESTORE\t32747\n#define OBM_RESTORED\t32744\n#define OBM_RGARROW\t32751\n#define OBM_RGARROWD\t32741\n#define OBM_RGARROWI\t32735\n#define OBM_SIZE\t32766\n#define OBM_UPARROW\t32753\n#define OBM_UPARROWD\t32743\n#define OBM_UPARROWI\t32737\n#define OBM_ZOOM\t32748\n#define OBM_ZOOMD\t32745\n#define DONT_RESOLVE_DLL_REFERENCES\t1\n#define LOAD_LIBRARY_AS_DATAFILE\t2\n#define LOAD_WITH_ALTERED_SEARCH_PATH\t8\n#define LMEM_FIXED\t0\n#define LMEM_MOVEABLE\t2\n#define LPTR\t64\n#define LHND\t66\n#define NONZEROLHND\t2\n#define NONZEROLPTR\t0\n#define LMEM_NONZEROLHND\t2\n#define LMEM_NONZEROLPTR\t0\n#define LMEM_DISCARDABLE\t3840\n#define LMEM_NOCOMPACT\t16\n#define LMEM_NODISCARD\t32\n#define LMEM_ZEROINIT\t64\n#define LMEM_DISCARDED\t16384\n#define LMEM_MODIFY\t128\n#define LMEM_INVALID_HANDLE\t32768\n#define LMEM_LOCKCOUNT\t255\n#define LOCKFILE_FAIL_IMMEDIATELY\t1\n#define LOCKFILE_EXCLUSIVE_LOCK\t2\n#define MB_USERICON\t128\n#define MB_ICONASTERISK\t64\n#define MB_ICONEXCLAMATION\t0x30\n#define MB_ICONWARNING\t0x30\n#define MB_ICONERROR\t16\n#define MB_ICONHAND\t16\n#define MB_ICONQUESTION\t32\n#define MB_OK\t0\n#define MB_ABORTRETRYIGNORE\t2\n#define MB_APPLMODAL\t0\n#define MB_DEFAULT_DESKTOP_ONLY\t0x20000\n#define MB_HELP\t0x4000\n#define MB_RIGHT\t0x80000\n#define MB_RTLREADING\t0x100000\n#define MB_TOPMOST\t0x40000\n#define MB_DEFBUTTON1\t0\n#define MB_DEFBUTTON2\t256\n#define MB_DEFBUTTON3\t512\n#define MB_DEFBUTTON4\t0x300\n#define MB_ICONINFORMATION\t64\n#define MB_ICONSTOP\t16\n#define MB_OKCANCEL\t1\n#define MB_RETRYCANCEL\t0x5\n#define MB_SERVICE_NOTIFICATION\t0x40000\n#define MB_SETFOREGROUND\t0x10000\n#define MB_SYSTEMMODAL\t4096\n#define MB_TASKMODAL\t0x2000\n#define MB_YESNO\t4\n#define MB_YESNOCANCEL\t3\n#define IDABORT\t3\n#define IDCANCEL\t2\n#define IDCLOSE\t8\n#define IDHELP\t9\n#define IDIGNORE\t5\n#define IDNO\t7\n#define IDOK\t1\n#define IDRETRY\t4\n#define IDYES\t6\n#define MSGF_DIALOGBOX\t0\n#define MSGF_MENU\t2\n#define MSGF_NEXTWINDOW\t6\n#define MSGF_SCROLLBAR\t5\n#define MSGF_MAINLOOP\t8\n#define MSGF_USER\t4096\n#define MWT_IDENTITY\t1\n#define MWT_LEFTMULTIPLY\t2\n#define MWT_RIGHTMULTIPLY\t3\n#define MWT_MIN\tMWT_IDENTITY\n#define MWT_MAX\tMWT_RIGHTMULTIPLY\n#define MOUSEEVENTF_ABSOLUTE\t32768\n#define MOUSEEVENTF_MOVE\t1\n#define MOUSEEVENTF_LEFTDOWN\t2\n#define MOUSEEVENTF_LEFTUP\t4\n#define MOUSEEVENTF_RIGHTDOWN\t8\n#define MOUSEEVENTF_RIGHTUP\t16\n#define MOUSEEVENTF_MIDDLEDOWN\t32\n#define MOUSEEVENTF_MIDDLEUP\t64\n#define MOVEFILE_REPLACE_EXISTING\t1\n#define MOVEFILE_COPY_ALLOWED\t2\n#define MOVEFILE_DELAY_UNTIL_REBOOT\t4\n#define MOVEFILE_WRITE_THROUGH\t8\n#define MOVEFILE_CREATE_HARD_LINK 16\n#define MOVEFILE_FAIL_IF_NOT_TRACKABLE 32\n#define MOVEFILE_CREATE_HARDLINK 16\n#define MOVEFILE_FAIL_IF_NOT_TRACKABLE 32\n#define WAIT_OBJECT_0\t0\n#define WAIT_ABANDONED_0\t128\n#define WAIT_TIMEOUT\t0x102\n#define WAIT_IO_COMPLETION\t0xc0\n#define WAIT_ABANDONED\t128\n#define WAIT_FAILED\t0xffffffff\n#define MAXIMUM_WAIT_OBJECTS\t64\n#define MAXIMUM_SUSPEND_COUNT\t0x7f\n#define MB_PRECOMPOSED\t1\n#define MB_COMPOSITE\t2\n#define MB_ERR_INVALID_CHARS\t8\n#define MB_USEGLYPHCHARS\t4\n#define TOKEN_ADJUST_DEFAULT\t128\n#define TOKEN_ADJUST_GROUPS\t64\n#define TOKEN_ADJUST_PRIVILEGES\t32\n#define TOKEN_ALL_ACCESS\t0xf00ff\n#define TOKEN_ASSIGN_PRIMARY\t1\n#define TOKEN_DUPLICATE\t2\n#define TOKEN_EXECUTE\t0x20000\n#define TOKEN_IMPERSONATE\t4\n#define TOKEN_QUERY\t8\n#define TOKEN_QUERY_SOURCE\t16\n#define TOKEN_READ\t0x20008\n#define TOKEN_WRITE\t0x200e0\n#define HWND_BROADCAST\t(HWND)65535\n#define CopyMemory\tRtlCopyMemory\n#define RtlCopyMemory\tmemcpy\n#define TAPE_FORMAT\t5\n#define TAPE_LOAD\t0\n#define TAPE_LOCK\t3\n#define TAPE_TENSION\t2\n#define TAPE_UNLOAD\t1\n#define TAPE_UNLOCK\t4\n#define IS_PSREBOOTSYSTEM\t3\n#define IS_PSRESTARTWINDOWS\t2\n#define PSPCB_CREATE\t2\n#define PSPCB_RELEASE\t1\n#define PURGE_TXABORT\t1\n#define PURGE_RXABORT\t2\n#define PURGE_TXCLEAR\t4\n#define PURGE_RXCLEAR\t8\n#define LPTx 0x80\n#define OWNER_SECURITY_INFORMATION\t1\n#define GROUP_SECURITY_INFORMATION\t2\n#define DACL_SECURITY_INFORMATION\t4\n#define SACL_SECURITY_INFORMATION\t8\n#define EVENTLOG_FORWARDS_READ\t4\n#define EVENTLOG_BACKWARDS_READ\t8\n#define EVENTLOG_SEEK_READ\t2\n#define EVENTLOG_SEQUENTIAL_READ\t1\n#define EVENTLOG_ERROR_TYPE\t1\n#define EVENTLOG_WARNING_TYPE\t2\n#define EVENTLOG_INFORMATION_TYPE\t4\n#define EVENTLOG_AUDIT_SUCCESS\t8\n#define EVENTLOG_AUDIT_FAILURE\t16\n#define RDW_ERASE\t4\n#define RDW_FRAME\t1024\n#define RDW_INTERNALPAINT\t2\n#define RDW_INVALIDATE\t1\n#define RDW_NOERASE\t32\n#define RDW_NOFRAME\t2048\n#define RDW_NOINTERNALPAINT\t16\n#define RDW_VALIDATE\t8\n#define RDW_ERASENOW\t512\n#define RDW_UPDATENOW\t256\n#define RDW_ALLCHILDREN\t128\n#define RDW_NOCHILDREN\t64\n#define HKEY_CLASSES_ROOT\t(HKEY)0x80000000\n#define HKEY_CURRENT_USER\t(HKEY)0x80000001\n#define HKEY_LOCAL_MACHINE\t(HKEY)0x80000002\n#define HKEY_USERS\t(HKEY)(-2147483645)\n#define HKEY_PERFORMANCE_DATA\t(HKEY)(-2147483644)\n#define HKEY_CURRENT_CONFIG\t(HKEY)(-2147483643)\n\n//#ifndef HKEY_DYN_DATA\n#define HKEY_DYN_DATA\t((HKEY)(0x80000006))\n//#endif\n#define REG_OPTION_VOLATILE\t1\n#define REG_OPTION_NON_VOLATILE\t0\n#define REG_CREATED_NEW_KEY\t1\n#define REG_OPENED_EXISTING_KEY\t2\n#define REG_BINARY\t3\n#define REG_DWORD\t4\n#define REG_DWORD_LITTLE_ENDIAN\t4\n#define REG_DWORD_BIG_ENDIAN\t5\n#define REG_EXPAND_SZ\t2\n#define REG_LINK\t6\n#define REG_MULTI_SZ\t7\n#define REG_NONE\t0\n#define REG_RESOURCE_LIST\t8\n#define REG_FULL_RESOURCE_DESCRIPTOR 9\n#define REG_RESOURCE_REQUIREMENTS_LIST 10\n#define REG_SZ\t1\n#define MOD_ALT\t1\n#define MOD_CONTROL\t2\n#define MOD_SHIFT\t4\n#define MOD_WIN\t8\n#define IDHOT_SNAPDESKTOP\t(-2)\n#define IDHOT_SNAPWINDOW\t(-1)\n#define REG_NOTIFY_CHANGE_NAME\t1\n#define REG_NOTIFY_CHANGE_ATTRIBUTES\t2\n#define REG_NOTIFY_CHANGE_LAST_SET\t4\n#define REG_NOTIFY_CHANGE_SECURITY\t8\n#define SW_ERASE\t4\n#define SW_INVALIDATE\t2\n#define SW_SCROLLCHILDREN\t1\n#define SMTO_ABORTIFHUNG\t2\n#define SMTO_BLOCK\t1\n#define SMTO_NORMAL\t0\n#define OPAQUE\t2\n#define TRANSPARENT\t1\n#define SLE_ERROR\t1\n#define SLE_MINORERROR\t2\n#define SLE_WARNING\t3\n#define SEM_FAILCRITICALERRORS\t1\n#define SEM_NOALIGNMENTFAULTEXCEPT\t4\n#define SEM_NOGPFAULTERRORBOX\t2\n#define SEM_NOOPENFILEERRORBOX\t32768\n#define ICM_ON\t2\n#define ICM_OFF\t1\n#define ICM_QUERY\t3\n#define LOCALE_ILANGUAGE\t1\n#define LOCALE_SLANGUAGE\t2\n#define LOCALE_SENGLANGUAGE\t4097\n#define LOCALE_SABBREVLANGNAME\t3\n#define LOCALE_SNATIVELANGNAME\t4\n#define LOCALE_ICOUNTRY\t5\n#define LOCALE_SCOUNTRY\t6\n#define LOCALE_SENGCOUNTRY\t4098\n#define LOCALE_SABBREVCTRYNAME\t7\n#define LOCALE_SNATIVECTRYNAME\t8\n#define LOCALE_IDEFAULTLANGUAGE\t9\n#define LOCALE_IDEFAULTCOUNTRY\t10\n#define LOCALE_IDEFAULTANSICODEPAGE\t4100\n#define LOCALE_IDEFAULTCODEPAGE\t11\n#define LOCALE_SLIST\t12\n#define LOCALE_IMEASURE\t13\n#define LOCALE_SDECIMAL\t14\n#define LOCALE_STHOUSAND\t15\n#define LOCALE_SGROUPING\t16\n#define LOCALE_IDIGITS\t17\n#define LOCALE_ILZERO\t18\n#define LOCALE_INEGNUMBER\t4112\n#define LOCALE_SCURRENCY\t20\n#define LOCALE_SMONDECIMALSEP\t22\n#define LOCALE_SMONTHOUSANDSEP\t23\n#define LOCALE_SMONGROUPING\t24\n#define LOCALE_ICURRDIGITS\t25\n#define LOCALE_ICURRENCY\t27\n#define LOCALE_INEGCURR\t28\n#define LOCALE_SDATE\t29\n#define LOCALE_STIME\t30\n#define LOCALE_STIMEFORMAT\t4099\n#define LOCALE_SSHORTDATE\t31\n#define LOCALE_SLONGDATE\t32\n#define LOCALE_IDATE\t33\n#define LOCALE_ILDATE\t34\n#define LOCALE_ITIME\t35\n#define LOCALE_ITLZERO\t37\n#define LOCALE_IDAYLZERO\t38\n#define LOCALE_IMONLZERO\t39\n#define LOCALE_S1159\t40\n#define LOCALE_S2359\t41\n#define LOCALE_ICALENDARTYPE\t4105\n#define LOCALE_IOPTIONALCALENDAR\t4107\n#define LOCALE_IFIRSTDAYOFWEEK\t4108\n#define LOCALE_IFIRSTWEEKOFYEAR\t4109\n#define LOCALE_SDAYNAME1\t42\n#define LOCALE_SDAYNAME2\t43\n#define LOCALE_SDAYNAME3\t44\n#define LOCALE_SDAYNAME4\t45\n#define LOCALE_SDAYNAME5\t46\n#define LOCALE_SDAYNAME6\t47\n#define LOCALE_SDAYNAME7\t48\n#define LOCALE_SABBREVDAYNAME1\t49\n#define LOCALE_SABBREVDAYNAME2\t50\n#define LOCALE_SABBREVDAYNAME3\t51\n#define LOCALE_SABBREVDAYNAME4\t52\n#define LOCALE_SABBREVDAYNAME5\t53\n#define LOCALE_SABBREVDAYNAME6\t54\n#define LOCALE_SABBREVDAYNAME7\t55\n#define LOCALE_SMONTHNAME1\t56\n#define LOCALE_SMONTHNAME2\t57\n#define LOCALE_SMONTHNAME3\t58\n#define LOCALE_SMONTHNAME4\t59\n#define LOCALE_SMONTHNAME5\t60\n#define LOCALE_SMONTHNAME6\t61\n#define LOCALE_SMONTHNAME7\t62\n#define LOCALE_SMONTHNAME8\t63\n#define LOCALE_SMONTHNAME9\t64\n#define LOCALE_SMONTHNAME10\t65\n#define LOCALE_SMONTHNAME11\t66\n#define LOCALE_SMONTHNAME12\t67\n#define LOCALE_SMONTHNAME13\t4110\n#define LOCALE_SABBREVMONTHNAME1\t68\n#define LOCALE_SABBREVMONTHNAME2\t69\n#define LOCALE_SABBREVMONTHNAME3\t70\n#define LOCALE_SABBREVMONTHNAME4\t71\n#define LOCALE_SABBREVMONTHNAME5\t72\n#define LOCALE_SABBREVMONTHNAME6\t73\n#define LOCALE_SABBREVMONTHNAME7\t74\n#define LOCALE_SABBREVMONTHNAME8\t75\n#define LOCALE_SABBREVMONTHNAME9\t76\n#define LOCALE_SABBREVMONTHNAME10\t77\n#define LOCALE_SABBREVMONTHNAME11\t78\n#define LOCALE_SABBREVMONTHNAME12\t79\n#define LOCALE_SABBREVMONTHNAME13\t4111\n#define LOCALE_SPOSITIVESIGN\t80\n#define LOCALE_SNEGATIVESIGN\t81\n#define LOCALE_IPOSSIGNPOSN\t82\n#define LOCALE_INEGSIGNPOSN\t83\n#define LOCALE_IPOSSYMPRECEDES\t84\n#define LOCALE_IPOSSEPBYSPACE\t85\n#define LOCALE_INEGSYMPRECEDES\t86\n#define LOCALE_INEGSEPBYSPACE\t87\n#define LOCALE_NOUSEROVERRIDE\t0x80000000\n#define CAL_ICALINTVALUE\t1\n#define CAL_IYEAROFFSETRANGE\t3\n#define CAL_SABBREVDAYNAME1\t14\n#define CAL_SABBREVDAYNAME2\t15\n#define CAL_SABBREVDAYNAME3\t16\n#define CAL_SABBREVDAYNAME4\t17\n#define CAL_SABBREVDAYNAME5\t18\n#define CAL_SABBREVDAYNAME6\t19\n#define CAL_SABBREVDAYNAME7\t20\n#define CAL_SABBREVMONTHNAME1\t34\n#define CAL_SABBREVMONTHNAME2\t35\n#define CAL_SABBREVMONTHNAME3\t36\n#define CAL_SABBREVMONTHNAME4\t37\n#define CAL_SABBREVMONTHNAME5\t38\n#define CAL_SABBREVMONTHNAME6\t39\n#define CAL_SABBREVMONTHNAME7\t40\n#define CAL_SABBREVMONTHNAME8\t41\n#define CAL_SABBREVMONTHNAME9\t42\n#define CAL_SABBREVMONTHNAME10\t43\n#define CAL_SABBREVMONTHNAME11\t44\n#define CAL_SABBREVMONTHNAME12\t45\n#define CAL_SABBREVMONTHNAME13\t46\n#define CAL_SCALNAME\t2\n#define CAL_SDAYNAME1\t7\n#define CAL_SDAYNAME2\t8\n#define CAL_SDAYNAME3\t9\n#define CAL_SDAYNAME4\t10\n#define CAL_SDAYNAME5\t11\n#define CAL_SDAYNAME6\t12\n#define CAL_SDAYNAME7\t13\n#define CAL_SERASTRING\t4\n#define CAL_SLONGDATE\t6\n#define CAL_SMONTHNAME1\t21\n#define CAL_SMONTHNAME2\t22\n#define CAL_SMONTHNAME3\t23\n#define CAL_SMONTHNAME4\t24\n#define CAL_SMONTHNAME5\t25\n#define CAL_SMONTHNAME6\t26\n#define CAL_SMONTHNAME7\t27\n#define CAL_SMONTHNAME8\t28\n#define CAL_SMONTHNAME9\t29\n#define CAL_SMONTHNAME10\t30\n#define CAL_SMONTHNAME11\t31\n#define CAL_SMONTHNAME12\t32\n#define CAL_SMONTHNAME13\t33\n#define CAL_SSHORTDATE\t5\n#define PROCESS_SET_QUOTA\t256\n#define BLACKONWHITE\t1\n#define COLORONCOLOR\t3\n#define HALFTONE\t4\n#define MAXSTRETCHBLTMODE\t4\n#define STRETCH_ANDSCANS\t1\n#define STRETCH_DELETESCANS\t3\n#define STRETCH_HALFTONE\t4\n#define STRETCH_ORSCANS\t2\n#define WHITEONBLACK\t2\n#define OCR_NORMAL\t32512\n#define OCR_IBEAM\t32513\n#define OCR_WAIT\t32514\n#define OCR_CROSS\t32515\n#define OCR_UP\t32516\n#define OCR_SIZE\t32640\n#define OCR_ICON\t32641\n#define OCR_SIZENWSE\t32642\n#define OCR_SIZENESW\t32643\n#define OCR_SIZEWE\t32644\n#define OCR_SIZENS\t32645\n#define OCR_SIZEALL\t32646\n#define OCR_NO\t32648\n#define OCR_APPSTARTING\t32650\n#define TAPE_ABSOLUTE_BLOCK\t1\n#define TAPE_LOGICAL_BLOCK\t2\n#define TAPE_REWIND\t0\n#define TAPE_SPACE_END_OF_DATA\t4\n#define TAPE_SPACE_FILEMARKS\t6\n#define TAPE_SPACE_RELATIVE_BLOCKS\t5\n#define TAPE_SPACE_SEQUENTIAL_FMKS\t7\n#define TAPE_SPACE_SEQUENTIAL_SMKS\t9\n#define TAPE_SPACE_SETMARKS\t8\n#define EXCEPTION_EXECUTE_HANDLER\t1\n#define EXCEPTION_CONTINUE_EXECUTION\t-1\n#define EXCEPTION_CONTINUE_SEARCH\t0\n#define HWND_BOTTOM\t(HWND)1\n#define HWND_NOTOPMOST\t(HWND)(-2)\n#define HWND_TOP\t(HWND)0\n#define HWND_TOPMOST\t(HWND)(-1)\n#define SWP_DRAWFRAME\t32\n#define SWP_FRAMECHANGED\t32\n#define SWP_HIDEWINDOW\t128\n#define SWP_NOACTIVATE\t16\n#define SWP_NOCOPYBITS\t256\n#define SWP_NOMOVE\t2\n#define SWP_NOSIZE\t1\n#define SWP_NOREDRAW\t8\n#define SWP_NOZORDER\t4\n#define SWP_SHOWWINDOW\t64\n#define SWP_NOOWNERZORDER\t512\n#define SWP_NOREPOSITION\t512\n#define SWP_NOSENDCHANGING\t1024\n#define HSHELL_ACTIVATESHELLWINDOW\t3\n#define HSHELL_GETMINRECT\t5\n#define HSHELL_LANGUAGE\t8\n#define HSHELL_REDRAW\t6\n#define HSHELL_TASKMAN\t7\n#define HSHELL_WINDOWACTIVATED\t4\n#define HSHELL_WINDOWCREATED\t1\n#define HSHELL_WINDOWDESTROYED\t2\n#define HSHELL_ACCESSIBILITYSTATE\t11\n#define HSHELL_APPCOMMAND\t12\n#define SW_HIDE\t0\n#define SW_NORMAL 1\n#define SW_MAXIMIZE\t3\n#define SW_MINIMIZE\t6\n#define SW_RESTORE\t9\n#define SW_SHOW\t5\n#define SW_SHOWDEFAULT\t10\n#define SW_SHOWMAXIMIZED\t3\n#define SW_SHOWMINIMIZED\t2\n#define SW_SHOWMINNOACTIVE\t7\n#define SW_SHOWNA\t8\n#define SW_SHOWNOACTIVATE\t4\n#define SW_SHOWNORMAL\t1\n#define WPF_RESTORETOMAXIMIZED\t2\n#define WPF_SETMINPOSITION\t1\n#define INFINITE\t(-1)\n#define SPI_GETACCESSTIMEOUT\t60\n#define SPI_GETANIMATION\t72\n#define SPI_GETBEEP\t1\n#define SPI_GETBORDER\t5\n#define SPI_GETDEFAULTINPUTLANG\t89\n#define SPI_GETDRAGFULLWINDOWS\t38\n#define SPI_GETFASTTASKSWITCH\t35\n#define SPI_GETFILTERKEYS\t50\n#define SPI_GETFONTSMOOTHING\t74\n#define SPI_GETGRIDGRANULARITY\t18\n#define SPI_GETHIGHCONTRAST\t66\n#define SPI_GETICONMETRICS\t45\n#define SPI_GETICONTITLELOGFONT\t31\n#define SPI_GETICONTITLEWRAP\t25\n#define SPI_GETKEYBOARDDELAY\t22\n#define SPI_GETKEYBOARDPREF\t68\n#define SPI_GETKEYBOARDSPEED\t10\n#define SPI_GETLOWPOWERACTIVE\t83\n#define SPI_GETLOWPOWERTIMEOUT\t79\n#define SPI_GETMENUDROPALIGNMENT\t27\n#define SPI_GETMINIMIZEDMETRICS\t43\n#define SPI_GETMOUSE\t3\n#define SPI_GETMOUSEKEYS\t54\n#define SPI_GETMOUSETRAILS\t94\n#define SPI_GETNONCLIENTMETRICS\t41\n#define SPI_GETPOWEROFFACTIVE\t84\n#define SPI_GETPOWEROFFTIMEOUT\t80\n#define SPI_GETSCREENREADER\t70\n#define SPI_GETSCREENSAVEACTIVE\t16\n#define SPI_GETSCREENSAVETIMEOUT\t14\n#define SPI_GETSERIALKEYS\t62\n#define SPI_GETSHOWSOUNDS\t56\n#define SPI_GETSOUNDSENTRY\t64\n#define SPI_GETSTICKYKEYS\t58\n#define SPI_GETTOGGLEKEYS\t52\n#define SPI_GETMOUSESPEED\t0x70\n#define SPI_SETMOUSESPEED\t0x71\n#define SPI_GETSCREENSAVERRUNNING 0x72\n#define SPI_GETDESKWALLPAPER\t0x73\n#define SPI_GETWINDOWSEXTENSION\t92\n#define SPI_GETWORKAREA\t48\n#define SPI_GETACTIVEWINDOWTRACKING\t0x1000\n#define SPI_SETACTIVEWINDOWTRACKING\t0x1001\n#define SPI_GETMENUANIMATION\t0x1002\n#define SPI_SETMENUANIMATION\t0x1003\n#define SPI_GETCOMBOBOXANIMATION\t0x1004\n#define SPI_SETCOMBOBOXANIMATION\t0x1005\n#define SPI_GETLISTBOXSMOOTHSCROLLING\t0x1006\n#define SPI_SETLISTBOXSMOOTHSCROLLING\t0x1007\n#define SPI_GETGRADIENTCAPTIONS\t0x1008\n#define SPI_SETGRADIENTCAPTIONS\t0x1009\n#define SPI_GETKEYBOARDCUES\t0x100A\n#define SPI_SETKEYBOARDCUES\t0x100B\n#define SPI_GETMENUUNDERLINES\tSPI_GETKEYBOARDCUES\n#define SPI_SETMENUUNDERLINES\tSPI_SETKEYBOARDCUES\n#define SPI_GETACTIVEWNDTRKZORDER\t0x100C\n#define SPI_SETACTIVEWNDTRKZORDER\t0x100D\n#define SPI_GETHOTTRACKING\t0x100E\n#define SPI_SETHOTTRACKING\t0x100F\n#define SPI_GETMENUFADE\t0x1012\n#define SPI_SETMENUFADE\t0x1013\n#define SPI_GETSELECTIONFADE\t0x1014\n#define SPI_SETSELECTIONFADE\t0x1015\n#define SPI_GETTOOLTIPANIMATION\t0x1016\n#define SPI_SETTOOLTIPANIMATION\t0x1017\n#define SPI_GETTOOLTIPFADE\t0x1018\n#define SPI_SETTOOLTIPFADE\t0x1019\n#define SPI_GETCURSORSHADOW\t0x101A\n#define SPI_SETCURSORSHADOW\t0x101B\n#define SPI_GETMOUSESONAR\t0x101C\n#define SPI_SETMOUSESONAR\t0x101D\n#define SPI_GETMOUSECLICKLOCK\t0x101E\n#define SPI_SETMOUSECLICKLOCK\t0x101F\n#define SPI_GETMOUSEVANISH\t0x1020\n#define SPI_SETMOUSEVANISH\t0x1021\n#define SPI_GETFLATMENU\t0x1022\n#define SPI_SETFLATMENU\t0x1023\n#define SPI_GETDROPSHADOW\t0x1024\n#define SPI_SETDROPSHADOW\t0x1025\n#define SPI_GETMOUSECLICKLOCKTIME\t0x2008\n#define SPI_SETMOUSECLICKLOCKTIME\t0x2009\n#define SPI_GETFONTSMOOTHINGTYPE\t0x200A\n#define SPI_SETFONTSMOOTHINGTYPE\t0x200B\n#define FE_FONTSMOOTHINGSTANDARD\t0x0001\n#define FE_FONTSMOOTHINGCLEARTYPE\t0x0002\n#define FE_FONTSMOOTHINGDOCKING\t0x8000\n#define SPI_GETFONTSMOOTHINGCONTRAST\t2\n#define SPI_SETFONTSMOOTHINGCONTRAST\t2\n#define SPI_GETFOCUSBORDERWIDTH\t0x200E\n#define SPI_SETFOCUSBORDERWIDTH\t0x200F\n#define SPI_GETFOCUSBORDERHEIGHT\t0x2010\n#define SPI_SETFOCUSBORDERHEIGHT\t0x2011\n#define SPI_ICONHORIZONTALSPACING\t13\n#define SPI_ICONVERTICALSPACING\t24\n#define SPI_LANGDRIVER\t12\n#define SPI_SCREENSAVERRUNNING\t97\n#define SPI_SETACCESSTIMEOUT\t61\n#define SPI_SETANIMATION\t73\n#define SPI_SETBEEP\t2\n#define SPI_SETBORDER\t6\n#define SPI_SETDEFAULTINPUTLANG\t90\n#define SPI_SETDESKPATTERN\t21\n#define SPI_SETDESKWALLPAPER\t20\n#define SPI_SETDOUBLECLICKTIME\t32\n#define SPI_SETDOUBLECLKHEIGHT\t30\n#define SPI_SETDOUBLECLKWIDTH\t29\n#define SPI_SETDRAGFULLWINDOWS\t37\n#define SPI_SETDRAGHEIGHT\t77\n#define SPI_SETDRAGWIDTH\t76\n#define SPI_SETFASTTASKSWITCH\t36\n#define SPI_SETFILTERKEYS\t51\n#define SPI_SETFONTSMOOTHING\t75\n#define SPI_SETGRIDGRANULARITY\t19\n#define SPI_SETHANDHELD\t78\n#define SPI_SETHIGHCONTRAST\t67\n#define SPI_SETICONMETRICS\t46\n#define SPI_SETICONTITLELOGFONT\t34\n#define SPI_SETICONTITLEWRAP\t26\n#define SPI_SETKEYBOARDDELAY\t23\n#define SPI_SETKEYBOARDPREF\t69\n#define SPI_SETKEYBOARDSPEED\t11\n#define SPI_SETLANGTOGGLE\t91\n#define SPI_SETLOWPOWERACTIVE\t85\n#define SPI_SETLOWPOWERTIMEOUT\t81\n#define SPI_SETMENUDROPALIGNMENT\t28\n#define SPI_SETMINIMIZEDMETRICS\t44\n#define SPI_SETMOUSE\t4\n#define SPI_SETMOUSEBUTTONSWAP\t33\n#define SPI_SETMOUSEKEYS\t55\n#define SPI_SETMOUSETRAILS\t93\n#define SPI_SETNONCLIENTMETRICS\t42\n#define SPI_SETPENWINDOWS\t49\n#define SPI_SETPOWEROFFACTIVE\t86\n#define SPI_SETPOWEROFFTIMEOUT\t82\n#define SPI_SETSCREENREADER\t71\n#define SPI_SETSCREENSAVEACTIVE\t17\n#define SPI_SETSCREENSAVETIMEOUT\t15\n#define SPI_SETSERIALKEYS\t63\n#define SPI_SETSHOWSOUNDS\t57\n#define SPI_SETSOUNDSENTRY\t65\n#define SPI_SETSTICKYKEYS\t59\n#define SPI_SETTOGGLEKEYS\t53\n#define SPI_SETWORKAREA\t47\n#define SPIF_UPDATEINIFILE\t1\n#define SPIF_SENDWININICHANGE\t2\n#define SPIF_SENDCHANGE\t2\n#define TPM_CENTERALIGN\t4\n#define TPM_LEFTALIGN\t0\n#define TPM_RIGHTALIGN\t8\n#define TPM_LEFTBUTTON\t0\n#define TPM_RIGHTBUTTON\t2\n#define TPM_HORIZONTAL\t0\n#define TPM_VERTICAL\t64\n#define TPM_TOPALIGN 0\n#define TPM_VCENTERALIGN 16\n#define TPM_BOTTOMALIGN 32\n#define TPM_NONOTIFY 128\n#define TPM_RETURNCMD 256\n#define TPM_RECURSE\t1\n#define TPM_HORPOSANIMATION 0x0400\n#define TPM_HORNEGANIMATION 0x0800\n#define TPM_VERPOSANIMATION 0x1000\n#define TPM_VERNEGANIMATION 0x2000\n#define TPM_NOANIMATION\t0x4000\n#define TCI_SRCCHARSET\t1\n#define TCI_SRCCODEPAGE\t2\n#define TCI_SRCFONTSIG\t3\n#define WC_COMPOSITECHECK\t512\n#define WC_DISCARDNS\t16\n#define WC_SEPCHARS\t32\n#define WC_DEFAULTCHAR\t64\n#define WC_DIALOG\tMAKEINTATOM(0x8002)\n#define HELP_COMMAND\t0x102\n#define HELP_CONTENTS\t3\n#define HELP_CONTEXT\t1\n#define HELP_CONTEXTPOPUP\t8\n#define HELP_FORCEFILE\t9\n#define HELP_HELPONHELP\t4\n#define HELP_INDEX\t3\n#define HELP_KEY\t0x101\n#define HELP_MULTIKEY\t0x201\n#define HELP_PARTIALKEY\t0x105\n#define HELP_QUIT\t2\n#define HELP_SETCONTENTS\t5\n#define HELP_SETINDEX\t5\n#define HELP_CONTEXTMENU\t0xa\n#define HELP_FINDER\t0xb\n#define HELP_WM_HELP\t0xc\n#define HELP_TCARD\t0x8000\n#define HELP_TCARD_DATA\t16\n#define HELP_TCARD_OTHER_CALLER\t0x11\n#define WNNC_NET_MSNET 0x010000\n#define WNNC_NET_LANMAN 0x020000\n#define WNNC_NET_NETWARE 0x030000\n#define WNNC_NET_VINES 0x040000\n#define WNNC_NET_10NET 0x050000\n#define WNNC_NET_LOCUS 0x060000\n#define WNNC_NET_SUN_PC_NFS 0x070000\n#define WNNC_NET_LANSTEP 0x080000\n#define WNNC_NET_9TILES 0x090000\n#define WNNC_NET_LANTASTIC 0x0A0000\n#define WNNC_NET_AS400 0x0B0000\n#define WNNC_NET_FTP_NFS 0x0C0000\n#define WNNC_NET_PATHWORKS 0x0D0000\n#define WNNC_NET_LIFENET 0x0E0000\n#define WNNC_NET_POWERLAN 0x0F0000\n#define WNNC_NET_BWNFS 0x100000\n#define WNNC_NET_COGENT 0x110000\n#define WNNC_NET_FARALLON 0x120000\n#define WNNC_NET_APPLETALK 0x130000\n#define WNNC_NET_INTERGRAPH 0x140000\n#define WNNC_NET_SYMFONET 0x150000\n#define WNNC_NET_CLEARCASE 0x160000\n#define WNNC_NET_FRONTIER 0x170000\n#define WNNC_NET_BMC 0x180000\n#define WNNC_NET_DCE 0x190000\n#define WNNC_NET_DECORB 0x200000\n#define WNNC_NET_PROTSTOR 0x210000\n#define WNNC_NET_FJ_REDIR 0x220000\n#define WNNC_NET_DISTINCT 0x230000\n#define WNNC_NET_TWINS 0x240000\n#define WNNC_NET_RDR2SAMPLE 0x250000\n#define WNFMT_MULTILINE 1\n#define WNFMT_ABBREVIATED 2\n#define WNFMT_INENUM 16\n#define WNFMT_CONNECTION\t0x20\n#define WNCON_FORNETCARD\t1\n#define WNCON_NOTROUTED\t2\n#define WNCON_SLOWLINK\t4\n#define WNCON_DYNAMIC\t8\n#define NETINFO_DLL16\t1\n#define NETINFO_DISKRED\t4\n#define NETINFO_PRINTERRED\t8\n#define NETPROPERTY_PERSISTENT\t1\n#define CONNECT_UPDATE_PROFILE\t1\n#define CONNECT_UPDATE_RECENT\t2\n#define CONNECT_TEMPORARY\t4\n#define CONNECT_INTERACTIVE\t8\n#define CONNECT_PROMPT\t\t16\n#define CONNECT_NEED_DRIVE\t32\n#define CONNECT_REFCOUNT\t64\n#define CONNECT_REDIRECT\t0x80\n#define CONNECT_LOCALDRIVE\t0x100\n#define CONNECT_CURRENT_MEDIA\t0x200\n#define CONNECT_DEFERRED\t0x400\n#define CONNECT_RESERVED\t0xFF000000\n#define CONNDLG_RO_PATH\t\t1\n#define CONNDLG_CONN_POINT\t2\n#define CONNDLG_USE_MRU\t\t4\n#define CONNDLG_HIDE_BOX\t8\n#define CONNDLG_PERSIST\t\t16\n#define CONNDLG_NOT_PERSIST\t32\n#define DISC_UPDATE_PROFILE\t1\n#define DISC_NO_FORCE\t\t0x40\n#define RESOURCETYPE_DISK\t1\n#define RESOURCETYPE_PRINT\t2\n#define RESOURCETYPE_ANY\t0\n#define RESOURCE_CONNECTED\t1\n#define RESOURCE_GLOBALNET\t2\n#define RESOURCE_REMEMBERED\t3\n#define RESOURCEUSAGE_CONNECTABLE\t1\n#define RESOURCEUSAGE_CONTAINER\t2\n#define WN_SUCCESS NO_ERROR\n#define WN_NO_ERROR NO_ERROR\n#define WN_NOT_SUPPORTED ERROR_NOT_SUPPORTED\n#define WN_CANCEL ERROR_CANCELLED\n#define WN_RETRY ERROR_RETRY\n#define WN_NET_ERROR ERROR_UNEXP_NET_ERR\n#define WN_MORE_DATA ERROR_MORE_DATA\n#define WN_BAD_POINTER ERROR_INVALID_ADDRESS\n#define WN_BAD_VALUE ERROR_INVALID_PARAMETER\n#define WN_BAD_USER ERROR_BAD_USERNAME\n#define WN_BAD_PASSWORD ERROR_INVALID_PASSWORD\n#define WN_ACCESS_DENIED ERROR_ACCESS_DENIED\n#define WN_FUNCTION_BUSY ERROR_BUSY\n#define WN_WINDOWS_ERROR ERROR_UNEXP_NET_ERR\n#define WN_OUT_OF_MEMORY ERROR_NOT_ENOUGH_MEMORY\n#define WN_NO_NETWORK ERROR_NO_NETWORK\n#define WN_EXTENDED_ERROR ERROR_EXTENDED_ERROR\n#define WN_BAD_LEVEL ERROR_INVALID_LEVEL\n#define WN_BAD_HANDLE ERROR_INVALID_HANDLE\n#define WN_NOT_INITIALIZING ERROR_ALREADY_INITIALIZED\n#define WN_NO_MORE_DEVICES ERROR_NO_MORE_DEVICES\n#define WN_NOT_CONNECTED ERROR_NOT_CONNECTED\n#define WN_OPEN_FILES ERROR_OPEN_FILES\n#define WN_DEVICE_IN_USE ERROR_DEVICE_IN_USE\n#define WN_BAD_NETNAME ERROR_BAD_NET_NAME\n#define WN_BAD_LOCALNAME ERROR_BAD_DEVICE\n#define WN_ALREADY_CONNECTED ERROR_ALREADY_ASSIGNED\n#define WN_DEVICE_ERROR ERROR_GEN_FAILURE\n#define WN_CONNECTION_CLOSED ERROR_CONNECTION_UNAVAIL\n#define WN_NO_NET_OR_BAD_PATH ERROR_NO_NET_OR_BAD_PATH\n#define WN_BAD_PROVIDER ERROR_BAD_PROVIDER\n#define WN_CANNOT_OPEN_PROFILE ERROR_CANNOT_OPEN_PROFILE\n#define WN_BAD_PROFILE ERROR_BAD_PROFILE\n#define WN_BAD_DEV_TYPE ERROR_BAD_DEV_TYPE\n#define WN_DEVICE_ALREADY_REMEMBERED ERROR_DEVICE_ALREADY_REMEMBERED\n#define WN_CONNECTED_OTHER_PASSWORD ERROR_CONNECTED_OTHER_PASSWORD\n#define WN_NO_MORE_ENTRIES ERROR_NO_MORE_ITEMS\n#define WN_NOT_CONTAINER ERROR_NOT_CONTAINER\n#define WN_NOT_AUTHENTICATED ERROR_NOT_AUTHENTICATED\n#define WN_NOT_LOGGED_ON ERROR_NOT_LOGGED_ON\n#define WN_NOT_VALIDATED ERROR_NO_LOGON_SERVERS\n#define UNIVERSAL_NAME_INFO_LEVEL\t1\n#define REMOTE_NAME_INFO_LEVEL\t2\n#define STILL_ACTIVE\t0x103\n#define SP_SERIALCOMM\t1\n#define BAUD_075\t1\n#define BAUD_110\t2\n#define BAUD_134_5\t4\n#define BAUD_150\t8\n#define BAUD_300\t16\n#define BAUD_600\t32\n#define BAUD_1200\t64\n#define BAUD_1800\t128\n#define BAUD_2400\t256\n#define BAUD_4800\t512\n#define BAUD_7200\t0x400\n#define BAUD_9600\t0x800\n#define BAUD_14400\t4096\n#define BAUD_19200\t0x2000\n#define BAUD_38400\t0x4000\n#define BAUD_56K\t0x8000\n#define BAUD_57600\t0x40000\n#define BAUD_115200\t0x20000\n#define BAUD_128K\t0x10000\n#define BAUD_USER\t0x10000000\n#define PST_FAX\t0x21\n#define PST_LAT\t0x101\n#define PST_MODEM\t6\n#define PST_NETWORK_BRIDGE\t256\n#define PST_PARALLELPORT\t2\n#define PST_RS232\t1\n#define PST_RS422\t3\n#define PST_RS423\t4\n#define PST_RS449\t5\n#define PST_SCANNER\t0x22\n#define PST_TCPIP_TELNET\t0x102\n#define PST_UNSPECIFIED\t0\n#define PST_X25\t0x103\n#define PCF_16BITMODE\t512\n#define PCF_DTRDSR\t1\n#define PCF_INTTIMEOUTS\t128\n#define PCF_PARITY_CHECK\t8\n#define PCF_RLSD\t4\n#define PCF_RTSCTS\t2\n#define PCF_SETXCHAR\t32\n#define PCF_SPECIALCHARS\t256\n#define PCF_TOTALTIMEOUTS\t64\n#define PCF_XONXOFF\t16\n#define SP_BAUD\t2\n#define SP_DATABITS\t4\n#define SP_HANDSHAKING\t0x10\n#define SP_PARITY\t1\n#define SP_PARITY_CHECK\t32\n#define SP_RLSD\t64\n#define SP_STOPBITS\t8\n#define DATABITS_5\t1\n#define DATABITS_6\t2\n#define DATABITS_7\t4\n#define DATABITS_8\t8\n#define DATABITS_16\t16\n#define DATABITS_16X\t32\n#define STOPBITS_10\t1\n#define STOPBITS_15\t2\n#define STOPBITS_20\t4\n#define PARITY_NONE\t256\n#define PARITY_ODD\t512\n#define PARITY_EVEN\t1024\n#define PARITY_MARK\t2048\n#define PARITY_SPACE\t4096\n#define COMMPROP_INITIALIZED\t0xe73cf52e\n#define CBR_110\t110\n#define CBR_300\t300\n#define CBR_600\t600\n#define CBR_1200\t1200\n#define CBR_2400\t2400\n#define CBR_4800\t4800\n#define CBR_9600\t9600\n#define CBR_14400\t14400\n#define CBR_19200\t19200\n#define CBR_38400\t38400\n#define CBR_56000\t56000\n#define CBR_57600\t57600\n#define CBR_115200\t115200\n#define CBR_128000\t128000\n#define CBR_256000\t256000\n#define DTR_CONTROL_DISABLE\t0\n#define DTR_CONTROL_ENABLE\t1\n#define DTR_CONTROL_HANDSHAKE\t2\n#define RTS_CONTROL_DISABLE\t0\n#define RTS_CONTROL_ENABLE\t1\n#define RTS_CONTROL_HANDSHAKE\t2\n#define RTS_CONTROL_TOGGLE\t3\n#define EVENPARITY\t2\n#define MARKPARITY\t3\n#define NOPARITY\t0\n#define SPACEPARITY\t4\n#define ODDPARITY\t1\n#define ONESTOPBIT\t0\n#define ONE5STOPBITS\t1\n#define TWOSTOPBITS\t2\n#define CREATE_FOR_IMPORT 1\n#define CREATE_FOR_DIR 2\n#define OVERWRITE_HIDDEN 4\n#define CREATE_PROCESS_DEBUG_EVENT\t3\n#define CREATE_THREAD_DEBUG_EVENT\t2\n#define EXCEPTION_DEBUG_EVENT\t1\n#define EXIT_PROCESS_DEBUG_EVENT\t5\n#define EXIT_THREAD_DEBUG_EVENT\t4\n#define LOAD_DLL_DEBUG_EVENT\t6\n#define OUTPUT_DEBUG_STRING_EVENT\t8\n#define UNLOAD_DLL_DEBUG_EVENT\t7\n#define RIP_EVENT\t9\n#define PROCESS_HEAP_REGION\t1\n#define PROCESS_HEAP_UNCOMMITTED_RANGE\t2\n#define PROCESS_HEAP_ENTRY_BUSY\t4\n#define PROCESS_HEAP_ENTRY_MOVEABLE\t16\n#define PROCESS_HEAP_ENTRY_DDESHARE\t32\n#define HINSTANCE_ERROR\t32\n#define BACKUP_INVALID\t0\n#define BACKUP_DATA\t1\n#define BACKUP_EA_DATA\t2\n#define BACKUP_SECURITY_DATA\t3\n#define BACKUP_ALTERNATE_DATA\t4\n#define BACKUP_LINK\t5\n#define BACKUP_PROPERTY_DATA\t6\n#define BACKUP_OBJECT_ID\t7\n#define BACKUP_REPARSE_DATA\t8\n#define BACKUP_SPARSE_BLOCK\t9\n#define STREAM_NORMAL_ATTRIBUTE\t0\n#define STREAM_MODIFIED_WHEN_READ\t1\n#define STREAM_CONTAINS_SECURITY\t2\n#define STREAM_CONTAINS_PROPERTIES\t4\n#define STREAM_SPARSE_ATTRIBUTE\t8\n#define STARTF_USESHOWWINDOW\t1\n#define STARTF_USEPOSITION\t4\n#define STARTF_USESIZE\t2\n#define STARTF_RUNFULLSCREEN\t0x20\n#define STARTF_USECOUNTCHARS\t8\n#define STARTF_USEFILLATTRIBUTE\t16\n#define STARTF_FORCEONFEEDBACK\t64\n#define STARTF_FORCEOFFFEEDBACK\t128\n#define STARTF_USESTDHANDLES\t256\n#define STARTF_USEHOTKEY\t0x0200\n#define VER_PLATFORM_WIN32s\t0\n#define VER_PLATFORM_WIN32_WINDOWS 1\n#define VER_PLATFORM_WIN32_NT\t2\n#define MAXPROPPAGES\t100\n#define PSP_DEFAULT\t0\n#define PSP_HASHELP\t32\n#define PSP_USECALLBACK\t128\n#define PSP_USEHICON\t2\n#define PSP_USEICONID\t4\n#define PSP_USEREFPARENT\t64\n#define PSP_USETITLE\t8\n#define PSP_RTLREADING\t16\n#define PSP_DLGINDIRECT\t1\n#define PSH_DEFAULT\t0\n#define PSH_HASHELP\t512\n#define PSH_MODELESS\t1024\n#define PSH_NOAPPLYNOW\t128\n#define PSH_PROPSHEETPAGE\t8\n#define PSH_PROPTITLE\t1\n#define PSH_USECALLBACK\t256\n#define PSH_USEHICON\t2\n#define PSH_USEICONID\t4\n#define PSH_USEPSTARTPAGE\t64\n#define PSH_WIZARD\t32\n#define PSH_RTLREADING\t2048\n#define PSCB_INITIALIZED\t1\n#define PSCB_PRECREATE\t2\n#define PSNRET_NOERROR\t0\n#define PSNRET_INVALID_NOCHANGEPAGE\t2\n#define PSBTN_APPLYNOW\t4\n#define PSBTN_BACK\t0\n#define PSBTN_CANCEL\t5\n#define PSBTN_FINISH\t2\n#define PSBTN_HELP\t6\n#define PSBTN_NEXT\t1\n#define PSBTN_OK\t3\n#define PSWIZB_BACK\t1\n#define PSWIZB_NEXT\t2\n#define PSWIZB_FINISH\t4\n#define PSWIZB_DISABLEDFINISH\t8\n#define ID_PSREBOOTSYSTEM\t3\n#define ID_PSRESTARTWINDOWS\t2\n#define WIZ_BODYCX\t184\n#define WIZ_BODYX\t92\n#define WIZ_CXBMP\t80\n#define WIZ_CXDLG\t276\n#define WIZ_CYDLG\t140\n#define PAN_ANY\t0\n#define PAN_NO_FIT\t1\n#define PAN_FAMILY_TEXT_DISPLAY\t2\n#define PAN_FAMILY_SCRIPT\t3\n#define PAN_FAMILY_DECORATIVE\t4\n#define PAN_FAMILY_PICTORIAL\t5\n#define PAN_SERIF_COVE\t2\n#define PAN_SERIF_OBTUSE_COVE\t3\n#define PAN_SERIF_SQUARE_COVE\t4\n#define PAN_SERIF_OBTUSE_SQUARE_COVE\t5\n#define PAN_SERIF_SQUARE\t6\n#define PAN_SERIF_THIN\t7\n#define PAN_SERIF_BONE\t8\n#define PAN_SERIF_EXAGGERATED\t9\n#define PAN_SERIF_TRIANGLE\t10\n#define PAN_SERIF_NORMAL_SANS\t11\n#define PAN_SERIF_OBTUSE_SANS\t12\n#define PAN_SERIF_PERP_SANS\t13\n#define PAN_SERIF_FLARED\t14\n#define PAN_SERIF_ROUNDED\t15\n#define PAN_WEIGHT_VERY_LIGHT\t2\n#define PAN_WEIGHT_LIGHT\t3\n#define PAN_WEIGHT_THIN\t4\n#define PAN_WEIGHT_BOOK\t5\n#define PAN_WEIGHT_MEDIUM\t6\n#define PAN_WEIGHT_DEMI\t7\n#define PAN_WEIGHT_BOLD\t8\n#define PAN_WEIGHT_HEAVY\t9\n#define PAN_WEIGHT_BLACK\t10\n#define PAN_WEIGHT_NORD\t11\n#define PAN_PROP_OLD_STYLE\t2\n#define PAN_PROP_MODERN\t3\n#define PAN_PROP_EVEN_WIDTH\t4\n#define PAN_PROP_EXPANDED\t5\n#define PAN_PROP_CONDENSED\t6\n#define PAN_PROP_VERY_EXPANDED\t7\n#define PAN_PROP_VERY_CONDENSED\t8\n#define PAN_PROP_MONOSPACED\t9\n#define PAN_CONTRAST_NONE\t2\n#define PAN_CONTRAST_VERY_LOW\t3\n#define PAN_CONTRAST_LOW\t4\n#define PAN_CONTRAST_MEDIUM_LOW\t5\n#define PAN_CONTRAST_MEDIUM\t6\n#define PAN_CONTRAST_MEDIUM_HIGH\t7\n#define PAN_CONTRAST_HIGH\t8\n#define PAN_CONTRAST_VERY_HIGH\t9\n#define PAN_STROKE_GRADUAL_DIAG\t2\n#define PAN_STROKE_GRADUAL_TRAN\t3\n#define PAN_STROKE_GRADUAL_VERT\t4\n#define PAN_STROKE_GRADUAL_HORZ\t5\n#define PAN_STROKE_RAPID_VERT\t6\n#define PAN_STROKE_RAPID_HORZ\t7\n#define PAN_STROKE_INSTANT_VERT\t8\n#define PAN_STRAIGHT_ARMS_HORZ\t2\n#define PAN_STRAIGHT_ARMS_WEDGE\t3\n#define PAN_STRAIGHT_ARMS_VERT\t4\n#define PAN_STRAIGHT_ARMS_SINGLE_SERIF\t5\n#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF\t6\n#define PAN_BENT_ARMS_HORZ\t7\n#define PAN_BENT_ARMS_VERT\t9\n#define PAN_BENT_ARMS_WEDGE\t8\n#define PAN_BENT_ARMS_SINGLE_SERIF\t10\n#define PAN_BENT_ARMS_DOUBLE_SERIF\t11\n#define PAN_LETT_NORMAL_CONTACT\t2\n#define PAN_LETT_NORMAL_WEIGHTED\t3\n#define PAN_LETT_NORMAL_BOXED\t4\n#define PAN_LETT_NORMAL_FLATTENED\t5\n#define PAN_LETT_NORMAL_ROUNDED\t6\n#define PAN_LETT_NORMAL_OFF_CENTER\t7\n#define PAN_LETT_NORMAL_SQUARE\t8\n#define PAN_LETT_OBLIQUE_CONTACT\t9\n#define PAN_LETT_OBLIQUE_WEIGHTED\t10\n#define PAN_LETT_OBLIQUE_BOXED\t11\n#define PAN_LETT_OBLIQUE_FLATTENED\t12\n#define PAN_LETT_OBLIQUE_ROUNDED\t13\n#define PAN_LETT_OBLIQUE_OFF_CENTER\t14\n#define PAN_LETT_OBLIQUE_SQUARE\t15\n#define PAN_MIDLINE_STANDARD_TRIMMED\t2\n#define PAN_MIDLINE_STANDARD_POINTED\t3\n#define PAN_MIDLINE_STANDARD_SERIFED\t4\n#define PAN_MIDLINE_HIGH_TRIMMED\t5\n#define PAN_MIDLINE_HIGH_POINTED\t6\n#define PAN_MIDLINE_HIGH_SERIFED\t7\n#define PAN_MIDLINE_CONSTANT_TRIMMED\t8\n#define PAN_MIDLINE_CONSTANT_POINTED\t9\n#define PAN_MIDLINE_CONSTANT_SERIFED\t10\n#define PAN_MIDLINE_LOW_TRIMMED\t11\n#define PAN_MIDLINE_LOW_POINTED\t12\n#define PAN_MIDLINE_LOW_SERIFED\t13\n#define PAN_XHEIGHT_CONSTANT_SMALL\t2\n#define PAN_XHEIGHT_CONSTANT_STD\t3\n#define PAN_XHEIGHT_CONSTANT_LARGE\t4\n#define PAN_XHEIGHT_DUCKING_SMALL\t5\n#define PAN_XHEIGHT_DUCKING_STD\t6\n#define PAN_XHEIGHT_DUCKING_LARGE\t7\n#define PC_EXPLICIT\t2\n#define PC_NOCOLLAPSE\t4\n#define PC_RESERVED\t1\n#define BS_DIBPATTERN\t5\n#define BS_DIBPATTERN8X8\t8\n#define BS_DIBPATTERNPT\t6\n#define BS_HATCHED\t2\n#define BS_HOLLOW\t1\n#define BS_NULL\t1\n#define BS_PATTERN\t3\n#define BS_PATTERN8X8\t7\n#define BS_SOLID\t0\n#define DM_ORIENTATION\t1\n#define DM_PAPERSIZE\t2\n#define DM_PAPERLENGTH\t4\n#define DM_PAPERWIDTH\t8\n#define DM_SCALE\t16\n#define DM_COPIES\t256\n#define DM_DEFAULTSOURCE\t512\n#define DM_PRINTQUALITY\t0x400\n#define DM_COLOR\t0x800\n#define DM_DUPLEX\t4096\n#define DM_YRESOLUTION\t0x2000\n#define DM_TTOPTION\t0x4000\n#define DM_COLLATE\t0x8000\n#define DM_FORMNAME\t0x10000\n#define DM_LOGPIXELS\t0x20000\n#define DM_ICMMETHOD\t0x800000\n#define DM_ICMINTENT\t0x1000000\n#define DM_MEDIATYPE\t0x2000000\n#define DM_DITHERTYPE\t0x4000000\n#define DMORIENT_LANDSCAPE\t2\n#define DMORIENT_PORTRAIT\t1\n#define DMPAPER_FIRST\t1\n#define DMPAPER_LETTER\t1\n#define DMPAPER_LEGAL\t5\n#define DMPAPER_A4\t9\n#define DMPAPER_CSHEET\t24\n#define DMPAPER_DSHEET\t25\n#define DMPAPER_ESHEET\t26\n#define DMPAPER_LETTERSMALL\t2\n#define DMPAPER_TABLOID\t3\n#define DMPAPER_LEDGER\t4\n#define DMPAPER_STATEMENT\t6\n#define DMPAPER_EXECUTIVE\t7\n#define DMPAPER_A3\t8\n#define DMPAPER_A4SMALL\t10\n#define DMPAPER_A5\t11\n#define DMPAPER_B4\t12\n#define DMPAPER_B5\t13\n#define DMPAPER_FOLIO\t14\n#define DMPAPER_QUARTO\t15\n#define DMPAPER_10X14\t16\n#define DMPAPER_11X17\t17\n#define DMPAPER_NOTE\t18\n#define DMPAPER_ENV_9\t19\n#define DMPAPER_ENV_10\t20\n#define DMPAPER_ENV_11\t21\n#define DMPAPER_ENV_12\t22\n#define DMPAPER_ENV_14\t23\n#define DMPAPER_ENV_DL\t27\n#define DMPAPER_ENV_C5\t28\n#define DMPAPER_ENV_C3\t29\n#define DMPAPER_ENV_C4\t30\n#define DMPAPER_ENV_C6\t31\n#define DMPAPER_ENV_C65\t32\n#define DMPAPER_ENV_B4\t33\n#define DMPAPER_ENV_B5\t34\n#define DMPAPER_ENV_B6\t35\n#define DMPAPER_ENV_ITALY\t36\n#define DMPAPER_ENV_MONARCH\t37\n#define DMPAPER_ENV_PERSONAL\t38\n#define DMPAPER_FANFOLD_US\t39\n#define DMPAPER_FANFOLD_STD_GERMAN\t40\n#define DMPAPER_FANFOLD_LGL_GERMAN\t41\n#define DMPAPER_ISO_B4\t42\n#define DMPAPER_JAPANESE_POSTCARD\t43\n#define DMPAPER_9X11\t44\n#define DMPAPER_10X11\t45\n#define DMPAPER_15X11\t46\n#define DMPAPER_ENV_INVITE\t47\n#define DMPAPER_RESERVED_48\t48\n#define DMPAPER_RESERVED_49\t49\n#define DMPAPER_LETTER_EXTRA\t50\n#define DMPAPER_LEGAL_EXTRA\t51\n#define DMPAPER_TABLOID_EXTRA\t52\n#define DMPAPER_A4_EXTRA\t53\n#define DMPAPER_LETTER_TRANSVERSE\t54\n#define DMPAPER_A4_TRANSVERSE\t55\n#define DMPAPER_LETTER_EXTRA_TRANSVERSE\t56\n#define DMPAPER_A_PLUS\t57\n#define DMPAPER_B_PLUS\t58\n#define DMPAPER_LETTER_PLUS\t59\n#define DMPAPER_A4_PLUS\t60\n#define DMPAPER_A5_TRANSVERSE\t61\n#define DMPAPER_B5_TRANSVERSE\t62\n#define DMPAPER_A3_EXTRA\t63\n#define DMPAPER_A5_EXTRA\t64\n#define DMPAPER_B5_EXTRA\t65\n#define DMPAPER_A2\t66\n#define DMPAPER_A3_TRANSVERSE\t67\n#define DMPAPER_A3_EXTRA_TRANSVERSE\t68\n#define DMPAPER_DBL_JAPANESE_POSTCARD 69\n#define DMPAPER_A6 70\n#define DMPAPER_JENV_KAKU2 71\n#define DMPAPER_JENV_KAKU3 72\n#define DMPAPER_JENV_CHOU3 73\n#define DMPAPER_JENV_CHOU4 74\n#define DMPAPER_LETTER_ROTATED 75\n#define DMPAPER_A3_ROTATED 76\n#define DMPAPER_A4_ROTATED 77\n#define DMPAPER_A5_ROTATED 78\n#define DMPAPER_B4_JIS_ROTATED 79\n#define DMPAPER_B5_JIS_ROTATED 80\n#define DMPAPER_JAPANESE_POSTCARD_ROTATED 81\n#define DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82\n#define DMPAPER_A6_ROTATED 83\n#define DMPAPER_JENV_KAKU2_ROTATED 84\n#define DMPAPER_JENV_KAKU3_ROTATED 85\n#define DMPAPER_JENV_CHOU3_ROTATED 86\n#define DMPAPER_JENV_CHOU4_ROTATED 87\n#define DMPAPER_B6_JIS 88\n#define DMPAPER_B6_JIS_ROTATED 89\n#define DMPAPER_12X11 90\n#define DMPAPER_JENV_YOU4 91\n#define DMPAPER_JENV_YOU4_ROTATED 92\n#define DMPAPER_P16K 93\n#define DMPAPER_P32K 94\n#define DMPAPER_P32KBIG 95\n#define DMPAPER_PENV_1 96\n#define DMPAPER_PENV_2 97\n#define DMPAPER_PENV_3 98\n#define DMPAPER_PENV_4 99\n#define DMPAPER_PENV_5 100\n#define DMPAPER_PENV_6 101\n#define DMPAPER_PENV_7 102\n#define DMPAPER_PENV_8 103\n#define DMPAPER_PENV_9 104\n#define DMPAPER_PENV_10 105\n#define DMPAPER_P16K_ROTATED 106\n#define DMPAPER_P32K_ROTATED 107\n#define DMPAPER_P32KBIG_ROTATED 108\n#define DMPAPER_PENV_1_ROTATED 109\n#define DMPAPER_PENV_2_ROTATED 110\n#define DMPAPER_PENV_3_ROTATED 111\n#define DMPAPER_PENV_4_ROTATED 112\n#define DMPAPER_PENV_5_ROTATED 113\n#define DMPAPER_PENV_6_ROTATED 114\n#define DMPAPER_PENV_7_ROTATED 115\n#define DMPAPER_PENV_8_ROTATED 116\n#define DMPAPER_PENV_9_ROTATED 117\n#define DMPAPER_PENV_10_ROTATED 118\n#define DMPAPER_LAST 118\n#define DMPAPER_USER 256\n#define DMBIN_FIRST\t1\n#define DMBIN_UPPER\t1\n#define DMBIN_ONLYONE\t1\n#define DMBIN_LOWER\t2\n#define DMBIN_MIDDLE\t3\n#define DMBIN_MANUAL\t4\n#define DMBIN_ENVELOPE\t5\n#define DMBIN_ENVMANUAL\t6\n#define DMBIN_AUTO\t7\n#define DMBIN_TRACTOR\t8\n#define DMBIN_SMALLFMT\t9\n#define DMBIN_LARGEFMT\t10\n#define DMBIN_LARGECAPACITY\t11\n#define DMBIN_CASSETTE\t14\n#define DMBIN_FORMSOURCE\t15\n#define DMBIN_LAST\t15\n#define DMBIN_USER\t256\n#define DMRES_HIGH\t(-4)\n#define DMRES_MEDIUM\t(-3)\n#define DMRES_LOW\t(-2)\n#define DMRES_DRAFT\t(-1)\n#define DMCOLOR_COLOR\t2\n#define DMCOLOR_MONOCHROME\t1\n#define DMDUP_SIMPLEX\t1\n#define DMDUP_HORIZONTAL\t3\n#define DMDUP_VERTICAL\t2\n#define DMTT_BITMAP\t1\n#define DMTT_DOWNLOAD\t2\n#define DMTT_SUBDEV\t3\n#define DMCOLLATE_TRUE\t1\n#define DMCOLLATE_FALSE\t0\n#define DM_GRAYSCALE\t1\n#define DM_INTERLACED\t2\n#define DMICMMETHOD_NONE\t1\n#define DMICMMETHOD_SYSTEM\t2\n#define DMICMMETHOD_DRIVER\t3\n#define DMICMMETHOD_DEVICE\t4\n#define DMICMMETHOD_USER\t256\n#define DMICM_SATURATE\t1\n#define DMICM_CONTRAST\t2\n#define DMICM_COLORMETRIC\t3\n#define DMICM_USER\t256\n#define DMMEDIA_STANDARD\t1\n#define DMMEDIA_GLOSSY\t3\n#define DMMEDIA_TRANSPARENCY\t2\n#define DMMEDIA_USER\t256\n#define DMDITHER_NONE\t1\n#define DMDITHER_COARSE\t2\n#define DMDITHER_FINE\t3\n#define DMDITHER_LINEART\t4\n#define DMDITHER_GRAYSCALE\t10\n#define DMDITHER_USER\t256\n#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 1\n#define DISPLAY_DEVICE_MULTI_DRIVER\t2\n#define DISPLAY_DEVICE_PRIMARY_DEVICE\t4\n#define DISPLAY_DEVICE_MIRRORING_DRIVER 8\n#define DISPLAY_DEVICE_VGA_COMPATIBLE\t0x10\n#define DISPLAY_DEVICE_REMOVABLE\t0x20\n#define DISPLAY_DEVICE_MODESPRUNED\t0x08000000\n#define DISPLAY_DEVICE_REMOTE\t0x04000000\n#define DISPLAY_DEVICE_DISCONNECT 0x02000000\n#define RDH_RECTANGLES\t1\n#define TT_POLYGON_TYPE\t24\n#define TT_PRIM_LINE\t1\n#define TT_PRIM_QSPLINE\t2\n#define GCPCLASS_ARABIC\t2\n#define GCPCLASS_HEBREW\t2\n#define GCPCLASS_LATIN\t1\n#define GCPCLASS_LATINNUMBER\t5\n#define GCPCLASS_LOCALNUMBER\t4\n#define GCPCLASS_LATINNUMERICSEPARATOR\t7\n#define GCPCLASS_LATINNUMERICTERMINATOR\t6\n#define GCPCLASS_NEUTRAL\t3\n#define GCPCLASS_NUMERICSEPARATOR\t8\n#define GCPCLASS_PREBOUNDLTR\t128\n#define GCPCLASS_PREBOUNDRTL\t64\n#define GCPCLASS_POSTBOUNDLTR\t32\n#define GCPCLASS_POSTBOUNDRTL\t16\n#define GCPGLYPH_LINKBEFORE\t32768\n#define GCPGLYPH_LINKAFTER\t16384\n#define TT_AVAILABLE\t1\n#define TT_ENABLED\t2\n#define CA_NEGATIVE\t1\n#define CA_LOG_FILTER\t2\n#define ILLUMINANT_DEVICE_DEFAULT\t0\n#define ILLUMINANT_A\t1\n#define ILLUMINANT_B\t2\n#define ILLUMINANT_C\t3\n#define ILLUMINANT_D50\t4\n#define ILLUMINANT_D55\t5\n#define ILLUMINANT_D65\t6\n#define ILLUMINANT_D75\t7\n#define ILLUMINANT_F2\t8\n#define ILLUMINANT_TUNGSTEN\t1\n#define ILLUMINANT_DAYLIGHT\t3\n#define ILLUMINANT_FLUORESCENT\t8\n#define ILLUMINANT_NTSC\t3\n#define ILLUMINANT_MAX_INDEX\tILLUMINANT_F2\n#define REFERENCE_WHITE_MIN\t(WORD)6000\n#define REFERENCE_WHITE_MAX\t(WORD)10000\n#define REFERENCE_BLACK_MIN\t(WORD)0\n#define REFERENCE_BLACK_MAX\t(WORD)4000\n#define DI_APPBANDING\t1\n#define EMR_HEADER\t1\n#define EMR_POLYBEZIER\t2\n#define EMR_POLYGON\t3\n#define EMR_POLYLINE\t4\n#define EMR_POLYBEZIERTO\t5\n#define EMR_POLYLINETO\t6\n#define EMR_POLYPOLYLINE\t7\n#define EMR_POLYPOLYGON\t8\n#define EMR_SETWINDOWEXTEX\t9\n#define EMR_SETWINDOWORGEX\t10\n#define EMR_SETVIEWPORTEXTEX\t11\n#define EMR_SETVIEWPORTORGEX\t12\n#define EMR_SETBRUSHORGEX\t13\n#define EMR_EOF\t14\n#define EMR_SETPIXELV\t15\n#define EMR_SETMAPPERFLAGS\t16\n#define EMR_SETMAPMODE\t17\n#define EMR_SETBKMODE\t18\n#define EMR_SETPOLYFILLMODE\t19\n#define EMR_SETROP2\t20\n#define EMR_SETSTRETCHBLTMODE\t21\n#define EMR_SETTEXTALIGN\t22\n#define EMR_SETCOLORADJUSTMENT\t23\n#define EMR_SETTEXTCOLOR\t24\n#define EMR_SETBKCOLOR\t25\n#define EMR_OFFSETCLIPRGN\t26\n#define EMR_MOVETOEX\t27\n#define EMR_SETMETARGN\t28\n#define EMR_EXCLUDECLIPRECT\t29\n#define EMR_INTERSECTCLIPRECT\t30\n#define EMR_SCALEVIEWPORTEXTEX\t31\n#define EMR_SCALEWINDOWEXTEX\t32\n#define EMR_SAVEDC\t33\n#define EMR_RESTOREDC\t34\n#define EMR_SETWORLDTRANSFORM\t35\n#define EMR_MODIFYWORLDTRANSFORM\t36\n#define EMR_SELECTOBJECT\t37\n#define EMR_CREATEPEN\t38\n#define EMR_CREATEBRUSHINDIRECT\t39\n#define EMR_DELETEOBJECT\t40\n#define EMR_ANGLEARC\t41\n#define EMR_ELLIPSE\t42\n#define EMR_RECTANGLE\t43\n#define EMR_ROUNDRECT\t44\n#define EMR_ARC\t45\n#define EMR_CHORD\t46\n#define EMR_PIE\t47\n#define EMR_SELECTPALETTE\t48\n#define EMR_CREATEPALETTE\t49\n#define EMR_SETPALETTEENTRIES\t50\n#define EMR_RESIZEPALETTE\t51\n#define EMR_REALIZEPALETTE\t52\n#define EMR_EXTFLOODFILL\t53\n#define EMR_LINETO\t54\n#define EMR_ARCTO\t55\n#define EMR_POLYDRAW\t56\n#define EMR_SETARCDIRECTION\t57\n#define EMR_SETMITERLIMIT\t58\n#define EMR_BEGINPATH\t59\n#define EMR_ENDPATH\t60\n#define EMR_CLOSEFIGURE\t61\n#define EMR_FILLPATH\t62\n#define EMR_STROKEANDFILLPATH\t63\n#define EMR_STROKEPATH\t64\n#define EMR_FLATTENPATH\t65\n#define EMR_WIDENPATH\t66\n#define EMR_SELECTCLIPPATH\t67\n#define EMR_ABORTPATH\t68\n#define EMR_GDICOMMENT\t70\n#define EMR_FILLRGN\t71\n#define EMR_FRAMERGN\t72\n#define EMR_INVERTRGN\t73\n#define EMR_PAINTRGN\t74\n#define EMR_EXTSELECTCLIPRGN\t75\n#define EMR_BITBLT\t76\n#define EMR_STRETCHBLT\t77\n#define EMR_MASKBLT\t78\n#define EMR_PLGBLT\t79\n#define EMR_SETDIBITSTODEVICE\t80\n#define EMR_STRETCHDIBITS\t81\n#define EMR_EXTCREATEFONTINDIRECTW\t82\n#define EMR_EXTTEXTOUTA\t83\n#define EMR_EXTTEXTOUTW\t84\n#define EMR_POLYBEZIER16\t85\n#define EMR_POLYGON16\t86\n#define EMR_POLYLINE16\t87\n#define EMR_POLYBEZIERTO16\t88\n#define EMR_POLYLINETO16\t89\n#define EMR_POLYPOLYLINE16\t90\n#define EMR_POLYPOLYGON16\t91\n#define EMR_POLYDRAW16\t92\n#define EMR_CREATEMONOBRUSH\t93\n#define EMR_CREATEDIBPATTERNBRUSHPT\t94\n#define EMR_EXTCREATEPEN\t95\n#define EMR_POLYTEXTOUTA\t96\n#define EMR_POLYTEXTOUTW\t97\n#define EMR_SETICMMODE\t98\n#define EMR_CREATECOLORSPACE\t99\n#define EMR_SETCOLORSPACE\t100\n#define EMR_DELETECOLORSPACE\t101\n#define EMR_GLSRECORD\t102\n#define EMR_GLSBOUNDEDRECORD\t103\n#define EMR_PIXELFORMAT\t104\n#define EMR_RESERVED_105 105\n#define EMR_RESERVED_106 106\n#define EMR_RESERVED_107 107\n#define EMR_RESERVED_108 108\n#define EMR_RESERVED_109 109\n#define EMR_RESERVED_110 110\n#define EMR_COLORCORRECTPALETTE 111\n#define EMR_SETICMPROFILEA 112\n#define EMR_SETICMPROFILEW 113\n#define EMR_ALPHABLEND 114\n#define EMR_SETLAYOUT 115\n#define EMR_TRANSPARENTBLT 116\n#define EMR_RESERVED_117 117\n#define EMR_GRADIENTFILL 118\n#define EMR_RESERVED_119 119\n#define EMR_RESERVED_120 120\n#define EMR_COLORMATCHTOTARGETW 121\n#define EMR_CREATECOLORSPACEW 122\n#define ENHMETA_SIGNATURE\t1179469088\n#define ENM_NONE\t0\n#define ENM_CHANGE\t1\n#define ENM_UPDATE\t2\n#define ENM_SCROLL\t4\n#define ENM_KEYEVENTS 0x10000\n#define ENM_MOUSEEVENTS 0x20000\n#define ENM_REQUESTRESIZE 0x40000\n#define ENM_SELCHANGE 0x80000\n#define ENM_DROPFILES 0x100000\n#define ENM_PROTECTED 0x200000\n#define ENM_CORRECTTEXT 0x400000\n#define ENM_SCROLLEVENTS\t8\n#define ENM_DRAGDROPDONE\t16\n#define ENM_PARAGRAPHEXPANDED\t32\n#define ENM_IMECHANGE\t0x800000\n#define ENM_LANGCHANGE\t0x1000000\n#define ENM_OBJECTPOSITIONS\t0x2000000\n#define ES_DISABLENOSCROLL\t0x2000\n\n//#if (WINVER > 1024)\n#define ES_EX_NOCALLOLEINIT 0\n//#else\n//#define ES_EX_NOCALLOLEINIT 16777216\n//#endif\n#define ES_NOIME\t0x80000\n#define ES_SAVESEL\t0x8000\n#define ES_SELFIME\t0x40000\n#define ES_SUNKEN\t0x4000\n#define ES_VERTICAL\t0x400000\n#define ES_SELECTIONBAR\t0x1000000\n#define ECOOP_SET\t1\n#define ECOOP_OR\t2\n#define ECOOP_AND\t3\n#define ECOOP_XOR\t4\n#define ECO_AUTOWORDSELECTION\t1\n#define ECO_AUTOVSCROLL\t64\n#define ECO_AUTOHSCROLL\t128\n#define ECO_NOHIDESEL\t256\n#define ECO_READONLY\t2048\n#define ECO_WANTRETURN\t4096\n#define ECO_SAVESEL\t0x8000\n#define ECO_SELECTIONBAR\t0x1000000\n#define ECO_VERTICAL\t0x400000\n#define SCF_WORD\t2\n#define SCF_SELECTION\t1\n#define SF_TEXT\t1\n#define SF_RTF\t2\n#define SF_RTFNOOBJS\t3\n#define SF_TEXTIZED\t4\n#define SFF_SELECTION\t0x8000\n#define SFF_PLAINRTF\t0x4000\n#define WB_CLASSIFY\t3\n#define WB_ISDELIMITER\t2\n#define WB_LEFT\t0\n#define WB_LEFTBREAK\t6\n#define WB_PREVBREAK\t6\n#define WB_MOVEWORDLEFT\t4\n#define WB_MOVEWORDPREV\t4\n#define WB_MOVEWORDRIGHT\t5\n#define WB_MOVEWORDNEXT\t5\n#define WB_RIGHT\t1\n#define WB_RIGHTBREAK\t7\n#define WB_NEXTBREAK\t7\n#define PC_LEADING\t2\n#define PC_FOLLOWING\t1\n#define PC_DELIMITER\t4\n#define PC_OVERFLOW\t3\n#define WBF_WORDWRAP\t16\n#define WBF_WORDBREAK\t32\n#define WBF_OVERFLOW\t64\n#define WBF_LEVEL1\t128\n#define WBF_LEVEL2\t256\n#define WBF_CUSTOM\t512\n#define WBF_BREAKAFTER\t64\n#define WBF_BREAKLINE\t32\n#define WBF_ISWHITE\t16\n#define CFM_BOLD\t1\n#define CFM_COLOR\t0x40000000\n#define CFM_FACE\t0x20000000\n#define CFM_ITALIC\t2\n#define CFM_OFFSET\t0x10000000\n#define CFM_PROTECTED\t16\n#define CFM_SIZE\t0x80000000\n#define CFM_STRIKEOUT\t8\n#define CFM_UNDERLINE\t4\n#define CFE_AUTOCOLOR\t0x40000000\n#define CFE_BOLD\t1\n#define CFE_ITALIC\t2\n#define CFE_STRIKEOUT\t8\n#define CFE_UNDERLINE\t4\n#define CFE_PROTECTED\t16\n#define PFM_ALIGNMENT\t8\n#define PFM_NUMBERING\t32\n#define PFM_OFFSET\t4\n#define PFM_OFFSETINDENT\t0x80000000\n#define PFM_RIGHTINDENT\t2\n#define PFM_STARTINDENT\t1\n#define PFM_TABSTOPS\t16\n#define PFN_BULLET\t1\n#define PFA_LEFT\t1\n#define PFA_RIGHT\t2\n#define PFA_CENTER\t3\n#define SEL_EMPTY\t0\n#define SEL_TEXT\t1\n#define SEL_OBJECT\t2\n#define SEL_MULTICHAR\t4\n#define SEL_MULTIOBJECT\t8\n#define CF_RTF\tTEXT(\"Rich Text Format\")\n#define CF_RETEXTOBJ\tTEXT(\"RichEdit Text and Objects\")\n#define ODT_BUTTON\t4\n#define ODT_COMBOBOX\t3\n#define ODT_LISTBOX\t2\n#define ODT_LISTVIEW\t102\n#define ODT_MENU\t1\n#define ODT_STATIC\t5\n#define ODT_TAB\t101\n#define ODT_HEADER\t100\n#define ODA_DRAWENTIRE\t1\n#define ODA_FOCUS\t4\n#define ODA_SELECT\t2\n#define ODS_CHECKED\t8\n#define ODS_COMBOBOXEDIT\t4096\n#define ODS_DEFAULT\t32\n#define ODS_DISABLED\t4\n#define ODS_FOCUS\t16\n#define ODS_GRAYED\t2\n#define ODS_SELECTED\t1\n#define ANIMATE_CLASSW\tL\"SysAnimate32\"\n#define HOTKEY_CLASSW\tL\"msctls_hotkey32\"\n#define PROGRESS_CLASSW\tL\"msctls_progress32\"\n#define STATUSCLASSNAMEW\tL\"msctls_statusbar32\"\n#define REBARCLASSNAMEW\t\tL\"ReBarWindow32\"\n#define TOOLBARCLASSNAMEW\tL\"ToolbarWindow32\"\n#define TOOLTIPS_CLASSW\tL\"tooltips_class32\"\n#define TRACKBAR_CLASSW\tL\"msctls_trackbar32\"\n#define UPDOWN_CLASSW\tL\"msctls_updown32\"\n#define WC_HEADERW\tL\"SysHeader32\"\n#define WC_LISTVIEWW\tL\"SysListView32\"\n#define WC_TABCONTROLW\tL\"SysTabControl32\"\n#define WC_TREEVIEWW\tL\"SysTreeView32\"\n#define WC_PAGESCROLLERW\tL\"SysPager\"\n#define WC_PAGESCROLLERA\t\"SysPager\"\n#define DATETIMEPICK_CLASSW\tL\"SysDateTimePick32\"\n#define DATETIMEPICK_CLASSA\t\"SysDateTimePick32\"\n#define CCS_ADJUSTABLE\t32\n#define CCS_BOTTOM\t3\n#define CCS_NODIVIDER\t64\n#define CCS_NOMOVEY\t2\n#define CCS_NOPARENTALIGN\t8\n#define CCS_NORESIZE\t4\n#define CCS_TOP\t1\n#define CCS_VERT 0x80\n#define CCS_LEFT 0x81\n#define CCS_RIGHT\t(CCS_VERT|CCS_BOTTOM)\n#define CCS_NOMOVEX\t(CCS_VERT|CCS_NOMOVEY)\n#define RICHEDIT_CLASSA         \"RichEdit20A\"\n#define RICHEDIT_CLASS10A   \"RICHEDIT\"\n\n//#ifndef _RICHEDIT_VER\n#define _RICHEDIT_VER  0x0210\n//#endif\n\n#define RICHEDIT_CLASSA      \"RichEdit20A\"\n#define RICHEDIT_CLASS10A     \"RICHEDIT\"\n#define RICHEDIT_CLASSW      L\"RichEdit20W\"\n//#if (_RICHEDIT_VER >= 0x0200 )\n\n#ifdef UNICODE\n\t#define RICHEDIT_CLASS       RICHEDIT_CLASSW\n#else\n\t#define RICHEDIT_CLASS       RICHEDIT_CLASSA\n#endif\n//#else\n//#define RICHEDIT_CLASS       RICHEDIT_CLASS10A\n//#endif /* _RICHEDIT_VER >= 0x0200 */\n\n#define ANIMATE_CLASSA\t\"SysAnimate32\"\n#define HOTKEY_CLASSA\t\"msctls_hotkey32\"\n#define PROGRESS_CLASSA\t\"msctls_progress32\"\n#define STATUSCLASSNAMEA\t\"msctls_statusbar32\"\n#define REBARCLASSNAMEA\t\"ReBarWindow32\"\n#define TOOLBARCLASSNAMEA\t\"ToolbarWindow32\"\n#define TOOLTIPS_CLASSA\t\"tooltips_class32\"\n#define TRACKBAR_CLASSA\t\"msctls_trackbar32\"\n#define UPDOWN_CLASSA\t\"msctls_updown32\"\n#define WC_HEADERA\t\"SysHeader32\"\n#define WC_LISTVIEWA\t\"SysListView32\"\n#define WC_TABCONTROLA\t\"SysTabControl32\"\n#define WC_TREEVIEWA\t\"SysTreeView32\"\n#define HDS_BUTTONS\t2\n#define HDS_HIDDEN\t8\n#define HDS_HOTTRACK\t4\n#define HDS_DRAGDROP\t0x40\n#define HDS_FULLDRAG\t0x80\n#define HDS_FILTERBAR\t0x100\n#define HDS_HORZ\t0\n#define HDS_FLAT\t0x0200\n#define HDFT_ISSTRING\t0\n#define HDFT_ISNUMBER\t1\n#define HDFT_HASNOVALUE 0x8000\n#define HDI_BITMAP\t16\n#define HDI_FORMAT\t4\n#define HDI_HEIGHT\t1\n#define HDI_LPARAM\t8\n#define HDI_TEXT\t2\n#define HDI_WIDTH\t1\n#define HDI_IMAGE\t0x20\n#define HDI_DI_SETITEM\t0x40\n#define HDI_ORDER\t0x80\n#define HDI_FILTER\t0x100\n#define HDF_CENTER\t2\n#define HDF_LEFT\t0\n#define HDF_RIGHT\t1\n#define HDF_RTLREADING\t4\n#define HDF_BITMAP\t8192\n#define HDF_OWNERDRAW\t32768\n#define HDF_STRING\t16384\n#define HDF_BITMAP_ON_RIGHT 0x1000\n#define HDF_IMAGE\t0x800\n#define HDF_SORTUP\t0x0400\n#define HDF_SORTDOWN\t0x0200\n#define HDF_JUSTIFYMASK\t3\n#define HHT_NOWHERE\t1\n#define HHT_ONDIVIDER\t4\n#define HHT_ONDIVOPEN\t8\n#define HHT_ONHEADER\t2\n#define HHT_TOLEFT\t2048\n#define HHT_TORIGHT\t1024\n#define HHT_ONFILTER\t0x0010\n#define HHT_ONFILTERBUTTON 0x0020\n#define HHT_ABOVE\t0x0100\n#define HHT_BELOW\t0x0200\n#define HINST_COMMCTRL\t((HANDLE)-1)\n#define IDB_STD_LARGE_COLOR\t1\n#define IDB_STD_SMALL_COLOR\t0\n#define IDB_VIEW_LARGE_COLOR\t5\n#define IDB_VIEW_SMALL_COLOR\t4\n#define IDB_HIST_SMALL_COLOR\t8\n#define IDB_HIST_LARGE_COLOR\t9\n#define STD_COPY\t1\n#define STD_CUT\t0\n#define STD_DELETE\t5\n#define STD_FILENEW\t6\n#define STD_FILEOPEN\t7\n#define STD_FILESAVE\t8\n#define STD_FIND\t12\n#define STD_HELP\t11\n#define STD_PASTE\t2\n#define STD_PRINT\t14\n#define STD_PRINTPRE\t9\n#define STD_PROPERTIES\t10\n#define STD_REDOW\t4\n#define STD_REPLACE\t13\n#define STD_UNDO\t3\n#define VIEW_LARGEICONS\t0\n#define VIEW_SMALLICONS\t1\n#define VIEW_LIST\t2\n#define VIEW_DETAILS\t3\n#define VIEW_SORTNAME\t4\n#define VIEW_SORTSIZE\t5\n#define VIEW_SORTDATE\t6\n#define VIEW_SORTTYPE\t7\n#define VIEW_PARENTFOLDER\t8\n#define VIEW_NETCONNECT\t9\n#define VIEW_NETDISCONNECT\t10\n#define VIEW_NEWFOLDER\t11\n#define VIEW_VIEWMENU\t12\n#define HIST_BACK\t0\n#define HIST_FORWARD\t1\n#define HIST_FAVORITES\t2\n#define HIST_ADDTOFAVORITES\t3\n#define HIST_VIEWTREE\t4\n#define TBSTYLE_FLAT\t2048\n#define TBSTYLE_ALTDRAG\t1024\n#define TBSTYLE_TOOLTIPS\t256\n#define TBSTYLE_WRAPABLE\t512\n#define TBSTYLE_BUTTON\t0\n#define TBSTYLE_CHECK\t2\n#define TBSTYLE_CHECKGROUP\t6\n#define TBSTYLE_GROUP\t4\n#define TBSTYLE_SEP\t1\n#define TBSTYLE_DROPDOWN\t8\n#define TBSTYLE_AUTOSIZE\t16\n#define TBSTYLE_NOPREFIX\t32\n#define TBSTYLE_LIST\t0x1000\n#define TBSTYLE_CUSTOMERASE\t0x2000\n#define TBSTYLE_REGISTERDROP\t0x4000\n#define TBSTYLE_TRANSPARENT\t0x8000\n#define TBSTYLE_EX_DRAWDDARROWS\t1\n#define TBSTYLE_EX_MIXEDBUTTONS\t0x8\n#define TBSTYLE_EX_HIDECLIPPEDBUTTONS\t0x10\n#define TBSTYLE_EX_DOUBLEBUFFER 0x80\n#define TBCDRF_NOEDGES\t0x00010000\n#define TBCDRF_HILITEHOTTRACK\t0x00020000\n#define TBCDRF_NOOFFSET\t0x040000\n#define TBCDRF_NOMARK\t0x00080000\n#define TBCDRF_NOETCHEDEFFECT\t0x00100000\n#define TBCDRF_BLENDICON\t0x00200000\n#define TBCDRF_NOBACKGROUND\t0x00400000\n#define BTNS_BUTTON\tTBSTYLE_BUTTON\n#define BTNS_SEP\tTBSTYLE_SEP\n#define BTNS_CHECK\tTBSTYLE_CHECK\n#define BTNS_GROUP\tTBSTYLE_GROUP\n#define BTNS_CHECKGROUP TBSTYLE_CHECKGROUP\n#define BTNS_DROPDOWN\tTBSTYLE_DROPDOWN\n#define BTNS_AUTOSIZE\tTBSTYLE_AUTOSIZE\n#define BTNS_NOPREFIX\tTBSTYLE_NOPREFIX\n#define BTNS_SHOWTEXT\t0x0040\n#define BTNS_WHOLEDROPDOWN\t0x0080\n#define TBSTATE_CHECKED\t1\n#define TBSTATE_ENABLED\t4\n#define TBSTATE_HIDDEN\t8\n#define TBSTATE_INDETERMINATE\t16\n#define TBSTATE_PRESSED\t2\n#define TBSTATE_WRAP\t32\n#define TBSTATE_ELLIPSES\t0x40\n#define TBSTATE_MARKED\t0x80\n#define TBIMHT_AFTER\t1\n#define TBIMHT_BACKGROUND\t2\n#define TTS_ALWAYSTIP\t1\n#define TTS_NOPREFIX\t2\n#define TTS_NOANIMATE\t0x10\n#define TTS_NOFADE\t0x20\n#define TTS_BALLOON\t0x40\n#define TTS_CLOSE\t0x80\n#define TTF_IDISHWND\t1\n#define TTF_CENTERTIP\t2\n#define TTF_RTLREADING\t4\n#define TTF_SUBCLASS\t16\n#define TTF_TRACK\t0x0020\n#define TTF_ABSOLUTE\t0x0080\n#define TTF_PARSELINKS\t0x1000\n#define TTF_DI_SETITEM\t0x8000\n#define TTI_NONE\t0\n#define TTI_INFO\t1\n#define TTI_WARNING\t2\n#define TTI_ERROR\t3\n#define TTM_GETBUBBLESIZE\t(WM_USER + 30)\n#define TTM_POPUP\t(WM_USER + 34)\n#define TTM_GETTITLE\t(WM_USER + 35)\n#define TTDT_AUTOMATIC\t0\n#define TTDT_AUTOPOP\t2\n#define TTDT_INITIAL\t3\n#define TTDT_RESHOW\t1\n#define SBARS_SIZEGRIP\t256\n#define SBARS_SIZEGRIP\t256\n#define RBS_TOOLTIPS\t0x0100\n#define RBS_VARHEIGHT\t0x0200\n#define RBS_BANDBORDERS\t0x0400\n#define RBS_FIXEDORDER\t0x0800\n#define RBS_REGISTERDROP\t0x1000\n#define RBS_AUTOSIZE\t0x2000\n#define RBS_VERTICALGRIPPER 0x4000\n#define RBS_DBLCLKTOGGLE\t0x8000\n#define RBIM_IMAGELIST\t1\n#define RB_INSERTBANDA\t(WM_USER+1)\n#define RB_DELETEBAND\t(WM_USER+2)\n#define RB_GETBARINFO\t(WM_USER+3)\n#define RB_SETBARINFO\t(WM_USER+4)\n#define RB_GETBANDINFO\t(WM_USER+5)\n#define RB_SETBANDINFOA\t(WM_USER+6)\n#define RB_SETPARENT\t(WM_USER+7)\n#define RB_HITTEST\t(WM_USER+8)\n#define RB_GETRECT\t(WM_USER+9)\n#define RB_INSERTBANDW\t(WM_USER+10)\n#define RB_SETBANDINFOW\t(WM_USER+11)\n#define RB_GETBANDCOUNT (WM_USER+12)\n#define RB_GETROWCOUNT\t(WM_USER+13)\n#define RB_GETROWHEIGHT\t(WM_USER+14)\n#define RB_IDTOINDEX (WM_USER+16)\n#define RB_GETTOOLTIPS (WM_USER+17)\n#define RB_SETTOOLTIPS (WM_USER+18)\n#define RB_SETBKCOLOR (WM_USER+19)\n#define RB_GETBKCOLOR (WM_USER+20)\n#define RB_SETTEXTCOLOR (WM_USER+21)\n#define RB_GETTEXTCOLOR (WM_USER+22)\n#define RB_SIZETORECT (WM_USER+23)\n#define RB_BEGINDRAG\t(WM_USER+24)\n#define RB_ENDDRAG\t(WM_USER+25)\n#define RB_DRAGMOVE\t(WM_USER+26)\n#define RB_GETBARHEIGHT\t(WM_USER+27)\n#define RB_GETBANDINFOW (WM_USER+28)\n#define RB_GETBANDINFOA (WM_USER+29)\n#define RB_MINIMIZEBAND (WM_USER+30)\n#define RB_MAXIMIZEBAND (WM_USER+31)\n#define RB_GETBANDBORDERS (WM_USER+34)\n#define RB_SHOWBAND\t(WM_USER+35)\n#define RB_SETPALETTE\t(WM_USER+37)\n#define RB_GETPALETTE\t(WM_USER+38)\n#define RB_SETCOLORSCHEME CCM_SETCOLORSCHEME\n#define RB_GETCOLORSCHEME CCM_GETCOLORSCHEME\n#define RB_GETDROPTARGET (CCM_GETDROPTARGET)\n#define RB_SETUNICODEFORMAT CCM_SETUNICODEFORMAT\n#define RB_GETUNICODEFORMAT CCM_GETUNICODEFORMAT\n#define RB_GETBANDMARGINS\t(WM_USER + 40)\n#define RB_SETWINDOWTHEME\tCCM_SETWINDOWTHEME\n#define RB_PUSHCHEVRON\t(WM_USER + 43)\n#define RB_MOVEBAND\t(WM_USER + 39)\n#define RBBIM_STYLE\t1\n#define RBBIM_COLORS\t2\n#define RBBIM_TEXT\t4\n#define RBBIM_IMAGE\t8\n#define RBBIM_CHILD\t16\n#define RBBIM_CHILDSIZE\t32\n#define RBBIM_SIZE\t64\n#define RBBIM_BACKGROUND\t0x80\n#define RBBIM_ID\t0x100\n#define RBBIM_IDEALSIZE\t0x200\n#define RBBIM_LPARAM\t0x400\n#define RBBIM_HEADERSIZE\t0x800\n#define RBBS_BREAK\t1\n#define RBBS_FIXEDSIZE\t2\n#define RBBS_CHILDEDGE\t4\n#define RBBS_HIDDEN\t8\n#define RBBS_NOVERT\t16\n#define RBBS_FIXEDBMP\t32\n#define RBBS_VARIABLEHEIGHT\t0x40\n#define RBBS_GRIPPERALWAYS\t0x80\n#define RBBS_NOGRIPPER\t0x100\n#define RBBS_USECHEVRON\t0x200\n#define RBBS_HIDETITLE\t0x400\n#define RBBS_TOPALIGN\t0x0800\n#define RBHT_NOWHERE\t1\n#define RBHT_CAPTION\t2\n#define RBHT_CLIENT\t3\n#define RBHT_GRABBER\t4\n#define RBHT_CHEVRON\t8\n#define RB_INSERTBANDA\t(WM_USER+1)\n#define RB_DELETEBAND\t(WM_USER+2)\n#define RB_GETBARINFO\t(WM_USER+3)\n#define RB_SETBARINFO\t(WM_USER+4)\n#define RB_GETBANDINFO\t(WM_USER+5)\n#define RB_SETBANDINFOA\t(WM_USER+6)\n#define RB_SETPARENT\t(WM_USER+7)\n#define RB_HITTEST (WM_USER+8)\n#define RB_GETRECT (WM_USER+9)\n#define RB_INSERTBANDW (WM_USER+10)\n#define RB_SETBANDINFOW (WM_USER+11)\n#define RB_GETBANDCOUNT (WM_USER+12)\n#define RB_GETROWCOUNT (WM_USER+13)\n#define RB_GETROWHEIGHT (WM_USER+14)\n#define RB_IDTOINDEX (WM_USER+16)\n#define RB_GETTOOLTIPS (WM_USER+17)\n#define RB_SETTOOLTIPS (WM_USER+18)\n#define RB_SETBKCOLOR (WM_USER+19)\n#define RB_GETBKCOLOR (WM_USER+20)\n#define RB_SETTEXTCOLOR (WM_USER+21)\n#define RB_GETTEXTCOLOR (WM_USER+22)\n#define RB_SIZETORECT (WM_USER+23)\n#define DL_MOVECURSOR\t3\n#define DL_COPYCURSOR\t2\n#define DL_STOPCURSOR\t1\n#define UDS_ALIGNLEFT\t8\n#define UDS_ALIGNRIGHT\t4\n#define UDS_ARROWKEYS\t32\n#define UDS_AUTOBUDDY\t16\n#define UDS_HORZ\t64\n#define UDS_NOTHOUSANDS\t128\n#define UDS_HOTTRACK\t256\n#define UDS_SETBUDDYINT\t2\n#define UDS_WRAP\t1\n#define PBS_SMOOTH 1\n#define PBS_VERTICAL 4\n#define UD_MAXVAL\t32767\n#define UD_MINVAL\t(-32767)\n#define HOTKEYF_ALT\t4\n#define HOTKEYF_CONTROL\t2\n#define HOTKEYF_EXT\t8\n#define HOTKEYF_SHIFT\t1\n#define HKCOMB_A\t8\n#define HKCOMB_C\t4\n#define HKCOMB_CA\t64\n#define HKCOMB_NONE\t1\n#define HKCOMB_S\t2\n#define HKCOMB_SA\t32\n#define HKCOMB_SC\t16\n#define HKCOMB_SCA\t128\n#define CBES_EX_NOEDITIMAGE\t1\n#define CBES_EX_NOEDITIMAGEINDENT\t2\n#define CBES_EX_PATHWORDBREAKPROC\t4\n#define CBES_EX_NOSIZELIMIT\t8\n#define CBES_EX_CASESENSITIVE\t0x10\n#define TBS_HORZ\t0\n#define TBS_VERT\t2\n#define TBS_AUTOTICKS\t1\n#define TBS_NOTICKS\t16\n#define TBS_TOP\t4\n#define TBS_BOTTOM\t0\n#define TBS_LEFT\t4\n#define TBS_RIGHT\t0\n#define TBS_BOTH\t8\n#define TBS_ENABLESELRANGE\t32\n#define TBS_FIXEDLENGTH\t64\n#define TBS_NOTHUMB\t128\n#define TBS_TOOLTIPS\t256\n#define TBS_REVERSED\t0x200\n#define TB_BOTTOM\t7\n#define TB_ENDTRACK\t8\n#define TB_LINEDOWN\t1\n#define TB_LINEUP\t0\n#define TB_PAGEDOWN\t3\n#define TB_PAGEUP\t2\n#define TB_THUMBPOSITION\t4\n#define TB_THUMBTRACK\t5\n#define TB_TOP\t6\n#define TB_MARKBUTTON\t(WM_USER + 6)\n#define TB_ISBUTTONHIGHLIGHTED (WM_USER + 14)\n#define LVS_ALIGNLEFT\t2048\n#define LVS_ALIGNTOP\t0\n#define LVS_AUTOARRANGE\t256\n#define LVS_EDITLABELS\t512\n#define LVS_ICON\t0\n#define LVS_LIST\t3\n#define LVS_NOCOLUMNHEADER\t16384\n#define LVS_NOLABELWRAP\t128\n#define LVS_NOSCROLL\t8192\n#define LVS_NOSORTHEADER\t32768\n#define LVS_OWNERDRAWFIXED\t1024\n#define LVS_REPORT\t1\n#define LVS_SHAREIMAGELISTS\t64\n#define LVS_SHOWSELALWAYS\t8\n#define LVS_SINGLESEL\t4\n#define LVS_SMALLICON\t2\n#define LVS_SORTASCENDING\t16\n#define LVS_SORTDESCENDING\t32\n#define LVS_TYPESTYLEMASK\t64512\n#define LVS_TYPEMASK\t3\n#define LVS_ALIGNMASK\t0xc00\n#define LVS_OWNERDATA\t0x1000\n#define LVS_EX_GRIDLINES\t1\n#define LVS_EX_SUBITEMIMAGES\t2\n#define LVS_EX_CHECKBOXES\t4\n#define LVS_EX_TRACKSELECT\t8\n#define LVS_EX_HEADERDRAGDROP\t16\n#define LVS_EX_FULLROWSELECT\t32\n#define LVS_EX_ONECLICKACTIVATE 64\n#define LVS_EX_TWOCLICKACTIVATE\t128\n#define LVS_EX_FLATSB\t256\n#define LVS_EX_REGIONAL\t512\n#define LVS_EX_INFOTIP\t1024\n#define LVS_EX_UNDERLINEHOT\t0x800\n#define LVS_EX_UNDERLINECOLD\t0x1000\n#define LVS_EX_MULTIWORKAREAS\t0x2000\n#define LVS_EX_LABELTIP\t0x4000\n#define LVS_EX_BORDERSELECT\t0x8000\n#define LVS_EX_LABELTIP\t0x4000\n#define LVS_EX_BORDERSELECT\t0x8000\n#define LVS_EX_DOUBLEBUFFER\t0x10000\n#define LVS_EX_HIDELABELS\t0x20000\n#define LVS_EX_SINGLEROW\t0x40000\n#define LVS_EX_SNAPTOGRID\t0x80000\n#define LVS_EX_SIMPLESELECT\t0x100000\n#define LVSIL_NORMAL\t0\n#define LVSIL_SMALL\t1\n#define LVSIL_STATE\t2\n#define LVIS_CUT\t4\n#define LVIS_DROPHILITED\t8\n#define LVIS_FOCUSED\t1\n#define LVIS_SELECTED\t2\n#define LVIS_OVERLAYMASK\t3840\n#define LVIS_STATEIMAGEMASK\t61440\n#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)\n#define LPSTR_TEXTCALLBACKW\t((LPWSTR)-1)\n#define LPSTR_TEXTCALLBACKA\t((LPSTR)-1)\n#define LVIF_TEXT\t1\n#define LVIF_IMAGE\t2\n#define LVIF_PARAM\t4\n#define LVIF_STATE\t8\n#define LVIF_DI_SETITEM\t4096\n#define LVNI_ABOVE\t256\n#define LVNI_ALL\t0\n#define LVNI_BELOW\t512\n#define LVNI_TOLEFT\t1024\n#define LVNI_TORIGHT\t2048\n#define LVNI_CUT\t4\n#define LVNI_DROPHILITED\t8\n#define LVNI_FOCUSED\t1\n#define LVNI_SELECTED\t2\n#define LVFI_PARAM\t1\n#define LVFI_PARTIAL\t8\n#define LVFI_STRING\t2\n#define LVFI_WRAP\t32\n#define LVFI_NEARESTXY\t64\n#define LVHT_ABOVE\t8\n#define LVHT_BELOW\t16\n#define LVHT_NOWHERE\t1\n#define LVHT_ONITEMICON\t2\n#define LVHT_ONITEMLABEL\t4\n#define LVHT_ONITEMSTATEICON\t8\n#define LVHT_TOLEFT\t64\n#define LVHT_TORIGHT\t32\n#define LVHT_ONITEM\t(LVHT_ONITEMICON|LVHT_ONITEMLABEL|LVHT_ONITEMSTATEICON)\n#define LVCF_FMT\t1\n#define LVCF_SUBITEM\t8\n#define LVCF_TEXT\t4\n#define LVCF_WIDTH\t2\n#define LVCF_IMAGE         0x0010\n#define LVCF_ORDER         0x0020\n#define LVCFMT_CENTER\t2\n#define LVCFMT_LEFT\t0\n#define LVCFMT_RIGHT\t1\n#define LVCFMT_IMAGE        0x0800\n#define LVCFMT_BITMAP_ON_RIGHT 0x1000\n#define LVCFMT_COL_HAS_IMAGES  0x8000\n#define LVCFMT_JUSTIFYMASK   0x0003\n#define LVIR_BOUNDS\t0\n#define LVIR_ICON\t1\n#define LVIR_LABEL\t2\n#define LVIR_SELECTBOUNDS\t3\n#define LVA_ALIGNLEFT\t1\n#define LVA_ALIGNTOP\t2\n#define LVA_DEFAULT\t0\n#define LVA_SNAPTOGRID\t5\n#define LVSCW_AUTOSIZE\t(-1)\n#define LVSCW_AUTOSIZE_USEHEADER\t(-2)\n#define MONTHCAL_CLASSW\tL\"SysMonthCal32\"\n#define MONTHCAL_CLASSA\t\"SysMonthCal32\"\n#define MCM_FIRST\t0x1000\n#define MCM_GETCURSEL\t(MCM_FIRST + 1)\n#define MonthCal_GetCurSel(h,p) (BOOL)SNDMSG(h,MCM_GETCURSEL,0,(LPARAM)(p))\n#define MCM_SETCURSEL\t(MCM_FIRST+2)\n#define MonthCal_SetCurSel(h,p) (BOOL)SNDMSG(h,MCM_SETCURSEL,0,(LPARAM)(p))\n#define MCM_GETMAXSELCOUNT (MCM_FIRST+3)\n#define MonthCal_GetMaxSelCount(h) (DWORD)SNDMSG(h,MCM_GETMAXSELCOUNT,0,0)\n#define MCM_SETMAXSELCOUNT (MCM_FIRST+4)\n#define MonthCal_SetMaxSelCount(h,n) (BOOL)SNDMSG(h,MCM_SETMAXSELCOUNT,(WPARAM)(n),0)\n#define MCM_GETSELRANGE (MCM_FIRST+5)\n#define MonthCal_GetSelRange(h,r) SNDMSG(h,MCM_GETSELRANGE,0,(LPARAM)(r))\n#define MCM_SETSELRANGE\t(MCM_FIRST+6)\n#define MonthCal_SetSelRange(h,r) SNDMSG(h,MCM_SETSELRANGE,0,(LPARAM)(r))\n#define MCM_GETMONTHRANGE (MCM_FIRST+7)\n#define MonthCal_GetMonthRange(h,g,r) (DWORD)SNDMSG(h,MCM_GETMONTHRANGE,(WPARAM)(g),(LPARAM)(r))\n#define MCM_SETDAYSTATE (MCM_FIRST+8)\n#define MonthCal_SetDayState(h,c,r) SNDMSG(h,MCM_SETDAYSTATE,(WPARAM)(c),(LPARAM)(r))\n#define MCM_GETMINREQRECT\t(MCM_FIRST+9)\n#define MonthCal_GetMinReqRect(h,p) SNDMSG(h,MCM_GETMINREQRECT,0,(LPARAM)(p))\n#define MCM_SETCOLOR (MCM_FIRST + 10)\n#define MonthCal_SetColor(h,i,c) SNDMSG(h,MCM_SETCOLOR,i,c)\n#define MCM_GETCOLOR (MCM_FIRST+11)\n#define MonthCal_GetColor(h,i) SNDMSG(h,MCM_GETCOLOR,i,0)\n#define MCSC_BACKGROUND\t0\n#define MCSC_TEXT\t1\n#define MCSC_TITLEBK\t2\n#define MCSC_TITLETEXT\t3\n#define MCSC_MONTHBK\t4\n#define MCSC_TRAILINGTEXT\t5\n#define MCM_SETTODAY\t(MCM_FIRST+12)\n#define MonthCal_SetToday(h,p) SNDMSG(h,MCM_SETTODAY,0,(LPARAM)(p))\n#define MCM_GETTODAY\t(MCM_FIRST+13)\n#define MonthCal_GetToday(h,p)\t(BOOL)SNDMSG(h,MCM_GETTODAY,0,(LPARAM)(p))\n#define MCM_HITTEST\t(MCM_FIRST+14)\n#define MonthCal_HitTest(h,p) SNDMSG(h, MCM_HITTEST, 0, (LPARAM)(PMCHITTESTINFO)(p))\n#define MCHT_TITLE\t0x10000\n#define MCHT_CALENDAR\t0x20000\n#define MCHT_TODAYLINK\t0x30000\n#define MCHT_NEXT\t0x1000000\n#define MCHT_PREV\t0x2000000\n#define MCHT_NOWHERE\t0\n#define MCHT_TITLEBK\t(MCHT_TITLE)\n#define MCHT_TITLEMONTH\t(MCHT_TITLE|1)\n#define MCHT_TITLEYEAR\t(MCHT_TITLE|2)\n#define MCHT_TITLEBTNNEXT\t(MCHT_TITLE|MCHT_NEXT|3)\n#define MCHT_TITLEBTNPREV\t(MCHT_TITLE|MCHT_PREV|3)\n#define MCHT_CALENDARBK\t(MCHT_CALENDAR)\n#define MCHT_CALENDARDATE\t(MCHT_CALENDAR|1)\n#define MCHT_CALENDARDATENEXT\t(MCHT_CALENDARDATE|MCHT_NEXT)\n#define MCHT_CALENDARDATEPREV\t(MCHT_CALENDARDATE|MCHT_PREV)\n#define MCHT_CALENDARDAY\t(MCHT_CALENDAR | 0x0002)\n#define MCHT_CALENDARWEEKNUM\t(MCHT_CALENDAR | 0x0003)\n#define MCM_SETFIRSTDAYOFWEEK (MCM_FIRST+15)\n#define MonthCal_SetFirstDayOfWeek(h,i) SNDMSG(h,MCM_SETFIRSTDAYOFWEEK,0,i)\n#define MCM_GETFIRSTDAYOFWEEK (MCM_FIRST+16)\n#define MonthCal_GetFirstDayOfWeek(h) (DWORD)SNDMSG(h,MCM_GETFIRSTDAYOFWEEK,0,0)\n#define MCM_GETRANGE (MCM_FIRST+17)\n#define MonthCal_GetRange(h, r) (DWORD)SNDMSG(h,MCM_GETRANGE,0,(LPARAM)(r))\n#define MCM_SETRANGE (MCM_FIRST+18)\n#define MonthCal_SetRange(h,g,r) (BOOL)SNDMSG(h,MCM_SETRANGE,(WPARAM)(g),(LPARAM)(r))\n#define MCM_GETMONTHDELTA (MCM_FIRST + 19)\n#define MonthCal_GetMonthDelta(hmc) (int)SNDMSG(h,MCM_GETMONTHDELTA,0,0)\n#define MCM_SETMONTHDELTA (MCM_FIRST+20)\n#define MonthCal_SetMonthDelta(h,n) (int)SNDMSG(h,MCM_SETMONTHDELTA,n,0)\n#define MCM_GETMAXTODAYWIDTH (MCM_FIRST+21)\n#define MonthCal_GetMaxTodayWidth(hmc) (DWORD)SNDMSG(h,MCM_GETMAXTODAYWIDTH,0,0)\n\n//#if (_WIN32_IE >= 0x0400)\n#define MCM_SETUNICODEFORMAT\tCCM_SETUNICODEFORMAT\n#define MonthCal_SetUnicodeFormat(h,f) (BOOL)SNDMSG((h),MCM_SETUNICODEFORMAT,(WPARAM)(f),0)\n#define MCM_GETUNICODEFORMAT\tCCM_GETUNICODEFORMAT\n#define MonthCal_GetUnicodeFormat(h) (BOOL)SNDMSG((h),MCM_GETUNICODEFORMAT,0,0)\n//#endif\n#define MCN_SELCHANGE\t(MCN_FIRST+1)\n#define MCN_GETDAYSTATE\t(MCN_FIRST+3)\n#define MCN_SELECT\t(MCN_FIRST+4)\n#define MCS_DAYSTATE\t1\n#define MCS_MULTISELECT\t2\n#define MCS_WEEKNUMBERS\t4\n#define MCS_NOTODAYCIRCLE\t8\n#define MCS_NOTODAY\t16\n#define GMR_VISIBLE\t0\n#define GMR_DAYSTATE\t1\n#define TVS_DISABLEDRAGDROP\t16\n#define TVS_EDITLABELS\t8\n#define TVS_HASBUTTONS\t1\n#define TVS_HASLINES\t2\n#define TVS_LINESATROOT\t4\n#define TVS_SHOWSELALWAYS\t32\n#define TVS_NOTOOLTIPS\t0x80\n#define TVS_CHECKBOXES\t0x100\n#define TVS_TRACKSELECT\t0x200\n#define TVS_SINGLEEXPAND\t0x400\n#define TVS_INFOTIP\t0x800\n#define TVS_FULLROWSELECT\t0x1000\n#define TVS_NOSCROLL\t0x2000\n#define TVS_NONEVENHEIGHT\t0x4000\n#define TVS_NOHSCROLL\t0x8000\n#define TVS_RTLREADING\t0x40\n#define TVIS_BOLD\t16\n#define TVIS_CUT\t4\n#define TVIS_DROPHILITED\t8\n#define TVIS_EXPANDED\t32\n#define TVIS_EXPANDEDONCE\t64\n#define TVIS_FOCUSED\t1\n#define TVIS_OVERLAYMASK\t3840\n#define TVIS_SELECTED\t2\n#define TVIS_STATEIMAGEMASK\t61440\n#define TVIS_USERMASK\t61440\n#define TVIF_CHILDREN\t64\n#define TVIF_HANDLE\t16\n#define TVIF_IMAGE\t2\n#define TVIF_PARAM\t4\n#define TVIF_SELECTEDIMAGE\t32\n#define TVIF_STATE\t8\n#define TVIF_TEXT\t1\n#define TVIF_DI_SETITEM\t0x1000\n#define I_CHILDRENCALLBACK\t(-1)\n#define I_IMAGECALLBACK\t(-1)\n#define I_IMAGENONE\t(-2)\n#define TVI_ROOT\t((HTREEITEM)(-65536))\n#define TVI_FIRST\t((HTREEITEM)(-65535))\n#define TVI_LAST\t((HTREEITEM)(-65534))\n#define TVI_SORT\t((HTREEITEM)(-65533))\n#define TVHT_ABOVE\t256\n#define TVHT_BELOW\t512\n#define TVHT_NOWHERE\t1\n#define TVHT_ONITEM\t70\n#define TVHT_ONITEMBUTTON\t16\n#define TVHT_ONITEMICON\t2\n#define TVHT_ONITEMINDENT\t8\n#define TVHT_ONITEMLABEL\t4\n#define TVHT_ONITEMRIGHT\t32\n#define TVHT_ONITEMSTATEICON\t64\n#define TVHT_TOLEFT\t2048\n#define TVHT_TORIGHT\t1024\n#define TVE_COLLAPSE\t1\n#define TVE_COLLAPSERESET\t32768\n#define TVE_EXPAND\t2\n#define TVE_TOGGLE\t3\n#define TVSIL_NORMAL\t0\n#define TVSIL_STATE\t2\n#define TVGN_CARET\t9\n#define TVGN_CHILD\t4\n#define TVGN_DROPHILITE\t8\n#define TVGN_FIRSTVISIBLE\t5\n#define TVGN_NEXT\t1\n#define TVGN_NEXTVISIBLE\t6\n#define TVGN_PARENT\t3\n#define TVGN_PREVIOUS\t2\n#define TVGN_PREVIOUSVISIBLE\t7\n#define TVGN_ROOT\t0\n#define TVC_BYKEYBOARD\t2\n#define TVC_BYMOUSE\t1\n#define TVC_UNKNOWN\t0\n#define TCS_BUTTONS\t256\n#define TCS_FIXEDWIDTH\t1024\n#define TCS_FOCUSNEVER\t32768\n#define TCS_FOCUSONBUTTONDOWN\t4096\n#define TCS_FORCEICONLEFT\t16\n#define TCS_FORCELABELLEFT\t32\n#define TCS_MULTILINE\t512\n#define TCS_OWNERDRAWFIXED\t8192\n#define TCS_RAGGEDRIGHT\t2048\n#define TCS_RIGHTJUSTIFY\t0\n#define TCS_SINGLELINE\t0\n#define TCS_TABS\t0\n#define TCS_TOOLTIPS\t16384\n#define TCS_SCROLLOPPOSITE\t1\n#define TCS_BOTTOM\t2\n#define TCS_RIGHT\t2\n#define TCS_BOTTOM\t2\n#define TCS_MULTISELECT\t4\n#define TCS_HOTTRACK\t0x40\n#define TCS_VERTICAL\t0x80\n#define TCS_FLATBUTTONS\t8\n#define TCS_HOTTRACK\t0x40\n#define TCS_VERTICAL\t0x80\n#define TCS_TABS\t0\n#define TCS_SINGLELINE\t0\n#define TCS_RIGHTJUSTIFY\t0\n#define TCS_RAGGEDRIGH\t0x800\n#define TCS_EX_FLATSEPARATORS\t1\n#define TCS_EX_REGISTERDROP\t2\n#define TCIF_TEXT\t1\n#define TCIF_IMAGE\t2\n#define TCIF_PARAM\t8\n#define TCIF_RTLREADING\t4\n#define TCIF_STATE\t0x10\n#define TCIS_BUTTONPRESSED\t1\n#define TCIS_HIGHLIGHTED\t2\n#define TCHT_NOWHERE\t1\n#define TCHT_ONITEM\t6\n#define TCHT_ONITEMICON\t2\n#define TCHT_ONITEMLABEL\t4\n#define LPTC_HITTESTINFO\tLPTCHITTESTINFO\n#define TC_HITTESTINFO\tTCHITTESTINFO\n#define ACS_AUTOPLAY\t4\n#define ACS_CENTER\t1\n#define ACS_TRANSPARENT\t2\n#define ACS_TIMER\t8\n#define DIALOPTION_BILLING\t64\n#define DIALOPTION_QUIET\t128\n#define DIALOPTION_DIALTONE\t256\n#define MDMVOLFLAG_LOW\t1\n#define MDMVOLFLAG_MEDIUM\t2\n#define MDMVOLFLAG_HIGH\t4\n#define MDMVOL_LOW\t0\n#define MDMVOL_MEDIUM\t1\n#define MDMVOL_HIGH\t2\n#define MDMSPKRFLAG_OFF\t1\n#define MDMSPKRFLAG_DIAL\t2\n#define MDMSPKRFLAG_ON\t4\n#define MDMSPKRFLAG_CALLSETUP\t8\n#define MDMSPKR_OFF\t0\n#define MDMSPKR_DIAL\t1\n#define MDMSPKR_ON\t2\n#define MDMSPKR_CALLSETUP\t3\n#define MDM_BLIND_DIAL\t512\n#define MDM_CCITT_OVERRIDE\t64\n#define MDM_CELLULAR\t8\n#define MDM_COMPRESSION\t1\n#define MDM_ERROR_CONTROL\t2\n#define MDM_FLOWCONTROL_HARD\t16\n#define MDM_FLOWCONTROL_SOFT\t32\n#define MDM_FORCED_EC\t4\n#define MDM_SPEED_ADJUST\t128\n#define MDM_TONE_DIAL\t256\n#define MDM_V23_OVERRIDE\t1024\n#define MINCHAR\t0x80\n#define MAXCHAR\t0x7f\n#define MINSHORT\t0x8000\n#define MAXSHORT\t0x7fff\n#define MINLONG\t0x80000000\n#define MAXLONG\t0x7fffffff\n#define MAXBYTE\t0xff\n#define MAXWORD\t0xffff\n#define MAXDWORD\t0xffffffff\n#define LANG_BULGARIAN\t2\n#define LANG_CHINESE\t4\n#define LANG_CROATIAN\t26\n#define LANG_CZECH\t5\n#define LANG_DANISH\t6\n#define LANG_DUTCH\t19\n#define LANG_ENGLISH\t9\n#define LANG_FINNISH\t11\n#define LANG_FRENCH\t12\n#define LANG_GERMAN\t7\n#define LANG_GREEK\t8\n#define LANG_HUNGARIAN\t14\n#define LANG_ICELANDIC\t15\n#define LANG_ITALIAN\t16\n#define LANG_JAPANESE\t17\n#define LANG_KOREAN\t18\n#define LANG_NEUTRAL\t0\n#define LANG_NORWEGIAN\t20\n#define LANG_POLISH\t21\n#define LANG_PORTUGUESE\t22\n#define LANG_ROMANIAN\t24\n#define LANG_RUSSIAN\t25\n#define LANG_SLOVAK\t27\n#define LANG_SLOVENIAN\t36\n#define LANG_SPANISH\t10\n#define LANG_SWEDISH\t29\n#define LANG_TURKISH\t31\n#define SUBLANG_CHINESE_SIMPLIFIED\t2\n#define SUBLANG_CHINESE_TRADITIONAL\t1\n#define SUBLANG_CHINESE_HONGKONG\t3\n#define SUBLANG_CHINESE_SINGAPORE\t4\n#define SUBLANG_DEFAULT\t1\n#define SUBLANG_DUTCH\t1\n#define SUBLANG_DUTCH_BELGIAN\t2\n#define SUBLANG_ENGLISH_AUS\t3\n#define SUBLANG_ENGLISH_CAN\t4\n#define SUBLANG_ENGLISH_EIRE\t6\n#define SUBLANG_ENGLISH_NZ\t5\n#define SUBLANG_ENGLISH_UK\t2\n#define SUBLANG_ENGLISH_US\t1\n#define SUBLANG_FRENCH\t1\n#define SUBLANG_FRENCH_BELGIAN\t2\n#define SUBLANG_FRENCH_CANADIAN\t3\n#define SUBLANG_FRENCH_SWISS\t4\n#define SUBLANG_GERMAN\t1\n#define SUBLANG_GERMAN_AUSTRIAN\t3\n#define SUBLANG_GERMAN_SWISS\t2\n#define SUBLANG_ITALIAN\t1\n#define SUBLANG_ITALIAN_SWISS\t2\n#define SUBLANG_NEUTRAL\t0\n#define SUBLANG_NORWEGIAN_BOKMAL\t1\n#define SUBLANG_NORWEGIAN_NYNORSK\t2\n#define SUBLANG_PORTUGUESE\t2\n#define SUBLANG_PORTUGUESE_BRAZILIAN\t1\n#define SUBLANG_SPANISH\t1\n#define SUBLANG_SPANISH_MEXICAN\t2\n#define SUBLANG_SPANISH_MODERN\t3\n#define SUBLANG_SYS_DEFAULT\t2\n#define NLS_VALID_LOCALE_MASK\t1048575\n#define SORT_DEFAULT\t0\n#define SORT_JAPANESE_XJIS\t0\n#define SORT_JAPANESE_UNICODE\t1\n#define SORT_CHINESE_BIG5\t0\n#define SORT_CHINESE_UNICODE\t1\n#define SORT_KOREAN_KSC\t0\n#define SORT_KOREAN_UNICODE\t1\n#define NM_LAST\t(-99U)\n#define LVN_FIRST\t((unsigned)-100)\n#define LVN_LAST\t(-199U)\n#define HDN_FIRST\t(-300U)\n#define HDN_LAST\t(-399U)\n#define TVN_FIRST\t(-400U)\n#define TVN_LAST\t(-499U)\n#define TTN_FIRST\t(-520U)\n#define TTN_LAST\t(-549U)\n#define TCN_FIRST\t(-550U)\n#define TCN_LAST\t(-580U)\n#define CDN_FIRST\t(-601U)\n#define CDN_LAST\t(-699U)\n#define TBN_FIRST\t(-700U)\n#define TBN_LAST\t(-720U)\n#define UDN_FIRST\t(-721)\n#define UDN_LAST\t(-740)\n#define MCN_FIRST\t(-750U)\n#define MCN_LAST\t(-759U)\n#define DTN_FIRST\t(-760U)\n#define DTN_LAST\t(-799U)\n#define DTM_FIRST\t0x1000\n#define CBEN_FIRST\t(0xfffffce0)\n#define CBEN_GETDISPINFO CBEN_FIRST\n#define CBEN_GETDISPINFOA CBEN_FIRST\n#define CBEN_GETDISPINFOW (CBEN_FIRST-7)\n#define CBEN_BEGINEDIT\t(CBEN_FIRST-4)\n#define CBEN_ENDEDITA\t(CBEN_FIRST-5)\n#define CBEN_ENDEDITW\t(CBEN_FIRST-6)\n#define CBEN_INSERTITEM\t(CBEN_FIRST-1)\n#define CBEN_DELETEITEM\t(CBEN_FIRST-2)\n\n#ifdef UNICODE\n#define TVM_INSERTITEM\tTVM_INSERTITEMW\n#define CBEN_ENDEDIT CBEN_ENDEDITW\n#define CBEN_DRAGBEGIN CBEN_DRAGBEGINW\n#define MONTHCAL_CLASS\tMONTHCAL_CLASSW\n#define WC_PAGESCROLLER\tWC_PAGESCROLLERW\n#define TTM_SETTITLE\tTTM_SETTITLEW\n#else\n#define TTM_SETTITLE\tTTM_SETTITLEA\n#define TVM_INSERTITEM\tTVM_INSERTITEMA\n#define CBEN_ENDEDIT CBEN_ENDEDITA\n#define CBEN_DRAGBEGIN CBEN_DRAGBEGINA\n#define MONTHCAL_CLASS\tMONTHCAL_CLASSA\n#define WC_PAGESCROLLER\tWC_PAGESCROLLERA\n#endif\n\n#define CBENF_KILLFOCUS\t1\n#define CBENF_RETURN\t2\n#define CBENF_ESCAPE\t3\n#define CBENF_DROPDOWN\t4\n#define CBEMAXSTRLEN 260\n#define CBEN_DRAGBEGINA\t(CBEN_FIRST - 8)\n#define CBEN_DRAGBEGINW\t(CBEN_FIRST - 9)\n#define CBEN_LAST\t(-830U)\n#define RBN_FIRST\t(0U-831U)\n#define RBN_LAST\t(0U-859U)\n#define RBN_HEIGHTCHANGE\t(RBN_FIRST - 0)\n#define RBN_GETOBJECT\t(RBN_FIRST - 1)\n#define RBN_LAYOUTCHANGED\t(RBN_FIRST - 2)\n#define RBN_AUTOSIZE\t(RBN_FIRST - 3)\n#define RBN_BEGINDRAG\t(RBN_FIRST - 4)\n#define RBN_ENDDRAG\t(RBN_FIRST - 5)\n#define RBN_DELETINGBAND\t(RBN_FIRST - 6)\n#define RBN_DELETEDBAND\t(RBN_FIRST - 7)\n#define RBN_CHILDSIZE\t(RBN_FIRST - 8)\n#define RBN_CHEVRONPUSHED\t(RBN_FIRST - 10)\n#define RBN_MINMAX\t(RBN_FIRST - 21)\n#define RBN_AUTOBREAK\t(RBN_FIRST - 22)\n#define RBNM_ID\t1\n#define RBNM_STYLE\t2\n#define RBNM_LPARAM\t4\n#define IPN_FIRST\t(-860U)\n#define IPN_LAST\t(-879U)\n#define PGN_FIRST\t(-900U)\n#define PGN_LAST\t(-950U)\n#define SBN_FIRST\t(-880U)\n#define SBN_LAST\t(-899U)\n#define DTM_GETSYSTEMTIME\t(DTM_FIRST+1)\n#define DTM_SETSYSTEMTIME\t(DTM_FIRST+2)\n#define DTM_GETRANGE\t(DTM_FIRST+3)\n#define DTM_SETRANGE\t(DTM_FIRST+4)\n#define DTM_SETFORMATA\t(DTM_FIRST+5)\n#define DTM_SETFORMATW\t(DTM_FIRST+50)\n#define DTM_SETMCCOLOR\t(DTM_FIRST+6)\n#define DTM_GETMCCOLOR\t(DTM_FIRST+7)\n#define DTM_GETMONTHCAL\t(DTM_FIRST+8)\n#define DTM_SETMCFONT\t(DTM_FIRST+9)\n#define DTM_GETMCFONT\t(DTM_FIRST+10)\n#define DTS_UPDOWN\t1\n#define DTS_SHOWNONE\t2\n#define DTS_SHORTDATEFORMAT 0\n#define DTS_LONGDATEFORMAT 4\n#define DTS_TIMEFORMAT\t9\n#define DTS_APPCANPARSE\t16\n#define DTS_RIGHTALIGN\t32\n#define DTS_SHORTDATECENTURYFORMAT 0xC\n#define DTN_DATETIMECHANGE (DTN_FIRST+1)\n#define DTN_USERSTRINGA\t(DTN_FIRST+2)\n#define DTN_USERSTRINGW\t(DTN_FIRST+15)\n#define DTN_WMKEYDOWNA\t(DTN_FIRST+3)\n#define DTN_WMKEYDOWNW\t(DTN_FIRST+16)\n#define DTN_FORMATA\t(DTN_FIRST + 4)\n#define DTN_FORMATW\t(DTN_FIRST+17)\n#define DTN_FORMATQUERYA\t(DTN_FIRST+5)\n#define DTN_FORMATQUERYW\t(DTN_FIRST+18)\n#define DTN_DROPDOWN\t(DTN_FIRST + 6)\n#define DTN_CLOSEUP\t(DTN_FIRST + 7)\n#define GDTR_MIN\t1\n#define GDTR_MAX\t2\n#define GDT_ERROR\t-1\n#define GDT_VALID\t0\n#define GDT_NONE\t1\n#define CDRF_DODEFAULT\t0\n#define CDRF_NEWFONT\t2\n#define CDRF_SKIPDEFAULT\t4\n#define CDRF_NOTIFYPOSTPAINT\t16\n#define CDRF_NOTIFYITEMDRAW\t32\n#define CDRF_NOTIFYSUBITEMDRAW\t32\n#define CDRF_NOTIFYPOSTERASE\t0x40\n#define CDDS_PREPAINT\t1\n#define CDDS_POSTPAINT\t2\n#define CDDS_PREERASE\t3\n#define CDDS_POSTERASE\t4\n#define CDDS_ITEM\t0x10000\n#define CDDS_ITEMPREPAINT\t(CDDS_ITEM | CDDS_PREPAINT)\n#define CDDS_ITEMPOSTPAINT\t(CDDS_ITEM | CDDS_POSTPAINT)\n#define CDDS_ITEMPREERASE\t(CDDS_ITEM | CDDS_PREERASE)\n#define CDDS_ITEMPOSTERASE\t(CDDS_ITEM | CDDS_POSTERASE)\n#define CDDS_SUBITEM\t0x20000\n#define CDIS_SELECTED\t1\n#define CDIS_GRAYED\t2\n#define CDIS_DISABLED\t4\n#define CDIS_CHECKED\t8\n#define CDIS_FOCUS\t16\n#define CDIS_DEFAULT\t32\n#define CDIS_HOT\t64\n#define CDIS_MARKED\t0x80\n#define CDIS_INDETERMINATE\t0x0100\n#define CLR_HILIGHT\tCLR_DEFAULT\n#define PROCESSOR_INTEL_386\t386\n#define PROCESSOR_INTEL_486\t486\n#define PROCESSOR_INTEL_PENTIUM\t586\n#define PROCESSOR_MIPS_R4000\t4000\n#define PROCESSOR_ALPHA_21064\t21064\n#define COMPRESSION_FORMAT_NONE\t0\n#define COMPRESSION_FORMAT_DEFAULT\t1\n#define COMPRESSION_FORMAT_LZNT1\t2\n#define TAPE_DRIVE_COMPRESSION\t131072\n#define TAPE_DRIVE_ECC\t65536\n#define TAPE_DRIVE_ERASE_BOP_ONLY\t64\n#define TAPE_DRIVE_ERASE_LONG\t32\n#define TAPE_DRIVE_ERASE_IMMEDIATE\t128\n#define TAPE_DRIVE_ERASE_SHORT\t16\n#define TAPE_DRIVE_FIXED\t1\n#define TAPE_DRIVE_FIXED_BLOCK\t1024\n#define TAPE_DRIVE_INITIATOR\t4\n#define TAPE_DRIVE_PADDING\t262144\n#define TAPE_DRIVE_GET_ABSOLUTE_BLK\t1048576\n#define TAPE_DRIVE_GET_LOGICAL_BLK\t2097152\n#define TAPE_DRIVE_REPORT_SMKS\t524288\n#define TAPE_DRIVE_SELECT\t2\n#define TAPE_DRIVE_SET_EOT_WZ_SIZE\t4194304\n#define TAPE_DRIVE_TAPE_CAPACITY\t256\n#define TAPE_DRIVE_TAPE_REMAINING\t512\n#define TAPE_DRIVE_VARIABLE_BLOCK\t2048\n#define TAPE_DRIVE_WRITE_PROTECT\t4096\n#define TAPE_DRIVE_ABS_BLK_IMMED\t(-2147475456)\n#define TAPE_DRIVE_ABSOLUTE_BLK\t(-2147479552)\n#define TAPE_DRIVE_END_OF_DATA\t(-2147418112)\n#define TAPE_DRIVE_FILEMARKS\t(-2147221504)\n#define TAPE_DRIVE_LOAD_UNLOAD\t(-2147483647)\n#define TAPE_DRIVE_LOAD_UNLD_IMMED\t(-2147483616)\n#define TAPE_DRIVE_LOCK_UNLOCK\t(-2147483644)\n#define TAPE_DRIVE_LOCK_UNLK_IMMED\t(-2147483520)\n#define TAPE_DRIVE_LOG_BLK_IMMED\t(-2147450880)\n#define TAPE_DRIVE_LOGICAL_BLK\t(-2147467264)\n#define TAPE_DRIVE_RELATIVE_BLKS\t(-2147352576)\n#define TAPE_DRIVE_REVERSE_POSITION\t(-2143289344)\n#define TAPE_DRIVE_REWIND_IMMEDIATE\t(-2147483640)\n#define TAPE_DRIVE_SEQUENTIAL_FMKS\t(-2146959360)\n#define TAPE_DRIVE_SEQUENTIAL_SMKS\t(-2145386496)\n#define TAPE_DRIVE_SET_BLOCK_SIZE\t(-2147483632)\n#define TAPE_DRIVE_SET_COMPRESSION\t(-2147483136)\n#define TAPE_DRIVE_SET_ECC\t(-2147483392)\n#define TAPE_DRIVE_SET_PADDING\t(-2147482624)\n#define TAPE_DRIVE_SET_REPORT_SMKS\t(-2147481600)\n#define TAPE_DRIVE_SETMARKS\t(-2146435072)\n#define TAPE_DRIVE_SPACE_IMMEDIATE\t(-2139095040)\n#define TAPE_DRIVE_TENSION\t(-2147483646)\n#define TAPE_DRIVE_TENSION_IMMED\t(-2147483584)\n#define TAPE_DRIVE_WRITE_FILEMARKS\t(-2113929216)\n#define TAPE_DRIVE_WRITE_LONG_FMKS\t(-2013265920)\n#define TAPE_DRIVE_WRITE_MARK_IMMED\t(-1879048192)\n#define TAPE_DRIVE_WRITE_SETMARKS\t(-2130706432)\n#define TAPE_DRIVE_WRITE_SHORT_FMKS\t(-2080374784)\n#define STANDARD_RIGHTS_REQUIRED\t0xf0000\n#define STANDARD_RIGHTS_WRITE\t0x20000\n#define STANDARD_RIGHTS_READ\t0x20000\n#define STANDARD_RIGHTS_EXECUTE\t0x20000\n#define STANDARD_RIGHTS_ALL\t0x1f0000\n#define SPECIFIC_RIGHTS_ALL\t0xffff\n#define MAXIMUM_ALLOWED\t0x2000000\n#define GENERIC_ALL\t0x10000000\n#define SECURITY_NULL_RID\t0\n#define SECURITY_WORLD_RID\t0\n#define SECURITY_LOCAL_RID\t0\n#define SECURITY_CREATOR_OWNER_RID\t0\n#define SECURITY_CREATOR_GROUP_RID\t1\n#define SECURITY_DIALUP_RID\t1\n#define SECURITY_NETWORK_RID\t2\n#define SECURITY_BATCH_RID\t3\n#define SECURITY_INTERACTIVE_RID\t4\n#define SECURITY_LOGON_IDS_RID\t5\n#define SECURITY_LOGON_IDS_RID_COUNT\t3\n#define SECURITY_SERVICE_RID\t6\n#define SECURITY_LOCAL_SYSTEM_RID\t0x12\n#define SECURITY_BUILTIN_DOMAIN_RID\t32\n#define DOMAIN_USER_RID_ADMIN\t0x1f4\n#define DOMAIN_USER_RID_GUEST\t0x1f5\n#define DOMAIN_GROUP_RID_ADMINS\t512\n#define DOMAIN_GROUP_RID_USERS\t0x201\n#define DOMAIN_ALIAS_RID_ADMINS\t0x220\n#define DOMAIN_ALIAS_RID_USERS\t0x221\n#define DOMAIN_ALIAS_RID_GUESTS\t0x222\n#define DOMAIN_ALIAS_RID_POWER_USERS\t0x223\n#define DOMAIN_ALIAS_RID_ACCOUNT_OPS\t0x224\n#define DOMAIN_ALIAS_RID_SYSTEM_OPS\t0x225\n#define DOMAIN_ALIAS_RID_PRINT_OPS\t0x226\n#define DOMAIN_ALIAS_RID_BACKUP_OPS\t0x227\n#define DOMAIN_ALIAS_RID_REPLICATOR\t0x228\n#define SE_GROUP_MANDATORY\t1\n#define SE_GROUP_ENABLED_BY_DEFAULT\t2\n#define SE_GROUP_ENABLED\t4\n#define SE_GROUP_OWNER\t8\n#define SE_GROUP_LOGON_ID\t0xc0000000\n#define SECURITY_DESCRIPTOR_REVISION\t1\n#define SECURITY_DESCRIPTOR_MIN_LENGTH\t20\n#define SE_OWNER_DEFAULTED\t1\n#define SE_GROUP_DEFAULTED\t2\n#define SE_DACL_PRESENT\t4\n#define SE_DACL_DEFAULTED\t8\n#define SE_SACL_PRESENT\t16\n#define SE_SACL_DEFAULTED\t32\n#define SE_SELF_RELATIVE\t32768\n#define SE_PRIVILEGE_ENABLED_BY_DEFAULT\t1\n#define SE_PRIVILEGE_ENABLED\t2\n#define SE_PRIVILEGE_USED_FOR_ACCESS\t0x80000000\n#define PRIVILEGE_SET_ALL_NECESSARY\t1\n#define OFN_ALLOWMULTISELECT\t512\n#define OFN_CREATEPROMPT\t0x2000\n#define OFN_ENABLEHOOK\t32\n#define OFN_ENABLETEMPLATE\t64\n#define OFN_ENABLETEMPLATEHANDLE\t128\n#define OFN_EXPLORER\t0x80000\n#define OFN_EXTENSIONDIFFERENT\t0x400\n#define OFN_FILEMUSTEXIST\t0x1000\n#define OFN_HIDEREADONLY\t4\n#define OFN_LONGNAMES\t0x200000\n#define OFN_NOCHANGEDIR\t8\n#define OFN_NODEREFERENCELINKS\t0x100000\n#define OFN_NOLONGNAMES\t0x40000\n#define OFN_NONETWORKBUTTON\t0x20000\n#define OFN_NOREADONLYRETURN\t0x8000\n#define OFN_NOTESTFILECREATE\t0x10000\n#define OFN_NOVALIDATE\t256\n#define OFN_OVERWRITEPROMPT\t2\n#define OFN_PATHMUSTEXIST\t0x800\n#define OFN_READONLY\t1\n#define OFN_SHAREAWARE\t0x4000\n#define OFN_SHOWHELP\t16\n#define OFN_SHAREFALLTHROUGH\t2\n#define OFN_SHARENOWARN\t1\n#define OFN_SHAREWARN\t0\n#define CDN_INITDONE\t0xfffffda7\n#define CDN_SELCHANGE\t0xfffffda6\n#define CDN_FOLDERCHANGE\t0xfffffda5\n#define CDN_SHAREVIOLATION\t0xfffffda4\n#define CDN_HELP\t0xfffffda3\n#define CDN_FILEOK\t0xfffffda2\n#define CDN_TYPECHANGE\t0xfffffda1\n#define CDM_GETFILEPATH\t0x465\n#define CDM_GETFOLDERIDLIST\t0x467\n#define CDM_GETFOLDERPATH\t0x466\n#define CDM_GETSPEC\t0x464\n#define CDM_HIDECONTROL\t0x469\n#define CDM_SETCONTROLTEXT\t0x468\n#define CDM_SETDEFEXT\t0x46a\n#define CC_ENABLEHOOK\t16\n#define CC_ENABLETEMPLATE\t32\n#define CC_ENABLETEMPLATEHANDLE\t64\n#define CC_FULLOPEN\t2\n#define CC_PREVENTFULLOPEN\t4\n#define CC_RGBINIT\t1\n#define CC_SHOWHELP\t8\n#define CC_SOLIDCOLOR\t128\n#define FR_DIALOGTERM\t64\n#define FR_DOWN\t1\n#define FR_ENABLEHOOK\t256\n#define FR_ENABLETEMPLATE\t512\n#define FR_ENABLETEMPLATEHANDLE\t0x2000\n#define FR_FINDNEXT\t8\n#define FR_HIDEUPDOWN\t0x4000\n#define FR_HIDEMATCHCASE\t0x8000\n#define FR_HIDEWHOLEWORD\t0x10000\n#define FR_MATCHCASE\t4\n#define FR_NOMATCHCASE\t0x800\n#define FR_NOUPDOWN\t0x400\n#define FR_NOWHOLEWORD\t4096\n#define FR_REPLACE\t16\n#define FR_REPLACEALL\t32\n#define FR_SHOWHELP\t128\n#define FR_WHOLEWORD\t2\n#define FR_PRIVATE\t0x10\n#define FR_NOT_ENUM\t0x20\n#define CF_APPLY\t512\n#define CF_ANSIONLY\t0x400\n#define CF_BOTH\t3\n#define CF_TTONLY\t0x40000\n#define CF_EFFECTS\t256\n#define CF_ENABLEHOOK\t8\n#define CF_ENABLETEMPLATE\t16\n#define CF_ENABLETEMPLATEHANDLE\t32\n#define CF_FIXEDPITCHONLY\t0x4000\n#define CF_FORCEFONTEXIST\t0x10000\n#define CF_INITTOLOGFONTSTRUCT\t64\n#define CF_LIMITSIZE\t0x2000\n#define CF_NOOEMFONTS\t0x800\n#define CF_NOFACESEL\t0x80000\n#define CF_NOSCRIPTSEL\t0x800000\n#define CF_NOSTYLESEL\t0x100000\n#define CF_NOSIZESEL\t0x200000\n#define CF_NOSIMULATIONS\t4096\n#define CF_NOVECTORFONTS\t0x800\n#define CF_NOVERTFONTS\t0x1000000\n#define CF_PRINTERFONTS\t2\n#define CF_SCALABLEONLY\t0x20000\n#define CF_SCREENFONTS\t1\n#define CF_SCRIPTSONLY\t0x400\n#define CF_SELECTSCRIPT\t0x400000\n#define CF_SHOWHELP\t4\n#define CF_USESTYLE\t128\n#define CF_WYSIWYG\t0x8000\n#define BOLD_FONTTYPE\t256\n#define ITALIC_FONTTYPE\t512\n#define PRINTER_FONTTYPE\t0x4000\n#define REGULAR_FONTTYPE\t0x400\n#define SCREEN_FONTTYPE\t0x2000\n#define SIMULATED_FONTTYPE\t0x8000\n#define COLOROKSTRINGW\tL\"commdlg_ColorOK\"\n#define FILEOKSTRINGW\tL\"commdlg_FileNameOK\"\n#define FINDMSGSTRINGW\tL\"commdlg_FindReplace\"\n#define HELPMSGSTRINGW\tL\"commdlg_help\"\n#define LBSELCHSTRINGW\tL\"commdlg_LBSelChangedNotify\"\n#define SETRGBSTRINGW\tL\"commdlg_SetRGBColor\"\n#define SHAREVISTRINGW\tL\"commdlg_ShareViolation\"\n#define COLOROKSTRINGA\t\"commdlg_ColorOK\"\n#define FILEOKSTRINGA\t\"commdlg_FileNameOK\"\n#define FINDMSGSTRINGA\t\"commdlg_FindReplace\"\n#define HELPMSGSTRINGA\t\"commdlg_help\"\n#define LBSELCHSTRINGA\t\"commdlg_LBSelChangedNotify\"\n#define SETRGBSTRINGA\t\"commdlg_SetRGBColor\"\n#define SHAREVISTRINGA\t\"commdlg_ShareViolation\"\n#define TBNOTIFYA NMTOOLBARA\n#define TBNOTIFYW NMTOOLBARW\n#define LPTBNOTIFYA LPNMTOOLBARA\n#define LPTBNOTIFYW LPNMTOOLBARW\n#define TBNOTIFY\tNMTOOLBAR\n#define LPTBNOTIFY\tLPNMTOOLBAR\n\n#ifdef UNICODE\n#define COLOROKSTRING COLOROKSTRINGW\n#define FILEOKSTRING FILEOKSTRINGW\n#define FINDMSGSTRING FINDMSGSTRINGW\n#define HELPMSGSTRING HELPMSGSTRINGW\n#define LBSELCHSTRING LBSELCHSTRINGW\n#define SETRGBSTRING SETRGBSTRINGW\n#define SHAREVISTRING SHAREVISTRINGW\n#define LVITEM\tLVITEMW\n#else\n#define COLOROKSTRING COLOROKSTRINGA\n#define FILEOKSTRING FILEOKSTRINGA\n#define FINDMSGSTRING FINDMSGSTRINGA\n#define HELPMSGSTRING HELPMSGSTRINGA\n#define LBSELCHSTRING LBSELCHSTRINGA\n#define SETRGBSTRING SETRGBSTRINGA\n#define SHAREVISTRING SHAREVISTRINGA\n#define LVITEM\tLVITEMA\n#endif\n\n#define CD_LBSELCHANGE\t0\n#define CD_LBSELADD\t2\n#define CD_LBSELSUB\t1\n#define CD_LBSELNOITEMS\t(-1)\n#define DN_DEFAULTPRN\t1\n#define PD_ALLPAGES\t0\n#define PD_COLLATE\t16\n#define PD_DISABLEPRINTTOFILE\t524288\n#define PD_ENABLEPRINTHOOK\t4096\n#define PD_ENABLEPRINTTEMPLATE\t16384\n#define PD_ENABLEPRINTTEMPLATEHANDLE\t65536\n#define PD_ENABLESETUPHOOK\t8192\n#define PD_ENABLESETUPTEMPLATE\t32768\n#define PD_ENABLESETUPTEMPLATEHANDLE\t131072\n#define PD_HIDEPRINTTOFILE\t1048576\n#define PD_NOPAGENUMS\t8\n#define PD_NOSELECTION\t4\n#define PD_NOWARNING\t128\n#define PD_PAGENUMS\t2\n#define PD_PRINTSETUP\t64\n#define PD_PRINTTOFILE\t32\n#define PD_RETURNDC\t256\n#define PD_RETURNDEFAULT\t1024\n#define PD_RETURNIC\t512\n#define PD_SELECTION\t1\n#define PD_SHOWHELP\t2048\n#define PD_USEDEVMODECOPIES\t262144\n#define PD_USEDEVMODECOPIESANDCOLLATE\t262144\n#define PSD_DEFAULTMINMARGINS\t0\n#define PSD_DISABLEMARGINS\t16\n#define PSD_DISABLEORIENTATION\t256\n#define PSD_DISABLEPAGEPAINTING\t524288\n#define PSD_DISABLEPAPER\t512\n#define PSD_DISABLEPRINTER\t32\n#define PSD_ENABLEPAGEPAINTHOOK\t262144\n#define PSD_ENABLEPAGESETUPHOOK\t8192\n#define PSD_ENABLEPAGESETUPTEMPLATE\t32768\n#define PSD_ENABLEPAGESETUPTEMPLATEHANDLE\t131072\n#define PSD_INHUNDREDTHSOFMILLIMETERS\t8\n#define PSD_INTHOUSANDTHSOFINCHES\t4\n#define PSD_INWININIINTLMEASURE\t0\n#define PSD_MARGINS\t2\n#define PSD_MINMARGINS\t1\n#define PSD_NOWARNING\t128\n#define PSD_RETURNDEFAULT\t1024\n#define PSD_SHOWHELP\t2048\n#define SW_OTHERUNZOOM\t4\n#define SW_OTHERZOOM\t2\n#define SW_PARENTCLOSING\t1\n#define SW_PARENTOPENING\t3\n#define AW_HOR_POSITIVE\t1\n#define AW_HOR_NEGATIVE\t2\n#define AW_VER_POSITIVE\t4\n#define AW_VER_NEGATIVE\t8\n#define AW_CENTER\t0x10\n#define AW_HIDE\t0x10000\n#define AW_ACTIVATE\t0x20000\n#define AW_SLIDE\t0x40000\n#define AW_BLEND\t0x80000\n#define VK_LBUTTON\t1\n#define VK_RBUTTON\t2\n#define VK_CANCEL\t3\n#define VK_MBUTTON\t4\n#define VK_BACK\t8\n#define VK_TAB\t9\n#define VK_CLEAR\t12\n#define VK_RETURN\t13\n#define VK_SHIFT\t16\n#define VK_CONTROL\t17\n#define VK_MENU\t18\n#define VK_PAUSE\t19\n#define VK_PRINT\t42\n#define VK_CAPITAL\t20\n#define VK_KANA\t0x15\n#define VK_HANGEUL\t0x15\n#define VK_HANGUL\t0x15\n#define VK_JUNJA\t0x17\n#define VK_FINAL\t0x18\n#define VK_HANJA\t0x19\n#define VK_KANJI\t0x19\n#define VK_CONVERT\t0x1C\n#define VK_NONCONVERT\t0x1D\n#define VK_ACCEPT\t0x1E\n#define VK_MODECHANGE\t0x1F\n#define VK_ESCAPE\t27\n#define VK_SPACE\t32\n#define VK_PRIOR\t33\n#define VK_NEXT\t34\n#define VK_END\t35\n#define VK_HOME\t36\n#define VK_LEFT\t37\n#define VK_UP\t38\n#define VK_RIGHT\t39\n#define VK_DOWN\t40\n#define VK_SELECT\t41\n#define VK_EXECUTE\t43\n#define VK_SNAPSHOT\t44\n#define VK_INSERT\t45\n#define VK_DELETE\t46\n#define VK_HELP\t47\n#define VK_0\t48\n#define VK_1\t49\n#define VK_2\t50\n#define VK_3\t51\n#define VK_4\t52\n#define VK_5\t53\n#define VK_6\t54\n#define VK_7\t55\n#define VK_8\t56\n#define VK_9\t57\n#define VK_A\t65\n#define VK_B\t66\n#define VK_C\t67\n#define VK_D\t68\n#define VK_E\t69\n#define VK_F\t70\n#define VK_G\t71\n#define VK_H\t72\n#define VK_I\t73\n#define VK_J\t74\n#define VK_K\t75\n#define VK_L\t76\n#define VK_M\t77\n#define VK_N\t78\n#define VK_O\t79\n#define VK_P\t80\n#define VK_Q\t81\n#define VK_R\t82\n#define VK_S\t83\n#define VK_T\t84\n#define VK_U\t85\n#define VK_V\t86\n#define VK_W\t87\n#define VK_X\t88\n#define VK_Y\t89\n#define VK_Z\t90\n#define VK_LWIN\t0x5B\n#define VK_RWIN\t0x5C\n#define VK_APPS\t0x5D\n#define VK_NUMPAD0\t96\n#define VK_NUMPAD1\t97\n#define VK_NUMPAD2\t98\n#define VK_NUMPAD3\t99\n#define VK_NUMPAD4\t100\n#define VK_NUMPAD5\t101\n#define VK_NUMPAD6\t102\n#define VK_NUMPAD7\t103\n#define VK_NUMPAD8\t104\n#define VK_NUMPAD9\t105\n#define VK_MULTIPLY\t106\n#define VK_ADD\t107\n#define VK_SEPARATOR\t108\n#define VK_SUBTRACT\t109\n#define VK_DECIMAL\t110\n#define VK_DIVIDE\t111\n#define VK_F1\t112\n#define VK_F2\t113\n#define VK_F3\t114\n#define VK_F4\t115\n#define VK_F5\t116\n#define VK_F6\t117\n#define VK_F7\t118\n#define VK_F8\t119\n#define VK_F9\t120\n#define VK_F10\t121\n#define VK_F11\t122\n#define VK_F12\t123\n#define VK_F13\t124\n#define VK_F14\t125\n#define VK_F15\t126\n#define VK_F16\t127\n#define VK_F17\t128\n#define VK_F18\t129\n#define VK_F19\t130\n#define VK_F20\t131\n#define VK_F21\t132\n#define VK_F22\t133\n#define VK_F23\t134\n#define VK_F24\t135\n#define VK_NUMLOCK\t144\n#define VK_SCROLL\t145\n#define VK_LSHIFT\t160\n#define VK_LCONTROL\t162\n#define VK_LMENU\t164\n#define VK_RSHIFT\t161\n#define VK_RCONTROL\t163\n#define VK_RMENU\t165\n#define VK_PROCESSKEY\t229\n#define KF_ALTDOWN\t8192\n#define KF_DLGMODE\t2048\n#define KF_EXTENDED\t256\n#define KF_MENUMODE\t4096\n#define KF_REPEAT\t16384\n#define KF_UP\t32768\n#define KL_NAMELENGTH\t9\n#define WA_ACTIVE\t1\n#define WA_CLICKACTIVE\t2\n#define WA_INACTIVE\t0\n#define PWR_CRITICALRESUME\t3\n#define PWR_SUSPENDREQUEST\t1\n#define PWR_SUSPENDRESUME\t2\n#define PWR_FAIL\t(-1)\n#define PWR_OK\t1\n#define NF_QUERY\t3\n#define NF_REQUERY\t4\n#define NFR_ANSI\t1\n#define NFR_UNICODE\t2\n#define WMSZ_BOTTOM\t6\n#define WMSZ_BOTTOMLEFT\t7\n#define WMSZ_BOTTOMRIGHT\t8\n#define WMSZ_LEFT\t1\n#define WMSZ_RIGHT\t2\n#define WMSZ_TOP\t3\n#define WMSZ_TOPLEFT\t4\n#define WMSZ_TOPRIGHT\t5\n#define WMSZ_BOTTOM 6\n#define WMSZ_BOTTOMLEFT 7\n#define WMSZ_BOTTOMRIGHT 8\n#define MA_ACTIVATE\t1\n#define MA_ACTIVATEANDEAT\t2\n#define MA_NOACTIVATE\t3\n#define MA_NOACTIVATEANDEAT\t4\n#define ICON_SMALL\t0\n#define ICON_BIG\t1\n#define SIZE_MAXHIDE\t4\n#define SIZE_MAXIMIZED\t2\n#define SIZEFULLSCREEN\t2\n#define SIZE_MAXSHOW\t3\n#define SIZE_MINIMIZED\t1\n#define SIZEICONIC\t1\n#define SIZE_RESTORED\t0\n#define SIZENORMAL\t0\n#define WVR_ALIGNTOP\t16\n#define WVR_ALIGNLEFT\t32\n#define WVR_ALIGNBOTTOM\t64\n#define WVR_ALIGNRIGHT\t128\n#define WVR_HREDRAW\t256\n#define WVR_VREDRAW\t512\n#define WVR_REDRAW\t768\n#define WVR_VALIDRECTS\t1024\n#define HTBOTTOM\t15\n#define HTBOTTOMLEFT\t16\n#define HTBOTTOMRIGHT\t17\n#define HTCAPTION\t2\n#define HTCLIENT\t1\n#define HTERROR\t(-2)\n#define HTGROWBOX\t4\n#define HTHSCROLL\t6\n#define HTLEFT\t10\n#define HTMENU\t5\n#define HTNOWHERE\t0\n#define HTREDUCE\t8\n#define HTRIGHT\t11\n#define HTSIZE\t4\n#define HTSYSMENU\t3\n#define HTTOP\t12\n#define HTTOPLEFT\t13\n#define HTTOPRIGHT\t14\n#define HTTRANSPARENT\t(-1)\n#define HTVSCROLL\t7\n#define HTZOOM\t9\n#define HTOBJECT\t19\n#define HTCLOSE\t20\n#define HTHELP\t21\n#define HTBORDER\t18\n#define HTMINBUTTON 8\n#define HTMAXBUTTON 9\n#define MK_CONTROL\t8\n#define MK_LBUTTON\t1\n#define MK_MBUTTON\t16\n#define MK_RBUTTON\t2\n#define MK_SHIFT\t4\n#define CS_BYTEALIGNCLIENT\t4096\n#define CS_BYTEALIGNWINDOW\t8192\n#define CS_KEYCVTWINDOW\t4\n#define\tCS_NOKEYCVT\t256\n#define CS_CLASSDC\t64\n#define CS_DBLCLKS\t8\n#define CS_GLOBALCLASS\t16384\n#define CS_IME\t0x10000\n#define CS_DROPSHADOW\t0x20000\n#define CS_HREDRAW\t2\n#define CS_NOCLOSE\t512\n#define CS_OWNDC\t32\n#define CS_PARENTDC\t128\n#define CS_SAVEBITS\t2048\n#define CS_VREDRAW\t1\n#define DLGWINDOWEXTRA\t30\n#define FALT\t16\n#define FCONTROL\t8\n#define FNOINVERT\t2\n#define FSHIFT\t4\n#define FVIRTKEY\t1\n#define MIIM_CHECKMARKS\t8\n#define MIIM_DATA\t32\n#define MIIM_ID\t2\n#define MIIM_STATE\t1\n#define MIIM_SUBMENU\t4\n#define MIIM_TYPE\t16\n#define MIIM_STRING\t0x040\n#define MIIM_BITMAP\t0x080\n#define MIIM_FTYPE\t0x0100\n#define MFT_BITMAP\t4\n#define MFT_MENUBARBREAK\t32\n#define MFT_MENUBREAK\t64\n#define MFT_OWNERDRAW\t256\n#define MFT_RADIOCHECK\t512\n#define MFT_RIGHTJUSTIFY\t0x4000\n#define MFT_SEPARATOR\t0x800\n#define MFT_STRING\t0\n#define MFS_CHECKED\t8\n#define MFS_DEFAULT\t4096\n#define MFS_DISABLED\t3\n#define MFS_ENABLED\t0\n#define MFS_GRAYED\t3\n#define MFS_HILITE\t128\n#define MFS_UNCHECKED\t0\n#define MFS_UNHILITE\t0\n#define SERKF_AVAILABLE\t2\n#define SERKF_INDICATOR\t4\n#define SERKF_SERIALKEYSON\t1\n#define FKF_AVAILABLE\t2\n#define FKF_CLICKON\t64\n#define FKF_FILTERKEYSON\t1\n#define FKF_HOTKEYACTIVE\t4\n#define FKF_HOTKEYSOUND\t16\n#define FKF_CONFIRMHOTKEY\t8\n#define FKF_INDICATOR\t32\n#define HELPINFO_MENUITEM\t2\n#define HELPINFO_WINDOW\t1\n#define PRF_CHECKVISIBLE\t1\n#define PRF_CHILDREN\t16\n#define PRF_CLIENT\t4\n#define PRF_ERASEBKGND\t8\n#define PRF_NONCLIENT\t2\n#define PRF_OWNED\t32\n#define HWND_DESKTOP\t(HWND)0\n#define SC_CLOSE\t61536\n#define SC_CONTEXTHELP\t61824\n#define SC_DEFAULT\t61792\n#define SC_HOTKEY\t61776\n#define SC_HSCROLL\t61568\n#define SC_KEYMENU\t61696\n#define SC_MAXIMIZE\t61488\n#define SC_ZOOM\t61488\n#define SC_MINIMIZE\t61472\n#define SC_ICON\t61472\n#define SC_MONITORPOWER\t61808\n#define SC_MOUSEMENU\t61584\n#define SC_MOVE\t61456\n#define SC_NEXTWINDOW\t61504\n#define SC_PREVWINDOW\t61520\n#define SC_RESTORE\t61728\n#define SC_SCREENSAVE\t61760\n#define SC_SIZE\t61440\n#define SC_TASKLIST\t61744\n#define SC_VSCROLL\t61552\n#define SC_ARRANGE\t61712\n#define DC_HASDEFID\t21323\n#define DLGC_BUTTON\t8192\n#define DLGC_DEFPUSHBUTTON\t16\n#define DLGC_HASSETSEL\t8\n#define DLGC_RADIOBUTTON\t64\n#define DLGC_STATIC\t256\n#define DLGC_UNDEFPUSHBUTTON\t32\n#define DLGC_WANTALLKEYS\t4\n#define DLGC_WANTARROWS\t1\n#define DLGC_WANTCHARS\t128\n#define DLGC_WANTMESSAGE\t4\n#define DLGC_WANTTAB\t2\n#define EC_LEFTMARGIN\t1\n#define EC_RIGHTMARGIN\t2\n#define EC_USEFONTINFO\t65535\n#define LB_ERR\t(-1)\n#define LB_ERRSPACE\t(-2)\n#define CB_ERR\t(-1)\n#define CB_ERRSPACE\t(-2)\n#define SKF_AUDIBLEFEEDBACK\t64\n#define SKF_AVAILABLE\t2\n#define SKF_CONFIRMHOTKEY\t8\n#define SKF_HOTKEYACTIVE\t4\n#define SKF_HOTKEYSOUND\t16\n#define SKF_INDICATOR\t32\n#define SKF_STICKYKEYSON\t1\n#define SKF_TRISTATE\t128\n#define SKF_TWOKEYSOFF\t256\n#define MKF_AVAILABLE\t2\n#define MKF_CONFIRMHOTKEY\t8\n#define MKF_HOTKEYACTIVE\t4\n#define MKF_HOTKEYSOUND\t16\n#define MKF_INDICATOR\t32\n#define MKF_MOUSEKEYSON\t1\n#define MKF_MODIFIERS\t64\n#define MKF_REPLACENUMBERS\t128\n#define SSF_AVAILABLE\t2\n#define SSF_SOUNDSENTRYON\t1\n#define SSTF_BORDER\t2\n#define SSTF_CHARS\t1\n#define SSTF_DISPLAY\t3\n#define SSTF_NONE\t0\n#define SSGF_DISPLAY\t3\n#define SSGF_NONE\t0\n#define SSWF_CUSTOM\t4\n#define SSWF_DISPLAY\t3\n#define SSWF_NONE\t0\n#define SSWF_TITLE\t1\n#define SSWF_WINDOW\t2\n#define ATF_ONOFFFEEDBACK\t2\n#define ATF_TIMEOUTON\t1\n#define HCF_AVAILABLE\t2\n#define HCF_CONFIRMHOTKEY\t8\n#define HCF_HIGHCONTRASTON\t1\n#define HCF_HOTKEYACTIVE\t4\n#define HCF_HOTKEYAVAILABLE\t64\n#define HCF_HOTKEYSOUND\t16\n#define HCF_INDICATOR\t32\n#define TKF_AVAILABLE\t2\n#define TKF_CONFIRMHOTKEY\t8\n#define TKF_HOTKEYACTIVE\t4\n#define TKF_HOTKEYSOUND\t16\n#define TKF_TOGGLEKEYSON\t1\n#define PP_DISPLAYERRORS\t1\n#define RESOURCEDISPLAYTYPE_DOMAIN\t1\n#define RESOURCEDISPLAYTYPE_FILE\t4\n#define RESOURCEDISPLAYTYPE_GENERIC\t0\n#define RESOURCEDISPLAYTYPE_GROUP\t5\n#define RESOURCEDISPLAYTYPE_SERVER\t2\n#define RESOURCEDISPLAYTYPE_SHARE\t3\n#define CAPSLOCK_ON\t128\n#define ENHANCED_KEY\t256\n#define LEFT_ALT_PRESSED\t2\n#define LEFT_CTRL_PRESSED\t8\n#define NUMLOCK_ON\t32\n#define RIGHT_ALT_PRESSED\t1\n#define RIGHT_CTRL_PRESSED\t4\n#define SCROLLLOCK_ON\t64\n#define SHIFT_PRESSED\t16\n#define FROM_LEFT_1ST_BUTTON_PRESSED\t1\n#define RIGHTMOST_BUTTON_PRESSED\t2\n#define FROM_LEFT_2ND_BUTTON_PRESSED\t4\n#define FROM_LEFT_3RD_BUTTON_PRESSED\t8\n#define FROM_LEFT_4TH_BUTTON_PRESSED\t16\n#define DOUBLE_CLICK\t2\n#define MOUSE_MOVED\t1\n#define KEY_EVENT\t1\n#define MOUSE_EVENT\t2\n#define WINDOW_BUFFER_SIZE_EVENT\t4\n#define MENU_EVENT\t8\n#define FOCUS_EVENT\t16\n#define BI_RGB 0\n#define BI_RLE8 1\n#define BI_RLE4 2\n#define BI_BITFIELDS 3\n#define BI_JPEG 4\n#define BI_PNG 5\n#define HFILE_ERROR ((HFILE)-1)\n#define CONTEXT_i386 0x10000\n#define CONTEXT_i486 0x10000\n#define CONTEXT_CONTROL (CONTEXT_i386 | 1)\n#define CONTEXT_INTEGER (CONTEXT_i386 | 2)\n#define CONTEXT_SEGMENTS (CONTEXT_i386 | 4)\n#define CONTEXT_FLOATING_POINT (CONTEXT_i386 | 8)\n#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386|0x10)\n#define CONTEXT_EXTENDED_REGISTERS (CONTEXT_i386 | 0x00000020L)\n#define CONTEXT_FULL (CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_SEGMENTS)\n#define MAX_MODULE_NAME32 255\n#define TH32CS_SNAPHEAPLIST 1\n#define TH32CS_SNAPPROCESS 2\n#define TH32CS_SNAPTHREAD 4\n#define TH32CS_SNAPMODULE 8\n#define TH32CS_SNAPALL (TH32CS_SNAPHEAPLIST|TH32CS_SNAPPROCESS|TH32CS_SNAPTHREAD|TH32CS_SNAPMODULE)\n#define TH32CS_INHERIT 0x80000000\n#define HF32_DEFAULT 1\n#define HF32_SHARED 2\n#define LF32_FIXED 1\n#define LF32_FREE 2\n#define LF32_MOVEABLE 4\n#define UnlockResource(r) ((r),0)\n#define METHOD_BUFFERED 0\n#define METHOD_IN_DIRECT 1\n#define METHOD_OUT_DIRECT 2\n#define METHOD_NEITHER 3\n#define FILE_ANY_ACCESS 0\n#define FILE_READ_ACCESS 1\n#define FILE_WRITE_ACCESS 2\n#define TMPF_FIXED_PITCH 1\n#define TMPF_VECTOR 2\n#define TMPF_DEVICE 8\n#define TMPF_TRUETYPE 4\n#define NTM_REGULAR 0x40\n#define NTM_BOLD 0x20\n#define NTM_ITALIC 1\n#define NTM_NONNEGATIVE_AC\t0x00010000\n#define NTM_PS_OPENTYPE\t0x00020000\n#define NTM_TT_OPENTYPE\t0x00040000\n#define NTM_MULTIPLEMASTER\t0x00080000\n#define NTM_TYPE1\t0x00100000\n#define NTM_DSIG\t0x00200000\n#define META_ANIMATEPALETTE\t0x436\n#define META_ARC\t0x817\n#define META_BITBLT\t0x922\n#define META_CHORD\t0x830\n#define META_CREATEBRUSHINDIRECT\t0x2FC\n#define META_CREATEFONTINDIRECT\t0x2FB\n#define META_CREATEPALETTE\t0xf7\n#define META_CREATEPATTERNBRUSH\t0x1F9\n#define META_CREATEPENINDIRECT\t0x2FA\n#define META_CREATEREGION\t0x6FF\n#define META_DELETEOBJECT\t0x1f0\n#define META_DIBBITBLT\t0x940\n#define META_DIBCREATEPATTERNBRUSH\t0x142\n#define META_DIBSTRETCHBLT\t0xb41\n#define META_ELLIPSE\t0x418\n#define META_ESCAPE\t0x626\n#define META_EXCLUDECLIPRECT\t0x415\n#define META_EXTFLOODFILL\t0x548\n#define META_EXTTEXTOUT\t0xa32\n#define META_FILLREGION\t0x228\n#define META_FLOODFILL\t0x419\n#define META_FRAMEREGION\t0x429\n#define META_INTERSECTCLIPRECT\t0x416\n#define META_INVERTREGION\t0x12A\n#define META_LINETO\t0x213\n#define META_MOVETO\t0x214\n#define META_OFFSETCLIPRGN\t0x220\n#define META_OFFSETVIEWPORTORG\t0x211\n#define META_OFFSETWINDOWORG\t0x20F\n#define META_PAINTREGION\t0x12B\n#define META_PATBLT\t0x61D\n#define META_PIE\t0x81A\n#define META_POLYGON\t0x324\n#define META_POLYLINE\t0x325\n#define META_POLYPOLYGON\t0x538\n#define META_REALIZEPALETTE\t0x35\n#define META_RECTANGLE\t0x41B\n#define META_RESIZEPALETTE\t0x139\n#define META_RESTOREDC\t0x127\n#define META_ROUNDRECT\t0x61C\n#define META_SAVEDC\t0x1E\n#define META_SCALEVIEWPORTEXT\t0x412\n#define META_SCALEWINDOWEXT\t0x410\n#define META_SELECTCLIPREGION\t0x12C\n#define META_SELECTOBJECT\t0x12D\n#define META_SELECTPALETTE\t0x234\n#define META_SETBKCOLOR\t0x201\n#define META_SETBKMODE\t0x102\n#define META_SETDIBTODEV\t0xd33\n#define META_SETMAPMODE\t0x103\n#define META_SETMAPPERFLAGS\t0x231\n#define META_SETPALENTRIES\t0x37\n#define META_SETPIXEL\t0x41F\n#define META_SETPOLYFILLMODE\t0x106\n#define META_SETRELABS\t0x105\n#define META_SETROP2\t0x104\n#define META_SETSTRETCHBLTMODE\t0x107\n#define META_SETTEXTALIGN\t0x12E\n#define META_SETTEXTCHAREXTRA\t0x108\n#define META_SETTEXTCOLOR\t0x209\n#define META_SETTEXTJUSTIFICATION\t0x20A\n#define META_SETVIEWPORTEXT\t0x20E\n#define META_SETVIEWPORTORG\t0x20D\n#define META_SETWINDOWEXT\t0x20C\n#define META_SETWINDOWORG\t0x20B\n#define META_STRETCHBLT\t0xB23\n#define META_STRETCHDIB\t0xf43\n#define META_TEXTOUT\t0x521\n#define PFD_DOUBLEBUFFER 1\n#define PFD_STEREO 2\n#define PFD_DRAW_TO_WINDOW 4\n#define PFD_DRAW_TO_BITMAP 8\n#define PFD_SUPPORT_GDI 0x10\n#define PFD_SUPPORT_OPENGL 0x20\n#define PFD_GENERIC_FORMAT 0x40\n#define PFD_NEED_PALETTE 0x80\n#define PFD_NEED_SYSTEM_PALETTE 0x100\n#define PFD_SWAP_EXCHANGE 0x200\n#define PFD_SWAP_COPY 0x400\n#define PFD_SWAP_LAYER_BUFFERS 0x800\n#define PFD_GENERIC_ACCELERATED\t0x1000\n#define PFD_TYPE_RGBA 0\n#define PFD_TYPE_COLORINDEX 1\n#define PFD_MAIN_PLANE 0\n#define PFD_OVERLAY_PLANE 1\n#define PFD_UNDERLAY_PLANE (-1)\n#define QDI_SETDIBITS\t1\n#define QDI_GETDIBITS\t2\n#define QDI_DIBTOSCREEN\t4\n#define QDI_STRETCHDIB\t8\n#define RAS_MaxDeviceType\t16\n#define RAS_MaxPhoneNumber\t128\n#define RAS_MaxIpAddress\t15\n#define RAS_MaxIpxAddress\t21\n#define RAS_MaxEntryName\t256\n#define RAS_MaxDeviceName\t128\n#define RAS_MaxAreaCode\t10\n#define RAS_MaxPadType\t32\n#define RAS_MaxX25Address\t200\n#define RAS_MaxFacilities\t200\n#define RAS_MaxUserData\t200\n#define TME_HOVER 1\n#define TME_LEAVE 2\n#define TME_NONCLIENT 16\n#define TME_QUERY\t0x40000000\n#define TME_CANCEL\t0x80000000\n#define HOVER_DEFAULT 0xFFFFFFFF\n#define\tGA_PARENT\t1\n#define\tGA_ROOT\t2\n#define\tGA_ROOTOWNER\t3\n#define CBEIF_TEXT\t1\n#define CBEIF_IMAGE\t2\n#define CBEIF_SELECTEDIMAGE\t4\n#define CBEIF_OVERLAY\t8\n#define CBEIF_INDENT\t16\n#define CBEIF_LPARAM\t32\n#define CBEIF_DI_SETITEM\t0x10000000\n#define HW_PROFILE_GUIDLEN 39\n#define MAX_PROFILE_LEN\t80\n#define DOCKINFO_UNDOCKED\t1\n#define DOCKINFO_DOCKED\t2\n#define DOCKINFO_USER_SUPPLIED\t4\n#define DOCKINFO_USER_UNDOCKED (DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED)\n#define DOCKINFO_USER_DOCKED (DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED)\n#define FIND_FIRST_EX_CASE_SENSITIVE 1\n#define ALL_TRANSPORTS \"M\\0\\0\\0\"\n#define MS_NBF \"MNBF\"\n#define NCBCALL 0x10\n#define NCBLISTEN 0x11\n#define NCBHANGUP 0x12\n#define NCBSEND 0x14\n#define NCBRECV 0x15\n#define NCBRECVANY 0x16\n#define NCBCHAINSEND 0x17\n#define NCBDGSEND 0x20\n#define NCBDGRECV 0x21\n#define NCBDGSENDBC 0x22\n#define NCBDGRECVBC 0x23\n#define NCBADDNAME 0x30\n#define NCBDELNAME 0x31\n#define NCBRESET 0x32\n#define NCBASTAT 0x33\n#define NCBSSTAT 0x34\n#define NCBCANCEL 0x35\n#define NCBADDGRNAME 0x36\n#define NCBENUM 0x37\n#define NCBUNLINK 0x70\n#define NCBSENDNA 0x71\n#define NCBCHAINSENDNA 0x72\n#define NCBLANSTALERT 0x73\n#define NCBACTION 0x77\n#define NCBFINDNAME 0x78\n#define NCBTRACE 0x79\n#define ASYNCH 0x80\n#define NRC_GOODRET 0x00\n#define NRC_BUFLEN 0x01\n#define NRC_ILLCMD 0x03\n#define NRC_CMDTMO 0x05\n#define NRC_INCOMP 0x06\n#define NRC_BADDR 0x07\n#define NRC_SNUMOUT 0x08\n#define NRC_NORES 0x09\n#define NRC_SCLOSED 0x0a\n#define NRC_CMDCAN 0x0b\n#define NRC_DUPNAME 0x0d\n#define NRC_NAMTFUL 0x0e\n#define NRC_ACTSES 0x0f\n#define NRC_LOCTFUL 0x11\n#define NRC_REMTFUL 0x12\n#define NRC_ILLNN 0x13\n#define NRC_NOCALL 0x14\n#define NRC_NOWILD 0x15\n#define NRC_INUSE 0x16\n#define NRC_NAMERR 0x17\n#define NRC_SABORT 0x18\n#define NRC_NAMCONF 0x19\n#define NRC_IFBUSY 0x21\n#define NRC_TOOMANY 0x22\n#define NRC_BRIDGE 0x23\n#define NRC_CANOCCR 0x24\n#define NRC_CANCEL 0x26\n#define NRC_DUPENV 0x30\n#define NRC_ENVNOTDEF 0x34\n#define NRC_OSRESNOTAV 0x35\n#define NRC_MAXAPPS 0x36\n#define NRC_NOSAPS 0x37\n#define NRC_NORESOURCES 0x38\n#define NRC_INVADDRESS 0x39\n#define NRC_INVDDID 0x3B\n#define NRC_LOCKFAIL 0x3C\n#define NRC_OPENERR 0x3f\n#define NRC_SYSTEM 0x40\n#define NRC_PENDING 0xff\n#define NCB_POST void CALLBACK\n#define ACL_REVISION\t2\n#define ACL_REVISION_DS\t4\n#define ACL_REVISION1\t1\n#define MIN_ACL_REVISION ACL_REVISION2\n#define ACL_REVISION2\t2\n#define ACL_REVISION3\t3\n#define ACL_REVISION4\t4\n#define MAX_ACL_REVISION ACL_REVISION4\n#define CONTAINING_RECORD(a,t,f) ((t *)((PCHAR)(a) - (ULONG_PTR)(&((t *)0)->f)))\n#define LOGON32_LOGON_INTERACTIVE\t2\n#define LOGON32_LOGON_NETWORK\t3\n#define LOGON32_LOGON_BATCH\t4\n#define LOGON32_LOGON_SERVICE\t5\n#define LOGON32_LOGON_UNLOCK\t7\n#define LOGON32_LOGON_NETWORK_CLEARTEXT 8\n#define LOGON32_LOGON_NEW_CREDENTIALS 9\n#define LOGON32_PROVIDER_DEFAULT\t0\n#define LOGON32_PROVIDER_WINNT35\t1\n#define LOGON32_PROVIDER_WINNT40\t2\n#define LOGON32_PROVIDER_WINNT50\t3\n#define LOGON_WITH_PROFILE\t1\n#define LOGON_NETCREDENTIALS_ONLY\t2\n#define LOGON_ZERO_PASSWORD_BUFFER\t0x80000000\n#define WINEVENT_OUTOFCONTEXT\t0\n#define WINEVENT_SKIPOWNTHREAD\t1\n#define WINEVENT_SKIPOWNPROCESS\t2\n#define WINEVENT_INCONTEXT\t4\n#define GetKValue(cmyk)\t((BYTE)(cmyk))\n#define GetYValue(cmyk)\t((BYTE)((cmyk)>> 8))\n#define GetMValue(cmyk)\t((BYTE)((cmyk)>>16))\n#define GetCValue(cmyk)\t((BYTE)((cmyk)>>24))\n#define GR_GDIOBJECTS\t0\n#define GR_USEROBJECTS\t1\n#define ENUM_CURRENT_SETTINGS ((DWORD)-1)\n#define ENUM_REGISTRY_SETTINGS ((DWORD)-2)\n#define NFS_EDIT\t1\n#define NFS_STATIC\t2\n#define NFS_LISTCOMBO\t4\n#define NFS_BUTTON\t8\n#define NFS_ALL\t0x10\n#define NFS_USEFONTASSOC\t0x20\n#define ENDSESSION_LOGOFF\t0x80000000\n#define GET_RAWINPUT_CODE_WPARAM(wParam)\t((wParam)&0xff)\n#define RIM_INPUT\t0\n#define RIM_INPUTSINK\t1\n#define RIM_TYPEMOUSE\t0\n#define RIM_TYPEKEYBOARD\t1\n#define RIM_TYPEHID\t2\n#define RI_MOUSE_LEFT_BUTTON_DOWN\t1\n#define RI_MOUSE_LEFT_BUTTON_UP\t2\n#define RI_MOUSE_RIGHT_BUTTON_DOWN\t4\n#define RI_MOUSE_RIGHT_BUTTON_UP\t8\n#define RI_MOUSE_MIDDLE_BUTTON_DOWN\t16\n#define RI_MOUSE_MIDDLE_BUTTON_UP\t0x20\n#define RI_MOUSE_BUTTON_1_DOWN\tRI_MOUSE_LEFT_BUTTON_DOWN\n#define RI_MOUSE_BUTTON_1_UP\tRI_MOUSE_LEFT_BUTTON_UP\n#define RI_MOUSE_BUTTON_2_DOWN\tRI_MOUSE_RIGHT_BUTTON_DOWN\n#define RI_MOUSE_BUTTON_2_UP\tRI_MOUSE_RIGHT_BUTTON_UP\n#define RI_MOUSE_BUTTON_3_DOWN\tRI_MOUSE_MIDDLE_BUTTON_DOWN\n#define RI_MOUSE_BUTTON_3_UP\tRI_MOUSE_MIDDLE_BUTTON_UP\n#define RI_MOUSE_BUTTON_4_DOWN\t0x0040\n#define RI_MOUSE_BUTTON_4_UP\t0x0080\n#define RI_MOUSE_BUTTON_5_DOWN\t0x0100\n#define RI_MOUSE_BUTTON_5_UP\t0x0200\n#define RI_MOUSE_WHEEL\t0x0400\n#define MOUSE_MOVE_RELATIVE\t0\n#define MOUSE_MOVE_ABSOLUTE\t1\n#define MOUSE_VIRTUAL_DESKTOP\t2\n#define MOUSE_ATTRIBUTES_CHANGED 4\n#define KEYBOARD_OVERRUN_MAKE_CODE\t0xFF\n#define RI_KEY_MAKE\t0\n#define RI_KEY_BREAK\t1\n#define RI_KEY_E0\t2\n#define RI_KEY_E1\t4\n#define RI_KEY_TERMSRV_SET_LED\t8\n#define RI_KEY_TERMSRV_SHADOW\t0x10\n#define RAWINPUT_ALIGN(x)\t(((x) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))\n#define NEXTRAWINPUTBLOCK(ptr) ((PRAWINPUT)RAWINPUT_ALIGN((ULONG_PTR)((PBYTE)(ptr) + (ptr)->header.dwSize)))\n#define RID_INPUT\t0x10000003\n#define RID_HEADER\t0x10000005\n#define RIDI_PREPARSEDDATA\t0x20000005\n#define RIDI_DEVICENAME\t0x20000007\n#define RIDI_DEVICEINFO\t0x2000000b\n#define RIDEV_REMOVE\t1\n#define RIDEV_EXCLUDE\t0x10\n#define RIDEV_PAGEONLY\t0x20\n#define RIDEV_NOLEGACY\t0x30\n#define RIDEV_CAPTUREMOUSE\t0x200\n#define RIDEV_NOHOTKEYS\t0x200\n#define RIDEV_EXMODEMASK\t0x0F0\n#define RIDEV_EXMODE(mode) ((mode)&RIDEV_EXMODEMASK)\n#define WTS_CONSOLE_CONNECT\t0x1\n#define WTS_CONSOLE_DISCONNECT\t0x2\n#define WTS_REMOTE_CONNECT\t0x3\n#define WTS_REMOTE_DISCONNECT\t0x4\n#define WTS_SESSION_LOGON\t0x5\n#define WTS_SESSION_LOGOFF\t0x6\n#define WTS_SESSION_LOCK\t0x7\n#define WTS_SESSION_UNLOCK\t0x8\n#define APPCOMMAND_BROWSER_BACKWARD 1\n#define APPCOMMAND_BROWSER_FORWARD 2\n#define APPCOMMAND_BROWSER_REFRESH 3\n#define APPCOMMAND_BROWSER_STOP 4\n#define APPCOMMAND_BROWSER_SEARCH 5\n#define APPCOMMAND_BROWSER_FAVORITES 6\n#define APPCOMMAND_BROWSER_HOME 7\n#define APPCOMMAND_VOLUME_MUTE 8\n#define APPCOMMAND_VOLUME_DOWN 9\n#define APPCOMMAND_VOLUME_UP 10\n#define APPCOMMAND_MEDIA_NEXTTRACK 11\n#define APPCOMMAND_MEDIA_PREVIOUSTRACK 12\n#define APPCOMMAND_MEDIA_STOP 13\n#define APPCOMMAND_MEDIA_PLAY_PAUSE 14\n#define APPCOMMAND_LAUNCH_MAIL 15\n#define APPCOMMAND_LAUNCH_MEDIA_SELECT 16\n#define APPCOMMAND_LAUNCH_APP1 17\n#define APPCOMMAND_LAUNCH_APP2 18\n#define APPCOMMAND_BASS_DOWN 19\n#define APPCOMMAND_BASS_BOOST 20\n#define APPCOMMAND_BASS_UP 21\n#define APPCOMMAND_TREBLE_DOWN 22\n#define APPCOMMAND_TREBLE_UP 23\n#define APPCOMMAND_MICROPHONE_VOLUME_MUTE 24\n#define APPCOMMAND_MICROPHONE_VOLUME_DOWN 25\n#define APPCOMMAND_MICROPHONE_VOLUME_UP 26\n#define APPCOMMAND_HELP 27\n#define APPCOMMAND_FIND 28\n#define APPCOMMAND_NEW 29\n#define APPCOMMAND_OPEN 30\n#define APPCOMMAND_CLOSE 31\n#define APPCOMMAND_SAVE 32\n#define APPCOMMAND_PRINT 33\n#define APPCOMMAND_UNDO 34\n#define APPCOMMAND_REDO 35\n#define APPCOMMAND_COPY 36\n#define APPCOMMAND_CUT 37\n#define APPCOMMAND_PASTE 38\n#define APPCOMMAND_REPLY_TO_MAIL 39\n#define APPCOMMAND_FORWARD_MAIL 40\n#define APPCOMMAND_SEND_MAIL 41\n#define APPCOMMAND_SPELL_CHECK 42\n#define APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE 43\n#define APPCOMMAND_MIC_ON_OFF_TOGGLE 44\n#define APPCOMMAND_CORRECTION_LIST 45\n#define FAPPCOMMAND_MOUSE 0x8000\n#define FAPPCOMMAND_KEY 0\n#define FAPPCOMMAND_OEM 0x1000\n#define FAPPCOMMAND_MASK 0xF000\n#define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))\n#define GET_DEVICE_LPARAM(lParam) ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK))\n#define GET_MOUSEORKEY_LPARAM GET_DEVICE_LPARAM\n#define GET_FLAGS_LPARAM(lParam) (LOWORD(lParam))\n#define GET_KEYSTATE_LPARAM(lParam) GET_FLAGS_LPARAM(lParam)\n#define UISF_HIDEFOCUS\t1\n#define UISF_HIDEACCEL\t2\n#define UISF_ACTIVE\t4\n#define UIS_SET\t1\n#define UIS_CLEAR\t2\n#define UIS_INITIALIZE\t3\n#define FLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)\n#define TLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)\n#define META_SETLAYOUT 0x0149\n#define MSGF_MESSAGEBOX 1\n#define MSGF_MAX 8\n#define ACCESS_STICKYKEYS 1\n#define ACCESS_FILTERKEYS 2\n#define ACCESS_MOUSEKEYS 3\n#define LLKHF_EXTENDED (KF_EXTENDED >> 8)\n#define LLKHF_INJECTED 0x00000010\n#define LLKHF_ALTDOWN (KF_ALTDOWN >> 8)\n#define LLKHF_UP (KF_UP >> 8)\n#define LLMHF_INJECTED 1\n#define ACCESS_OBJECT_GUID\t0\n#define ACCESS_PROPERTY_SET_GUID 1\n#define ACCESS_PROPERTY_GUID\t2\n#define ACCESS_MAX_LEVEL\t4\n#define VER_NT_WORKSTATION\t1\n#define VER_NT_DOMAIN_CONTROLLER\t2\n#define VER_NT_SERVER\t3\n#define VER_SERVER_NT\t0x80000000\n#define VER_WORKSTATION_NT\t0x40000000\n#define VER_SUITE_SMALLBUSINESS\t1\n#define VER_SUITE_ENTERPRISE\t2\n#define VER_SUITE_BACKOFFICE\t4\n#define VER_SUITE_COMMUNICATIONS 8\n#define VER_SUITE_TERMINAL\t0x10\n#define VER_SUITE_SMALLBUSINESS_RESTRICTED 0x20\n#define VER_SUITE_EMBEDDEDNT\t0x40\n#define VER_SUITE_DATACENTER\t0x80\n#define VER_SUITE_SINGLEUSERTS\t0x100\n#define VER_SUITE_PERSONAL\t0x200\n#define VER_SUITE_BLADE\t0x400\n#define VER_SUITE_EMBEDDED_RESTRICTED\t0x800\n#define VER_SUITE_SECURITY_APPLIANCE 0x1000\n#define AC_LINE_OFFLINE\t0\n#define AC_LINE_ONLINE\t1\n#define AC_LINE_BACKUP_POWER\t2\n#define AC_LINE_UNKNOWN\t0xFF\n#define BATTERY_FLAG_HIGH\t1\n#define BATTERY_FLAG_LOW\t2\n#define BATTERY_FLAG_CRITICAL\t4\n#define BATTERY_FLAG_CHARGING\t8\n#define BATTERY_FLAG_NO_BATTERY\t0x80\n#define BATTERY_FLAG_UNKNOWN\t0xFF\n#define BATTERY_PERCENTAGE_UNKNOWN\t0xFF\n#define BATTERY_LIFE_UNKNOWN\t0xFFFFFFFF\n#define JOB_OBJECT_MSG_END_OF_JOB_TIME 1\n#define JOB_OBJECT_MSG_END_OF_PROCESS_TIME 2\n#define JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT 3\n#define JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO 4\n#define JOB_OBJECT_MSG_NEW_PROCESS 6\n#define JOB_OBJECT_MSG_EXIT_PROCESS 7\n#define JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS 8\n#define JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT 9\n#define JOB_OBJECT_MSG_JOB_MEMORY_LIMIT 10\n#define JOB_OBJECT_LIMIT_WORKINGSET\t1\n#define JOB_OBJECT_LIMIT_PROCESS_TIME\t2\n#define JOB_OBJECT_LIMIT_JOB_TIME\t4\n#define JOB_OBJECT_LIMIT_ACTIVE_PROCESS\t8\n#define JOB_OBJECT_LIMIT_AFFINITY\t0x10\n#define JOB_OBJECT_LIMIT_PRIORITY_CLASS\t0x20\n#define JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME 0x40\n#define JOB_OBJECT_LIMIT_SCHEDULING_CLASS\t0x80\n#define JOB_OBJECT_LIMIT_PROCESS_MEMORY\t0x100\n#define JOB_OBJECT_LIMIT_JOB_MEMORY\t0x200\n#define JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION 0x400\n#define JOB_OBJECT_LIMIT_BREAKAWAY_OK\t0x800\n#define JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK\t0x1000\n#define JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE\t0x2000\n#define JOB_OBJECT_LIMIT_RESERVED2 0x4000\n#define JOB_OBJECT_LIMIT_RESERVED3 0x8000\n#define JOB_OBJECT_LIMIT_RESERVED4 0x10000\n#define JOB_OBJECT_LIMIT_RESERVED5 0x20000\n#define JOB_OBJECT_LIMIT_RESERVED6 0x40000\n#define JOB_OBJECT_LIMIT_VALID_FLAGS\t0x7ffff\n#define JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS 0x0ff\n#define JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS 0x003fff\n#define JOB_OBJECT_RESERVED_LIMIT_VALID_FLAGS 0x07ffff\n#define JOB_OBJECT_UILIMIT_NONE\t0\n#define JOB_OBJECT_UILIMIT_HANDLES\t1\n#define JOB_OBJECT_UILIMIT_READCLIPBOARD\t2\n#define JOB_OBJECT_UILIMIT_WRITECLIPBOARD\t4\n#define JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS\t8\n#define JOB_OBJECT_UILIMIT_DISPLAYSETTINGS\t0x10\n#define JOB_OBJECT_UILIMIT_GLOBALATOMS\t0x20\n#define JOB_OBJECT_UILIMIT_DESKTOP\t0x40\n#define JOB_OBJECT_UILIMIT_EXITWINDOWS\t0x80\n#define JOB_OBJECT_UILIMIT_ALL\t0xFF\n#define JOB_OBJECT_UI_VALID_FLAGS 0xFF\n#define JOB_OBJECT_SECURITY_NO_ADMIN\t1\n#define JOB_OBJECT_SECURITY_RESTRICTED_TOKEN\t2\n#define JOB_OBJECT_SECURITY_ONLY_TOKEN\t4\n#define JOB_OBJECT_SECURITY_FILTER_TOKENS\t8\n#define JOB_OBJECT_SECURITY_VALID_FLAGS\t0xf\n#define SEF_DACL_AUTO_INHERIT\t1\n#define SEF_SACL_AUTO_INHERIT\t2\n#define SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT\t4\n#define SEF_AVOID_PRIVILEGE_CHECK\t8\n#define SEF_AVOID_OWNER_CHECK\t0x10\n#define SEF_DEFAULT_OWNER_FROM_PARENT\t0x20\n#define SEF_DEFAULT_GROUP_FROM_PARENT\t0x40\n#define MIM_MAXHEIGHT 1\n#define MIM_BACKGROUND 2\n#define MIM_HELPID 4\n#define MIM_MENUDATA 8\n#define MIM_STYLE 0x10\n#define MIM_APPLYTOSUBMENUS 0x80000000\n#define MNS_NOCHECK 0x80000000\n#define MNS_MODELESS 0x40000000\n#define MNS_DRAGDROP 0x20000000\n#define MNS_AUTODISMISS 0x10000000\n#define MNS_NOTIFYBYPOS 0x8000000\n#define MNS_CHECKORBMP 0x4000000\n#define QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX 4\n#define QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE 8\n#define QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS 0x10\n#define QUERY_ACTCTX_FLAG_NO_ADDREF 0x80000000\n#define EVENTLOG_FULL_INFO 0\n//#if (_WIN32_IE >= 0x0300)\n#define LPTV_HITTESTINFO\tLPTVHITTESTINFO\n#define TV_HITTESTINFO\tTVHITTESTINFO\n//#else\n//#define tagTVHITTESTINFO\t_TV_HITTESTINFO\n//#define TVHITTESTINFO\tTV_HITTESTINFO\n//#define LPTVHITTESTINFO\tLPTV_HITTESTINFO\n//#endif\n#define LWA_COLORKEY\t1\n#define LWA_ALPHA\t2\n#define ULW_COLORKEY\t1\n#define ULW_ALPHA\t2\n#define ULW_OPAQUE\t4\n#define ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID 1\n#define ACTCTX_FLAG_LANGID_VALID 2\n#define ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID 4\n#define ACTCTX_FLAG_RESOURCE_NAME_VALID 8\n#define ACTCTX_FLAG_SET_PROCESS_DEFAULT 0x10\n#define ACTCTX_FLAG_APPLICATION_NAME_VALID 0x20\n#define ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF 0x040\n#define ACTCTX_FLAG_HMODULE_VALID 0x080\n#define TIME_ZONE_ID_INVALID ((DWORD)0xFFFFFFFF)\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A \"GetSystemWow64DirectoryA\"\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W L\"GetSystemWow64DirectoryA\"\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T TEXT(\"GetSystemWow64DirectoryA\")\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A \"GetSystemWow64DirectoryW\"\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W L\"GetSystemWow64DirectoryW\"\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T TEXT(\"GetSystemWow64DirectoryW\")\n#define HEAP_NO_SERIALIZE\t1\n#define HEAP_GROWABLE\t2\n#define HEAP_GENERATE_EXCEPTIONS\t4\n#define HEAP_ZERO_MEMORY\t8\n#define HEAP_REALLOC_IN_PLACE_ONLY\t0x10\n#define HEAP_TAIL_CHECKING_ENABLED\t0x020\n#define HEAP_FREE_CHECKING_ENABLED\t0x040\n#define HEAP_DISABLE_COALESCE_ON_FREE\t0x080\n#define HEAP_CREATE_ALIGN_16\t0x010000\n#define HEAP_CREATE_ENABLE_TRACING\t0x00020000\n#define HEAP_CREATE_ENABLE_EXECUTE\t0x00040000\n#define HEAP_MAXIMUM_TAG\t0x0FFF\n#define HEAP_PSEUDO_TAG_FLAG 0x8000\n#define HEAP_TAG_SHIFT            18\n#define HEAP_MAKE_TAG_FLAGS(b,o) ((DWORD)((b)+((o)<<18)))\n#define FILE_ENCRYPTABLE 0\n#define FILE_IS_ENCRYPTED 1\n#define FILE_SYSTEM_ATTR 2\n#define FILE_ROOT_DIR 3\n#define FILE_SYSTEM_DIR 4\n#define FILE_UNKNOWN 5\n#define FILE_SYSTEM_NOT_SUPPORT 6\n#define FILE_USER_DISALLOWED 7\n#define FILE_READ_ONLY 8\n#define FILE_DIR_DISALLOWED 9\n#define HasOverlappedIoCompleted(lpOverlapped) (((DWORD)(lpOverlapped)->Internal) != STATUS_PENDING)\n#define FIBER_FLAG_FLOAT_SWITCH 1\n#define DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION 1\n#define GET_MODULE_HANDLE_EX_FLAG_PIN 1\n#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2\n#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\t4\n#define FreeModule(hLibModule) FreeLibrary((hLibModule))\n#define PROFILE_LINKED\t'LINK'\n#define PROFILE_EMBEDDED\t'MBED'\n#define LVCF_IMAGE\t0x0010\n#define LVCF_ORDER\t0x0020\n#define LVCFMT_IMAGE\t0x0800\n#define LVCFMT_BITMAP_ON_RIGHT\t0x1000\n#define LVCFMT_COL_HAS_IMAGES\t0x8000\n#define LVCFMT_JUSTIFYMASK\t0x0003\n\n#ifdef UNICODE\n#define HD_TEXTFILTER HD_TEXTFILTERW\n#define HDTEXTFILTER HD_TEXTFILTERW\n#define LPHD_TEXTFILTER LPHD_TEXTFILTERW\n#define LPHDTEXTFILTER LPHD_TEXTFILTERW\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T\n#else\n#define HD_TEXTFILTER HD_TEXTFILTERA\n#define HDTEXTFILTER HD_TEXTFILTERA\n#define LPHD_TEXTFILTER LPHD_TEXTFILTERA\n#define LPHDTEXTFILTER LPHD_TEXTFILTERA\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W\n#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T\n#endif\n\n#define INVALID_LINK_INDEX (-1)\n#define MAX_LINKID_TEXT\t48\n#define L_MAX_URL_LENGTH\t(2048 + 32 + sizeof(\"://\"))\n#define LWS_TRANSPARENT 1\n#define LWS_IGNORERETURN 2\n#define LIF_ITEMINDEX 1\n#define LIF_STATE 2\n#define LIF_ITEMID 4\n#define LIF_URL\t8\n#define LIS_FOCUSED 1\n#define LIS_ENABLED 2\n#define LIS_VISITED 4\n/* Structures.h */\ntypedef struct tagACTCTXA {\n\tULONG     cbSize;\n\tDWORD     dwFlags;\n\tLPCSTR    lpSource;\n\tUSHORT    wProcessorArchitecture;\n\tLANGID    wLangId;\n\tLPCSTR    lpAssemblyDirectory;\n\tLPCSTR    lpResourceName;\n\tLPCSTR    lpApplicationName;\n\tHMODULE   hModule;\n} ACTCTXA, *PACTCTXA;\ntypedef struct tagACTCTXW {\n\tULONG     cbSize;\n\tDWORD     dwFlags;\n\tLPCWSTR   lpSource;\n\tUSHORT    wProcessorArchitecture;\n\tLANGID    wLangId;\n\tLPCWSTR   lpAssemblyDirectory;\n\tLPCWSTR   lpResourceName;\n\tLPCWSTR   lpApplicationName;\n\tHMODULE   hModule;\n} ACTCTXW, *PACTCTXW;\ntypedef const ACTCTXA *PCACTCTXA;\ntypedef const ACTCTXW *PCACTCTXW;\n\n//#if !defined(ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED)\n//typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {\n//\tHANDLE hActCtx;\n//\tDWORD  dwFlags;\n//} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;\n//typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;\n//#define ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED 1\n//#endif\n\ntypedef struct tagWTSSESSION_NOTIFICATION { DWORD cbSize; DWORD dwSessionId; } WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;\n//#ifndef RC_INVOKED\ntypedef struct tagKBDLLHOOKSTRUCT {\n\tDWORD vkCode;\n\tDWORD scanCode;\n\tDWORD flags;\n\tDWORD time;\n\tULONG_PTR dwExtraInfo;\n} KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;\ntypedef struct tagHARDWAREHOOKSTRUCT {\n\tHWND hwnd;\n\tUINT message;\n\tWPARAM wParam;\n\tLPARAM lParam;\n} HARDWAREHOOKSTRUCT, *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;\ntypedef struct tagRAWHID{DWORD dwSizeHid;DWORD dwCount;BYTE bRawData[1];}RAWHID,*PRAWHID,*LPRAWHID;\ntypedef struct tagRID_DEVICE_INFO_MOUSE {\n\tDWORD dwId;\n\tDWORD dwNumberOfButtons;\n\tDWORD dwSampleRate;\n} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;\ntypedef struct tagRID_DEVICE_INFO_KEYBOARD {\n\tDWORD dwType;\n\tDWORD dwSubType;\n\tDWORD dwKeyboardMode;\n\tDWORD dwNumberOfFunctionKeys;\n\tDWORD dwNumberOfIndicators;\n\tDWORD dwNumberOfKeysTotal;\n} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;\ntypedef struct tagRID_DEVICE_INFO_HID {\n\tDWORD dwVendorId;\n\tDWORD dwProductId;\n\tDWORD dwVersionNumber;\n\tUSHORT usUsagePage;\n\tUSHORT usUsage;\n} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;\ntypedef struct tagRID_DEVICE_INFO {\n\tDWORD cbSize;\n\tDWORD dwType;\n\tunion {\n\t\tRID_DEVICE_INFO_MOUSE mouse;\n\t\tRID_DEVICE_INFO_KEYBOARD keyboard;\n\t\tRID_DEVICE_INFO_HID hid;\n\t};\n} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;\ntypedef struct tagRAWKEYBOARD {\n\tUSHORT MakeCode;\n\tUSHORT Flags;\n\tUSHORT Reserved;\n\tUSHORT VKey;\n\tUINT Message;\n\tULONG ExtraInformation;\n} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;\ntypedef struct tagRAWINPUTHEADER {\n\tDWORD dwType;\n\tDWORD dwSize;\n\tHANDLE hDevice;\n\tWPARAM wParam;\n} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;\ntypedef struct tagRAWMOUSE {\n\tUSHORT usFlags;\n\tunion {\n\t\tULONG ulButtons;\n\t\tstruct {\n\t\tUSHORT usButtonFlags;\n\t\tUSHORT usButtonData;\n\t\t};\n\t};\n\tULONG ulRawButtons;\n\tLONG lLastX;\n\tLONG lLastY;\n\tULONG ulExtraInformation;\n} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;\ntypedef struct tagRAWINPUT {\n\tRAWINPUTHEADER header;\n\tunion {\n\t\tRAWMOUSE mouse;\n\t\tRAWKEYBOARD keyboard;\n\t\tRAWHID hid;\n\t} data;\n} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;\ntypedef struct tagRAWINPUTDEVICE {\n\tUSHORT usUsagePage;\n\tUSHORT usUsage;\n\tDWORD dwFlags;\n\tHWND hwndTarget;\n} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;\ntypedef CONST RAWINPUTDEVICE* PCRAWINPUTDEVICE;\ntypedef struct tagRAWINPUTDEVICELIST { HANDLE hDevice; DWORD dwType;} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;\ntypedef union _LARGE_INTEGER {\n\tstruct { DWORD LowPart; LONG HighPart;};\n\tstruct { DWORD LowPart; LONG HighPart; } u;\n\tlong long int QuadPart;\n} LARGE_INTEGER,*PLARGE_INTEGER;\ntypedef DWORD (WINAPI *LPPROGRESS_ROUTINE)(LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,DWORD,DWORD,HANDLE,HANDLE,LPVOID);\ntypedef struct _ABC {\n\tint abcA;\n\tUINT abcB;\n\tint abcC;\n} ABC,*LPABC;\ntypedef struct _ABCFLOAT {\n\tFLOAT abcfA;\n\tFLOAT abcfB;\n\tFLOAT abcfC;\n} ABCFLOAT,*LPABCFLOAT;\n#pragma pack(push,2)\ntypedef struct tagACCEL {\n\tBYTE fVirt;\n\tWORD key;\n\tWORD cmd;\n} ACCEL,*LPACCEL;\n#pragma pack(pop)\ntypedef struct _ACE_HEADER {\n\tBYTE AceType;\n\tBYTE AceFlags;\n\tWORD AceSize;\n} ACE_HEADER;\ntypedef DWORD ACCESS_MASK;\ntypedef ACCESS_MASK REGSAM;\ntypedef struct _ACCESS_ALLOWED_ACE {\n\tACE_HEADER Header;\n\tACCESS_MASK Mask;\n\tDWORD SidStart;\n} ACCESS_ALLOWED_ACE;\ntypedef struct _ACCESS_DENIED_ACE {\n\tACE_HEADER Header;\n\tACCESS_MASK Mask;\n\tDWORD SidStart;\n} ACCESS_DENIED_ACE;\ntypedef struct tagACCESSTIMEOUT {\n\tUINT cbSize;\n\tDWORD dwFlags;\n\tDWORD iTimeOutMSec;\n} ACCESSTIMEOUT;\ntypedef struct _ACL {\n\tBYTE AclRevision;\n\tBYTE Sbz1;\n\tWORD AclSize;\n\tWORD AceCount;\n\tWORD Sbz2;\n} ACL,*PACL;\ntypedef struct _ACL_REVISION_INFORMATION {\n\tDWORD AclRevision;\n} ACL_REVISION_INFORMATION;\ntypedef struct _ACL_SIZE_INFORMATION {\n\tDWORD AceCount;\n\tDWORD AclBytesInUse;\n\tDWORD AclBytesFree;\n} ACL_SIZE_INFORMATION;\ntypedef struct _ACTION_HEADER {\n\tULONG transport_id;\n\tUSHORT action_code;\n\tUSHORT reserved;\n} ACTION_HEADER;\ntypedef struct _ADAPTER_STATUS {\n\tUCHAR adapter_address[6];\n\tUCHAR rev_major;\n\tUCHAR reserved0;\n\tUCHAR adapter_type;\n\tUCHAR rev_minor;\n\tWORD duration;\n\tWORD frmr_recv;\n\tWORD frmr_xmit;\n\tWORD iframe_recv_err;\n\tWORD xmit_aborts;\n\tDWORD xmit_success;\n\tDWORD recv_success;\n\tWORD iframe_xmit_err;\n\tWORD recv_buff_unavail;\n\tWORD t1_timeouts;\n\tWORD ti_timeouts;\n\tDWORD reserved1;\n\tWORD free_ncbs;\n\tWORD max_cfg_ncbs;\n\tWORD max_ncbs;\n\tWORD xmit_buf_unavail;\n\tWORD max_dgram_size;\n\tWORD pending_sess;\n\tWORD max_cfg_sess;\n\tWORD max_sess;\n\tWORD max_sess_pkt_size;\n\tWORD name_count;\n} ADAPTER_STATUS;\ntypedef struct tagANIMATIONINFO {\n\tUINT cbSize;\n\tint iMinAnimate;\n} ANIMATIONINFO,*LPANIMATIONINFO;\ntypedef struct _RECT {\n\tLONG left;\n\tLONG top;\n\tLONG right;\n\tLONG bottom;\n} RECT,*LPRECT;\ntypedef struct _RECT *PRECT;\ntypedef const RECT *LPCRECT;\ntypedef struct _RECTL {\n\tLONG left;\n\tLONG top;\n\tLONG right;\n\tLONG bottom;\n} RECTL,*LPRECTL;\ntypedef const RECTL *LPCRECTL;\ntypedef struct tagBITMAP {\n\tLONG bmType;\n\tLONG bmWidth;\n\tLONG bmHeight;\n\tLONG bmWidthBytes;\n\tWORD bmPlanes;\n\tWORD bmBitsPixel;\n\tLPVOID bmBits;\n} BITMAP,*PBITMAP,*NPBITMAP,*LPBITMAP;\ntypedef struct tagBITMAPCOREHEADER {\n\tDWORD bcSize;\n\tWORD bcWidth;\n\tWORD bcHeight;\n\tWORD bcPlanes;\n\tWORD bcBitCount;\n} BITMAPCOREHEADER;\n /* was missing jn */\ntypedef BITMAPCOREHEADER *LPBITMAPCOREHEADER;\ntypedef struct tagRGBTRIPLE {\n\tBYTE rgbtBlue;\n\tBYTE rgbtGreen;\n\tBYTE rgbtRed;\n} RGBTRIPLE;\ntypedef struct _BITMAPCOREINFO {\n\tBITMAPCOREHEADER bmciHeader;\n\tRGBTRIPLE bmciColors[1];\n} BITMAPCOREINFO;\n/* was missing jn */\ntypedef BITMAPCOREINFO *LPBITMAPCOREINFO;\n#pragma pack(1)\ntypedef struct tagBITMAPFILEHEADER {\n\tWORD bfType;\n\tDWORD bfSize;\n\tWORD bfReserved1;\n\tWORD bfReserved2;\n\tDWORD bfOffBits;\n} BITMAPFILEHEADER,*LPBITMAPFILEHEADER,*PBITMAPFILEHEADER;\n#pragma pack()\ntypedef struct tagBITMAPINFOHEADER {\n\tDWORD biSize;\n\tLONG biWidth;\n\tLONG biHeight;\n\tWORD biPlanes;\n\tWORD biBitCount;\n\tDWORD biCompression;\n\tDWORD biSizeImage;\n\tLONG biXPelsPerMeter;\n\tLONG biYPelsPerMeter;\n\tDWORD biClrUsed;\n\tDWORD biClrImportant;\n} BITMAPINFOHEADER,*LPBITMAPINFOHEADER,*PBITMAPINFOHEADER;\ntypedef struct tagRGBQUAD {\n\tBYTE rgbBlue;\n\tBYTE rgbGreen;\n\tBYTE rgbRed;\n\tBYTE rgbReserved;\n} RGBQUAD,*LPRGBQUAD;\ntypedef struct tagBITMAPINFO {\n\tBITMAPINFOHEADER bmiHeader;\n\tRGBQUAD bmiColors[1];\n} BITMAPINFO,*LPBITMAPINFO,*PBITMAPINFO;\ntypedef long FXPT2DOT30,*LPFXPT2DOT30;\ntypedef struct tagCIEXYZ {\n\tFXPT2DOT30 ciexyzX;\n\tFXPT2DOT30 ciexyzY;\n\tFXPT2DOT30 ciexyzZ;\n} CIEXYZ;\ntypedef CIEXYZ *LPCIEXYZ;\ntypedef struct tagICEXYZTRIPLE {\n\tCIEXYZ ciexyzRed;\n\tCIEXYZ ciexyzGreen;\n\tCIEXYZ ciexyzBlue;\n} CIEXYZTRIPLE, *LPCIEXYZTRIPLE;\ntypedef struct {\n\tDWORD bV4Size;\n\tLONG bV4Width;\n\tLONG bV4Height;\n\tWORD bV4Planes;\n\tWORD bV4BitCount;\n\tDWORD bV4V4Compression;\n\tDWORD bV4SizeImage;\n\tLONG bV4XPelsPerMeter;\n\tLONG bV4YPelsPerMeter;\n\tDWORD bV4ClrUsed;\n\tDWORD bV4ClrImportant;\n\tDWORD bV4RedMask;\n\tDWORD bV4GreenMask;\n\tDWORD bV4BlueMask;\n\tDWORD bV4AlphaMask;\n\tDWORD bV4CSType;\n\tCIEXYZTRIPLE bV4Endpoints;\n\tDWORD bV4GammaRed;\n\tDWORD bV4GammaGreen;\n\tDWORD bV4GammaBlue;\n} BITMAPV4HEADER,*LPBITMAPV4HEADER,*PBITMAPV4HEADER;\ntypedef struct {\n\tDWORD bV5Size;\n\tLONG bV5Width;\n\tLONG bV5Height;\n\tWORD bV5Planes;\n\tWORD bV5BitCount;\n\tDWORD bV5Compression;\n\tDWORD bV5SizeImage;\n\tLONG bV5XPelsPerMeter;\n\tLONG bV5YPelsPerMeter;\n\tDWORD bV5ClrUsed;\n\tDWORD bV5ClrImportant;\n\tDWORD bV5RedMask;\n\tDWORD bV5GreenMask;\n\tDWORD bV5BlueMask;\n\tDWORD bV5AlphaMask;\n\tDWORD bV5CSType;\n\tCIEXYZTRIPLE bV5Endpoints;\n\tDWORD bV5GammaRed;\n\tDWORD bV5GammaGreen;\n\tDWORD bV5GammaBlue;\n\tDWORD bV5Intent;\n\tDWORD bV5ProfileData;\n\tDWORD bV5ProfileSize;\n\tDWORD bV5Reserved;\n} BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER;\n\n//#ifndef _SHITEMID_DEFINED\ntypedef struct _SHITEMID { USHORT cb; BYTE abID[1]; } SHITEMID,*LPSHITEMID;\n#define _SHITEMID_DEFINED\n//#endif\ntypedef const SHITEMID *LPCSHITEMID;\n//#ifndef _ITEMIDLIST_DEFINED\n#define _ITEMIDLIST_DEFINED\ntypedef struct _ITEMIDLIST { SHITEMID mkid; } ITEMIDLIST,*LPITEMIDLIST;\n//#endif\ntypedef const ITEMIDLIST *LPCITEMIDLIST;\ntypedef struct _browseinfo {\n\tHWND hwndOwner;\n\tLPCITEMIDLIST pidlRoot;\n\tLPSTR pszDisplayName;\n\tLPCSTR lpszTitle;\n\tUINT ulFlags;\n\tBFFCALLBACK lpfn;\n\tLPARAM lParam;\n\tint iImage;\n} BROWSEINFO,*PBROWSEINFO,*LPBROWSEINFO;\ntypedef struct tagFILETIME {\n\tDWORD dwLowDateTime;\n\tDWORD dwHighDateTime;\n} FILETIME,*LPFILETIME,*PFILETIME;\n#define _FILETIME\ntypedef struct _BY_HANDLE_FILE_INFORMATION {\n\tDWORD dwFileAttributes;\n\tFILETIME ftCreationTime;\n\tFILETIME ftLastAccessTime;\n\tFILETIME ftLastWriteTime;\n\tDWORD dwVolumeSerialNumber;\n\tDWORD nFileSizeHigh;\n\tDWORD nFileSizeLow;\n\tDWORD nNumberOfLinks;\n\tDWORD nFileIndexHigh;\n\tDWORD nFileIndexLow;\n} BY_HANDLE_FILE_INFORMATION,*LPBY_HANDLE_FILE_INFORMATION;\ntypedef struct _FIXED {\n\tWORD fract;\n\tshort value;\n} FIXED;\ntypedef struct tagPOINT {\n\tLONG x;\n\tLONG y;\n} POINT,*PPOINT;\n#define LPPOINT PPOINT\ntypedef struct tagPOINTFX {\n\tFIXED x;\n\tFIXED y;\n} POINTFX;\ntypedef struct _POINTL {\n\tLONG x;\n\tLONG y;\n} POINTL;\ntypedef struct tagPOINTS {\n\tSHORT x;\n\tSHORT y;\n} POINTS;\ntypedef struct tagCREATESTRUCT {\n\tLPVOID lpCreateParams;\n\tHINSTANCE hInstance;\n\tHMENU hMenu;\n\tHWND hwndParent;\n\tint cy;\n\tint cx;\n\tint y;\n\tint x;\n\tLONG style;\n\tLPCTSTR lpszName;\n\tLPCTSTR lpszClass;\n\tDWORD dwExStyle;\n} CREATESTRUCT,*LPCREATESTRUCT;\ntypedef struct tagCBT_CREATEWNDA {\n\tstruct tagCREATESTRUCTA *lpcs;\n\tHWND\thwndInsertAfter;\n} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;\ntypedef struct tagCBT_CREATEWNDW {\n\tstruct tagCREATESTRUCTW *lpcs;\n\tHWND hwndInsertAfter;\n} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;\n\n#ifdef UNICODE\ntypedef ACTCTXW ACTCTX;\ntypedef PACTCTXW PACTCTX;\ntypedef CBT_CREATEWNDW CBT_CREATEWND;\ntypedef LPCBT_CREATEWNDW LPCBT_CREATEWND;\n#else\ntypedef ACTCTXA ACTCTX;\ntypedef PACTCTXA PACTCTX;\ntypedef CBT_CREATEWNDA CBT_CREATEWND;\ntypedef LPCBT_CREATEWNDA LPCBT_CREATEWND;\n#endif\n\ntypedef struct tagCBTACTIVATESTRUCT {\n\tBOOL fMouse;\n\tHWND hWndActive;\n} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;\n#define WTS_CONSOLE_CONNECT\t\t1\n#define WTS_CONSOLE_DISCONNECT\t\t2\n#define WTS_REMOTE_CONNECT\t\t3\n#define WTS_REMOTE_DISCONNECT\t\t4\n#define WTS_SESSION_LOGON\t\t5\n#define WTS_SESSION_LOGOFF\t\t6\n#define WTS_SESSION_LOCK\t\t7\n#define WTS_SESSION_UNLOCK\t\t8\n#define WTS_SESSION_REMOTE_CONTROL\t9\ntypedef struct _CHAR_INFO {\n\tunion { WCHAR UnicodeChar; CHAR AsciiChar; } Char;\n\tWORD Attributes;\n} CHAR_INFO,*PCHAR_INFO;\ntypedef struct tagMSLLHOOKSTRUCT {\n\tPOINT pt;\n\tDWORD mouseData;\n\tDWORD flags;\n\tDWORD time;\n\tULONG_PTR dwExtraInfo;\n} MSLLHOOKSTRUCT, *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;\n#ifndef _CHARRANGE_DEFINED\n#define _CHARRANGE_DEFINED\ntypedef struct _charrange { LONG cpMin; LONG cpMax; } CHARRANGE;\n#endif\ntypedef struct tagCHARSET { DWORD aflBlock[3]; DWORD flLang; } CHARSET;\ntypedef struct tagFONTSIGNATURE { DWORD fsUsb[4]; DWORD fsCsb[2]; }\n\tFONTSIGNATURE,*LPFONTSIGNATURE;\ntypedef struct {\n\tUINT ciCharset;\n\tUINT ciACP;\n\tFONTSIGNATURE fs;\n} CHARSETINFO,*LPCHARSETINFO;\ntypedef struct {\n\tDWORD lStructSize;\n\tHWND hwndOwner;\n\tHWND hInstance;\n\tCOLORREF rgbResult;\n\tCOLORREF *lpCustColors;\n\tDWORD Flags;\n\tLPARAM lCustData;\n\tLPCCHOOKPROC lpfnHook;\n\tLPCTSTR lpTemplateName;\n} CHOOSECOLOR,*LPCHOOSECOLOR;\ntypedef struct tagLOGFONTA {\n\tLONG\tlfHeight;\n\tLONG\tlfWidth;\n\tLONG\tlfEscapement;\n\tLONG\tlfOrientation;\n\tLONG\tlfWeight;\n\tBYTE\tlfItalic;\n\tBYTE\tlfUnderline;\n\tBYTE\tlfStrikeOut;\n\tBYTE\tlfCharSet;\n\tBYTE\tlfOutPrecision;\n\tBYTE\tlfClipPrecision;\n\tBYTE\tlfQuality;\n\tBYTE\tlfPitchAndFamily;\n\tCHAR\tlfFaceName[LF_FACESIZE];\n} LOGFONTA, *PLOGFONTA, NEAR *NPLOGFONTA, FAR *LPLOGFONTA;\ntypedef struct tagLOGFONTW\n{\n\tLONG\tlfHeight;\n\tLONG\tlfWidth;\n\tLONG\tlfEscapement;\n\tLONG\tlfOrientation;\n\tLONG\tlfWeight;\n\tBYTE\tlfItalic;\n\tBYTE\tlfUnderline;\n\tBYTE\tlfStrikeOut;\n\tBYTE\tlfCharSet;\n\tBYTE\tlfOutPrecision;\n\tBYTE\tlfClipPrecision;\n\tBYTE\tlfQuality;\n\tBYTE\tlfPitchAndFamily;\n\tWCHAR\tlfFaceName[LF_FACESIZE];\n} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;\n#ifdef UNICODE\ntypedef LOGFONTW LOGFONT;\ntypedef PLOGFONTW PLOGFONT;\ntypedef NPLOGFONTW NPLOGFONT;\ntypedef LPLOGFONTW LPLOGFONT;\n#else\ntypedef LOGFONTA LOGFONT;\ntypedef PLOGFONTA PLOGFONT;\ntypedef NPLOGFONTA NPLOGFONT;\ntypedef LPLOGFONTA LPLOGFONT;\n#endif\ntypedef struct {\n\tDWORD lStructSize;\n\tHWND hwndOwner;\n\tHDC hDC;\n\tLPLOGFONT lpLogFont;\n\tINT iPointSize;\n\tDWORD Flags;\n\tDWORD rgbColors;\n\tLPARAM lCustData;\n\tLPCFHOOKPROC lpfnHook;\n\tLPCTSTR lpTemplateName;\n\tHINSTANCE hInstance;\n\tLPTSTR lpszStyle;\n\tWORD nFontType;\n\tWORD ___MISSING_ALIGNMENT__;\n\tINT nSizeMin;\n\tINT nSizeMax;\n} CHOOSEFONT,*LPCHOOSEFONT;\n#ifndef _IDA_DEFINED\n#define _IDA_DEFINED\ntypedef struct _IDA { UINT cidl; UINT aoffset[1]; } CIDA,*LPIDA;\n#endif\ntypedef struct tagCLIENTCREATESTRUCT {\n\tHANDLE hWindowMenu;\n\tUINT idFirstChild;\n} CLIENTCREATESTRUCT;\ntypedef struct tagCOLORADJUSTMENT {\n\tWORD caSize;\n\tWORD caFlags;\n\tWORD caIlluminantIndex;\n\tWORD caRedGamma;\n\tWORD caGreenGamma;\n\tWORD caBlueGamma;\n\tWORD caReferenceBlack;\n\tWORD caReferenceWhite;\n\tSHORT caContrast;\n\tSHORT caBrightness;\n\tSHORT caColorfulness;\n\tSHORT caRedGreenTint;\n} COLORADJUSTMENT,*LPCOLORADJUSTMENT;\ntypedef struct _COLORMAP {\n\tCOLORREF from;\n\tCOLORREF to;\n} COLORMAP,*LPCOLORMAP;\ntypedef struct _DCB {\n\tDWORD DCBlength;\n\tDWORD BaudRate;\n\tunsigned fBinary:1;\n\tunsigned fParity:1;\n\tunsigned fOutxCtsFlow:1;\n\tunsigned fOutxDsrFlow:1;\n\tunsigned fDtrControl:2;\n\tunsigned fDsrSensitivity:1;\n\tunsigned fTXContinueOnXoff:1;\n\tunsigned fOutX:1;\n\tunsigned fInX:1;\n\tunsigned fErrorChar:1;\n\tunsigned fNull:1;\n\tunsigned fRtsControl:2;\n\tunsigned fAbortOnError:1;\n\tunsigned fDummy2:17;\n\tWORD wReserved;\n\tWORD XonLim;\n\tWORD XoffLim;\n\tBYTE ByteSize;\n\tBYTE Parity;\n\tBYTE StopBits;\n\tchar XonChar;\n\tchar XoffChar;\n\tchar ErrorChar;\n\tchar EofChar;\n\tchar EvtChar;\n\tWORD wReserved1;\n} DCB,*LPDCB;\ntypedef struct _DEC { USHORT wReserved; BYTE scale; BYTE sign;\n ULONG Hi32; long long int Lo64; } DECIMAL;\ntypedef struct tagBLOB { ULONG cbSize; BYTE *pBlobData; } BLOB;\ntypedef struct tagBLOB *LPBLOB;\n#define _LPBLOB_DEFINED\ntypedef struct _COMM_CONFIG {\n\tDWORD dwSize;\n\tWORD wVersion;\n\tWORD wReserved;\n\tDCB dcb;\n\tDWORD dwProviderSubType;\n\tDWORD dwProviderOffset;\n\tDWORD dwProviderSize;\n\tWCHAR wcProviderData[2];\n} COMMCONFIG,*LPCOMMCONFIG;\ntypedef struct _COMMPROP {\n\tWORD wPacketLength;\n\tWORD wPacketVersion;\n\tDWORD dwServiceMask;\n\tDWORD dwReserved1;\n\tDWORD dwMaxTxQueue;\n\tDWORD dwMaxRxQueue;\n\tDWORD dwMaxBaud;\n\tDWORD dwProvSubType;\n\tDWORD dwProvCapabilities;\n\tDWORD dwSettableParams;\n\tDWORD dwSettableBaud;\n\tWORD wSettableData;\n\tWORD wSettableStopParity;\n\tDWORD dwCurrentTxQueue;\n\tDWORD dwCurrentRxQueue;\n\tDWORD dwProvSpec1;\n\tDWORD dwProvSpec2;\n\tWCHAR wcProvChar[1];\n} COMMPROP,*LPCOMMPROP;\ntypedef struct _COMMTIMEOUTS {\n\tDWORD ReadIntervalTimeout;\n\tDWORD ReadTotalTimeoutMultiplier;\n\tDWORD ReadTotalTimeoutConstant;\n\tDWORD WriteTotalTimeoutMultiplier;\n\tDWORD WriteTotalTimeoutConstant;\n} COMMTIMEOUTS,*LPCOMMTIMEOUTS;\ntypedef struct tagCOMPAREITEMSTRUCT {\n\tUINT CtlType;\n\tUINT CtlID;\n\tHWND hwndItem;\n\tUINT itemID1;\n\tDWORD itemData1;\n\tUINT itemID2;\n\tDWORD itemData2;\n} COMPAREITEMSTRUCT;\ntypedef struct _COMSTAT {\n\tunsigned fCtsHold:1;\n\tunsigned fDsrHold:1;\n\tunsigned fRlsdHold:1;\n\tunsigned fXoffHold:1;\n\tunsigned fXoffSent:1;\n\tunsigned fEof:1;\n\tunsigned fTxim:1;\n\tunsigned fReserved:25;\n\tDWORD cbInQue;\n\tDWORD cbOutQue;\n} COMSTAT,*LPCOMSTAT;\ntypedef struct _CONSOLE_CURSOR_INFO {\n\tDWORD dwSize;\n\tBOOL bVisible;\n} CONSOLE_CURSOR_INFO,*PCONSOLE_CURSOR_INFO;\ntypedef struct _COORD {\n\tSHORT X;\n\tSHORT Y;\n} COORD;\ntypedef struct _SMALL_RECT {\n\tSHORT Left;\n\tSHORT Top;\n\tSHORT Right;\n\tSHORT Bottom;\n} SMALL_RECT,*PSMALL_RECT;\ntypedef struct _CONSOLE_SCREEN_BUFFER_INFO {\n\tCOORD dwSize;\n\tCOORD dwCursorPosition;\n\tWORD wAttributes;\n\tSMALL_RECT srWindow;\n\tCOORD dwMaximumWindowSize;\n} CONSOLE_SCREEN_BUFFER_INFO,*PCONSOLE_SCREEN_BUFFER_INFO;\n#ifndef _CONTEXT_DEFINED_\n#define _CONTEXT_DEFINED_\n#define MAXIMUM_SUPPORTED_EXTENSION\t512\ntypedef struct _FLOATING_SAVE_AREA {\n\tDWORD ControlWord;\n\tDWORD StatusWord;\n\tDWORD TagWord;\n\tDWORD ErrorOffset;\n\tDWORD ErrorSelector;\n\tDWORD DataOffset;\n\tDWORD DataSelector;\n\tBYTE RegisterArea[80];\n\tDWORD Cr0NpxState;\n} FLOATING_SAVE_AREA;\ntypedef struct _CONTEXT {\n\tDWORD ContextFlags;\n\tDWORD Dr0;\n\tDWORD Dr1;\n\tDWORD Dr2;\n\tDWORD Dr3;\n\tDWORD Dr6;\n\tDWORD Dr7;\n\tFLOATING_SAVE_AREA FloatSave;\n\tDWORD SegGs;\n\tDWORD SegFs;\n\tDWORD SegEs;\n\tDWORD SegDs;\n\tDWORD Edi;\n\tDWORD Esi;\n\tDWORD Ebx;\n\tDWORD Edx;\n\tDWORD Ecx;\n\tDWORD Eax;\n\tDWORD Ebp;\n\tDWORD Eip;\n\tDWORD SegCs;\n\tDWORD EFlags;\n\tDWORD Esp;\n\tDWORD SegSs;\n\tBYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];\n} CONTEXT,*PCONTEXT,*LPCONTEXT;\n#endif\ntypedef struct _POWER_DEVICE_TIMEOUTS {\n DWORD ConservationIdleTime;\n DWORD PerformanceIdleTime;\n} POWER_DEVICE_TIMEOUTS, *PPOWER_DEVICE_TIMEOUTS;\ntypedef struct _LIST_ENTRY {\n\tstruct _LIST_ENTRY *Flink;\n\tstruct _LIST_ENTRY *Blink;\n} LIST_ENTRY,*PLIST_ENTRY;\ntypedef struct _RTL_CRITICAL_SECTION_DEBUG {\n\tWORD Type;\n\tWORD CreatorBackTraceIndex;\n\tstruct _RTL_CRITICAL_SECTION *CriticalSection;\n\tLIST_ENTRY ProcessLocksList;\n\tDWORD EntryCount;\n\tDWORD ContentionCount;\n\tDWORD Spare[ 2];\n} RTL_CRITICAL_SECTION_DEBUG,*PRTL_CRITICAL_SECTION_DEBUG,RTL_RESOURCE_DEBUG,*PRTL_RESOURCE_DEBUG;\ntypedef struct _SECURITY_QUALITY_OF_SERVICE {\n\tDWORD Length;\n\tSECURITY_IMPERSONATION_LEVEL ImpersonationLevel;\n\tBOOL ContextTrackingMode;\n\tBOOLEAN EffectiveOnly;\n} SECURITY_QUALITY_OF_SERVICE;\ntypedef struct tagCONVCONTEXT {\n\tUINT cb;\n\tUINT wFlags;\n\tUINT wCountryID;\n\tint iCodePage;\n\tDWORD dwLangID;\n\tDWORD dwSecurity;\n\tSECURITY_QUALITY_OF_SERVICE qos;\n} CONVCONTEXT;\ntypedef struct tagCONVINFO {\n\tDWORD cb;\n\tDWORD hUser;\n\tHCONV hConvPartner;\n\tHSZ hszSvcPartner;\n\tHSZ hszServiceReq;\n\tHSZ hszTopic;\n\tHSZ hszItem;\n\tUINT wFmt;\n\tUINT wType;\n\tUINT wStatus;\n\tUINT wConvst;\n\tUINT wLastError;\n\tHCONVLIST hConvList;\n\tCONVCONTEXT ConvCtxt;\n\tHWND hwnd;\n\tHWND hwndPartner;\n} CONVINFO;\ntypedef struct tagCOPYDATASTRUCT {\n\tDWORD dwData;\n\tDWORD cbData;\n\tPVOID lpData;\n} COPYDATASTRUCT,*PCOPYDATASTRUCT;\ntypedef struct tagMDINEXTMENU {\n\tHMENU hmenuIn;\n\tHMENU hmenuNext;\n\tHWND hwndNext;\n} MDINEXTMENU,*PMDINEXTMENU, *LPMDINEXTMENU;\ntypedef struct _cpinfo {\n\tUINT MaxCharSize;\n\tBYTE DefaultChar[MAX_DEFAULTCHAR];\n\tBYTE LeadByte[MAX_LEADBYTES];\n} CPINFO,*LPCPINFO;\ntypedef struct _CREATE_PROCESS_DEBUG_INFO {\n\tHANDLE hFile;\n\tHANDLE hProcess;\n\tHANDLE hThread;\n\tLPVOID lpBaseOfImage;\n\tDWORD dwDebugInfoFileOffset;\n\tDWORD nDebugInfoSize;\n\tLPVOID lpThreadLocalBase;\n\tLPTHREAD_START_ROUTINE lpStartAddress;\n\tLPVOID lpImageName;\n\tWORD fUnicode;\n} CREATE_PROCESS_DEBUG_INFO,*LPCREATE_PROCESS_DEBUG_INFO;\ntypedef struct _CREATE_THREAD_DEBUG_INFO {\n\tHANDLE hThread;\n\tLPVOID lpThreadLocalBase;\n\tLPTHREAD_START_ROUTINE lpStartAddress;\n} CREATE_THREAD_DEBUG_INFO,*LPCREATE_THREAD_DEBUG_INFO;\ntypedef struct _currencyfmtA {\n\tUINT NumDigits;\n\tUINT LeadingZero;\n\tUINT Grouping;\n\tLPSTR lpDecimalSep;\n\tLPSTR lpThousandSep;\n\tUINT NegativeOrder;\n\tUINT PositiveOrder;\n\tLPTSTR lpCurrencySymbol;\n} CURRENCYFMTA,*LPCURRENCYFMTA;\ntypedef struct _currencyfmtW {\n\tUINT NumDigits;\n\tUINT LeadingZero;\n\tUINT Grouping;\n\tLPWSTR lpDecimalSep;\n\tLPWSTR lpThousandSep;\n\tUINT NegativeOrder;\n\tUINT PositiveOrder;\n\tLPWSTR lpCurrencySymbol;\n} CURRENCYFMTW,*LPCURRENCYFMTW;\ntypedef struct tagCURSORSHAPE {\n\tint xHotSpot;\n\tint yHotSpot;\n\tint cx;\n\tint cy;\n\tint cbWidth;\n\tBYTE Planes;\n\tBYTE BitsPixel;\n} CURSORSHAPE,*LPCURSORSHAPE;\ntypedef struct tagCWPRETSTRUCT {\n\tLRESULT lResult;\n\tLPARAM lParam;\n\tWPARAM wParam;\n\tDWORD message;\n\tHWND hwnd;\n} CWPRETSTRUCT;\ntypedef struct tagCWPSTRUCT {\n\tLPARAM lParam;\n\tWPARAM wParam;\n\tUINT message;\n\tHWND hwnd;\n} CWPSTRUCT,*PWCWPSTRUCT;\ntypedef struct {\n\tunsigned bAppReturnCode:8,reserved:6,fBusy:1,fAck:1;\n} DDEACK;\ntypedef struct {\n\tunsigned reserved:14,fDeferUpd:1,fAckReq:1;\n\tshort cfFormat;\n} DDEADVISE;\ntypedef struct {\n\tunsigned unused:12,fResponse:1,fRelease:1,reserved:1,fAckReq:1;\n\tshort cfFormat;\n\tBYTE Value[1];\n} DDEDATA;\ntypedef struct {\n\tunsigned unused:13,fRelease:1,fDeferUpd:1,fAckReq:1;\n\tshort cfFormat;\n} DDELN;\ntypedef struct tagDDEML_MSG_HOOK_DATA {\n\tUINT uiLo;\n\tUINT uiHi;\n\tDWORD cbData;\n\tDWORD Data[8];\n} DDEML_MSG_HOOK_DATA;\ntypedef struct {\n\tunsigned unused:13,fRelease:1,fReserved:2;\n\tshort cfFormat;\n\tBYTE Value[1];\n} DDEPOKE;\ntypedef struct {\n\tunsigned unused:12,fAck:1,fRelease:1,fReserved:1,fAckReq:1;\n\tshort cfFormat;\n\tBYTE rgb[1];\n} DDEUP;\n#ifndef _EXCEPTION_RECORD_DEFINED_\n#define _EXCEPTION_RECORD_DEFINED_\ntypedef struct _EXCEPTION_RECORD {\n\tDWORD ExceptionCode;\n\tDWORD ExceptionFlags;\n\tstruct _EXCEPTION_RECORD *ExceptionRecord;\n\tPVOID ExceptionAddress;\n\tDWORD NumberParameters;\n\tDWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];\n} EXCEPTION_RECORD,*PEXCEPTION_RECORD,*LPEXCEPTION_RECORD;\n#endif\ntypedef struct _EXCEPTION_DEBUG_INFO {\n\tEXCEPTION_RECORD ExceptionRecord;\n\tDWORD dwFirstChance;\n} EXCEPTION_DEBUG_INFO;\ntypedef struct _EXIT_PROCESS_DEBUG_INFO {\n\tDWORD dwExitCode;\n} EXIT_PROCESS_DEBUG_INFO;\ntypedef struct _EXIT_THREAD_DEBUG_INFO {\n\tDWORD dwExitCode;\n} EXIT_THREAD_DEBUG_INFO;\ntypedef struct _LOAD_DLL_DEBUG_INFO {\n\tHANDLE hFile;\n\tLPVOID lpBaseOfDll;\n\tDWORD dwDebugInfoFileOffset;\n\tDWORD nDebugInfoSize;\n\tLPVOID lpImageName;\n\tWORD fUnicode;\n} LOAD_DLL_DEBUG_INFO;\ntypedef struct _UNLOAD_DLL_DEBUG_INFO {\n\tLPVOID lpBaseOfDll;\n} UNLOAD_DLL_DEBUG_INFO;\ntypedef struct _OUTPUT_DEBUG_STRING_INFO {\n\tLPSTR lpDebugStringData;\n\tWORD fUnicode;\n\tWORD nDebugStringLength;\n} OUTPUT_DEBUG_STRING_INFO;\ntypedef struct _RIP_INFO {\n\tDWORD dwError;\n\tDWORD dwType;\n} RIP_INFO;\ntypedef struct _DEBUG_EVENT {\n\tDWORD dwDebugEventCode;\n\tDWORD dwProcessId;\n\tDWORD dwThreadId;\n\tunion {\n\t\tEXCEPTION_DEBUG_INFO Exception;\n\t\tCREATE_THREAD_DEBUG_INFO CreateThread;\n\t\tCREATE_PROCESS_DEBUG_INFO CreateProcessInfo;\n\t\tEXIT_THREAD_DEBUG_INFO ExitThread;\n\t\tEXIT_PROCESS_DEBUG_INFO ExitProcess;\n\t\tLOAD_DLL_DEBUG_INFO LoadDll;\n\t\tUNLOAD_DLL_DEBUG_INFO UnloadDll;\n\t\tOUTPUT_DEBUG_STRING_INFO DebugString;\n\t\tRIP_INFO RipInfo;\n\t} u;\n} DEBUG_EVENT,*LPDEBUG_EVENT;\ntypedef struct tagDEBUGHOOKINFO {\n\tDWORD idThread;\n\tDWORD idThreadInstaller;\n\tLPARAM lParam;\n\tWPARAM wParam;\n\tint code;\n} DEBUGHOOKINFO;\n#ifndef _EXCEPTION_POINTERS_DEFINED_\n#define _EXCEPTION_POINTERS_DEFINED_\ntypedef struct _EXCEPTION_POINTERS {\n\tPEXCEPTION_RECORD ExceptionRecord;\n\tPCONTEXT ContextRecord;\n} EXCEPTION_POINTERS,*PEXCEPTION_POINTERS,*LPEXCEPTION_POINTERS;\n#endif\ntypedef LONG( * PTOP_LEVEL_EXCEPTION_FILTER) (struct _EXCEPTION_POINTERS * ExceptionInfo);\ntypedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;\ntypedef struct tagDELETEITEMSTRUCT {\n\tUINT CtlType;\n\tUINT CtlID;\n\tUINT itemID;\n\tHWND hwndItem;\n\tUINT itemData;\n} DELETEITEMSTRUCT,*LPDELETEITEMSTRUCT,*PDELETEITEMSTRUCT;\ntypedef struct _DEV_BROADCAST_HDR {\n\tULONG dbch_size;\n\tULONG dbch_devicetype;\n\tULONG dbch_reserved;\n} DEV_BROADCAST_HDR;\ntypedef DEV_BROADCAST_HDR *PDEV_BROADCAST_HDR;\ntypedef struct _DEV_BROADCAST_OEM {\n\tULONG dbco_size;\n\tULONG dbco_devicetype;\n\tULONG dbco_reserved;\n\tULONG dbco_identifier;\n\tULONG dbco_suppfunc;\n} DEV_BROADCAST_OEM;\ntypedef DEV_BROADCAST_OEM *PDEV_BROADCAST_OEM;\ntypedef struct _DEV_BROADCAST_PORT {\n\tULONG dbcp_size;\n\tULONG dbcp_devicetype;\n\tULONG dbcp_reserved;\n\tchar dbcp_name[1];\n} DEV_BROADCAST_PORT;\ntypedef DEV_BROADCAST_PORT *PDEV_BROADCAST_PORT;\nstruct _DEV_BROADCAST_USERDEFINED {\n\tstruct _DEV_BROADCAST_HDR dbud_dbh;\n\tchar dbud_szName[1];\n\tBYTE dbud_rgbUserDefined[1];\n};\ntypedef struct _DEV_BROADCAST_VOLUME {\n\tULONG dbcv_size;\n\tULONG dbcv_devicetype;\n\tULONG dbcv_reserved;\n\tULONG dbcv_unitmask;\n\tUSHORT dbcv_flags;\n} DEV_BROADCAST_VOLUME;\ntypedef DEV_BROADCAST_VOLUME *PDEV_BROADCAST_VOLUME;\ntypedef struct _devicemodeA {\n\tBYTE dmDeviceName[CCHDEVICENAME];\n\tWORD dmSpecVersion;\n\tWORD dmDriverVersion;\n\tWORD dmSize;\n\tWORD dmDriverExtra;\n\tDWORD dmFields;\n\tunion {\n\tstruct { short dmOrientation; short dmPaperSize; short dmPaperLength;\n\t\tshort dmPaperWidth; };\n\tPOINTL dmPosition;\n\t};\n\tshort dmScale;\n\tshort dmCopies;\n\tshort dmDefaultSource;\n\tshort dmPrintQuality;\n\tshort dmColor;\n\tshort dmDuplex;\n\tshort dmYResolution;\n\tshort dmTTOption;\n\tshort dmCollate;\n\tBYTE dmFormName[CCHFORMNAME];\n\tWORD dmLogPixels;\n\tDWORD dmBitsPerPel;\n\tDWORD dmPelsWidth;\n\tDWORD dmPelsHeight;\n\tDWORD dmDisplayFlags;\n\tDWORD dmDisplayFrequency;\n#if(WINVER >= 0x0400)\n\tDWORD dmICMMethod;\n\tDWORD dmICMIntent;\n\tDWORD dmMediaType;\n\tDWORD dmDitherType;\n\tDWORD dmReserved1;\n\tDWORD dmReserved2;\n#if (WINVER >= 0x0500)\n\tDWORD dmPanningWidth;\n\tDWORD dmPanningHeight;\n#endif\n#endif\n} DEVMODEA,*PDEVMODEA,*NPDEVMODEA,*LPDEVMODEA;\ntypedef struct _devicemodeW {\n\tWCHAR dmDeviceName[CCHDEVICENAME];\n\tWORD dmSpecVersion;\n\tWORD dmDriverVersion;\n\tWORD dmSize;\n\tWORD dmDriverExtra;\n\tDWORD dmFields;\n\tunion {\n\tstruct {\n\tshort dmOrientation; short dmPaperSize; short dmPaperLength; short dmPaperWidth; };\n\tPOINTL dmPosition;\n\t};\n\tshort dmScale;\n\tshort dmCopies;\n\tshort dmDefaultSource;\n\tshort dmPrintQuality;\n\tshort dmColor;\n\tshort dmDuplex;\n\tshort dmYResolution;\n\tshort dmTTOption;\n\tshort dmCollate;\n\tWCHAR dmFormName[CCHFORMNAME];\n\tWORD dmLogPixels;\n\tDWORD dmBitsPerPel;\n\tDWORD dmPelsWidth;\n\tDWORD dmPelsHeight;\n\tDWORD dmDisplayFlags;\n\tDWORD dmDisplayFrequency;\n#if(WINVER >= 0x0400)\n\tDWORD dmICMMethod;\n\tDWORD dmICMIntent;\n\tDWORD dmMediaType;\n\tDWORD dmDitherType;\n\tDWORD dmReserved1;\n\tDWORD dmReserved2;\n#if (WINVER >= 0x0500)\n\tDWORD dmPanningWidth;\n\tDWORD dmPanningHeight;\n#endif\n#endif\n} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;\n#ifdef UNICODE\ntypedef DEVMODEW DEVMODE;\ntypedef PDEVMODEW PDEVMODE;\ntypedef NPDEVMODEW NPDEVMODE;\ntypedef LPDEVMODEW LPDEVMODE;\ntypedef CURRENCYFMTW CURRENCYFMT;\ntypedef LPCURRENCYFMTW LPCURRENCYFMT;\n#else\ntypedef DEVMODEA DEVMODE;\ntypedef PDEVMODEA PDEVMODE;\ntypedef NPDEVMODEA NPDEVMODE;\ntypedef LPDEVMODEA LPDEVMODE;\ntypedef CURRENCYFMTA CURRENCYFMT;\ntypedef LPCURRENCYFMTA LPCURRENCYFMT;\n#endif\ntypedef struct tagDEVNAMES {\n\tWORD wDriverOffset;\n\tWORD wDeviceOffset;\n\tWORD wOutputOffset;\n\tWORD wDefault;\n} DEVNAMES,*LPDEVNAMES;\ntypedef struct tagDIBSECTION {\n\tBITMAP dsBm;\n\tBITMAPINFOHEADER dsBmih;\n\tDWORD dsBitfields[3];\n\tHANDLE dshSection;\n\tDWORD dsOffset;\n} DIBSECTION,*LPDIBSECTION,*PDIBSECTION;\ntypedef struct {\n\tDWORD style;\n\tDWORD dwExtendedStyle;\n\tshort x;\n\tshort y;\n\tshort cx;\n\tshort cy;\n\tWORD id;\n} DLGITEMTEMPLATE,*LPDLGITEMTEMPLATE;\ntypedef struct {\n\tDWORD style;\n\tDWORD dwExtendedStyle;\n\tWORD cdit;\n\tshort x;\n\tshort y;\n\tshort cx;\n\tshort cy;\n} DLGTEMPLATE,*LPDLGTEMPLATE;\ntypedef const DLGTEMPLATE *LPCDLGTEMPLATE;\ntypedef struct {\n\tint cbSize;\n\tLPCTSTR lpszDocName;\n\tLPCTSTR lpszOutput;\n\tLPCTSTR lpszDatatype;\n\tDWORD fwType;\n} DOCINFO;\ntypedef struct {\n\tUINT uNotification;\n\tHWND hWnd;\n\tPOINT ptCursor;\n} DRAGLISTINFO,*LPDRAGLISTINFO;\ntypedef struct tagDRAWITEMSTRUCT {\n\tUINT CtlType;\n\tUINT CtlID;\n\tUINT itemID;\n\tUINT itemAction;\n\tUINT itemState;\n\tHWND hwndItem;\n\tHDC hDC;\n\tRECT rcItem;\n\tDWORD itemData;\n} DRAWITEMSTRUCT,*LPDRAWITEMSTRUCT,*PDRAWITEMSTRUCT;\ntypedef struct {\n\tUINT cbSize;\n\tint iTabLength;\n\tint iLeftMargin;\n\tint iRightMargin;\n\tUINT uiLengthDrawn;\n} DRAWTEXTPARAMS,*LPDRAWTEXTPARAMS;\ntypedef struct tagEMR {\n\tDWORD iType;\n\tDWORD nSize;\n} EMR,*PEMR;\ntypedef struct tagEMRANGLEARC {\n\tEMR emr;\n\tPOINTL ptlCenter;\n\tDWORD nRadius;\n\tFLOAT eStartAngle;\n\tFLOAT eSweepAngle;\n} EMRANGLEARC,*PEMRANGLEARC;\ntypedef struct tagEMRARC {\n\tEMR emr;\n\tRECTL rclBox;\n\tPOINTL ptlStart;\n\tPOINTL ptlEnd;\n} EMRARC,*PEMRARC,\nEMRARCTO,*PEMRARCTO,\nEMRCHORD,*PEMRCHORD,\nEMRPIE,*PEMRPIE;\ntypedef struct _XFORM {\n\tFLOAT eM11;\n\tFLOAT eM12;\n\tFLOAT eM21;\n\tFLOAT eM22;\n\tFLOAT eDx;\n\tFLOAT eDy;\n} XFORM,*PXFORM,*LPXFORM;\ntypedef struct tagEMRBITBLT {\n\tEMR emr;\n\tRECTL rclBounds;\n\tLONG xDest;\n\tLONG yDest;\n\tLONG cxDest;\n\tLONG cyDest;\n\tDWORD dwRop;\n\tLONG xSrc;\n\tLONG ySrc;\n\tXFORM xformSrc;\n\tCOLORREF crBkColorSrc;\n\tDWORD iUsageSrc;\n\tDWORD offBmiSrc;\n\tDWORD offBitsSrc;\n\tDWORD cbBitsSrc;\n} EMRBITBLT,*PEMRBITBLT;\ntypedef struct tagLOGBRUSH {\n\tUINT lbStyle;\n\tCOLORREF lbColor;\n\tLONG lbHatch;\n} LOGBRUSH,*LPLOGBRUSH;\ntypedef struct tagLOGBRUSH32 {\n\tUINT\tlbStyle;\n\tCOLORREF\tlbColor;\n\tULONG\tlbHatch;\n} LOGBRUSH32, *PLOGBRUSH32, *NPLOGBRUSH32, *LPLOGBRUSH32;\ntypedef struct tagEMRCREATEBRUSHINDIRECT {\n\tEMR emr;\n\tDWORD ihBrush;\n\tLOGBRUSH lb;\n} EMRCREATEBRUSHINDIRECT,*PEMRCREATEBRUSHINDIRECT;\ntypedef LONG LCSCSTYPE;\ntypedef LONG LCSGAMUTMATCH;\ntypedef struct tagLOGCOLORSPACE {\n\tDWORD lcsSignature;\n\tDWORD lcsVersion;\n\tDWORD lcsSize;\n\tLCSCSTYPE lcsCSType;\n\tLCSGAMUTMATCH lcsIntent;\n\tCIEXYZTRIPLE lcsEndpoints;\n\tDWORD lcsGammaRed;\n\tDWORD lcsGammaGreen;\n\tDWORD lcsGammaBlue;\n\tTCHAR lcsFilename[MAX_PATH];\n} LOGCOLORSPACE,*LPLOGCOLORSPACE;\ntypedef struct tagEMRCREATECOLORSPACE {\n\tEMR emr;\n\tDWORD ihCS;\n\tLOGCOLORSPACE lcs;\n} EMRCREATECOLORSPACE,*PEMRCREATECOLORSPACE;\ntypedef struct tagEMRCREATEDIBPATTERNBRUSHPT {\n\tEMR emr;\n\tDWORD ihBrush;\n\tDWORD iUsage;\n\tDWORD offBmi;\n\tDWORD cbBmi;\n\tDWORD offBits;\n\tDWORD cbBits;\n} EMRCREATEDIBPATTERNBRUSHPT,\nPEMRCREATEDIBPATTERNBRUSHPT;\ntypedef struct tagEMRCREATEMONOBRUSH {\n\tEMR emr;\n\tDWORD ihBrush;\n\tDWORD iUsage;\n\tDWORD offBmi;\n\tDWORD cbBmi;\n\tDWORD offBits;\n\tDWORD cbBits;\n} EMRCREATEMONOBRUSH,*PEMRCREATEMONOBRUSH;\ntypedef struct tagPALETTEENTRY {\n\tBYTE peRed;\n\tBYTE peGreen;\n\tBYTE peBlue;\n\tBYTE peFlags;\n} PALETTEENTRY,*LPPALETTEENTRY,*PPALETTEENTRY;\ntypedef struct tagLOGPALETTE {\n\tWORD palVersion;\n\tWORD palNumEntries;\n\tPALETTEENTRY palPalEntry[1];\n} LOGPALETTE,*PLOGPALETTE;\ntypedef LOGPALETTE *LPLOGPALETTE;\ntypedef struct tagEMRCREATEPALETTE {\n\tEMR emr;\n\tDWORD ihPal;\n\tLOGPALETTE lgpl;\n} EMRCREATEPALETTE,*PEMRCREATEPALETTE;\ntypedef struct tagLOGPEN {\n\tUINT lopnStyle;\n\tPOINT lopnWidth;\n\tCOLORREF lopnColor;\n} LOGPEN,*LPLOGPEN;\ntypedef struct tagEMRCREATEPEN {\n\tEMR emr;\n\tDWORD ihPen;\n\tLOGPEN lopn;\n} EMRCREATEPEN,*PEMRCREATEPEN;\ntypedef struct tagEMRELLIPSE {\n\tEMR emr;\n\tRECTL rclBox;\n} EMRELLIPSE,*PEMRELLIPSE,\nEMRRECTANGLE,*PEMRRECTANGLE;\ntypedef struct tagEMREOF {\n\tEMR emr;\n\tDWORD nPalEntries;\n\tDWORD offPalEntries;\n\tDWORD nSizeLast;\n} EMREOF,*PEMREOF;\ntypedef struct tagEMREXCLUDECLIPRECT {\n\tEMR emr;\n\tRECTL rclClip;\n} EMREXCLUDECLIPRECT,*PEMREXCLUDECLIPRECT,\nEMRINTERSECTCLIPRECT,*PEMRINTERSECTCLIPRECT;\ntypedef struct tagPANOSE {\n\tBYTE bFamilyType;\n\tBYTE bSerifStyle;\n\tBYTE bWeight;\n\tBYTE bProportion;\n\tBYTE bContrast;\n\tBYTE bStrokeVariation;\n\tBYTE bArmStyle;\n\tBYTE bLetterform;\n\tBYTE bMidline;\n\tBYTE bXHeight;\n} PANOSE,*LPPANOSE;\ntypedef struct tagEXTLOGFONT {\n\tLOGFONT elfLogFont;\n\tBCHAR elfFullName[LF_FULLFACESIZE];\n\tBCHAR elfStyle[LF_FACESIZE];\n\tDWORD elfVersion;\n\tDWORD elfStyleSize;\n\tDWORD elfMatch;\n\tDWORD elfReserved;\n\tBYTE elfVendorId[ELF_VENDOR_SIZE];\n\tDWORD elfCulture;\n\tPANOSE elfPanose;\n} EXTLOGFONT,*LPEXTLOGFONT;\ntypedef struct tagEMREXTCREATEFONTINDIRECTW {\n\tEMR emr;\n\tDWORD ihFont;\n\tEXTLOGFONT elfw;\n} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;\ntypedef struct tagEXTLOGPEN {\n\tUINT elpPenStyle;\n\tUINT elpWidth;\n\tUINT elpBrushStyle;\n\tCOLORREF elpColor;\n\tLONG elpHatch;\n\tDWORD elpNumEntries;\n\tDWORD elpStyleEntry[1];\n} EXTLOGPEN,*LPEXTLOGPEN,*NPEXTLOGPEN;\ntypedef struct tagEMREXTCREATEPEN {\n\tEMR emr;\n\tDWORD ihPen;\n\tDWORD offBmi;\n\tDWORD cbBmi;\n\tDWORD offBits;\n\tDWORD cbBits;\n\tEXTLOGPEN elp;\n} EMREXTCREATEPEN,*PEMREXTCREATEPEN;\ntypedef struct tagEMREXTFLOODFILL {\n\tEMR emr;\n\tPOINTL ptlStart;\n\tCOLORREF crColor;\n\tDWORD iMode;\n} EMREXTFLOODFILL,*PEMREXTFLOODFILL;\ntypedef struct tagEMREXTSELECTCLIPRGN {\n\tEMR emr;\n\tDWORD cbRgnData;\n\tDWORD iMode;\n\tBYTE RgnData[1];\n} EMREXTSELECTCLIPRGN,*PEMREXTSELECTCLIPRGN;\ntypedef struct tagEMRTEXT {\n\tPOINTL ptlReference;\n\tDWORD nChars;\n\tDWORD offString;\n\tDWORD fOptions;\n\tRECTL rcl;\n\tDWORD offDx;\n} EMRTEXT,*PEMRTEXT;\ntypedef struct tagEMREXTTEXTOUTA {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD iGraphicsMode;\n\tFLOAT exScale;\n\tFLOAT eyScale;\n\tEMRTEXT emrtext;\n} EMREXTTEXTOUTA,*PEMREXTTEXTOUTA,\nEMREXTTEXTOUTW,*PEMREXTTEXTOUTW;\ntypedef struct tagEMRFILLPATH {\n\tEMR emr;\n\tRECTL rclBounds;\n} EMRFILLPATH,*PEMRFILLPATH,\nEMRSTROKEANDFILLPATH,*PEMRSTROKEANDFILLPATH,\nEMRSTROKEPATH,*PEMRSTROKEPATH;\ntypedef struct tagEMRFILLRGN {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD cbRgnData;\n\tDWORD ihBrush;\n\tBYTE RgnData[1];\n} EMRFILLRGN,*PEMRFILLRGN;\ntypedef struct tagEMRFORMAT {\n\tDWORD dSignature;\n\tDWORD nVersion;\n\tDWORD cbData;\n\tDWORD offData;\n} EMRFORMAT;\ntypedef struct tagSIZE {\n\tLONG cx;\n\tLONG cy;\n} SIZE,*PSIZE,*LPSIZE,SIZEL,*PSIZEL,*LPSIZEL;\ntypedef struct tagEMRFRAMERGN {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD cbRgnData;\n\tDWORD ihBrush;\n\tSIZEL szlStroke;\n\tBYTE RgnData[1];\n} EMRFRAMERGN,*PEMRFRAMERGN;\ntypedef struct tagEMRGDICOMMENT {\n\tEMR emr;\n\tDWORD cbData;\n\tBYTE Data[1];\n} EMRGDICOMMENT,*PEMRGDICOMMENT;\ntypedef struct tagEMRINVERTRGN {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD cbRgnData;\n\tBYTE RgnData[1];\n} EMRINVERTRGN,*PEMRINVERTRGN,\nEMRPAINTRGN,*PEMRPAINTRGN;\ntypedef struct tagEMRLINETO {\n\tEMR emr;\n\tPOINTL ptl;\n} EMRLINETO,*PEMRLINETO,\nEMRMOVETOEX,*PEMRMOVETOEX;\ntypedef struct tagEMRMASKBLT {\n\tEMR emr;\n\tRECTL rclBounds;\n\tLONG xDest;\n\tLONG yDest;\n\tLONG cxDest;\n\tLONG cyDest;\n\tDWORD dwRop;\n\tLONG xSrc;\n\tLONG ySrc;\n\tXFORM xformSrc;\n\tCOLORREF crBkColorSrc;\n\tDWORD iUsageSrc;\n\tDWORD offBmiSrc;\n\tDWORD cbBmiSrc;\n\tDWORD offBitsSrc;\n\tDWORD cbBitsSrc;\n\tLONG xMask;\n\tLONG yMask;\n\tDWORD iUsageMask;\n\tDWORD offBmiMask;\n\tDWORD cbBmiMask;\n\tDWORD offBitsMask;\n\tDWORD cbBitsMask;\n} EMRMASKBLT,*PEMRMASKBLT;\ntypedef struct tagEMRMODIFYWORLDTRANSFORM {\n\tEMR emr;\n\tXFORM xform;\n\tDWORD iMode;\n} EMRMODIFYWORLDTRANSFORM,\nPEMRMODIFYWORLDTRANSFORM;\ntypedef struct tagEMROFFSETCLIPRGN {\n\tEMR emr;\n\tPOINTL ptlOffset;\n} EMROFFSETCLIPRGN,*PEMROFFSETCLIPRGN;\ntypedef struct tagEMRPLGBLT {\n\tEMR emr;\n\tRECTL rclBounds;\n\tPOINTL aptlDest[3];\n\tLONG xSrc;\n\tLONG ySrc;\n\tLONG cxSrc;\n\tLONG cySrc;\n\tXFORM xformSrc;\n\tCOLORREF crBkColorSrc;\n\tDWORD iUsageSrc;\n\tDWORD offBmiSrc;\n\tDWORD cbBmiSrc;\n\tDWORD offBitsSrc;\n\tDWORD cbBitsSrc;\n\tLONG xMask;\n\tLONG yMask;\n\tDWORD iUsageMask;\n\tDWORD offBmiMask;\n\tDWORD cbBmiMask;\n\tDWORD offBitsMask;\n\tDWORD cbBitsMask;\n} EMRPLGBLT,*PEMRPLGBLT;\ntypedef struct tagEMRPOLYDRAW {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD cptl;\n\tPOINTL aptl[1];\n\tBYTE abTypes[1];\n} EMRPOLYDRAW,*PEMRPOLYDRAW;\ntypedef struct tagEMRPOLYDRAW16 {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD cpts;\n\tPOINTS apts[1];\n\tBYTE abTypes[1];\n} EMRPOLYDRAW16,*PEMRPOLYDRAW16;\ntypedef struct tagEMRPOLYLINE {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD cptl;\n\tPOINTL aptl[1];\n} EMRPOLYLINE,*PEMRPOLYLINE,\nEMRPOLYBEZIER,*PEMRPOLYBEZIER,\nEMRPOLYGON,*PEMRPOLYGON,\nEMRPOLYBEZIERTO,*PEMRPOLYBEZIERTO,\nEMRPOLYLINETO,*PEMRPOLYLINETO;\ntypedef struct tagEMRPOLYLINE16 {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD cpts;\n\tPOINTL apts[1];\n} EMRPOLYLINE16,*PEMRPOLYLINE16,\nEMRPOLYBEZIER16,*PEMRPOLYBEZIER16,\nEMRPOLYGON16,*PEMRPOLYGON16,\nEMRPOLYBEZIERTO16,*PEMRPOLYBEZIERTO16,\nEMRPOLYLINETO16,*PEMRPOLYLINETO16;\ntypedef struct tagEMRPOLYPOLYLINE {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD nPolys;\n\tDWORD cptl;\n\tDWORD aPolyCounts[1];\n\tPOINTL aptl[1];\n} EMRPOLYPOLYLINE,*PEMRPOLYPOLYLINE,\nEMRPOLYPOLYGON,*PEMRPOLYPOLYGON;\ntypedef struct tagEMRPOLYPOLYLINE16 {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD nPolys;\n\tDWORD cpts;\n\tDWORD aPolyCounts[1];\n\tPOINTS apts[1];\n} EMRPOLYPOLYLINE16,*PEMRPOLYPOLYLINE16,\nEMRPOLYPOLYGON16,*PEMRPOLYPOLYGON16;\ntypedef struct tagEMRPOLYTEXTOUTA {\n\tEMR emr;\n\tRECTL rclBounds;\n\tDWORD iGraphicsMode;\n\tFLOAT exScale;\n\tFLOAT eyScale;\n\tLONG cStrings;\n\tEMRTEXT aemrtext[1];\n} EMRPOLYTEXTOUTA,*PEMRPOLYTEXTOUTA,\nEMRPOLYTEXTOUTW,*PEMRPOLYTEXTOUTW;\ntypedef struct tagEMRRESIZEPALETTE {\n\tEMR emr;\n\tDWORD ihPal;\n\tDWORD cEntries;\n} EMRRESIZEPALETTE,*PEMRRESIZEPALETTE;\ntypedef struct tagEMRRESTOREDC {\n\tEMR emr;\n\tLONG iRelative;\n} EMRRESTOREDC,*PEMRRESTOREDC;\ntypedef struct tagEMRROUNDRECT {\n\tEMR emr;\n\tRECTL rclBox;\n\tSIZEL szlCorner;\n} EMRROUNDRECT,*PEMRROUNDRECT;\ntypedef struct tagEMRSCALEVIEWPORTEXTEX {\n\tEMR emr;\n\tLONG xNum;\n\tLONG xDenom;\n\tLONG yNum;\n\tLONG yDenom;\n} EMRSCALEVIEWPORTEXTEX,*PEMRSCALEVIEWPORTEXTEX,\nEMRSCALEWINDOWEXTEX,*PEMRSCALEWINDOWEXTEX;\ntypedef struct tagEMRSELECTCOLORSPACE {\n\tEMR emr;\n\tDWORD ihCS;\n} EMRSELECTCOLORSPACE,*PEMRSELECTCOLORSPACE,\nEMRDELETECOLORSPACE,*PEMRDELETECOLORSPACE;\ntypedef struct tagEMRSELECTOBJECT {\n\tEMR emr;\n\tDWORD ihObject;\n} EMRSELECTOBJECT,*PEMRSELECTOBJECT,\nEMRDELETEOBJECT,*PEMRDELETEOBJECT;\ntypedef struct tagEMRSELECTPALETTE {\n\tEMR emr;\n\tDWORD ihPal;\n} EMRSELECTPALETTE,*PEMRSELECTPALETTE;\ntypedef struct tagEMRSETARCDIRECTION {\n\tEMR emr;\n\tDWORD iArcDirection;\n} EMRSETARCDIRECTION,*PEMRSETARCDIRECTION;\ntypedef struct tagEMRSETTEXTCOLOR {\n\tEMR emr;\n\tCOLORREF crColor;\n} EMRSETBKCOLOR,*PEMRSETBKCOLOR,\nEMRSETTEXTCOLOR,*PEMRSETTEXTCOLOR;\ntypedef struct tagEMRSETCOLORADJUSTMENT {\n\tEMR emr;\n\tCOLORADJUSTMENT ColorAdjustment;\n} EMRSETCOLORADJUSTMENT,*PEMRSETCOLORADJUSTMENT;\ntypedef struct tagEMRSETDIBITSTODEVICE {\n\tEMR emr;\n\tRECTL rclBounds;\n\tLONG xDest;\n\tLONG yDest;\n\tLONG xSrc;\n\tLONG ySrc;\n\tLONG cxSrc;\n\tLONG cySrc;\n\tDWORD offBmiSrc;\n\tDWORD cbBmiSrc;\n\tDWORD offBitsSrc;\n\tDWORD cbBitsSrc;\n\tDWORD iUsageSrc;\n\tDWORD iStartScan;\n\tDWORD cScans;\n} EMRSETDIBITSTODEVICE,*PEMRSETDIBITSTODEVICE;\ntypedef struct tagEMRSETMAPPERFLAGS {\n\tEMR emr;\n\tDWORD dwFlags;\n} EMRSETMAPPERFLAGS,*PEMRSETMAPPERFLAGS;\ntypedef struct tagEMRSETMITERLIMIT {\n\tEMR emr;\n\tFLOAT eMiterLimit;\n} EMRSETMITERLIMIT,*PEMRSETMITERLIMIT;\ntypedef struct tagEMRSETPALETTEENTRIES {\n\tEMR emr;\n\tDWORD ihPal;\n\tDWORD iStart;\n\tDWORD cEntries;\n\tPALETTEENTRY aPalEntries[1];\n} EMRSETPALETTEENTRIES,*PEMRSETPALETTEENTRIES;\ntypedef struct tagEMRSETPIXELV {\n\tEMR emr;\n\tPOINTL ptlPixel;\n\tCOLORREF crColor;\n} EMRSETPIXELV,*PEMRSETPIXELV;\ntypedef struct tagEMRSETVIEWPORTEXTEX {\n\tEMR emr;\n\tSIZEL szlExtent;\n} EMRSETVIEWPORTEXTEX,*PEMRSETVIEWPORTEXTEX,\nEMRSETWINDOWEXTEX,*PEMRSETWINDOWEXTEX;\ntypedef struct tagEMRSETVIEWPORTORGEX {\n\tEMR emr;\n\tPOINTL ptlOrigin;\n} EMRSETVIEWPORTORGEX,*PEMRSETVIEWPORTORGEX,\nEMRSETWINDOWORGEX,*PEMRSETWINDOWORGEX,\nEMRSETBRUSHORGEX,*PEMRSETBRUSHORGEX;\ntypedef struct tagEMRSETWORLDTRANSFORM {\n\tEMR emr;\n\tXFORM xform;\n} EMRSETWORLDTRANSFORM,*PEMRSETWORLDTRANSFORM;\ntypedef struct tagEMRSTRETCHBLT {\n\tEMR emr;\n\tRECTL rclBounds;\n\tLONG xDest;\n\tLONG yDest;\n\tLONG cxDest;\n\tLONG cyDest;\n\tDWORD dwRop;\n\tLONG xSrc;\n\tLONG ySrc;\n\tXFORM xformSrc;\n\tCOLORREF crBkColorSrc;\n\tDWORD iUsageSrc;\n\tDWORD offBmiSrc;\n\tDWORD cbBmiSrc;\n\tDWORD offBitsSrc;\n\tDWORD cbBitsSrc;\n\tLONG cxSrc;\n\tLONG cySrc;\n} EMRSTRETCHBLT,*PEMRSTRETCHBLT;\ntypedef struct tagEMRSTRETCHDIBITS {\n\tEMR emr;\n\tRECTL rclBounds;\n\tLONG xDest;\n\tLONG yDest;\n\tLONG xSrc;\n\tLONG ySrc;\n\tLONG cxSrc;\n\tLONG cySrc;\n\tDWORD offBmiSrc;\n\tDWORD cbBmiSrc;\n\tDWORD offBitsSrc;\n\tDWORD cbBitsSrc;\n\tDWORD iUsageSrc;\n\tDWORD dwRop;\n\tLONG cxDest;\n\tLONG cyDest;\n} EMRSTRETCHDIBITS,*PEMRSTRETCHDIBITS;\ntypedef struct tagABORTPATH {\n\tEMR emr;\n} EMRABORTPATH,*PEMRABORTPATH,\nEMRBEGINPATH,*PEMRBEGINPATH,\nEMRENDPATH,*PEMRENDPATH,\nEMRCLOSEFIGURE,*PEMRCLOSEFIGURE,\nEMRFLATTENPATH,*PEMRFLATTENPATH,\nEMRWIDENPATH,*PEMRWIDENPATH,\nEMRSETMETARGN,*PEMRSETMETARGN,\nEMRSAVEDC,*PEMRSAVEDC,\nEMRREALIZEPALETTE,*PEMRREALIZEPALETTE;\ntypedef struct tagEMRSELECTCLIPPATH {\n\tEMR emr;\n\tDWORD iMode;\n} EMRSELECTCLIPPATH,*PEMRSELECTCLIPPATH,\nEMRSETBKMODE,*PEMRSETBKMODE,\nEMRSETMAPMODE,*PEMRSETMAPMODE,\nEMRSETPOLYFILLMODE,*PEMRSETPOLYFILLMODE,\nEMRSETROP2,*PEMRSETROP2,\nEMRSETSTRETCHBLTMODE,*PEMRSETSTRETCHBLTMODE,\nEMRSETTEXTALIGN,*PEMRSETTEXTALIGN,\nEMRENABLEICM,*PEMRENABLEICM;\ntypedef struct tagNMHDR {\n\tHWND hwndFrom;\n\tUINT idFrom;\n\tUINT code;\n} NMHDR;\ntypedef struct tagNMIPADDRESS { NMHDR hdr; int iField; int iValue; } NMIPADDRESS, *LPNMIPADDRESS;\ntypedef NMHDR *LPNMHDR;\ntypedef struct tagENHMETAHEADER {\n\tDWORD iType;\n\tDWORD nSize;\n\tRECTL rclBounds;\n\tRECTL rclFrame;\n\tDWORD dSignature;\n\tDWORD nVersion;\n\tDWORD nBytes;\n\tDWORD nRecords;\n\tWORD nHandles;\n\tWORD sReserved;\n\tDWORD nDescription;\n\tDWORD offDescription;\n\tDWORD nPalEntries;\n\tSIZEL szlDevice;\n\tSIZEL szlMillimeters;\n} ENHMETAHEADER,*LPENHMETAHEADER;\ntypedef struct tagENHMETARECORD {\n\tDWORD iType;\n\tDWORD nSize;\n\tDWORD dParm[1];\n} ENHMETARECORD,*LPENHMETARECORD;\ntypedef struct tagENUMLOGFONT {\n\tLOGFONT elfLogFont;\n\tBCHAR elfFullName[LF_FULLFACESIZE];\n\tBCHAR elfStyle[LF_FACESIZE];\n} ENUMLOGFONT;\ntypedef struct tagENUMLOGFONTEX {\n\tLOGFONT elfLogFont;\n\tBCHAR elfFullName[LF_FULLFACESIZE];\n\tBCHAR elfStyle[LF_FACESIZE];\n\tBCHAR elfScript[LF_FACESIZE];\n} ENUMLOGFONTEX;\ntypedef struct _EVENTLOGRECORD {\n\tDWORD Length;\n\tDWORD Reserved;\n\tDWORD RecordNumber;\n\tDWORD TimeGenerated;\n\tDWORD TimeWritten;\n\tDWORD EventID;\n\tWORD EventType;\n\tWORD NumStrings;\n\tWORD EventCategory;\n\tWORD ReservedFlags;\n\tDWORD ClosingRecordNumber;\n\tDWORD StringOffset;\n\tDWORD UserSidLength;\n\tDWORD UserSidOffset;\n\tDWORD DataLength;\n\tDWORD DataOffset;\n} EVENTLOGRECORD;\ntypedef struct tagEVENTMSG {\n\tUINT message;\n\tUINT paramL;\n\tUINT paramH;\n\tDWORD time;\n\tHWND hwnd;\n} EVENTMSG;\ntypedef PVOID PACCESS_TOKEN;\ntypedef ACCESS_MASK *PACCESS_MASK;\ntypedef struct _EXT_BUTTON {\n\tWORD idCommand;\n\tWORD idsHelp;\n\tWORD fsStyle;\n} EXT_BUTTON,*LPEXT_BUTTON;\ntypedef struct tagFILTERKEYS {\n\tUINT cbSize;\n\tDWORD dwFlags;\n\tDWORD iWaitMSec;\n\tDWORD iDelayMSec;\n\tDWORD iRepeatMSec;\n\tDWORD iBounceMSec;\n} FILTERKEYS;\ntypedef struct _FIND_NAME_BUFFER {\n\tUCHAR length;\n\tUCHAR access_control;\n\tUCHAR frame_control;\n\tUCHAR destination_addr[6];\n\tUCHAR source_addr[6];\n\tUCHAR routing_info[18];\n} FIND_NAME_BUFFER;\ntypedef struct _FIND_NAME_HEADER {\n\tWORD node_count;\n\tUCHAR reserved;\n\tUCHAR unique_group;\n} FIND_NAME_HEADER;\ntypedef struct {\n\tDWORD lStructSize;\n\tHWND hwndOwner;\n\tHINSTANCE hInstance;\n\tDWORD Flags;\n\tLPTSTR lpstrFindWhat;\n\tLPTSTR lpstrReplaceWith;\n\tWORD wFindWhatLen;\n\tWORD wReplaceWithLen;\n\tLPARAM lCustData;\n\tLPFRHOOKPROC lpfnHook;\n\tLPCTSTR lpTemplateName;\n} FINDREPLACE,*LPFINDREPLACE;\n#ifndef __FINDTEXT_DEFINED\n#define __FINDTEXT_DEFINED\ntypedef struct _findtext {\n\tCHARRANGE chrg;\n\tLPCSTR lpstrText;\n} FINDTEXT;\n#endif\ntypedef struct _findtextex {\n\tCHARRANGE chrg;\n\tLPSTR lpstrText;\n\tCHARRANGE chrgText;\n} FINDTEXTEX;\ntypedef struct _FMS_GETDRIVEINFO {\n\tDWORD dwTotalSpace;\n\tDWORD dwFreeSpace;\n\tTCHAR szPath[260];\n\tTCHAR szVolume[14];\n\tTCHAR szShare[128];\n} FMS_GETDRIVEINFO;\ntypedef struct _FMS_GETFILESEL {\n\tFILETIME ftTime;\n\tDWORD dwSize;\n\tBYTE bAttr;\n\tTCHAR szName[260];\n} FMS_GETFILESEL;\ntypedef struct _FMS_LOAD {\n\tDWORD dwSize;\n\tTCHAR szMenuName[MENU_TEXT_LEN];\n\tHMENU hMenu;\n\tUINT wMenuDelta;\n} FMS_LOAD;\ntypedef struct _FMS_TOOLBARLOAD {\n\tDWORD dwSize;\n\tLPEXT_BUTTON lpButtons;\n\tWORD cButtons;\n\tWORD cBitmaps;\n\tWORD idBitmap;\n\tHBITMAP hBitmap;\n} FMS_TOOLBARLOAD;\ntypedef struct _FOCUS_EVENT_RECORD {\n\tBOOL bSetFocus;\n} FOCUS_EVENT_RECORD;\ntypedef struct tagGCP_RESULTS {\n\tDWORD lStructSize;\n\tLPTSTR lpOutString;\n\tUINT *lpOrder;\n\tINT *lpDx;\n\tINT *lpCaretPos;\n\tLPTSTR lpClass;\n\tUINT *lpGlyphs;\n\tUINT nGlyphs;\n\tUINT nMaxFit;\n} GCP_RESULTS,*LPGCP_RESULTS;\ntypedef struct _GENERIC_MAPPING {\n\tACCESS_MASK GenericRead;\n\tACCESS_MASK GenericWrite;\n\tACCESS_MASK GenericExecute;\n\tACCESS_MASK GenericAll;\n} GENERIC_MAPPING,*PGENERIC_MAPPING;\ntypedef struct _GLYPHMETRICS {\n\tUINT gmBlackBoxX;\n\tUINT gmBlackBoxY;\n\tPOINT gmptGlyphOrigin;\n\tshort gmCellIncX;\n\tshort gmCellIncY;\n} GLYPHMETRICS,*LPGLYPHMETRICS;\ntypedef struct tagHANDLETABLE {\n\tHGDIOBJ objectHandle[1];\n} HANDLETABLE,*LPHANDLETABLE;\ntypedef struct _HD_HITTESTINFO {\n\tPOINT pt;\n\tUINT flags;\n\tint iItem;\n} HD_HITTESTINFO,*LPHDHITTESTINFO;\n#define HDHITTESTINFO\tHD_HITTESTINFO\ntypedef struct _HD_ITEM {\n\tUINT mask;\n\tint cxy;\n\tLPTSTR pszText;\n\tHBITMAP hbm;\n\tint cchTextMax;\n\tint fmt;\n\tLPARAM lParam;\n} HD_ITEM;\ntypedef struct _WINDOWPOS {\n\tHWND hwnd;\n\tHWND hwndInsertAfter;\n\tint x;\n\tint y;\n\tint cx;\n\tint cy;\n\tUINT flags;\n} WINDOWPOS,*PWINDOWPOS,*LPWINDOWPOS;\ntypedef struct _HD_LAYOUT {\n\tRECT *prc;\n\tWINDOWPOS *pwpos;\n} HD_LAYOUT,*LPHDLAYOUT;\n#define HDLAYOUT HD_LAYOUT\ntypedef struct _HD_NOTIFY {\n\tNMHDR hdr;\n\tint iItem;\n\tint iButton;\n\tHD_ITEM *pitem;\n} HD_NOTIFY;\ntypedef struct _HD_ITEMA {\n\tUINT\tmask;\n\tint\tcxy;\n\tLPSTR\tpszText;\n\tHBITMAP hbm;\n\tint\tcchTextMax;\n\tint\tfmt;\n\tLPARAM lParam;\n\tint\tiImage;\n\tint\tiOrder;\n\tUINT\ttype;\n\tLPVOID\tpvFilter;\n} HDITEMA, *LPHDITEMA;\n#define HDITEMA_V1_SIZE CCSIZEOF_STRUCT(HDITEMA, lParam)\n#define HDITEMW_V1_SIZE CCSIZEOF_STRUCT(HDITEMW, lParam)\ntypedef struct _HD_ITEMW {\n\tUINT\tmask;\n\tint\tcxy;\n\tLPWSTR\tpszText;\n\tHBITMAP hbm;\n\tint\tcchTextMax;\n\tint\tfmt;\n\tLPARAM lParam;\n\tint\tiImage;\n\tint\tiOrder;\n\tUINT\ttype;\n\tLPVOID pvFilter;\n} HDITEMW, *LPHDITEMW;\n#ifdef UNICODE\n#define HDITEM HDITEMW\n#define LPHDITEM LPHDITEMW\n#define HDITEM_V1_SIZE HDITEMW_V1_SIZE\n#else\n#define HDITEM HDITEMA\n#define LPHDITEM LPHDITEMA\n#define HDITEM_V1_SIZE HDITEMA_V1_SIZE\n#endif\ntypedef struct tagNMHEADERA {\n\tNMHDR\thdr;\n\tint\tiItem;\n\tint\tiButton;\n\tHDITEMA *pitem;\n} NMHEADERA,* LPNMHEADERA;\ntypedef struct tagNMHEADERW {\n\tNMHDR\thdr;\n\tint\tiItem;\n\tint\tiButton;\n\tHDITEMW *pitem;\n} NMHEADERW,*LPNMHEADERW;\n#ifdef UNICODE\n#define NMHEADER\tNMHEADERW\n#define LPNMHEADER\tLPNMHEADERW\n#else\n#define NMHEADER\tNMHEADERA\n#define LPNMHEADER\tLPNMHEADERA\n#endif\ntypedef struct tagHELPINFO {\n\tUINT cbSize;\n\tint iContextType;\n\tint iCtrlId;\n\tHANDLE hItemHandle;\n\tDWORD dwContextId;\n\tPOINT MousePos;\n} HELPINFO,*LPHELPINFO;\ntypedef struct {\n\tint wStructSize;\n\tint x;\n\tint y;\n\tint dx;\n\tint dy;\n\tint wMax;\n\tTCHAR rgchMember[2];\n} HELPWININFO;\ntypedef struct tagHIGHCONTRAST {\n\tUINT cbSize;\n\tDWORD dwFlags;\n\tLPTSTR lpszDefaultScheme;\n} HIGHCONTRAST,*LPHIGHCONTRAST;\ntypedef struct tagHSZPAIR {\n\tHSZ hszSvc;\n\tHSZ hszTopic;\n} HSZPAIR;\ntypedef struct _ICONINFO {\n\tBOOL fIcon;\n\tDWORD xHotspot;\n\tDWORD yHotspot;\n\tHBITMAP hbmMask;\n\tHBITMAP hbmColor;\n} ICONINFO,*PICONINFO;\ntypedef struct tagICONMETRICS {\n\tUINT cbSize;\n\tint iHorzSpacing;\n\tint iVertSpacing;\n\tint iTitleWrap;\n\tLOGFONT lfFont;\n} ICONMETRICS,*LPICONMETRICS;\ntypedef struct _IMAGEINFO {\n\tHBITMAP hbmImage;\n\tHBITMAP hbmMask;\n\tint Unused1;\n\tint Unused2;\n\tRECT rcImage;\n} IMAGEINFO;\ntypedef struct _KEY_EVENT_RECORD {\n\tBOOL bKeyDown;\n\tWORD wRepeatCount;\n\tWORD wVirtualKeyCode;\n\tWORD wVirtualScanCode;\n\tunion { WCHAR UnicodeChar; CHAR AsciiChar; } uChar;\n\tDWORD dwControlKeyState;\n} KEY_EVENT_RECORD;\ntypedef struct _MOUSE_EVENT_RECORD {\n\tCOORD dwMousePosition;\n\tDWORD dwButtonState;\n\tDWORD dwControlKeyState;\n\tDWORD dwEventFlags;\n} MOUSE_EVENT_RECORD;\ntypedef struct _WINDOW_BUFFER_SIZE_RECORD {\n\tCOORD dwSize;\n} WINDOW_BUFFER_SIZE_RECORD;\ntypedef struct _MENU_EVENT_RECORD {\n\tUINT dwCommandId;\n} MENU_EVENT_RECORD,*PMENU_EVENT_RECORD;\ntypedef struct _INPUT_RECORD {\n\tWORD EventType;\n\tWORD __alignmentDummy;\n\tunion {\n\t\tKEY_EVENT_RECORD KeyEvent;\n\t\tMOUSE_EVENT_RECORD MouseEvent;\n\t\tWINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;\n\t\tMENU_EVENT_RECORD MenuEvent;\n\t\tFOCUS_EVENT_RECORD FocusEvent;\n\t} Event;\n} INPUT_RECORD,*PINPUT_RECORD;\ntypedef struct _SYSTEMTIME {\n\tWORD wYear;\n\tWORD wMonth;\n\tWORD wDayOfWeek;\n\tWORD wDay;\n\tWORD wHour;\n\tWORD wMinute;\n\tWORD wSecond;\n\tWORD wMilliseconds;\n} SYSTEMTIME,*LPSYSTEMTIME,*PSYSTEMTIME;\ntypedef struct _SID_IDENTIFIER_AUTHORITY {\n\tBYTE Value[6];\n} SID_IDENTIFIER_AUTHORITY,*PSID_IDENTIFIER_AUTHORITY,\n*LPSID_IDENTIFIER_AUTHORITY;\ntypedef struct _SID {\n\tBYTE Revision;\n\tBYTE SubAuthorityCount;\n\tSID_IDENTIFIER_AUTHORITY IdentifierAuthority;\n\tDWORD SubAuthority[ANYSIZE_ARRAY];\n} SID,*PSID;\n#define SID_REVISION              (1)\n#define SID_MAX_SUB_AUTHORITIES       (15)\n#define SID_RECOMMENDED_SUB_AUTHORITIES (1)\n#define SECURITY_MAX_SID_SIZE (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))\ntypedef WORD SECURITY_DESCRIPTOR_CONTROL,*PSECURITY_DESCRIPTOR_CONTROL;\ntypedef struct _SECURITY_DESCRIPTOR_RELATIVE {\n\tBYTE Revision;\n\tBYTE Sbz1;\n\tSECURITY_DESCRIPTOR_CONTROL Control;\n\tDWORD Owner;\n\tDWORD Group;\n\tDWORD Sacl;\n\tDWORD Dacl;\n} SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;\ntypedef struct _SECURITY_DESCRIPTOR {\n\tBYTE Revision;\n\tBYTE Sbz1;\n\tSECURITY_DESCRIPTOR_CONTROL Control;\n\tPSID Owner;\n\tPSID Group;\n\tPACL Sacl;\n\tPACL Dacl;\n} SECURITY_DESCRIPTOR,*PSECURITY_DESCRIPTOR;\ntypedef struct tagKERNINGPAIR {\n\tWORD wFirst;\n\tWORD wSecond;\n\tint iKernAmount;\n} KERNINGPAIR,*LPKERNINGPAIR;\ntypedef struct _LANA_ENUM {\n\tUCHAR length;\n\tUCHAR lana[MAX_LANA];\n} LANA_ENUM;\ntypedef struct _LDT_ENTRY {\n\tWORD LimitLow;\n\tWORD BaseLow;\n\tunion {\n\t\tstruct {\n\t\t\tBYTE BaseMid;\n\t\t\tBYTE Flags1;\n\t\t\tBYTE Flags2;\n\t\t\tBYTE BaseHi;\n\t\t} Bytes;\n\t\tstruct {\n\t\t\tunsigned BaseMid:8;\n\t\t\tunsigned Type:5;\n\t\t\tunsigned Dpl:2;\n\t\t\tunsigned Pres:1;\n\t\t\tunsigned LimitHi:4;\n\t\t\tunsigned Sys:1;\n\t\t\tunsigned Reserved_0:1;\n\t\t\tunsigned Default_Big:1;\n\t\t\tunsigned Granularity:1;\n\t\t\tunsigned BaseHi:8;\n\t\t} Bits;\n\t} HighWord;\n} LDT_ENTRY,*PLDT_ENTRY,*LPLDT_ENTRY;\ntypedef struct tagLOCALESIGNATURE {\n\tDWORD lsUsb[4];\n\tDWORD lsCsbDefault[2];\n\tDWORD lsCsbSupported[2];\n} LOCALESIGNATURE;\ntypedef long FXPT16DOT16,*LPFXPT16DOT16;\ntypedef LARGE_INTEGER LUID,*PLUID;\ntypedef struct _LUID_AND_ATTRIBUTES {\n\tLUID Luid;\n\tDWORD Attributes;\n} LUID_AND_ATTRIBUTES,*PLUID_AND_ATTRIBUTES;\ntypedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];\ntypedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;\ntypedef struct _LV_COLUMN {\n\tUINT mask;\n\tint fmt;\n\tint cx;\n\tLPTSTR pszText;\n\tint cchTextMax;\n\tint iSubItem;\n} LV_COLUMN;\ntypedef struct _LV_ITEM {\n\tUINT mask;\n\tint iItem;\n\tint iSubItem;\n\tUINT state;\n\tUINT stateMask;\n\tLPTSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tLPARAM lParam;\n} LV_ITEM;\ntypedef struct tagLV_DISPINFO {\n\tNMHDR hdr;\n\tLV_ITEM item;\n} LV_DISPINFO;\ntypedef struct _LV_FINDINFO {\n\tUINT flags;\n\tLPCTSTR psz;\n\tLPARAM lParam;\n\tPOINT pt;\n\tUINT vkDirection;\n} LV_FINDINFO;\ntypedef struct _LV_HITTESTINFO {\n\tPOINT pt;\n\tUINT flags;\n\tint iItem;\n} LV_HITTESTINFO;\ntypedef struct tagLV_KEYDOWN {\n\tNMHDR hdr;\n\tWORD wVKey;\n\tUINT flags;\n} LV_KEYDOWN;\ntypedef struct _MAT2 {\n\tFIXED eM11;\n\tFIXED eM12;\n\tFIXED eM21;\n\tFIXED eM22;\n} MAT2;\ntypedef struct tagMDICREATESTRUCT {\n\tLPCTSTR szClass;\n\tLPCTSTR szTitle;\n\tHANDLE hOwner;\n\tint x;\n\tint y;\n\tint cx;\n\tint cy;\n\tDWORD style;\n\tLPARAM lParam;\n} MDICREATESTRUCT;\ntypedef MDICREATESTRUCT *LPMDICREATESTRUCT;\ntypedef struct tagMEASUREITEMSTRUCT {\n\tUINT CtlType;\n\tUINT CtlID;\n\tUINT itemID;\n\tUINT itemWidth;\n\tUINT itemHeight;\n\tDWORD itemData;\n} MEASUREITEMSTRUCT;\ntypedef MEASUREITEMSTRUCT *LPMEASUREITEMSTRUCT,*PMEASUREITEMSTRUCT;\ntypedef struct _MEMORY_BASIC_INFORMATION {\n\tPVOID BaseAddress;\n\tPVOID AllocationBase;\n\tDWORD AllocationProtect;\n\tDWORD RegionSize;\n\tDWORD State;\n\tDWORD Protect;\n\tDWORD Type;\n} MEMORY_BASIC_INFORMATION;\ntypedef MEMORY_BASIC_INFORMATION *PMEMORY_BASIC_INFORMATION;\ntypedef struct _MEMORYSTATUS {\n\tDWORD dwLength;\n\tDWORD dwMemoryLoad;\n\tDWORD dwTotalPhys;\n\tDWORD dwAvailPhys;\n\tDWORD dwTotalPageFile;\n\tDWORD dwAvailPageFile;\n\tDWORD dwTotalVirtual;\n\tDWORD dwAvailVirtual;\n} MEMORYSTATUS,*LPMEMORYSTATUS;\ntypedef struct _MEMORYSTATUSEX {\n\tDWORD dwLength;\n\tDWORD dwMemoryLoad;\n\tlong long ullTotalPhys;\n\tlong long ullAvailPhys;\n\tlong long ullTotalPageFile;\n\tlong long ullAvailPageFile;\n\tlong long ullTotalVirtual;\n\tlong long ullAvailVirtual;\n\tlong long ullAvailExtendedVirtual;\n} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;\ntypedef struct {\n\tWORD wVersion;\n\tWORD wOffset;\n\tDWORD dwHelpId;\n} MENUEX_TEMPLATE_HEADER;\ntypedef struct {\n\tDWORD dwType;\n\tDWORD dwState;\n\tUINT uId;\n\tBYTE bResInfo;\n\tWCHAR szText[1];\n\tDWORD dwHelpId;\n} MENUEX_TEMPLATE_ITEM;\ntypedef struct tagMENUITEMINFO {\n\tUINT cbSize;\n\tUINT fMask;\n\tUINT fType;\n\tUINT fState;\n\tUINT wID;\n\tHMENU hSubMenu;\n\tHBITMAP hbmpChecked;\n\tHBITMAP hbmpUnchecked;\n\tDWORD dwItemData;\n\tLPTSTR dwTypeData;\n\tUINT cch;\n} MENUITEMINFO,*LPMENUITEMINFO;\ntypedef MENUITEMINFO CONST *LPCMENUITEMINFO;\ntypedef struct {\n\tWORD mtOption;\n\tWORD mtID;\n\tWCHAR mtString[1];\n} MENUITEMTEMPLATE;\ntypedef struct {\n\tWORD versionNumber;\n\tWORD offset;\n} MENUITEMTEMPLATEHEADER;\ntypedef VOID MENUTEMPLATE,*LPMENUTEMPLATE;\ntypedef struct tagMETAFILEPICT {\n\tLONG mm;\n\tLONG xExt;\n\tLONG yExt;\n\tHMETAFILE hMF;\n} METAFILEPICT,*LPMETAFILEPICT;\ntypedef struct tagMETAHEADER {\n\tWORD mtType;\n\tWORD mtHeaderSize;\n\tWORD mtVersion;\n\tDWORD mtSize;\n\tWORD mtNoObjects;\n\tDWORD mtMaxRecord;\n\tWORD mtNoParameters;\n} METAHEADER,*LPMETAHEADER;\ntypedef struct tagMETARECORD {\n\tDWORD rdSize;\n\tWORD rdFunction;\n\tWORD rdParm[1];\n} METARECORD,*LPMETARECORD;\ntypedef struct tagMINIMIZEDMETRICS {\n\tUINT cbSize;\n\tint iWidth;\n\tint iHorzGap;\n\tint iVertGap;\n\tint iArrange;\n} MINIMIZEDMETRICS,*LPMINIMIZEDMETRICS;\ntypedef struct tagMINMAXINFO {\n\tPOINT ptReserved;\n\tPOINT ptMaxSize;\n\tPOINT ptMaxPosition;\n\tPOINT ptMinTrackSize;\n\tPOINT ptMaxTrackSize;\n} MINMAXINFO,*LPMINMAXINFO;\ntypedef struct modemdevcaps_tag {\n\tDWORD dwActualSize;\n\tDWORD dwRequiredSize;\n\tDWORD dwDevSpecificOffset;\n\tDWORD dwDevSpecificSize;\n\tDWORD dwModemProviderVersion;\n\tDWORD dwModemManufacturerOffset;\n\tDWORD dwModemManufacturerSize;\n\tDWORD dwModemModelOffset;\n\tDWORD dwModemModelSize;\n\tDWORD dwModemVersionOffset;\n\tDWORD dwModemVersionSize;\n\tDWORD dwDialOptions;\n\tDWORD dwCallSetupFailTimer;\n\tDWORD dwInactivityTimeout;\n\tDWORD dwSpeakerVolume;\n\tDWORD dwSpeakerMode;\n\tDWORD dwModemOptions;\n\tDWORD dwMaxDTERate;\n\tDWORD dwMaxDCERate;\n\tBYTE abVariablePortion[1];\n} MODEMDEVCAPS,*PMODEMDEVCAPS,*LPMODEMDEVCAPS;\ntypedef struct modemsettings_tag {\n\tDWORD dwActualSize;\n\tDWORD dwRequiredSize;\n\tDWORD dwDevSpecificOffset;\n\tDWORD dwDevSpecificSize;\n\tDWORD dwCallSetupFailTimer;\n\tDWORD dwInactivityTimeout;\n\tDWORD dwSpeakerVolume;\n\tDWORD dwSpeakerMode;\n\tDWORD dwPreferredModemOptions;\n\tDWORD dwNegotiatedModemOptions;\n\tDWORD dwNegotiatedDCERate;\n\tBYTE abVariablePortion[1];\n} MODEMSETTINGS,*PMODEMSETTINGS,*LPMODEMSETTINGS;\ntypedef struct tagMONCBSTRUCT {\n\tUINT cb;\n\tDWORD dwTime;\n\tHANDLE hTask;\n\tDWORD dwRet;\n\tUINT wType;\n\tUINT wFmt;\n\tHCONV hConv;\n\tHSZ hsz1;\n\tHSZ hsz2;\n\tHDDEDATA hData;\n\tDWORD dwData1;\n\tDWORD dwData2;\n\tCONVCONTEXT cc;\n\tDWORD cbData;\n\tDWORD Data[8];\n} MONCBSTRUCT;\ntypedef struct tagMONCONVSTRUCT {\n\tUINT cb;\n\tBOOL fConnect;\n\tDWORD dwTime;\n\tHANDLE hTask;\n\tHSZ hszSvc;\n\tHSZ hszTopic;\n\tHCONV hConvClient;\n\tHCONV hConvServer;\n} MONCONVSTRUCT;\ntypedef struct tagMONERRSTRUCT {\n\tUINT cb;\n\tUINT wLastError;\n\tDWORD dwTime;\n\tHANDLE hTask;\n} MONERRSTRUCT;\ntypedef struct tagMONHSZSTRUCT {\n\tUINT cb;\n\tBOOL fsAction;\n\tDWORD dwTime;\n\tHSZ hsz;\n\tHANDLE hTask;\n\tTCHAR str[1];\n} MONHSZSTRUCT;\ntypedef struct tagMONLINKSTRUCT {\n\tUINT cb;\n\tDWORD dwTime;\n\tHANDLE hTask;\n\tBOOL fEstablished;\n\tBOOL fNoData;\n\tHSZ hszSvc;\n\tHSZ hszTopic;\n\tHSZ hszItem;\n\tUINT wFmt;\n\tBOOL fServer;\n\tHCONV hConvServer;\n\tHCONV hConvClient;\n} MONLINKSTRUCT;\ntypedef struct tagMONMSGSTRUCT {\n\tUINT cb;\n\tHWND hwndTo;\n\tDWORD dwTime;\n\tHANDLE hTask;\n\tUINT wMsg;\n\tWPARAM wParam;\n\tLPARAM lParam;\n\tDDEML_MSG_HOOK_DATA dmhd;\n} MONMSGSTRUCT;\ntypedef struct tagMOUSEHOOKSTRUCT {\n\tPOINT pt;\n\tHWND hwnd;\n\tUINT wHitTestCode;\n\tDWORD dwExtraInfo;\n} MOUSEHOOKSTRUCT,*PMOUSEHOOKSTRUCT;\ntypedef struct tagMOUSEHOOKSTRUCTEX {\n\tPOINT pt;\n\tHWND hwnd;\n\tUINT wHitTestCode;\n\tDWORD dwExtraInfo;\n\tDWORD mouseData;\n} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;\ntypedef struct _MOUSEKEYS {\n\tDWORD cbSize;\n\tDWORD dwFlags;\n\tDWORD iMaxSpeed;\n\tDWORD iTimeToMaxSpeed;\n\tDWORD iCtrlSpeed;\n\tDWORD dwReserved1;\n\tDWORD dwReserved2;\n} MOUSEKEYS;\ntypedef struct tagMSG {\n\tHWND hwnd;\n\tUINT message;\n\tWPARAM wParam;\n\tLPARAM lParam;\n\tDWORD time;\n\tPOINT pt;\n} MSG,*LPMSG,*PMSG;\ntypedef void (CALLBACK * MSGBOXCALLBACK) (LPHELPINFO lpHelpInfo);\ntypedef struct {\n\tUINT cbSize;\n\tHWND hwndOwner;\n\tHINSTANCE hInstance;\n\tLPCTSTR lpszText;\n\tLPCTSTR lpszCaption;\n\tDWORD dwStyle;\n\tLPCTSTR lpszIcon;\n\tDWORD dwContextHelpId;\n\tMSGBOXCALLBACK lpfnMsgBoxCallback;\n\tDWORD dwLanguageId;\n} MSGBOXPARAMS,*PMSGBOXPARAMS,*LPMSGBOXPARAMS;\ntypedef struct tagMULTIKEYHELP {\n\tDWORD mkSize;\n\tTCHAR mkKeylist;\n\tTCHAR szKeyphrase[1];\n} MULTIKEYHELP;\ntypedef struct _NAME_BUFFER {\n\tUCHAR name[NCBNAMSZ];\n\tUCHAR name_num;\n\tUCHAR name_flags;\n} NAME_BUFFER;\ntypedef struct _NCB {\n\tUCHAR ncb_command;\n\tUCHAR ncb_retcode;\n\tUCHAR ncb_lsn;\n\tUCHAR ncb_num;\n\tPUCHAR ncb_buffer;\n\tWORD ncb_length;\n\tUCHAR ncb_callname[NCBNAMSZ];\n\tUCHAR ncb_name[NCBNAMSZ];\n\tUCHAR ncb_rto;\n\tUCHAR ncb_sto;\n\tvoid (*ncb_post) (struct _NCB *);\n\tUCHAR ncb_lana_num;\n\tUCHAR ncb_cmd_cplt;\n\tUCHAR ncb_reserve[10];\n\tHANDLE ncb_event;\n} NCB,*PNCB;\ntypedef struct _NCCALCSIZE_PARAMS {\n\tRECT rgrc[3];\n\tPWINDOWPOS lppos;\n} NCCALCSIZE_PARAMS;\ntypedef struct _NDDESHAREINFO {\n\tLONG lRevision;\n\tLPTSTR lpszShareName;\n\tLONG lShareType;\n\tLPTSTR lpszAppTopicList;\n\tLONG fSharedFlag;\n\tLONG fService;\n\tLONG fStartAppFlag;\n\tLONG nCmdShow;\n\tLONG qModifyId[2];\n\tLONG cNumItems;\n\tLPTSTR lpszItemList;\n} NDDESHAREINFO;\n#ifndef _NETRESOURCE_DEFINED\n#define _NETRESOURCE_DEFINED\ntypedef struct _NETRESOURCE {\n\tDWORD dwScope;\n\tDWORD dwType;\n\tDWORD dwDisplayType;\n\tDWORD dwUsage;\n\tLPTSTR lpLocalName;\n\tLPTSTR lpRemoteName;\n\tLPTSTR lpComment;\n\tLPTSTR lpProvider;\n} NETRESOURCE,*LPNETRESOURCE;\n#endif\n#pragma pack(push,4)\ntypedef struct tagNEWTEXTMETRIC {\n\tLONG tmHeight;\n\tLONG tmAscent;\n\tLONG tmDescent;\n\tLONG tmInternalLeading;\n\tLONG tmExternalLeading;\n\tLONG tmAveCharWidth;\n\tLONG tmMaxCharWidth;\n\tLONG tmWeight;\n\tLONG tmOverhang;\n\tLONG tmDigitizedAspectX;\n\tLONG tmDigitizedAspectY;\n\tBCHAR tmFirstChar;\n\tBCHAR tmLastChar;\n\tBCHAR tmDefaultChar;\n\tBCHAR tmBreakChar;\n\tBYTE tmItalic;\n\tBYTE tmUnderlined;\n\tBYTE tmStruckOut;\n\tBYTE tmPitchAndFamily;\n\tBYTE tmCharSet;\n\tDWORD ntmFlags;\n\tUINT ntmSizeEM;\n\tUINT ntmCellHeight;\n\tUINT ntmAvgWidth;\n} NEWTEXTMETRIC;\n#pragma pack(pop)\ntypedef struct tagNEWTEXTMETRICEX {\n\tNEWTEXTMETRIC ntmentm;\n\tFONTSIGNATURE ntmeFontSignature;\n} NEWTEXTMETRICEX;\ntypedef struct tagNM_LISTVIEW {\n\tNMHDR hdr;\n\tint iItem;\n\tint iSubItem;\n\tUINT uNewState;\n\tUINT uOldState;\n\tUINT uChanged;\n\tPOINT ptAction;\n\tLPARAM lParam;\n} NM_LISTVIEW,*LPNM_LISTVIEW;\ntypedef struct _TREEITEM *HTREEITEM;\ntypedef struct tagTVITEMA {\n\tUINT mask;\n\tHTREEITEM hItem;\n\tUINT state;\n\tUINT stateMask;\n\tLPSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tint iSelectedImage;\n\tint cChildren;\n\tLPARAM lParam;\n} TVITEMA, *LPTVITEMA;\ntypedef struct tagTVITEMW {\n\tUINT mask;\n\tHTREEITEM hItem;\n\tUINT state;\n\tUINT stateMask;\n\tLPWSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tint iSelectedImage;\n\tint cChildren;\n\tLPARAM lParam;\n} TVITEMW, *LPTVITEMW;\n#define TV_ITEM\tTVITEM\n#define LPTV_ITEM\tLPTVITEM\n#ifdef UNICODE\n#define TVITEM\tTVITEMW\n#define\tLPTVITEM LPTVITEMW\n#else\n#define TVITEM\tTVITEMA\n#define\tLPTVITEM LPTVITEMA\n#endif\ntypedef struct tagTVITEMEXA {\n\tUINT\tmask;\n\tHTREEITEM hItem;\n\tUINT\tstate;\n\tUINT\tstateMask;\n\tLPSTR\tpszText;\n\tint\tcchTextMax;\n\tint\tiImage;\n\tint\tiSelectedImage;\n\tint\tcChildren;\n\tLPARAM\tlParam;\n\tint\tiIntegral;\n} TVITEMEXA, *LPTVITEMEXA;\ntypedef struct tagTVITEMEXW {\n\tUINT\tmask;\n\tHTREEITEM hItem;\n\tUINT\tstate;\n\tUINT\tstateMask;\n\tLPWSTR\tpszText;\n\tint\tcchTextMax;\n\tint\tiImage;\n\tint\tiSelectedImage;\n\tint\tcChildren;\n\tLPARAM\tlParam;\n\tint\tiIntegral;\n} TVITEMEXW,*LPTVITEMEXW;\ntypedef struct tagTVINSERTSTRUCTA {\n\tHTREEITEM hParent;\n\tHTREEITEM hInsertAfter;\n\tunion {\n\t\tTVITEMEXA itemex;\n\t\tTVITEMA item;\n\t};\n} TVINSERTSTRUCTA,*LPTVINSERTSTRUCTA;\ntypedef struct tagTVINSERTSTRUCTW {\n\tHTREEITEM hParent;\n\tHTREEITEM hInsertAfter;\n\tunion {\n\t\tTVITEMEXW itemex;\n\t\tTVITEMW item;\n\t} ;\n} TVINSERTSTRUCTW,*LPTVINSERTSTRUCTW;\ntypedef struct _NM_TREEVIEW {\n\tNMHDR hdr;\n\tUINT action;\n\tTV_ITEM itemOld;\n\tTV_ITEM itemNew;\n\tPOINT ptDrag;\n} NM_TREEVIEW;\ntypedef NM_TREEVIEW *LPNM_TREEVIEW;\ntypedef NM_TREEVIEW *LPNMTREEVIEW;\ntypedef struct _NM_UPDOWN {\n\tNMHDR hdr;\n\tint iPos;\n\tint iDelta;\n} NMUPDOWN,*LPNMUPDOWN;\ntypedef struct tagNONCLIENTMETRICS {\n\tUINT cbSize;\n\tint iBorderWidth;\n\tint iScrollWidth;\n\tint iScrollHeight;\n\tint iCaptionWidth;\n\tint iCaptionHeight;\n\tLOGFONT lfCaptionFont;\n\tint iSmCaptionWidth;\n\tint iSmCaptionHeight;\n\tLOGFONT lfSmCaptionFont;\n\tint iMenuWidth;\n\tint iMenuHeight;\n\tLOGFONT lfMenuFont;\n\tLOGFONT lfStatusFont;\n\tLOGFONT lfMessageFont;\n} NONCLIENTMETRICS,*LPNONCLIENTMETRICS;\ntypedef struct _SERVICE_ADDRESS {\n\tDWORD dwAddressType;\n\tDWORD dwAddressFlags;\n\tDWORD dwAddressLength;\n\tDWORD dwPrincipalLength;\n\tBYTE *lpAddress;\n\tBYTE *lpPrincipal;\n} SERVICE_ADDRESS;\ntypedef struct _SERVICE_ADDRESSES {\n\tDWORD dwAddressCount;\n\tSERVICE_ADDRESS Addresses[1];\n} SERVICE_ADDRESSES,*LPSERVICE_ADDRESSES;\n#ifndef GUID_DEFINED\ntypedef struct _GUID {\n\tunsigned long Data1;\n\tunsigned short Data2;\n\tunsigned short Data3;\n\tunsigned char Data4[8];\n} GUID,*LPGUID;\ntypedef CONST GUID *LPCGUID;\n#define GUID_DEFINED\n#endif\n#if !defined(__IID_DEFINED__)\n#define __IID_DEFINED__\ntypedef GUID IID;\ntypedef IID *LPIID;\ntypedef IID *REFIID;\ntypedef GUID CLSID,*LPCLSID;\ntypedef CLSID *REFCLSID;\ntypedef GUID *REFGUID;\n#endif\ntypedef struct tagRemHGLOBAL {\n\tlong fNullHGlobal;\n\tunsigned long cbData;\n\tunsigned char data[1]; } RemHGLOBAL;\ntypedef struct tagRemHMETAFILEPICT {\n\tlong mm;\n\tlong xExt;\n\tlong yExt;\n\tunsigned long cbData;\n\tunsigned char data[1];\n}\tRemHMETAFILEPICT;\ntypedef void *HMETAFILEPICT;\ntypedef struct tagRemHENHMETAFILE {\n\tunsigned long cbData;\n\tunsigned char data[1];\n\t} RemHENHMETAFILE;\ntypedef struct tagRemHBITMAP {\n\tunsigned long cbData;\n\tunsigned char data[1];\n}\tRemHBITMAP;\ntypedef struct tagRemHPALETTE {\n\tunsigned long cbData;\n\tunsigned char data[1];\n}\tRemHPALETTE;\ntypedef struct tagRemBRUSH {\n\tunsigned long cbData;\n\tunsigned char data[1];\n}\tRemHBRUSH;\ntypedef struct _numberfmta {\n\tUINT NumDigits;\n\tUINT LeadingZero;\n\tUINT Grouping;\n\tLPSTR lpDecimalSep;\n\tLPSTR lpThousandSep;\n\tUINT NegativeOrder;\n} NUMBERFMTA;\ntypedef struct _numberfmtw {\n\tUINT NumDigits;\n\tUINT LeadingZero;\n\tUINT Grouping;\n\tLPWSTR lpDecimalSep;\n\tLPWSTR lpThousandSep;\n\tUINT NegativeOrder;\n} NUMBERFMTW;\ntypedef struct _OFSTRUCT {\n\tBYTE cBytes;\n\tBYTE fFixedDisk;\n\tWORD nErrCode;\n\tWORD Reserved1;\n\tWORD Reserved2;\n\tCHAR szPathName[OFS_MAXPATHNAME];\n} OFSTRUCT,*LPOFSTRUCT;\ntypedef struct tagOFNA {\n\tDWORD\tlStructSize;\n\tHWND\thwndOwner;\n\tHINSTANCE\thInstance;\n\tLPCSTR\tlpstrFilter;\n\tLPSTR\tlpstrCustomFilter;\n\tDWORD\tnMaxCustFilter;\n\tDWORD\tnFilterIndex;\n\tLPSTR\tlpstrFile;\n\tDWORD\tnMaxFile;\n\tLPSTR\tlpstrFileTitle;\n\tDWORD\tnMaxFileTitle;\n\tLPCSTR\tlpstrInitialDir;\n\tLPCSTR\tlpstrTitle;\n\tDWORD\tFlags;\n\tWORD\tnFileOffset;\n\tWORD\tnFileExtension;\n\tLPCSTR\tlpstrDefExt;\n\tLPARAM\tlCustData;\n\tLPOFNHOOKPROC\tlpfnHook;\n\tLPCSTR\tlpTemplateName;\n} OPENFILENAMEA,*LPOPENFILENAMEA;\ntypedef struct tagOFNW {\n\tDWORD\tlStructSize;\n\tHWND\thwndOwner;\n\tHINSTANCE\thInstance;\n\tLPCWSTR\tlpstrFilter;\n\tLPWSTR\tlpstrCustomFilter;\n\tDWORD\tnMaxCustFilter;\n\tDWORD\tnFilterIndex;\n\tLPWSTR\tlpstrFile;\n\tDWORD\tnMaxFile;\n\tLPWSTR\tlpstrFileTitle;\n\tDWORD\tnMaxFileTitle;\n\tLPCWSTR\tlpstrInitialDir;\n\tLPCWSTR\tlpstrTitle;\n\tDWORD\tFlags;\n\tWORD\tnFileOffset;\n\tWORD\tnFileExtension;\n\tLPCWSTR\tlpstrDefExt;\n\tLPARAM\tlCustData;\n\tLPOFNHOOKPROC\tlpfnHook;\n\tLPCWSTR\tlpTemplateName;\n} OPENFILENAMEW, *LPOPENFILENAMEW;\n#ifdef UNICODE\ntypedef TVITEMEXW TVITEMEX;\ntypedef LPTVITEMEXW LPTVITEMEX;\n#define LPOPENFILENAME LPOPENFILENAMEW\n#define OPENFILENAME OPENFILENAMEW\n#define TVINSERTSTRUCT\t\tTVINSERTSTRUCTW\n#define LPTVINSERTSTRUCT\tLPTVINSERTSTRUCTW\n#define NUMBERFMT\tNUMBERFMTW\n#else\n#define LPOPENFILENAME LPOPENFILENAMEA\n#define OPENFILENAME OPENFILENAMEA\ntypedef TVITEMEXA TVITEMEX;\ntypedef LPTVITEMEXA LPTVITEMEX;\n#define TVINSERTSTRUCT\t\tTVINSERTSTRUCTA\n#define LPTVINSERTSTRUCT\tLPTVINSERTSTRUCTA\n#define NUMBERFMT\tNUMBERFMTA\n#endif\ntypedef struct _OFNOTIFY {\n\tNMHDR hdr;\n\tLPOPENFILENAME lpOFN;\n\tLPTSTR pszFile;\n} OFNOTIFY,*LPOFNOTIFY;\ntypedef struct _OSVERSIONINFOA {\n\tDWORD dwOSVersionInfoSize;\n\tDWORD dwMajorVersion;\n\tDWORD dwMinorVersion;\n\tDWORD dwBuildNumber;\n\tDWORD dwPlatformId;\n\tCHAR szCSDVersion[128];\n} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;\n\ntypedef struct _OSVERSIONINFOW {\n\tDWORD dwOSVersionInfoSize;\n\tDWORD dwMajorVersion;\n\tDWORD dwMinorVersion;\n\tDWORD dwBuildNumber;\n\tDWORD dwPlatformId;\n\tWCHAR szCSDVersion[128];\n} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;\ntypedef struct _OSVERSIONINFOEXA {\n\tDWORD dwOSVersionInfoSize;\n\tDWORD dwMajorVersion;\n\tDWORD dwMinorVersion;\n\tDWORD dwBuildNumber;\n\tDWORD dwPlatformId;\n\tCHAR szCSDVersion[128];\n\tWORD wServicePackMajor;\n\tWORD wServicePackMinor;\n\tWORD wSuiteMask;\n\tBYTE wProductType;\n\tBYTE wReserved;\n} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;\n\ntypedef struct _OSVERSIONINFOEXW {\n\tDWORD dwOSVersionInfoSize;\n\tDWORD dwMajorVersion;\n\tDWORD dwMinorVersion;\n\tDWORD dwBuildNumber;\n\tDWORD dwPlatformId;\n\tWCHAR szCSDVersion[128];\n\tWORD wServicePackMajor;\n\tWORD wServicePackMinor;\n\tWORD wSuiteMask;\n\tBYTE wProductType;\n\tBYTE wReserved;\n} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;\n#ifdef UNICODE\ntypedef OSVERSIONINFOW OSVERSIONINFO;\ntypedef POSVERSIONINFOW POSVERSIONINFO;\ntypedef LPOSVERSIONINFOW LPOSVERSIONINFO;\ntypedef OSVERSIONINFOEXW OSVERSIONINFOEX;\ntypedef POSVERSIONINFOEXW POSVERSIONINFOEX;\ntypedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;\n#else\ntypedef OSVERSIONINFOEXA OSVERSIONINFOEX;\ntypedef POSVERSIONINFOEXA POSVERSIONINFOEX;\ntypedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;\ntypedef OSVERSIONINFOA OSVERSIONINFO;\ntypedef POSVERSIONINFOA POSVERSIONINFO;\ntypedef LPOSVERSIONINFOA LPOSVERSIONINFO;\n#endif\ntypedef struct tagTEXTMETRIC {\n\tLONG tmHeight;\n\tLONG tmAscent;\n\tLONG tmDescent;\n\tLONG tmInternalLeading;\n\tLONG tmExternalLeading;\n\tLONG tmAveCharWidth;\n\tLONG tmMaxCharWidth;\n\tLONG tmWeight;\n\tLONG tmOverhang;\n\tLONG tmDigitizedAspectX;\n\tLONG tmDigitizedAspectY;\n\tBCHAR tmFirstChar;\n\tBCHAR tmLastChar;\n\tBCHAR tmDefaultChar;\n\tBCHAR tmBreakChar;\n\tBYTE tmItalic;\n\tBYTE tmUnderlined;\n\tBYTE tmStruckOut;\n\tBYTE tmPitchAndFamily;\n\tBYTE tmCharSet;\n\tBYTE pad1;\n\tBYTE pad2;\n\tBYTE pad3;\n\tBYTE pad4;\n} TEXTMETRIC,*LPTEXTMETRIC;\ntypedef int (CALLBACK *OLDFONTENUMPROC)(LOGFONT *,TEXTMETRIC *,DWORD,LPARAM);\ntypedef struct tagTEXTMETRIC *PTEXTMETRIC;\ntypedef struct tagTEXTMETRICW {\n\tLONG\ttmHeight;\n\tLONG\ttmAscent;\n\tLONG\ttmDescent;\n\tLONG\ttmInternalLeading;\n\tLONG\ttmExternalLeading;\n\tLONG\ttmAveCharWidth;\n\tLONG\ttmMaxCharWidth;\n\tLONG\ttmWeight;\n\tLONG\ttmOverhang;\n\tLONG\ttmDigitizedAspectX;\n\tLONG\ttmDigitizedAspectY;\n\tWCHAR\ttmFirstChar;\n\tWCHAR\ttmLastChar;\n\tWCHAR\ttmDefaultChar;\n\tWCHAR\ttmBreakChar;\n\tBYTE\ttmItalic;\n\tBYTE\ttmUnderlined;\n\tBYTE\ttmStruckOut;\n\tBYTE\ttmPitchAndFamily;\n\tBYTE\ttmCharSet;\n} TEXTMETRICW,*PTEXTMETRICW,*NPTEXTMETRICW,*LPTEXTMETRICW;\ntypedef struct _OUTLINETEXTMETRIC {\n\tUINT otmSize;\n\tTEXTMETRIC otmTextMetrics;\n\tBYTE otmFiller;\n\tPANOSE otmPanoseNumber;\n\tUINT otmfsSelection;\n\tUINT otmfsType;\n\tint otmsCharSlopeRise;\n\tint otmsCharSlopeRun;\n\tint otmItalicAngle;\n\tUINT otmEMSquare;\n\tint otmAscent;\n\tint otmDescent;\n\tUINT otmLineGap;\n\tUINT otmsCapEmHeight;\n\tUINT otmsXHeight;\n\tRECT otmrcFontBox;\n\tint otmMacAscent;\n\tint otmMacDescent;\n\tUINT otmMacLineGap;\n\tUINT otmusMinimumPPEM;\n\tPOINT otmptSubscriptSize;\n\tPOINT otmptSubscriptOffset;\n\tPOINT otmptSuperscriptSize;\n\tPOINT otmptSuperscriptOffset;\n\tUINT otmsStrikeoutSize;\n\tint otmsStrikeoutPosition;\n\tint otmsUnderscoreSize;\n\tint otmsUnderscorePosition;\n\tPSTR otmpFamilyName;\n\tPSTR otmpFaceName;\n\tPSTR otmpStyleName;\n\tPSTR otmpFullName;\n} OUTLINETEXTMETRIC,*LPOUTLINETEXTMETRIC;\ntypedef struct _OVERLAPPED {\n\tDWORD Internal;\n\tDWORD InternalHigh;\n\tDWORD Offset;\n\tDWORD OffsetHigh;\n\tHANDLE hEvent;\n} OVERLAPPED,*LPOVERLAPPED;\ntypedef struct tagPSD {\n\tDWORD lStructSize;\n\tHWND hwndOwner;\n\tHGLOBAL hDevMode;\n\tHGLOBAL hDevNames;\n\tDWORD Flags;\n\tPOINT ptPaperSize;\n\tRECT rtMinMargin;\n\tRECT rtMargin;\n\tHINSTANCE hInstance;\n\tLPARAM lCustData;\n\tLPPAGESETUPHOOK lpfnPageSetupHook;\n\tLPPAGEPAINTHOOK lpfnPagePaintHook;\n\tLPCTSTR lpPageSetupTemplateName;\n\tHGLOBAL hPageSetupTemplate;\n} PAGESETUPDLG,*LPPAGESETUPDLG;\ntypedef struct tagPAINTSTRUCT {\n\tHDC hdc;\n\tBOOL fErase;\n\tRECT rcPaint;\n\tBOOL fRestore;\n\tBOOL fIncUpdate;\n\tBYTE rgbReserved[32];\n} PAINTSTRUCT,*LPPAINTSTRUCT;\n#ifndef __PARAFORMAT_DEFINED\n#define __PARAFORMAT_DEFINED\ntypedef struct _paraformat {\n\tUINT cbSize;\n\tDWORD dwMask;\n\tWORD wNumbering;\n\tWORD wEffects;\n\tLONG dxStartIndent;\n\tLONG dxRightIndent;\n\tLONG dxOffset;\n\tWORD wAlignment;\n\tSHORT cTabCount;\n\tLONG rgxTabs[MAX_TAB_STOPS];\n} PARAFORMAT;\n#endif\ntypedef struct _POLYTEXT {\n\tint x;\n\tint y;\n\tUINT n;\n\tLPCTSTR lpstr;\n\tUINT uiFlags;\n\tRECT rcl;\n\tint *pdx;\n} POLYTEXT;\ntypedef struct _PRIVILEGE_SET {\n\tDWORD PrivilegeCount;\n\tDWORD Control;\n\tLUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];\n} PRIVILEGE_SET,*PPRIVILEGE_SET,*LPPRIVILEGE_SET;\ntypedef struct _PROCESS_HEAP_ENTRY {\n\tPVOID lpData;\n\tDWORD cbData;\n\tBYTE cbOverhead;\n\tBYTE iRegionIndex;\n\tWORD wFlags;\n\tDWORD dwCommittedSize;\n\tDWORD dwUnCommittedSize;\n\tLPVOID lpFirstBlock;\n\tLPVOID lpLastBlock;\n\tHANDLE hMem;\n} PROCESS_HEAP_ENTRY,*LPPROCESS_HEAP_ENTRY;\ntypedef struct _PROCESS_INFORMATION {\n\tHANDLE hProcess;\n\tHANDLE hThread;\n\tDWORD dwProcessId;\n\tDWORD dwThreadId;\n} PROCESS_INFORMATION,*LPPROCESS_INFORMATION;\ntypedef PROCESS_INFORMATION *PPROCESS_INFORMATION;\ntypedef UINT(CALLBACK * LPFNPSPCALLBACK) (HWND,UINT,LPVOID);\ntypedef struct _PROPSHEETPAGE {\n\tDWORD dwSize;\n\tDWORD dwFlags;\n\tHINSTANCE hInstance;\n\tunion {\n\t\tLPCTSTR pszTemplate;\n\t\tLPCDLGTEMPLATE pResource;\n\t};\n\tunion {\n\t\tHICON hIcon;\n\t\tLPCTSTR pszIcon;\n\t};\n\tLPCTSTR pszTitle;\n\tDLGPROC pfnDlgProc;\n\tLPARAM lParam;\n\tLPFNPSPCALLBACK pfnCallback;\n\tUINT *pcRefParent;\n} PROPSHEETPAGE,*LPPROPSHEETPAGE;\ntypedef const PROPSHEETPAGE *LPCPROPSHEETPAGE;\ntypedef struct _PSP *HPROPSHEETPAGE;\ntypedef struct _PROPSHEETHEADER {\n\tDWORD dwSize;\n\tDWORD dwFlags;\n\tHWND hwndParent;\n\tHINSTANCE hInstance;\n\tunion {\n\t\tHICON hIcon;\n\t\tLPCTSTR pszIcon;\n\t};\n\tLPCTSTR pszCaption;\n\tUINT nPages;\n\tunion {\n\t\tUINT nStartPage;\n\t\tLPCTSTR pStartPage;\n\t};\n\tunion {\n\t\tLPCPROPSHEETPAGE ppsp;\n\t\tHPROPSHEETPAGE *phpage;\n\t};\n\tPFNPROPSHEETCALLBACK pfnCallback;\n} PROPSHEETHEADER,*LPPROPSHEETHEADER;\ntypedef const PROPSHEETHEADER *LPCPROPSHEETHEADER;\ntypedef BOOL(CALLBACK * LPFNADDPROPSHEETPAGE) (HPROPSHEETPAGE,LPARAM);\ntypedef\nBOOL(CALLBACK * LPFNADDPROPSHEETPAGES) (LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);\ntypedef struct _PROTOCOL_INFO {\n\tDWORD dwServiceFlags;\n\tINT iAddressFamily;\n\tINT iMaxSockAddr;\n\tINT iMinSockAddr;\n\tINT iSocketType;\n\tINT iProtocol;\n\tDWORD dwMessageSize;\n\tLPTSTR lpProtocol;\n} PROTOCOL_INFO;\ntypedef struct _PSHNOTIFY {\n\tNMHDR hdr;\n\tLPARAM lParam;\n} PSHNOTIFY,*LPPSHNOTIFY;\ntypedef struct _RASAMB {\n\tDWORD dwSize;\n\tDWORD dwError;\n\tTCHAR szNetBiosError[NETBIOS_NAME_LEN + 1];\n\tBYTE bLana;\n} RASAMB;\ntypedef struct _RASTERIZER_STATUS {\n\tshort nSize;\n\tshort wFlags;\n\tshort nLanguageID;\n} RASTERIZER_STATUS,*LPRASTERIZER_STATUS;\ntypedef struct _REMOTE_NAME_INFO {\n\tLPTSTR lpUniversalName;\n\tLPTSTR lpConnectionName;\n\tLPTSTR lpRemainingPath;\n} REMOTE_NAME_INFO;\ntypedef struct _RGNDATAHEADER {\n\tDWORD dwSize;\n\tDWORD iType;\n\tDWORD nCount;\n\tDWORD nRgnSize;\n\tRECT rcBound;\n} RGNDATAHEADER;\ntypedef struct _RGNDATA {\n\tRGNDATAHEADER rdh;\n\tchar Buffer[1];\n} RGNDATA,*LPRGNDATA;\ntypedef struct tagSCROLLINFO {\n\tUINT cbSize;\n\tUINT fMask;\n\tint nMin;\n\tint nMax;\n\tUINT nPage;\n\tint nPos;\n\tint nTrackPos;\n} SCROLLINFO,*LPSCROLLINFO;\ntypedef SCROLLINFO const *LPCSCROLLINFO;\ntypedef struct _SECURITY_ATTRIBUTES {\n\tDWORD nLength;\n\tLPVOID lpSecurityDescriptor;\n\tBOOL bInheritHandle;\n} SECURITY_ATTRIBUTES,*LPSECURITY_ATTRIBUTES;\ntypedef DWORD SECURITY_INFORMATION,*PSECURITY_INFORMATION;\ntypedef struct tagSERIALKEYS {\n\tDWORD cbSize;\n\tDWORD dwFlags;\n\tLPSTR lpszActivePort;\n\tLPSTR lpszPort;\n\tDWORD iBaudRate;\n\tDWORD iPortState;\n} SERIALKEYS,*LPSERIALKEYS;\ntypedef struct _SESSION_BUFFER {\n\tUCHAR lsn;\n\tUCHAR state;\n\tUCHAR local_name[NCBNAMSZ];\n\tUCHAR remote_name[NCBNAMSZ];\n\tUCHAR rcvs_outstanding;\n\tUCHAR sends_outstanding;\n} SESSION_BUFFER;\ntypedef struct _SESSION_HEADER {\n\tUCHAR sess_name;\n\tUCHAR num_sess;\n\tUCHAR rcv_dg_outstanding;\n\tUCHAR rcv_any_outstanding;\n} SESSION_HEADER;\n//#ifndef SHCONTF_DEFINED\n//typedef enum tagSHCONTF { SHCONTF_FOLDERS=32, SHCONTF_NONFOLDERS=64, SHCONTF_INCLUDEHIDDEN=128,\n//SHCONTF_INIT_ON_FIRST_NEXT=256, SHCONTF_NETPRINTERSRCH=512, SHCONTF_SHAREABLE=1024,\n//SHCONTF_STORAGE=2048 };\n//\n//typedef DWORD SHCONTF;\n//\n//#define SHCONTF_DEFINED\n//#endif\n#ifndef __FILEOP_FLAGS_DEFINED\ntypedef WORD FILEOP_FLAGS;\n#define __FILEOP_FLAGS_DEFINED\n#endif\n#ifndef SHGNO_DEFINED\ntypedef enum tagSHGDN { SHGDN_NORMAL=0, SHGDN_INFOLDER=1, SHGDN_FOREDITING=4096,\nSHGDN_FORADDRESSBAR=0x4000, SHGDN_FORPARSING=0x8000 } SHGNO;\n#define SHGNO_DEFINED\n#endif\ntypedef struct _SID_AND_ATTRIBUTES {\n\tPSID Sid;\n\tDWORD Attributes;\n} SID_AND_ATTRIBUTES,*PSID_AND_ATTRIBUTES;\ntypedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];\ntypedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;\ntypedef struct _SINGLE_LIST_ENTRY {\n\tstruct _SINGLE_LIST_ENTRY *Next;\n} SINGLE_LIST_ENTRY;\ntypedef struct tagSOUNDSENTRY {\n\tUINT cbSize;\n\tDWORD dwFlags;\n\tDWORD iFSTextEffect;\n\tDWORD iFSTextEffectMSec;\n\tDWORD iFSTextEffectColorBits;\n\tDWORD iFSGrafEffect;\n\tDWORD iFSGrafEffectMSec;\n\tDWORD iFSGrafEffectColor;\n\tDWORD iWindowsEffect;\n\tDWORD iWindowsEffectMSec;\n\tLPTSTR lpszWindowsEffectDLL;\n\tDWORD iWindowsEffectOrdinal;\n} SOUNDSENTRY,*LPSOUNDSENTRY;\ntypedef struct _STARTUPINFOA {\n\tDWORD cb;\n\tLPSTR lpReserved;\n\tLPSTR lpDesktop;\n\tLPSTR lpTitle;\n\tDWORD dwX;\n\tDWORD dwY;\n\tDWORD dwXSize;\n\tDWORD dwYSize;\n\tDWORD dwXCountChars;\n\tDWORD dwYCountChars;\n\tDWORD dwFillAttribute;\n\tDWORD dwFlags;\n\tWORD wShowWindow;\n\tWORD cbReserved2;\n\tLPBYTE lpReserved2;\n\tHANDLE hStdInput;\n\tHANDLE hStdOutput;\n\tHANDLE hStdError;\n} STARTUPINFOA, *LPSTARTUPINFOA;\ntypedef struct _STARTUPINFOW {\n\tDWORD cb;\n\tLPWSTR lpReserved;\n\tLPWSTR lpDesktop;\n\tLPWSTR lpTitle;\n\tDWORD dwX;\n\tDWORD dwY;\n\tDWORD dwXSize;\n\tDWORD dwYSize;\n\tDWORD dwXCountChars;\n\tDWORD dwYCountChars;\n\tDWORD dwFillAttribute;\n\tDWORD dwFlags;\n\tWORD wShowWindow;\n\tWORD cbReserved2;\n\tLPBYTE lpReserved2;\n\tHANDLE hStdInput;\n\tHANDLE hStdOutput;\n\tHANDLE hStdError;\n} STARTUPINFOW, *LPSTARTUPINFOW;\n#ifdef UNICODE\ntypedef STARTUPINFOW STARTUPINFO;\ntypedef LPSTARTUPINFOW LPSTARTUPINFO;\n#else\ntypedef STARTUPINFOA STARTUPINFO;\ntypedef LPSTARTUPINFOA LPSTARTUPINFO;\n#endif\ntypedef struct tagSTICKYKEYS {\n\tDWORD cbSize;\n\tDWORD dwFlags;\n} STICKYKEYS,*LPSTICKYKEYS;\n#ifndef _STRRET_DEFINED\n#pragma pack(push,8)\ntypedef struct _STRRET { UINT uType; union { LPWSTR pOleStr; UINT uOffset; char cStr[260]; } ;\n} STRRET,*LPSTRRET;\n#define _STRRET_DEFINED\n#endif\n#pragma pack(pop)\ntypedef struct tagSTYLESTRUCT {\n\tDWORD styleOld;\n\tDWORD styleNew;\n} STYLESTRUCT,*LPSTYLESTRUCT;\ntypedef struct _SYSTEM_AUDIT_ACE {\n\tACE_HEADER Header;\n\tACCESS_MASK Mask;\n\tDWORD SidStart;\n} SYSTEM_AUDIT_ACE;\ntypedef struct _SYSTEM_INFO {\n\tWORD wProcessorArchitecture;\n\tWORD wReserved;\n\tDWORD dwPageSize;\n\tLPVOID lpMinimumApplicationAddress;\n\tLPVOID lpMaximumApplicationAddress;\n\tDWORD dwActiveProcessorMask;\n\tDWORD dwNumberOfProcessors;\n\tDWORD dwProcessorType;\n\tDWORD dwAllocationGranularity;\n\tWORD wProcessorLevel;\n\tWORD wProcessorRevision;\n} SYSTEM_INFO,*LPSYSTEM_INFO;\ntypedef struct _SYSTEM_POWER_STATUS {\n\tBYTE ACLineStatus;\n\tBYTE BatteryFlag;\n\tBYTE BatteryLifePercent;\n\tBYTE Reserved1;\n\tDWORD BatteryLifeTime;\n\tDWORD BatteryFullLifeTime;\n} SYSTEM_POWER_STATUS;\ntypedef SYSTEM_POWER_STATUS *LPSYSTEM_POWER_STATUS;\ntypedef struct _TAPE_ERASE {\n\tULONG Type;\n} TAPE_ERASE;\ntypedef struct _TAPE_GET_DRIVE_PARAMETERS {\n\tBOOLEAN ECC;\n\tBOOLEAN Compression;\n\tBOOLEAN DataPadding;\n\tBOOLEAN ReportSetmarks;\n\tULONG DefaultBlockSize;\n\tULONG MaximumBlockSize;\n\tULONG MinimumBlockSize;\n\tULONG MaximumPartitionCount;\n\tULONG FeaturesLow;\n\tULONG FeaturesHigh;\n\tULONG EOTWarningZoneSize;\n} TAPE_GET_DRIVE_PARAMETERS;\ntypedef struct _TAPE_GET_MEDIA_PARAMETERS {\n\tLARGE_INTEGER Capacity;\n\tLARGE_INTEGER Remaining;\n\tDWORD BlockSize;\n\tDWORD PartitionCount;\n\tBOOLEAN WriteProtected;\n} TAPE_GET_MEDIA_PARAMETERS;\ntypedef struct _TAPE_GET_POSITION {\n\tULONG Type;\n\tULONG Partition;\n\tULONG OffsetLow;\n\tULONG OffsetHigh;\n} TAPE_GET_POSITION;\ntypedef struct _TAPE_PREPARE {\n\tULONG Operation;\n} TAPE_PREPARE;\ntypedef struct _TAPE_SET_DRIVE_PARAMETERS {\n\tBOOLEAN ECC;\n\tBOOLEAN Compression;\n\tBOOLEAN DataPadding;\n\tBOOLEAN ReportSetmarks;\n\tULONG EOTWarningZoneSize;\n} TAPE_SET_DRIVE_PARAMETERS;\ntypedef struct _TAPE_SET_MEDIA_PARAMETERS {\n\tULONG BlockSize;\n} TAPE_SET_MEDIA_PARAMETERS;\ntypedef struct _TAPE_SET_POSITION {\n\tULONG Method;\n\tULONG Partition;\n\tULONG OffsetLow;\n\tULONG OffsetHigh;\n} TAPE_SET_POSITION;\ntypedef struct _TAPE_WRITE_MARKS {\n\tULONG Type;\n\tULONG Count;\n} TAPE_WRITE_MARKS;\ntypedef struct tagTBADDBITMAP {\n\tHINSTANCE hInst;\n\tUINT nID;\n} TBADDBITMAP,*LPTBADDBITMAP;\ntypedef struct _TBBUTTON {\n\tint iBitmap;\n\tint idCommand;\n\tBYTE fsState;\n\tBYTE fsStyle;\n\tBYTE bReserved[2];\n\tDWORD dwData;\n\tint iString;\n} TBBUTTON,*PTBBUTTON,*LPTBBUTTON;\ntypedef const TBBUTTON *LPCTBBUTTON;\ntypedef struct tagNMTOOLBARA {\n\tNMHDR\thdr;\n\tint\tiItem;\n\tTBBUTTON tbButton;\n\tint\tcchText;\n\tLPSTR\tpszText;\n\tRECT\trcButton;\n} NMTOOLBARA,*LPNMTOOLBARA;\ntypedef struct tagNMTOOLBARW {\n\tNMHDR\thdr;\n\tint\tiItem;\n\tTBBUTTON tbButton;\n\tint\tcchText;\n\tLPWSTR\tpszText;\n\tRECT\trcButton;\n} NMTOOLBARW, *LPNMTOOLBARW;\ntypedef struct tagNMTOOLTIPSCREATED {\n\tNMHDR hdr;\n\tHWND hwndToolTips;\n} NMTOOLTIPSCREATED, * LPNMTOOLTIPSCREATED;\ntypedef struct tagTBSAVEPARAMSA {\n\tHKEY hkr;\n\tLPCSTR pszSubKey;\n\tLPCSTR pszValueName;\n} TBSAVEPARAMSA,*LPTBSAVEPARAMSA;\ntypedef struct tagTBSAVEPARAMSW {\n\tHKEY hkr;\n\tLPCWSTR pszSubKey;\n\tLPCWSTR pszValueName;\n} TBSAVEPARAMSW,*LPTBSAVEPARAMW;\n#ifdef UNICODE\n#define TBSAVEPARAMS\tTBSAVEPARAMSW\n#define LPTBSAVEPARAMS\tLPTBSAVEPARAMSW\n#else\n#define TBSAVEPARAMS\tTBSAVEPARAMSA\n#define LPTBSAVEPARAMS\tLPTBSAVEPARAMSA\n#endif\ntypedef struct _TC_HITTESTINFO {\n\tPOINT pt;\n\tUINT flags;\n} TC_HITTESTINFO;\ntypedef struct _TC_ITEM {\n\tUINT mask;\n\tUINT lpReserved1;\n\tUINT lpReserved2;\n\tLPTSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tLPARAM lParam;\n} TC_ITEM;\ntypedef struct _TC_ITEMHEADER {\n\tUINT mask;\n\tUINT lpReserved1;\n\tUINT lpReserved2;\n\tLPTSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n} TC_ITEMHEADER;\ntypedef struct _TC_KEYDOWN {\n\tNMHDR hdr;\n\tWORD wVKey;\n\tUINT flags;\n} NMTCKEYDOWN;\n#ifndef _TEXTRANGE_DEFINED\n#define _TEXTRANGE_DEFINED\ntypedef struct _textrange { CHARRANGE chrg; LPSTR lpstrText; } TEXTRANGE;\n#endif\ntypedef struct _TIME_ZONE_INFORMATION {\n\tLONG Bias;\n\tWCHAR StandardName[32];\n\tSYSTEMTIME StandardDate;\n\tLONG StandardBias;\n\tWCHAR DaylightName[32];\n\tSYSTEMTIME DaylightDate;\n\tLONG DaylightBias;\n} TIME_ZONE_INFORMATION,*LPTIME_ZONE_INFORMATION;\ntypedef struct tagTOGGLEKEYS {\n\tDWORD cbSize;\n\tDWORD dwFlags;\n} TOGGLEKEYS;\ntypedef struct _TOKEN_SOURCE {\n\tCHAR SourceName[8];\n\tLUID SourceIdentifier;\n} TOKEN_SOURCE,*PTOKEN_SOURCE;\ntypedef struct _TOKEN_CONTROL {\n\tLUID TokenId;\n\tLUID AuthenticationId;\n\tLUID ModifiedId;\n\tTOKEN_SOURCE TokenSource;\n} TOKEN_CONTROL;\ntypedef struct _TOKEN_DEFAULT_DACL {\n\tPACL DefaultDacl;\n} TOKEN_DEFAULT_DACL;\ntypedef struct _TOKEN_GROUPS {\n\tDWORD GroupCount;\n\tSID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];\n} TOKEN_GROUPS,*PTOKEN_GROUPS,*LPTOKEN_GROUPS;\ntypedef struct _TOKEN_OWNER {\n\tPSID Owner;\n} TOKEN_OWNER;\ntypedef struct _TOKEN_PRIMARY_GROUP {\n\tPSID PrimaryGroup;\n} TOKEN_PRIMARY_GROUP;\ntypedef struct _TOKEN_PRIVILEGES {\n\tDWORD PrivilegeCount;\n\tLUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];\n} TOKEN_PRIVILEGES,*PTOKEN_PRIVILEGES,*LPTOKEN_PRIVILEGES;\ntypedef struct _TOKEN_STATISTICS {\n\tLUID TokenId;\n\tLUID AuthenticationId;\n\tLARGE_INTEGER ExpirationTime;\n\tTOKEN_TYPE TokenType;\n\tSECURITY_IMPERSONATION_LEVEL ImpersonationLevel;\n\tDWORD DynamicCharged;\n\tDWORD DynamicAvailable;\n\tDWORD GroupCount;\n\tDWORD PrivilegeCount;\n\tLUID ModifiedId;\n} TOKEN_STATISTICS;\ntypedef struct _TOKEN_USER {\n\tSID_AND_ATTRIBUTES User;\n} TOKEN_USER;\ntypedef struct {\n\tUINT cbSize;\n\tUINT uFlags;\n\tHWND hwnd;\n\tUINT uId;\n\tRECT rect;\n\tHINSTANCE hinst;\n\tLPTSTR lpszText;\n\tLPARAM lParam;\n} TOOLINFO,*PTOOLINFO,*LPTOOLINFO;\ntypedef struct {\n\tNMHDR hdr;\n\tLPTSTR lpszText;\n\tchar szText[80];\n\tHINSTANCE hinst;\n\tUINT uFlags;\n} TOOLTIPTEXT,*LPTOOLTIPTEXT;\ntypedef struct tagTPMPARAMS {\n\tUINT cbSize;\n\tRECT rcExclude;\n} TPMPARAMS,*LPTPMPARAMS;\ntypedef struct _TT_HITTESTINFO {\n\tHWND hwnd;\n\tPOINT pt;\n\tTOOLINFO ti;\n} TTHITTESTINFO,*LPHITTESTINFO;\ntypedef struct tagTTPOLYCURVE {\n\tWORD wType;\n\tWORD cpfx;\n\tPOINTFX apfx[1];\n} TTPOLYCURVE,*LPTTPOLYCURVE;\ntypedef struct _TTPOLYGONHEADER {\n\tDWORD cb;\n\tDWORD dwType;\n\tPOINTFX pfxStart;\n} TTPOLYGONHEADER,*LPTTPOLYGONHEADER;\ntypedef struct _TV_DISPINFO {\n\tNMHDR hdr;\n\tTV_ITEM item;\n} TV_DISPINFO;\ntypedef struct tagTVDISPINFOA {\n\tNMHDR hdr;\n\tTVITEMA item;\n} NMTVDISPINFOA, *LPNMTVDISPINFOA;\ntypedef struct tagTVDISPINFOW {\n\tNMHDR hdr;\n\tTVITEMW item;\n} NMTVDISPINFOW, *LPNMTVDISPINFOW;\ntypedef struct _TVHITTESTINFO {\n\tPOINT pt;\n\tUINT flags;\n\tHTREEITEM hItem;\n} TV_HITTESTINFO,*LPTV_HITTESTINFO;\ntypedef struct _TV_INSERTSTRUCT {\n\tHTREEITEM hParent;\n\tHTREEITEM hInsertAfter;\n\tTV_ITEM item;\n} TV_INSERTSTRUCT,*LPTV_INSERTSTRUCT;\ntypedef struct _TV_KEYDOWN {\n\tNMHDR hdr;\n\tWORD wVKey;\n\tUINT flags;\n} TV_KEYDOWN;\ntypedef struct _TV_SORTCB {\n\tHTREEITEM hParent;\n\tPFNTVCOMPARE lpfnCompare;\n\tLPARAM lParam;\n} TV_SORTCB,*LPTV_SORTCB;\ntypedef union _ULARGE_INTEGER {\n\tstruct {DWORD LowPart; DWORD HighPart;};\n\tlong long QuadPart;\n} ULARGE_INTEGER,*PULARGE_INTEGER;\ntypedef struct _UNIVERSAL_NAME_INFO {\n\tLPTSTR lpUniversalName;\n} UNIVERSAL_NAME_INFO;\ntypedef struct tagUSEROBJECTFLAGS {\n\tBOOL fInherit;\n\tBOOL fReserved;\n\tDWORD dwFlags;\n} USEROBJECTFLAGS;\ntypedef struct value_entA {\n\tLPSTR ve_valuename;\n\tDWORD ve_valuelen;\n\tDWORD ve_valueptr;\n\tDWORD ve_type;\n}VALENTA, *PVALENTA;\ntypedef struct value_entW {\n\tLPWSTR ve_valuename;\n\tDWORD ve_valuelen;\n\tDWORD ve_valueptr;\n\tDWORD ve_type;\n}VALENTW, *PVALENTW;\ntypedef struct pvalueA { LPSTR pv_valuename; int pv_valuelen; LPVOID pv_value_context;DWORD pv_type;}PVALUEA, *PPVALUEA;\ntypedef struct pvalueW { LPWSTR pv_valuename;int pv_valuelen;LPVOID pv_value_context;DWORD pv_type;}PVALUEW, *PPVALUEW;\n#ifdef UNICODE\ntypedef PVALUEW PVALUE;\ntypedef PPVALUEW PPVALUE;\ntypedef VALENTW VALENT;\ntypedef PVALENTW PVALENT;\n#define TBN_GETDISPINFO\tTBN_GETDISPINFOW\n#define NMTBDISPINFO\tNMTBDISPINFOW\n#define LPNMTBDISPINFO\tLPNMTBDISPINFOW\n#define TBN_GETINFOTIP\tTBN_GETINFOTIPW\n#define NMTBGETINFOTIP\tNMTBGETINFOTIPW\n#define LPNMTBGETINFOTIP\tLPNMTBGETINFOTIPW\n#define WIN32_FIND_DATA\tWIN32_FIND_DATAW\n#define LPWIN32_FIND_DATA LPWIN32_FIND_DATAW\n#define NMTVDISPINFO\tNMTVDISPINFOW\n#define LPNMTVDISPINFO\tLPNMTVDISPINFOW\n#else\ntypedef PVALUEA PVALUE;\ntypedef PPVALUEA PPVALUE;\ntypedef VALENTA VALENT;\ntypedef PVALENTA PVALENT;\n#define TBN_GETDISPINFO\tTBN_GETDISPINFOA\n#define NMTBDISPINFO\tNMTBDISPINFOA\n#define LPNMTBDISPINFO\tLPNMTBDISPINFOA\n#define TBN_GETINFOTIP\tTBN_GETINFOTIPA\n#define NMTBGETINFOTIP\tNMTBGETINFOTIPA\n#define LPNMTBGETINFOTIP\tLPNMTBGETINFOTIPA\n#define WIN32_FIND_DATA WIN32_FIND_DATAA\n#define LPWIN32_FIND_DATA\tLPWIN32_FIND_DATAA\n#define NMTVDISPINFO\tNMTVDISPINFOA\n#define LPNMTVDISPINFO\tLPNMTVDISPINFOA\n#endif\ntypedef struct _WIN32_STREAM_ID {\n\tDWORD dwStreamId;\n\tDWORD dwStreamAttributes;\n\tLARGE_INTEGER Size;\n\tDWORD dwStreamNameSize;\n\tWCHAR *cStreamName;\n} WIN32_STREAM_ID,*LPWIN32_STREAM_ID;\ntypedef struct _WINDOWPLACEMENT {\n\tUINT length;\n\tUINT flags;\n\tUINT showCmd;\n\tPOINT ptMinPosition;\n\tPOINT ptMaxPosition;\n\tRECT rcNormalPosition;\n} WINDOWPLACEMENT,*LPWINDOWPLACEMENT,*PWINDOWPLACEMENT;\ntypedef struct tagWNDCLASSEXA {\n\tUINT\tcbSize;\n\tUINT\tstyle;\n\tWNDPROC\tlpfnWndProc;\n\tint\tcbClsExtra;\n\tint\tcbWndExtra;\n\tHINSTANCE\thInstance;\n\tHICON\thIcon;\n\tHCURSOR\thCursor;\n\tHBRUSH\thbrBackground;\n\tLPCSTR\tlpszMenuName;\n\tLPCSTR\tlpszClassName;\n\tHICON\thIconSm;\n} WNDCLASSEXA, *PWNDCLASSEXA,*NPWNDCLASSEXA,*LPWNDCLASSEXA;\ntypedef struct tagWNDCLASSEXW {\n\tUINT cbSize;\n\tUINT style;\n\tWNDPROC lpfnWndProc;\n\tint cbClsExtra;\n\tint cbWndExtra;\n\tHINSTANCE hInstance;\n\tHICON hIcon;\n\tHCURSOR hCursor;\n\tHBRUSH hbrBackground;\n\tLPCWSTR lpszMenuName;\n\tLPCWSTR lpszClassName;\n\tHICON hIconSm;\n} WNDCLASSEXW,*PWNDCLASSEXW,*NPWNDCLASSEXW,*LPWNDCLASSEXW;\n#ifdef UNICODE\ntypedef WNDCLASSEXW WNDCLASSEX;\ntypedef PWNDCLASSEXW PWNDCLASSEX;\ntypedef NPWNDCLASSEXW NPWNDCLASSEX;\ntypedef LPWNDCLASSEXW LPWNDCLASSEX;\n#else\ntypedef WNDCLASSEXA WNDCLASSEX;\ntypedef PWNDCLASSEXA PWNDCLASSEX;\ntypedef NPWNDCLASSEXA NPWNDCLASSEX;\ntypedef LPWNDCLASSEXA LPWNDCLASSEX;\n#endif\ntypedef struct tagWNDCLASSA {\n\tUINT\tstyle;\n\tWNDPROC\tlpfnWndProc;\n\tint\tcbClsExtra;\n\tint\tcbWndExtra;\n\tHINSTANCE\thInstance;\n\tHICON\thIcon;\n\tHCURSOR\thCursor;\n\tHBRUSH\thbrBackground;\n\tLPCSTR\tlpszMenuName;\n\tLPCSTR\tlpszClassName;\n} WNDCLASSA, *PWNDCLASSA,*NPWNDCLASSA,*LPWNDCLASSA;\ntypedef struct tagWNDCLASSW {\n\tUINT\tstyle;\n\tWNDPROC\tlpfnWndProc;\n\tint\tcbClsExtra;\n\tint\tcbWndExtra;\n\tHINSTANCE hInstance;\n\tHICON\thIcon;\n\tHCURSOR\thCursor;\n\tHBRUSH\thbrBackground;\n\tLPCWSTR\tlpszMenuName;\n\tLPCWSTR\tlpszClassName;\n} WNDCLASSW, *PWNDCLASSW,*NPWNDCLASSW,*LPWNDCLASSW;\n#ifdef UNICODE\ntypedef WNDCLASSW WNDCLASS;\ntypedef PWNDCLASSW PWNDCLASS;\ntypedef NPWNDCLASSW NPWNDCLASS;\ntypedef LPWNDCLASSW LPWNDCLASS;\n#else\ntypedef WNDCLASSA WNDCLASS;\ntypedef PWNDCLASSA PWNDCLASS;\ntypedef NPWNDCLASSA NPWNDCLASS;\ntypedef LPWNDCLASSA LPWNDCLASS;\n#endif\ntypedef struct _CONNECTDLGSTRUCT {\n\tDWORD cbStructure;\n\tHWND hwndOwner;\n\tLPNETRESOURCE lpConnRes;\n\tDWORD dwFlags;\n\tDWORD dwDevNum;\n} CONNECTDLGSTRUCT,*LPCONNECTDLGSTRUCT;\ntypedef struct _DISCDLGSTRUCT {\n\tDWORD cbStructure;\n\tHWND hwndOwner;\n\tLPTSTR lpLocalName;\n\tLPTSTR lpRemoteName;\n\tDWORD dwFlags;\n} DISCDLGSTRUCT,*LPDISCDLGSTRUCT;\ntypedef struct _NETINFOSTRUCT {\n\tDWORD cbStructure;\n\tDWORD dwProviderVersion;\n\tDWORD dwStatus;\n\tDWORD dwCharacteristics;\n\tDWORD dwHandle;\n\tWORD wNetType;\n\tDWORD dwPrinters;\n\tDWORD dwDrives;\n} NETINFOSTRUCT,*LPNETINFOSTRUCT;\ntypedef struct _NETCONNECTINFOSTRUCT {\n\tDWORD cbStructure;\n\tDWORD dwFlags;\n\tDWORD dwSpeed;\n\tDWORD dwDelay;\n\tDWORD dwOptDataSize;\n} NETCONNECTINFOSTRUCT,*LPNETCONNECTINFOSTRUCT;\ntypedef struct _MESSAGE_RESOURCE_ENTRY {\n\tWORD\tLength;\n\tWORD\tFlags;\n\tBYTE\tText[ 1 ];\n} MESSAGE_RESOURCE_ENTRY,*PMESSAGE_RESOURCE_ENTRY;\n#define MESSAGE_RESOURCE_UNICODE 1\ntypedef struct _MESSAGE_RESOURCE_BLOCK {\n\tDWORD\tLowId;\n\tDWORD\tHighId;\n\tDWORD OffsetToEntries;\n} MESSAGE_RESOURCE_BLOCK,*PMESSAGE_RESOURCE_BLOCK;\ntypedef struct _MESSAGE_RESOURCE_DATA {\n\tDWORD\tNumberOfBlocks;\n\tMESSAGE_RESOURCE_BLOCK Blocks[1];\n} MESSAGE_RESOURCE_DATA,*PMESSAGE_RESOURCE_DATA;\ntypedef enum tagMEMCTX {MEMCTX_TASK=1,MEMCTX_SHARED=2,MEMCTX_MACSYSTEM=3,MEMCTX_UNKNOWN = -1,MEMCTX_SAME=-2 }MEMCTX;\ntypedef enum tagCLSCTX {CLSCTX_INPROC_SERVER=1,CLSCTX_INPROC_HANDLER=2,\n\tCLSCTX_LOCAL_SERVER=4,CLSCTX_INPROC_SERVER16=8,CLSCTX_REMOTE_SERVER=16} CLSCTX;\ntypedef enum tagMSHLFLAGS {MSHLFLAGS_NORMAL=0,MSHLFLAGS_TABLESTRONG= 1,\n\tMSHLFLAGS_TABLEWEAK=2,MSHLFLAGS_NOPING=4} MSHLFLAGS;\ntypedef enum tagMSHCTX {MSHCTX_LOCAL=0,MSHCTX_NOSHAREDMEM=1,\n\tMSHCTX_DIFFERENTMACHINE=2,MSHCTX_INPROC=3,MSHCTX_CROSSCTX = 4} MSHCTX;\ntypedef enum _DVASPECT {DVASPECT_CONTENT=1,DVASPECT_THUMBNAIL=2,\n DVASPECT_ICON=4,DVASPECT_DOCPRINT=8} DVASPECT;\ntypedef enum tagSTGC {STGC_DEFAULT=0,STGC_OVERWRITE=1,\n\tSTGC_ONLYIFCURRENT=2,STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE=4,STGC_CONSOLIDATE=8}STGC;\ntypedef enum tagSTGMOVE {STGMOVE_MOVE=0,STGMOVE_COPY=1,STGMOVE_SHALLOWCOPY=2}STGMOVE;\ntypedef enum tagSTATFLAG {STATFLAG_DEFAULT= 0,STATFLAG_NONAME=1,STATFLAG_NOOPEN=2} STATFLAG;\ntypedef void *HCONTEXT;\ntypedef struct tagLVBKIMAGEA {\n\tULONG ulFlags;\n\tHBITMAP hbm;\n\tLPSTR pszImage;\n\tUINT cchImageMax;\n\tint xOffsetPercent;\n\tint yOffsetPercent;\n} LVBKIMAGEA, *LPLVBKIMAGEA;\ntypedef struct tagLVBKIMAGEW {\n\tULONG ulFlags;\n\tHBITMAP hbm;\n\tLPWSTR pszImage;\n\tUINT cchImageMax;\n\tint xOffsetPercent;\n\tint yOffsetPercent;\n} LVBKIMAGEW, *LPLVBKIMAGEW;\ntypedef struct {\n\tUINT cbSize;\n\tDWORD dwMask;\n\tint idCommand;\n\tint iImage;\n\tBYTE fsState;\n\tBYTE fsStyle;\n\tWORD cx;\n\tDWORD_PTR lParam;\n\tLPSTR pszText;\n\tint cchText;\n} TBBUTTONINFOA, *LPTBBUTTONINFOA;\ntypedef struct {\n\tUINT cbSize;\n\tDWORD dwMask;\n\tint idCommand;\n\tint iImage;\n\tBYTE fsState;\n\tBYTE fsStyle;\n\tWORD cx;\n\tDWORD *lParam;\n\tLPWSTR pszText;\n\tint cchText;\n} TBBUTTONINFOW, *LPTBBUTTONINFOW;\ntypedef struct tagNMKEY {\n\tNMHDR hdr;\n\tUINT nVKey;\n\tUINT uFlags;\n} NMKEY,*LPNMKEY;\ntypedef struct tagNMCHAR {\n\tNMHDR\thdr;\n\tUINT\tch;\n\tDWORD\tdwItemPrev;\n\tDWORD\tdwItemNext;\n} NMCHAR,*LPNMCHAR;\ntypedef struct tagNMCUSTOMDRAWINFO {\n\tNMHDR hdr;\n\tDWORD dwDrawStage;\n\tHDC hdc;\n\tRECT rc;\n\tDWORD_PTR dwItemSpec;\n\tUINT uItemState;\n\tLPARAM lItemlParam;\n} NMCUSTOMDRAW, FAR * LPNMCUSTOMDRAW;\ntypedef struct tagNMLVCUSTOMDRAW {\n\tNMCUSTOMDRAW nmcd;\n\tCOLORREF clrText;\n\tCOLORREF clrTextBk;\n\tint iSubItem;\n} NMLVCUSTOMDRAW, *LPNMLVCUSTOMDRAW;\ntypedef struct _NMTBCUSTOMDRAW {\n\tNMCUSTOMDRAW nmcd;\n\tHBRUSH hbrMonoDither;\n\tHBRUSH hbrLines;\n\tHPEN hpenLines;\n\tCOLORREF clrText;\n\tCOLORREF clrMark;\n\tCOLORREF clrTextHighlight;\n\tCOLORREF clrBtnFace;\n\tCOLORREF clrBtnHighlight;\n\tCOLORREF clrHighlightHotTrack;\n\tRECT rcText;\n\tint nStringBkMode;\n\tint nHLStringBkMode;\n} NMTBCUSTOMDRAW, *LPNMTBCUSTOMDRAW;\ntypedef struct {\n\tNMHDR hdr;\n\tDWORD dwMask;\n\tint idCommand;\n\tDWORD_PTR lParam;\n\tint iImage;\n\tLPSTR pszText;\n\tint cchText;\n} NMTBDISPINFOA,*LPNMTBDISPINFOA;\ntypedef struct {\n\tNMHDR hdr;\n\tDWORD dwMask;\n\tint idCommand;\n\tDWORD_PTR lParam;\n\tint iImage;\n\tLPWSTR pszText;\n\tint cchText;\n} NMTBDISPINFOW,*LPNMTBDISPINFOW;\ntypedef struct tagNMOBJECTNOTIFY {\n\tNMHDR\thdr;\n\tint\tiItem;\n\tconst void *piid;\n\tvoid *pObject;\n\tHRESULT hResult;\n\tDWORD dwFlags;\n} NMOBJECTNOTIFY,*LPNMOBJECTNOTIFY;\ntypedef struct tagNMTBHOTITEM {\n\tNMHDR\thdr;\n\tint\tidOld;\n\tint\tidNew;\n\tDWORD\tdwFlags;\n} NMTBHOTITEM, * LPNMTBHOTITEM;\ntypedef struct tagNMTBGETINFOTIPA {\n\tNMHDR hdr;\n\tLPSTR pszText;\n\tint cchTextMax;\n\tint iItem;\n\tLPARAM lParam;\n} NMTBGETINFOTIPA, *LPNMTBGETINFOTIPA;\ntypedef struct tagNMTBGETINFOTIPW {\n\tNMHDR hdr;\n\tLPWSTR pszText;\n\tint cchTextMax;\n\tint iItem;\n\tLPARAM lParam;\n} NMTBGETINFOTIPW, *LPNMTBGETINFOTIPW;\ntypedef struct {\n\tint\tiButton;\n\tDWORD dwFlags;\n} TBINSERTMARK,*LPTBINSERTMARK;\ntypedef struct {\n\tHINSTANCE\thInstOld;\n\tUINT_PTR\tnIDOld;\n\tHINSTANCE\thInstNew;\n\tUINT_PTR\tnIDNew;\n\tint\tnButtons;\n} TBREPLACEBITMAP, *LPTBREPLACEBITMAP;\n#define TBIMHT_AFTER\t1\n#define TBIMHT_BACKGROUND\t2\ntypedef struct {\n\tNMHDR hdr;\n\tWORD fwKeys;\n\tRECT rcParent;\n\tint iDir;\n\tint iXpos;\n\tint iYpos;\n\tint iScroll;\n}NMPGSCROLL,*LPNMPGSCROLL;\ntypedef struct {\n\tNMHDR\thdr;\n\tDWORD\tdwFlag;\n\tint\tiWidth;\n\tint\tiHeight;\n}NMPGCALCSIZE, *LPNMPGCALCSIZE;\n#define PBM_SETRANGE32\t(WM_USER+6)\ntypedef struct {\n\tint iLow;\n\tint iHigh;\n} PBRANGE, *PPBRANGE;\n#define PBM_GETRANGE\t(WM_USER+7)\n#define PBM_GETPOS\t(WM_USER+8)\n#define PBM_SETBARCOLOR\t(WM_USER+9)\n#define PBM_SETBKCOLOR\tCCM_SETBKCOLOR\ntypedef struct _UDACCEL {\n\tUINT nSec;\n\tUINT nInc;\n} UDACCEL,*LPUDACCEL;\ntypedef struct tagTCITEMHEADERA {\n\tUINT mask;\n\tUINT lpReserved1;\n\tUINT lpReserved2;\n\tLPSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n} TCITEMHEADERA,*LPTCITEMHEADERA;\ntypedef struct tagTCITEMHEADERW {\n\tUINT mask;\n\tUINT lpReserved1;\n\tUINT lpReserved2;\n\tLPWSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n} TCITEMHEADERW,*LPTCITEMHEADERW;\ntypedef struct tagTCITEMA {\n\tUINT mask;\n\tDWORD dwState;\n\tDWORD dwStateMask;\n\tLPSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tLPARAM lParam;\n} TCITEMA,*LPTCITEMA;\ntypedef struct tagTCITEMW {\n\tUINT mask;\n\tDWORD dwState;\n\tDWORD dwStateMask;\n\tLPWSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tLPARAM lParam;\n} TCITEMW, *LPTCITEMW;\n#ifdef UNICODE\n#define TCITEMHEADER\tTCITEMHEADERW\n#define LPTCITEMHEADER\tLPTCITEMHEADERW\n#define TCITEMHEADER\tTCITEMHEADERW\n#define LPTCITEMHEADER\tLPTCITEMHEADERW\n#define TCITEM\tTCITEMW\n#define LPTCITEM\tLPTCITEMW\n#else\n#define TCITEMHEADER\tTCITEMHEADERA\n#define LPTCITEMHEADER\tLPTCITEMHEADERA\n#define TCITEMHEADER\tTCITEMHEADERA\n#define LPTCITEMHEADER\tLPTCITEMHEADERA\n#define TCITEM\tTCITEMA\n#define LPTCITEM\tLPTCITEMA\n#endif\n#ifndef FIELD_OFFSET\n#define FIELD_OFFSET(type, field) ((LONG)(LONG *)&(((type *)0)->field))\n#endif\ntypedef DWORD MONTHDAYSTATE,*LPMONTHDAYSTATE;\ntypedef HANDLE HRAWINPUT;\n/* Structures associated with the executable image files. jn */\n\n#define IMAGE_DOS_SIGNATURE 0x5A4D\n#define IMAGE_OS2_SIGNATURE 0x454E\n#define IMAGE_OS2_SIGNATURE_LE 0x454C\n#define IMAGE_VXD_SIGNATURE 0x454C\n#define IMAGE_NT_SIGNATURE 0x4550\n#define IMAGE_SIZEOF_FILE_HEADER 20\n#define IMAGE_FILE_RELOCS_STRIPPED 1\n#define IMAGE_FILE_EXECUTABLE_IMAGE 2\n#define IMAGE_FILE_LINE_NUMS_STRIPPED 4\n#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 8\n#define IMAGE_FILE_BYTES_REVERSED_LO 128\n#define IMAGE_FILE_32BIT_MACHINE 256\n#define IMAGE_FILE_DEBUG_STRIPPED 512\n#define IMAGE_FILE_SYSTEM 0x1000\n#define IMAGE_FILE_DLL 0x2000\n#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000\n#define IMAGE_FILE_MACHINE_UNKNOWN 0\n#define IMAGE_FILE_MACHINE_I386 0x14c\n#define IMAGE_FILE_MACHINE_R3000 0x162\n#define IMAGE_FILE_MACHINE_R4000 0x166\n#define IMAGE_FILE_MACHINE_R10000 0x168\n#define IMAGE_FILE_MACHINE_ALPHA 0x184\n#define IMAGE_FILE_MACHINE_POWERPC 0x1F0\n#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16\n#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER 56\n#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER 28\n#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER 224\n#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b\n#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107\n#define IMAGE_FIRST_SECTION(nth) ((PIMAGE_SECTION_HEADER) \\\n ((DWORD)nth + FIELD_OFFSET( IMAGE_NT_HEADERS,OptionalHeader ) + \\\n ((PIMAGE_NT_HEADERS)(nth))->FileHeader.SizeOfOptionalHeader))\n#define IMAGE_SUBSYSTEM_UNKNOWN 0\n#define IMAGE_SUBSYSTEM_NATIVE 1\n#define IMAGE_SUBSYSTEM_WINDOWS_GUI 2\n#define IMAGE_SUBSYSTEM_WINDOWS_CUI 3\n#define IMAGE_SUBSYSTEM_OS2_CUI 5\n#define IMAGE_SUBSYSTEM_POSIX_CUI 7\n#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9\n#define IMAGE_DIRECTORY_ENTRY_EXPORT 0\n#define IMAGE_DIRECTORY_ENTRY_IMPORT 1\n#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2\n#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3\n#define IMAGE_DIRECTORY_ENTRY_SECURITY 4\n#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5\n#define IMAGE_DIRECTORY_ENTRY_DEBUG 6\n#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7\n#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8\n#define IMAGE_DIRECTORY_ENTRY_TLS 9\n#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10\n#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11\n#define IMAGE_DIRECTORY_ENTRY_IAT 12\n#define IMAGE_SIZEOF_SHORT_NAME 8\n#define IMAGE_SIZEOF_SECTION_HEADER 40\n#define IMAGE_SCN_TYPE_NO_PAD 8\n#define IMAGE_SCN_CNT_CODE 32\n#define IMAGE_SCN_CNT_INITIALIZED_DATA 64\n#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 128\n#define IMAGE_SCN_LNK_OTHER 256\n#define IMAGE_SCN_LNK_INFO 512\n#define IMAGE_SCN_LNK_REMOVE 0x800\n#define IMAGE_SCN_LNK_COMDAT 0x1000\n#define IMAGE_SCN_MEM_FARDATA 0x8000\n#define IMAGE_SCN_MEM_PURGEABLE 0x20000\n#define IMAGE_SCN_MEM_16BIT 0x20000\n#define IMAGE_SCN_MEM_LOCKED 0x40000\n#define IMAGE_SCN_MEM_PRELOAD 0x80000\n#define IMAGE_SCN_ALIGN_1BYTES 0x100000\n#define IMAGE_SCN_ALIGN_2BYTES 0x200000\n#define IMAGE_SCN_ALIGN_4BYTES 0x300000\n#define IMAGE_SCN_ALIGN_8BYTES 0x400000\n#define IMAGE_SCN_ALIGN_16BYTES 0x500000\n#define IMAGE_SCN_ALIGN_32BYTES 0x600000\n#define IMAGE_SCN_ALIGN_64BYTES 0x700000\n#define IMAGE_SCN_LNK_NRELOC_OVFL 0x1000000\n#define IMAGE_SCN_MEM_DISCARDABLE 0x2000000\n#define IMAGE_SCN_MEM_NOT_CACHED 0x4000000\n#define IMAGE_SCN_MEM_NOT_PAGED 0x8000000\n#define IMAGE_SCN_MEM_SHARED 0x10000000\n#define IMAGE_SCN_MEM_EXECUTE 0x20000000\n#define IMAGE_SCN_MEM_READ 0x40000000\n#define IMAGE_SCN_MEM_WRITE 0x80000000\n#define IMAGE_SIZEOF_SYMBOL 18\n#define IMAGE_SYM_UNDEFINED (SHORT)0\n#define IMAGE_SYM_ABSOLUTE (SHORT)-1\n#define IMAGE_SYM_DEBUG (SHORT)-2\n#define IMAGE_SYM_TYPE_NULL 0\n#define IMAGE_SYM_TYPE_VOID 1\n#define IMAGE_SYM_TYPE_CHAR 2\n#define IMAGE_SYM_TYPE_SHORT 3\n#define IMAGE_SYM_TYPE_INT 4\n#define IMAGE_SYM_TYPE_LONG 5\n#define IMAGE_SYM_TYPE_FLOAT 6\n#define IMAGE_SYM_TYPE_DOUBLE 7\n#define IMAGE_SYM_TYPE_STRUCT 8\n#define IMAGE_SYM_TYPE_UNION 9\n#define IMAGE_SYM_TYPE_ENUM 10\n#define IMAGE_SYM_TYPE_MOE 11\n#define IMAGE_SYM_TYPE_BYTE 12\n#define IMAGE_SYM_TYPE_WORD 13\n#define IMAGE_SYM_TYPE_UINT 14\n#define IMAGE_SYM_TYPE_DWORD 15\n#define IMAGE_SYM_TYPE_PCODE 0x8000\n#define IMAGE_SYM_DTYPE_NULL 0\n#define IMAGE_SYM_DTYPE_POINTER 1\n#define IMAGE_SYM_DTYPE_FUNCTION 2\n#define IMAGE_SYM_DTYPE_ARRAY 3\n#define IMAGE_SYM_CLASS_END_OF_FUNCTION (BYTE )-1\n#define IMAGE_SYM_CLASS_NULL 0\n#define IMAGE_SYM_CLASS_AUTOMATIC 1\n#define IMAGE_SYM_CLASS_EXTERNAL 2\n#define IMAGE_SYM_CLASS_STATIC 3\n#define IMAGE_SYM_CLASS_REGISTER 4\n#define IMAGE_SYM_CLASS_EXTERNAL_DEF 5\n#define IMAGE_SYM_CLASS_LABEL 6\n#define IMAGE_SYM_CLASS_UNDEFINED_LABEL 7\n#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 8\n#define IMAGE_SYM_CLASS_ARGUMENT 9\n#define IMAGE_SYM_CLASS_STRUCT_TAG 10\n#define IMAGE_SYM_CLASS_MEMBER_OF_UNION 11\n#define IMAGE_SYM_CLASS_UNION_TAG 12\n#define IMAGE_SYM_CLASS_TYPE_DEFINITION 13\n#define IMAGE_SYM_CLASS_UNDEFINED_STATIC 14\n#define IMAGE_SYM_CLASS_ENUM_TAG 15\n#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM 16\n#define IMAGE_SYM_CLASS_REGISTER_PARAM 17\n#define IMAGE_SYM_CLASS_BIT_FIELD 18\n#define IMAGE_SYM_CLASS_FAR_EXTERNAL 0x44\n#define IMAGE_SYM_CLASS_BLOCK 0x64\n#define IMAGE_SYM_CLASS_FUNCTION 0x65\n#define IMAGE_SYM_CLASS_END_OF_STRUCT 0x66\n#define IMAGE_SYM_CLASS_FILE 0x67\n#define IMAGE_SYM_CLASS_SECTION 0x68\n#define IMAGE_SYM_CLASS_WEAK_EXTERNAL 0x69\n#define N_BTMASK 0xF\n#define N_TMASK 0x30\n#define N_TMASK1 0xC0\n#define N_TMASK2 0xF0\n#define N_BTSHFT 4\n#define N_TSHIFT 2\n#define BTYPE(x) ((x) & N_BTMASK)\n#ifndef ISPTR\n#define ISPTR(x) (((x)&N_TMASK)==(IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))\n#endif\n#ifndef ISFCN\n#define ISFCN(x) (((x)&N_TMASK)==(IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))\n#endif\n#ifndef ISARY\n#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))\n#endif\n#ifndef ISTAG\n#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)\n#endif\n#ifndef INCREF\n#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))\n#endif\n#ifndef DECREF\n#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))\n#endif\n#define IMAGE_SIZEOF_SYMBOL\t18\n#define IMAGE_COMDAT_SELECT_NODUPLICATES\t1\n#define IMAGE_COMDAT_SELECT_ANY\t2\n#define IMAGE_COMDAT_SELECT_SAME_SIZE\t3\n#define IMAGE_COMDAT_SELECT_EXACT_MATCH\t4\n#define IMAGE_COMDAT_SELECT_ASSOCIATIVE\t5\n#define IMAGE_COMDAT_SELECT_LARGEST\t6\n#define IMAGE_COMDAT_SELECT_NEWEST\t7\n#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY\t1\n#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY\t2\n#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS\t3\n#define IMAGE_SIZEOF_RELOCATION 10\n#define IMAGE_REL_I386_ABSOLUTE\t0\n#define IMAGE_REL_I386_DIR16\t1\n#define IMAGE_REL_I386_REL16\t2\n#define IMAGE_REL_I386_DIR32\t6\n#define IMAGE_REL_I386_DIR32NB\t7\n#define IMAGE_REL_I386_SEG12 9\n#define IMAGE_REL_I386_SECTION 10\n#define IMAGE_REL_I386_SECREL 11\n#define IMAGE_REL_I386_REL32 0x14\n#define IMAGE_SIZEOF_BASE_RELOCATION 8\n#define IMAGE_REL_BASED_ABSOLUTE 0\n#define IMAGE_REL_BASED_HIGH 1\n#define IMAGE_REL_BASED_LOW 2\n#define IMAGE_REL_BASED_HIGHLOW 3\n#define IMAGE_REL_BASED_HIGHADJ 4\n#define IMAGE_REL_BASED_MIPS_JMPADDR 5\n#define IMAGE_SIZEOF_LINENUMBER 6\n#define IMAGE_ARCHIVE_START_SIZE 8\n#define IMAGE_ARCHIVE_START \"!<arch>\\n\"\n#define IMAGE_ARCHIVE_END \"`\\n\"\n#define IMAGE_ARCHIVE_PAD \"\\n\"\n#define IMAGE_ARCHIVE_LINKER_MEMBER \"/ \"\n#define IMAGE_ARCHIVE_LONGNAMES_MEMBER \"// \"\n#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR 60\n#define IMAGE_ORDINAL_FLAG 0x80000000\n#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)\n#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)\n#define IMAGE_RESOURCE_NAME_IS_STRING 0x80000000\n#define IMAGE_RESOURCE_DATA_IS_DIRECTORY 0x80000000\n#define IMAGE_DEBUG_TYPE_UNKNOWN 0\n#define IMAGE_DEBUG_TYPE_COFF 1\n#define IMAGE_DEBUG_TYPE_CODEVIEW 2\n#define IMAGE_DEBUG_TYPE_FPO 3\n#define IMAGE_DEBUG_TYPE_MISC 4\n#define IMAGE_DEBUG_TYPE_EXCEPTION 5\n#define IMAGE_DEBUG_TYPE_FIXUP 6\n#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC 7\n#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC 8\n#define FRAME_FPO 0\n#define FRAME_TRAP 1\n#define FRAME_TSS 2\n#define FRAME_NONFPO 3\n#define SIZEOF_RFPO_DATA 16\n#define IMAGE_DEBUG_MISC_EXENAME 1\n#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944\n#define CCHILDREN_TITLEBAR\t5\n#define CCHILDREN_SCROLLBAR\t5\ntypedef struct _IMAGE_DOS_HEADER {\n\tWORD e_magic;\n\tWORD e_cblp;\n\tWORD e_cp;\n\tWORD e_crlc;\n\tWORD e_cparhdr;\n\tWORD e_minalloc;\n\tWORD e_maxalloc;\n\tWORD e_ss;\n\tWORD e_sp;\n\tWORD e_csum;\n\tWORD e_ip;\n\tWORD e_cs;\n\tWORD e_lfarlc;\n\tWORD e_ovno;\n\tWORD e_res[4];\n\tWORD e_oemid;\n\tWORD e_oeminfo;\n\tWORD e_res2[10];\n\tLONG e_lfanew;\n} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;\ntypedef struct _IMAGE_OS2_HEADER {\n\tWORD ne_magic;\n\tCHAR ne_ver;\n\tCHAR ne_rev;\n\tWORD ne_enttab;\n\tWORD ne_cbenttab;\n\tLONG ne_crc;\n\tWORD ne_flags;\n\tWORD ne_autodata;\n\tWORD ne_heap;\n\tWORD ne_stack;\n\tLONG ne_csip;\n\tLONG ne_sssp;\n\tWORD ne_cseg;\n\tWORD ne_cmod;\n\tWORD ne_cbnrestab;\n\tWORD ne_segtab;\n\tWORD ne_rsrctab;\n\tWORD ne_restab;\n\tWORD ne_modtab;\n\tWORD ne_imptab;\n\tLONG ne_nrestab;\n\tWORD ne_cmovent;\n\tWORD ne_align;\n\tWORD ne_cres;\n\tBYTE ne_exetyp;\n\tBYTE ne_flagsothers;\n\tWORD ne_pretthunks;\n\tWORD ne_psegrefbytes;\n\tWORD ne_swaparea;\n\tWORD ne_expver;\n} IMAGE_OS2_HEADER,*PIMAGE_OS2_HEADER;\ntypedef struct _IMAGE_VXD_HEADER {\n\tWORD e32_magic;\n\tBYTE e32_border;\n\tBYTE e32_worder;\n\tDWORD e32_level;\n\tWORD e32_cpu;\n\tWORD e32_os;\n\tDWORD e32_ver;\n\tDWORD e32_mflags;\n\tDWORD e32_mpages;\n\tDWORD e32_startobj;\n\tDWORD e32_eip;\n\tDWORD e32_stackobj;\n\tDWORD e32_esp;\n\tDWORD e32_pagesize;\n\tDWORD e32_lastpagesize;\n\tDWORD e32_fixupsize;\n\tDWORD e32_fixupsum;\n\tDWORD e32_ldrsize;\n\tDWORD e32_ldrsum;\n\tDWORD e32_objtab;\n\tDWORD e32_objcnt;\n\tDWORD e32_objmap;\n\tDWORD e32_itermap;\n\tDWORD e32_rsrctab;\n\tDWORD e32_rsrccnt;\n\tDWORD e32_restab;\n\tDWORD e32_enttab;\n\tDWORD e32_dirtab;\n\tDWORD e32_dircnt;\n\tDWORD e32_fpagetab;\n\tDWORD e32_frectab;\n\tDWORD e32_impmod;\n\tDWORD e32_impmodcnt;\n\tDWORD e32_impproc;\n\tDWORD e32_pagesum;\n\tDWORD e32_datapage;\n\tDWORD e32_preload;\n\tDWORD e32_nrestab;\n\tDWORD e32_cbnrestab;\n\tDWORD e32_nressum;\n\tDWORD e32_autodata;\n\tDWORD e32_debuginfo;\n\tDWORD e32_debuglen;\n\tDWORD e32_instpreload;\n\tDWORD e32_instdemand;\n\tDWORD e32_heapsize;\n\tBYTE e32_res3[12];\n\tDWORD e32_winresoff;\n\tDWORD e32_winreslen;\n\tWORD e32_devid;\n\tWORD e32_ddkver;\n} IMAGE_VXD_HEADER,*PIMAGE_VXD_HEADER;\ntypedef struct _IMAGE_FILE_HEADER {\n\tWORD Machine;\n\tWORD NumberOfSections;\n\tDWORD TimeDateStamp;\n\tDWORD PointerToSymbolTable;\n\tDWORD NumberOfSymbols;\n\tWORD SizeOfOptionalHeader;\n\tWORD Characteristics;\n} IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;\ntypedef struct _IMAGE_DATA_DIRECTORY {\n\tDWORD VirtualAddress;\n\tDWORD Size;\n} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;\ntypedef struct _IMAGE_OPTIONAL_HEADERXXX {\n\tWORD Magic;\n\tBYTE MajorLinkerVersion;\n\tBYTE MinorLinkerVersion;\n\tDWORD SizeOfCode;\n\tDWORD SizeOfInitializedData;\n\tDWORD SizeOfUninitializedData;\n\tDWORD AddressOfEntryPoint;\n\tDWORD BaseOfCode;\n\tDWORD BaseOfData;\n\tDWORD ImageBase;\n\tDWORD SectionAlignment;\n\tDWORD FileAlignment;\n\tWORD MajorOperatingSystemVersion;\n\tWORD MinorOperatingSystemVersion;\n\tWORD MajorImageVersion;\n\tWORD MinorImageVersion;\n\tWORD MajorSubsystemVersion;\n\tWORD MinorSubsystemVersion;\n\tDWORD Win32VersionValue;\n\tDWORD SizeOfImage;\n\tDWORD SizeOfHeaders;\n\tDWORD CheckSum;\n\tWORD Subsystem;\n\tWORD DllCharacteristics;\n\tDWORD SizeOfStackReserve;\n\tDWORD SizeOfStackCommit;\n\tDWORD SizeOfHeapReserve;\n\tDWORD SizeOfHeapCommit;\n\tDWORD LoaderFlags;\n\tDWORD NumberOfRvaAndSizes;\n\tIMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER,*PIMAGE_OPTIONAL_HEADER;\ntypedef struct _IMAGE_OPTIONAL_HEADER64 {\n\tWORD\tMagic;\n\tBYTE\tMajorLinkerVersion;\n\tBYTE\tMinorLinkerVersion;\n\tDWORD\tSizeOfCode;\n\tDWORD\tSizeOfInitializedData;\n\tDWORD\tSizeOfUninitializedData;\n\tDWORD\tAddressOfEntryPoint;\n\tDWORD\tBaseOfCode;\n\tULONGLONG\tImageBase;\n\tDWORD\tSectionAlignment;\n\tDWORD\tFileAlignment;\n\tWORD\tMajorOperatingSystemVersion;\n\tWORD\tMinorOperatingSystemVersion;\n\tWORD\tMajorImageVersion;\n\tWORD\tMinorImageVersion;\n\tWORD\tMajorSubsystemVersion;\n\tWORD\tMinorSubsystemVersion;\n\tDWORD\tWin32VersionValue;\n\tDWORD\tSizeOfImage;\n\tDWORD\tSizeOfHeaders;\n\tDWORD\tCheckSum;\n\tWORD\tSubsystem;\n\tWORD\tDllCharacteristics;\n\tULONGLONG SizeOfStackReserve;\n\tULONGLONG SizeOfStackCommit;\n\tULONGLONG SizeOfHeapReserve;\n\tULONGLONG SizeOfHeapCommit;\n\tDWORD\tLoaderFlags;\n\tDWORD\tNumberOfRvaAndSizes;\n\tIMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;\n\n\n#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER\t240\n\n\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n    //\n    // Standard fields.\n    //\n\n    WORD    Magic;\n    BYTE    MajorLinkerVersion;\n    BYTE    MinorLinkerVersion;\n    DWORD   SizeOfCode;\n    DWORD   SizeOfInitializedData;\n    DWORD   SizeOfUninitializedData;\n    DWORD   AddressOfEntryPoint;\n    DWORD   BaseOfCode;\n    DWORD   BaseOfData;\n\n    //\n    // NT additional fields.\n    //\n\n    DWORD   ImageBase;\n    DWORD   SectionAlignment;\n    DWORD   FileAlignment;\n    WORD    MajorOperatingSystemVersion;\n    WORD    MinorOperatingSystemVersion;\n    WORD    MajorImageVersion;\n    WORD    MinorImageVersion;\n    WORD    MajorSubsystemVersion;\n    WORD    MinorSubsystemVersion;\n    DWORD   Win32VersionValue;\n    DWORD   SizeOfImage;\n    DWORD   SizeOfHeaders;\n    DWORD   CheckSum;\n    WORD    Subsystem;\n    WORD    DllCharacteristics;\n    DWORD   SizeOfStackReserve;\n    DWORD   SizeOfStackCommit;\n    DWORD   SizeOfHeapReserve;\n    DWORD   SizeOfHeapCommit;\n    DWORD   LoaderFlags;\n    DWORD   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n\n\n\ntypedef struct _IMAGE_NT_HEADERS64 {\n\tDWORD Signature;\n\tIMAGE_FILE_HEADER FileHeader;\n\tIMAGE_OPTIONAL_HEADER64 OptionalHeader;\n} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;\n\ntypedef struct _IMAGE_ROM_OPTIONAL_HEADER {\n\tWORD Magic;\n\tBYTE MajorLinkerVersion;\n\tBYTE MinorLinkerVersion;\n\tDWORD SizeOfCode;\n\tDWORD SizeOfInitializedData;\n\tDWORD SizeOfUninitializedData;\n\tDWORD AddressOfEntryPoint;\n\tDWORD BaseOfCode;\n\tDWORD BaseOfData;\n\tDWORD BaseOfBss;\n\tDWORD GprMask;\n\tDWORD CprMask[4];\n\tDWORD GpValue;\n} IMAGE_ROM_OPTIONAL_HEADER,*PIMAGE_ROM_OPTIONAL_HEADER;\n#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER 56\n#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER 28\n#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER 224\n#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b\n#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107\ntypedef struct _IMAGE_NT_HEADERS {\n\tDWORD Signature;\n\tIMAGE_FILE_HEADER FileHeader;\n\tIMAGE_OPTIONAL_HEADER OptionalHeader;\n} IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;\ntypedef IMAGE_NT_HEADERS IMAGE_NT_HEADERS32;\ntypedef IMAGE_NT_HEADERS32 *PIMAGE_NT_HEADERS32;\n#define LPIMAGE_NT_HEADERS PIMAGE_NT_HEADERS;\ntypedef struct _IMAGE_ROM_HEADERS {\n\tIMAGE_FILE_HEADER FileHeader;\n\tIMAGE_ROM_OPTIONAL_HEADER OptionalHeader;\n} IMAGE_ROM_HEADERS,*PIMAGE_ROM_HEADERS;\ntypedef struct _IMAGE_SECTION_HEADER {\n\tBYTE Name[IMAGE_SIZEOF_SHORT_NAME];\n\tunion {\n\t\tDWORD PhysicalAddress;\n\t\tDWORD VirtualSize;\n\t} Misc;\n\tDWORD VirtualAddress;\n\tDWORD SizeOfRawData;\n\tDWORD PointerToRawData;\n\tDWORD PointerToRelocations;\n\tDWORD PointerToLinenumbers;\n\tWORD NumberOfRelocations;\n\tWORD NumberOfLinenumbers;\n\tDWORD Characteristics;\n} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;\ntypedef struct _IMAGE_SYMBOL {\n\tunion {\n\t\tBYTE ShortName[8];\n\t\tstruct {\n\t\t\tDWORD Short;\n\t\t\tDWORD Long;\n\t\t} Name;\n\t\tPBYTE LongName[2];\n\t} N;\n\tDWORD Value;\n\tSHORT SectionNumber;\n\tWORD Type;\n\tBYTE StorageClass;\n\tBYTE NumberOfAuxSymbols;\n} IMAGE_SYMBOL;\ntypedef IMAGE_SYMBOL *PIMAGE_SYMBOL;\ntypedef union _IMAGE_AUX_SYMBOL {\n\tstruct {\n\t\tDWORD TagIndex;\n\t\tunion {\n\t\t\tstruct { WORD Linenumber; WORD Size; } LnSz;\n\t\t\tDWORD TotalSize;\n\t\t} Misc;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tDWORD PointerToLinenumber;\n\t\t\t\tDWORD PointerToNextFunction;\n\t\t\t} Function;\n\t\t\tstruct {\n\t\t\t\tWORD Dimension[4];\n\t\t\t} Array;\n\t\t} FcnAry;\n\t\tWORD TvIndex;\n\t} Sym;\n\tstruct {\n\t\tBYTE Name[IMAGE_SIZEOF_SYMBOL];\n\t} File;\n\tstruct {\n\t\tDWORD Length;\n\t\tWORD NumberOfRelocations;\n\t\tWORD NumberOfLinenumbers;\n\t\tDWORD CheckSum;\n\t\tSHORT Number;\n\t\tBYTE Selection;\n\t} Section;\n} IMAGE_AUX_SYMBOL;\ntypedef IMAGE_AUX_SYMBOL *PIMAGE_AUX_SYMBOL;\ntypedef struct _IMAGE_RELOCATION {\n#ifdef __LCC__ /* I do not support unnamed unions... jn */\n\tDWORD VirtualAddress;\n#else\n\tunion {\n\t\tDWORD VirtualAddress;\n\t\tDWORD RelocCount;\n\t};\n#endif\n\tDWORD SymbolTableIndex;\n\tWORD Type;\n} IMAGE_RELOCATION;\ntypedef IMAGE_RELOCATION *PIMAGE_RELOCATION;\ntypedef struct _IMAGE_BASE_RELOCATION {\n\tDWORD VirtualAddress;\n\tDWORD SizeOfBlock;\n} IMAGE_BASE_RELOCATION,*PIMAGE_BASE_RELOCATION;\ntypedef struct _IMAGE_LINENUMBER {\n\tunion {\n\t\tDWORD SymbolTableIndex;\n\t\tDWORD VirtualAddress;\n\t} Type;\n\tWORD Linenumber;\n} IMAGE_LINENUMBER;\ntypedef IMAGE_LINENUMBER *PIMAGE_LINENUMBER;\ntypedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {\n\tBYTE Name[16];\n\tBYTE Date[12];\n\tBYTE UserID[6];\n\tBYTE GroupID[6];\n\tBYTE Mode[8];\n\tBYTE Size[10];\n\tBYTE EndHeader[2];\n} IMAGE_ARCHIVE_MEMBER_HEADER,*PIMAGE_ARCHIVE_MEMBER_HEADER;\ntypedef struct _IMAGE_EXPORT_DIRECTORY {\n\tDWORD Characteristics;\n\tDWORD TimeDateStamp;\n\tWORD MajorVersion;\n\tWORD MinorVersion;\n\tDWORD Name;\n\tDWORD Base;\n\tDWORD NumberOfFunctions;\n\tDWORD NumberOfNames;\n\tDWORD AddressOfFunctions;\n\tDWORD AddressOfNames;\n\tDWORD AddressOfNameOrdinals;\n} IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;\n\ntypedef struct _IMAGE_IMPORT_BY_NAME {\n\tWORD Hint;\n\tBYTE Name[1];\n} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;\ntypedef struct _IMAGE_THUNK_DATA {\n\tunion {\n\t\tPBYTE ForwarderString;\n\t\tPDWORD Function;\n\t\tDWORD Ordinal;\n\t\tPIMAGE_IMPORT_BY_NAME AddressOfData;\n\t} ;\n} IMAGE_THUNK_DATA,*PIMAGE_THUNK_DATA;\ntypedef struct _IMAGE_THUNK_DATA64 {\n\tunion {\n\t\tULONGLONG ForwarderString;\n\t\tULONGLONG Function;\n\t\tULONGLONG Ordinal;\n\t\tULONGLONG AddressOfData;\n\t};\n} IMAGE_THUNK_DATA64;\ntypedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\n\tunion {\n\t\tDWORD Characteristics;\n\t\tDWORD OriginalFirstThunk;\n\t} ;\n\tDWORD TimeDateStamp;\n\tDWORD ForwarderChain;\n\tDWORD Name;\n\tDWORD FirstThunk;\n} IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;\ntypedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {\n\tDWORD TimeDateStamp;\n\tWORD OffsetModuleName;\n\tWORD NumberOfModuleForwarderRefs;\n} IMAGE_BOUND_IMPORT_DESCRIPTOR,*PIMAGE_BOUND_IMPORT_DESCRIPTOR;\ntypedef struct _IMAGE_BOUND_FORWARDER_REF {\n\tDWORD TimeDateStamp;\n\tWORD OffsetModuleName;\n\tWORD Reserved;\n} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;\ntypedef VOID ( *PIMAGE_TLS_CALLBACK)(PVOID,DWORD,PVOID);\ntypedef struct _IMAGE_TLS_DIRECTORY {\n\tDWORD StartAddressOfRawData;\n\tDWORD EndAddressOfRawData;\n\tPDWORD AddressOfIndex;\n\tPIMAGE_TLS_CALLBACK *AddressOfCallBacks;\n\tDWORD SizeOfZeroFill;\n\tDWORD Characteristics;\n} IMAGE_TLS_DIRECTORY,*PIMAGE_TLS_DIRECTORY;\ntypedef struct _IMAGE_RESOURCE_DIRECTORY {\n\tDWORD Characteristics;\n\tDWORD TimeDateStamp;\n\tWORD MajorVersion;\n\tWORD MinorVersion;\n\tWORD NumberOfNamedEntries;\n\tWORD NumberOfIdEntries;\n} IMAGE_RESOURCE_DIRECTORY,*PIMAGE_RESOURCE_DIRECTORY;\ntypedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {\n\tunion {\n\t\tstruct { unsigned NameOffset:31; unsigned NameIsString:1; };\n\t\tDWORD Name;\n\t\tWORD Id;\n\t} ;\n\tunion {\n\t\tDWORD OffsetToData;\n\t\tstruct { unsigned OffsetToDirectory:31; unsigned DataIsDirectory:1; };\n\t} ;\n} IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;\ntypedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {\n\tWORD Length;\n\tCHAR NameString[1];\n} IMAGE_RESOURCE_DIRECTORY_STRING,*PIMAGE_RESOURCE_DIRECTORY_STRING;\ntypedef struct _IMAGE_RESOURCE_DIR_STRING_U {\n\tWORD Length;\n\tWCHAR NameString[1];\n} IMAGE_RESOURCE_DIR_STRING_U,*PIMAGE_RESOURCE_DIR_STRING_U;\ntypedef struct _IMAGE_RESOURCE_DATA_ENTRY {\n\tDWORD OffsetToData;\n\tDWORD Size;\n\tDWORD CodePage;\n\tDWORD Reserved;\n} IMAGE_RESOURCE_DATA_ENTRY,*PIMAGE_RESOURCE_DATA_ENTRY;\ntypedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {\n\tDWORD Characteristics;\n\tDWORD TimeDateStamp;\n\tWORD MajorVersion;\n\tWORD MinorVersion;\n\tDWORD GlobalFlagsClear;\n\tDWORD GlobalFlagsSet;\n\tDWORD CriticalSectionDefaultTimeout;\n\tDWORD DeCommitFreeBlockThreshold;\n\tDWORD DeCommitTotalFreeThreshold;\n\tPVOID LockPrefixTable;\n\tDWORD MaximumAllocationSize;\n\tDWORD VirtualMemoryThreshold;\n\tDWORD ProcessHeapFlags;\n\tDWORD Reserved[4];\n} IMAGE_LOAD_CONFIG_DIRECTORY,*PIMAGE_LOAD_CONFIG_DIRECTORY;\ntypedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {\n\tDWORD BeginAddress;\n\tDWORD EndAddress;\n\tPVOID ExceptionHandler;\n\tPVOID HandlerData;\n\tDWORD PrologEndAddress;\n} IMAGE_RUNTIME_FUNCTION_ENTRY,*PIMAGE_RUNTIME_FUNCTION_ENTRY;\ntypedef struct _IMAGE_DEBUG_DIRECTORY {\n\tDWORD Characteristics;\n\tDWORD TimeDateStamp;\n\tWORD MajorVersion;\n\tWORD MinorVersion;\n\tDWORD Type;\n\tDWORD SizeOfData;\n\tDWORD AddressOfRawData;\n\tDWORD PointerToRawData;\n} IMAGE_DEBUG_DIRECTORY,*PIMAGE_DEBUG_DIRECTORY;\ntypedef struct _IMAGE_COFF_SYMBOLS_HEADER {\n\tDWORD NumberOfSymbols;\n\tDWORD LvaToFirstSymbol;\n\tDWORD NumberOfLinenumbers;\n\tDWORD LvaToFirstLinenumber;\n\tDWORD RvaToFirstByteOfCode;\n\tDWORD RvaToLastByteOfCode;\n\tDWORD RvaToFirstByteOfData;\n\tDWORD RvaToLastByteOfData;\n} IMAGE_COFF_SYMBOLS_HEADER,*PIMAGE_COFF_SYMBOLS_HEADER;\n#define FRAME_FPO 0\n#define FRAME_TRAP 1\n#define FRAME_TSS 2\n#define FRAME_NONFPO 3\ntypedef struct _FPO_DATA {\n\tDWORD ulOffStart;\n\tDWORD cbProcSize;\n\tDWORD cdwLocals;\n\tWORD cdwParams;\n\tunsigned cbProlog:8;\n\tunsigned cbRegs:3;\n\tunsigned fHasSEH:1;\n\tunsigned fUseBP:1;\n\tunsigned reserved:1;\n\tunsigned cbFrame:2;\n} FPO_DATA,*PFPO_DATA;\n#define SIZEOF_RFPO_DATA 16\ntypedef struct _IMAGE_DEBUG_MISC {\n\tDWORD DataType;\n\tDWORD Length;\n\tBOOLEAN Unicode;\n\tBYTE Reserved[3];\n\tBYTE Data[1];\n} IMAGE_DEBUG_MISC,*PIMAGE_DEBUG_MISC;\ntypedef struct _IMAGE_FUNCTION_ENTRY {\n\tDWORD StartingAddress;\n\tDWORD EndingAddress;\n\tDWORD EndOfPrologue;\n} IMAGE_FUNCTION_ENTRY,*PIMAGE_FUNCTION_ENTRY;\ntypedef struct _IMAGE_SEPARATE_DEBUG_HEADER {\n\tWORD Signature;\n\tWORD Flags;\n\tWORD Machine;\n\tWORD Characteristics;\n\tDWORD TimeDateStamp;\n\tDWORD CheckSum;\n\tDWORD ImageBase;\n\tDWORD SizeOfImage;\n\tDWORD NumberOfSections;\n\tDWORD ExportedNamesSize;\n\tDWORD DebugDirectorySize;\n\tDWORD SectionAlignment;\n\tDWORD Reserved[2];\n} IMAGE_SEPARATE_DEBUG_HEADER,*PIMAGE_SEPARATE_DEBUG_HEADER;\ntypedef int (CALLBACK *ENUMMETAFILEPROC)(HDC,HANDLETABLE *,METARECORD *,int,LPARAM);\ntypedef int (CALLBACK *ENHMETAFILEPROC) (HDC,HANDLETABLE,ENHMETARECORD,int,LPARAM);\ntypedef int (CALLBACK *ENUMFONTSPROC) (LPLOGFONT,LPTEXTMETRIC,DWORD,LPARAM);\ntypedef int (CALLBACK *FONTENUMPROC)(ENUMLOGFONT *,NEWTEXTMETRIC *,int,LPARAM);\ntypedef int (CALLBACK *FONTENUMEXPROC)(ENUMLOGFONTEX *,NEWTEXTMETRICEX *,int,LPARAM);\ntypedef VOID(CALLBACK *LPOVERLAPPED_COMPLETION_ROUTINE)(DWORD,DWORD,LPOVERLAPPED);\ntypedef int (CALLBACK* ENHMFENUMPROC)(HDC,HANDLETABLE *,ENHMETARECORD *,int,LPARAM);\ntypedef int (CALLBACK* MFENUMPROC)(HDC,HANDLETABLE *,METARECORD *,int,LPARAM);\ntypedef struct _NT_TIB {\n\tstruct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;\n\tPVOID StackBase;\n\tPVOID StackLimit;\n\tPVOID SubSystemTib;\n\tunion { PVOID FiberData; DWORD Version; };\n\tPVOID ArbitraryUserPointer;\n\tstruct _NT_TIB *Self;\n} NT_TIB;\ntypedef NT_TIB *PNT_TIB;\n#define THREAD_BASE_PRIORITY_LOWRT\t15\n#define THREAD_BASE_PRIORITY_MAX\t2\n#define THREAD_BASE_PRIORITY_MIN\t-2\n#define THREAD_BASE_PRIORITY_IDLE\t-15\n#pragma pack(push,8)\ntypedef struct _QUOTA_LIMITS {\n\tSIZE_T PagedPoolLimit;\n\tSIZE_T NonPagedPoolLimit;\n\tSIZE_T MinimumWorkingSetSize;\n\tSIZE_T MaximumWorkingSetSize;\n\tSIZE_T PagefileLimit;\n\tLARGE_INTEGER TimeLimit;\n} QUOTA_LIMITS, *PQUOTA_LIMITS;\n#pragma pack(pop)\n#define QUOTA_LIMITS_HARDWS_MIN_ENABLE\t1\n#define QUOTA_LIMITS_HARDWS_MIN_DISABLE 2\n#define QUOTA_LIMITS_HARDWS_MAX_ENABLE\t4\n#define QUOTA_LIMITS_HARDWS_MAX_DISABLE 8\ntypedef struct _QUOTA_LIMITS_EX {\n\tSIZE_T PagedPoolLimit;\n\tSIZE_T NonPagedPoolLimit;\n\tSIZE_T MinimumWorkingSetSize;\n\tSIZE_T MaximumWorkingSetSize;\n\tSIZE_T PagefileLimit;\n\tLARGE_INTEGER TimeLimit;\n\tSIZE_T Reserved1;\n\tSIZE_T Reserved2;\n\tSIZE_T Reserved3;\n\tSIZE_T Reserved4;\n\tDWORD Flags;\n\tDWORD Reserved5;\n} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;\ntypedef struct _IO_COUNTERS {\n\tULONGLONG ReadOperationCount;\n\tULONGLONG WriteOperationCount;\n\tULONGLONG OtherOperationCount;\n\tULONGLONG ReadTransferCount;\n\tULONGLONG WriteTransferCount;\n\tULONGLONG OtherTransferCount;\n} IO_COUNTERS;\ntypedef IO_COUNTERS *PIO_COUNTERS;\ntypedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {\n\tLARGE_INTEGER PerProcessUserTimeLimit;\n\tLARGE_INTEGER PerJobUserTimeLimit;\n\tDWORD LimitFlags;\n\tSIZE_T MinimumWorkingSetSize;\n\tSIZE_T MaximumWorkingSetSize;\n\tDWORD ActiveProcessLimit;\n\tULONG_PTR Affinity;\n\tDWORD PriorityClass;\n\tDWORD SchedulingClass;\n} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;\ntypedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {\n\tJOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;\n\tDWORD align;\n\tIO_COUNTERS IoInfo;\n\tSIZE_T ProcessMemoryLimit;\n\tSIZE_T JobMemoryLimit;\n\tSIZE_T PeakProcessMemoryUsed;\n\tSIZE_T PeakJobMemoryUsed;\n} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;\ntypedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {\n\tDWORD NumberOfAssignedProcesses;\n\tDWORD NumberOfProcessIdsInList;\n\tULONG_PTR ProcessIdList[1];\n} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;\ntypedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {\n\tDWORD UIRestrictionsClass;\n} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;\ntypedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {\n\tDWORD SecurityLimitFlags ;\n\tHANDLE JobToken ;\n\tPTOKEN_GROUPS SidsToDisable ;\n\tPTOKEN_PRIVILEGES PrivilegesToDelete ;\n\tPTOKEN_GROUPS RestrictedSids ;\n} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;\ntypedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {\n\tDWORD EndOfJobTimeAction;\n} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;\ntypedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {\n\tPVOID CompletionKey;\n\tHANDLE CompletionPort;\n} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;\ntypedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {\n\tLARGE_INTEGER TotalUserTime;\n\tLARGE_INTEGER TotalKernelTime;\n\tLARGE_INTEGER ThisPeriodTotalUserTime;\n\tLARGE_INTEGER ThisPeriodTotalKernelTime;\n\tDWORD TotalPageFaultCount;\n\tDWORD TotalProcesses;\n\tDWORD ActiveProcesses;\n\tDWORD TotalTerminatedProcesses;\n} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;\ntypedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {\n\tJOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;\n\tIO_COUNTERS IoInfo;\n} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;\ntypedef struct _JOBOBJECT_JOBSET_INFORMATION {\n\tDWORD MemberLevel;\n} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;\n#define JOB_OBJECT_TERMINATE_AT_END_OF_JOB 0\n#define JOB_OBJECT_POST_AT_END_OF_JOB\t1\ntypedef struct tagPIXELFORMATDESCRIPTOR {\n\tWORD\tnSize;\n\tWORD\tnVersion;\n\tDWORD\tdwFlags;\n\tBYTE\tiPixelType;\n\tBYTE\tcColorBits;\n\tBYTE\tcRedBits;\n\tBYTE\tcRedShift;\n\tBYTE\tcGreenBits;\n\tBYTE\tcGreenShift;\n\tBYTE\tcBlueBits;\n\tBYTE\tcBlueShift;\n\tBYTE\tcAlphaBits;\n\tBYTE\tcAlphaShift;\n\tBYTE\tcAccumBits;\n\tBYTE\tcAccumRedBits;\n\tBYTE\tcAccumGreenBits;\n\tBYTE\tcAccumBlueBits;\n\tBYTE\tcAccumAlphaBits;\n\tBYTE\tcDepthBits;\n\tBYTE\tcStencilBits;\n\tBYTE\tcAuxBuffers;\n\tBYTE\tiLayerType;\n\tBYTE\tbReserved;\n\tDWORD\tdwLayerMask;\n\tDWORD\tdwVisibleMask;\n\tDWORD\tdwDamageMask;\n} PIXELFORMATDESCRIPTOR,*PPIXELFORMATDESCRIPTOR,*LPPIXELFORMATDESCRIPTOR;\ntypedef struct _WIN_CERTIFICATE {\n\tDWORD\tdwLength;\n\tWORD\twRevision;\n\tWORD\twCertificateType;\n\tBYTE\tbCertificate[1];\n} WIN_CERTIFICATE,*LPWIN_CERTIFICATE;\n#define WIN_CERT_REVISION_1_0\t0x100\n#define WIN_CERT_TYPE_X509 1\n#define WIN_CERT_TYPE_PKCS_SIGNED_DATA\t2\n#define WIN_CERT_TYPE_RESERVED_1\t3\ntypedef LPVOID WIN_TRUST_SUBJECT;\ntypedef struct _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT {\n\tHANDLE\thClientToken;\n\tGUID\t*SubjectType;\n\tWIN_TRUST_SUBJECT Subject;\n} WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT,*LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;\ntypedef struct _WIN_TRUST_ACTDATA_SUBJECT_ONLY {\n\tGUID\t*SubjectType;\n\tWIN_TRUST_SUBJECT Subject;\n} WIN_TRUST_ACTDATA_SUBJECT_ONLY,*LPWIN_TRUST_ACTDATA_SUBJECT_ONLY;\n#define WIN_TRUST_SUBJTYPE_RAW_FILE {0x959dc450,0x8d9e,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}\n#define WIN_TRUST_SUBJTYPE_PE_IMAGE {0x43c9a1e0,0x8da0,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}\n#define WIN_TRUST_SUBJTYPE_OLE_STORAGE {0xc257e740,0x8da0,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}\n#define WIN_TRUST_SUBJTYPE_JAVA_CLASS {0x08ad3990,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}\ntypedef struct _WIN_TRUST_SUBJECT_FILE {\n\tHANDLE hFile; LPCWSTR lpPath;\n} WIN_TRUST_SUBJECT_FILE,*LPWIN_TRUST_SUBJECT_FILE;\n/* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb */\n#define WIN_SPUB_ACTION_TRUSTED_PUBLISHER {0x66426730,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}\n#define WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE {0x8bc96b00,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}\n#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE {0x64b9d180,0x8da2,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}\ntypedef struct _WIN_SPUB_TRUSTED_PUBLISHER_DATA { HANDLE hClientToken;\n\tLPWIN_CERTIFICATE\tlpCertificate;\n} WIN_SPUB_TRUSTED_PUBLISHER_DATA,*LPWIN_SPUB_TRUSTED_PUBLISHER_DATA;\ntypedef VOID (WINAPI *PFIBER_START_ROUTINE)(LPVOID);\ntypedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;\ntypedef struct tagNMDATETIMECHANGE {\n NMHDR nmhdr;\n DWORD dwFlags;\n SYSTEMTIME st;\n} NMDATETIMECHANGE,*LPNMDATETIMECHANGE;\ntypedef struct tagNMDATETIMESTRINGA {\n NMHDR nmhdr;\n LPCSTR pszUserString;\n SYSTEMTIME st;\n DWORD dwFlags;\n} NMDATETIMESTRINGA,FAR * LPNMDATETIMESTRINGA;\ntypedef struct tagNMDATETIMESTRINGW {\n NMHDR nmhdr;\n LPCWSTR pszUserString;\n SYSTEMTIME st;\n DWORD dwFlags;\n} NMDATETIMESTRINGW,* LPNMDATETIMESTRINGW;\ntypedef struct tagNMDATETIMEWMKEYDOWNA {\n\tNMHDR\tnmhdr;\n\tint\tnVirtKey;\n\tLPCSTR\tpszFormat;\n\tSYSTEMTIME\tst;\n} NMDATETIMEWMKEYDOWNA,* LPNMDATETIMEWMKEYDOWNA;\ntypedef struct tagNMDATETIMEWMKEYDOWNW {\n\tNMHDR\tnmhdr;\n\tint\tnVirtKey;\n\tLPCWSTR\tpszFormat;\n\tSYSTEMTIME\tst;\n} NMDATETIMEWMKEYDOWNW,* LPNMDATETIMEWMKEYDOWNW;\ntypedef struct tagNMDATETIMEFORMATA {\n\tNMHDR\tnmhdr;\n\tLPCSTR\tpszFormat;\n\tSYSTEMTIME st;\n\tLPCSTR pszDisplay;\n\tCHAR szDisplay[64];\n} NMDATETIMEFORMATA,* LPNMDATETIMEFORMATA;\ntypedef struct tagNMDATETIMEFORMATW {\n\tNMHDR nmhdr;\n\tLPCWSTR pszFormat;\n\tSYSTEMTIME st;\n\tLPCWSTR pszDisplay;\n\tWCHAR szDisplay[64];\n} NMDATETIMEFORMATW,* LPNMDATETIMEFORMATW;\ntypedef struct tagNMDATETIMEFORMATQUERYA {\n\tNMHDR nmhdr;\n\tLPCSTR pszFormat;\n\tSIZE szMax;\n} NMDATETIMEFORMATQUERYA,* LPNMDATETIMEFORMATQUERYA;\ntypedef struct tagNMDATETIMEFORMATQUERYW {\n\tNMHDR nmhdr;\n\tLPCWSTR pszFormat;\n\tSIZE szMax;\n} NMDATETIMEFORMATQUERYW,* LPNMDATETIMEFORMATQUERYW;\ntypedef struct _COAUTHIDENTITY {\n\tUSHORT *User;\n\tULONG UserLength;\n\tUSHORT *Domain;\n\tULONG DomainLength;\n\tUSHORT *Password;\n\tULONG PasswordLength;\n\tULONG Flags;\n} COAUTHIDENTITY;\ntypedef struct _COAUTHINFO {\n\tDWORD dwAuthnSvc;\n\tDWORD dwAuthzSvc;\n\tLPWSTR pwszServerPrincName;\n\tDWORD dwAuthnLevel;\n\tDWORD dwImpersonationLevel;\n\tCOAUTHIDENTITY *pAuthIdentityData;\n\tDWORD dwCapabilities;\n} COAUTHINFO;\ntypedef WCHAR OLECHAR;\ntypedef struct _userCLIPFORMAT {\n\tlong fContext;\n\tunion __MIDL_IWinTypes_0001 {\n\t\tDWORD dwValue;\n\t\tshort *pwszName;\n\t} u;\n} userCLIPFORMAT;\ntypedef struct _userBITMAP {\n\tLONG bmType;\n\tLONG bmWidth;\n\tLONG bmHeight;\n\tLONG bmWidthBytes;\n\tWORD bmPlanes;\n\tWORD bmBitsPixel;\n\tULONG cbSize;\n\tUCHAR pBuffer[1];\n} userBITMAP;\ntypedef struct _userHBITMAP {\n\tlong fContext;\n\tunion __MIDL_IWinTypes_0007 {\n\t\tlong hInproc;\n\t\tuserBITMAP *hRemote;\n\t\tlong hGlobal;\n\t} u;\n} userHBITMAP;\ntypedef struct tagrpcLOGPALETTE {\n\tWORD palVersion;\n\tWORD palNumEntries;\n\tPALETTEENTRY palPalEntry[1];\n} rpcLOGPALETTE;\ntypedef struct _FLAGGED_BYTE_BLOB {\n\tunsigned long fFlags;\n\tunsigned long clSize;\n\tBYTE abData[1];\n} FLAGGED_BYTE_BLOB;\ntypedef struct _BYTE_BLOB {\n\tunsigned long clSize;\n\tBYTE abData[1];\n} BYTE_BLOB;\ntypedef struct _userHMETAFILE {\n\tlong fContext;\n\tunion __MIDL_IWinTypes_0004 {\n\t\tlong hInproc;\n\t\tBYTE_BLOB *hRemote;\n\t\tlong hGlobal;\n\t} u;\n} userHMETAFILE;\ntypedef struct _remoteMETAFILEPICT {\n\tlong mm;\n\tlong xExt;\n\tlong yExt;\n\tuserHMETAFILE *hMF;\n} remoteMETAFILEPICT;\ntypedef struct _userHENHMETAFILE {\n\tlong fContext;\n\tunion __MIDL_IWinTypes_0006 {\n\t\tlong hInproc;\n\t\tBYTE_BLOB *hRemote;\n\t\tlong hGlobal;\n\t} u;\n} userHENHMETAFILE;\ntypedef struct _userHMETAFILEPICT {\n\tlong fContext;\n\tunion __MIDL_IWinTypes_0005 {\n\t\tlong hInproc;\n\t\tremoteMETAFILEPICT *hRemote;\n\t\tlong hGlobal;\n\t} u;\n} userHMETAFILEPICT;\ntypedef struct _userHGLOBAL {\n\tlong fContext;\n\tunion __MIDL_IWinTypes_0003 {\n\t\tlong hInproc;\n\t\tFLAGGED_BYTE_BLOB *hRemote;\n\t\tlong hGlobal;\n\t} u;\n} userHGLOBAL;\ntypedef struct _userHPALETTE {\n\tlong fContext;\n\tunion __MIDL_IWinTypes_0008 {\n\t\tlong hInproc;\n\t\trpcLOGPALETTE *hRemote;\n\t\tlong hGlobal;\n\t} u;\n} userHPALETTE;\n#ifndef _tagBSTRBLOB_DEFINED\n#define _tagBSTRBLOB_DEFINED\ntypedef struct tagBSTRBLOB {\n\tULONG cbSize;\n\tBYTE *pData;\n} BSTRBLOB;\ntypedef struct tagBSTRBLOB *LPBSTRBLOB;\n#endif\ntypedef struct _CLIPDATA {\n\tULONG cbSize;\n\tlong ulClipFmt;\n\tBYTE *pClipData;\n} CLIPDATA;\ntypedef struct _FLAGGED_WORD_BLOB {\n\tunsigned long fFlags;\n\tunsigned long clSize;\n\tunsigned short asData[1];\n}FLAGGED_WORD_BLOB;\ntypedef struct _BYTE_SIZEDARR {\n\tunsigned long clSize;\n\tunsigned char *pData;\n}BYTE_SIZEDARR;\ntypedef struct _SHORT_SIZEDARR {\n\tunsigned long clSize;\n\tunsigned short *pData;\n} WORD_SIZEDARR;\ntypedef struct _LONG_SIZEDARR {\n\tunsigned long clSize;\n\tunsigned long *pData;\n}DWORD_SIZEDARR;\ntypedef struct _HYPER_SIZEDARR {\n\tunsigned long clSize;\n\tlong long int *pData;\n}HYPER_SIZEDARR;\ntypedef FLAGGED_WORD_BLOB *wireBSTR;\ntypedef userHENHMETAFILE *wireHENHMETAFILE;\ntypedef userHGLOBAL *wireHGLOBAL;\ntypedef userHMETAFILEPICT wireHMETAFILEPICT;\ntypedef userHMETAFILE *wireHMETAFILE;\ntypedef userHPALETTE *wireHPALETTE;\ntypedef userHBITMAP *wireHBITMAP;\ntypedef userCLIPFORMAT *wireCLIPFORMAT;\ntypedef WORD CLIPFORMAT;\ntypedef unsigned long PROPID;\ntypedef OLECHAR *LPOLESTR;\ntypedef GUID FMTID;\ntypedef FMTID *REFFMTID;\ntypedef enum _CLASSPATHTYPE { ExeNamePath=0,DllNamePath=ExeNamePath+1,TlbNamePath=DllNamePath+1,\n\tCabFilePath=TlbNamePath+1,InfFilePath=CabFilePath+1,DrwFilePath=InfFilePath+1,\n\tSetupNamePath=DrwFilePath+1 } CLASSPATHTYPE;\ntypedef struct __MIDL___MIDL_itf_wtypes_0002_0001 {\n\tDWORD tyspec;\n\tunion __MIDL___MIDL_itf_wtypes_0002_00 {\n\t\tCLSID clsid;\n\t\tIID iid;\n\t\tGUID typelibID;\n\t\tLPOLESTR pFileExt;\n\t\tLPOLESTR pMimeType;\n\t\tLPOLESTR pProgId;\n\t\tLPOLESTR pFileName;\n\t\tLPOLESTR pJavaClassName;\n\t\tstruct { LPOLESTR pPackageName; GUID PolicyId;} ByName;\n\t\tstruct { LPOLESTR pScriptName; GUID PolicyId;} ByScript;\n\t} tagged_union;\n} uCLSSPEC;\ntypedef struct _CSPLATFORM {\n\tDWORD dwPlatformId;\n\tDWORD dwVersionHi;\n\tDWORD dwVersionLo;\n\tDWORD dwProcessorArch;\n} CSPLATFORM;\ntypedef struct _QUERYCONTEXT {\n\tDWORD dwContext;\n\tCSPLATFORM Platform;\n\tLCID Locale;\n\tDWORD dwVersionHi;\n\tDWORD dwVersionLo;\n} QUERYCONTEXT;\ntypedef struct _CLASSDETAIL {\n\tCLSID Clsid;\n\tCLSID TreatAs;\n\tDWORD cProgId;\n\tDWORD dwComClassContext;\n\tLPOLESTR *prgProgId;\n} CLASSDETAIL;\ntypedef struct _ACTIVATIONINFO {\n\tUINT cClasses;\n\tCLASSDETAIL *pClasses;\n\tUINT cShellFileExt;\n\tLPOLESTR *prgShellFileExt;\n\tUINT *prgPriority;\n\tUINT cInterfaces;\n\tIID *prgInterfaceId;\n\tUINT cTypeLib;\n\tGUID *prgTlbId;\n} ACTIVATIONINFO;\ntypedef struct _PLATFORMINFO {\n\tUINT cPlatforms;\n\tCSPLATFORM *prgPlatform;\n UINT cLocales;\n\tLCID *prgLocale;\n} PLATFORMINFO;\ntypedef struct tagINSTALLINFO {\n\tDWORD dwActFlags;\n\tCLASSPATHTYPE PathType;\n\tLPOLESTR pszScriptPath;\n\tLPOLESTR pszSetupCommand;\n\tLPOLESTR pszUrl;\n\tULONGLONG Usn;\n\tUINT InstallUiLevel;\n\tGUID *pClsid;\n\tGUID ProductCode;\n\tGUID Mvipc;\n\tDWORD dwVersionHi;\n\tDWORD dwVersionLo;\n\tDWORD dwRevision;\n\tUINT cUpgrades;\n\tLPOLESTR *prgUpgradeScript;\n\tDWORD *prgUpgradeFlag;\n\tULONG cScriptLen;\n}INSTALLINFO;\ntypedef struct tagPACKAGEDETAIL {\n\tLPOLESTR pszPackageName;\n\tLPOLESTR pszPublisher;\n\tUINT cSources;\n\tLPOLESTR *pszSourceList;\n\tUINT cCategories;\n\tGUID *rpCategory;\n\tACTIVATIONINFO *pActInfo;\n\tPLATFORMINFO *pPlatformInfo;\n\tINSTALLINFO *pInstallInfo;\n} PACKAGEDETAIL;\ntypedef struct tagTRACKMOUSEEVENT {\n\tDWORD cbSize;\n\tDWORD dwFlags;\n\tHWND hwndTrack;\n\tDWORD dwHoverTime;\n} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;\ntypedef struct tagREBARINFO {\n\tUINT cbSize;\n\tUINT fMask;\n\tHANDLE himl;\n} REBARINFO,*LPREBARINFO;\ntypedef struct tagREBARBANDINFOA {\n\tUINT cbSize;\n\tUINT fMask;\n\tUINT fStyle;\n\tCOLORREF clrFore;\n\tCOLORREF clrBack;\n\tLPSTR lpText;\n\tUINT cch;\n\tint iImage;\n\tHWND hwndChild;\n\tUINT cxMinChild;\n\tUINT cyMinChild;\n\tUINT cx;\n\tHBITMAP hbmBack;\n\tUINT wID;\n\tUINT cyChild;\n\tUINT cyMaxChild;\n\tUINT cyIntegral;\n\tUINT cxIdeal;\n\tLPARAM lParam;\n\tUINT cxHeader;\n} REBARBANDINFOA,*LPREBARBANDINFOA;\ntypedef REBARBANDINFOA CONST *LPCREBARBANDINFOA;\ntypedef struct tagREBARBANDINFOW {\n\tUINT\tcbSize;\n\tUINT\tfMask;\n\tUINT\tfStyle;\n\tCOLORREF\tclrFore;\n\tCOLORREF\tclrBack;\n\tLPWSTR\tlpText;\n\tUINT\tcch;\n\tint\tiImage;\n\tHWND\thwndChild;\n\tUINT\tcxMinChild;\n\tUINT\tcyMinChild;\n\tUINT\tcx;\n\tHBITMAP\thbmBack;\n\tUINT\twID;\n\tUINT\tcyChild;\n\tUINT\tcyMaxChild;\n\tUINT\tcyIntegral;\n\tUINT\tcxIdeal;\n\tLPARAM\tlParam;\n\tUINT\tcxHeader;\n} REBARBANDINFOW, *LPREBARBANDINFOW;\ntypedef REBARBANDINFOW CONST *LPCREBARBANDINFOW;\ntypedef struct tagLVITEMA {\n\tUINT mask;\n\tint iItem;\n\tint iSubItem;\n\tUINT state;\n\tUINT stateMask;\n\tLPSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tLPARAM lParam;\n\tint iIndent;\n} LVITEMA, *LPLVITEMA;\ntypedef struct tagLVITEMW {\n\tUINT mask;\n\tint iItem;\n\tint iSubItem;\n\tUINT state;\n\tUINT stateMask;\n\tLPWSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tLPARAM lParam;\n\tint iIndent;\n} LVITEMW, *LPLVITEMW;\ntypedef struct tagLVDISPINFO {\n\tNMHDR hdr;\n\tLVITEMA item;\n} NMLVDISPINFOA, *LPNMLVDISPINFOA;\ntypedef struct tagLVDISPINFOW {\n\tNMHDR hdr;\n\tLVITEMW item;\n} NMLVDISPINFOW, *LPNMLVDISPINFOW;\n#define LVN_KEYDOWN\t(-155)\n#define LV_KEYDOWN NMLVKEYDOWN\ntypedef struct tagLVKEYDOWN {\n\tNMHDR hdr;\n\tWORD wVKey;\n\tUINT flags;\n} NMLVKEYDOWN, *LPNMLVKEYDOWN;\n#define LVN_MARQUEEBEGIN\t(-156)\ntypedef struct tagNMLVGETINFOTIPA {\n\tNMHDR hdr;\n\tDWORD dwFlags;\n\tLPSTR pszText;\n\tint cchTextMax;\n\tint iItem;\n\tint iSubItem;\n\tLPARAM lParam;\n} NMLVGETINFOTIPA, *LPNMLVGETINFOTIPA;\ntypedef struct tagNMLVGETINFOTIPW {\n\tNMHDR hdr;\n\tDWORD dwFlags;\n\tLPWSTR pszText;\n\tint cchTextMax;\n\tint iItem;\n\tint iSubItem;\n\tLPARAM lParam;\n} NMLVGETINFOTIPW, *LPNMLVGETINFOTIPW;\n#define LVGIT_UNFOLDED\t1\n#define LVN_GETINFOTIPA (-157)\n#define LVN_GETINFOTIPW (-158)\ntypedef struct tagNMMOUSE {\n\tNMHDR\thdr;\n\tDWORD_PTR dwItemSpec;\n\tDWORD_PTR dwItemData;\n\tPOINT\tpt;\n\tLPARAM dwHitInfo;\n} NMMOUSE, *LPNMMOUSE;\ntypedef NMMOUSE NMCLICK;\ntypedef LPNMMOUSE LPNMCLICK;\ntypedef struct tagNMLVCACHEHINT {\n\tNMHDR hdr;\n\tint iFrom;\n\tint iTo;\n} NMLVCACHEHINT,*LPNMLVCACHEHINT;\ntypedef struct tagCOLORSCHEME {\n\tDWORD\tdwSize;\n\tCOLORREF\tclrBtnHighlight;\n\tCOLORREF\tclrBtnShadow;\n} COLORSCHEME, *LPCOLORSCHEME;\n#define LPNM_CACHEHINT\tLPNMLVCACHEHINT\n#define PNM_CACHEHINT\tLPNMLVCACHEHINT\n#define NM_CACHEHINT\tNMLVCACHEHINT\ntypedef struct tagLVFINDINFOA {\n\tUINT flags;\n\tLPCSTR psz;\n\tLPARAM lParam;\n\tPOINT pt;\n\tUINT vkDirection;\n} LVFINDINFOA, *LPFINDINFOA;\ntypedef struct tagLVFINDINFOW {\n\tUINT flags;\n\tLPCWSTR psz;\n\tLPARAM lParam;\n\tPOINT pt;\n\tUINT vkDirection;\n} LVFINDINFOW, *LPFINDINFOW;\ntypedef struct tagNMLVFINDITEM {\n\tNMHDR hdr;\n\tint iStart;\n\tLVFINDINFO lvfi;\n} NMLVFINDITEM, *LPNMLVFINDITEM;\n#define PNM_FINDITEM LPNMLVFINDITEM\n#define LPNM_FINDITEM LPNMLVFINDITEM\n#define NM_FINDITEM NMLVFINDITEM\ntypedef struct tagNMLVODSTATECHANGE {\n\tNMHDR hdr;\n\tint iFrom;\n\tint iTo;\n\tUINT uNewState;\n\tUINT uOldState;\n} NMLVODSTATECHANGE, *LPNMLVODSTATECHANGE;\n#define PNM_ODSTATECHANGE LPNMLVODSTATECHANGE\n#define LPNM_ODSTATECHANGE LPNMLVODSTATECHANGE\n#define NM_ODSTATECHANGE NMLVODSTATECHANGE\n#define IID_NULL\tGUID_NULL\n#define CLSID_NULL\tGUID_NULL\n#define FMTID_NULL\tGUID_NULL\ntypedef struct tagNMITEMACTIVATE{\n\tNMHDR\thdr;\n\tint\tiItem;\n\tint\tiSubItem;\n\tUINT\tuNewState;\n\tUINT\tuOldState;\n\tUINT\tuChanged;\n\tPOINT\tptAction;\n\tLPARAM\tlParam;\n\tUINT\tuKeyFlags;\n} NMITEMACTIVATE, *LPNMITEMACTIVATE;\ntypedef struct _LVHITTESTINFO {\n\tPOINT pt;\n\tUINT flags;\n\tint iItem;\n\tint iSubItem;\n} LVHITTESTINFO, *LPLVHITTESTINFO;\ntypedef struct tagCOMBOBOXINFO {\n\tDWORD cbSize;\n\tRECT rcItem;\n\tRECT rcButton;\n\tDWORD stateButton;\n\tHWND hwndCombo;\n\tHWND hwndItem;\n\tHWND hwndList;\n} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;\ntypedef struct tagWINDOWINFO {\n\tDWORD cbSize;\n\tRECT rcWindow;\n\tRECT rcClient;\n\tDWORD dwStyle;\n\tDWORD dwExStyle;\n\tDWORD dwWindowStatus;\n\tUINT cxWindowBorders;\n\tUINT cyWindowBorders;\n\tATOM atomWindowType;\n\tWORD wCreatorVersion;\n} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;\ntypedef VOID (APIENTRY *PAPCFUNC)(ULONG *);\n#define INPUT_MOUSE\t0\n#define INPUT_KEYBOARD\t1\n#define INPUT_HARDWARE\t2\ntypedef struct tagMOUSEINPUT {\n\tLONG\tdx;\n\tLONG\tdy;\n\tDWORD\tmouseData;\n\tDWORD\tdwFlags;\n\tDWORD\ttime;\n\tDWORD\tdwExtraInfo;\n} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;\ntypedef struct tagHARDWAREINPUT {\n\tDWORD\tuMsg;\n\tWORD\twParamL;\n\tWORD\twParamH;\n} HARDWAREINPUT, *PHARDWAREINPUT, *LPHARDWAREINPUT;\ntypedef struct tagKEYBDINPUT {\n\tWORD\twVk;\n\tWORD\twScan;\n\tDWORD\tdwFlags;\n\tDWORD\ttime;\n\tDWORD\tdwExtraInfo;\n} KEYBDINPUT, *PKEYBDINPUT, FAR* LPKEYBDINPUT;\ntypedef struct tagINPUT {\n\tDWORD\ttype;\n\tunion {\n\t\tMOUSEINPUT\tmi;\n\t\tKEYBDINPUT\tki;\n\t\tHARDWAREINPUT\thi;\n\t};\n} INPUT, *PINPUT, *LPINPUT;\ntypedef struct tagMENUBARINFO {\n\tDWORD cbSize;\n\tRECT rcBar;\n\tHMENU hMenu;\n\tHWND hwndMenu;\n\tBOOL fBarFocused:1;\n\tBOOL fFocused:1;\n} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;\ntypedef struct tagSCROLLBARINFO {\n\tDWORD\tcbSize;\n\tRECT\trcScrollBar;\n\tint\tdxyLineButton;\n\tint\txyThumbTop;\n\tint\txyThumbBottom;\n\tint\treserved;\n\tDWORD rgstate[CCHILDREN_SCROLLBAR+1];\n} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;\ntypedef struct tagTITLEBARINFO {\n\tDWORD\tcbSize;\n\tRECT\trcTitleBar;\n\tDWORD\trgstate[CCHILDREN_TITLEBAR+1];\n} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;\ntypedef struct tagCURSORINFO {\n\tDWORD\tcbSize;\n\tDWORD\tflags;\n\tHCURSOR hCursor;\n\tPOINT\tptScreenPos;\n} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;\ntypedef struct {\n\tNMHDR hdr;\n\tint\tiItemid;\n\tWCHAR szText[CBEMAXSTRLEN];\n}NMCBEDRAGBEGINW, *LPNMCBEDRAGBEGINW, *PNMCBEDRAGBEGINW;\ntypedef struct {\n\tNMHDR hdr;\n\tint\tiItemid;\n\tchar szText[CBEMAXSTRLEN];\n}NMCBEDRAGBEGINA, *LPNMCBEDRAGBEGINA, *PNMCBEDRAGBEGINA;\ntypedef struct {\n\tNMHDR hdr;\n\tBOOL fChanged;\n\tint iNewSelection;\n\tWCHAR szText[CBEMAXSTRLEN];\n\tint iWhy;\n} NMCBEENDEDITW, *LPNMCBEENDEDITW, *PNMCBEENDEDITW;\n\ntypedef struct {\n\tNMHDR hdr;\n\tBOOL fChanged;\n\tint iNewSelection;\n\tchar szText[CBEMAXSTRLEN];\n\tint iWhy;\n} NMCBEENDEDITA, *LPNMCBEENDEDITA,*PNMCBEENDEDITA;\ntypedef struct tagCOMBOBOXEXITEMA {\n\tUINT mask;\n\tint iItem;\n\tLPSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tint iSelectedImage;\n\tint iOverlay;\n\tint iIndent;\n\tLPARAM lParam;\n} COMBOBOXEXITEMA, *PCOMBOBOXEXITEMA;\ntypedef COMBOBOXEXITEMA CONST *PCCOMBOEXITEMA;\ntypedef struct tagCOMBOBOXEXITEMW {\n\tUINT mask;\n\tint iItem;\n\tLPWSTR pszText;\n\tint cchTextMax;\n\tint iImage;\n\tint iSelectedImage;\n\tint iOverlay;\n\tint iIndent;\n\tLPARAM lParam;\n} COMBOBOXEXITEMW, *PCOMBOBOXEXITEMW;\ntypedef COMBOBOXEXITEMW CONST *PCCOMBOEXITEMW;\ntypedef struct tagNMHDDISPINFOW {\n\tNMHDR\thdr;\n\tint\tiItem;\n\tUINT\tmask;\n\tLPWSTR pszText;\n\tint\tcchTextMax;\n\tint\tiImage;\n\tLPARAM lParam;\n} NMHDDISPINFOW, *LPNMHDDISPINFOW;\ntypedef struct tagNMHDDISPINFOA {\n\tNMHDR\thdr;\n\tint\tiItem;\n\tUINT\tmask;\n\tLPSTR\tpszText;\n\tint\tcchTextMax;\n\tint\tiImage;\n\tLPARAM lParam;\n} NMHDDISPINFOA,*LPNMHDDISPINFOA;\n#ifdef UNICODE\n#define NMHDDISPINFO\tNMHDDISPINFOW\n#define LPNMHDDISPINFO\tLPNMHDDISPINFOW\n#else\n#define NMHDDISPINFO\tNMHDDISPINFOA\n#define LPNMHDDISPINFO\tLPNMHDDISPINFOA\n#endif\ntypedef enum _JOBOBJECTINFOCLASS { JobObjectBasicAccountingInformation = 1,\n\tJobObjectBasicLimitInformation, JobObjectBasicProcessIdList,\n\tJobObjectBasicUIRestrictions, JobObjectSecurityLimitInformation,\n\tJobObjectEndOfJobTimeInformation, JobObjectAssociateCompletionPortInformation,\n\tJobObjectBasicAndIoAccountingInformation, JobObjectExtendedLimitInformation,\n\tJobObjectJobSetInformation, MaxJobObjectInfoClass\n} JOBOBJECTINFOCLASS;\ntypedef struct tagPDA {\n\tDWORD lStructSize;\n\tHWND hwndOwner;\n\tHGLOBAL hDevMode;\n\tHGLOBAL hDevNames;\n\tHDC hDC;\n\tDWORD Flags;\n\tWORD nFromPage;\n\tWORD nToPage;\n\tWORD nMinPage;\n\tWORD nMaxPage;\n\tWORD nCopies;\n\tHINSTANCE hInstance;\n\tLPARAM lCustData;\n\tLPPRINTHOOKPROC lpfnPrintHook;\n\tLPSETUPHOOKPROC lpfnSetupHook;\n\tLPCSTR lpPrintTemplateName;\n\tLPCSTR lpSetupTemplateName;\n\tHGLOBAL hPrintTemplate;\n\tHGLOBAL hSetupTemplate;\n} PRINTDLGA, *LPPRINTDLGA;\ntypedef struct tagPDW {\n\tDWORD lStructSize;\n\tHWND hwndOwner;\n\tHGLOBAL hDevMode;\n\tHGLOBAL hDevNames;\n\tHDC\thDC;\n\tDWORD Flags;\n\tWORD nFromPage;\n\tWORD nToPage;\n\tWORD nMinPage;\n\tWORD nMaxPage;\n\tWORD nCopies;\n\tHINSTANCE hInstance;\n\tLPARAM lCustData;\n\tLPPRINTHOOKPROC lpfnPrintHook;\n\tLPSETUPHOOKPROC lpfnSetupHook;\n\tLPCWSTR lpPrintTemplateName;\n\tLPCWSTR lpSetupTemplateName;\n\tHGLOBAL hPrintTemplate;\n\tHGLOBAL\t\thSetupTemplate;\n} PRINTDLGW, *LPPRINTDLGW;\ntypedef struct tagHW_PROFILE_INFOA {\n\tDWORD dwDockInfo; CHAR szHwProfileGuid[HW_PROFILE_GUIDLEN];\n\tCHAR\tszHwProfileName[MAX_PROFILE_LEN];\n} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;\ntypedef struct tagHW_PROFILE_INFOW {\n\tDWORD dwDockInfo;\n\tWCHAR szHwProfileGuid[HW_PROFILE_GUIDLEN];\n\tWCHAR szHwProfileName[MAX_PROFILE_LEN];\n} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;\ntypedef struct _FILE_NOTIFY_INFORMATION {\n\tDWORD NextEntryOffset;\n\tDWORD Action;\n\tDWORD FileNameLength;\n\tWCHAR FileName[1];\n} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;\ntypedef union _FILE_SEGMENT_ELEMENT {\n\tlong long * Buffer;\n\tlong long Alignment;\n}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;\ntypedef struct tagALTTABINFO {\n\tDWORD\tcbSize;\n\tint\tcItems;\n\tint\tcColumns;\n\tint\tcRows;\n\tint\tiColFocus;\n\tint\tiRowFocus;\n\tint\tcxItem;\n\tint\tcyItem;\n\tPOINT\tptStart;\n} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;\ntypedef VOID (CALLBACK* WINEVENTPROC)(HWINEVENTHOOK,DWORD,HWND,LONG,LONG,DWORD,DWORD);\ntypedef VOID (APIENTRY *PTIMERAPCROUTINE)(LPVOID,DWORD,DWORD);\ntypedef enum _FINDEX_INFO_LEVELS { FindExInfoStandard, FindExInfoMaxInfoLevel } FINDEX_INFO_LEVELS;\ntypedef enum _FINDEX_SEARCH_OPS { FindExSearchNameMatch, FindExSearchLimitToDirectories, FindExSearchLimitToDevices, FindExSearchMaxSearchOp } FINDEX_SEARCH_OPS;\ntypedef struct { UINT cbSize; POINT pt; UINT uHit; SYSTEMTIME st; } MCHITTESTINFO, *PMCHITTESTINFO;\ntypedef struct tagNMSELCHANGE { NMHDR nmhdr;SYSTEMTIME stSelStart; SYSTEMTIME stSelEnd; } NMSELCHANGE, *LPNMSELCHANGE;\ntypedef struct tagNMDAYSTATE { NMHDR nmhdr; SYSTEMTIME stStart; int cDayState; LPMONTHDAYSTATE prgDayState; } NMDAYSTATE,*LPNMDAYSTATE;\n#ifdef UNICODE\ntypedef HW_PROFILE_INFOW HW_PROFILE_INFO;\ntypedef LPHW_PROFILE_INFOW LPHW_PROFILE_INFO;\ntypedef PRINTDLGW PRINTDLG;\ntypedef LPPRINTDLGW LPPRINTDLG;\n#else\ntypedef HW_PROFILE_INFOA HW_PROFILE_INFO;\ntypedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;\ntypedef PRINTDLGA PRINTDLG;\ntypedef LPPRINTDLGA LPPRINTDLG;\n#endif\ntypedef struct tagGUITHREADINFO {\n\tDWORD cbSize;\n\tDWORD flags;\n\tHWND hwndActive;\n\tHWND hwndFocus;\n\tHWND hwndCapture;\n\tHWND hwndMenuOwner;\n\tHWND hwndMoveSize;\n\tHWND hwndCaret;\n\tRECT rcCaret;\n} GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO;\n#define GUI_CARETBLINKING\t1\n#define GUI_INMOVESIZE\t2\n#define GUI_INMENUMODE\t4\n#define GUI_SYSTEMMENUMODE 8\n#define GUI_POPUPMENUMODE\t16\ntypedef struct tagLVCOLUMNA {\n\tUINT mask;\n\tint fmt;\n\tint cx;\n\tLPSTR pszText;\n\tint cchTextMax;\n\tint iSubItem;\n\tint iImage;\n\tint iOrder;\n} LVCOLUMNA, *LPLVCOLUMNA;\ntypedef struct tagLVCOLUMNW {\n\tUINT mask;\n\tint fmt;\n\tint cx;\n\tLPWSTR pszText;\n\tint cchTextMax;\n\tint iSubItem;\n\tint iImage;\n\tint iOrder;\n} LVCOLUMNW, *LPLVCOLUMNW;\ntypedef struct {UINT cbSize; HWND hwnd; DWORD dwFlags; UINT uCount; DWORD dwTimeout; } FLASHWINFO, *PFLASHWINFO;\ntypedef enum _GET_FILEEX_INFO_LEVELS { GetFileExInfoStandard, GetFileExMaxInfoLevel } GET_FILEEX_INFO_LEVELS;\ntypedef struct _BLENDFUNCTION {\n\tBYTE\tBlendOp;\n\tBYTE\tBlendFlags;\n\tBYTE\tSourceConstantAlpha;\n\tBYTE\tAlphaFormat;\n}BLENDFUNCTION,*PBLENDFUNCTION;\ntypedef struct _WIN32_FILE_ATTRIBUTE_DATA {\n\tDWORD dwFileAttributes;\n\tFILETIME ftCreationTime;\n\tFILETIME ftLastAccessTime;\n\tFILETIME ftLastWriteTime;\n\tDWORD nFileSizeHigh;\n\tDWORD nFileSizeLow;\n} WIN32_FILE_ATTRIBUTE_DATA,*LPWIN32_FILE_ATTRIBUTE_DATA;\ntypedef VOID (WINAPI *PFLS_CALLBACK_FUNCTION)(PVOID);\ntypedef USHORT COLOR16;\ntypedef struct _TRIVERTEX {LONG x; LONG y; COLOR16 Red; COLOR16 Green;\nCOLOR16 Blue; COLOR16 Alpha; }TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;\ntypedef struct _GRADIENT_TRIANGLE { ULONG Vertex1; ULONG Vertex2; ULONG Vertex3;\n} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;\ntypedef struct _GRADIENT_RECT { ULONG UpperLeft; ULONG LowerRight;\n}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;\ntypedef struct _OBJECT_TYPE_LIST { WORD Level; WORD Sbz; GUID *ObjectType; } OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;\ntypedef enum _AUDIT_EVENT_TYPE { AuditEventObjectAccess, AuditEventDirectoryServiceAccess } AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;\ntypedef ACE_HEADER *PACE_HEADER;\ntypedef struct tagMENUINFO {\n\tDWORD cbSize;\n\tDWORD fMask;\n\tDWORD dwStyle;\n\tUINT cyMax;\n\tHBRUSH hbrBack;\n\tDWORD dwContextHelpID;\n\tULONG_PTR dwMenuData;\n} MENUINFO, *LPMENUINFO;\ntypedef MENUINFO CONST *LPCMENUINFO;\ntypedef struct tagMENUGETOBJECTINFO {\n\tDWORD dwFlags;\n\tUINT uPos;\n\tHMENU hmenu;\n\tPVOID riid;\n\tPVOID pvObj;\n} MENUGETOBJECTINFO, *PMENUGETOBJECTINFO;\ntypedef struct _JOB_SET_ARRAY {\n\tHANDLE JobHandle;\n\tDWORD MemberLevel;\n\tDWORD Flags;\n} JOB_SET_ARRAY, *PJOB_SET_ARRAY;\ntypedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {\nRelationProcessorCore, RelationNumaNode\n} LOGICAL_PROCESSOR_RELATIONSHIP;\ntypedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {\n\tULONG_PTR  ProcessorMask;\n\tLOGICAL_PROCESSOR_RELATIONSHIP Relationship;\n\tunion {\n\t\tstruct {\n\t\t\tBYTE Flags;\n\t\t} ProcessorCore;\n\t\tstruct {\n\t\t\tDWORD NodeNumber;\n\t\t} NumaNode;\n\t\tULONGLONG Reserved[2];\n\t};\n} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;\ntypedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER)(struct _EXCEPTION_POINTERS *);\ntypedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {\n\tULONG cbSize;\n\tULONG ulDataFormatVersion;\n\tPVOID lpData;\n\tULONG ulLength;\n\tPVOID lpSectionGlobalData;\n\tULONG ulSectionGlobalDataLength;\n\tPVOID lpSectionBase;\n\tULONG ulSectionTotalLength;\n\tHANDLE hActCtx;\n\tULONG ulAssemblyRosterIndex;\n} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;\ntypedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;\n\ntypedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {\n\tPVOID lpInformation;\n\tPVOID lpSectionBase;\n\tULONG ulSectionLength;\n\tPVOID lpSectionGlobalDataBase;\n\tULONG ulSectionGlobalDataLength;\n} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;\ntypedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;\ntypedef struct tagACTCTX_SECTION_KEYED_DATA {\n\tULONG cbSize;\n\tULONG ulDataFormatVersion;\n\tPVOID lpData;\n\tULONG ulLength;\n\tPVOID lpSectionGlobalData;\n\tULONG ulSectionGlobalDataLength;\n\tPVOID lpSectionBase;\n\tULONG ulSectionTotalLength;\n\tHANDLE hActCtx;\n\tULONG ulAssemblyRosterIndex;\n// 2600 stops here\n\tULONG ulFlags;\n\tACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;\n} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;\ntypedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;\ntypedef struct _EVENTLOG_FULL_INFORMATION { DWORD   dwFull; }\nEVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;\n#define FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX 1\n#define FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS 2\n#define FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA 4\ntypedef enum _COMPUTER_NAME_FORMAT {\n   ComputerNameNetBIOS, ComputerNameDnsHostname, ComputerNameDnsDomain,\n   ComputerNameDnsFullyQualified, ComputerNamePhysicalNetBIOS, ComputerNamePhysicalDnsHostname,\n   ComputerNamePhysicalDnsDomain, ComputerNamePhysicalDnsFullyQualified, ComputerNameMax\n} COMPUTER_NAME_FORMAT ;\ntypedef enum _STREAM_INFO_LEVELS { FindStreamInfoStandard, FindStreamInfoMaxInfoLevel\n} STREAM_INFO_LEVELS;\ntypedef struct _WIN32_FIND_DATAA {\n\tDWORD dwFileAttributes;\n\tFILETIME ftCreationTime;\n\tFILETIME ftLastAccessTime;\n\tFILETIME ftLastWriteTime;\n\tDWORD nFileSizeHigh;\n\tDWORD nFileSizeLow;\n\tDWORD dwReserved0;\n\tDWORD dwReserved1;\n\tCHAR  cFileName[ MAX_PATH ];\n\tCHAR  cAlternateFileName[ 14 ];\n} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;\ntypedef struct _WIN32_FIND_DATAW {\n\tDWORD dwFileAttributes;\n\tFILETIME ftCreationTime;\n\tFILETIME ftLastAccessTime;\n\tFILETIME ftLastWriteTime;\n\tDWORD nFileSizeHigh;\n\tDWORD nFileSizeLow;\n\tDWORD dwReserved0;\n\tDWORD dwReserved1;\n\tWCHAR cFileName[ MAX_PATH ];\n\tWCHAR cAlternateFileName[ 14 ];\n} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;\n#define RTL_CRITSECT_TYPE 0\n#define RTL_RESOURCE_TYPE 1\ntypedef struct _RTL_CRITICAL_SECTION {\n\tPRTL_CRITICAL_SECTION_DEBUG DebugInfo;\n\tLONG LockCount;\n\tLONG RecursionCount;\n\tHANDLE OwningThread;\n\tHANDLE LockSemaphore;\n\tULONG_PTR SpinCount;\n} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;\ntypedef RTL_CRITICAL_SECTION CRITICAL_SECTION;\ntypedef RTL_CRITICAL_SECTION *LPCRITICAL_SECTION;\ntypedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;\ntypedef enum _HEAP_INFORMATION_CLASS { HeapCompatibilityInformation } HEAP_INFORMATION_CLASS;\ntypedef enum { WinNullSid=0,WinWorldSid=1, WinLocalSid=2, WinCreatorOwnerSid=3,\n WinCreatorGroupSid=4, WinCreatorOwnerServerSid=5, WinCreatorGroupServerSid=6,\n WinNtAuthoritySid=7, WinDialupSid=8, WinNetworkSid=9, WinBatchSid=10,\n WinInteractiveSid=11, WinServiceSid=12, WinAnonymousSid=13, WinProxySid=14,\n WinEnterpriseControllersSid=15, WinSelfSid=16, WinAuthenticatedUserSid=17,\n WinRestrictedCodeSid=18, WinTerminalServerSid=19, WinRemoteLogonIdSid=20,\n WinLogonIdsSid=21, WinLocalSystemSid=22, WinLocalServiceSid=23,\n WinNetworkServiceSid=24, WinBuiltinDomainSid=25, WinBuiltinAdministratorsSid=26,\n WinBuiltinUsersSid=27, WinBuiltinGuestsSid=28, WinBuiltinPowerUsersSid=29,\n WinBuiltinAccountOperatorsSid=30, WinBuiltinSystemOperatorsSid=31,\n WinBuiltinPrintOperatorsSid=32, WinBuiltinBackupOperatorsSid=33,\n WinBuiltinReplicatorSid=34, WinBuiltinPreWindows2000CompatibleAccessSid=35,\n WinBuiltinRemoteDesktopUsersSid=36, WinBuiltinNetworkConfigurationOperatorsSid=37,\n WinAccountAdministratorSid=38, WinAccountGuestSid=39, WinAccountKrbtgtSid=40,\n WinAccountDomainAdminsSid=41, WinAccountDomainUsersSid=42, WinAccountDomainGuestsSid=43,\n WinAccountComputersSid=44, WinAccountControllersSid=45, WinAccountCertAdminsSid=46,\n WinAccountSchemaAdminsSid=47, WinAccountEnterpriseAdminsSid=48,\n WinAccountPolicyAdminsSid=49, WinAccountRasAndIasServersSid=50,\n WinNTLMAuthenticationSid=51, WinDigestAuthenticationSid=52,\n WinSChannelAuthenticationSid=53, WinThisOrganizationSid=54, WinOtherOrganizationSid=55,\n WinBuiltinIncomingForestTrustBuildersSid=56, WinBuiltinPerfMonitoringUsersSid=57,\n WinBuiltinPerfLoggingUsersSid=58, WinBuiltinAuthorizationAccessSid=59,\n WinBuiltinTerminalServerLicenseServersSid=60\n} WELL_KNOWN_SID_TYPE;\ntypedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE { LowMemoryResourceNotification,\nHighMemoryResourceNotification } MEMORY_RESOURCE_NOTIFICATION_TYPE;\ntypedef struct _WIN32_FIND_STREAM_DATA {\n\tLARGE_INTEGER StreamSize;\n\tWCHAR cStreamName[ MAX_PATH + 36 ];\n} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;\ntypedef BOOL (WINAPI* PGET_MODULE_HANDLE_EXA)(DWORD,LPCSTR,HMODULE*);\ntypedef BOOL (WINAPI* PGET_MODULE_HANDLE_EXW)(DWORD,LPCWSTR,HMODULE*);\ntypedef DWORD (WINAPI *PFE_EXPORT_FUNC)(PBYTE,PVOID,ULONG);\ntypedef DWORD (WINAPI *PFE_IMPORT_FUNC)(PBYTE,PVOID,PULONG);\ntypedef struct tagNMTTCUSTOMDRAW {\n\tNMCUSTOMDRAW nmcd;\n\tUINT uDrawFlags;\n} NMTTCUSTOMDRAW, *LPNMTTCUSTOMDRAW;\ntypedef struct _IMAGELISTDRAWPARAMS {\n\tDWORD cbSize;\n\tHIMAGELIST himl;\n\tint i;\n\tHDC hdcDst;\n\tint x;\n\tint y;\n\tint cx;\n\tint cy;\n\tint xBitmap;\n\tint yBitmap;\n\tCOLORREF rgbBk;\n\tCOLORREF rgbFg;\n\tUINT fStyle;\n\tDWORD dwRop;\n#if (_WIN32_IE >= 0x501)\n\tDWORD fState;\n\tDWORD Frame;\n\tCOLORREF crEffect;\n#endif\n} IMAGELISTDRAWPARAMS, *LPIMAGELISTDRAWPARAMS;\n#ifndef __ISequentialStream_INTERFACE_DEFINED__\n#define __ISequentialStream_INTERFACE_DEFINED__\nstruct ISequentialStream { const struct ISequentialStreamVtbl *lpVtbl; };\n#endif\ntypedef struct _HD_TEXTFILTERA {\n\tLPSTR pszText;\n\tINT cchTextMax;\n} HD_TEXTFILTERA, *LPHD_TEXTFILTERA;\ntypedef struct _HD_TEXTFILTERW {\n\tLPWSTR pszText;\n\tINT cchTextMax;\n} HD_TEXTFILTERW, *LPHD_TEXTFILTERW;\ntypedef struct {\n\tUINT cbSize;\n\tDWORD dwMask;\n\tint cxPad;\n\tint cyPad;\n\tint cxBarPad;\n\tint cyBarPad;\n\tint cxButtonSpacing;\n\tint cyButtonSpacing;\n} TBMETRICS, * LPTBMETRICS;\ntypedef struct tagNMTBSAVE {\n\tNMHDR hdr;\n\tDWORD* pData;\n\tDWORD* pCurrent;\n\tUINT cbData;\n\tint iItem;\n\tint cButtons;\n\tTBBUTTON tbButton;\n} NMTBSAVE, *LPNMTBSAVE;\ntypedef struct tagNMTBRESTORE {\n\tNMHDR hdr;\n\tDWORD* pData;\n\tDWORD* pCurrent;\n\tUINT cbData;\n\tint iItem;\n\tint cButtons;\n\tint cbBytesPerRecord;\n\tTBBUTTON tbButton;\n} NMTBRESTORE, *LPNMTBRESTORE;\ntypedef struct tagNMREBARCHILDSIZE {\n\tNMHDR hdr;\n\tUINT uBand;\n\tUINT wID;\n\tRECT rcChild;\n\tRECT rcBand;\n} NMREBARCHILDSIZE, *LPNMREBARCHILDSIZE;\ntypedef struct tagNMREBAR {\n\tNMHDR  hdr;\n\tDWORD  dwMask;\n\tUINT   uBand;\n\tUINT   fStyle;\n\tUINT   wID;\n\tLPARAM lParam;\n} NMREBAR, *LPNMREBAR;\ntypedef struct tagLVGROUPMETRICS {\n\tUINT cbSize;\n\tUINT mask;\n\tUINT Left;\n\tUINT Top;\n\tUINT Right;\n\tUINT Bottom;\n\tCOLORREF crLeft;\n\tCOLORREF crTop;\n\tCOLORREF crRight;\n\tCOLORREF crBottom;\n\tCOLORREF crHeader;\n\tCOLORREF crFooter;\n} LVGROUPMETRICS, *PLVGROUPMETRICS;\ntypedef struct tagLVGROUP {\n\tUINT cbSize;\n\tUINT mask;\n\tLPWSTR pszHeader;\n\tint cchHeader;\n\tLPWSTR pszFooter;\n\tint cchFooter;\n\tint iGroupId;\n\tUINT stateMask;\n\tUINT state;\n\tUINT uAlign;\n} LVGROUP, *PLVGROUP;\ntypedef int (CALLBACK *PFNLVGROUPCOMPARE)(int, int, void *);\ntypedef struct tagLVINSERTGROUPSORTED {\n\tPFNLVGROUPCOMPARE pfnGroupCompare;\n\tvoid *pvData;\n\tLVGROUP lvGroup;\n}LVINSERTGROUPSORTED, *PLVINSERTGROUPSORTED;\ntypedef struct tagLVTILEVIEWINFO {\n\tUINT cbSize;\n\tDWORD dwMask;\n\tDWORD dwFlags;\n\tSIZE sizeTile;\n\tint cLines;\n\tRECT rcLabelMargin;\n} LVTILEVIEWINFO, *PLVTILEVIEWINFO;\ntypedef struct {\n\tUINT cbSize;\n\tDWORD dwFlags;\n\tint iItem;\n\tDWORD dwReserved;\n} LVINSERTMARK, * LPLVINSERTMARK;\ntypedef struct tagLVSETINFOTIP {\n\tUINT cbSize;\n\tDWORD dwFlags;\n\tLPWSTR pszText;\n\tint iItem;\n\tint iSubItem;\n} LVSETINFOTIP, *PLVSETINFOTIP;\ntypedef struct {\n\tHIMAGELIST himl;\n\tRECT margin;\n\tUINT uAlign;\n} BUTTON_IMAGELIST, *PBUTTON_IMAGELIST;\ntypedef struct tagNMBCHOTITEM {\n\tNMHDR hdr;\n\tDWORD dwFlags;\n} NMBCHOTITEM, *LPNMBCHOTITEM;\ntypedef struct _tagEDITBALLOONTIP {\n\tDWORD  cbStruct;\n\tLPCWSTR pszTitle;\n\tLPCWSTR pszText;\n\tINT   ttiIcon;\n} EDITBALLOONTIP, *PEDITBALLOONTIP;\ntypedef struct tagNMHDFILTERBTNCLICK {\n\tNMHDR hdr;\n\tINT iItem;\n\tRECT rc;\n} NMHDFILTERBTNCLICK, *LPNMHDFILTERBTNCLICK;\ntypedef struct tagNMRBAUTOSIZE {\n\tNMHDR hdr;\n\tBOOL fChanged;\n\tRECT rcTarget;\n\tRECT rcActual;\n} NMRBAUTOSIZE, *LPNMRBAUTOSIZE;\ntypedef struct tagNMREBARCHEVRON {\n\tNMHDR hdr;\n\tUINT uBand;\n\tUINT wID;\n\tLPARAM lParam;\n\tRECT rc;\n\tLPARAM lParamNM;\n} NMREBARCHEVRON, *LPNMREBARCHEVRON;\ntypedef struct tagNMREBARAUTOBREAK {\n\tNMHDR hdr;\n\tUINT uBand;\n\tUINT wID;\n\tLPARAM lParam;\n\tUINT uMsg;\n\tUINT fStyleCurrent;\n\tBOOL fAutoBreak;\n} NMREBARAUTOBREAK, *LPNMREBARAUTOBREAK;\ntypedef struct _RB_HITTESTINFO {\n\tPOINT pt;\n\tUINT flags;\n\tint iBand;\n} RBHITTESTINFO, *LPRBHITTESTINFO;\ntypedef struct _TTGETTITLE {\n\tDWORD dwSize;\n\tUINT uTitleBitmap;\n\tUINT cch;\n\tWCHAR* pszTitle;\n} TTGETTITLE, *PTTGETTITLE;\ntypedef struct _DRAWPATRECT {\n\tPOINT ptPosition;\n\tPOINT ptSize;\n\tWORD wStyle;\n\tWORD wPattern;\n} DRAWPATRECT, *PDRAWPATRECT;\ntypedef struct _PSINJECTDATA {\n\tDWORD\tDataBytes;\n\tWORD\tInjectionPoint;\n\tWORD   PageNumber;\n} PSINJECTDATA, *PPSINJECTDATA;\ntypedef struct _PSFEATURE_OUTPUT {\n\tBOOL bPageIndependent;\n\tBOOL bSetPageDevice;\n} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;\ntypedef struct _PSFEATURE_CUSTPAPER {\n\tLONG lOrientation;\n\tLONG lWidth;\n\tLONG lHeight;\n\tLONG lWidthOffset;\n\tLONG lHeightOffset;\n} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;\ntypedef struct tagWCRANGE {\n\tWCHAR wcLow;\n\tUSHORT cGlyphs;\n} WCRANGE, *PWCRANGE,*LPWCRANGE;\ntypedef struct tagGLYPHSET {\n\tDWORD   cbThis;\n\tDWORD   flAccel;\n\tDWORD   cGlyphsSupported;\n\tDWORD   cRanges;\n\tWCRANGE ranges[1];\n} GLYPHSET, *PGLYPHSET, *LPGLYPHSET;\ntypedef struct _WGLSWAP {\n\tHDC hdc;\n\tUINT uiFlags;\n} WGLSWAP, *PWGLSWAP, *LPWGLSWAP;\ntypedef struct tagLITEM {\n\tUINT\tmask ;\n\tint\tiLink ;\n\tUINT\tstate ;\n\tUINT\tstateMask ;\n\tWCHAR\tszID[MAX_LINKID_TEXT] ;\n\tWCHAR\tszUrl[L_MAX_URL_LENGTH] ;\n} LITEM, * PLITEM ;\ntypedef struct tagNMLINK {\n\tNMHDR hdr;\n\tLITEM item ;\n} NMLINK, *PNMLINK;\ntypedef struct tagUPDATELAYEREDWINDOWINFO {\n\tDWORD\tcbSize;\n\tHDC\thdcDst;\n\tPOINT\t*pptDst;\n\tSIZE\t*psize;\n\tHDC\thdcSrc;\n\tPOINT\t*pptSrc;\n\tCOLORREF\tcrKey;\n\tBLENDFUNCTION\t *pblend;\n\tDWORD\tdwFlags;\n\tRECT\t*prcDirty;\n} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;\ntypedef struct tagLASTINPUTINFO { UINT cbSize; DWORD dwTime; } LASTINPUTINFO,*PLASTINPUTINFO;\n/* Functions.h Declarations for all the WIN32 Functions */\nBOOL WINAPI GetLastInputInfo(PLASTINPUTINFO);\nDWORD WINAPI GetClipboardSequenceNumber(void);\nBOOL WINAPI UpdateLayeredWindow(HWND,HDC,POINT *,SIZE *,HDC,POINT *,COLORREF,BLENDFUNCTION *,DWORD);\nUINT WINAPI GetEnhMetaFilePixelFormat(HENHMETAFILE,UINT,PIXELFORMATDESCRIPTOR *);\nBOOL WINAPI ColorCorrectPalette(HDC,HPALETTE,DWORD,DWORD);\nDWORD WINAPI ReadEncryptedFileRaw(PFE_EXPORT_FUNC,PVOID,PVOID);\nDWORD WINAPI WriteEncryptedFileRaw(PFE_IMPORT_FUNC,PVOID,PVOID);\nVOID WINAPI CloseEncryptedFileRaw(PVOID);\nBOOLEAN WINAPI Wow64EnableWow64FsRedirection(BOOLEAN);\nBOOL WINAPI FileEncryptionStatusA(LPCSTR,LPDWORD);\nBOOL WINAPI FileEncryptionStatusW(LPCWSTR,LPDWORD);\nBOOL WINAPI AddAuditAccessAceEx(PACL,DWORD,DWORD,DWORD,PSID,BOOL,BOOL);\nBOOL WINAPI AddAccessDeniedObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID);\nBOOL WINAPI AddAuditAccessObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID,BOOL,BOOL);\nBOOL WINAPI ZombifyActCtx(HANDLE);\nHANDLE WINAPI CreateActCtxA(PCACTCTXA);\nHANDLE WINAPI CreateActCtxW(PCACTCTXW);\nVOID WINAPI AddRefActCtx(HANDLE);\nVOID WINAPI ReleaseActCtx(HANDLE);\nBOOL WINAPI ActivateActCtx(HANDLE,ULONG_PTR *);\nBOOL WINAPI DeactivateActCtx(DWORD,ULONG_PTR);\nBOOL WINAPI GetCurrentActCtx(HANDLE *);\nBOOL WINAPI SetThreadStackGuarantee(PULONG);\nBOOL WINAPI SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,SECURITY_DESCRIPTOR_CONTROL,SECURITY_DESCRIPTOR_CONTROL);\nBOOL WINAPI SetPrivateObjectSecurityEx(SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,ULONG,PGENERIC_MAPPING,HANDLE);\nBOOL WINAPI MakeAbsoluteSD2(PSECURITY_DESCRIPTOR,LPDWORD);\nBOOL WINAPI TzSpecificLocalTimeToSystemTime(LPTIME_ZONE_INFORMATION,LPSYSTEMTIME,LPSYSTEMTIME);\nBOOL WINAPI IsTokenRestricted(HANDLE);\nDWORD WINAPI GetThreadId(HANDLE);\nBOOL WINAPI GetThreadIOPendingFlag(HANDLE,PBOOL);\nLPVOID WINAPI CreateFiberEx(SIZE_T,SIZE_T,DWORD,LPFIBER_START_ROUTINE,LPVOID);\nLPVOID WINAPI ConvertThreadToFiberEx(LPVOID,DWORD);\nBOOL WINAPI ConvertFiberToThread(VOID);\nBOOL WINAPI IsWellKnownSid (PSID, WELL_KNOWN_SID_TYPE);\nHANDLE WINAPI CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE);\nBOOL WINAPI QueryMemoryResourceNotification(HANDLE,PBOOL);\nDWORD WINAPI OpenEncryptedFileRawA(LPCSTR,ULONG,PVOID *);\nDWORD WINAPI OpenEncryptedFileRawW(LPCWSTR,ULONG,PVOID *);\nBOOL WINAPI IsTokenUntrusted(HANDLE);\nBOOL APIENTRY CheckTokenMembership(HANDLE,PSID,PBOOL);\nBOOL WINAPI NeedCurrentDirectoryForExePathA(LPCSTR);\nBOOL WINAPI NeedCurrentDirectoryForExePathW(LPCWSTR);\nHANDLE WINAPI OpenWaitableTimerA(DWORD,BOOL,LPCSTR);\nHANDLE WINAPI OpenWaitableTimerW(DWORD,BOOL,LPCWSTR);\nBOOL WINAPI SetFirmwareEnvironmentVariableA(LPCSTR,LPCSTR,PVOID,DWORD);\nBOOL WINAPI SetFirmwareEnvironmentVariableW(LPCWSTR,LPCWSTR,PVOID,DWORD);\nDWORD WINAPI GetFirmwareEnvironmentVariableA(LPCSTR,LPCSTR,PVOID,DWORD);\nDWORD WINAPI GetFirmwareEnvironmentVariableW(LPCWSTR,LPCWSTR,PVOID,DWORD);\nBOOL WINAPI GetWindowsAccountDomainSid(PSID,PSID,DWORD *);\nBOOL WINAPI EqualDomainSid(PSID,PSID,BOOL *);\nBOOL WINAPI CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,\n\tPSECURITY_DESCRIPTOR *,GUID *,BOOL,ULONG,HANDLE,PGENERIC_MAPPING);\nBOOL WINAPI CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR,\n\tPSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,GUID **,ULONG,BOOL,ULONG,\n\tHANDLE,PGENERIC_MAPPING);\nBOOL WINAPI CreateWellKnownSid(WELL_KNOWN_SID_TYPE,PSID,PSID,DWORD *);\nBOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR,LPVOID,HANDLE,LPCSTR,\n\tLPCSTR,PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,\n\tDWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);\nBOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR,LPVOID,HANDLE,LPCWSTR,\n\tLPCWSTR,PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,\n\tDWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);\nBOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR,LPVOID,LPCSTR,LPCSTR,\n\tPSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,\n\tDWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);\nBOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR,LPVOID,LPCWSTR,LPCWSTR,\n\tPSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,\n\tDWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);\nBOOL WINAPI CheckNameLegalDOS8Dot3A(LPCSTR,LPSTR,DWORD,PBOOL,PBOOL);\nBOOL WINAPI CheckNameLegalDOS8Dot3W(LPCWSTR,LPSTR,DWORD,PBOOL,PBOOL);\nDWORD WINAPI GetDllDirectoryA(DWORD,LPSTR);\nDWORD WINAPI GetDllDirectoryW(DWORD,LPWSTR);\nBOOL WINAPI SetDllDirectoryA(LPCSTR);\nBOOL WINAPI SetDllDirectoryW(LPCWSTR);\nBOOL WINAPI DnsHostnameToComputerNameA(LPCSTR,LPSTR,LPDWORD);\nBOOL WINAPI DnsHostnameToComputerNameW(LPCWSTR,LPWSTR,LPDWORD);\nUINT WINAPI GetWriteWatch(DWORD,PVOID,SIZE_T,PVOID *,PULONG_PTR,PULONG);\nUINT WINAPI ResetWriteWatch(LPVOID,SIZE_T);\nSIZE_T WINAPI GetLargePageMinimum(void);\nBOOL WINAPI HeapSetInformation(HANDLE,HEAP_INFORMATION_CLASS,PVOID,SIZE_T);\nBOOL WINAPI HeapQueryInformation(HANDLE,HEAP_INFORMATION_CLASS,PVOID,SIZE_T,PSIZE_T);\nDWORD WINAPI GetFreeSpace(UINT);\nBOOL WINAPI AccessCheckByType(PSECURITY_DESCRIPTOR,PSID,HANDLE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPBOOL);\nBOOL WINAPI AccessCheckByTypeResultList (PSECURITY_DESCRIPTOR,PSID,HANDLE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPDWORD);\nBOOL WINAPI AccessCheckByTypeAndAuditAlarmA(LPCSTR,LPVOID,LPCSTR,LPCSTR,PSECURITY_DESCRIPTOR,\n\tPSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,\n\tBOOL,LPDWORD,LPBOOL,LPBOOL);\nBOOL WINAPI AccessCheckByTypeAndAuditAlarmW(LPCWSTR,LPVOID,LPCWSTR,LPCWSTR,PSECURITY_DESCRIPTOR,\n\tPSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,\n\tBOOL,LPDWORD,LPBOOL,LPBOOL);\nBOOL WINAPI AccessCheckAndAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);\nBOOL WINAPI AccessCheckAndAuditAlarmW(LPCWSTR,LPVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);\nHANDLE WINAPI FindFirstStreamW(LPCWSTR,STREAM_INFO_LEVELS,LPVOID,DWORD);\nBOOL APIENTRY FindNextStreamW(HANDLE,LPVOID);\nPVOID WINAPI AddVectoredContinueHandler (ULONG,PVECTORED_EXCEPTION_HANDLER);\nULONG WINAPI RemoveVectoredContinueHandler (PVOID);\nBOOL WINAPI UnregisterWaitEx(HANDLE,HANDLE);\nBOOL WINAPI DeleteTimerQueueTimer(HANDLE,HANDLE,HANDLE);\nBOOL WINAPI VerifyVersionInfoA(LPOSVERSIONINFOEXA,DWORD,DWORDLONG);\nBOOL WINAPI VerifyVersionInfoW(LPOSVERSIONINFOEXW,DWORD,DWORDLONG);\nBOOL WINAPI GetEventLogInformation (HANDLE,DWORD,LPVOID,DWORD,LPDWORD);\nBOOL WINAPI GetLongPathNameW(LPCWSTR,LPWSTR,DWORD);\nUINT GetRawInputDeviceInfoA(HANDLE,UINT,LPVOID,PUINT);\nUINT GetRawInputDeviceInfoW(HANDLE,UINT,LPVOID,PUINT);\nUINT WINAPI GetRegisteredRawInputDevices(PRAWINPUTDEVICE,PUINT,UINT);\nUINT WINAPI GetRawInputDeviceList(PRAWINPUTDEVICELIST,PUINT,UINT);\nLRESULT WINAPI DefRawInputProc(PRAWINPUT*,INT,UINT);\nBOOL WINAPI ReplaceFileA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPVOID,LPVOID);\nBOOL WINAPI ReplaceFileW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPVOID,LPVOID);\nHANDLE WINAPI ReOpenFile(HANDLE,DWORD,DWORD,DWORD);\n#ifdef UNICODE\n#define FileEncryptionStatus FileEncryptionStatusW\n#define CreateActCtx CreateActCtxW\n#define OpenEncryptedFileRaw OpenEncryptedFileRawW\n#define NeedCurrentDirectoryForExePath NeedCurrentDirectoryForExePathW\n#define OpenWaitableTimer OpenWaitableTimerW\n#define SetFirmwareEnvironmentVariable SetFirmwareEnvironmentVariableW\n#define GetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariableW\n#define AccessCheckByTypeResultListAndAuditAlarmByHandle AccessCheckByTypeResultListAndAuditAlarmByHandleW\n#define AccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmW\n#define AccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmW\n#define CheckNameLegalDOS8Dot3 CheckNameLegalDOS8Dot3W\n#define GetDllDirectory GetDllDirectoryW\n#define SetDllDirectory SetDllDirectoryW\n#define DnsHostnameToComputerName DnsHostnameToComputerNameW\ntypedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;\ntypedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;\n#define ReplaceFile ReplaceFileW\n#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmW\n#define VerifyVersionInfo VerifyVersionInfoW\n#define GetRawInputDeviceInfo GetRawInputDeviceInfoW\n#define FindActCtxSectionString FindActCtxSectionStringW\n#else\n#define FileEncryptionStatus FileEncryptionStatusA\n#define CreateActCtx CreateActCtxA\n#define OpenEncryptedFileRaw OpenEncryptedFileRawA\n#define NeedCurrentDirectoryForExePath NeedCurrentDirectoryForExePathA\n#define OpenWaitableTimer OpenWaitableTimerA\n#define SetFirmwareEnvironmentVariable SetFirmwareEnvironmentVariableA\n#define GetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariableA\n#define AccessCheckByTypeResultListAndAuditAlarmByHandle AccessCheckByTypeResultListAndAuditAlarmByHandleA\n#define AccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmA\n#define AccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmA\n#define CheckNameLegalDOS8Dot3 CheckNameLegalDOS8Dot3A\n#define GetDllDirectory GetDllDirectoryA\n#define SetDllDirectory SetDllDirectoryA\n#define DnsHostnameToComputerName DnsHostnameToComputerNameA\ntypedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;\ntypedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;\n#define ReplaceFile ReplaceFileA\n#define GetRawInputDeviceInfo GetRawInputDeviceInfoA\n#define FindActCtxSectionString FindActCtxSectionStringA\n#define VerifyVersionInfo VerifyVersionInfoA\n#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmA\n#endif\nBOOL WINAPI FindActCtxSectionStringA(DWORD,const GUID *,ULONG,LPCSTR,PACTCTX_SECTION_KEYED_DATA);\nBOOL WINAPI FindActCtxSectionStringW(DWORD,const GUID *,ULONG,LPCWSTR,PACTCTX_SECTION_KEYED_DATA);\nBOOL WINAPI FindActCtxSectionGuid(DWORD,const GUID *,ULONG,const GUID *,PACTCTX_SECTION_KEYED_DATA);\nUINT WINAPI GetRawInputBuffer(PRAWINPUT,PUINT,UINT);\nUINT GetRawInputData(HRAWINPUT,UINT,LPVOID,PUINT,UINT);\nvoid RtlZeroMemory(void *,unsigned int);\nBOOL GetBinaryTypeW(LPCWSTR,LPDWORD);\nDWORD GetShortPathNameW(LPCWSTR,LPWSTR,DWORD);\nLPWSTR GetEnvironmentStringsW(VOID);\nBOOL FreeEnvironmentStringsW(LPWSTR);\nDWORD FormatMessageW(DWORD,LPCVOID,DWORD,DWORD,LPWSTR,DWORD,va_list *);\nHANDLE CreateMailslotW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);\nint lstrcmpW(LPCWSTR,LPCWSTR);\nint lstrcmpiW( LPCWSTR,LPCWSTR);\nLPWSTR lstrcpynW(LPWSTR,LPCWSTR,int);\nLPWSTR lstrcpyW(LPWSTR,LPCWSTR);\nLPWSTR lstrcatW(LPWSTR,LPCWSTR);\nint lstrlenW(LPCWSTR);\nHANDLE CreateMutexW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);\nHANDLE OpenMutexW(DWORD,BOOL,LPCWSTR);\nHANDLE CreateEventW(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCWSTR);\nHANDLE OpenEventW(DWORD,BOOL,LPCWSTR);\nHANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCWSTR);\nHANDLE OpenSemaphoreW(DWORD,BOOL,LPCWSTR);\nHANDLE CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);\nHANDLE OpenFileMappingW(DWORD,BOOL,LPCWSTR);\nDWORD GetLogicalDriveStringsW(DWORD,LPWSTR);\nHINSTANCE LoadLibraryW(LPCWSTR);\nHINSTANCE LoadLibraryExW(LPCWSTR,HANDLE,DWORD);\nDWORD GetModuleFileNameW(HINSTANCE,LPWSTR,DWORD);\nHMODULE GetModuleHandleW(LPCWSTR);\nBOOL WINAPI GetModuleHandleExA(DWORD,LPCSTR,HMODULE*);\nBOOL WINAPI GetModuleHandleExW(DWORD,LPCWSTR,HMODULE*);\nVOID FatalAppExitW(UINT,LPCWSTR);\nLPWSTR GetCommandLineW(VOID);\nDWORD GetEnvironmentVariableW(LPCWSTR,LPWSTR,DWORD);\nBOOL SetEnvironmentVariableW(LPCWSTR,LPCWSTR);\nDWORD ExpandEnvironmentStringsW(LPCWSTR,LPWSTR,DWORD);\nVOID OutputDebugStringW(LPCWSTR);\nHRSRC FindResourceW(HINSTANCE,LPCWSTR,LPCWSTR);\nHRSRC FindResourceExW(HINSTANCE,LPCWSTR,LPCWSTR,WORD);\nBOOL EnumResourceTypesW(HINSTANCE,ENUMRESTYPEPROC,LONG);\nBOOL EnumResourceNamesW(HINSTANCE,LPCWSTR,ENUMRESNAMEPROC,LONG);\nBOOL EnumResourceLanguagesW(HINSTANCE,LPCWSTR,LPCWSTR,ENUMRESLANGPROC,LONG);\nHANDLE BeginUpdateResourceW(LPCWSTR,BOOL);\nBOOL UpdateResourceW(HANDLE,LPCWSTR,LPCWSTR,WORD,LPVOID,DWORD);\nBOOL EndUpdateResourceW(HANDLE,BOOL);\nATOM GlobalAddAtomW( LPCWSTR);\nATOM GlobalFindAtomW( LPCWSTR);\nUINT GlobalGetAtomNameW(ATOM,LPWSTR,int);\nATOM AddAtomW(LPCWSTR);\nATOM FindAtomW(LPCWSTR);\nUINT GetAtomNameW(ATOM,LPWSTR,int);\nUINT GetProfileIntW(LPCWSTR,LPCWSTR,INT);\nDWORD GetProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD);\nBOOL WriteProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR);\nDWORD GetProfileSectionW(LPCWSTR,LPWSTR,DWORD);\nBOOL WriteProfileSectionW(LPCWSTR,LPCWSTR);\nUINT GetPrivateProfileIntW(LPCWSTR,LPCWSTR,INT,LPCWSTR);\nBOOL WINAPI GetPrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);\nBOOL WINAPI GetPrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);\nDWORD GetPrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD,LPCWSTR);\nBOOL WritePrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);\nBOOL WINAPI WritePrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);\nBOOL WINAPI WritePrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);\nDWORD GetPrivateProfileSectionW(LPCWSTR,LPWSTR,DWORD,LPCWSTR);\nDWORD WINAPI GetPrivateProfileSectionNamesA(LPSTR,DWORD,LPCSTR);\nDWORD WINAPI GetPrivateProfileSectionNamesW(LPWSTR,DWORD,LPCWSTR);\nBOOL WritePrivateProfileSectionW(LPCWSTR,LPCWSTR,LPCWSTR);\nUINT GetDriveTypeW(LPCWSTR);\nUINT GetSystemDirectoryW(LPWSTR,UINT);\nDWORD GetTempPathW(DWORD,LPWSTR);\nUINT GetTempFileNameW(LPCWSTR,LPCWSTR,UINT,LPWSTR);\nUINT WINAPI GetWindowModuleFileNameA(HWND,LPSTR,UINT);\nUINT WINAPI GetWindowModuleFileNameW(HWND,LPWSTR,UINT);\nUINT WINAPI GetWindowsDirectoryW(LPWSTR,UINT);\nUINT WINAPI GetSystemWindowsDirectoryA(LPSTR,UINT);\nUINT WINAPI GetSystemWindowsDirectoryW(LPWSTR,UINT);\nBOOL WINAPI GetWindowInfo(HWND,PWINDOWINFO);\nDWORD WINAPI GetListBoxInfo(HWND);\nBOOL WINAPI GetScrollBarInfo(HWND,LONG,PSCROLLBARINFO);\nBOOL WINAPI GetCursorInfo(PCURSORINFO);\nBOOL WINAPI GetTitleBarInfo(HWND,PTITLEBARINFO);\nBOOL SetCurrentDirectoryW(LPCWSTR);\nDWORD GetCurrentDirectoryW(DWORD,LPWSTR);\nBOOL WINAPI GetCurrentHwProfileA(LPHW_PROFILE_INFOA);\nBOOL WINAPI GetCurrentHwProfileW(LPHW_PROFILE_INFOW);\nBOOL GetDiskFreeSpaceW(LPCWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);\nBOOL WINAPI GetDiskFreeSpaceExW(LPCWSTR,long long *,long long *,long long *);\nBOOL CreateDirectoryW(LPCWSTR,LPSECURITY_ATTRIBUTES);\nBOOL CreateDirectoryExW(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);\nBOOL RemoveDirectoryW(LPCWSTR);\nDWORD GetFullPathNameW(LPCWSTR,DWORD,LPWSTR,LPWSTR *);\nBOOL DefineDosDeviceW(DWORD,LPCWSTR,LPCWSTR);\nDWORD QueryDosDeviceW(LPCWSTR,LPWSTR,DWORD);\nHANDLE CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);\nBOOL SetFileAttributesW(LPCWSTR,DWORD);\nDWORD GetFileAttributesW(LPCWSTR);\nBOOL WINAPI GetFileAttributesExA(LPCSTR,GET_FILEEX_INFO_LEVELS,LPVOID);\nBOOL WINAPI GetFileAttributesExW(LPCWSTR,GET_FILEEX_INFO_LEVELS,LPVOID);\nDWORD GetCompressedFileSizeW(LPCWSTR,LPDWORD);\nBOOL DeleteFileW(LPCWSTR);\nDWORD SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR *);\nBOOL CopyFileW(LPCWSTR,LPCWSTR,BOOL);\nBOOL WINAPI CopyFileExW(LPCWSTR,LPCWSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);\nBOOL WINAPI CreateHardLinkW(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);\nBOOL MoveFileW(LPCWSTR,LPCWSTR);\nBOOL MoveFileExW(LPCWSTR,LPCWSTR,DWORD);\nBOOL WINAPI MoveFileWithProgressW(LPCWSTR,LPCWSTR,LPPROGRESS_ROUTINE,LPVOID,DWORD);\nHANDLE CreateNamedPipeW(LPCWSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);\nBOOL GetNamedPipeHandleStateW(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPWSTR,DWORD);\nBOOL CallNamedPipeW(LPCWSTR,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,DWORD);\nBOOL WaitNamedPipeW(LPCWSTR,DWORD);\nBOOL SetVolumeLabelW(LPCWSTR,LPCWSTR);\nBOOL GetVolumeInformationW(LPCWSTR,LPWSTR,DWORD,LPDWORD,LPDWORD,LPDWORD,LPWSTR,DWORD);\nBOOL WINAPI CancelIo(HANDLE);\nBOOL ClearEventLogW(HANDLE,LPCWSTR);\nBOOL BackupEventLogW(HANDLE,LPCWSTR);\nHANDLE OpenEventLogW(LPCWSTR,LPCWSTR);\nHANDLE RegisterEventSourceW(LPCWSTR,LPCWSTR);\nHANDLE OpenBackupEventLogW(LPCWSTR,LPCWSTR);\nBOOL ReadEventLogW(HANDLE,DWORD,DWORD,LPVOID,DWORD,DWORD *,DWORD *);\nBOOL ReportEventW(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCWSTR *,LPVOID);\nBOOL AccessCheckAndAuditAlarmW(LPCWSTR,LPVOID HandleId,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);\nBOOL ObjectOpenAuditAlarmW(LPCWSTR,LPVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,LPBOOL);\nBOOL ObjectPrivilegeAuditAlarmW(LPCWSTR,LPVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);\nBOOL ObjectCloseAuditAlarmW(LPCWSTR,LPVOID,BOOL);\nBOOL WINAPI ObjectDeleteAuditAlarmA(LPCSTR,LPVOID,BOOL);\nBOOL WINAPI ObjectDeleteAuditAlarmW(LPCWSTR,LPVOID,BOOL);\nDWORD WINAPI GetGuiResources(HANDLE,DWORD);\nCOLORREF WINAPI SetDCBrushColor(HDC,COLORREF);\nCOLORREF WINAPI SetDCPenColor(HDC,COLORREF);\nDWORD WINAPI SetLayout(HDC,DWORD);\nDWORD WINAPI GetLayout(HDC);\nBOOL LockWorkStation(void);\nBOOL WINAPI UserHandleGrantAccess(HANDLE,HANDLE,BOOL);\nHANDLE WINAPI AddFontMemResourceEx(PVOID,DWORD,PVOID,DWORD*);\nBOOL WINAPI RemoveFontMemResourceEx(HANDLE);\n#ifdef UNICODE\n#define GetModuleHandleEx GetModuleHandleExW\n#define GetCurrentHwProfile GetCurrentHwProfileW\n#define ObjectDeleteAuditAlarm\tObjectDeleteAuditAlarmW\n#define GetComputerNameEx GetComputerNameExW\n#define SetComputerNameEx SetComputerNameExW\n#define AddFontResourceEx AddFontResourceExW\n#define RemoveFontResourceEx RemoveFontResourceExW\n#else\n#define RemoveFontResourceEx RemoveFontResourceExA\n#define AddFontResourceEx AddFontResourceExA\n#define GetModuleHandleEx GetModuleHandleExA\n#define GetCurrentHwProfile GetCurrentHwProfileA\n#define ObjectDeleteAuditAlarm\tObjectDeleteAuditAlarmA\n#define GetComputerNameEx GetComputerNameExA\n#define SetComputerNameEx SetComputerNameExA\n#endif\nBOOL PrivilegedServiceAuditAlarmW(LPCWSTR,LPCWSTR,HANDLE,PPRIVILEGE_SET,BOOL);\nBOOL SetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);\nBOOL GetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);\nHANDLE FindFirstChangeNotificationW(LPCWSTR,BOOL,DWORD);\nBOOL IsBadStringPtrW(LPCWSTR,UINT);\nBOOL LookupAccountSidW(LPCWSTR,PSID,LPWSTR,LPDWORD,LPWSTR,LPDWORD,PSID_NAME_USE);\nBOOL LookupAccountNameW(LPCWSTR,LPCWSTR,PSID,LPDWORD,LPWSTR,LPDWORD,PSID_NAME_USE);\nBOOL LookupPrivilegeValueW(LPCWSTR,LPCWSTR,PLUID);\nBOOL LookupPrivilegeNameW(LPCWSTR,PLUID,LPWSTR,LPDWORD);\nBOOL LookupPrivilegeDisplayNameW(LPCWSTR,LPCWSTR,LPWSTR,LPDWORD,LPDWORD);\nBOOL BuildCommDCBW(LPCWSTR,LPDCB);\nBOOL BuildCommDCBAndTimeoutsW(LPCWSTR,LPDCB,LPCOMMTIMEOUTS);\nBOOL CommConfigDialogW(LPCWSTR,HWND,LPCOMMCONFIG);\nBOOL GetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,LPDWORD);\nBOOL SetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,DWORD);\nBOOL GetComputerNameW(LPWSTR,LPDWORD);\nBOOL SetComputerNameW(LPCWSTR);\nBOOL WINAPI GetComputerNameExA(COMPUTER_NAME_FORMAT,LPSTR,LPDWORD);\nBOOL WINAPI GetComputerNameExW(COMPUTER_NAME_FORMAT,LPWSTR,LPDWORD);\nBOOL WINAPI SetComputerNameExA(COMPUTER_NAME_FORMAT,LPCSTR);\nBOOL WINAPI SetComputerNameExW(COMPUTER_NAME_FORMAT,LPCWSTR);\nBOOL GetUserNameW(LPWSTR,LPDWORD);\nint wvsprintfW(LPWSTR,LPCWSTR,va_list arglist);\nint CDECL wsprintfW(LPWSTR,LPCWSTR,...);\nHKL LoadKeyboardLayoutW(LPCWSTR,UINT);\nBOOL GetKeyboardLayoutNameW(LPWSTR);\nHDESK CreateDesktopW(LPWSTR,LPWSTR,LPDEVMODE,DWORD,DWORD,LPSECURITY_ATTRIBUTES);\nHDESK OpenDesktopW(LPWSTR,DWORD,BOOL,DWORD);\nBOOL EnumDesktopsW(HWINSTA,DESKTOPENUMPROC,LPARAM);\nHWINSTA CreateWindowStationW(LPWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);\nHWINSTA OpenWindowStationW(LPWSTR,BOOL,DWORD);\nBOOL EnumWindowStationsW(ENUMWINDOWSTATIONPROC,LPARAM);\nBOOL GetUserObjectInformationW(HANDLE,int,PVOID,DWORD,LPDWORD);\nBOOL SetUserObjectInformationW(HANDLE,int,PVOID,DWORD);\nUINT RegisterWindowMessageW(LPCWSTR);\nBOOL GetMessageW(LPMSG,HWND,UINT,UINT);\nLONG DispatchMessageW(CONST MSG *);\nBOOL PeekMessageW(LPMSG,HWND,UINT,UINT,UINT);\nLRESULT SendMessageW(HWND,UINT,WPARAM,LPARAM);\nLRESULT SendMessageTimeoutW(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);\nBOOL SendNotifyMessageW(HWND,UINT,WPARAM,LPARAM);\nBOOL SendMessageCallbackW(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);\nBOOL PostMessageW(HWND,UINT,WPARAM,LPARAM);\nBOOL PostThreadMessageW(DWORD,UINT,WPARAM,LPARAM);\nLRESULT DefWindowProcW(HWND,UINT,WPARAM,LPARAM);\nLRESULT CallWindowProcW(WNDPROC,HWND,UINT,WPARAM,LPARAM);\nATOM RegisterClassW(CONST WNDCLASSW *);\nBOOL UnregisterClassW(LPCWSTR,HINSTANCE);\nBOOL GetClassInfoW(HINSTANCE,LPCWSTR,LPWNDCLASS);\nATOM RegisterClassExW(CONST WNDCLASSEX *);\nBOOL GetClassInfoExW(HINSTANCE,LPCWSTR,LPWNDCLASSEX);\nHWND CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);\nHWND CreateDialogParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);\nHWND CreateDialogIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);\nint DialogBoxParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);\nint DialogBoxIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);\nBOOL SetDlgItemTextW(HWND,int,LPCWSTR);\nUINT GetDlgItemTextW(HWND,int,LPWSTR,int);\nLONG SendDlgItemMessageW(HWND,int,UINT,WPARAM,LPARAM);\nLRESULT DefDlgProcW(HWND,UINT,WPARAM,LPARAM);\nBOOL CallMsgFilterW(LPMSG,int);\nUINT RegisterClipboardFormatW(LPCWSTR);\nint GetClipboardFormatNameW(UINT,LPWSTR,int);\nBOOL CharToOemW(LPCWSTR,LPSTR);\nBOOL OemToCharW(LPCSTR,LPWSTR);\nBOOL CharToOemBuffW(LPCWSTR,LPSTR,DWORD);\nBOOL OemToCharBuffW(LPCSTR,LPWSTR,DWORD);\nLPWSTR CharUpperW(LPWSTR);\nDWORD CharUpperBuffW(LPWSTR,DWORD);\nLPWSTR CharLowerW(LPWSTR);\nDWORD CharLowerBuffW(LPWSTR,DWORD);\nLPWSTR CharNextW(LPCWSTR);\nLPWSTR CharPrevW(LPCWSTR,LPCWSTR);\nBOOL IsCharAlphaW(WCHAR);\nBOOL IsCharAlphaNumericW(WCHAR);\nBOOL IsCharUpperW(WCHAR);\nBOOL IsCharLowerW(WCHAR);\nint GetKeyNameTextW(LONG,LPWSTR,int);\nUINT WINAPI SendInput(UINT,LPINPUT,int);\nSHORT VkKeyScanW(WCHAR);\nSHORT VkKeyScanExW(WCHAR,HKL);\nUINT MapVirtualKeyW(UINT,UINT);\nUINT MapVirtualKeyExW(UINT,UINT,HKL);\nHACCEL LoadAcceleratorsW(HINSTANCE,LPCWSTR);\nHACCEL CreateAcceleratorTableW(LPACCEL,int);\nint CopyAcceleratorTableW(HACCEL,LPACCEL,int);\nint TranslateAcceleratorW(HWND,HACCEL,LPMSG);\nHMENU LoadMenuW(HINSTANCE,LPCWSTR);\nHMENU LoadMenuIndirectW(CONST MENUTEMPLATE *);\nBOOL ChangeMenuW(HMENU,UINT,LPCWSTR,UINT,UINT);\nint GetMenuStringW(HMENU,UINT,LPWSTR,int,UINT);\nBOOL InsertMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);\nBOOL AppendMenuW(HMENU,UINT,UINT,LPCWSTR);\nBOOL ModifyMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);\nBOOL InsertMenuItemW(HMENU,UINT,BOOL,LPCMENUITEMINFO);\nBOOL GetMenuItemInfoW(HMENU,UINT,BOOL,LPMENUITEMINFO);\nBOOL SetMenuItemInfoW( HMENU,UINT,BOOL,LPCMENUITEMINFO);\nint DrawTextW(HDC,LPCWSTR,int,LPRECT,UINT);\nint DrawTextExW(HDC,LPWSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);\nBOOL GrayStringW(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);\nBOOL DrawStateW(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);\nLONG TabbedTextOutW(HDC,int,int,LPCWSTR,int,int,LPINT,int);\nDWORD GetTabbedTextExtentW(HDC,LPCWSTR,int,int,LPINT);\nBOOL SetPropW(HWND,LPCWSTR,HANDLE);\nHANDLE GetPropW(HWND,LPCWSTR);\nHANDLE RemovePropW(HWND,LPCWSTR);\nint EnumPropsExW(HWND,PROPENUMPROCEX,LPARAM);\nint EnumPropsW(HWND,PROPENUMPROC);\nBOOL SetWindowTextW(HWND,LPCWSTR);\nint GetWindowTextW(HWND,LPWSTR,int);\nint GetWindowTextLengthW(HWND);\nint MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT);\nint MessageBoxExW(HWND,LPCWSTR,LPCWSTR,UINT,WORD);\nint MessageBoxIndirectW(LPMSGBOXPARAMS);\nLONG GetWindowLongW(HWND,int);\n#define GetWindowLongPtrW\tGetWindowLongW\n#define GetWindowLongPtrA\tGetWindowLongA\nLONG SetWindowLongW(HWND,int,LONG);\n#define SetWindowLongPtrW\tSetWindowLongW\n#define SetWindowLongPtrA\tSetWindowLongA\n#define GetClassLongPtrA\tGetWindowLongA\n#define GetClassLongPtrW\tGetWindowLongW\n#define SetClassLongPtrA\tSetWindowLongA\n#define SetClassLongPtrW\tSetWindowLongA\nDWORD GetClassLongW(HWND,int);\nDWORD SetClassLongW(HWND,int,LONG);\nHWND FindWindowW(LPCWSTR,LPCWSTR);\nHWND FindWindowExW(HWND,HWND,LPCWSTR,LPCWSTR);\nint GetClassNameW(HWND,LPWSTR,int);\nHHOOK SetWindowsHookExW(int,HOOKPROC,HINSTANCE,DWORD);\n#define DefHookProc(c,p,lp,hh) CallNextHookEx((HHOOK)*hh,c,p,lp)\nHBITMAP LoadBitmapW(HINSTANCE,LPCWSTR);\nHCURSOR LoadCursorW(HINSTANCE,LPCWSTR);\nHCURSOR LoadCursorFromFileW(LPCWSTR);\nHICON LoadIconW(HINSTANCE,LPCWSTR);\nHANDLE LoadImageW(HINSTANCE,LPCWSTR,UINT,int,int,UINT);\nint LoadStringW(HINSTANCE,UINT,LPWSTR,int);\nBOOL IsDialogMessageW(HWND,LPMSG);\nint DlgDirListW(HWND,LPWSTR,int,int,UINT);\nBOOL DlgDirSelectExW(HWND,LPWSTR,int,int);\nint DlgDirListComboBoxW(HWND,LPWSTR,int,int,UINT);\nBOOL DlgDirSelectComboBoxExW(HWND,LPWSTR,int,int);\nLRESULT DefFrameProcW(HWND,HWND,UINT,WPARAM,LPARAM);\nLRESULT DefMDIChildProcW(HWND,UINT,WPARAM,LPARAM);\nHWND CreateMDIWindowW(LPWSTR,LPWSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);\nBOOL WinHelpW(HWND,LPCWSTR,UINT,DWORD);\nLONG ChangeDisplaySettingsW(LPDEVMODE,DWORD);\nLONG WINAPI ChangeDisplaySettingsExW(\n   LPCWSTR lpszDeviceName,\n   LPDEVMODEW lpDevMode,\n   HWND hwnd,\n   DWORD dwflags,\n   LPVOID lParam);\n\n\n\nBOOL EnumDisplaySettingsW(LPCWSTR,DWORD,LPDEVMODE);\nBOOL SystemParametersInfoW(UINT,UINT,PVOID,UINT);\nint AddFontResourceW(LPCWSTR);\nint WINAPI AddFontResourceExA(LPCSTR,DWORD,PVOID);\nint WINAPI AddFontResourceExW(LPCWSTR,DWORD,PVOID);\nHMETAFILE CopyMetaFileW(HMETAFILE,LPCWSTR);\nHFONT CreateFontIndirectW(CONST LOGFONT *);\nHFONT CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);\nHDC CreateICW(LPCWSTR,LPCWSTR,LPCWSTR,CONST DEVMODE *);\nHDC CreateMetaFileW(LPCWSTR);\nBOOL CreateScalableFontResourceW(DWORD,LPCWSTR,LPCWSTR,LPCWSTR);\nint DeviceCapabilitiesW(LPCWSTR,LPCWSTR,WORD,LPWSTR,CONST DEVMODE *);\nint EnumFontFamiliesExW(HDC,LPLOGFONT,FONTENUMEXPROC,LPARAM,DWORD);\nint EnumFontFamiliesW(HDC,LPCWSTR,FONTENUMPROC,LPARAM);\nint EnumFontsW(HDC,LPCWSTR,ENUMFONTSPROC,LPARAM);\nBOOL GetCharWidthW(HDC,UINT,UINT,LPINT);\nBOOL GetCharWidth32W(HDC,UINT,UINT,LPINT);\nBOOL GetCharWidthFloatW(HDC,UINT,UINT,PFLOAT);\nBOOL GetCharABCWidthsW(HDC,UINT,UINT,LPABC);\nBOOL GetCharABCWidthsFloatW(HDC,UINT,UINT,LPABCFLOAT);\nDWORD GetGlyphOutlineW(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,LPVOID,CONST MAT2 *);\nHMETAFILE GetMetaFileW(LPCWSTR);\nUINT GetOutlineTextMetricsW(HDC,UINT,LPOUTLINETEXTMETRIC);\nBOOL GetTextExtentPointW(HDC,LPCWSTR,int,LPSIZE);\nBOOL GetTextExtentPoint32W( HDC,LPCWSTR,int,LPSIZE);\nBOOL GetTextExtentExPointW( HDC,LPCWSTR,int,int,LPINT,LPINT,LPSIZE );\nBOOL WINAPI GetTextExtentPointI(HDC,LPWORD,int,LPSIZE);\nBOOL WINAPI GetTextExtentExPointI(HDC,LPWORD,int,int,LPINT,LPINT,LPSIZE);\nBOOL WINAPI GetCharWidthI(HDC,UINT,UINT,LPWORD,LPINT);\nBOOL WINAPI GetCharABCWidthsI(HDC,UINT,UINT,LPWORD,LPABC);\nDWORD GetCharacterPlacementW(HDC,LPCWSTR,int,int,LPGCP_RESULTS,DWORD);\nHDC ResetDCW(HDC,CONST DEVMODE *);\nBOOL RemoveFontResourceW(LPCWSTR);\nBOOL WINAPI RemoveFontResourceExA(LPCSTR,DWORD,PVOID);\nBOOL WINAPI RemoveFontResourceExW(LPCWSTR,DWORD,PVOID);\nHENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE,LPCWSTR);\nHDC CreateEnhMetaFileW(HDC,LPCWSTR,CONST RECT *,LPCWSTR);\nHENHMETAFILE GetEnhMetaFileW(LPCWSTR);\nUINT GetEnhMetaFileDescriptionW(HENHMETAFILE,UINT,LPWSTR );\nBOOL GetTextMetricsW(HDC,LPTEXTMETRICW);\nint StartDocW(HDC,CONST DOCINFO *);\nint GetObjectW(HGDIOBJ,int,LPVOID);\nBOOL TextOutW(HDC,int,int,LPCWSTR,int);\nBOOL ExtTextOutW(HDC,int,int,UINT,CONST RECT *,LPCWSTR,UINT,CONST INT *);\nBOOL PolyTextOutW(HDC,CONST POLYTEXT *,int);\nint GetTextFaceW(HDC,int,LPWSTR);\nDWORD GetKerningPairsW(HDC,DWORD,LPKERNINGPAIR);\nBOOL GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACE,DWORD);\nHCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACE);\nBOOL GetICMProfileW(HDC,DWORD,LPWSTR);\nBOOL SetICMProfileW(HDC,LPWSTR);\nBOOL UpdateICMRegKeyW(DWORD,DWORD,LPWSTR,UINT);\nint EnumICMProfilesW(HDC,ICMENUMPROC,LPARAM);\nHPROPSHEETPAGE CreatePropertySheetPageW(LPCPROPSHEETPAGE);\nint PropertySheetW(LPCPROPSHEETHEADER);\nHIMAGELIST ImageList_LoadImageW(HINSTANCE,LPCWSTR,int,int,COLORREF,UINT,UINT);\nHIMAGELIST WINAPI ImageList_Duplicate(HIMAGELIST);\nBOOL WINAPI ImageList_Copy(HIMAGELIST,int,HIMAGELIST,int,UINT);\nBOOL WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS*);\n#define\tImageList_LoadBitmap(h,l,x,G,M) ImageList_LoadImage(h,l,x,G,M,IMAGE_BITMAP,0)\n#define ImageList_RemoveAll(himl) ImageList_Remove(himl,-1)\n#define ImageList_ExtractIcon(hi, himl,i) ImageList_GetIcon(himl,i,0)\nHWND CreateStatusWindowW(LONG,LPCWSTR,HWND,UINT);\nvoid DrawStatusTextW(HDC,LPRECT,LPCWSTR,UINT);\nBOOL GetOpenFileNameW(LPOPENFILENAME);\nBOOL GetSaveFileNameW(LPOPENFILENAME);\nshort GetFileTitleW(LPCWSTR,LPWSTR,WORD);\nBOOL ChooseColorW(LPCHOOSECOLOR);\nHWND ReplaceTextW(LPFINDREPLACE);\nBOOL ChooseFontW(LPCHOOSEFONT);\nHWND FindTextW(LPFINDREPLACE);\nBOOL PrintDlgW(LPPRINTDLG);\nBOOL PageSetupDlgW(LPPAGESETUPDLG);\nBOOL CreateProcessW(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFO,LPPROCESS_INFORMATION);\nBOOL WINAPI CreateProcessAsUserA(HANDLE,LPCSTR,LPSTR, LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES, BOOL,DWORD,LPVOID,LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);\nBOOL WINAPI CreateProcessAsUserW(HANDLE,LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);\nBOOL WINAPI CreateProcessWithLogonW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPCWSTR,LPWSTR,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);\nBOOL APIENTRY ImpersonateAnonymousToken(HANDLE);\nVOID GetStartupInfoW(LPSTARTUPINFO);\nHANDLE FindFirstFileW(LPCWSTR,LPWIN32_FIND_DATAW);\nHANDLE WINAPI FindFirstFileExW(LPCWSTR,FINDEX_INFO_LEVELS,LPVOID,FINDEX_SEARCH_OPS,LPVOID,DWORD);\nBOOL FindNextFileW(HANDLE,LPWIN32_FIND_DATA);\nBOOL GetVersionExW(LPOSVERSIONINFO);\n#define CreateWindowW(Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param) CreateWindowExW(0,Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param)\n#define CreateDialogW(hI,lpN,hP,Func) CreateDialogParamW(hI,lpN,hP,Func,0)\n#define CreateDialogIndirectW(I,T,hP,Func) CreateDialogIndirectParamW(I,T,hP,Func,0)\n#define DialogBoxW(Inst,Template,Parent,Func) DialogBoxParamW(Inst,Template,Parent,Func,0)\n#define DialogBoxIndirectW(Inst,Template,Parent,Func) DialogBoxIndirectParamW(Inst,Template,Parent,Func,0)\nHDC CreateDCW(LPCWSTR,LPCWSTR,LPCWSTR,CONST DEVMODE *);\nHFONT CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);\nDWORD VerInstallFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT);\nDWORD GetFileVersionInfoSizeW(LPWSTR,LPDWORD);\nBOOL GetFileVersionInfoW(LPWSTR,DWORD,DWORD,LPVOID);\nDWORD VerLanguageNameW(DWORD,LPWSTR,DWORD);\nDWORD VerFindFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT,LPWSTR,PUINT);\nLONG RegSetValueExW(HKEY,LPCWSTR,DWORD,DWORD,BYTE*,DWORD);\nLONG RegUnLoadKeyW(HKEY,LPCWSTR);\nBOOL InitiateSystemShutdownW(LPWSTR,LPWSTR,DWORD,BOOL,BOOL);\nBOOL AbortSystemShutdownW(LPWSTR);\nLONG RegRestoreKeyW(HKEY,LPCWSTR,DWORD);\nLONG RegSaveKeyW(HKEY,LPCWSTR,LPSECURITY_ATTRIBUTES);\nLONG RegSetValueW(HKEY,LPCWSTR,DWORD,LPCWSTR,DWORD);\nLONG RegQueryValueW(HKEY,LPCWSTR,LPWSTR,PLONG);\nLONG RegQueryMultipleValuesW(HKEY,PVALENTW,DWORD,LPWSTR,LPDWORD);\nLONG RegQueryValueExW(HKEY,LPCWSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);\nLONG RegReplaceKeyW(HKEY,LPCWSTR,LPCWSTR,LPCWSTR);\nLONG RegConnectRegistryW(LPWSTR,HKEY,PHKEY);\nLONG RegCreateKeyW(HKEY,LPCWSTR,PHKEY);\nLONG RegCreateKeyExW(HKEY,LPCWSTR,DWORD,LPWSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,LPDWORD);\nLONG RegDeleteKeyW(HKEY,LPCWSTR);\nLONG RegDeleteValueW(HKEY,LPCWSTR);\nLONG RegEnumKeyW(HKEY,DWORD,LPWSTR,DWORD);\nLONG RegEnumKeyExW(HKEY,DWORD,LPWSTR,LPDWORD,LPDWORD,LPWSTR,LPDWORD,PFILETIME);\nLONG RegEnumValueW(HKEY,DWORD,LPWSTR,LPDWORD,LPDWORD,LPDWORD,LPBYTE,LPDWORD);\nLONG RegLoadKeyW(HKEY,LPCWSTR,LPCWSTR);\nLONG RegOpenKeyW(HKEY,LPCWSTR,PHKEY);\nLONG RegOpenKeyExW(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);\nLONG RegQueryInfoKeyW(HKEY,LPWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,PFILETIME);\nint CompareStringW(LCID,DWORD,LPCWSTR,int,LPCWSTR,int);\nint LCMapStringW(LCID,DWORD,LPCWSTR,int,LPWSTR,int);\nint GetLocaleInfoW(LCID,LCTYPE,LPWSTR,int);\nBOOL SetLocaleInfoW(LCID,LCTYPE,LPCWSTR);\nint GetTimeFormatW(LCID,DWORD,CONST SYSTEMTIME *,LPCWSTR,LPWSTR,int);\nint GetDateFormatW(LCID,DWORD,CONST SYSTEMTIME *,LPCWSTR,LPWSTR,int);\nint GetNumberFormatW(LCID,DWORD,LPCWSTR,CONST NUMBERFMTW *,LPWSTR,int);\nint GetCurrencyFormatW(LCID,DWORD,LPCWSTR,CONST CURRENCYFMTW *,LPWSTR,int);\nBOOL EnumCalendarInfoW(CALINFO_ENUMPROC,LCID,CALID,CALTYPE);\nBOOL EnumTimeFormatsW(TIMEFMT_ENUMPROC,LCID,DWORD);\nBOOL EnumDateFormatsW(DATEFMT_ENUMPROC,LCID,DWORD);\nBOOL GetStringTypeExW(LCID,DWORD,LPCWSTR,int,LPWORD);\nBOOL GetStringTypeW(DWORD,LPCWSTR,int,LPWORD);\nint FoldStringW(DWORD,LPCWSTR,int,LPWSTR,int);\nBOOL EnumSystemLocalesW(LOCALE_ENUMPROC,DWORD);\nBOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROC,DWORD);\nBOOL PeekConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);\nBOOL ReadConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);\nBOOL WriteConsoleInputW(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);\nBOOL ReadConsoleOutputW(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);\nBOOL WriteConsoleOutputW(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);\nBOOL ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,LPDWORD);\nBOOL WriteConsoleOutputCharacterW(HANDLE,LPCWSTR,DWORD,COORD,LPDWORD);\nBOOL FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,LPDWORD);\nBOOL ScrollConsoleScreenBufferW(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);\nDWORD GetConsoleTitleW(LPWSTR,DWORD);\nBOOL SetConsoleTitleW(LPCWSTR);\nHANDLE GetConsoleWindow(void);\nBOOL ReadConsoleW(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);\nBOOL WriteConsoleW(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);\nDWORD WNetAddConnectionW(LPCWSTR,LPCWSTR,LPCWSTR);\nDWORD WNetAddConnection2W(LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD);\nDWORD WNetAddConnection3W(HWND,LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD);\nDWORD WNetCancelConnectionW(LPCWSTR,BOOL);\nDWORD WNetCancelConnection2W(LPCWSTR,DWORD,BOOL);\nDWORD WNetGetConnectionW(LPCWSTR,LPWSTR,LPDWORD);\nDWORD WNetUseConnectionW(HWND,LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPDWORD,LPDWORD);\nDWORD WNetSetConnectionW(LPCWSTR,DWORD,LPVOID);\nDWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCT);\nDWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCT);\nDWORD WNetOpenEnumW(DWORD,DWORD,DWORD,LPNETRESOURCE,LPHANDLE);\nDWORD WNetEnumResourceW(HANDLE,LPDWORD,LPVOID,LPDWORD);\nDWORD WNetGetUniversalNameW(LPCWSTR,DWORD,LPVOID,LPDWORD);\nDWORD WNetGetUserW(LPCWSTR,LPWSTR,LPDWORD);\nDWORD WNetGetProviderNameW(DWORD,LPWSTR,LPDWORD);\nDWORD WNetGetNetworkInformationW(LPCWSTR,LPNETINFOSTRUCT);\nDWORD WNetGetLastErrorW(LPDWORD,LPWSTR,DWORD,LPWSTR,DWORD);\nDWORD MultinetGetConnectionPerformanceW(LPNETRESOURCE,LPNETCONNECTINFOSTRUCT);\n/* ASCIIFunctions.h Declarations for all the WIN32 ASCII Functions */\nDWORD WINAPI GetLongPathNameA(LPCSTR,LPSTR,DWORD);\nBOOL GetBinaryTypeA(LPCSTR,LPDWORD);\nDWORD GetShortPathNameA(LPCSTR,LPSTR,DWORD);\nBOOL FreeEnvironmentStringsA(LPSTR);\nDWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);\nHANDLE CreateMailslotA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);\nint lstrcmpA(LPCSTR,LPCSTR);\nint lstrcmpiA(LPCSTR,LPCSTR);\nLPSTR lstrcpynA(LPSTR,LPCSTR,int);\nLPSTR lstrcpyA(LPSTR,LPCSTR);\nLPSTR lstrcatA(LPSTR,LPCSTR);\nint lstrlenA(LPCSTR);\nHANDLE CreateMutexA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);\nHANDLE OpenMutexA(DWORD,BOOL,LPCSTR);\nHANDLE CreateEventA(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCSTR);\nHANDLE OpenEventA(DWORD,BOOL,LPCSTR);\nHANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCSTR);\nHANDLE OpenSemaphoreA(DWORD,BOOL,LPCSTR);\nHANDLE CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);\nHANDLE OpenFileMappingA(DWORD,BOOL,LPCSTR);\nDWORD GetLogicalDriveStringsA(DWORD,LPSTR);\nHINSTANCE LoadLibraryA(LPCSTR);\nHINSTANCE LoadLibraryExA(LPCSTR,HANDLE,DWORD);\nDWORD GetModuleFileNameA(HINSTANCE,LPSTR,DWORD);\nHMODULE GetModuleHandleA(LPCSTR);\nVOID FatalAppExitA(UINT,LPCSTR);\nLPSTR GetCommandLineA(VOID);\nDWORD GetEnvironmentVariableA(LPCSTR,LPSTR,DWORD);\nBOOL SetEnvironmentVariableA(LPCSTR,LPCSTR);\nDWORD ExpandEnvironmentStringsA(LPCSTR,LPSTR,DWORD);\nVOID OutputDebugStringA(LPCSTR);\nHRSRC FindResourceA(HMODULE,LPCSTR,LPCSTR);\nHRSRC FindResourceExA(HINSTANCE,LPCSTR,LPCSTR,WORD);\nBOOL EnumResourceTypesA(HINSTANCE,ENUMRESTYPEPROC,LONG);\nBOOL EnumResourceNamesA(HINSTANCE,LPCSTR,ENUMRESNAMEPROC,LONG);\nBOOL EnumResourceLanguagesA(HINSTANCE,LPCSTR,LPCSTR,ENUMRESLANGPROC,LONG);\nHANDLE BeginUpdateResourceA(LPCSTR,BOOL);\nBOOL UpdateResourceA(HANDLE,LPCSTR,LPCSTR,WORD,LPVOID,DWORD);\nBOOL EndUpdateResourceA(HANDLE,BOOL);\nATOM GlobalAddAtomA(LPCSTR);\nATOM GlobalFindAtomA(LPCSTR);\nUINT GlobalGetAtomNameA(ATOM,LPSTR,int);\nATOM AddAtomA(LPCSTR);\nATOM FindAtomA(LPCSTR);\nUINT GetAtomNameA(ATOM,LPSTR,int);\nUINT GetProfileIntA(LPCSTR,LPCSTR,INT);\nDWORD GetProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD);\nBOOL WriteProfileStringA(LPCSTR,LPCSTR,LPCSTR);\nDWORD GetProfileSectionA(LPCSTR,LPSTR,DWORD);\nBOOL WriteProfileSectionA(LPCSTR,LPCSTR);\nUINT GetPrivateProfileIntA(LPCSTR,LPCSTR,INT,LPCSTR);\nDWORD GetPrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD,LPCSTR);\nBOOL WritePrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPCSTR);\nDWORD GetPrivateProfileSectionA(LPCSTR,LPSTR,DWORD,LPCSTR);\nBOOL WritePrivateProfileSectionA(LPCSTR,LPCSTR,LPCSTR);\nUINT GetDriveTypeA(LPCSTR);\nUINT GetSystemDirectoryA(LPSTR,UINT);\nBOOL WINAPI GetSystemRegistryQuota(PDWORD,PDWORD);\nBOOL WINAPI GetSystemTimes(LPFILETIME,LPFILETIME,LPFILETIME);\nVOID WINAPI GetNativeSystemInfo(LPSYSTEM_INFO);\nDWORD GetTempPathA(DWORD,LPSTR);\nUINT GetTempFileNameA(LPCSTR,LPCSTR,UINT,LPSTR);\nUINT GetWindowsDirectoryA(LPSTR,UINT);\nBOOL SetCurrentDirectoryA(LPCSTR);\nDWORD GetCurrentDirectoryA(DWORD,LPSTR);\nBOOL GetDiskFreeSpaceA(LPCSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);\nBOOL WINAPI GetDiskFreeSpaceExA(LPCSTR,long long *,long long *,long long *);\nBOOL CreateDirectoryA(LPCSTR,LPSECURITY_ATTRIBUTES);\nBOOL CreateDirectoryExA(LPCSTR,LPCSTR,LPSECURITY_ATTRIBUTES);\nBOOL RemoveDirectoryA(LPCSTR);\nDWORD GetFullPathNameA(LPCSTR,DWORD,LPSTR,LPSTR *);\nBOOL DefineDosDeviceA(DWORD,LPCSTR,LPCSTR);\nDWORD QueryDosDeviceA(LPCSTR,LPSTR,DWORD);\nHANDLE CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);\nBOOL SetFileAttributesA(LPCSTR,DWORD);\nDWORD GetFileAttributesA(LPCSTR);\nDWORD GetCompressedFileSizeA(LPCSTR,LPDWORD);\nBOOL DeleteFileA(LPCSTR);\nDWORD SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR *);\nHANDLE WINAPI FindFirstVolumeA(LPSTR,DWORD);\nHANDLE WINAPI FindFirstVolumeW(LPWSTR,DWORD);\nBOOL WINAPI FindNextVolumeA(HANDLE,LPSTR,DWORD);\nBOOL WINAPI FindNextVolumeW(HANDLE,LPWSTR,DWORD);\nBOOL CopyFileA(LPCSTR,LPCSTR,BOOL);\nHANDLE WINAPI FindFirstVolumeMountPointA(LPCSTR,LPSTR,DWORD);\nHANDLE WINAPI FindFirstVolumeMountPointW(LPCWSTR,LPWSTR,DWORD);\nBOOL WINAPI FindNextVolumeMountPointA(HANDLE,LPSTR,DWORD);\nBOOL WINAPI FindNextVolumeMountPointW(HANDLE,LPWSTR,DWORD);\nBOOL WINAPI FindVolumeMountPointClose(HANDLE);\nBOOL WINAPI FindVolumeClose(HANDLE);\nBOOL WINAPI SetVolumeMountPointA(LPCSTR,LPCSTR);\nBOOL WINAPI SetVolumeMountPointW(LPCWSTR,LPCWSTR);\nBOOL WINAPI DeleteVolumeMountPointA(LPCSTR);\nBOOL WINAPI DeleteVolumeMountPointW(LPCWSTR);\nBOOL WINAPI GetVolumeNameForVolumeMountPointA(LPCSTR,LPSTR,DWORD);\nBOOL WINAPI GetVolumeNameForVolumeMountPointW(LPCWSTR,LPWSTR,DWORD);\nBOOL WINAPI GetVolumePathNameA(LPCSTR,LPSTR,DWORD);\nBOOL WINAPI GetVolumePathNameW(LPCWSTR,LPWSTR,DWORD);\nBOOL WINAPI GetVolumePathNamesForVolumeNameA(LPCSTR,LPSTR,DWORD,PDWORD);\nBOOL WINAPI GetVolumePathNamesForVolumeNameW(LPCWSTR,LPWSTR,DWORD,PDWORD);\nBOOL WINAPI AllocateUserPhysicalPages(HANDLE,PULONG_PTR,PULONG_PTR);\nBOOL WINAPI FreeUserPhysicalPages(HANDLE,PULONG_PTR,PULONG_PTR);\nBOOL WINAPI MapUserPhysicalPages(PVOID,ULONG_PTR,PULONG_PTR);\nBOOL WINAPI MapUserPhysicalPagesScatter(PVOID *,ULONG_PTR,PULONG_PTR);\nHANDLE WINAPI CreateJobObjectA(LPSECURITY_ATTRIBUTES,LPCSTR);\nHANDLE WINAPI CreateJobObjectW(LPSECURITY_ATTRIBUTES,LPCWSTR);\n#ifdef UNICODE\n#define CreateJobObject CreateJobObjectW\n#define OpenJobObject OpenJobObjectW\n#define EncryptFile EncryptFileW\n#else\n#define CreateJobObject CreateJobObjectA\n#define OpenJobObject OpenJobObjectA\n#define EncryptFile EncryptFileA\n#endif\ntypedef BOOL(WINAPI *PQUERYACTCTXW_FUNC)(DWORD,HANDLE,PVOID,ULONG,PVOID,SIZE_T,SIZE_T *);\nBOOL WINAPI QueryActCtxW(DWORD,HANDLE,PVOID,ULONG,PVOID,SIZE_T,SIZE_T *);\nDWORD WINAPI WTSGetActiveConsoleSessionId(void);\nBOOL WINAPI IsWow64Process(HANDLE,PBOOL);\nBOOL WINAPI GetNumaProcessorNode(UCHAR,PUCHAR);\nBOOL WINAPI GetNumaNodeProcessorMask(UCHAR,PULONGLONG);\nBOOL WINAPI GetNumaAvailableMemoryNode(UCHAR,PULONGLONG);\nBOOL WINAPI GetNumaHighestNodeNumber(PULONG);\nBOOL WINAPI GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION,PDWORD);\nBOOL WINAPI EncryptFileA(LPCSTR);\nBOOL WINAPI EncryptFileW(LPCWSTR);\nBOOL WINAPI DecryptFileA(LPCSTR,DWORD);\nBOOL WINAPI DecryptFileW(LPCWSTR,DWORD);\nBOOL WINAPI AssignProcessToJobObject(HANDLE,HANDLE);\nBOOL WINAPI TerminateJobObject(HANDLE,UINT);\nBOOL WINAPI QueryInformationJobObject(HANDLE,JOBOBJECTINFOCLASS,LPVOID,DWORD,LPDWORD);\nBOOL WINAPI SetInformationJobObject(HANDLE,JOBOBJECTINFOCLASS,LPVOID,DWORD);\nBOOL WINAPI IsProcessInJob (HANDLE,HANDLE,PBOOL);\nBOOL WINAPI CreateJobSet (ULONG,PJOB_SET_ARRAY,ULONG);\nPVOID WINAPI AddVectoredExceptionHandler(ULONG,PVECTORED_EXCEPTION_HANDLER);\nULONG WINAPI RemoveVectoredExceptionHandler(PVOID);\nHANDLE WINAPI OpenJobObjectA(DWORD,BOOL,LPCSTR);\nHANDLE WINAPI OpenJobObjectW(DWORD,BOOL,LPCWSTR);\nBOOL WINAPI CopyFileExA(LPCSTR,LPCSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);\nBOOL WINAPI CreateHardLinkA(LPCSTR,LPCSTR,LPSECURITY_ATTRIBUTES);\nBOOL MoveFileA(LPCSTR,LPCSTR);\nBOOL MoveFileExA(LPCSTR,LPCSTR,DWORD);\nBOOL WINAPI MoveFileWithProgressA(LPCSTR,LPCSTR,LPPROGRESS_ROUTINE,LPVOID,DWORD);\nHANDLE CreateNamedPipeA(LPCSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);\nBOOL GetNamedPipeHandleStateA(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPSTR,DWORD);\nBOOL CallNamedPipeA(LPCSTR,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,DWORD);\nBOOL WaitNamedPipeA(LPCSTR,DWORD);\nBOOL SetVolumeLabelA(LPCSTR,LPCSTR);\nBOOL GetVolumeInformationA(LPCSTR,LPSTR,DWORD,LPDWORD,LPDWORD,LPDWORD,LPSTR,DWORD);\nBOOL ClearEventLogA(HANDLE,LPCSTR);\nBOOL BackupEventLogA(HANDLE,LPCSTR);\nHANDLE OpenEventLogA (LPCSTR,LPCSTR);\nHANDLE RegisterEventSourceA (LPCSTR,LPCSTR);\nHANDLE OpenBackupEventLogA(LPCSTR,LPCSTR);\nBOOL ReadEventLogA(HANDLE,DWORD,DWORD,LPVOID,DWORD,DWORD *,DWORD *);\nBOOL ReportEventA(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCSTR *,LPVOID);\nBOOL AccessCheckAndAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,\n\tDWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);\nBOOL ObjectOpenAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,LPBOOL);\nBOOL ObjectPrivilegeAuditAlarmA(LPCSTR,LPVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);\nBOOL ObjectCloseAuditAlarmA(LPCSTR,LPVOID,BOOL);\nBOOL PrivilegedServiceAuditAlarmA(LPCSTR,LPCSTR,HANDLE,PPRIVILEGE_SET,BOOL);\nBOOL SetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);\nBOOL GetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);\nHANDLE FindFirstChangeNotificationA(LPCSTR,BOOL,DWORD);\nBOOL IsBadStringPtrA(LPCSTR,UINT);\nBOOL LookupAccountSidA(LPCSTR,PSID,LPSTR,LPDWORD,LPSTR,LPDWORD,PSID_NAME_USE);\nBOOL LookupAccountNameA(LPCSTR,LPCSTR,PSID,LPDWORD,LPSTR,LPDWORD,PSID_NAME_USE);\nBOOL LookupPrivilegeValueA(LPCSTR,LPCSTR,PLUID);\nBOOL LookupPrivilegeNameA(LPCSTR,PLUID,LPSTR,LPDWORD);\nBOOL LookupPrivilegeDisplayNameA(LPCSTR,LPCSTR,LPSTR,LPDWORD,LPDWORD);\nBOOL BuildCommDCBA(LPCSTR lpDef,LPDCB lpDCB);\nBOOL BuildCommDCBAndTimeoutsA(LPCSTR,LPDCB,LPCOMMTIMEOUTS);\nBOOL CommConfigDialogA(LPCSTR,HWND,LPCOMMCONFIG);\nBOOL GetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,LPDWORD);\nBOOL SetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,DWORD);\nBOOL GetComputerNameA (LPSTR,LPDWORD);\nBOOL SetComputerNameA (LPCSTR);\nBOOL GetUserNameA (LPSTR,LPDWORD);\nint wvsprintfA(LPSTR,LPCSTR,va_list arglist);\nint CDECL wsprintfA(LPSTR,LPCSTR,...);\nHKL LoadKeyboardLayoutA(LPCSTR,UINT);\nBOOL GetKeyboardLayoutNameA(LPSTR);\nHDESK CreateDesktopA(LPSTR,LPSTR,LPDEVMODE,DWORD,DWORD,LPSECURITY_ATTRIBUTES);\nHDESK OpenDesktopA(LPSTR,DWORD,BOOL,DWORD);\nBOOL EnumDesktopsA(HWINSTA,DESKTOPENUMPROC,LPARAM);\nHWINSTA CreateWindowStationA(LPSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);\nHWINSTA OpenWindowStationA(LPSTR,BOOL,DWORD);\nBOOL EnumWindowStationsA(ENUMWINDOWSTATIONPROC,LPARAM);\nBOOL GetUserObjectInformationA(HANDLE,int,PVOID,DWORD,LPDWORD);\nBOOL SetUserObjectInformationA(HANDLE,int,PVOID,DWORD);\nUINT RegisterWindowMessageA(LPCSTR);\nBOOL GetMessageA(LPMSG,HWND,UINT,UINT);\nLONG DispatchMessageA(CONST MSG *);\nBOOL PeekMessageA(LPMSG,HWND,UINT,UINT,UINT);\nLRESULT SendMessageA(HWND,UINT,WPARAM,LPARAM);\nLRESULT SendMessageTimeoutA(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);\nBOOL SendNotifyMessageA(HWND,UINT,WPARAM,LPARAM);\nBOOL SendMessageCallbackA(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);\nBOOL PostMessageA(HWND,UINT,WPARAM,LPARAM);\nBOOL PostThreadMessageA(DWORD,UINT,WPARAM,LPARAM);\nLRESULT DefWindowProcA(HWND,UINT,WPARAM,LPARAM);\nLRESULT CallWindowProcA(WNDPROC,HWND,UINT,WPARAM,LPARAM);\nATOM RegisterClassA(CONST WNDCLASS *);\nBOOL UnregisterClassA(LPCSTR,HINSTANCE);\nBOOL GetClassInfoA(HINSTANCE,LPCSTR,LPWNDCLASS);\nATOM RegisterClassExA(CONST WNDCLASSEX *);\nBOOL GetClassInfoExA(HINSTANCE,LPCSTR,LPWNDCLASSEX);\nHWND CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);\nHWND CreateDialogParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);\nHWND CreateDialogIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);\nint DialogBoxParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);\nint DialogBoxIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);\nBOOL SetDlgItemTextA(HWND,int,LPCSTR);\nUINT GetDlgItemTextA(HWND,int,LPSTR,int);\nLONG SendDlgItemMessageA(HWND,int,UINT,WPARAM,LPARAM);\nLRESULT DefDlgProcA(HWND,UINT,WPARAM,LPARAM);\nBOOL CallMsgFilterA(LPMSG,int);\nUINT RegisterClipboardFormatA(LPCSTR);\nint GetClipboardFormatNameA(UINT,LPSTR,int);\nBOOL CharToOemA(LPCSTR,LPSTR);\nBOOL OemToCharA(LPCSTR,LPSTR);\nBOOL CharToOemBuffA(LPCSTR,LPSTR,DWORD);\nBOOL OemToCharBuffA(LPCSTR,LPSTR,DWORD);\nLPSTR CharUpperA(LPSTR);\nDWORD CharUpperBuffA(LPSTR,DWORD);\nLPSTR CharLowerA(LPSTR);\nDWORD CharLowerBuffA(LPSTR,DWORD);\nLPSTR CharNextA(LPCSTR);\nLPSTR CharPrevA(LPCSTR,LPCSTR);\nBOOL IsCharAlphaA(CHAR ch);\nBOOL IsCharAlphaNumericA(CHAR);\nBOOL IsCharUpperA(CHAR);\nBOOL IsCharLowerA(CHAR);\nint GetKeyNameTextA(LONG,LPSTR,int);\nSHORT VkKeyScanA(CHAR);\nSHORT VkKeyScanExA(CHAR,HKL);\nUINT MapVirtualKeyA(UINT,UINT);\nUINT MapVirtualKeyExA(UINT,UINT,HKL);\nHACCEL LoadAcceleratorsA(HINSTANCE,LPCSTR);\nHACCEL CreateAcceleratorTableA(LPACCEL,int);\nint CopyAcceleratorTableA(HACCEL,LPACCEL,int);\nint TranslateAcceleratorA(HWND,HACCEL,LPMSG);\nHMENU LoadMenuA(HINSTANCE,LPCSTR);\nHMENU LoadMenuIndirectA(CONST MENUTEMPLATE *);\nBOOL ChangeMenuA(HMENU,UINT,LPCSTR,UINT,UINT);\nint GetMenuStringA(HMENU,UINT,LPSTR,int,UINT);\nBOOL InsertMenuA(HMENU,UINT,UINT,UINT,LPCSTR);\nBOOL AppendMenuA(HMENU,UINT,UINT,LPCSTR);\nBOOL ModifyMenuA(HMENU,UINT,UINT,UINT,LPCSTR);\nBOOL InsertMenuItemA(HMENU,UINT,BOOL,LPCMENUITEMINFO);\nBOOL GetMenuItemInfoA(HMENU,UINT,BOOL,LPMENUITEMINFO);\nBOOL SetMenuItemInfoA(HMENU,UINT,BOOL,LPCMENUITEMINFO);\nint DrawTextA(HDC,LPCSTR,int,LPRECT,UINT);\nint DrawTextExA(HDC,LPSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);\nBOOL GrayStringA(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);\nBOOL DrawStateA(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);\nLONG TabbedTextOutA(HDC,int,int,LPCSTR,int,int,LPINT,int);\nDWORD GetTabbedTextExtentA(HDC,LPCSTR,int,int,LPINT);\nBOOL SetPropA(HWND,LPCSTR,HANDLE);\nHANDLE GetPropA(HWND,LPCSTR);\nHANDLE RemovePropA(HWND,LPCSTR);\nint EnumPropsExA(HWND,PROPENUMPROCEX,LPARAM);\nint EnumPropsA(HWND,PROPENUMPROC);\nBOOL SetWindowTextA(HWND,LPCSTR);\nint GetWindowTextA(HWND,LPSTR,int);\nint GetWindowTextLengthA(HWND);\nint MessageBoxA(HWND,LPCSTR,LPCSTR,UINT);\nint MessageBoxExA(HWND,LPCSTR,LPCSTR,UINT,WORD);\nint MessageBoxIndirectA(LPMSGBOXPARAMS);\nLONG GetWindowLongA(HWND,int);\nLONG SetWindowLongA(HWND,int,LONG);\n#define GetWindowLongPtrA\tGetWindowLongA\n#define SetWindowLongPtrA\tSetWindowLongA\nDWORD GetClassLongA(HWND,int);\nDWORD SetClassLongA(HWND,int,LONG);\nHWND FindWindowA(LPCSTR,LPCSTR);\nHWND FindWindowExA(HWND,HWND,LPCSTR,LPCSTR);\nint GetClassNameA(HWND,LPSTR,int);\nHHOOK SetWindowsHookExA(int,HOOKPROC,HINSTANCE,DWORD);\nHOOKPROC WINAPI SetWindowsHookA(int,HOOKPROC);\nHBITMAP LoadBitmapA(HINSTANCE,LPCSTR);\nHCURSOR LoadCursorA(HINSTANCE,LPCSTR);\nHCURSOR LoadCursorFromFileA(LPCSTR);\nHICON LoadIconA(HINSTANCE,LPCSTR);\nHANDLE LoadImageA(HINSTANCE,LPCSTR,UINT,int,int,UINT);\nint LoadStringA(HINSTANCE,UINT,LPSTR,int);\nBOOL IsDialogMessageA(HWND,LPMSG);\nint DlgDirListA(HWND,LPSTR,int,int,UINT);\nBOOL DlgDirSelectExA(HWND,LPSTR,int,int);\nint DlgDirListComboBoxA(HWND,LPSTR,int,int,UINT);\nBOOL DlgDirSelectComboBoxExA(HWND,LPSTR,int,int);\nLRESULT DefFrameProcA(HWND,HWND,UINT,WPARAM,LPARAM);\nLRESULT DefMDIChildProcA(HWND,UINT,WPARAM,LPARAM);\nHWND CreateMDIWindowA(LPSTR,LPSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);\nBOOL WinHelpA(HWND,LPCSTR,UINT,DWORD);\nLONG ChangeDisplaySettingsA(LPDEVMODE,DWORD);\nLONG WINAPI ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, LPDEVMODEA lpDevMode, HWND hwnd,\n\t\t\t\t\t\t\t\t\t\t\t   DWORD dwflags, LPVOID lParam);\nBOOL EnumDisplaySettingsA(LPCSTR,DWORD,LPDEVMODE);\nBOOL SystemParametersInfoA(UINT,UINT,PVOID,UINT);\nint AddFontResourceA(LPCSTR);\nint WINAPI ChoosePixelFormat(HDC,PIXELFORMATDESCRIPTOR *);\nBOOL WINAPI SetPixelFormat(HDC,int,PIXELFORMATDESCRIPTOR *);\nHMETAFILE CopyMetaFileA(HMETAFILE,LPCSTR);\nHFONT CreateFontIndirectA(CONST LOGFONT *);\nHDC CreateICA(LPCSTR,LPCSTR,LPCSTR,CONST DEVMODE *);\nHDC CreateMetaFileA(LPCSTR);\nBOOL CreateScalableFontResourceA(DWORD,LPCSTR,LPCSTR,LPCSTR);\nint DeviceCapabilitiesA(LPCSTR,LPCSTR,WORD,LPSTR,CONST DEVMODE *);\nint EnumFontFamiliesExA(HDC,LPLOGFONT,FONTENUMEXPROC,LPARAM,DWORD);\nint EnumFontFamiliesA(HDC,LPCSTR,FONTENUMPROC,LPARAM);\nint EnumFontsA(HDC,LPCSTR,ENUMFONTSPROC,LPARAM);\nBOOL GetCharWidthA(HDC,UINT,UINT,LPINT);\nBOOL GetCharWidth32A(HDC,UINT,UINT,LPINT);\nBOOL GetCharWidthFloatA(HDC,UINT,UINT,PFLOAT);\nBOOL GetCharABCWidthsA(HDC,UINT,UINT,LPABC);\nBOOL GetCharABCWidthsFloatA(HDC,UINT,UINT,LPABCFLOAT);\nDWORD GetGlyphOutlineA(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,LPVOID,CONST MAT2 *);\nHMETAFILE GetMetaFileA(LPCSTR);\nUINT GetOutlineTextMetricsA(HDC,UINT,LPOUTLINETEXTMETRIC);\nBOOL GetTextExtentPointA(HDC,LPCSTR,int,LPSIZE);\nBOOL GetTextExtentPoint32A(HDC,LPCSTR,int,LPSIZE);\nBOOL GetTextExtentExPointA(HDC,LPCSTR,int,int,LPINT,LPINT,LPSIZE);\nBOOL SignalObjectAndWait(HANDLE,HANDLE,DWORD,BOOL);\nDWORD GetCharacterPlacementA(HDC,LPCSTR,int,int,LPGCP_RESULTS,DWORD);\nHDC ResetDCA(HDC,CONST DEVMODE *);\nBOOL RemoveFontResourceA(LPCSTR);\nHENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE,LPCSTR);\nHDC CreateEnhMetaFileA(HDC,LPCSTR,CONST RECT *,LPCSTR);\nHENHMETAFILE GetEnhMetaFileA(LPCSTR);\nUINT GetEnhMetaFileDescriptionA(HENHMETAFILE,UINT,LPSTR);\nBOOL GetTextMetricsA(HDC,LPTEXTMETRIC);\nint StartDocA(HDC,CONST DOCINFO *);\nint GetObjectA(HGDIOBJ,int,LPVOID);\nBOOL TextOutA(HDC,int,int,LPCSTR,int);\nBOOL ExtTextOutA(HDC,int,int,UINT,CONST RECT *,LPCSTR,UINT,CONST INT *);\nBOOL PolyTextOutA(HDC,CONST POLYTEXT *,int);\nint GetTextFaceA(HDC,int,LPSTR);\nDWORD GetKerningPairsA(HDC,DWORD,LPKERNINGPAIR);\nHCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACE);\nBOOL GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACE,DWORD);\nBOOL GetICMProfileA(HDC,DWORD,LPSTR);\nBOOL SetICMProfileA(HDC,LPSTR);\nBOOL UpdateICMRegKeyA(DWORD,DWORD,LPSTR,UINT);\nint EnumICMProfilesA(HDC,ICMENUMPROC,LPARAM);\nint PropertySheetA(LPCPROPSHEETHEADER);\nHIMAGELIST ImageList_LoadImageA(HINSTANCE,LPCSTR,int,int,COLORREF,UINT,UINT);\nHWND CreateStatusWindowA(LONG,LPCSTR,HWND,UINT);\nvoid DrawStatusTextA(HDC,LPRECT,LPCSTR,UINT);\nBOOL GetOpenFileNameA(LPOPENFILENAME);\nBOOL GetSaveFileNameA(LPOPENFILENAME);\nshort GetFileTitleA(LPCSTR,LPSTR,WORD);\nBOOL ChooseColorA(LPCHOOSECOLOR);\nHWND FindTextA(LPFINDREPLACE);\nHWND ReplaceTextA(LPFINDREPLACE);\nBOOL ChooseFontA(LPCHOOSEFONT);\nBOOL PrintDlgA(LPPRINTDLG);\nBOOL PageSetupDlgA(LPPAGESETUPDLG);\nBOOL CreateProcessA(LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCSTR,LPSTARTUPINFO,LPPROCESS_INFORMATION);\nBOOL WINAPI CreateProcessWithTokenW(HANDLE,DWORD,LPCWSTR,LPWSTR,DWORD,LPVOID,\n\tLPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);\nVOID GetStartupInfoA(LPSTARTUPINFO);\nHANDLE FindFirstFileA(LPCSTR,LPWIN32_FIND_DATA);\nHANDLE WINAPI FindFirstFileExA(LPCSTR,FINDEX_INFO_LEVELS,LPVOID,FINDEX_SEARCH_OPS,LPVOID,DWORD);\nBOOL FindNextFileA(HANDLE,LPWIN32_FIND_DATA);\nBOOL GetVersionExA(LPOSVERSIONINFO);\n#define CreateWindowA(C,WN,S,x,y,W,H,hW,hM,hI,l) CreateWindowExA(0,C,WN,S,x,y,W,H,hW,hM,hI,l)\n#define CreateDialogA(hI,Name,hP,Func) CreateDialogParamA(hI,Name,hP,Func,0)\n#define CreateDialogIndirectA(hI,T,P,Func) CreateDialogIndirectParamA(hI,T,P,Func,0)\n#define DialogBoxA(h,T,P,D) DialogBoxParamA(h,T,P,D,0)\n#define DialogBoxIndirectA(h,T,P,D) DialogBoxIndirectParamA(h,T,P,D,0)\nHDC CreateDCA(LPCSTR,LPCSTR,LPCSTR,CONST DEVMODE *);\nDWORD VerInstallFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,PUINT);\nDWORD GetFileVersionInfoSizeA(LPSTR,LPDWORD);\nBOOL GetFileVersionInfoA(LPSTR,DWORD,DWORD,LPVOID);\nDWORD VerLanguageNameA(DWORD,LPSTR,DWORD);\nDWORD VerFindFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,PUINT,LPSTR,PUINT);\nLONG RegConnectRegistryA(LPSTR,HKEY,PHKEY);\nLONG RegCreateKeyA(HKEY,LPCSTR,PHKEY);\nLONG RegCreateKeyExA(HKEY,LPCSTR,DWORD,LPSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,LPDWORD);\nLONG RegDeleteKeyA(HKEY,LPCSTR);\nLONG RegDeleteValueA (HKEY,LPCSTR);\nLONG RegEnumKeyA (HKEY,DWORD,LPSTR,DWORD);\nLONG RegEnumKeyExA(HKEY,DWORD,LPSTR,LPDWORD,LPDWORD,LPSTR,LPDWORD,PFILETIME);\nLONG RegEnumValueA(HKEY,DWORD,LPSTR,LPDWORD,LPDWORD,LPDWORD,LPBYTE,LPDWORD);\nLONG RegLoadKeyA(HKEY,LPCSTR,LPCSTR);\nLONG RegOpenKeyA(HKEY,LPCSTR,PHKEY);\nLONG RegOpenKeyExA(HKEY,LPCSTR,DWORD,REGSAM,PHKEY);\nLONG RegQueryInfoKeyA(HKEY,LPSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD,\n\tLPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,PFILETIME);\nLONG RegQueryValueA(HKEY,LPCSTR,LPSTR,PLONG);\nLONG RegQueryMultipleValuesA(HKEY,PVALENT,DWORD,LPSTR,LPDWORD);\nLONG RegQueryValueExA (HKEY,LPCSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);\nLONG RegReplaceKeyA(HKEY,LPCSTR,LPCSTR,LPCSTR);\nLONG RegRestoreKeyA (HKEY,LPCSTR,DWORD);\nLONG RegSaveKeyA(HKEY,LPCSTR,LPSECURITY_ATTRIBUTES);\nLONG RegSetValueA(HKEY,LPCSTR,DWORD,LPCSTR,DWORD);\nLONG RegSetValueExA(HKEY,LPCSTR,DWORD,DWORD,BYTE*,DWORD);\nLONG RegUnLoadKeyA(HKEY,LPCSTR);\nBOOL InitiateSystemShutdownA(LPSTR,LPSTR,DWORD,BOOL,BOOL);\nBOOL AbortSystemShutdownA(LPSTR);\nint CompareStringA(LCID,DWORD,LPCSTR,int,LPCSTR,int);\nint LCMapStringA(LCID,DWORD,LPCSTR,int,LPSTR,int);\nint GetLocaleInfoA(LCID,LCTYPE,LPSTR,int);\nBOOL SetLocaleInfoA(LCID,LCTYPE,LPCSTR);\nint GetTimeFormatA(LCID,DWORD,CONST SYSTEMTIME *,LPCSTR,LPSTR,int);\nint GetDateFormatA(LCID,DWORD,CONST SYSTEMTIME *,LPCSTR,LPSTR,int);\nint GetNumberFormatA(LCID,DWORD,LPCSTR,CONST NUMBERFMTA *,LPSTR,int);\nint GetCurrencyFormatA(LCID,DWORD,LPCSTR,CONST CURRENCYFMT *,LPSTR,int);\nBOOL EnumCalendarInfoA(CALINFO_ENUMPROC,LCID,CALID,CALTYPE);\nBOOL EnumTimeFormatsA(TIMEFMT_ENUMPROC,LCID,DWORD);\nBOOL EnumDateFormatsA(DATEFMT_ENUMPROC,LCID,DWORD);\nBOOL GetStringTypeExA(LCID,DWORD,LPCSTR,int,LPWORD);\nBOOL GetStringTypeA(LCID,DWORD,LPCSTR,int,LPWORD);\nint FoldStringA(DWORD,LPCSTR,int,LPSTR,int);\nBOOL EnumSystemLocalesA(LOCALE_ENUMPROC,DWORD);\nBOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROC,DWORD);\nBOOL PeekConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);\nBOOL ReadConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);\nBOOL WriteConsoleInputA(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);\nBOOL ReadConsoleOutputA(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);\nBOOL WriteConsoleOutputA(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);\nBOOL ReadConsoleOutputCharacterA(HANDLE,LPSTR,DWORD,COORD,LPDWORD);\nBOOL WriteConsoleOutputCharacterA(HANDLE,LPCSTR,DWORD,COORD,LPDWORD);\nBOOL FillConsoleOutputCharacterA(HANDLE,CHAR,DWORD,COORD,LPDWORD);\nBOOL ScrollConsoleScreenBufferA(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);\nDWORD GetConsoleTitleA(LPSTR,DWORD);\nBOOL SetConsoleTitleA(LPCSTR);\nBOOL ReadConsoleA(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);\nBOOL WriteConsoleA(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);\nDWORD WNetAddConnectionA(LPCSTR,LPCSTR,LPCSTR);\nDWORD WNetAddConnection2A(LPNETRESOURCE,LPCSTR,LPCSTR,DWORD);\nDWORD WNetAddConnection3A(HWND,LPNETRESOURCE,LPCSTR,LPCSTR,DWORD);\nDWORD WNetCancelConnectionA(LPCSTR,BOOL);\nDWORD WNetCancelConnection2A(LPCSTR,DWORD,BOOL);\nDWORD WNetGetConnectionA(LPCSTR,LPSTR,LPDWORD);\nDWORD WNetUseConnectionA(HWND,LPNETRESOURCE,LPCSTR,LPCSTR,DWORD,LPSTR,LPDWORD,LPDWORD);\nDWORD WNetSetConnectionA(LPCSTR,DWORD,LPVOID);\nDWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCT);\nDWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCT);\nDWORD WNetOpenEnumA(DWORD,DWORD,DWORD,LPNETRESOURCE,LPHANDLE);\nDWORD WNetEnumResourceA(HANDLE,LPDWORD,LPVOID,LPDWORD);\nDWORD WNetGetUniversalNameA(LPCSTR,DWORD,LPVOID,LPDWORD);\nDWORD WNetGetUserA(LPCSTR,LPSTR,LPDWORD);\nDWORD WNetGetProviderNameA(DWORD,LPSTR,LPDWORD);\nDWORD WNetGetNetworkInformationA(LPCSTR,LPNETINFOSTRUCT);\nDWORD WNetGetLastErrorA(LPDWORD,LPSTR,DWORD,LPSTR,DWORD);\nDWORD MultinetGetConnectionPerformanceA(LPNETRESOURCE,LPNETCONNECTINFOSTRUCT);\nBOOL WINAPI TrackMouseEvent(LPTRACKMOUSEEVENT);\nHWND WINAPI GetAncestor(HWND,UINT);\nBOOL WINAPI GetComboBoxInfo(HWND,PCOMBOBOXINFO);\nUCHAR APIENTRY Netbios(PNCB);\nLANGID WINAPI GetMUILanguage(void);\nvoid WINAPI InitMUILanguage(LANGID);\n#ifdef UNICODE\n#define GetLongPathName GetLongPathNameW\n#define GetDiskFreeSpaceEx GetDiskFreeSpaceExW\n#define CreateProcessAsUser CreateProcessAsUserW\n#define HDITEM\tHDITEMW\n#define LPHDITEM LPHDITEMW\n#define COMBOBOXEXITEM\tCOMBOBOXEXITEMW\n#define PCOMBOBOXEXITEM\tPCOMBOBOXEXITEMW\n#define PCCOMBOBOXEXITEM\tPCCOMBOBOXEXITEMW\n#define CBEM_INSERTITEM\tCBEM_INSERTITEMW\n#define CBEM_SETITEM\tCBEM_SETITEMW\n#define CBEM_GETITEM\tCBEM_GETITEMW\n#define DATETIMEPICK_CLASS\tDATETIMEPICK_CLASSW\n#define DTN_USERSTRING\tDTN_USERSTRINGW\n#define NMDATETIMESTRING\tNMDATETIMESTRINGW\n#define LPNMDATETIMESTRING\tLPNMDATETIMESTRINGW\n#define DTN_WMKEYDOWN\tDTN_WMKEYDOWNW\n#define NMDATETIMEWMKEYDOWN\tNMDATETIMEWMKEYDOWNW\n#define LPNMDATETIMEWMKEYDOWN\tLPNMDATETIMEWMKEYDOWNW\n#define DTN_FORMAT\tDTN_FORMATW\n#define NMDATETIMEFORMAT\tNMDATETIMEFORMATW\n#define LPNMDATETIMEFORMAT\tLPNMDATETIMEFORMATW\n#define DTN_FORMATQUERY\tDTN_FORMATQUERYW\n#define NMDATETIMEFORMATQUERY\tNMDATETIMEFORMATQUERYW\n#define LPNMDATETIMEFORMATQUERY\tLPNMDATETIMEFORMATQUERYW\n#define RegConnectRegistry\tRegConnectRegistryW\n#define RegCreateKey\tRegCreateKeyW\n#define RegCreateKeyEx\tRegCreateKeyExW\n#define RegDeleteKey\tRegDeleteKeyW\n#define RegDeleteValue\tRegDeleteValueW\n#define RegEnumKey\tRegEnumKeyW\n#define RegEnumKeyEx\tRegEnumKeyExW\n#define RegEnumValue\tRegEnumValueW\n#define RegLoadKey\tRegLoadKeyW\n#define RegOpenKey\tRegOpenKeyW\n#define RegOpenKeyEx\tRegOpenKeyExW\n#define RegQueryInfoKey RegQueryInfoKeyW\n#define RegQueryValue\tRegQueryValueW\n#define RegQueryMultipleValues RegQueryMultipleValuesW\n#define RegQueryValueEx RegQueryValueExW\n#define RegReplaceKey\tRegReplaceKeyW\n#define RegRestoreKey\tRegRestoreKeyW\n#define RegSaveKey\tRegSaveKeyW\n#define RegSetValue\tRegSetValueW\n#define RegSetValueEx RegSetValueExW\n#define AbortSystemShutdown AbortSystemShutdownW\n#define InitiateSystemShutdown InitiateSystemShutdownW\n#define RegUnLoadKey RegUnLoadKeyW\n#define SetProp SetPropW\n#define GetProp GetPropW\n#define RemoveProp RemovePropW\n#define EnumPropsEx EnumPropsExW\n#define EnumProps EnumPropsW\n#define SetWindowText SetWindowTextW\n#define GetWindowText GetWindowTextW\n#define GetWindowTextLength GetWindowTextLengthW\n#define MessageBox MessageBoxW\n#define MessageBoxEx MessageBoxExW\n#define MessageBoxIndirect MessageBoxIndirectW\n#define GetWindowLong GetWindowLongW\n#define SetWindowLong SetWindowLongW\n#define GetWindowLongPtr GetWindowLongPtrW\n#define SetWindowLongPtr SetWindowLongPtrW\n#define SetWindowLongPtrW\tSetWindowLongW\n#define GetClassLong GetClassLongW\n#define SetClassLong SetClassLongW\n#define GetClassLongPtr GetClassLongPtrW\n#define SetClassLongPtr\tSetClassLongPtrW\n#define FindWindow FindWindowW\n#define FindWindowEx FindWindowExW\n#define GetClassName\tGetClassNameW\n#define SetWindowsHookEx\tSetWindowsHookExW\n#define SetWindowsHook\tSetWindowsHookW\n#define LoadBitmap\tLoadBitmapW\n#define LoadCursor\tLoadCursorW\n#define LoadCursorFromFile\tLoadCursorFromFileW\n#define LoadIcon\tLoadIconW\n#define LoadImage LoadImageW\n#define LoadString LoadStringW\n#define IsDialogMessage IsDialogMessageW\n#define DlgDirList DlgDirListW\n#define DlgDirSelectEx DlgDirSelectExW\n#define DlgDirListComboBox DlgDirListComboBoxW\n#define DlgDirSelectComboBoxEx DlgDirSelectComboBoxExW\n#define DefFrameProc DefFrameProcW\n#define DefMDIChildProc DefMDIChildProcW\n#define CreateMDIWindow CreateMDIWindowW\n#define WinHelp WinHelpW\n#define ChangeDisplaySettings ChangeDisplaySettingsW\n#define ChangeDisplaySettingsEx ChangeDisplaySettingsExW\n#define EnumDisplaySettings EnumDisplaySettingsW\n#define SystemParametersInfo SystemParametersInfoW\n#define AddFontResource AddFontResourceW\n#define CopyMetaFile CopyMetaFileW\n#define CreateDC CreateDCW\n#define CreateFontIndirect CreateFontIndirectW\n#define CreateFont CreateFontW\n#define CreateIC CreateICW\n#define CreateMetaFile CreateMetaFileW\n#define CreateScalableFontResource CreateScalableFontResourceW\n#define DeviceCapabilities DeviceCapabilitiesW\n#define EnumFontFamiliesEx EnumFontFamiliesExW\n#define EnumFontFamilies EnumFontFamiliesW\n#define EnumFonts EnumFontsW\n#define GetCharWidth GetCharWidthW\n#define GetCharWidth32 GetCharWidth32W\n#define GetCharWidthFloat GetCharWidthFloatW\n#define GetCharABCWidths GetCharABCWidthsW\n#define GetCharABCWidthsFloat GetCharABCWidthsFloatW\n#define GetGlyphOutline GetGlyphOutlineW\n#define GetMetaFile GetMetaFileW\n#define GetOutlineTextMetrics GetOutlineTextMetricsW\n#define GetTextExtentPoint GetTextExtentPointW\n#define GetTextExtentPoint32 GetTextExtentPoint32W\n#define GetTextExtentExPoint GetTextExtentExPointW\n#define GetCharacterPlacement GetCharacterPlacementW\n#define ResetDC ResetDCW\n#define RemoveFontResource RemoveFontResourceW\n#define CopyEnhMetaFile CopyEnhMetaFileW\n#define CreateEnhMetaFile CreateEnhMetaFileW\n#define GetEnhMetaFile GetEnhMetaFileW\n#define GetEnhMetaFileDescription GetEnhMetaFileDescriptionW\n#define GetTextMetrics GetTextMetricsW\n#define StartDoc StartDocW\n#define GetObject GetObjectW\n#define TextOut TextOutW\n#define ExtTextOut ExtTextOutW\n#define PolyTextOut PolyTextOutW\n#define GetTextFace GetTextFaceW\n#define GetKerningPairs GetKerningPairsW\n#define GetLogColorSpace GetLogColorSpaceW\n#define CreateColorSpace CreateColorSpaceW\n#define GetICMProfile GetICMProfileW\n#define SetICMProfile SetICMProfileW\n#define UpdateICMRegKey UpdateICMRegKeyW\n#define EnumICMProfiles EnumICMProfilesW\n#define CreatePropertySheetPage CreatePropertySheetPageW\n#define PropertySheet PropertySheetW\n#define ImageList_LoadImage ImageList_LoadImageW\n#define CreateStatusWindow CreateStatusWindowW\n#define DrawStatusText DrawStatusTextW\n#define GetOpenFileName GetOpenFileNameW\n#define GetSaveFileName GetSaveFileNameW\n#define GetFileTitle GetFileTitleW\n#define ChooseColor ChooseColorW\n#define FindText FindTextW\n#define ReplaceText ReplaceTextW\n#define ChooseFont ChooseFontW\n#define PrintDlg PrintDlgW\n#define PageSetupDlg PageSetupDlgW\n#define DefWindowProc DefWindowProcW\n#define CallWindowProc CallWindowProcW\n#define RegisterClass RegisterClassW\n#define UnregisterClass UnregisterClassW\n#define GetClassInfo GetClassInfoW\n#define RegisterClassEx RegisterClassExW\n#define GetClassInfoEx GetClassInfoExW\n#define CreateWindowEx CreateWindowExW\n#define CreateWindow CreateWindowW\n#define CreateDialogParam CreateDialogParamW\n#define CreateDialogIndirectParam CreateDialogIndirectParamW\n#define CreateDialog CreateDialogW\n#define CreateDialogIndirect CreateDialogIndirectW\n#define DialogBoxParam DialogBoxParamW\n#define DialogBoxIndirectParam DialogBoxIndirectParamW\n#define DialogBox DialogBoxW\n#define DialogBoxIndirect DialogBoxIndirectW\n#define RegisterClipboardFormat RegisterClipboardFormatW\n#define SetDlgItemText SetDlgItemTextW\n#define GetDlgItemText GetDlgItemTextW\n#define SendDlgItemMessage SendDlgItemMessageW\n#define DefDlgProc DefDlgProcW\n#define CallMsgFilter CallMsgFilterW\n#define GetClipboardFormatName GetClipboardFormatNameW\n#define CharToOem CharToOemW\n#define OemToChar OemToCharW\n#define CharToOemBuff CharToOemBuffW\n#define OemToCharBuff OemToCharBuffW\n#define CharUpper CharUpperW\n#define CharUpperBuff CharUpperBuffW\n#define CharLower CharLowerW\n#define CharLowerBuff CharLowerBuffW\n#define CharNext CharNextW\n#define CharPrev CharPrevW\n#define IsCharAlpha IsCharAlphaW\n#define IsCharAlphaNumeric IsCharAlphaNumericW\n#define IsCharUpper IsCharUpperW\n#define IsCharLower IsCharLowerW\n#define GetKeyNameText GetKeyNameTextW\n#define VkKeyScan VkKeyScanW\n#define VkKeyScanEx VkKeyScanExW\n#define MapVirtualKey MapVirtualKeyW\n#define MapVirtualKeyEx MapVirtualKeyExW\n#define LoadAccelerators LoadAcceleratorsW\n#define CreateAcceleratorTable CreateAcceleratorTableW\n#define CopyAcceleratorTable CopyAcceleratorTableW\n#define TranslateAccelerator TranslateAcceleratorW\n#define LoadMenu LoadMenuW\n#define LoadMenuIndirect LoadMenuIndirectW\n#define ChangeMenu ChangeMenuW\n#define GetMenuString GetMenuStringW\n#define InsertMenu InsertMenuW\n#define AppendMenu AppendMenuW\n#define ModifyMenu ModifyMenuW\n#define InsertMenuItem InsertMenuItemW\n#define GetMenuItemInfo GetMenuItemInfoW\n#define SetMenuItemInfo SetMenuItemInfoW\n#define DrawText DrawTextW\n#define DrawTextEx DrawTextExW\n#define GrayString GrayStringW\n#define DrawState DrawStateW\n#define TabbedTextOut TabbedTextOutW\n#define GetTabbedTextExtent GetTabbedTextExtentW\n#define GetVersionEx GetVersionExW\n#define wvsprintf wvsprintfW\n#define wsprintf wsprintfW\n#define LoadKeyboardLayout LoadKeyboardLayoutW\n#define GetKeyboardLayoutName GetKeyboardLayoutNameW\n#define CreateDesktop CreateDesktopW\n#define OpenDesktop OpenDesktopW\n#define EnumDesktops EnumDesktopsW\n#define CreateWindowStation CreateWindowStationW\n#define OpenWindowStation OpenWindowStationW\n#define EnumWindowStations EnumWindowStationsW\n#define IsBadStringPtr IsBadStringPtrW\n#define LookupAccountSid LookupAccountSidW\n#define LookupAccountName LookupAccountNameW\n#define LookupPrivilegeValue LookupPrivilegeValueW\n#define LookupPrivilegeName LookupPrivilegeNameW\n#define LookupPrivilegeDisplayName LookupPrivilegeDisplayNameW\n#define BuildCommDCB BuildCommDCBW\n#define BuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsW\n#define CommConfigDialog CommConfigDialogW\n#define GetDefaultCommConfig GetDefaultCommConfigW\n#define SetDefaultCommConfig SetDefaultCommConfigW\n#define GetComputerName GetComputerNameW\n#define SetComputerName SetComputerNameW\n#define GetUserName GetUserNameW\n#define CreateMailslot CreateMailslotW\n#define FormatMessage FormatMessageW\n#define GetEnvironmentStrings GetEnvironmentStringsW\n#define FreeEnvironmentStrings FreeEnvironmentStringsW\n#define lstrcmp lstrcmpW\n#define lstrcmpi lstrcmpiW\n#define lstrcpyn lstrcpynW\n#define lstrcpy lstrcpyW\n#define lstrcat lstrcatW\n#define lstrlen lstrlenW\n#define GetBinaryType GetBinaryTypeW\n#define GetShortPathName GetShortPathNameW\n#define SetFileSecurity SetFileSecurityW\n#define GetFileSecurity GetFileSecurityW\n#define FindFirstChangeNotification FindFirstChangeNotificationW\n#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmW\n#define ObjectOpenAuditAlarm ObjectOpenAuditAlarmW\n#define ObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmW\n#define ObjectCloseAuditAlarm ObjectCloseAuditAlarmW\n#define PrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmW\n#define OpenEventLog OpenEventLogW\n#define RegisterEventSource RegisterEventSourceW\n#define OpenBackupEventLog OpenBackupEventLogW\n#define ReadEventLog ReadEventLogW\n#define ReportEvent ReportEventW\n#define CreateProcess CreateProcessW\n#define FatalAppExit FatalAppExitW\n#define GetStartupInfo GetStartupInfoW\n#define GetEnvironmentVariable GetEnvironmentVariableW\n#define GetCommandLine GetCommandLineW\n#define SetEnvironmentVariable SetEnvironmentVariableW\n#define ExpandEnvironmentStrings ExpandEnvironmentStringsW\n#define OutputDebugString OutputDebugStringW\n#define FindResource FindResourceW\n#define FindResourceEx FindResourceExW\n#define EnumResourceTypes EnumResourceTypesW\n#define EnumResourceNames EnumResourceNamesW\n#define EnumResourceLanguages EnumResourceLanguagesW\n#define BeginUpdateResource BeginUpdateResourceW\n#define UpdateResource UpdateResourceW\n#define EndUpdateResource EndUpdateResourceW\n#define GlobalAddAtom GlobalAddAtomW\n#define GlobalFindAtom GlobalFindAtomW\n#define GlobalGetAtomName GlobalGetAtomNameW\n#define AddAtom AddAtomW\n#define FindAtom FindAtomW\n#define GetAtomName GetAtomNameW\n#define GetProfileInt GetProfileIntW\n#define GetProfileString GetProfileStringW\n#define WriteProfileString WriteProfileStringW\n#define GetProfileSection GetProfileSectionW\n#define WriteProfileSection WriteProfileSectionW\n#define GetPrivateProfileInt GetPrivateProfileIntW\n#define GetPrivateProfileSectionNames GetrivateProfileSectionNamesW\n#define GetPrivateProfileString GetPrivateProfileStringW\n#define WritePrivateProfileString WritePrivateProfileStringW\n#define WritePrivateProfileStruct WritePrivateProfileStructW\n#define GetPrivateProfileSection GetPrivateProfileSectionW\n#define WritePrivateProfileSection WritePrivateProfileSectionW\n#define GetDriveType GetDriveTypeW\n#define GetSystemDirectory GetSystemDirectoryW\n#define GetTempPath GetTempPathW\n#define GetTempFileName GetTempFileNameW\n#define GetWindowsDirectory GetWindowsDirectoryW\n#define SetCurrentDirectory SetCurrentDirectoryW\n#define GetCurrentDirectory GetCurrentDirectoryW\n#define GetDiskFreeSpace GetDiskFreeSpaceW\n#define CreateDirectory CreateDirectoryW\n#define CreateDirectoryEx CreateDirectoryExW\n#define RemoveDirectory RemoveDirectoryW\n#define GetFullPathName GetFullPathNameW\n#define DefineDosDevice DefineDosDeviceW\n#define QueryDosDevice QueryDosDeviceW\n#define CreateFile CreateFileW\n#define SetFileAttributes SetFileAttributesW\n#define GetFileAttributes GetFileAttributesW\n#define GetCompressedFileSize GetCompressedFileSizeW\n#define DeleteFile DeleteFileW\n#define FindFirstFile FindFirstFileW\n#define FindFirstFileEx FindFirstFileExW\n#define FindNextFile FindNextFileW\n#define SearchPath SearchPathW\n#define CopyFile CopyFileW\n#define CopyFileEx CopyFileExW\n#define CreateHardLink CreateHardLinkW\n#define MoveFile MoveFileW\n#define MoveFileWithProgress MoveFileWithProgressW\n#define MoveFileEx MoveFileExW\n#define CreateNamedPipe CreateNamedPipeW\n#define GetNamedPipeHandleState GetNamedPipeHandleStateW\n#define CallNamedPipe CallNamedPipeW\n#define WaitNamedPipe WaitNamedPipeW\n#define SetVolumeLabel SetVolumeLabelW\n#define GetVolumeInformation GetVolumeInformationW\n#define ClearEventLog ClearEventLogW\n#define BackupEventLog BackupEventLogW\n#define CreateMutex CreateMutexW\n#define OpenMutex OpenMutexW\n#define CreateEvent CreateEventW\n#define OpenEvent OpenEventW\n#define CreateSemaphore CreateSemaphoreW\n#define OpenSemaphore OpenSemaphoreW\n#define CreateFileMapping CreateFileMappingW\n#define OpenFileMapping OpenFileMappingW\n#define GetLogicalDriveStrings GetLogicalDriveStringsW\n#define LoadLibrary LoadLibraryW\n#define LoadLibraryEx LoadLibraryExW\n#define GetModuleFileName GetModuleFileNameW\n#define GetModuleHandle GetModuleHandleW\n#define GetUserObjectInformation GetUserObjectInformationW\n#define SetUserObjectInformation SetUserObjectInformationW\n#define RegisterWindowMessage RegisterWindowMessageW\n#define GetMessage GetMessageW\n#define DispatchMessage DispatchMessageW\n#define PeekMessage PeekMessageW\n#define SendMessage SendMessageW\n#define SendMessageTimeout SendMessageTimeoutW\n#define SendNotifyMessage SendNotifyMessageW\n#define SendMessageCallback SendMessageCallbackW\n#define PostMessage PostMessageW\n#define PostThreadMessage PostThreadMessageW\n#define VerFindFile VerFindFileW\n#define VerInstallFile VerInstallFileW\n#define GetFileVersionInfoSize GetFileVersionInfoSizeW\n#define GetFileVersionInfo GetFileVersionInfoW\n#define VerLanguageName VerLanguageNameW\n#define VerQueryValue VerQueryValueW\n#define CompareString CompareStringW\n#define LCMapString LCMapStringW\n#define GetLocaleInfo GetLocaleInfoW\n#define SetLocaleInfo SetLocaleInfoW\n#define GetTimeFormat GetTimeFormatW\n#define GetDateFormat GetDateFormatW\n#define GetNumberFormat GetNumberFormatW\n#define GetCurrencyFormat GetCurrencyFormatW\n#define EnumCalendarInfo EnumCalendarInfoW\n#define EnumTimeFormats EnumTimeFormatsW\n#define FoldString FoldStringW\n#define EnumSystemCodePages EnumSystemCodePagesW\n#define EnumSystemLocales EnumSystemLocalesW\n#define GetStringTypeEx GetStringTypeExW\n#define EnumDateFormats EnumDateFormatsW\n#define GetConsoleTitle GetConsoleTitleW\n#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferW\n#define SetConsoleTitle SetConsoleTitleW\n#define ReadConsole ReadConsoleW\n#define WriteConsole WriteConsoleW\n#define PeekConsoleInput PeekConsoleInputW\n#define ReadConsoleInput ReadConsoleInputW\n#define WriteConsoleInput WriteConsoleInputW\n#define ReadConsoleOutput ReadConsoleOutputW\n#define WriteConsoleOutput WriteConsoleOutputW\n#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterW\n#define WriteConsoleOutputCharacter WriteConsoleOutputCharacterW\n#define FillConsoleOutputCharacter FillConsoleOutputCharacterW\n#define WNetGetProviderName WNetGetProviderNameW\n#define WNetGetNetworkInformation WNetGetNetworkInformationW\n#define WNetGetLastError WNetGetLastErrorW\n#define MultinetGetConnectionPerformance MultinetGetConnectionPerformanceW\n#define WNetConnectionDialog1 WNetConnectionDialog1W\n#define WNetDisconnectDialog1 WNetDisconnectDialog1W\n#define WNetOpenEnum WNetOpenEnumW\n#define WNetEnumResource WNetEnumResourceW\n#define WNetGetUniversalName WNetGetUniversalNameW\n#define WNetGetUser WNetGetUserW\n#define WNetAddConnection WNetAddConnectionW\n#define WNetAddConnection2 WNetAddConnection2W\n#define WNetAddConnection3 WNetAddConnection3W\n#define WNetCancelConnection WNetCancelConnectionW\n#define WNetCancelConnection2 WNetCancelConnection2W\n#define WNetGetConnection WNetGetConnectionW\n#define WNetUseConnection WNetUseConnectionW\n#define WNetSetConnection WNetSetConnectionW\n#define CreateService CreateServiceW\n#define ChangeServiceConfig ChangeServiceConfigW\n#define EnumDependentServices EnumDependentServicesW\n#define EnumServicesStatus EnumServicesStatusW\n#define GetServiceKeyName GetServiceKeyNameW\n#define GetServiceDisplayName GetServiceDisplayNameW\n#define OpenSCManager OpenSCManagerW\n#define OpenService OpenServiceW\n#define QueryServiceConfig QueryServiceConfigW\n#define QueryServiceLockStatus QueryServiceLockStatusW\n#define RegisterServiceCtrlHandler RegisterServiceCtrlHandlerW\n#define StartServiceCtrlDispatcher StartServiceCtrlDispatcherW\n#define StartService StartServiceW\n#define CommDlg_OpenSave_GetSpec CommDlg_OpenSave_GetSpecW\n#define CommDlg_OpenSave_GetFilePath CommDlg_OpenSave_GetFilePathW\n#define CommDlg_OpenSave_GetFolderPath CommDlg_OpenSave_GetFolderPathW\n#define GetPrivateProfileStruct GetPrivateProfileStructW\n#define LVCOLUMN LVCOLUMNW\n#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointW\n#define GetVolumePathName GetVolumePathNameW\n#define GetVolumePathNamesForVolumeName GetVolumePathNamesForVolumeNameW\n#define DeleteVolumeMountPoint DeleteVolumeMountPointW\n#define SetVolumeMountPoint SetVolumeMountPointW\n#define FindNextVolumeMountPoint FindNextVolumeMountPointW\n#define FindFirstVolumeMountPoint FindFirstVolumeMountPointW\n#define FindNextVolume FindNextVolumeW\n#define FindFirstVolume FindFirstVolumeW\n#define GetGlyphIndices GetGlyphIndicesW\n#else\n#define GetGlyphIndices GetGlyphIndicesA\n#define GetLongPathName GetLongPathNameA\n#define GetDiskFreeSpaceEx GetDiskFreeSpaceExA\n#define CreateProcessAsUser CreateProcessAsUserA\n#define HDITEM HDITEMA\n#define LPHDITEM LPHDITEMA\n#define COMBOBOXEXITEM\tCOMBOBOXEXITEMA\n#define PCOMBOBOXEXITEM\tPCOMBOBOXEXITEMA\n#define PCCOMBOBOXEXITEM\tPCCOMBOBOXEXITEMA\n#define CBEM_INSERTITEM\tCBEM_INSERTITEMA\n#define CBEM_SETITEM\tCBEM_SETITEMA\n#define CBEM_GETITEM\tCBEM_GETITEMA\n#define DATETIMEPICK_CLASS\tDATETIMEPICK_CLASSA\n#define DATETIMEPICK_CLASS\tDATETIMEPICK_CLASSA\n#define DTN_USERSTRING\tDTN_USERSTRINGA\n#define NMDATETIMESTRING\tNMDATETIMESTRINGA\n#define LPNMDATETIMESTRING\tLPNMDATETIMESTRINGA\n#define DTN_WMKEYDOWN\tDTN_WMKEYDOWNA\n#define NMDATETIMEWMKEYDOWN\tNMDATETIMEWMKEYDOWNA\n#define LPNMDATETIMEWMKEYDOWN\tLPNMDATETIMEWMKEYDOWNA\n#define DTN_FORMAT\tDTN_FORMATA\n#define NMDATETIMEFORMAT\tNMDATETIMEFORMATA\n#define LPNMDATETIMEFORMAT\tLPNMDATETIMEFORMATA\n#define DTN_FORMATQUERY\tDTN_FORMATQUERYA\n#define NMDATETIMEFORMATQUERY\tNMDATETIMEFORMATQUERYA\n#define LPNMDATETIMEFORMATQUERY\tLPNMDATETIMEFORMATQUERYA\n#define RegConnectRegistry RegConnectRegistryA\n#define RegCreateKey RegCreateKeyA\n#define RegCreateKeyEx RegCreateKeyExA\n#define RegDeleteKey RegDeleteKeyA\n#define RegDeleteValue RegDeleteValueA\n#define RegEnumKey RegEnumKeyA\n#define RegEnumKeyEx RegEnumKeyExA\n#define RegEnumValue RegEnumValueA\n#define RegLoadKey RegLoadKeyA\n#define RegOpenKey RegOpenKeyA\n#define RegOpenKeyEx RegOpenKeyExA\n#define RegQueryInfoKey RegQueryInfoKeyA\n#define RegQueryValue RegQueryValueA\n#define RegQueryMultipleValues RegQueryMultipleValuesA\n#define RegQueryValueEx RegQueryValueExA\n#define RegReplaceKey RegReplaceKeyA\n#define RegRestoreKey RegRestoreKeyA\n#define RegSaveKey RegSaveKeyA\n#define RegSetValue RegSetValueA\n#define RegSetValueEx RegSetValueExA\n#define AbortSystemShutdown AbortSystemShutdownA\n#define InitiateSystemShutdown InitiateSystemShutdownA\n#define RegUnLoadKey RegUnLoadKeyA\n#define LoadIcon LoadIconA\n#define LoadImage LoadImageA\n#define LoadString LoadStringA\n#define IsDialogMessage IsDialogMessageA\n#define DlgDirList DlgDirListA\n#define DlgDirSelectEx DlgDirSelectExA\n#define DlgDirListComboBox DlgDirListComboBoxA\n#define DlgDirSelectComboBoxEx DlgDirSelectComboBoxExA\n#define DefFrameProc DefFrameProcA\n#define DefMDIChildProc DefMDIChildProcA\n#define CreateMDIWindow CreateMDIWindowA\n#define WinHelp WinHelpA\n#define ChangeDisplaySettings ChangeDisplaySettingsA\n#define ChangeDisplaySettingsEx ChangeDisplaySettingsExA\n#define EnumDisplaySettings EnumDisplaySettingsA\n#define SystemParametersInfo SystemParametersInfoA\n#define GetWindowLong GetWindowLongA\n#define SetWindowLong SetWindowLongA\n#define GetWindowLongPtrA\tGetWindowLongA\n#define GetWindowLongPtr\tGetWindowLongPtrA\n#define SetWindowLongPtr\tSetWindowLongPtrA\n#define GetClassLong GetClassLongA\n#define GetClassLongPtr\tGetClassLongPtrA\n#define SetClassLongPtr\tSetClassLongPtrA\n#define SetClassLong SetClassLongA\n#define FindWindow FindWindowA\n#define FindWindowEx FindWindowExA\n#define GetClassName GetClassNameA\n#define SetWindowsHookEx SetWindowsHookExA\n#define SetWindowsHook SetWindowsHookA\n#define LoadBitmap LoadBitmapA\n#define LoadCursor LoadCursorA\n#define LoadCursorFromFile LoadCursorFromFileA\n#define SetProp SetPropA\n#define GetProp GetPropA\n#define RemoveProp RemovePropA\n#define EnumPropsEx EnumPropsExA\n#define EnumProps EnumPropsA\n#define SetWindowText SetWindowTextA\n#define GetWindowText GetWindowTextA\n#define GetWindowTextLength GetWindowTextLengthA\n#define MessageBox MessageBoxA\n#define MessageBoxEx MessageBoxExA\n#define MessageBoxIndirect MessageBoxIndirectA\n#define AddFontResource AddFontResourceA\n#define CopyMetaFile CopyMetaFileA\n#define CreateDC CreateDCA\n#define CreateFontIndirect CreateFontIndirectA\n#define CreateFont CreateFontA\n#define CreateIC CreateICA\n#define CreateMetaFile CreateMetaFileA\n#define CreateScalableFontResource CreateScalableFontResourceA\n#define DeviceCapabilities DeviceCapabilitiesA\n#define EnumFontFamiliesEx EnumFontFamiliesExA\n#define EnumFontFamilies EnumFontFamiliesA\n#define EnumFonts EnumFontsA\n#define GetCharWidth GetCharWidthA\n#define GetCharWidth32 GetCharWidth32A\n#define GetCharWidthFloat GetCharWidthFloatA\n#define GetCharABCWidths GetCharABCWidthsA\n#define GetCharABCWidthsFloat GetCharABCWidthsFloatA\n#define GetGlyphOutline GetGlyphOutlineA\n#define GetMetaFile GetMetaFileA\n#define GetOutlineTextMetrics GetOutlineTextMetricsA\n#define GetTextExtentPoint GetTextExtentPointA\n#define GetTextExtentPoint32 GetTextExtentPoint32A\n#define GetTextExtentExPoint GetTextExtentExPointA\n#define GetCharacterPlacement GetCharacterPlacementA\n#define ResetDC ResetDCA\n#define RemoveFontResource RemoveFontResourceA\n#define CopyEnhMetaFile CopyEnhMetaFileA\n#define CreateEnhMetaFile CreateEnhMetaFileA\n#define GetEnhMetaFile GetEnhMetaFileA\n#define GetEnhMetaFileDescription GetEnhMetaFileDescriptionA\n#define GetTextMetrics GetTextMetricsA\n#define StartDoc StartDocA\n#define GetObject GetObjectA\n#define TextOut TextOutA\n#define ExtTextOut ExtTextOutA\n#define PolyTextOut PolyTextOutA\n#define GetTextFace GetTextFaceA\n#define GetKerningPairs GetKerningPairsA\n#define GetLogColorSpace GetLogColorSpaceA\n#define CreateColorSpace CreateColorSpaceA\n#define GetICMProfile GetICMProfileA\n#define SetICMProfile SetICMProfileA\n#define UpdateICMRegKey UpdateICMRegKeyA\n#define EnumICMProfiles EnumICMProfilesA\n#define CreatePropertySheetPage CreatePropertySheetPageA\n#define PropertySheet PropertySheetA\n#define ImageList_LoadImage ImageList_LoadImageA\n#define CreateStatusWindow CreateStatusWindowA\n#define DrawStatusText DrawStatusTextA\n#define GetOpenFileName GetOpenFileNameA\n#define GetSaveFileName GetSaveFileNameA\n#define GetFileTitle GetFileTitleA\n#define ChooseColor ChooseColorA\n#define FindText FindTextA\n#define ReplaceText ReplaceTextA\n#define ChooseFont ChooseFontA\n#define PrintDlg PrintDlgA\n#define PageSetupDlg PageSetupDlgA\n#define DefWindowProc DefWindowProcA\n#define CallWindowProc CallWindowProcA\n#define RegisterClass RegisterClassA\n#define UnregisterClass UnregisterClassA\n#define GetClassInfo GetClassInfoA\n#define RegisterClassEx RegisterClassExA\n#define GetClassInfoEx GetClassInfoExA\n#define CreateWindowEx CreateWindowExA\n#define CreateWindow CreateWindowA\n#define CreateDialogParam CreateDialogParamA\n#define CreateDialogIndirectParam CreateDialogIndirectParamA\n#define CreateDialog CreateDialogA\n#define CreateDialogIndirect CreateDialogIndirectA\n#define DialogBoxParam DialogBoxParamA\n#define DialogBoxIndirectParam DialogBoxIndirectParamA\n#define DialogBox DialogBoxA\n#define DialogBoxIndirect DialogBoxIndirectA\n#define RegisterClipboardFormat RegisterClipboardFormatA\n#define SetDlgItemText SetDlgItemTextA\n#define GetDlgItemText GetDlgItemTextA\n#define SendDlgItemMessage SendDlgItemMessageA\n#define DefDlgProc DefDlgProcA\n#define CallMsgFilter CallMsgFilterA\n#define GetClipboardFormatName GetClipboardFormatNameA\n#define CharToOem CharToOemA\n#define OemToChar OemToCharA\n#define CharToOemBuff CharToOemBuffA\n#define OemToCharBuff OemToCharBuffA\n#define CharUpper CharUpperA\n#define CharUpperBuff CharUpperBuffA\n#define CharLower CharLowerA\n#define CharLowerBuff CharLowerBuffA\n#define CharNext CharNextA\n#define CharPrev CharPrevA\n#define IsCharAlpha IsCharAlphaA\n#define IsCharAlphaNumeric IsCharAlphaNumericA\n#define IsCharUpper IsCharUpperA\n#define IsCharLower IsCharLowerA\n#define GetKeyNameText GetKeyNameTextA\n#define VkKeyScan VkKeyScanA\n#define VkKeyScanEx VkKeyScanExA\n#define MapVirtualKey MapVirtualKeyA\n#define MapVirtualKeyEx MapVirtualKeyExA\n#define LoadAccelerators LoadAcceleratorsA\n#define CreateAcceleratorTable CreateAcceleratorTableA\n#define CopyAcceleratorTable CopyAcceleratorTableA\n#define TranslateAccelerator TranslateAcceleratorA\n#define LoadMenu LoadMenuA\n#define LoadMenuIndirect LoadMenuIndirectA\n#define ChangeMenu ChangeMenuA\n#define GetMenuString GetMenuStringA\n#define InsertMenu InsertMenuA\n#define AppendMenu AppendMenuA\n#define ModifyMenu ModifyMenuA\n#define InsertMenuItem InsertMenuItemA\n#define GetMenuItemInfo GetMenuItemInfoA\n#define SetMenuItemInfo SetMenuItemInfoA\n#define DrawText DrawTextA\n#define DrawTextEx DrawTextExA\n#define GrayString GrayStringA\n#define DrawState DrawStateA\n#define TabbedTextOut TabbedTextOutA\n#define GetTabbedTextExtent GetTabbedTextExtentA\n#define GetVersionEx GetVersionExA\n#define wvsprintf wvsprintfA\n#define wsprintf wsprintfA\n#define LoadKeyboardLayout LoadKeyboardLayoutA\n#define GetKeyboardLayoutName GetKeyboardLayoutNameA\n#define CreateDesktop CreateDesktopA\n#define OpenDesktop OpenDesktopA\n#define EnumDesktops EnumDesktopsA\n#define CreateWindowStation CreateWindowStationA\n#define OpenWindowStation OpenWindowStationA\n#define EnumWindowStations EnumWindowStationsA\n#define IsBadStringPtr IsBadStringPtrA\n#define LookupAccountSid LookupAccountSidA\n#define LookupAccountName LookupAccountNameA\n#define LookupPrivilegeValue LookupPrivilegeValueA\n#define LookupPrivilegeName LookupPrivilegeNameA\n#define LookupPrivilegeDisplayName LookupPrivilegeDisplayNameA\n#define BuildCommDCB BuildCommDCBA\n#define BuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsA\n#define CommConfigDialog CommConfigDialogA\n#define GetDefaultCommConfig GetDefaultCommConfigA\n#define SetDefaultCommConfig SetDefaultCommConfigA\n#define GetComputerName GetComputerNameA\n#define SetComputerName SetComputerNameA\n#define GetUserName GetUserNameA\n#define CreateMailslot CreateMailslotA\n#define FormatMessage FormatMessageA\n#define GetEnvironmentStrings GetEnvironmentStringsA\n#define FreeEnvironmentStrings FreeEnvironmentStringsA\n#define lstrcmp lstrcmpA\n#define lstrcmpi lstrcmpiA\n#define lstrcpyn lstrcpynA\n#define lstrcpy lstrcpyA\n#define lstrcat lstrcatA\n#define lstrlen lstrlenA\n#define GetBinaryType GetBinaryTypeA\n#define GetShortPathName GetShortPathNameA\n#define SetFileSecurity SetFileSecurityA\n#define GetFileSecurity GetFileSecurityA\n#define FindFirstChangeNotification FindFirstChangeNotificationA\n#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmA\n#define ObjectOpenAuditAlarm ObjectOpenAuditAlarmA\n#define ObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmA\n#define ObjectCloseAuditAlarm ObjectCloseAuditAlarmA\n#define PrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmA\n#define OpenEventLog OpenEventLogA\n#define RegisterEventSource RegisterEventSourceA\n#define OpenBackupEventLog OpenBackupEventLogA\n#define ReadEventLog ReadEventLogA\n#define ReportEvent ReportEventA\n#define CreateProcess CreateProcessA\n#define FatalAppExit FatalAppExitA\n#define GetStartupInfo GetStartupInfoA\n#define GetCommandLine GetCommandLineA\n#define GetEnvironmentVariable GetEnvironmentVariableA\n#define SetEnvironmentVariable SetEnvironmentVariableA\n#define ExpandEnvironmentStrings ExpandEnvironmentStringsA\n#define OutputDebugString OutputDebugStringA\n#define FindResource FindResourceA\n#define FindResourceEx FindResourceExA\n#define EnumResourceTypes EnumResourceTypesA\n#define EnumResourceNames EnumResourceNamesA\n#define EnumResourceLanguages EnumResourceLanguagesA\n#define BeginUpdateResource BeginUpdateResourceA\n#define UpdateResource UpdateResourceA\n#define EndUpdateResource EndUpdateResourceA\n#define GlobalAddAtom GlobalAddAtomA\n#define GlobalFindAtom GlobalFindAtomA\n#define GlobalGetAtomName GlobalGetAtomNameA\n#define AddAtom AddAtomA\n#define FindAtom FindAtomA\n#define GetProfileInt GetProfileIntA\n#define GetAtomName GetAtomNameA\n#define GetProfileString GetProfileStringA\n#define WriteProfileString WriteProfileStringA\n#define GetProfileSection GetProfileSectionA\n#define WriteProfileSection WriteProfileSectionA\n#define GetPrivateProfileInt GetPrivateProfileIntA\n#define GetPrivateProfileSectionNames GetPrivateProfileSectionNamesA\n#define GetPrivateProfileString GetPrivateProfileStringA\n#define WritePrivateProfileString WritePrivateProfileStringA\n#define WritePrivateProfileStruct WritePrivateProfileStructA\n#define GetPrivateProfileSection GetPrivateProfileSectionA\n#define WritePrivateProfileSection WritePrivateProfileSectionA\n#define GetDriveType GetDriveTypeA\n#define GetSystemDirectory GetSystemDirectoryA\n#define GetTempPath GetTempPathA\n#define GetTempFileName GetTempFileNameA\n#define GetWindowsDirectory GetWindowsDirectoryA\n#define SetCurrentDirectory SetCurrentDirectoryA\n#define GetCurrentDirectory GetCurrentDirectoryA\n#define GetDiskFreeSpace GetDiskFreeSpaceA\n#define CreateDirectory CreateDirectoryA\n#define CreateDirectoryEx CreateDirectoryExA\n#define RemoveDirectory RemoveDirectoryA\n#define GetFullPathName GetFullPathNameA\n#define DefineDosDevice DefineDosDeviceA\n#define QueryDosDevice QueryDosDeviceA\n#define CreateFile CreateFileA\n#define SetFileAttributes SetFileAttributesA\n#define GetFileAttributes GetFileAttributesA\n#define GetCompressedFileSize GetCompressedFileSizeA\n#define DeleteFile DeleteFileA\n#define FindFirstFile FindFirstFileA\n#define FindFirstFileEx FindFirstFileExA\n#define FindNextFile FindNextFileA\n#define SearchPath SearchPathA\n#define CopyFile CopyFileA\n#define CopyFileEx CopyFileExA\n#define CreateHardLink CreateHardLinkA\n#define MoveFile MoveFileA\n#define MoveFileEx MoveFileExA\n#define MoveFileWithProgress MoveFileWithProgressA\n#define CreateNamedPipe CreateNamedPipeA\n#define GetNamedPipeHandleState GetNamedPipeHandleStateA\n#define CallNamedPipe CallNamedPipeA\n#define WaitNamedPipe WaitNamedPipeA\n#define SetVolumeLabel SetVolumeLabelA\n#define GetVolumeInformation GetVolumeInformationA\n#define ClearEventLog ClearEventLogA\n#define BackupEventLog BackupEventLogA\n#define CreateMutex CreateMutexA\n#define OpenMutex OpenMutexA\n#define CreateEvent CreateEventA\n#define OpenEvent OpenEventA\n#define CreateSemaphore CreateSemaphoreA\n#define OpenSemaphore OpenSemaphoreA\n#define CreateFileMapping CreateFileMappingA\n#define OpenFileMapping OpenFileMappingA\n#define GetLogicalDriveStrings GetLogicalDriveStringsA\n#define LoadLibrary LoadLibraryA\n#define LoadLibraryEx LoadLibraryExA\n#define GetModuleFileName GetModuleFileNameA\n#define GetModuleHandle GetModuleHandleA\n#define GetUserObjectInformation GetUserObjectInformationA\n#define SetUserObjectInformation SetUserObjectInformationA\n#define RegisterWindowMessage RegisterWindowMessageA\n#define GetMessage GetMessageA\n#define DispatchMessage DispatchMessageA\n#define PeekMessage PeekMessageA\n#define SendMessage SendMessageA\n#define SendMessageTimeout SendMessageTimeoutA\n#define SendNotifyMessage SendNotifyMessageA\n#define SendMessageCallback SendMessageCallbackA\n#define PostMessage PostMessageA\n#define PostThreadMessage PostThreadMessageA\n#define VerFindFile VerFindFileA\n#define VerInstallFile VerInstallFileA\n#define GetFileVersionInfoSize GetFileVersionInfoSizeA\n#define GetFileVersionInfo GetFileVersionInfoA\n#define VerLanguageName VerLanguageNameA\n#define VerQueryValue VerQueryValueA\n#define CompareString CompareStringA\n#define LCMapString LCMapStringA\n#define GetLocaleInfo GetLocaleInfoA\n#define SetLocaleInfo SetLocaleInfoA\n#define GetTimeFormat GetTimeFormatA\n#define GetDateFormat GetDateFormatA\n#define GetNumberFormat GetNumberFormatA\n#define GetCurrencyFormat GetCurrencyFormatA\n#define EnumCalendarInfo EnumCalendarInfoA\n#define EnumTimeFormats EnumTimeFormatsA\n#define FoldString FoldStringA\n#define EnumSystemCodePages EnumSystemCodePagesA\n#define EnumSystemLocales EnumSystemLocalesA\n#define GetStringTypeEx GetStringTypeExA\n#define EnumDateFormats EnumDateFormatsA\n#define GetConsoleTitle GetConsoleTitleA\n#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferA\n#define SetConsoleTitle SetConsoleTitleA\n#define ReadConsole ReadConsoleA\n#define WriteConsole WriteConsoleA\n#define PeekConsoleInput PeekConsoleInputA\n#define ReadConsoleInput ReadConsoleInputA\n#define WriteConsoleInput WriteConsoleInputA\n#define ReadConsoleOutput ReadConsoleOutputA\n#define WriteConsoleOutput WriteConsoleOutputA\n#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterA\n#define WriteConsoleOutputCharacter WriteConsoleOutputCharacterA\n#define FillConsoleOutputCharacter FillConsoleOutputCharacterA\n#define MultinetGetConnectionPerformance MultinetGetConnectionPerformanceA\n#define WNetGetLastError WNetGetLastErrorA\n#define WNetGetProviderName WNetGetProviderNameA\n#define WNetGetNetworkInformation WNetGetNetworkInformationA\n#define WNetConnectionDialog1 WNetConnectionDialog1A\n#define WNetDisconnectDialog1 WNetDisconnectDialog1A\n#define WNetOpenEnum WNetOpenEnumA\n#define WNetEnumResource WNetEnumResourceA\n#define WNetGetUniversalName WNetGetUniversalNameA\n#define WNetGetUser WNetGetUserA\n#define WNetAddConnection WNetAddConnectionA\n#define WNetAddConnection2 WNetAddConnection2A\n#define WNetAddConnection3 WNetAddConnection3A\n#define WNetCancelConnection WNetCancelConnectionA\n#define WNetCancelConnection2 WNetCancelConnection2A\n#define WNetGetConnection WNetGetConnectionA\n#define WNetUseConnection WNetUseConnectionA\n#define WNetSetConnection WNetSetConnectionA\n#define OpenService OpenServiceA\n#define QueryServiceConfig QueryServiceConfigA\n#define QueryServiceLockStatus QueryServiceLockStatusA\n#define RegisterServiceCtrlHandler RegisterServiceCtrlHandlerA\n#define StartServiceCtrlDispatcher StartServiceCtrlDispatcherA\n#define StartService StartServiceA\n#define ChangeServiceConfig ChangeServiceConfigA\n#define CreateService CreateServiceA\n#define EnumDependentServices EnumDependentServicesA\n#define EnumServicesStatus EnumServicesStatusA\n#define GetServiceKeyName GetServiceKeyNameA\n#define GetServiceDisplayName GetServiceDisplayNameA\n#define OpenSCManager OpenSCManagerA\n#define CommDlg_OpenSave_GetSpec CommDlg_OpenSave_GetSpecA\n#define CommDlg_OpenSave_GetFilePath CommDlg_OpenSave_GetFilePathA\n#define CommDlg_OpenSave_GetFolderPath CommDlg_OpenSave_GetFolderPathA\n#define GetPrivateProfileStruct GetPrivateProfileStructA\n#define LVCOLUMN LVCOLUMNA\n#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointA\n#define GetVolumePathName GetVolumePathNameA\n#define GetVolumePathNamesForVolumeName GetVolumePathNamesForVolumeNameA\n#define DeleteVolumeMountPoint DeleteVolumeMountPointA\n#define SetVolumeMountPoint SetVolumeMountPointA\n#define FindNextVolumeMountPoint FindNextVolumeMountPointA\n#define FindFirstVolumeMountPoint FindFirstVolumeMountPointA\n#define FindNextVolume FindNextVolumeA\n#define FindFirstVolume FindFirstVolumeA\n#endif\nlong get_osfhandle(int);\n#define _get_osfhandle get_osfhandle\nBOOL AbnormalTermination(VOID);\nint AbortDoc(HDC);\nBOOL AbortPrinter(HANDLE);\nBOOL CALLBACK AbortProc(HDC,int);\nLONG InterlockedIncrement(LPLONG);\nLONG WINAPI InterlockedExchangeAdd ( LONG volatile *Addend, LONG Value );\nLONG WINAPI InterlockedCompareExchange ( LONG volatile *Destination, LONG Exchange, LONG Comperand );\nLONG InterlockedDecrement(LPLONG);\nLONG InterlockedExchange(LPLONG,LONG);\nBOOL FreeResource(HGLOBAL);\nLPVOID LockResource(HGLOBAL);\nint WinMain(HINSTANCE,HINSTANCE,LPSTR,int);\nBOOL FreeLibrary(HINSTANCE);\nVOID FreeLibraryAndExitThread(HMODULE,DWORD);\nBOOL DisableThreadLibraryCalls(HMODULE);\nFARPROC GetProcAddress(HINSTANCE,LPCSTR);\nDWORD GetVersion(VOID);\nHGLOBAL GlobalAlloc(UINT,DWORD);\nHGLOBAL GlobalDiscard(HGLOBAL);\nHGLOBAL GlobalReAlloc(HGLOBAL,DWORD,UINT);\nDWORD GlobalSize(HGLOBAL);\nUINT GlobalFlags(HGLOBAL);\nLPVOID GlobalLock(HGLOBAL);\nHGLOBAL GlobalHandle(LPCVOID);\nBOOL GlobalUnlock(HGLOBAL);\nHGLOBAL GlobalFree(HGLOBAL);\nUINT GlobalCompact(DWORD);\nVOID GlobalFix(HGLOBAL);\nVOID GlobalUnfix(HGLOBAL);\nLPVOID GlobalWire(HGLOBAL);\nBOOL GlobalUnWire(HGLOBAL);\nVOID GlobalMemoryStatus(LPMEMORYSTATUS);\nBOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX);\nHLOCAL LocalAlloc(UINT,UINT);\nHLOCAL LocalDiscard(HLOCAL);\nHLOCAL LocalReAlloc(HLOCAL,UINT,UINT);\nLPVOID LocalLock(HLOCAL);\nHLOCAL LocalHandle(LPCVOID);\nBOOL LocalUnlock(HLOCAL);\nUINT LocalSize(HLOCAL);\nUINT LocalFlags(HLOCAL);\nHLOCAL LocalFree(HLOCAL);\nUINT LocalShrink(HLOCAL,UINT);\nUINT LocalCompact(UINT);\nBOOL FlushInstructionCache(HANDLE,LPCVOID,DWORD);\nLPVOID VirtualAlloc(LPVOID,DWORD,DWORD,DWORD);\nLPVOID WINAPI VirtualAllocEx(HANDLE,LPVOID,unsigned long,DWORD,DWORD);\nBOOL VirtualFree(LPVOID,DWORD,DWORD);\nBOOL WINAPI VirtualFreeEx(HANDLE,LPVOID,DWORD,DWORD);\nBOOL VirtualProtect(LPVOID,DWORD,DWORD,PDWORD);\nDWORD VirtualQuery(LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);\nBOOL VirtualProtectEx(HANDLE,LPVOID,DWORD,DWORD,PDWORD);\nDWORD VirtualQueryEx(HANDLE,LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);\nHANDLE HeapCreate(DWORD,DWORD,DWORD);\nBOOL HeapDestroy(HANDLE);\nLPVOID HeapAlloc(HANDLE,DWORD,DWORD);\nLPVOID HeapReAlloc(HANDLE,DWORD,LPVOID,DWORD);\nBOOL HeapFree(HANDLE,DWORD,LPVOID);\nDWORD HeapSize(HANDLE,DWORD,LPCVOID);\nBOOL HeapValidate(HANDLE,DWORD,LPCVOID);\nUINT HeapCompact(HANDLE,DWORD);\nHANDLE GetProcessHeap(VOID);\nDWORD WINAPI GetProcessIdOfThread(HANDLE);\nDWORD WINAPI GetProcessId(HANDLE);\nDWORD WINAPI GetCurrentProcessorNumber(void);\nBOOL WINAPI GetProcessHandleCount(HANDLE,PDWORD);\nBOOL WINAPI GetProcessIoCounters(HANDLE,PIO_COUNTERS);\nBOOL WINAPI GetProcessWorkingSetSize(HANDLE,PSIZE_T,PSIZE_T);\nBOOL WINAPI GetProcessWorkingSetSizeEx(HANDLE,PSIZE_T,PSIZE_T,PDWORD);\nBOOL WINAPI SetProcessWorkingSetSize(HANDLE,SIZE_T,SIZE_T);\nBOOL WINAPI SetProcessWorkingSetSizeEx(HANDLE,SIZE_T,SIZE_T,DWORD);\nDWORD GetProcessHeaps(DWORD,PHANDLE);\nDWORD GetProcessVersion(DWORD);\nBOOL WINAPI SetEnvironmentStringsA(LPSTR);\nBOOL WINAPI SetEnvironmentStringsW(LPWSTR);\nBOOL HeapLock(HANDLE);\nBOOL HeapUnlock(HANDLE);\nBOOL HeapWalk(HANDLE,LPPROCESS_HEAP_ENTRY);\nBOOL GetProcessAffinityMask(HANDLE,LPDWORD,LPDWORD);\nBOOL GetProcessTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);\nBOOL GetProcessWorkingSetSize(HANDLE,LPDWORD,LPDWORD);\nBOOL SetProcessWorkingSetSize(HANDLE,DWORD,DWORD);\nBOOL WINAPI SetProcessAffinityMask(HANDLE,DWORD);\nBOOL WINAPI SetProcessPriorityBoost(HANDLE,BOOL);\nBOOL WINAPI GetProcessPriorityBoost(HANDLE,BOOL *);\nBOOL WINAPI RequestWakeupLatency(LATENCY_TIME);\nBOOL WINAPI IsSystemResumeAutomatic(VOID);\nHANDLE WINAPI OpenThread(DWORD,BOOL,DWORD);\nHANDLE OpenProcess(DWORD,BOOL,DWORD);\nHANDLE GetCurrentProcess(VOID);\nDWORD GetCurrentProcessId(VOID);\nBOOL ProcessIdToSessionId(DWORD DWORD);\nVOID ExitProcess(UINT);\nBOOL TerminateProcess(HANDLE,UINT);\nBOOL GetExitCodeProcess(HANDLE,LPDWORD);\nVOID FatalExit(int);\nLPTSTR GetEnvironmentStrings(VOID);\nVOID RaiseException(DWORD,DWORD,DWORD,CONST DWORD *);\nLONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *);\nLPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER);\nHANDLE CreateThread(LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);\nHANDLE CreateRemoteThread(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);\nHANDLE GetCurrentThread(VOID);\nDWORD GetCurrentThreadId(VOID);\nDWORD SetThreadAffinityMask(HANDLE,DWORD);\nDWORD WINAPI SetThreadIdealProcessor(HANDLE,DWORD);\nBOOL SetThreadPriority(HANDLE,int);\nint GetThreadPriority(HANDLE);\nBOOL WINAPI SetThreadPriorityBoost(HANDLE,BOOL);\nBOOL WINAPI GetThreadPriorityBoost(HANDLE,BOOL *);\nBOOL GetThreadTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);\nBOOL WINAPI GetGUIThreadInfo(DWORD,PGUITHREADINFO pgui);\nVOID ExitThread(DWORD);\nBOOL TerminateThread(HANDLE,DWORD);\nEXECUTION_STATE WINAPI SetThreadExecutionState(EXECUTION_STATE);\nBOOL GetExitCodeThread(HANDLE,LPDWORD);\nBOOL GetThreadSelectorEntry(HANDLE,DWORD,LPLDT_ENTRY);\nDWORD GetLastError(VOID);\nVOID WINAPI RestoreLastError(DWORD);\nVOID SetLastError(DWORD);\nBOOL GetOverlappedResult(HANDLE,LPOVERLAPPED,LPDWORD,BOOL);\nHANDLE CreateIoCompletionPort(HANDLE,HANDLE,DWORD,DWORD);\nBOOL GetQueuedCompletionStatus(HANDLE,LPDWORD,LPDWORD,LPOVERLAPPED *,DWORD);\nBOOL WINAPI PostQueuedCompletionStatus(HANDLE,DWORD,long long int *,LPOVERLAPPED);\nDWORD WINAPI QueueUserAPC(PAPCFUNC,HANDLE,long long int *);\nBOOL WINAPI IsDebuggerPresent(void);\nUINT SetErrorMode(UINT);\nBOOL ReadProcessMemory(HANDLE,LPCVOID,LPVOID,DWORD,LPDWORD);\nBOOL WriteProcessMemory(HANDLE,LPVOID,LPVOID,DWORD,LPDWORD);\nBOOL GetThreadContext(HANDLE,LPCONTEXT);\nBOOL SetThreadContext(HANDLE,CONST CONTEXT *);\nDWORD SuspendThread(HANDLE);\nDWORD ResumeThread(HANDLE);\nVOID DebugBreak(VOID);\nBOOL WaitForDebugEvent(LPDEBUG_EVENT,DWORD);\nBOOL ContinueDebugEvent(DWORD,DWORD,DWORD);\nBOOL DebugActiveProcess(DWORD);\nBOOL WINAPI DebugActiveProcessStop(DWORD);\nBOOL WINAPI DebugSetProcessKillOnExit(BOOL);\nBOOL WINAPI DebugBreakProcess(HANDLE);\nBOOL WINAPI CheckRemoteDebuggerPresent(HANDLE,PBOOL);\nVOID InitializeCriticalSection(LPCRITICAL_SECTION);\nVOID EnterCriticalSection(LPCRITICAL_SECTION);\nVOID LeaveCriticalSection(LPCRITICAL_SECTION);\nVOID DeleteCriticalSection(LPCRITICAL_SECTION);\nBOOL WINAPI InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION,DWORD);\nWINBASEAPI DWORD WINAPI SetCriticalSectionSpinCount(LPCRITICAL_SECTION,DWORD);\nWINBASEAPI BOOL WINAPI TryEnterCriticalSection(LPCRITICAL_SECTION);\nBOOL SetEvent(HANDLE);\nBOOL ResetEvent(HANDLE);\nBOOL PulseEvent(HANDLE);\nBOOL ReleaseSemaphore(HANDLE,LONG,LPLONG);\nBOOL ReleaseMutex(HANDLE);\nDWORD WaitForSingleObject(HANDLE,DWORD);\nDWORD WaitForMultipleObjects(DWORD,CONST HANDLE *,BOOL,DWORD);\nVOID Sleep(DWORD);\nHGLOBAL LoadResource(HINSTANCE,HRSRC);\nDWORD SizeofResource(HINSTANCE,HRSRC);\nATOM GlobalDeleteAtom(ATOM);\nBOOL InitAtomTable(DWORD);\nATOM DeleteAtom(ATOM);\nUINT SetHandleCount(UINT);\nDWORD GetLogicalDrives(VOID);\nBOOL LockFile( HANDLE,DWORD,DWORD,DWORD,DWORD);\nBOOL UnlockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);\nBOOL LockFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPOVERLAPPED);\nBOOL UnlockFileEx(HANDLE,DWORD,DWORD,DWORD,LPOVERLAPPED);\nBOOL GetFileInformationByHandle(HANDLE,LPBY_HANDLE_FILE_INFORMATION);\nDWORD GetFileType(HANDLE);\nDWORD GetFileSize(HANDLE,LPDWORD);\nBOOL WINAPI GetFileSizeEx(HANDLE,PLARGE_INTEGER);\nHANDLE GetStdHandle(DWORD);\nBOOL SetStdHandle(DWORD,HANDLE);\nBOOL WriteFile(HANDLE,LPCVOID,DWORD,LPDWORD,LPOVERLAPPED);\nBOOL ReadFile(HANDLE,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);\nBOOL WINAPI ReadFileScatter(HANDLE h,FILE_SEGMENT_ELEMENT aSegmentArray[],DWORD,LPDWORD,LPOVERLAPPED);\nBOOL WINAPI WriteFileGather(HANDLE hFile,FILE_SEGMENT_ELEMENT aSegmentArray[],DWORD n,LPDWORD l,LPOVERLAPPED);\nBOOL FlushFileBuffers(HANDLE);\nBOOL DeviceIoControl(HANDLE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);\nBOOL WINAPI RequestDeviceWakeup(HANDLE);\nBOOL WINAPI CancelDeviceWakeupRequest(HANDLE);\nBOOL WINAPI GetDevicePowerState(HANDLE,BOOL *);\nBOOL WINAPI SetMessageWaitingIndicator(HANDLE,ULONG);\nBOOL SetEndOfFile(HANDLE);\nDWORD SetFilePointer(HANDLE,LONG,PLONG,DWORD);\nBOOL WINAPI SetFilePointerEx(HANDLE,LARGE_INTEGER,PLARGE_INTEGER,DWORD);\nBOOL WINAPI SetFileValidData(HANDLE,LONGLONG);\nBOOL WINAPI SetFileShortNameA(HANDLE,LPCSTR);\nBOOL WINAPI SetFileShortNameW(HANDLE,LPCWSTR);\nBOOL FindClose(HANDLE);\nBOOL GetFileTime(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME);\nBOOL SetFileTime(HANDLE,CONST FILETIME *,CONST FILETIME *,CONST FILETIME *);\nBOOL CloseHandle(HANDLE);\nBOOL DuplicateHandle(HANDLE,HANDLE,HANDLE,LPHANDLE,DWORD,BOOL,DWORD);\nBOOL GetHandleInformation(HANDLE,LPDWORD);\nBOOL SetHandleInformation(HANDLE,DWORD,DWORD);\nDWORD LoadModule(LPCSTR,LPVOID);\nUINT WinExec(LPCSTR,UINT);\nBOOL ClearCommBreak(HANDLE);\nBOOL ClearCommError(HANDLE,LPDWORD,LPCOMSTAT);\nBOOL SetupComm(HANDLE,DWORD,DWORD);\nBOOL EscapeCommFunction(HANDLE,DWORD);\nBOOL GetCommConfig(HANDLE,LPCOMMCONFIG,LPDWORD);\nBOOL GetCommMask(HANDLE,LPDWORD);\nBOOL GetCommProperties(HANDLE,LPCOMMPROP);\nBOOL GetCommModemStatus(HANDLE,LPDWORD);\nBOOL GetCommState(HANDLE,LPDCB);\nBOOL GetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);\nBOOL PurgeComm(HANDLE,DWORD);\nBOOL SetCommBreak(HANDLE);\nBOOL SetCommConfig(HANDLE,LPCOMMCONFIG,DWORD);\nBOOL SetCommMask(HANDLE,DWORD);\nBOOL SetCommState(HANDLE,LPDCB);\nBOOL SetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);\nBOOL TransmitCommChar(HANDLE,char);\nBOOL WaitCommEvent(HANDLE,LPDWORD,LPOVERLAPPED);\nDWORD SetTapePosition(HANDLE,DWORD,DWORD,DWORD,DWORD,BOOL);\nDWORD GetTapePosition(HANDLE,DWORD,LPDWORD,LPDWORD,LPDWORD);\nDWORD PrepareTape(HANDLE,DWORD,BOOL);\nDWORD EraseTape(HANDLE,DWORD,BOOL);\nDWORD CreateTapePartition(HANDLE,DWORD,DWORD,DWORD);\nDWORD WriteTapemark(HANDLE,DWORD,DWORD,BOOL);\nDWORD GetTapeStatus(HANDLE);\nDWORD GetTapeParameters(HANDLE,DWORD,LPDWORD,LPVOID);\nDWORD SetTapeParameters( HANDLE,DWORD,LPVOID);\nBOOL Beep(DWORD,DWORD);\nVOID OpenSound(VOID);\nVOID CloseSound(VOID);\nVOID StartSound(VOID);\nVOID StopSound(VOID);\nDWORD WaitSoundState(DWORD);\nDWORD SyncAllVoices(VOID);\nDWORD CountVoiceNotes(DWORD nVoice);\nLPDWORD GetThresholdEvent(VOID);\nDWORD GetThresholdStatus(VOID);\nDWORD SetSoundNoise(DWORD,DWORD);\nDWORD SetVoiceAccent(DWORD,DWORD,DWORD,DWORD,DWORD);\nDWORD SetVoiceEnvelope(DWORD,DWORD,DWORD);\nDWORD SetVoiceNote(DWORD,DWORD,DWORD,DWORD);\nDWORD SetVoiceQueueSize(DWORD,DWORD);\nDWORD SetVoiceSound(DWORD,DWORD,DWORD);\nDWORD SetVoiceThreshold(DWORD,DWORD);\nint MulDiv(int,int,int);\nVOID GetSystemTime(LPSYSTEMTIME);\nVOID GetSystemTimeAsFileTime(LPFILETIME);\nBOOL SetSystemTime(CONST SYSTEMTIME *);\nBOOL SetSystemPowerState(BOOL,BOOL);\nBOOL WINAPI GetSystemPowerStatus(LPSYSTEM_POWER_STATUS);\nVOID GetLocalTime(LPSYSTEMTIME);\nBOOL SetLocalTime(CONST SYSTEMTIME *);\nVOID GetSystemInfo(LPSYSTEM_INFO);\nBOOL SystemTimeToTzSpecificLocalTime(LPTIME_ZONE_INFORMATION,LPSYSTEMTIME,LPSYSTEMTIME);\nDWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION);\nBOOL SetTimeZoneInformation(CONST TIME_ZONE_INFORMATION *);\nBOOL SystemTimeToFileTime(CONST SYSTEMTIME *,LPFILETIME);\nBOOL FileTimeToLocalFileTime(CONST FILETIME *,LPFILETIME);\nBOOL LocalFileTimeToFileTime(CONST FILETIME *,LPFILETIME);\nBOOL FileTimeToSystemTime(CONST FILETIME *,LPSYSTEMTIME);\nLONG CompareFileTime(CONST FILETIME *,CONST FILETIME *);\nBOOL FileTimeToDosDateTime(CONST FILETIME *,LPWORD,LPWORD);\nBOOL DosDateTimeToFileTime(WORD,WORD,LPFILETIME);\nDWORD GetTickCount(VOID);\nBOOL SetSystemTimeAdjustment(DWORD,BOOL);\nBOOL GetSystemTimeAdjustment(PDWORD,PDWORD,PWINBOOL);\nBOOL CreatePipe(PHANDLE,PHANDLE,LPSECURITY_ATTRIBUTES,DWORD);\nBOOL ConnectNamedPipe(HANDLE,LPOVERLAPPED);\nBOOL DisconnectNamedPipe(HANDLE);\nBOOL SetNamedPipeHandleState(HANDLE,LPDWORD,LPDWORD,LPDWORD);\nBOOL GetNamedPipeInfo(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD);\nBOOL PeekNamedPipe(HANDLE,LPVOID,DWORD,LPDWORD,LPDWORD,LPDWORD);\nBOOL TransactNamedPipe(HANDLE,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);\nBOOL GetMailslotInfo(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD);\nBOOL SetMailslotInfo(HANDLE,DWORD);\nLPVOID MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);\nBOOL FlushViewOfFile(LPCVOID,DWORD);\nBOOL UnmapViewOfFile(LPVOID);\nHFILE OpenFile(LPCSTR,LPOFSTRUCT,UINT);\nHFILE _lopen( LPCSTR,int);\nHFILE _lcreat(LPCSTR,int);\nUINT _lread(HFILE,LPVOID,UINT);\nUINT _lwrite(HFILE,LPCSTR,UINT);\nlong _hread(HFILE,LPVOID,long);\nlong _hwrite(HFILE,LPCSTR,long);\nHFILE _lclose(HFILE);\nLONG _llseek(HFILE,LONG,int);\nBOOL IsTextUnicode(CONST LPVOID,int,LPINT);\nWINBASEAPI DWORD WINAPI FlsAlloc(PFLS_CALLBACK_FUNCTION);\nWINBASEAPI PVOID WINAPI FlsGetValue(DWORD);\nWINBASEAPI BOOL WINAPI FlsSetValue(DWORD,PVOID);\nWINBASEAPI BOOL WINAPI FlsFree(DWORD);\nDWORD TlsAlloc(VOID);\nLPVOID TlsGetValue(DWORD);\nBOOL TlsSetValue(DWORD,LPVOID);\nBOOL TlsFree(DWORD);\nDWORD SleepEx(DWORD,BOOL);\nDWORD WaitForSingleObjectEx(HANDLE,DWORD,BOOL);\nDWORD WaitForMultipleObjectsEx(DWORD,CONST HANDLE *,BOOL,DWORD,BOOL);\nBOOL ReadFileEx(HANDLE,LPVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);\nBOOL WriteFileEx( HANDLE,LPCVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);\nBOOL BackupRead(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID *);\nBOOL BackupSeek(HANDLE,DWORD,DWORD,LPDWORD,LPDWORD,LPVOID *);\nBOOL BackupWrite(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID *);\nBOOL SetProcessShutdownParameters(DWORD,DWORD);\nBOOL GetProcessShutdownParameters(LPDWORD,LPDWORD);\nVOID SetFileApisToOEM(VOID);\nVOID SetFileApisToANSI(VOID);\nBOOL AreFileApisANSI(VOID);\nBOOL CloseEventLog(HANDLE);\nBOOL DeregisterEventSource(HANDLE);\nBOOL NotifyChangeEventLog (HANDLE,HANDLE);\nBOOL GetNumberOfEventLogRecords(HANDLE,PDWORD);\nBOOL GetOldestEventLogRecord(HANDLE,PDWORD);\nBOOL DuplicateToken(HANDLE,SECURITY_IMPERSONATION_LEVEL,PHANDLE);\nBOOL WINAPI DuplicateTokenEx(HANDLE,DWORD,LPSECURITY_ATTRIBUTES,SECURITY_IMPERSONATION_LEVEL,TOKEN_TYPE,PHANDLE);\nBOOL APIENTRY CreateRestrictedToken(HANDLE,DWORD,DWORD,PSID_AND_ATTRIBUTES,DWORD,PLUID_AND_ATTRIBUTES,DWORD,PSID_AND_ATTRIBUTES,PHANDLE);\nBOOL GetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);\nBOOL WINAPI IsProcessRestricted(void);\nBOOL ImpersonateNamedPipeClient(HANDLE);\nBOOL WINAPI ImpersonateLoggedOnUser(HANDLE);\nBOOL WINAPI LogonUserA(LPSTR,LPSTR,LPSTR,DWORD,DWORD,PHANDLE);\nBOOL WINAPI LogonUserW(LPWSTR,LPWSTR,LPWSTR,DWORD,DWORD,PHANDLE);\nBOOL WINAPI LogonUserExA (LPCSTR,LPCSTR,LPCSTR,DWORD,DWORD,PHANDLE,PSID *,PVOID *,LPDWORD,PQUOTA_LIMITS);\nBOOL WINAPI LogonUserExW (LPCWSTR,LPCWSTR,LPCWSTR,DWORD,DWORD,PHANDLE,PSID *,PVOID *,LPDWORD,PQUOTA_LIMITS);\n#ifdef UNICODE\n#define SetFileShortName SetFileShortNameW\n#define SetEnvironmentStrings SetEnvironmentStringsW\n#define LogonUserEx LogonUserExW\n#define LogonUser LogonUserW\n#define GetFileAttributesEx GetFileAttributesExW\n#else\n#define SetFileShortName SetFileShortNameA\n#define SetEnvironmentStrings SetEnvironmentStringsW\n#define LogonUser\tLogonUserA\n#define GetFileAttributesEx GetFileAttributesExA\n#define LogonUserEx LogonUserExA\n#endif\nBOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL);\nBOOL RevertToSelf(VOID);\nBOOL SetThreadToken (PHANDLE,HANDLE);\nBOOL AccessCheck(PSECURITY_DESCRIPTOR,HANDLE,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPBOOL);\nBOOL OpenProcessToken(HANDLE,DWORD,PHANDLE);\nBOOL OpenThreadToken(HANDLE,DWORD,BOOL,PHANDLE);\nBOOL GetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,LPVOID,DWORD,PDWORD);\nBOOL SetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,LPVOID,DWORD);\nBOOL AdjustTokenPrivileges(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);\nBOOL AdjustTokenGroups (HANDLE,BOOL,PTOKEN_GROUPS,DWORD,PTOKEN_GROUPS,PDWORD);\nBOOL PrivilegeCheck (HANDLE,PPRIVILEGE_SET,LPBOOL);\nBOOL IsValidSid (PSID);\nBOOL EqualSid(PSID,PSID);\nBOOL EqualPrefixSid (PSID,PSID);\nDWORD GetSidLengthRequired(UCHAR);\nBOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY,BYTE,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,PSID *);\nPVOID FreeSid(PSID);\nBOOL InitializeSid (PSID,PSID_IDENTIFIER_AUTHORITY,BYTE);\nPSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID);\nPDWORD GetSidSubAuthority (PSID,DWORD);\nPUCHAR GetSidSubAuthorityCount (PSID);\nDWORD GetLengthSid (PSID);\nBOOL CopySid(DWORD,PSID,PSID);\nBOOL AreAllAccessesGranted (DWORD,DWORD);\nBOOL AreAnyAccessesGranted (DWORD,DWORD);\nVOID MapGenericMask(PDWORD,PGENERIC_MAPPING);\nBOOL IsValidAcl(PACL);\nBOOL InitializeAcl(PACL,DWORD,DWORD);\nBOOL GetAclInformation(PACL,LPVOID,DWORD,ACL_INFORMATION_CLASS);\nBOOL SetAclInformation (PACL,LPVOID,DWORD,ACL_INFORMATION_CLASS);\nBOOL AddAce(PACL,DWORD,DWORD,LPVOID,DWORD);\nBOOL WINAPI AddAccessAllowedObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID);\nBOOL WINAPI AddAccessDeniedAceEx(PACL,DWORD,DWORD,DWORD,PSID);\nBOOL DeleteAce(PACL,DWORD);\nBOOL GetAce (PACL,DWORD,LPVOID *);\nBOOL AddAccessAllowedAce(PACL,DWORD,DWORD,PSID);\nBOOL WINAPI AddAccessAllowedAceEx(PACL,DWORD,DWORD,DWORD,PSID);\nBOOL AddAccessDeniedAce(PACL,DWORD,DWORD,PSID);\nBOOL AddAuditAccessAce(PACL,DWORD,DWORD,PSID,BOOL,BOOL);\nBOOL FindFirstFreeAce (PACL,LPVOID *);\nBOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR,DWORD);\nBOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR);\nDWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR);\nBOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR_CONTROL,LPDWORD);\nBOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);\nBOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL *,LPBOOL);\nBOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);\nBOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL *,LPBOOL);\nBOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID pOwner,BOOL);\nBOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID *,LPBOOL);\nBOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID,BOOL);\nBOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID *,LPBOOL);\nDWORD WINAPI SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR,PUCHAR);\nDWORD WINAPI GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR,PUCHAR);\nBOOL WINAPI ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,GUID *,BOOLEAN,PGENERIC_MAPPING);\nBOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,BOOL,HANDLE,PGENERIC_MAPPING);\nBOOL SetPrivateObjectSecurity(SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,PGENERIC_MAPPING,HANDLE);\nBOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);\nBOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *);\nBOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,LPDWORD);\nBOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,LPDWORD,PACL,LPDWORD,PACL,LPDWORD,PSID,LPDWORD,PSID,LPDWORD);\nBOOL SetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);\nBOOL FindNextChangeNotification(HANDLE);\nBOOL FindCloseChangeNotification(HANDLE);\nBOOL VirtualLock(LPVOID,DWORD);\nBOOL VirtualUnlock(LPVOID,DWORD);\nLPVOID MapViewOfFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPVOID);\nBOOL SetPriorityClass(HANDLE,DWORD);\nDWORD GetPriorityClass(HANDLE);\nBOOL IsBadReadPtr(CONST VOID *,UINT);\nBOOL IsBadWritePtr(LPVOID,UINT);\nBOOL IsBadHugeReadPtr(CONST VOID *,UINT);\nBOOL IsBadHugeWritePtr(LPVOID,UINT);\nBOOL IsBadCodePtr(FARPROC);\nBOOL AllocateLocallyUniqueId(PLUID);\nBOOL QueryPerformanceCounter(LARGE_INTEGER *);\nBOOL QueryPerformanceFrequency(LARGE_INTEGER *);\nVOID MoveMemory(PVOID,CONST VOID *,DWORD);\nVOID NTAPI RtlMoveMemory(VOID *,CONST VOID *,SIZE_T);\n#define MoveMemory(a,b,c) RtlMoveMemory(a,b,c)\nVOID FillMemory(PVOID,DWORD,BYTE);\nVOID ZeroMemory(PVOID,DWORD);\n#ifdef WIN95\nHKL ActivateKeyboardLayout(HKL,UINT);\n#else\nBOOL ActivateKeyboardLayout(HKL,UINT);\n#endif\nint ToUnicodeEx(UINT,UINT,PBYTE,LPWSTR,int,UINT,HKL);\nBOOL UnloadKeyboardLayout(HKL);\nint GetKeyboardLayoutList(int,HKL *);\nHKL GetKeyboardLayout(DWORD);\nHDESK OpenInputDesktop(DWORD,BOOL,DWORD);\nBOOL EnumDesktopWindows(HDESK,ENUMWINDOWSPROC,LPARAM);\nBOOL SwitchDesktop(HDESK);\nBOOL SetThreadDesktop(HDESK);\nBOOL CloseDesktop(HDESK);\nHDESK GetThreadDesktop(DWORD);\nBOOL CloseWindowStation(HWINSTA);\nBOOL SetProcessWindowStation(HWINSTA);\nHWINSTA GetProcessWindowStation(VOID);\nBOOL SetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR);\nBOOL GetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);\nBOOL TranslateMessage(CONST MSG *);\nBOOL SetMessageQueue(int);\nBOOL RegisterHotKey(HWND,int,UINT,UINT);\nBOOL UnregisterHotKey(HWND,int);\nBOOL ExitWindowsEx(UINT,DWORD);\n#define ExitWindows(a,b) ExitWindowsEx(EWX_LOGOFF,0xFFFFFFFF)\nBOOL SwapMouseButton(BOOL);\nDWORD GetMessagePos(VOID);\nLONG GetMessageTime(VOID);\nLONG GetMessageExtraInfo(VOID);\nLPARAM SetMessageExtraInfo(LPARAM);\nlong BroadcastSystemMessage(DWORD,LPDWORD,UINT,WPARAM,LPARAM);\nBOOL AttachThreadInput(DWORD,DWORD,BOOL);\nBOOL ReplyMessage(LRESULT);\nBOOL WaitMessage(VOID);\nDWORD WaitForInputIdle(HANDLE,DWORD);\nVOID PostQuitMessage(int);\nBOOL InSendMessage(VOID);\nUINT GetDoubleClickTime(VOID);\nBOOL SetDoubleClickTime(UINT);\nBOOL IsWindow(HWND);\nBOOL IsMenu(HMENU);\nBOOL IsChild(HWND,HWND);\nBOOL DestroyWindow(HWND);\nBOOL ShowWindow(HWND,int);\nBOOL AnimateWindow(HWND,DWORD,DWORD);\nBOOL UpdateLayeredWindow(HWND,HDC,POINT *,SIZE *,HDC,POINT *,COLORREF,BLENDFUNCTION *,DWORD);\nBOOL SetLayeredWindowAttributes(HWND,COLORREF,BYTE,DWORD);\n#define LWA_COLORKEY\t1\n#define LWA_ALPHA\t2\n#define ULW_COLORKEY\t1\n#define ULW_ALPHA\t2\n#define ULW_OPAQUE\t4\nBOOL ShowWindowAsync(HWND,int);\nBOOL FlashWindow(HWND,BOOL);\nBOOL FlashWindowEx(PFLASHWINFO);\n#define FLASHW_STOP\t0\n#define FLASHW_CAPTION\t1\n#define FLASHW_TRAY\t2\n#define FLASHW_ALL\t(FLASHW_CAPTION|FLASHW_TRAY)\n#define FLASHW_TIMER\t4\n#define FLASHW_TIMERNOFG\t0xC\nBOOL ShowOwnedPopups(HWND,BOOL);\nBOOL OpenIcon(HWND);\nBOOL CloseWindow(HWND);\nBOOL MoveWindow(HWND,int,int,int,int,BOOL);\nBOOL SetWindowPos(HWND,HWND,int,int,int,int,UINT);\nBOOL GetWindowPlacement(HWND,WINDOWPLACEMENT *);\nBOOL SetWindowPlacement(HWND hWnd,CONST WINDOWPLACEMENT *);\nHDWP BeginDeferWindowPos(int);\nHDWP DeferWindowPos(HDWP,HWND,HWND,int,int,int,int,UINT);\nBOOL EndDeferWindowPos(HDWP);\nBOOL IsWindowVisible(HWND);\nBOOL IsIconic(HWND);\nBOOL AnyPopup(VOID);\nBOOL BringWindowToTop(HWND);\nBOOL IsZoomed(HWND);\nBOOL EndDialog(HWND,int);\nHWND GetDlgItem(HWND,int);\nBOOL SetDlgItemInt(HWND,int,UINT,BOOL);\nUINT GetDlgItemInt(HWND,int,BOOL *,BOOL);\nBOOL CheckDlgButton(HWND,int,UINT);\nBOOL CheckRadioButton(HWND,int,int,int);\nUINT IsDlgButtonChecked(HWND,int);\nHWND GetNextDlgGroupItem(HWND,HWND,BOOL);\nHWND GetNextDlgTabItem(HWND,HWND,BOOL);\nint GetDlgCtrlID(HWND);\nlong GetDialogBaseUnits(VOID);\nBOOL OpenClipboard(HWND);\nBOOL CloseClipboard(VOID);\nHWND GetClipboardOwner(VOID);\nHWND SetClipboardViewer(HWND);\nHWND GetClipboardViewer(VOID);\nBOOL ChangeClipboardChain(HWND,HWND);\nHANDLE SetClipboardData(UINT,HANDLE);\nHANDLE GetClipboardData(UINT);\nint CountClipboardFormats(VOID);\nUINT EnumClipboardFormats(UINT);\nBOOL EmptyClipboard(VOID);\nBOOL IsClipboardFormatAvailable(UINT);\nint GetPriorityClipboardFormat(UINT *,int);\nHWND GetOpenClipboardWindow(VOID);\nLPSTR CharNextExA(WORD,LPCSTR,DWORD);\nLPSTR CharPrevExA(WORD,LPCSTR,LPCSTR,DWORD dwFlags);\nHWND SetFocus(HWND);\nHWND GetActiveWindow(VOID);\nHWND GetFocus(VOID);\nUINT GetKBCodePage(VOID);\nSHORT GetKeyState(int);\nSHORT GetAsyncKeyState(int);\nBOOL GetKeyboardState(PBYTE);\nBOOL SetKeyboardState(LPBYTE);\nint GetKeyboardType(int);\nint ToAscii(UINT,UINT,PBYTE,LPWORD,UINT);\nint ToAsciiEx(UINT,UINT,PBYTE,LPWORD,UINT,HKL);\nint ToUnicode(UINT,UINT,PBYTE,LPWSTR,int,UINT);\nDWORD OemKeyScan(WORD);\nVOID keybd_event(BYTE,BYTE,DWORD,DWORD);\nVOID mouse_event(DWORD,DWORD,DWORD,DWORD,DWORD);\nBOOL GetInputState(VOID);\nDWORD GetQueueStatus(UINT flags);\nHWND GetCapture(VOID);\nHWND SetCapture(HWND hWnd);\nBOOL ReleaseCapture(VOID);\nDWORD MsgWaitForMultipleObjects(DWORD,LPHANDLE,BOOL,DWORD,DWORD);\nDWORD WINAPI MsgWaitForMultipleObjectsEx(DWORD,CONST HANDLE *,DWORD,DWORD,DWORD);\nUINT SetTimer(HWND,UINT,UINT,TIMERPROC);\nBOOL KillTimer(HWND,UINT);\nBOOL IsWindowUnicode(HWND);\nBOOL EnableWindow(HWND,BOOL);\nBOOL IsWindowEnabled(HWND);\nBOOL DestroyAcceleratorTable(HACCEL);\nint GetSystemMetrics(int);\nHMENU GetMenu(HWND);\nBOOL WINAPI GetMenuBarInfo(HWND,LONG,LONG,PMENUBARINFO);\nBOOL SetMenu(HWND,HMENU);\nBOOL HiliteMenuItem(HWND,HMENU,UINT,UINT);\nUINT GetMenuState(HMENU,UINT,UINT);\nBOOL DrawMenuBar(HWND);\nHMENU GetSystemMenu(HWND,BOOL);\nHMENU CreateMenu(VOID);\nHMENU CreatePopupMenu(VOID);\nBOOL DestroyMenu(HMENU);\nDWORD CheckMenuItem(HMENU,UINT,UINT);\nBOOL EnableMenuItem(HMENU,UINT,UINT);\nHMENU GetSubMenu(HMENU,int);\nUINT GetMenuItemID(HMENU,int);\nint GetMenuItemCount(HMENU);\nBOOL RemoveMenu(HMENU,UINT,UINT);\nBOOL DeleteMenu(HMENU,UINT,UINT);\nBOOL SetMenuItemBitmaps(HMENU,UINT,UINT,HBITMAP,HBITMAP);\nLONG GetMenuCheckMarkDimensions(VOID);\nBOOL TrackPopupMenu(HMENU,UINT,int,int,int,HWND,CONST RECT *);\nBOOL WINAPI GetMenuInfo(HMENU,LPMENUINFO);\nBOOL WINAPI SetMenuInfo(HMENU,LPCMENUINFO);\nBOOL WINAPI EndMenu(VOID);\nUINT GetMenuDefaultItem(HMENU,UINT,UINT);\nBOOL SetMenuDefaultItem(HMENU,UINT,UINT);\nBOOL GetMenuItemRect(HWND,HMENU,UINT,LPRECT);\nint MenuItemFromPoint(HWND,HMENU,POINT);\nDWORD DragObject(HWND,HWND,UINT,DWORD,HCURSOR);\nBOOL DragDetect(HWND,POINT);\nBOOL DrawIcon(HDC,int,int,HICON);\nBOOL UpdateWindow(HWND);\nHWND SetActiveWindow(HWND);\nHWND GetForegroundWindow(VOID);\nBOOL PaintDesktop(HDC);\nBOOL SetForegroundWindow(HWND hWnd);\nHWND WindowFromDC(HDC hDC);\nHDC GetDC(HWND);\nHDC GetDCEx(HWND,HRGN,DWORD);\nHDC GetWindowDC(HWND);\nint ReleaseDC(HWND,HDC);\nHDC BeginPaint( HWND,LPPAINTSTRUCT);\nBOOL EndPaint(HWND,CONST PAINTSTRUCT *);\nBOOL GetUpdateRect(HWND,LPRECT,BOOL);\nint GetUpdateRgn(HWND,HRGN,BOOL);\nint SetWindowRgn(HWND,HRGN,BOOL);\nint GetWindowRgn(HWND,HRGN);\nint ExcludeUpdateRgn(HDC,HWND);\nBOOL InvalidateRect(HWND,CONST RECT *,BOOL);\nBOOL ValidateRect(HWND,CONST RECT *);\nBOOL InvalidateRgn(HWND,HRGN,BOOL);\nBOOL ValidateRgn(HWND,HRGN);\nBOOL RedrawWindow(HWND,CONST RECT *,HRGN,UINT);\nBOOL LockWindowUpdate(HWND );\nBOOL ScrollWindow(HWND,int,int,CONST RECT *,CONST RECT *);\nBOOL ScrollDC(HDC,int,int,CONST RECT *,CONST RECT *,HRGN,LPRECT);\nint ScrollWindowEx(HWND,int,int,CONST RECT *,CONST RECT *,HRGN,LPRECT,UINT);\nint SetScrollPos(HWND,int,int,BOOL);\nint GetScrollPos(HWND,int);\nBOOL SetScrollRange(HWND,int,int,int,BOOL);\nBOOL GetScrollRange(HWND,int,LPINT,LPINT);\nBOOL ShowScrollBar(HWND,int,BOOL);\nBOOL EnableScrollBar(HWND,UINT,UINT);\nBOOL GetClientRect(HWND,LPRECT);\nBOOL GetWindowRect(HWND,LPRECT);\nBOOL AdjustWindowRect(LPRECT,DWORD,BOOL);\nBOOL AdjustWindowRectEx(LPRECT,DWORD,BOOL,DWORD);\nBOOL SetWindowContextHelpId(HWND,DWORD);\nDWORD GetWindowContextHelpId(HWND);\nBOOL SetMenuContextHelpId(HMENU,DWORD);\nDWORD GetMenuContextHelpId(HMENU);\nBOOL MessageBeep(UINT);\nint ShowCursor(BOOL);\nBOOL SetCursorPos(int,int);\nHCURSOR SetCursor(HCURSOR);\nBOOL GetCursorPos(LPPOINT);\nBOOL ClipCursor(CONST RECT *);\nBOOL GetClipCursor(LPRECT);\nHCURSOR GetCursor(VOID);\nBOOL CreateCaret(HWND,HBITMAP,int,int);\nUINT GetCaretBlinkTime(VOID);\nBOOL SetCaretBlinkTime(UINT);\nBOOL DestroyCaret(VOID);\nBOOL HideCaret(HWND);\nBOOL ShowCaret(HWND);\nBOOL SetCaretPos(int,int);\nBOOL GetCaretPos(LPPOINT);\nBOOL ClientToScreen(HWND,LPPOINT);\nBOOL ScreenToClient(HWND,LPPOINT);\nint MapWindowPoints(HWND,HWND,LPPOINT,UINT);\nHWND WindowFromPoint(POINT);\nHWND ChildWindowFromPoint(HWND,POINT);\nDWORD GetSysColor(int);\nHBRUSH GetSysColorBrush(int);\nBOOL SetSysColors(int,CONST INT *,CONST COLORREF *);\nBOOL DrawFocusRect(HDC,CONST RECT *);\nint FillRect(HDC,CONST RECT *,HBRUSH);\nint FrameRect(HDC,CONST RECT *,HBRUSH);\nBOOL InvertRect(HDC,CONST RECT *);\nBOOL SetRect(LPRECT,int,int,int,int);\nBOOL SetRectEmpty(LPRECT);\nBOOL CopyRect(LPRECT,CONST RECT *);\nBOOL InflateRect(LPRECT,int,int);\nBOOL IntersectRect(LPRECT,CONST RECT *,CONST RECT *);\nBOOL UnionRect(LPRECT,CONST RECT *,CONST RECT *);\nBOOL SubtractRect(LPRECT,CONST RECT *,CONST RECT *);\nBOOL OffsetRect(LPRECT,int,int);\nBOOL IsRectEmpty( CONST RECT *);\nBOOL EqualRect(CONST RECT *,CONST RECT *);\nBOOL PtInRect( CONST RECT *lprc,POINT pt);\nWORD GetWindowWord(HWND,int);\nWORD SetWindowWord(HWND,int,WORD);\nWORD GetClassWord(HWND,int);\nWORD SetClassWord(HWND,int,WORD);\nHWND GetDesktopWindow(VOID);\nHWND GetParent(HWND);\nHWND SetParent(HWND,HWND);\nBOOL EnumChildWindows(HWND,ENUMWINDOWSPROC,LPARAM);\nBOOL EnumWindows(ENUMWINDOWSPROC,LPARAM );\nBOOL EnumThreadWindows(DWORD,ENUMWINDOWSPROC,LPARAM);\nHWND GetTopWindow(HWND);\nDWORD GetWindowThreadProcessId(HWND,LPDWORD);\nHWND GetLastActivePopup(HWND);\nHWND GetWindow(HWND,UINT);\nBOOL UnhookWindowsHook(int,HOOKPROC);\nBOOL UnhookWindowsHookEx(HHOOK);\nBOOL WINAPI UnhookWinEvent(HWINEVENTHOOK);\nHWINEVENTHOOK WINAPI SetWinEventHook(DWORD,DWORD,HMODULE,WINEVENTPROC,DWORD,DWORD,DWORD);\nLRESULT CallNextHookEx(HHOOK,int,WPARAM,LPARAM);\nVOID WINAPI NotifyWinEvent(DWORD,HWND,LONG,LONG);\nBOOL CheckMenuRadioItem(HMENU,UINT,UINT,UINT,UINT);\nHCURSOR CreateCursor(HINSTANCE,int,int,int,int,CONST VOID *,CONST VOID *);\nBOOL DestroyCursor(HCURSOR);\nBOOL SetSystemCursor( HCURSOR,DWORD);\nHICON CreateIcon(HINSTANCE,int,int,BYTE,BYTE,CONST BYTE *,CONST BYTE *);\nBOOL DestroyIcon(HICON);\nint LookupIconIdFromDirectory(PBYTE,BOOL);\nint LookupIconIdFromDirectoryEx(PBYTE,BOOL,int,int,UINT);\nHICON CreateIconFromResource(PBYTE,DWORD,BOOL,DWORD);\nHICON CreateIconFromResourceEx(PBYTE,DWORD,BOOL,DWORD,int,int,UINT);\nHICON CopyImage( HANDLE,UINT,int,int,UINT);\nHICON CreateIconIndirect(PICONINFO);\nHICON CopyIcon(HICON);\n#define CopyCursor(p) ((HCURSOR)CopyIcon((HICON)(p)))\nBOOL GetIconInfo( HICON hIcon,PICONINFO piconinfo);\nBOOL MapDialogRect( HWND hDlg,LPRECT lpRect);\nint SetScrollInfo(HWND,int,LPCSCROLLINFO,BOOL);\nBOOL GetScrollInfo(HWND,int,LPSCROLLINFO);\nBOOL TranslateMDISysAccel(HWND,LPMSG);\nUINT ArrangeIconicWindows(HWND);\nWORD TileWindows(HWND,UINT,CONST RECT *,UINT,const HWND *);\nWORD CascadeWindows(HWND,UINT,CONST RECT *,UINT,const HWND *);\nVOID SetLastErrorEx(DWORD,DWORD);\nVOID SetDebugErrorLevel(DWORD);\nBOOL DrawEdge(HDC,LPRECT,UINT,UINT);\nBOOL DrawFrameControl(HDC,LPRECT,UINT,UINT);\nBOOL DrawCaption(HWND,HDC,CONST RECT *,UINT);\nBOOL DrawAnimatedRects(HWND,int,CONST RECT *,CONST RECT *);\nBOOL TrackPopupMenuEx(HMENU,UINT,int,int,HWND,LPTPMPARAMS);\nHWND ChildWindowFromPointEx(HWND,POINT,UINT);\nHWND WINAPI RealChildWindowFromPoint(HWND,POINT);\nUINT WINAPI RealGetWindowClassA(HWND,LPSTR,UINT);\nBOOL WINAPI IsProcessorFeaturePresent(DWORD);\nBOOL DrawIconEx(HDC,int,int,HICON,int,int,UINT,HBRUSH,UINT);\nBOOL AnimatePalette(HPALETTE,UINT,UINT,CONST PALETTEENTRY *);\nBOOL Arc(HDC,int,int,int,int,int,int,int,int);\nBOOL BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);\nBOOL CancelDC(HDC);\nBOOL Chord(HDC,int,int,int,int,int,int,int,int);\nHMETAFILE CloseMetaFile(HDC);\nint CombineRgn(HRGN,HRGN,HRGN,int);\nHBITMAP CreateBitmap(int,int,UINT,UINT,CONST VOID *);\nHBITMAP CreateBitmapIndirect(CONST BITMAP *);\nHBRUSH CreateBrushIndirect(CONST LOGBRUSH *);\nHBITMAP CreateCompatibleBitmap(HDC,int,int);\nHBITMAP CreateDiscardableBitmap(HDC,int,int);\nHDC CreateCompatibleDC(HDC);\nHBITMAP CreateDIBitmap(HDC,CONST BITMAPINFOHEADER *,DWORD,CONST VOID *,CONST BITMAPINFO *,UINT);\nHBRUSH CreateDIBPatternBrush(HGLOBAL,UINT);\nHBRUSH CreateDIBPatternBrushPt(CONST VOID *,UINT);\nHRGN CreateEllipticRgn(int,int,int,int);\nHRGN CreateEllipticRgnIndirect(CONST RECT *);\nHBRUSH CreateHatchBrush(int,COLORREF);\nHPALETTE CreatePalette(CONST LOGPALETTE *);\nHPEN CreatePen(int,int,COLORREF);\nHPEN CreatePenIndirect(CONST LOGPEN *);\nHRGN CreatePolyPolygonRgn(CONST POINT *,CONST INT *,int,int);\nHBRUSH CreatePatternBrush(HBITMAP);\nHRGN CreateRectRgn(int,int,int,int);\nHRGN CreateRectRgnIndirect(CONST RECT *);\nHRGN CreateRoundRectRgn(int,int,int,int,int,int);\nHBRUSH CreateSolidBrush(COLORREF);\nBOOL DeleteDC(HDC);\nBOOL DeleteMetaFile(HMETAFILE);\nBOOL DeleteObject(HGDIOBJ);\nint WINAPI DescribePixelFormat(HDC,int, UINT, LPPIXELFORMATDESCRIPTOR);\nBOOL WINAPI SwapBuffers(HDC);\nint DrawEscape(HDC,int,int,LPCSTR);\nBOOL Ellipse(HDC,int,int,int,int);\nint EnumObjects(HDC,int,ENUMOBJECTSPROC,LPARAM);\nBOOL EqualRgn(HRGN,HRGN);\nint Escape(HDC,int,int,LPCSTR,LPVOID);\nint ExtEscape(HDC,int,int,LPCSTR,int,LPSTR);\nint ExcludeClipRect(HDC,int,int,int,int);\nHRGN ExtCreateRegion(CONST XFORM *,DWORD,CONST RGNDATA *);\nBOOL ExtFloodFill(HDC,int,int,COLORREF,UINT);\nBOOL FillRgn(HDC,HRGN,HBRUSH);\nBOOL FloodFill(HDC,int,int,COLORREF);\nBOOL FrameRgn(HDC,HRGN,HBRUSH,int,int);\nint GetROP2(HDC);\nBOOL GetAspectRatioFilterEx(HDC,LPSIZE);\nCOLORREF GetBkColor(HDC);\nCOLORREF GetDCBrushColor(HDC);\nCOLORREF GetDCPenColor(HDC);\nint GetBkMode(HDC);\nLONG GetBitmapBits(HBITMAP,LONG,LPVOID);\nBOOL GetBitmapDimensionEx(HBITMAP,LPSIZE);\nUINT GetBoundsRect(HDC,LPRECT,UINT);\nBOOL GetBrushOrgEx(HDC,LPPOINT);\nint GetClipBox(HDC,LPRECT);\nint GetClipRgn(HDC,HRGN);\nint GetMetaRgn(HDC,HRGN);\nHGDIOBJ GetCurrentObject(HDC,UINT);\nBOOL GetCurrentPositionEx(HDC,LPPOINT);\nint GetDeviceCaps(HDC,int);\nint GetDIBits(HDC,HBITMAP,UINT,UINT,LPVOID,LPBITMAPINFO,UINT);\nDWORD GetFontData(HDC,DWORD,DWORD,LPVOID,DWORD);\nDWORD WINAPI GetFontUnicodeRanges(HDC,LPGLYPHSET);\nDWORD WINAPI GetGlyphIndicesA(HDC,LPCSTR,int,LPWORD,DWORD);\nDWORD WINAPI GetGlyphIndicesW(HDC,LPCWSTR,int,LPWORD,DWORD);\nint GetGraphicsMode(HDC);\nint GetMapMode(HDC);\nUINT GetMetaFileBitsEx(HMETAFILE,UINT,LPVOID);\nCOLORREF GetNearestColor(HDC,COLORREF);\nUINT GetNearestPaletteIndex(HPALETTE,COLORREF);\nDWORD GetObjectType(HGDIOBJ);\nUINT GetPaletteEntries(HPALETTE,UINT,UINT,LPPALETTEENTRY);\nCOLORREF GetPixel(HDC,int,int);\nint GetPixelFormat(HDC);\nint GetPolyFillMode(HDC);\nBOOL GetRasterizerCaps(LPRASTERIZER_STATUS,UINT);\nint WINAPI GetRandomRgn (HDC,HRGN,INT);\nDWORD GetRegionData(HRGN,DWORD,LPRGNDATA);\nint GetRgnBox(HRGN,LPRECT);\nHGDIOBJ GetStockObject(int);\nint GetStretchBltMode(HDC);\nUINT GetSystemPaletteEntries(HDC,UINT,UINT,LPPALETTEENTRY);\nUINT GetSystemPaletteUse(HDC);\nint GetTextCharacterExtra(HDC);\nUINT GetTextAlign(HDC);\nCOLORREF GetTextColor(HDC);\nint GetTextCharset(HDC);\nint GetTextCharsetInfo(HDC,LPFONTSIGNATURE,DWORD);\nBOOL TranslateCharsetInfo( DWORD *,LPCHARSETINFO,DWORD);\nDWORD GetFontLanguageInfo(HDC);\nBOOL GetViewportExtEx(HDC,LPSIZE);\nBOOL GetViewportOrgEx(HDC,LPPOINT);\nBOOL GetWindowExtEx(HDC,LPSIZE);\nBOOL GetWindowOrgEx(HDC,LPPOINT);\nint IntersectClipRect(HDC,int,int,int,int);\nBOOL InvertRgn(HDC,HRGN);\nBOOL LineDDA(int,int,int,int,LINEDDAPROC,LPARAM);\nBOOL LineTo(HDC,int,int);\nBOOL MaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD);\nBOOL PlgBlt(HDC,CONST POINT *,HDC,int,int,int,int,HBITMAP,int,int);\nint OffsetClipRgn(HDC,int,int);\nint OffsetRgn(HRGN,int,int);\nBOOL PatBlt(HDC,int,int,int,int,DWORD);\nBOOL Pie(HDC,int,int,int,int,int,int,int,int);\nBOOL PlayMetaFile(HDC,HMETAFILE);\nBOOL PaintRgn(HDC,HRGN);\nBOOL PolyPolygon(HDC,CONST POINT *,CONST INT *,int);\nBOOL PtInRegion(HRGN,int,int);\nBOOL PtVisible(HDC,int,int);\nBOOL RectInRegion(HRGN,CONST RECT *);\nBOOL RectVisible(HDC,CONST RECT *);\nBOOL Rectangle(HDC,int,int,int,int);\nBOOL RestoreDC(HDC,int);\nUINT RealizePalette(HDC);\nBOOL RoundRect(HDC,int,int,int,int,int,int);\nBOOL ResizePalette(HPALETTE,UINT);\nint SaveDC(HDC);\nint SelectClipRgn(HDC,HRGN);\nint ExtSelectClipRgn(HDC,HRGN,int);\nint SetMetaRgn(HDC);\nHGDIOBJ SelectObject(HDC,HGDIOBJ);\nHPALETTE SelectPalette(HDC,HPALETTE,BOOL);\nCOLORREF SetBkColor(HDC,COLORREF);\nint SetBkMode(HDC,int);\nLONG SetBitmapBits(HBITMAP,DWORD,CONST VOID *);\nUINT SetBoundsRect(HDC,CONST RECT *,UINT);\nint SetDIBits(HDC,HBITMAP,UINT,UINT,CONST VOID *,CONST BITMAPINFO *,UINT);\nint SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,CONST VOID *,CONST BITMAPINFO *,UINT);\nDWORD SetMapperFlags(HDC,DWORD);\nint SetGraphicsMode(HDC,int);\nint SetMapMode(HDC,int);\nHMETAFILE SetMetaFileBitsEx(UINT,CONST BYTE *);\nUINT SetPaletteEntries(HPALETTE,UINT,UINT,CONST PALETTEENTRY *);\nCOLORREF SetPixel(HDC,int,int,COLORREF);\nBOOL SetPixelV(HDC,int,int,COLORREF);\nint SetPolyFillMode(HDC,int);\nBOOL StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);\nBOOL SetRectRgn(HRGN,int,int,int,int);\nint StretchDIBits(HDC,int,int,int,int,int,int,int,int,CONST VOID *,CONST BITMAPINFO *,UINT,DWORD);\nint SetROP2(HDC,int);\nint SetStretchBltMode(HDC,int);\nUINT SetSystemPaletteUse(HDC,UINT);\nint SetTextCharacterExtra(HDC,int);\nCOLORREF SetTextColor(HDC,COLORREF);\nUINT SetTextAlign(HDC,UINT);\nBOOL SetTextJustification(HDC,int,int);\nBOOL UpdateColors(HDC);\nBOOL PlayMetaFileRecord(HDC,LPHANDLETABLE,LPMETARECORD,UINT);\nBOOL EnumMetaFile(HDC,HMETAFILE,ENUMMETAFILEPROC,LPARAM);\nHENHMETAFILE CloseEnhMetaFile(HDC);\nBOOL DeleteEnhMetaFile(HENHMETAFILE);\nBOOL EnumEnhMetaFile(HDC,HENHMETAFILE,ENHMETAFILEPROC,LPVOID,CONST RECT *);\nUINT GetEnhMetaFileHeader(HENHMETAFILE,UINT,LPENHMETAHEADER );\nUINT GetEnhMetaFilePaletteEntries(HENHMETAFILE,UINT,LPPALETTEENTRY );\nUINT WINAPI GetEnhMetaFileBits(HENHMETAFILE,UINT,LPBYTE);\nUINT GetWinMetaFileBits(HENHMETAFILE,UINT,LPBYTE,INT,HDC);\nBOOL PlayEnhMetaFile(HDC,HENHMETAFILE,CONST RECT *);\nBOOL PlayEnhMetaFileRecord(HDC,LPHANDLETABLE,CONST ENHMETARECORD *,UINT);\nHENHMETAFILE SetEnhMetaFileBits(UINT,CONST BYTE *);\nHENHMETAFILE SetWinMetaFileBits(UINT,CONST BYTE *,HDC,CONST METAFILEPICT *);\nBOOL GdiComment(HDC,UINT,CONST BYTE *);\nBOOL AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);\nBOOL PolyPolyline(HDC,CONST POINT *,CONST DWORD *,DWORD);\nBOOL GetWorldTransform(HDC,LPXFORM);\nBOOL SetWorldTransform(HDC,CONST XFORM *);\nBOOL ModifyWorldTransform(HDC,CONST XFORM *,DWORD);\nBOOL CombineTransform(LPXFORM,CONST XFORM *,CONST XFORM *);\nHBITMAP CreateDIBSection(HDC,CONST BITMAPINFO *,UINT,VOID **,HANDLE,DWORD);\nUINT GetDIBColorTable(HDC,UINT,UINT,RGBQUAD *);\nUINT SetDIBColorTable(HDC,UINT,UINT,CONST RGBQUAD *);\nBOOL SetColorAdjustment(HDC,CONST COLORADJUSTMENT *);\nBOOL GetColorAdjustment(HDC,LPCOLORADJUSTMENT);\nHPALETTE CreateHalftonePalette(HDC);\nBOOL WINAPI ReadDirectoryChangesW(HANDLE,LPVOID,DWORD,BOOL,DWORD,LPDWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);\nint EndDoc(HDC);\nint StartPage(HDC);\nint EndPage(HDC);\nint AbortDoc(HDC);\nint SetAbortProc(HDC,ABORTPROC);\nBOOL AbortPath(HDC);\nBOOL ArcTo(HDC,int,int,int,int,int,int,int,int);\nBOOL BeginPath(HDC);\nBOOL CloseFigure(HDC);\nBOOL EndPath(HDC);\nBOOL FillPath(HDC);\nBOOL FlattenPath(HDC);\nint GetPath(HDC,LPPOINT,LPBYTE,int);\nHRGN PathToRegion(HDC);\nBOOL PolyDraw(HDC,CONST POINT *,CONST BYTE *,int);\nBOOL SelectClipPath(HDC,int);\nint SetArcDirection(HDC,int);\nBOOL SetMiterLimit(HDC,FLOAT,PFLOAT);\nBOOL StrokeAndFillPath(HDC);\nBOOL StrokePath(HDC);\nBOOL WidenPath(HDC);\nHPEN ExtCreatePen(DWORD,DWORD,CONST LOGBRUSH *,DWORD,CONST DWORD *);\nBOOL GetMiterLimit(HDC,PFLOAT);\nint GetArcDirection(HDC);\nBOOL MoveToEx(HDC,int,int,LPPOINT);\nHRGN CreatePolygonRgn(CONST POINT *,int,int);\nBOOL DPtoLP(HDC,LPPOINT,int);\nBOOL LPtoDP(HDC,LPPOINT,int);\nBOOL Polygon(HDC,CONST POINT *,int);\nBOOL Polyline(HDC,CONST POINT *,int);\nBOOL PolyBezier(HDC,CONST POINT *,DWORD);\nBOOL PolyBezierTo(HDC,CONST POINT *,DWORD);\nBOOL PolylineTo(HDC,CONST POINT *,DWORD);\nBOOL SetViewportExtEx(HDC,int,int,LPSIZE);\nBOOL SetViewportOrgEx(HDC,int,int,LPPOINT);\nBOOL SetWindowExtEx(HDC,int,int,LPSIZE);\nBOOL SetWindowOrgEx(HDC,int,int,LPPOINT);\nBOOL OffsetViewportOrgEx(HDC,int,int,LPPOINT);\nBOOL OffsetWindowOrgEx(HDC,int,int,LPPOINT);\nBOOL ScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);\nBOOL ScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);\nBOOL SetBitmapDimensionEx(HBITMAP,int,int,LPSIZE);\nBOOL SetBrushOrgEx(HDC,int,int,LPPOINT);\nBOOL GetDCOrgEx(HDC,LPPOINT);\nBOOL FixBrushOrgEx(HDC,int,int,LPPOINT);\nBOOL UnrealizeObject(HGDIOBJ);\nBOOL GdiFlush(void);\nDWORD GdiSetBatchLimit(DWORD);\nDWORD GdiGetBatchLimit(void);\nint SetICMMode(HDC,int);\nBOOL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);\nHANDLE GetColorSpace(HDC);\nBOOL SetColorSpace(HDC,HCOLORSPACE);\nBOOL DeleteColorSpace(HCOLORSPACE);\nBOOL GetDeviceGammaRamp(HDC,LPVOID);\nBOOL SetDeviceGammaRamp(HDC,LPVOID);\nBOOL ColorMatchToTarget(HDC,HDC,DWORD);\nHPROPSHEETPAGE CreatePropertySheetPageA(LPCPROPSHEETPAGE);\nBOOL DestroyPropertySheetPage(HPROPSHEETPAGE);\nvoid InitCommonControls(void);\ntypedef struct tagINITCOMMONCONTROLSEX { DWORD dwSize; DWORD dwICC; } INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;\n#define ICC_LISTVIEW_CLASSES 1\n#define ICC_TREEVIEW_CLASSES 2\n#define ICC_BAR_CLASSES\t4\n#define ICC_TAB_CLASSES 8\n#define ICC_UPDOWN_CLASS 0x10\n#define ICC_PROGRESS_CLASS 0x20\n#define ICC_HOTKEY_CLASS 0x40\n#define ICC_ANIMATE_CLASS 0x80\n#define ICC_WIN95_CLASSES 0xFF\n#define ICC_DATE_CLASSES 0x100\n#define ICC_USEREX_CLASSES 0x200\n#define ICC_COOL_CLASSES 0x400\n#define ICC_INTERNET_CLASSES 0x800\n#define ICC_PAGESCROLLER_CLASS 0x1000\n#define ICC_NATIVEFNTCTL_CLASS 0x2000\n#define ICC_STANDARD_CLASSES 0x04000\n#define ECM_FIRST 0x1500\n#define BCM_FIRST 0x1600\n#define BCM_GETIDEALSIZE  (BCM_FIRST + 1)\n#define BCM_SETIMAGELIST  (BCM_FIRST + 2)\n#define BCM_GETIMAGELIST  (BCM_FIRST + 3)\n#define BCM_SETTEXTMARGIN (BCM_FIRST + 4)\n#define BCM_GETTEXTMARGIN (BCM_FIRST + 5)\n#define CBM_FIRST 0x1700\n#define ICC_LINK_CLASS 0x08000\nBOOL AlphaBlend(HDC,int,int,int,int,HDC,int,int,int,int,BLENDFUNCTION);\nBOOL TransparentBlt(HDC,int,int,int,int,HDC,int,int,int,int,UINT);\n#define AC_SRC_OVER 0\n#define AC_SRC_ALPHA 1\n#define GRADIENT_FILL_RECT_H\t0\n#define GRADIENT_FILL_RECT_V\t1\n#define GRADIENT_FILL_TRIANGLE\t2\n#define GRADIENT_FILL_OP_FLAG\t0x0ff\nBOOL GradientFill(HDC,PTRIVERTEX,ULONG,PVOID,ULONG,ULONG);\nBOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX);\n#define ImageList_AddIcon(himl,hicon) ImageList_ReplaceIcon(himl,-1,hicon)\nHIMAGELIST ImageList_Create(int,int,UINT,int,int);\nBOOL ImageList_Destroy(HIMAGELIST);\nint ImageList_GetImageCount(HIMAGELIST);\nint ImageList_Add(HIMAGELIST,HBITMAP,HBITMAP);\nint ImageList_ReplaceIcon(HIMAGELIST,int,HICON);\nCOLORREF ImageList_SetBkColor(HIMAGELIST,COLORREF);\nCOLORREF ImageList_GetBkColor(HIMAGELIST himl);\nBOOL ImageList_SetOverlayImage(HIMAGELIST,int,int);\nBOOL ImageList_Draw(HIMAGELIST,int,HDC,int,int,UINT);\nBOOL ImageList_Replace(HIMAGELIST,int,HBITMAP,HBITMAP);\nint ImageList_AddMasked(HIMAGELIST,HBITMAP,COLORREF);\nBOOL ImageList_DrawEx(HIMAGELIST,int,HDC,int,int,int,int,COLORREF,COLORREF,UINT);\nBOOL ImageList_Remove(HIMAGELIST,int);\nHICON ImageList_GetIcon(HIMAGELIST,int,UINT);\nBOOL ImageList_BeginDrag(HIMAGELIST,int,int,int);\nvoid ImageList_EndDrag(VOID);\nBOOL ImageList_DragEnter(HWND,int,int);\nBOOL ImageList_DragLeave(HWND);\nBOOL ImageList_DragMove(int,int);\nBOOL ImageList_SetDragCursorImage(HIMAGELIST,int,int,int);\nBOOL ImageList_DragShowNolock(BOOL);\nHIMAGELIST ImageList_GetDragImage(POINT *,POINT *);\nBOOL ImageList_GetIconSize(HIMAGELIST,int *,int *);\nBOOL ImageList_SetIconSize(HIMAGELIST,int,int);\nBOOL ImageList_GetImageInfo(HIMAGELIST,int,IMAGEINFO *);\nHIMAGELIST ImageList_Merge(HIMAGELIST,int,HIMAGELIST,int,int,int);\nBOOL WINAPI ImageList_SetImageCount(HIMAGELIST,UINT);\nHWND CreateToolbarEx(HWND,DWORD,UINT,int,HINSTANCE,UINT,LPCTBBUTTON,int,int,int,int,int,UINT);\nHBITMAP CreateMappedBitmap(HINSTANCE,int,UINT,LPCOLORMAP,int);\nvoid MenuHelp(UINT,WPARAM,LPARAM,HMENU,HINSTANCE,HWND,UINT *);\nBOOL ShowHideMenuCtl(HWND,UINT,LPINT);\nvoid GetEffectiveClientRect(HWND,LPRECT,LPINT);\nBOOL MakeDragList(HWND);\nvoid DrawInsert(HWND,HWND,int);\nint LBItemFromPt(HWND,POINT,BOOL);\nHWND CreateUpDownControl(DWORD,int,int,int,int,HWND,int,HINSTANCE,HWND,int,int,int);\nDWORD CommDlgExtendedError(VOID);\nBOOL SetWaitableTimer(HANDLE,const LARGE_INTEGER *,LONG,PTIMERAPCROUTINE,LPVOID,BOOL);\nBOOL CancelWaitableTimer(HANDLE);\nHANDLE WINAPI CreateWaitableTimerA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);\nHANDLE WINAPI CreateWaitableTimerW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);\n#define WSB_PROP_CYVSCROLL\t1\n#define WSB_PROP_CXHSCROLL\t2\n#define WSB_PROP_CYHSCROLL\t4\n#define WSB_PROP_CXVSCROLL\t8\n#define WSB_PROP_CXHTHUMB\t0x10\n#define WSB_PROP_CYVTHUMB\t0x20\n#define WSB_PROP_VBKGCOLOR\t0x40\n#define WSB_PROP_HBKGCOLOR\t0x80\n#define WSB_PROP_VSTYLE\t0x100\n#define WSB_PROP_HSTYLE\t0x200\n#define WSB_PROP_WINSTYLE\t0x400\n#define WSB_PROP_PALETTE\t0x800\n#define WSB_PROP_MASK\t0xFFF\n#define FSB_FLAT_MODE\t2\n#define FSB_ENCARTA_MODE\t1\n#define FSB_REGULAR_MODE\t0\nBOOL WINAPI FlatSB_EnableScrollBar(HWND,int,UINT);\nBOOL WINAPI FlatSB_ShowScrollBar(HWND,int,BOOL);\nBOOL WINAPI FlatSB_GetScrollRange(HWND,int,LPINT,LPINT);\nBOOL WINAPI FlatSB_GetScrollInfo(HWND,int,LPSCROLLINFO);\nint WINAPI FlatSB_GetScrollPos(HWND,int);\nBOOL WINAPI FlatSB_GetScrollProp(HWND,int,LPINT);\n#define FlatSB_GetScrollPropPtr FlatSB_GetScrollProp\nint WINAPI FlatSB_SetScrollPos(HWND,int,int,BOOL);\nint WINAPI FlatSB_SetScrollInfo(HWND,int,LPSCROLLINFO,BOOL);\nint WINAPI FlatSB_SetScrollRange(HWND,int,int,int,BOOL);\nBOOL WINAPI FlatSB_SetScrollProp(HWND,UINT,int,BOOL);\n#define FlatSB_SetScrollPropPtr FlatSB_SetScrollProp\nBOOL WINAPI InitializeFlatSB(HWND);\nHRESULT WINAPI UninitializeFlatSB(HWND);\n#define Button_GetTextMargin(h,p) (BOOL)SNDMSG((h),BCM_GETTEXTMARGIN,0,(LPARAM)(p))\n#define Button_SetTextMargin(h, p) (BOOL)SNDMSG((h),BCM_SETTEXTMARGIN,0, (LPARAM)(p))\n#define Button_GetImageList(h,p) (BOOL)SNDMSG((h),BCM_GETIMAGELIST,0,(LPARAM)(p))\n#define Button_SetImageList(hwnd, pbuttonImagelist) (BOOL)SNDMSG((hwnd), BCM_SETIMAGELIST, 0, (LPARAM)(pbuttonImagelist))\n#define Button_GetIdealSize(hwnd, psize) (BOOL)SNDMSG((hwnd), BCM_GETIDEALSIZE, 0, (LPARAM)(psize))\n#define Edit_SetCueBannerText(hwnd, lpcwText) (BOOL)SNDMSG((hwnd), EM_SETCUEBANNER, 0, (LPARAM)(lpcwText))\n#define Edit_GetCueBannerText(h,lpwText, cchText) (BOOL)SNDMSG((h),EM_GETCUEBANNER, (WPARAM)(lpwText), (LPARAM)(cchText))\n#define Edit_ShowBalloonTip(hwnd, peditballoontip) (BOOL)SNDMSG((hwnd), EM_SHOWBALLOONTIP, 0, (LPARAM)(peditballoontip))\n#define Edit_HideBalloonTip(hwnd) (BOOL)SNDMSG((hwnd), EM_HIDEBALLOONTIP, 0, 0)\n#define DateTime_GetSystemtime(hdp, pst) (DWORD)SNDMSG(hdp, DTM_GETSYSTEMTIME, 0, (LPARAM)(pst))\n#define DateTime_SetSystemtime(hdp, gd, pst) (BOOL)SNDMSG(hdp, DTM_SETSYSTEMTIME, (WPARAM)(gd), (LPARAM)(pst))\n#define DateTime_GetRange(hdp, rgst) (DWORD)SNDMSG(hdp, DTM_GETRANGE, 0, (LPARAM)(rgst))\n#define DateTime_SetRange(hdp, gd, rgst) (BOOL)SNDMSG(hdp, DTM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))\n#define Animate_Create(hP,id,S,I) CreateWindow(ANIMATE_CLASS,NULL,S,0,0,0,0,hP,(HMENU)(id),I,NULL)\n#define Animate_Open(hw,Name) SendMessage(hw,ACM_OPEN,0,(LPARAM)(LPTSTR)(Name))\n#define Animate_Play(h,f,t,r) SendMessage(h,ACM_PLAY,(WPARAM)(r),(LPARAM)MAKELONG(f,t))\n#define Animate_Stop(hw) SendMessage(hw,ACM_STOP,0,0)\n#define Animate_Close(h) Animate_Open(h,NULL)\n#define Animate_Seek(h,f) Animate_Play(h,f,f,1)\n#define PropSheet_AddPage(h,hp) SendMessage(h,PSM_ADDPAGE,0,(LPARAM)hp)\n#define PropSheet_Apply(h) SendMessage(h,PSM_APPLY,0,0)\n#define PropSheet_CancelToClose(h) SendMessage(h,PSM_CANCELTOCLOSE,0,0)\n#define PropSheet_Changed(h,w) SendMessage(h,PSM_CHANGED,(WPARAM)w,0)\n#define PropSheet_GetCurrentPageHwnd(h) SendMessage(h,PSM_GETCURRENTPAGEHWND,0,0)\n#define PropSheet_GetTabControl(h) SendMessage(h,PSM_GETTABCONTROL,0,0)\n#define PropSheet_IsDialogMessage(h,M) SendMessage(h,PSM_ISDIALOGMESSAGE,0,(LPARAM)M)\n#define PropSheet_PressButton(h,B) SendMessage(h,PSM_PRESSBUTTON,(WPARAM)B,0)\n#define PropSheet_QuerySiblings(h,p1,p2) SendMessage(h,PSM_QUERYSIBLINGS,(WPARAM)p1,(LPARAM)p2)\n#define PropSheet_RebootSystem(h) SendMessage(h,PSM_REBOOTSYSTEM,0,0)\n#define PropSheet_RemovePage(h,i,p) SendMessage(h,PSM_REMOVEPAGE,(WPARAM)(int)i,(LPARAM)p)\n#define PropSheet_RestartWindows(h) SendMessage(h,PSM_RESTARTWINDOWS,0,0)\n#define PropSheet_SetCurSel(hDlg,hpage,index) SendMessage(hDlg,PSM_SETCURSEL,(WPARAM)index,(LPARAM)hpage)\n#define PropSheet_SetCurSelByID(hPropSheetDlg,id) SendMessage(hPropSheetDlg,PSM_SETCURSELID,0,(LPARAM)id)\n#define PropSheet_SetFinishText(h,T) SendMessage(h,PSM_SETFINISHTEXT,0,(LPARAM)T)\n#define PropSheet_SetTitle(h,S,T) SendMessage(h,PSM_SETTITLE,(WPARAM)S,(LPARAM)T)\n#define PropSheet_SetWizButtons(h,F) SendMessage(h,PSM_SETWIZBUTTONS,0,(LPARAM)F)\n#define PropSheet_UnChanged(hDlg,hP) SendMessage(hDlg,PSM_UNCHANGED,(WPARAM)(HWND)hP,0)\n#define Header_DeleteItem(hHD,i) (BOOL)SendMessage((hHD),HDM_DELETEITEM,(WPARAM)(i),0)\n#define Header_GetItem(hHD,i,p) (BOOL)SendMessage((hHD),HDM_GETITEM,(WPARAM)(i),(LPARAM)(p))\n#define Header_GetUnicodeFormat(h) (BOOL)SendMessage(h,HDM_GETUNICODEFORMAT,0,0)\n#define Header_SetUnicodeFormat(h,f) (BOOL)SendMessage(h,HDM_SETUNICODEFORMAT,f,0)\n#define Header_GetItemCount(hHD) (int)SendMessage((hHD),HDM_GETITEMCOUNT,0,0)\n#define Header_InsertItem(hHD,i,phdi) (int)SendMessage((hHD),HDM_INSERTITEM,(WPARAM)(i),(LPARAM)(phdi))\n#define Header_Layout(hHD,p) (BOOL)SendMessage((hHD),HDM_LAYOUT,0,(LPARAM)(p))\n#define Header_SetItem(hHD,i,p) (BOOL)SendMessage((hHD),HDM_SETITEM,(WPARAM)(i),(LPARAM)(p))\n#define ListView_MapIDToIndex(hwnd, id) (UINT)SNDMSG((hwnd), LVM_MAPIDTOINDEX, (WPARAM)id, (LPARAM)0)\n#define ListView_MapIndexToID(hwnd, index) (UINT)SNDMSG((hwnd), LVM_MAPINDEXTOID, (WPARAM)index, (LPARAM)0)\n#define ListView_CancelEditLabel(hwnd) (VOID)SNDMSG((hwnd), LVM_CANCELEDITLABEL, (WPARAM)0, (LPARAM)0)\n#define ListView_SetOutlineColor(hwnd, color) (COLORREF)SNDMSG((hwnd), LVM_SETOUTLINECOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))\n#define ListView_GetOutlineColor(hwnd) (COLORREF)SNDMSG((hwnd), LVM_GETOUTLINECOLOR, 0, 0)\n#define ListView_IsGroupViewEnabled(h) (BOOL)SNDMSG((h), LVM_ISGROUPVIEWENABLED, 0, 0)\n#define ListView_GetSelectedColumn(hwnd) (UINT)SNDMSG((hwnd), LVM_GETSELECTEDCOLUMN, 0, 0)\n#define ListView_SetInfoTip(hwndLV, plvInfoTip) (BOOL)SNDMSG((hwndLV), LVM_SETINFOTIP, (WPARAM)0, (LPARAM)plvInfoTip)\n#define ListView_GetInsertMarkColor(h) (COLORREF)SNDMSG((h),LVM_GETINSERTMARKCOLOR,(WPARAM)0, (LPARAM)0)\n#define ListView_SetInsertMarkColor(hwnd, color) (COLORREF)SNDMSG((hwnd), LVM_SETINSERTMARKCOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))\n#define ListView_GetInsertMarkRect(h,rc) (int)SNDMSG((h),LVM_GETINSERTMARKRECT,(WPARAM)0,(LPARAM)(LPRECT)(rc))\n#define ListView_InsertMarkHitTest(h,p,lvim) (int)SNDMSG((h),LVM_INSERTMARKHITTEST,(WPARAM)(LPPOINT)(p),(LPARAM)(LPLVINSERTMARK)(lvim))\n#define ListView_GetInsertMark(hwnd, lvim) (BOOL)SNDMSG((hwnd), LVM_GETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))\n#define ListView_SetInsertMark(hwnd, lvim) (BOOL)SNDMSG((hwnd), LVM_SETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))\n#define ListView_GetTileInfo(hwnd, pti) SNDMSG((hwnd), LVM_GETTILEINFO, 0, (LPARAM)pti)\n#define ListView_SetTileInfo(hwnd, pti) SNDMSG((hwnd), LVM_SETTILEINFO, 0, (LPARAM)pti)\n#define ListView_GetTileViewInfo(hwnd, ptvi) SNDMSG((hwnd), LVM_GETTILEVIEWINFO, 0, (LPARAM)ptvi)\n#define ListView_SetTileViewInfo(hwnd, ptvi) SNDMSG((hwnd), LVM_SETTILEVIEWINFO, 0, (LPARAM)ptvi)\n#define ListView_HasGroup(hwnd, dwGroupId) SNDMSG((hwnd), LVM_HASGROUP, dwGroupId, 0)\n#define ListView_RemoveAllGroups(hwnd) SNDMSG((hwnd), LVM_REMOVEALLGROUPS, 0, 0)\n#define ListView_InsertGroupSorted(hwnd, structInsert) SNDMSG((hwnd), LVM_INSERTGROUPSORTED, (WPARAM)structInsert, 0)\n#define ListView_SortGroups(hwnd, _pfnGroupCompate, _plv) SNDMSG((hwnd), LVM_SORTGROUPS, (WPARAM)_pfnGroupCompate, (LPARAM)_plv)\n#define ListView_EnableGroupView(hwnd, fEnable) SNDMSG((hwnd), LVM_ENABLEGROUPVIEW, (WPARAM)fEnable, 0)\n#define ListView_GetGroupMetrics(hwnd, pGroupMetrics) SNDMSG((hwnd), LVM_GETGROUPMETRICS, 0, (LPARAM)pGroupMetrics)\n#define ListView_SetGroupMetrics(hwnd, pGroupMetrics) SNDMSG((hwnd),LVM_SETGROUPMETRICS, 0, (LPARAM)pGroupMetrics)\n#define ListView_MoveItemToGroup(hwnd, idItemFrom, idGroupTo) SNDMSG((hwnd), LVM_MOVEITEMTOGROUP, (WPARAM)idItemFrom, (LPARAM)idGroupTo)\n#define ListView_MoveGroup(hwnd, iGroupId, toIndex) SNDMSG((hwnd), LVM_MOVEGROUP, (WPARAM)iGroupId, (LPARAM)toIndex)\n#define ListView_RemoveGroup(hwnd, iGroupId) SNDMSG((hwnd), LVM_REMOVEGROUP, (WPARAM)iGroupId, 0)\n#define ListView_GetGroupInfo(hwnd, iGroupId, pgrp) SNDMSG((hwnd),LVM_GETGROUPINFO, (WPARAM)iGroupId, (LPARAM)pgrp)\n#define ListView_SetGroupInfo(hwnd, iGroupId, pgrp) SNDMSG((hwnd), LVM_SETGROUPINFO, (WPARAM)iGroupId, (LPARAM)pgrp)\n#define ListView_InsertGroup(hwnd, index, pgrp) SNDMSG((hwnd), LVM_INSERTGROUP, (WPARAM)index, (LPARAM)pgrp)\n#define ListView_SetTileWidth(h,cpWidth) SNDMSG((h), LVM_SETTILEWIDTH,(WPARAM)cpWidth,0)\n#define ListView_SetSelectedColumn(h,iCol) SNDMSG((h), LVM_SETSELECTEDCOLUMN, (WPARAM)iCol, 0)\n#define ListView_ApproximateViewRect(h,W,H,C) (DWORD)SNDMSG((h),LVM_APPROXIMATEVIEWRECT,C,MAKELPARAM(W,H))\n#define ListView_SetView(hwnd, iView) (DWORD)SNDMSG((hwnd), LVM_SETVIEW, (WPARAM)(DWORD)iView, 0)\n#define ListView_GetColumnOrderArray(h,iCount, pi) (BOOL)SendMessage((h),LVM_GETCOLUMNORDERARRAY,(WPARAM)(iCount),(LPARAM)(LPINT)(pi))\n#define ListView_GetExtendedListViewStyle(h) (DWORD)SendMessage((h),LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)\n#define ListView_GetHeader(hwnd) (HWND)SendMessage((hwnd), LVM_GETHEADER, 0, 0L)\n#define ListView_GetHotCursor(hwnd) (HCURSOR)SendMessage((hwnd), LVM_GETHOTCURSOR, 0, 0)\n#define ListView_GetHotItem(hwnd) (int)SendMessage((hwnd), LVM_GETHOTITEM, 0, 0)\n#define ListView_SetColumnOrderArray(hwnd, iCount, pi) (BOOL)SendMessage((hwnd), LVM_SETCOLUMNORDERARRAY, (WPARAM)(iCount), (LPARAM)(LPINT)(pi))\n#define ListView_SetExtendedListViewStyle(h,dw) (DWORD)SNDMSG((h),LVM_SETEXTENDEDLISTVIEWSTYLE,0,dw)\n#define ListView_SetExtendedListViewStyleEx(h,M,dw) (DWORD)SNDMSG(h,LVM_SETEXTENDEDLISTVIEWSTYLE,M,dw)\n#define ListView_SetHotItem(hwnd, i) (int)SendMessage((hwnd),LVM_SETHOTITEM, (WPARAM)(i),0)\n#define ListView_SetHotCursor(hwnd, hcur) (HCURSOR)SendMessage((hwnd), LVM_SETHOTCURSOR, 0, (LPARAM)(hcur))\n#define ListView_SetIconSpacing(hwndLV, cx, cy) (DWORD)SendMessage((hwndLV), LVM_SETICONSPACING,0, MAKELONG(cx,cy))\n#define ListView_SetWorkAreas(h,WA,prc) (BOOL)SNDMSG((h),LVM_SETWORKAREAS,(WPARAM)(int)(WA),(LPARAM)(RECT *)(prc))\n#define ListView_SetCheckState(h,i,f) ListView_SetItemState(h,i,INDEXTOSTATEIMAGEMASK((f)?2:1),LVIS_STATEIMAGEMASK)\n#define ListView_GetCheckState(h,i) ((((UINT)(SNDMSG((h),LVM_GETITEMSTATE,(WPARAM)(i),LVIS_STATEIMAGEMASK))) >> 12) -1)\n#define ListView_GetWorkAreas(hwnd, nWorkAreas, prc) (BOOL)SNDMSG((hwnd),LVM_GETWORKAREAS,(WPARAM)(int)(nWorkAreas),(LPARAM)(RECT *)(prc))\n#define ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas) (BOOL)SNDMSG((hwnd),LVM_GETNUMBEROFWORKAREAS,0,(LPARAM)(UINT *)(pnWorkAreas))\n#define ListView_GetSelectionMark(hwnd) (int)SNDMSG((hwnd),LVM_GETSELECTIONMARK,0,0)\n#define ListView_SetSelectionMark(hwnd, i) (int)SNDMSG((hwnd),LVM_SETSELECTIONMARK,0,(LPARAM)(i))\n#define ListView_GetSubItemRect(h,i,SI,code,prc) (BOOL)SNDMSG((h),LVM_GETSUBITEMRECT,(WPARAM)(int)(i), ((prc) ? ((((LPRECT)(prc))->top=SI),(((LPRECT)(prc))->left = code), (LPARAM)(prc)) : (LPARAM)(LPRECT)NULL))\n#define ListView_SubItemHitTest(h,p) (int)SNDMSG((h),LVM_SUBITEMHITTEST,0,(LPARAM)(LPLVHITTESTINFO)(p))\n#define ListView_SetHoverTime(hwndLV, dwHoverTimeMs) (DWORD)SNDMSG((hwndLV),LVM_SETHOVERTIME,0,(LPARAM)(dwHoverTimeMs))\n#define ListView_GetHoverTime(hwndLV) (DWORD)SNDMSG((hwndLV),LVM_GETHOVERTIME,0,0)\n#define ListView_SetToolTips(hwndLV, hwndNewHwnd) (HWND)SNDMSG((hwndLV),LVM_SETTOOLTIPS,(WPARAM)(hwndNewHwnd),0)\n#define ListView_GetToolTips(hwndLV) (HWND)SNDMSG((hwndLV),LVM_GETTOOLTIPS,0,0)\n#define ListView_SortItemsEx(hwndLV, _pfnCompare, _lPrm) (BOOL)SNDMSG((hwndLV),LVM_SORTITEMSEX,(WPARAM)(LPARAM)(_lPrm),(LPARAM)(PFNLVCOMPARE)(_pfnCompare))\n#define ListView_SetBkImage(hwnd, plvbki) (BOOL)SNDMSG((hwnd),LVM_SETBKIMAGE,0,(LPARAM)(plvbki))\n#define ListView_GetBkImage(hwnd, plvbki) (BOOL)SNDMSG((hwnd),LVM_GETBKIMAGE,0,(LPARAM)(plvbki))\n#define ListView_Arrange(hLV,c) SendMessage((hLV),LVM_ARRANGE,(WPARAM)(c),0)\n#define ListView_CreateDragImage(h,i,l) SendMessage((h),LVM_CREATEDRAGIMAGE,(WPARAM)(i),(LPARAM)(l))\n#define ListView_DeleteAllItems(h) SendMessage(h,LVM_DELETEALLITEMS,0,0)\n#define ListView_DeleteColumn(h,iCol) SendMessage((h),LVM_DELETECOLUMN,(WPARAM)(iCol),0)\n#define ListView_DeleteItem(h,iItem) SendMessage(h,LVM_DELETEITEM,(WPARAM)iItem,0)\n#define ListView_EditLabel(hLV,i) (HWND)SendMessage((hLV),LVM_EDITLABEL,(WPARAM)i,0)\n#define ListView_EnsureVisible(hLV,i,fOK) SendMessage(hLV,LVM_ENSUREVISIBLE,(WPARAM)i,MAKELPARAM((fOK),0))\n#define ListView_FindItem(hwnd,i,p) SendMessage(hwnd,LVM_FINDITEM,(WPARAM)i,(LPARAM)p)\n#define ListView_GetBkColor(hwnd) SendMessage((HWND)hwnd,LVM_GETBKCOLOR,0,0)\n#define ListView_GetCallbackMask(h) SendMessage(h,LVM_GETCALLBACKMASK,0,0)\n#define ListView_GetColumn(hwnd,iCol,pcol) SendMessage((hwnd),LVM_GETCOLUMN,(WPARAM)(iCol),(LPARAM)(pcol))\n#define ListView_GetColumnWidth(h,iCol) SendMessage((h),LVM_GETCOLUMNWIDTH,(WPARAM)(iCol),0)\n#define ListView_GetCountPerPage(h) SendMessage((h),LVM_GETCOUNTPERPAGE,0,0)\n#define ListView_GetEditControl(h) (HWND)SendMessage((h),LVM_GETEDITCONTROL,0,0)\n#define ListView_GetImageList(h,iIL) SendMessage(h,LVM_GETIMAGELIST,(WPARAM)iIL,0)\n#define ListView_GetISearchString(h,l) SendMessage((h),LVM_GETISEARCHSTRING,0,(LPARAM)l)\n#define ListView_GetItem(h,p) SendMessage(h,LVM_GETITEM,0,(LPARAM)(p))\n#define ListView_GetItemCount(h) SendMessage(h,LVM_GETITEMCOUNT,0,0)\n#define ListView_GetItemPosition(h,i,ppt) SendMessage(h,LVM_GETITEMPOSITION,(WPARAM)(int)i,(LPARAM)ppt)\n#define ListView_GetItemRect(h,i,p,c) SendMessage(h,LVM_GETITEMRECT,(WPARAM)i,((p) ? (((RECT *)(p))->left=(c),(LPARAM)(p)):(LPARAM)NULL))\n#define ListView_GetItemSpacing(hLV,f) SendMessage((hLV),LVM_GETITEMSPACING,f,0)\n#define ListView_GetItemState(hLV,i,m) SendMessage((hLV),LVM_GETITEMSTATE,(WPARAM)i,(LPARAM)m)\n#define ListView_GetItemText(hLV,i,iS,T,c) {LV_ITEM _gnu_l;_gnu_l.iSubItem=iS;_gnu_l.cchTextMax=c;_gnu_l.pszText=(TCHAR *)T;SendMessage((hLV),LVM_GETITEMTEXT,(WPARAM)i,(LPARAM)&_gnu_l);}\n#define ListView_GetNextItem(h,S,f) SendMessage(h,LVM_GETNEXTITEM,(WPARAM)S,(LPARAM)f)\n#define ListView_GetOrigin(hLV,ppt) SendMessage((hLV),LVM_GETORIGIN,(WPARAM)0,(LPARAM)(ppt))\n#define ListView_GetSelectedCount(h) SendMessage((h),LVM_GETSELECTEDCOUNT,0,0)\n#define ListView_GetStringWidth(h,psz) SendMessage(h,LVM_GETSTRINGWIDTH,0,(LPARAM)psz)\n#define ListView_GetTextBkColor(h) SendMessage((h),LVM_GETTEXTBKCOLOR,0,0)\n#define ListView_GetTextColor(h) SendMessage((h),LVM_GETTEXTCOLOR,0,0)\n#define ListView_GetTopIndex(h) SendMessage((h),LVM_GETTOPINDEX,0,0)\n#define ListView_GetViewRect(h,prc) SendMessage((h),LVM_GETVIEWRECT,0,(LPARAM)(prc))\n#define ListView_HitTest(hLV,pinfo) SendMessage(hLV,LVM_HITTEST,0,(LPARAM)pinfo)\n#define ListView_InsertColumn(hwnd,iCol,pcol) SendMessage((hwnd),LVM_INSERTCOLUMN,(WPARAM)(int)(iCol),(LPARAM)(pcol))\n#define ListView_InsertItem(hwnd,pitem) SendMessage(hwnd,LVM_INSERTITEM,0,(LPARAM)pitem)\n#define ListView_RedrawItems(hLV,iFirst,iLast) SendMessage((hLV),LVM_REDRAWITEMS,(WPARAM)iFirst,(LPARAM)iLast)\n#define ListView_Scroll(hLV,dx,dy) SendMessage((hLV),LVM_SCROLL,(WPARAM)dx,(LPARAM)dy)\n#define ListView_SetBkColor(h,clrBk) SendMessage(h,LVM_SETBKCOLOR,0,(LPARAM)(COLORREF)clrBk)\n#define ListView_SetCallbackMask(h,m) SendMessage(h,LVM_SETCALLBACKMASK,(WPARAM)(UINT)(m),0)\n#define ListView_SetColumn(h,iCol,pcol) SendMessage((h),LVM_SETCOLUMN,(WPARAM)(iCol),(LPARAM)(pcol))\n#define ListView_SetColumnWidth(hwnd,iCol,cx) SendMessage((hwnd),LVM_SETCOLUMNWIDTH,(WPARAM)(int)(iCol),MAKELPARAM((cx),0))\n#define ListView_SetImageList(hwnd,himl,iImageList) (HIMAGELIST)SendMessage(hwnd,LVM_SETIMAGELIST,(WPARAM)(iImageList),(LPARAM)(HIMAGELIST)(himl))\n#define ListView_SetItem(hwnd,pitem) SendMessage(hwnd,LVM_SETITEM,0,(LPARAM)pitem)\n#define ListView_SetItemCount(hLV,cItems) SendMessage((hLV),LVM_SETITEMCOUNT,(WPARAM)cItems,0)\n#define ListView_SetItemPosition(hLV,i,x,y) SendMessage(hLV,LVM_SETITEMPOSITION,(WPARAM)(int)(i),MAKELPARAM((x),(y)))\n#define ListView_SetItemPosition32(hLV,i,x,y) {POINT ptNewPos={x,y};SendMessage((hLV),LVM_SETITEMPOSITION32,(WPARAM)(i),(LPARAM)&ptNewPos);}\n#define ListView_SetItemState(hLV,i,d,m) {LV_ITEM _gnu_l;_gnu_l.stateMask=m;_gnu_l.state=d;SendMessage((hLV),LVM_SETITEMSTATE,(WPARAM)(i),(LPARAM)&_gnu_l);}\n#define ListView_SetItemText(hLV,i,iS,T) {LV_ITEM _gnu_l;_gnu_l.iSubItem=iS;_gnu_l.pszText=T;SendMessage((hLV),LVM_SETITEMTEXT,(WPARAM)(i),(LPARAM)&_gnu_l);}\n#define ListView_SetTextBkColor(h,c) SendMessage((h),LVM_SETTEXTBKCOLOR,0,(LPARAM)(c))\n#define ListView_SetTextColor(h,c) SendMessage((h),LVM_SETTEXTCOLOR,0,(LPARAM)(c))\n#define ListView_SortItems(hLV,p,l) SendMessage((hLV),LVM_SORTITEMS,(WPARAM)l,(LPARAM)p)\n#define ListView_Update(hLV,i) SendMessage((hLV),LVM_UPDATE,(WPARAM)i,0)\n#define ListView_GetUnicodeFormat(h) (BOOL)SendMessage((h),LVM_GETUNICODEFORMAT,0,0)\n#define ListView_SetUnicodeFormat(h,f) (BOOL)SendMessage((h),LVM_SETUNICODEFORMAT,(WPARAM)f,0)\n#define TreeView_GetScrollTime(h) (UINT)SendMessage(h,TVM_GETSCROLLTIME,0,0)\n#define TreeView_SetItemHeight(h,iHeight) (int)SendMessage((h), TVM_SETITEMHEIGHT,(WPARAM)(iHeight), 0)\n#define TreeView_GetItemHeight(h) (int)SendMessage((h),TVM_GETITEMHEIGHT, 0, 0)\n#define TreeView_SetItemState(h,hti,d,m) {TVITEM TVi;TVi.mask=TVIF_STATE;TVi.hItem = hti;TVi.stateMask=m;TVi.state=d;SNDMSG((h),TVM_SETITEM,0,(LPARAM)(TV_ITEM *)&TVi);}\n#define TreeView_SetBkColor(h,clr) (COLORREF)SendMessage((h),TVM_SETBKCOLOR, 0, (LPARAM)(clr))\n#define TreeView_SetTextColor(hwnd, clr) (COLORREF)SendMessage((hwnd), TVM_SETTEXTCOLOR, 0, (LPARAM)(clr))\n#define TreeView_GetBkColor(hwnd) (COLORREF)SendMessage((hwnd), TVM_GETBKCOLOR, 0, 0)\n#define TreeView_GetTextColor(hwnd) (COLORREF)SendMessage((hwnd),TVM_GETTEXTCOLOR, 0, 0)\n#define TreeView_SetScrollTime(hwnd, uTime) (UINT)SendMessage((hwnd), TVM_SETSCROLLTIME, uTime, 0)\n#define TreeView_SetInsertMarkColor(hwnd, clr) (COLORREF)SendMessage((hwnd),TVM_SETINSERTMARKCOLOR, 0, (LPARAM)(clr))\n#define TreeView_GetInsertMarkColor(hwnd) (COLORREF)SendMessage((hwnd), TVM_GETINSERTMARKCOLOR, 0, 0)\n#define TreeView_InsertItem(h,l) (HTREEITEM)SendMessage((h),TVM_INSERTITEM,0,(LPARAM)(l))\n#define TreeView_DeleteItem(h,i) (HTREEITEM)SendMessage((h),TVM_DELETEITEM,0,(LPARAM)(i))\n#define TreeView_DeleteAllItems(h) SendMessage((h),TVM_DELETEITEM,0,(LPARAM)TVI_ROOT)\n#define TreeView_Expand(h,i,c) SendMessage((h),TVM_EXPAND,(WPARAM)c,(LPARAM)(i))\n#define TreeView_GetLineColor(h) (COLORREF)SendMessage(h,TVM_GETLINECOLOR,0,0)\n#define TreeView_SetLineColor(h,c) (COLORREF)SendMessage(h,TVM_SETLINECOLOR,0,(LPARAM)c)\n#define TreeView_GetCheckState(h,i) ((((UINT)(SendMessage(h,TVM_GETITEMSTATE,(WPARAM)i,TVIS_STATEIMAGEMASK))) >> 12) -1)\n#define TreeView_GetItemState(h,i,m) (UINT)SendMessage(h,TVM_GETITEMSTATE,(WPARAM)i,(LPARAM)m)\n#define TreeView_SetCheckState(h,i,C) TreeView_SetItemState(h,i,INDEXTOSTATEIMAGEMASK((C)?2:1),TVIS_STATEIMAGEMASK)\n#define TreeView_GetItemRect(h,hitem,prc,c) (*(HTREEITEM *)prc=(hitem),(BOOL)SendMessage((h),TVM_GETITEMRECT,(WPARAM)(c),(LPARAM)(RECT *)(prc)))\n#define TreeView_GetCount(h) SendMessage((h),TVM_GETCOUNT,0,0)\n#define TreeView_GetIndent(h) SendMessage((h),TVM_GETINDENT,0,0)\n#define TreeView_SetIndent(h,i) SendMessage((h),TVM_SETINDENT,(WPARAM)i,0)\n#define TreeView_GetImageList(h,i) SendMessage((h),TVM_GETIMAGELIST,i,0)\n#define TreeView_SetImageList(h,hi,i) SendMessage((h),TVM_SETIMAGELIST,i,(LPARAM)(hi))\n#define TreeView_GetNextItem(h,hi,c) (HTREEITEM)SendMessage((h),TVM_GETNEXTITEM,(WPARAM)c,(LPARAM)(hi))\n#define TreeView_GetChild(h,i) TreeView_GetNextItem(h,i,TVGN_CHILD)\n#define TreeView_GetNextSibling(h,i) TreeView_GetNextItem(h,i,TVGN_NEXT)\n#define TreeView_GetPrevSibling(h,i) TreeView_GetNextItem(h,i,TVGN_PREVIOUS)\n#define TreeView_GetParent(h,i) TreeView_GetNextItem(h,i,TVGN_PARENT)\n#define TreeView_GetFirstVisible(h) TreeView_GetNextItem(h,NULL,TVGN_FIRSTVISIBLE)\n#define TreeView_GetNextVisible(h,i) TreeView_GetNextItem(h,i,TVGN_NEXTVISIBLE)\n#define TreeView_GetPrevVisible(h,i) TreeView_GetNextItem(h,i,TVGN_PREVIOUSVISIBLE)\n#define TreeView_GetSelection(h) TreeView_GetNextItem(h,NULL,TVGN_CARET)\n#define TreeView_GetDropHilight(h) TreeView_GetNextItem(h,NULL,TVGN_DROPHILITE)\n#define TreeView_GetRoot(h) (HTREEITEM)TreeView_GetNextItem(h,NULL,TVGN_ROOT)\n#define TreeView_Select(h,i,c) SendMessage((h),TVM_SELECTITEM,(WPARAM)c,(LPARAM)(i))\n#define TreeView_SelectItem(h,i) TreeView_Select(h,i,TVGN_CARET)\n#define TreeView_SelectDropTarget(h,i) TreeView_Select(h,i,TVGN_DROPHILITE)\n#define TreeView_SelectSetFirstVisible(h,p) TreeView_Select(h,p,TVGN_FIRSTVISIBLE)\n#define TreeView_GetItem(h,p) SendMessage((h),TVM_GETITEM,0,(LPARAM)(TV_ITEM *)(p))\n#define TreeView_SetItem(h,p) (int)SendMessage((h),TVM_SETITEM,0,(LPARAM)(TV_ITEM *)(p))\n#define TreeView_EditLabel(h,i) (HWND)SendMessage((h),TVM_EDITLABEL,0,(LPARAM)(HTREEITEM)(i))\n#define TreeView_GetEditControl(h) (HWND)SendMessage((h),TVM_GETEDITCONTROL,0,0)\n#define TreeView_GetVisibleCount(h) (unsigned int)SendMessage((h),TVM_GETVISIBLECOUNT,0,0)\n#define TreeView_HitTest(h,l) (HTREEITEM)SendMessage((h),TVM_HITTEST,0,(LPARAM)(LPTV_HITTESTINFO)(l))\n#define TreeView_CreateDragImage(hwnd,hitem) (HIMAGELIST)SendMessage((hwnd),TVM_CREATEDRAGIMAGE,0,(LPARAM)(hitem))\n#define TreeView_SortChildren(h,i,r) (BOOL)SendMessage((h),TVM_SORTCHILDREN,(WPARAM)r,(LPARAM)(i))\n#define TreeView_EnsureVisible(h,i) (BOOL)SendMessage((h),TVM_ENSUREVISIBLE,0,(LPARAM)(i))\n#define TreeView_SortChildrenCB(h,p,r) SendMessage((h),TVM_SORTCHILDRENCB,(WPARAM)r,(LPARAM)(p))\n#define TreeView_EndEditLabelNow(h,f) SendMessage((h),TVM_ENDEDITLABELNOW,(WPARAM)f,0)\n#define TreeView_GetISearchString(h,lpsz) SendMessage((h),TVM_GETISEARCHSTRING,0,(LPARAM)(LPTSTR)lpsz)\n#define TabCtrl_GetImageList(h) SendMessage((h),TCM_GETIMAGELIST,0,0)\n#define TabCtrl_SetImageList(hwnd,himl) SendMessage((hwnd),TCM_SETIMAGELIST,0,(LPARAM)(himl))\n#define TabCtrl_GetItemCount(hwnd) SendMessage((hwnd),TCM_GETITEMCOUNT,0,0)\n#define TabCtrl_GetItem(h,i,p) SendMessage(h,TCM_GETITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))\n#define TabCtrl_SetItem(h,i,p) SendMessage((h),TCM_SETITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))\n#define TabCtrl_InsertItem(h,i,p) SendMessage((h),TCM_INSERTITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))\n#define TabCtrl_DeleteItem(hwnd,i) SendMessage((hwnd),TCM_DELETEITEM,(WPARAM)(int)(i),0)\n#define TabCtrl_DeleteAllItems(h) SendMessage((h),TCM_DELETEALLITEMS,0,0)\n#define TabCtrl_GetItemRect(h,i,prc) SendMessage((h),TCM_GETITEMRECT,(WPARAM)(i),(LPARAM)(prc))\n#define TabCtrl_GetCurSel(h) SendMessage((h),TCM_GETCURSEL,0,0)\n#define TabCtrl_SetCurSel(h,i) SendMessage((h),TCM_SETCURSEL,(WPARAM)i,0)\n#define TabCtrl_HitTest(h,p) SendMessage((h),TCM_HITTEST,0,(LPARAM)(TC_HITTESTINFO *)(p))\n#define TabCtrl_SetItemExtra(h,cb) SendMessage((h),TCM_SETITEMEXTRA,(WPARAM)(cb),0)\n#define TabCtrl_AdjustRect(h,L,prc) SendMessage(h,TCM_ADJUSTRECT,(WPARAM)L,(LPARAM)(RECT *)prc)\n#define TabCtrl_SetItemSize(h,x,y) SendMessage((h),TCM_SETITEMSIZE,0,MAKELPARAM(x,y))\n#define TabCtrl_RemoveImage(h,i) SendMessage((h),TCM_REMOVEIMAGE,i,0)\n#define TabCtrl_SetPadding(h,cx,cy) SendMessage((h),TCM_SETPADDING,0,MAKELPARAM(cx,cy))\n#define TabCtrl_GetRowCount(h) SendMessage((h),TCM_GETROWCOUNT,0,0)\n#define TabCtrl_GetToolTips(h) SendMessage((h),TCM_GETTOOLTIPS,0,0)\n#define TabCtrl_SetToolTips(h,T) SendMessage((h),TCM_SETTOOLTIPS,(WPARAM)T,0)\n#define TabCtrl_GetCurFocus(hwnd) SendMessage((hwnd),TCM_GETCURFOCUS,0,0)\n#define TabCtrl_SetCurFocus(hwnd,i) SendMessage((hwnd),TCM_SETCURFOCUS,i,0)\n#define TabCtrl_SetMinTabWidth(h,x) (int)SNDMSG((h),TCM_SETMINTABWIDTH,0,x)\n#define TabCtrl_DeselectAll(h,E) (void)SNDMSG((h), TCM_DESELECTALL,E,0)\n#define TabCtrl_SetExtendedStyle(h,d) (DWORD)SNDMSG((h),TCM_SETEXTENDEDSTYLE,0,d)\n#define TabCtrl_GetExtendedStyle(h) (DWORD)SNDMSG((h),TCM_GETEXTENDEDSTYLE,0,0)\n#define TabCtrl_SetUnicodeFormat(h,U) (BOOL)SNDMSG((h),TCM_SETUNICODEFORMAT,(WPARAM)(U),0)\n#define TabCtrl_GetUnicodeFormat(h) (BOOL)SNDMSG((h),TCM_GETUNICODEFORMAT,0,0)\n#define CommDlg_OpenSave_GetSpecA(h,p,c) SendMessage(h,CDM_GETSPEC,(WPARAM)c,(LPARAM)p)\n#define CommDlg_OpenSave_GetSpecW(h,_psz,c) SendMessage(h,CDM_GETSPEC,(WPARAM)c,(LPARAM)_psz)\n#define CommDlg_OpenSave_GetFilePathA(_hdlg,_psz,c) SendMessage(_hdlg,CDM_GETFILEPATH,(WPARAM)c,(LPARAM)(LPSTR)_psz)\n#define CommDlg_OpenSave_GetFilePathW(h,p,c) SendMessage(h,CDM_GETFILEPATH,(WPARAM)c,(LPARAM)(LPWSTR)p)\n#define CommDlg_OpenSave_GetFolderPathA(h,_psz,c) SendMessage(h,CDM_GETFOLDERPATH,(WPARAM)c,(LPARAM)(LPSTR)_psz)\n#define CommDlg_OpenSave_GetFolderPathW(h,p,c) SendMessage(h,CDM_GETFOLDERPATH,(WPARAM)c,(LPARAM)(LPWSTR)p)\n#define CommDlg_OpenSave_GetFolderIDList(g,p,c) SendMessage(g,CDM_GETFOLDERIDLIST,(WPARAM)c,(LPARAM)(LPVOID)p)\n#define CommDlg_OpenSave_SetControlText(h,id,t) SendMessage(h,CDM_SETCONTROLTEXT,(WPARAM)id,(LPARAM)t)\n#define CommDlg_OpenSave_HideControl(_hdlg,_id) SendMessage(_hdlg,CDM_HIDECONTROL,(WPARAM)_id,0)\n#define CommDlg_OpenSave_SetDefExt(h,psz) SendMessage(h,CDM_SETDEFEXT,0,(LPARAM)psz)\n#define GetCurrentFiber() (((PNT_TIB)NtCurrentTeb())->FiberData)\n#define GetFiberData() (*(PVOID *)(GetCurrentFiber()))\nLONG RegCloseKey (HKEY);\nLONG RegSetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);\nLONG RegFlushKey(HKEY);\nLONG RegGetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,LPDWORD);\nLONG RegNotifyChangeKeyValue(HKEY,BOOL,DWORD,HANDLE,BOOL);\nBOOL IsValidCodePage(UINT);\nUINT GetACP(void);\nUINT GetOEMCP(void);\nBOOL GetCPInfo(UINT,LPCPINFO);\nBOOL IsDBCSLeadByte(BYTE);\nBOOL IsDBCSLeadByteEx(UINT,BYTE);\nint MultiByteToWideChar(UINT,DWORD,LPCSTR,int,LPWSTR,int);\nint WideCharToMultiByte(UINT,DWORD,LPCWSTR,int,LPSTR,int,LPCSTR,LPBOOL);\nBOOL IsValidLocale(LCID,DWORD);\nLCID ConvertDefaultLocale(LCID);\nLCID GetThreadLocale(void);\nBOOL SetThreadLocale(LCID);\nLANGID GetSystemDefaultLangID(void);\nLANGID GetUserDefaultLangID(void);\nLCID GetSystemDefaultLCID(void);\nLCID GetUserDefaultLCID(void);\nBOOL ReadConsoleOutputAttribute(HANDLE,LPWORD,DWORD,COORD,LPDWORD);\nBOOL WriteConsoleOutputAttribute(HANDLE,CONST WORD *,DWORD,COORD,LPDWORD);\nBOOL FillConsoleOutputAttribute(HANDLE,WORD,DWORD,COORD,LPDWORD);\nBOOL GetConsoleMode(HANDLE,LPDWORD);\nBOOL GetNumberOfConsoleInputEvents(HANDLE,LPDWORD);\nBOOL GetConsoleScreenBufferInfo(HANDLE,PCONSOLE_SCREEN_BUFFER_INFO);\nCOORD GetLargestConsoleWindowSize(HANDLE);\nBOOL GetConsoleCursorInfo(HANDLE,PCONSOLE_CURSOR_INFO);\nBOOL GetNumberOfConsoleMouseButtons(LPDWORD);\nBOOL SetConsoleMode(HANDLE,DWORD);\nBOOL SetConsoleActiveScreenBuffer(HANDLE);\nBOOL FlushConsoleInputBuffer(HANDLE);\nBOOL SetConsoleScreenBufferSize(HANDLE,COORD);\nBOOL SetConsoleCursorPosition(HANDLE,COORD);\nBOOL SetConsoleCursorInfo(HANDLE,CONST CONSOLE_CURSOR_INFO *);\nBOOL SetConsoleWindowInfo(HANDLE,BOOL,CONST SMALL_RECT *);\nBOOL SetConsoleTextAttribute(HANDLE,WORD);\nBOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE,BOOL);\nBOOL GenerateConsoleCtrlEvent(DWORD,DWORD);\nBOOL AllocConsole(VOID);\nBOOL FreeConsole(VOID);\nHANDLE CreateConsoleScreenBuffer(DWORD,DWORD,CONST SECURITY_ATTRIBUTES *,DWORD,LPVOID);\nUINT GetConsoleCP(VOID);\nBOOL SetConsoleCP(UINT);\nUINT GetConsoleOutputCP(VOID);\nBOOL SetConsoleOutputCP(UINT);\nDWORD WNetConnectionDialog(HWND,DWORD);\nDWORD WNetDisconnectDialog(HWND,DWORD);\nDWORD WNetCloseEnum( HANDLE);\nBOOL NotifyBootConfigStatus(BOOL);\nBOOL WinLoadTrustProvider(GUID *);\nLONG WinVerifyTrust(HWND,GUID *,LPVOID);\nBOOL WinSubmitCertificate(LPWIN_CERTIFICATE);\nBOOL\tWINAPI wglCopyContext(HGLRC,HGLRC, UINT);\nHGLRC\tWINAPI wglCreateContext(HDC);\nHGLRC\tWINAPI wglCreateLayerContext(HDC,int);\nBOOL\tWINAPI wglDeleteContext(HGLRC);\nHGLRC\tWINAPI wglGetCurrentContext(VOID);\nHDC\tWINAPI wglGetCurrentDC(VOID);\nFARPROC\tWINAPI wglGetProcAddress(LPCSTR);\nBOOL\tWINAPI wglMakeCurrent(HDC,HGLRC);\nBOOL\tWINAPI wglShareLists(HGLRC,HGLRC);\nBOOL\tWINAPI wglUseFontBitmapsA(HDC,DWORD, DWORD, DWORD);\nBOOL\tWINAPI wglUseFontBitmapsW(HDC,DWORD, DWORD, DWORD);\nBOOL\tWINAPI SwapBuffers(HDC);\nBOOL\tWINAPI wglSwapLayerBuffers(HDC,UINT);\nBOOL\tWINAPI GetAltTabInfoA(HWND,int,PALTTABINFO,LPSTR,UINT);\nBOOL\tWINAPI GetAltTabInfoW(HWND,int,PALTTABINFO,LPWSTR,UINT);\n#ifdef UNICODE\n#define wglUseFontBitmaps wglUseFontBitmapsW\n#define GetAltTabInfo\tGetAltTabInfoW\n#define CreateWaitableTimer\tCreateWaitableTimerW\n#else\n#define wglUseFontBitmaps wglUseFontBitmapsA\n#define GetAltTabInfo\tGetAltTabInfoA\n#define CreateWaitableTimer\tCreateWaitableTimerA\n#endif\ntypedef struct _POINTFLOAT {\n\tFLOAT\tx;\n\tFLOAT\ty;\n} POINTFLOAT,*PPOINTFLOAT;\ntypedef struct _GLYPHMETRICSFLOAT {\n\tFLOAT\tgmfBlackBoxX;\n\tFLOAT\tgmfBlackBoxY;\n\tPOINTFLOAT gmfptGlyphOrigin;\n\tFLOAT\tgmfCellIncX;\n\tFLOAT\tgmfCellIncY;\n} GLYPHMETRICSFLOAT,*PGLYPHMETRICSFLOAT,*LPGLYPHMETRICSFLOAT;\n#define WGL_FONT_LINES\t0\n#define WGL_FONT_POLYGONS\t1\n#define WGL_SWAPMULTIPLE_MAX 16\nBOOL\tWINAPI wglUseFontOutlinesA(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);\nBOOL\tWINAPI wglUseFontOutlinesW(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);\n#ifdef UNICODE\n#define wglUseFontOutlines wglUseFontOutlinesW\n#else\n#define wglUseFontOutlines wglUseFontOutlinesA\n#endif\ntypedef struct _LAYERPLANEDESCRIPTOR {\n\tWORD\tnSize;\n\tWORD\tnVersion;\n\tDWORD\tdwFlags;\n\tBYTE\tiPixelType;\n\tBYTE\tcColorBits;\n\tBYTE\tcRedBits;\n\tBYTE\tcRedShift;\n\tBYTE\tcGreenBits;\n\tBYTE\tcGreenShift;\n\tBYTE\tcBlueBits;\n\tBYTE\tcBlueShift;\n\tBYTE\tcAlphaBits;\n\tBYTE\tcAlphaShift;\n\tBYTE\tcAccumBits;\n\tBYTE\tcAccumRedBits;\n\tBYTE\tcAccumGreenBits;\n\tBYTE\tcAccumBlueBits;\n\tBYTE\tcAccumAlphaBits;\n\tBYTE\tcDepthBits;\n\tBYTE\tcStencilBits;\n\tBYTE\tcAuxBuffers;\n\tBYTE\tiLayerPlane;\n\tBYTE\tbReserved;\n\tCOLORREF crTransparent;\n} LAYERPLANEDESCRIPTOR,*PLAYERPLANEDESCRIPTOR,*LPLAYERPLANEDESCRIPTOR;\n#define LPD_DOUBLEBUFFER\t1\n#define LPD_STEREO\t2\n#define LPD_SUPPORT_GDI\t16\n#define LPD_SUPPORT_OPENGL\t32\n#define LPD_SHARE_DEPTH\t0x40\n#define LPD_SHARE_STENCIL\t0x80\n#define LPD_SHARE_ACCUM\t0x100\n#define LPD_SWAP_EXCHANGE\t0x200\n#define LPD_SWAP_COPY\t0x400\n#define LPD_TRANSPARENT\t0x1000\n#define LPD_TYPE_RGBA\t0\n#define LPD_TYPE_COLORINDEX\t1\n#define WGL_SWAP_MAIN_PLANE\t1\n#define WGL_SWAP_OVERLAY1\t2\n#define WGL_SWAP_OVERLAY2\t4\n#define WGL_SWAP_OVERLAY3\t8\n#define\tWGL_SWAP_OVERLAY4\t0x10\n#define\tWGL_SWAP_OVERLAY5\t0x20\n#define\tWGL_SWAP_OVERLAY6\t0x40\n#define\tWGL_SWAP_OVERLAY7\t0x80\n#define\tWGL_SWAP_OVERLAY8\t0x100\n#define\tWGL_SWAP_OVERLAY9\t0x200\n#define\tWGL_SWAP_OVERLAY10\t0x400\n#define\tWGL_SWAP_OVERLAY11\t0x800\n#define\tWGL_SWAP_OVERLAY12\t0x1000\n#define\tWGL_SWAP_OVERLAY13\t0x2000\n#define\tWGL_SWAP_OVERLAY14\t0x4000\n#define\tWGL_SWAP_OVERLAY15\t0x8000\n#define\tWGL_SWAP_UNDERLAY1\t0x10000\n#define\tWGL_SWAP_UNDERLAY2\t0x20000\n#define\tWGL_SWAP_UNDERLAY3\t0x40000\n#define\tWGL_SWAP_UNDERLAY4\t0x80000\n#define\tWGL_SWAP_UNDERLAY5\t0x100000\n#define\tWGL_SWAP_UNDERLAY6\t0x200000\n#define\tWGL_SWAP_UNDERLAY7\t0x400000\n#define\tWGL_SWAP_UNDERLAY8\t0x800000\n#define\tWGL_SWAP_UNDERLAY9\t0x1000000\n#define\tWGL_SWAP_UNDERLAY10\t0x2000000\n#define\tWGL_SWAP_UNDERLAY11\t0x4000000\n#define\tWGL_SWAP_UNDERLAY12\t0x08000000\n#define WGL_SWAP_UNDERLAY13 0x10000000\n#define WGL_SWAP_UNDERLAY14 0x20000000\n#define WGL_SWAP_UNDERLAY15 0x40000000\nBOOL WINAPI wglDescribeLayerPlane(HDC,int,int,UINT,LPLAYERPLANEDESCRIPTOR);\nint WINAPI wglSetLayerPaletteEntries(HDC,int,int,int,COLORREF *);\nint WINAPI wglGetLayerPaletteEntries(HDC,int,int,int,COLORREF *);\nBOOL WINAPI wglRealizeLayerPalette(HDC,int, BOOL);\nBOOL WINAPI wglSwapLayerBuffers(HDC,UINT);\nstruct\t_TEB\t*NtCurrentTeb(void);\nLPVOID\tWINAPI\tCreateFiber(DWORD,LPFIBER_START_ROUTINE,LPVOID);\nVOID WINAPI DeleteFiber(LPVOID);\nLPVOID WINAPI ConvertThreadToFiber(LPVOID);\nVOID WINAPI SwitchToFiber(LPVOID);\nBOOL WINAPI SwitchToThread(VOID);\ntypedef void (* WAITORTIMERCALLBACKFUNC)(PVOID,BOOL);\ntypedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;\nHANDLE WINAPI RegisterWaitForSingleObject(HANDLE,WAITORTIMERCALLBACK,PVOID,ULONG);\nHANDLE WINAPI RegisterWaitForSingleObjectEx(HANDLE,WAITORTIMERCALLBACK,PVOID,ULONG,ULONG);\nBOOL WINAPI UnregisterWait(HANDLE);\nBOOL WINAPI QueueUserWorkItem(LPTHREAD_START_ROUTINE,PVOID,BOOL);\nBOOL WINAPI CreateTimerQueueTimer(PHANDLE,HANDLE, WAITORTIMERCALLBACK,PVOID,DWORD,DWORD,ULONG);\nBOOL WINAPI BindIoCompletionCallback (HANDLE,LPOVERLAPPED_COMPLETION_ROUTINE,ULONG);\nHANDLE WINAPI CreateTimerQueue(VOID);\nHANDLE WINAPI SetTimerQueueTimer(HANDLE,WAITORTIMERCALLBACK,PVOID,DWORD,DWORD,BOOL);\nBOOL WINAPI ChangeTimerQueueTimer(HANDLE,HANDLE,ULONG,ULONG);\nWINBASEAPI BOOL WINAPI CancelTimerQueueTimer(HANDLE,HANDLE);\nWINBASEAPI BOOL WINAPI DeleteTimerQueue(HANDLE);\nBOOL WINAPI DeleteTimerQueueEx(HANDLE, HANDLE);\n#define MakeProcInstance(a,b) (a)\n#define FreeProcInstance(a)\t(a)\n#define AnsiToOem CharToOemA\n#define OemToAnsi OemToCharA\n#define AnsiToOemBuff CharToOemBuffA\n#define OemToAnsiBuff OemToCharBuffA\n#define AnsiUpper CharUpperA\n#define AnsiUpperBuff CharUpperBuffA\n#define AnsiLower CharLowerA\n#define AnsiLowerBuff CharLowerBuffA\n#define AnsiNext CharNextA\n#define AnsiPrev CharPrevA\n#define DefineHandleTable(w) ((w),TRUE)\n#define LimitEmsPages(dw)\n#define SetSwapAreaSize(w) (w)\n#define LockSegment(w) GlobalFix((HANDLE)(w))\n#define UnlockSegment(w) GlobalUnfix((HANDLE)(w))\n#define GetCurrentTime() GetTickCount()\n#define Yield()\n#define ZeroMemory RtlZeroMemory\n#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))\n#define MAKE_HRESULT(s,f,c) ((HRESULT)(((DWORD)(s)<<31)|((DWORD)(f)<<16)|((DWORD)(c))))\n\n//#ifdef RC_INVOKED\n//#define _HRESULT_TYPEDEF_(_sc) _sc\n//#else\n//#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)\n//#endif\n\n#define E_FAIL\t_HRESULT_TYPEDEF_(0x80004005)\n#define E_UNEXPECTED\t_HRESULT_TYPEDEF_(0x8000FFFF)\n#define E_NOTIMPL\t_HRESULT_TYPEDEF_(0x80004001)\n#define E_OUTOFMEMORY\t_HRESULT_TYPEDEF_(0x8007000E)\n#define E_INVALIDARG\t_HRESULT_TYPEDEF_(0x80070057)\n#define E_NOINTERFACE\t_HRESULT_TYPEDEF_(0x80004002)\n#define E_POINTER\t_HRESULT_TYPEDEF_(0x80004003)\n#define E_HANDLE\t_HRESULT_TYPEDEF_(0x80070006)\n#define E_ABORT\t\t_HRESULT_TYPEDEF_(0x80004004)\n#define E_ACCESSDENIED\t_HRESULT_TYPEDEF_(0x80070005)\n#define CO_E_INIT_TLS\t_HRESULT_TYPEDEF_(0x80004006)\n#define CO_E_INIT_SHARED_ALLOCATOR\t_HRESULT_TYPEDEF_(0x80004007)\n#define CO_E_INIT_MEMORY_ALLOCATOR\t_HRESULT_TYPEDEF_(0x80004008)\n#define CO_E_INIT_CLASS_CACHE\t_HRESULT_TYPEDEF_(0x80004009)\n#define CO_E_INIT_RPC_CHANNEL\t_HRESULT_TYPEDEF_(0x8000400A)\n#define CO_E_INIT_TLS_SET_CHANNEL_CONTROL\t_HRESULT_TYPEDEF_(0x8000400B)\n#define CO_E_INIT_TLS_CHANNEL_CONTROL\t_HRESULT_TYPEDEF_(0x8000400C)\n#define CO_E_INIT_UNACCEPTED_USER_ALLOCATOR _HRESULT_TYPEDEF_(0x8000400D)\n#define CO_E_INIT_SCM_MUTEX_EXISTS\t_HRESULT_TYPEDEF_(0x8000400E)\n#define CO_E_INIT_SCM_FILE_MAPPING_EXISTS _HRESULT_TYPEDEF_(0x8000400F)\n#define CO_E_INIT_SCM_MAP_VIEW_OF_FILE\t_HRESULT_TYPEDEF_(0x80004010)\n#define CO_E_INIT_SCM_EXEC_FAILURE\t_HRESULT_TYPEDEF_(0x80004011)\n#define CO_E_INIT_ONLY_SINGLE_THREADED\t_HRESULT_TYPEDEF_(0x80004012)\n#define CO_E_CANT_REMOTE\t_HRESULT_TYPEDEF_(0x80004013)\n#define CO_E_BAD_SERVER_NAME\t_HRESULT_TYPEDEF_(0x80004014)\n#define CO_E_WRONG_SERVER_IDENTITY\t_HRESULT_TYPEDEF_(0x80004015)\n#define CO_E_OLE1DDE_DISABLED\t_HRESULT_TYPEDEF_(0x80004016)\n#define CO_E_RUNAS_SYNTAX\t_HRESULT_TYPEDEF_(0x80004017)\n#define CO_E_CREATEPROCESS_FAILURE\t_HRESULT_TYPEDEF_(0x80004018)\n#define CO_E_RUNAS_CREATEPROCESS_FAILURE _HRESULT_TYPEDEF_(0x80004019)\n#define CO_E_RUNAS_LOGON_FAILURE\t_HRESULT_TYPEDEF_(0x8000401A)\n#define CO_E_LAUNCH_PERMSSION_DENIED\t_HRESULT_TYPEDEF_(0x8000401B)\n#define CO_E_START_SERVICE_FAILURE\t_HRESULT_TYPEDEF_(0x8000401C)\n#define CO_E_REMOTE_COMMUNICATION_FAILURE _HRESULT_TYPEDEF_(0x8000401D)\n#define CO_E_SERVER_START_TIMEOUT\t_HRESULT_TYPEDEF_(0x8000401E)\n#define CO_E_CLSREG_INCONSISTENT\t_HRESULT_TYPEDEF_(0x8000401F)\n#define CO_E_IIDREG_INCONSISTENT\t_HRESULT_TYPEDEF_(0x80004020)\n#define CO_E_NOT_SUPPORTED\t_HRESULT_TYPEDEF_(0x80004021)\n#define CO_E_RELOAD_DLL\t_HRESULT_TYPEDEF_(0x80004022)\n#define CO_E_MSI_ERROR\t_HRESULT_TYPEDEF_(0x80004023)\n#define\tCLASS_E_NOAGGREGATION\t_HRESULT_TYPEDEF_(0x80040110)\n#define CLASS_E_CLASSNOTAVAILABLE\t_HRESULT_TYPEDEF_(0x80040111)\n/* Errors.h WIN32 error codes Numerical order */\n#define NO_ERROR 0\n#define ERROR_SUCCESS 0\n#define ERROR_INVALID_FUNCTION 1\n#define ERROR_FILE_NOT_FOUND 2\n#define ERROR_PATH_NOT_FOUND 3\n#define ERROR_TOO_MANY_OPEN_FILES 4\n#define ERROR_ACCESS_DENIED 5\n#define ERROR_INVALID_HANDLE 6\n#define ERROR_ARENA_TRASHED 7\n#define ERROR_NOT_ENOUGH_MEMORY 8\n#define ERROR_INVALID_BLOCK 9\n#define ERROR_BAD_ENVIRONMENT 10\n#define ERROR_BAD_FORMAT 11\n#define ERROR_INVALID_ACCESS 12\n#define ERROR_INVALID_DATA 13\n#define ERROR_OUTOFMEMORY 14\n#define ERROR_INVALID_DRIVE 15\n#define ERROR_CURRENT_DIRECTORY 16\n#define ERROR_NOT_SAME_DEVICE 17\n#define ERROR_NO_MORE_FILES 18\n#define ERROR_WRITE_PROTECT 19\n#define ERROR_BAD_UNIT 20\n#define ERROR_NOT_READY 21\n#define ERROR_BAD_COMMAND 22\n#define ERROR_CRC 23\n#define ERROR_BAD_LENGTH 24\n#define ERROR_SEEK 25\n#define ERROR_NOT_DOS_DISK 26\n#define ERROR_SECTOR_NOT_FOUND 27\n#define ERROR_OUT_OF_PAPER 28\n#define ERROR_WRITE_FAULT 29\n#define ERROR_READ_FAULT 30\n#define ERROR_GEN_FAILURE 31\n#define ERROR_SHARING_VIOLATION 32\n#define ERROR_LOCK_VIOLATION 33\n#define ERROR_WRONG_DISK 34\n#define ERROR_SHARING_BUFFER_EXCEEDED 36\n#define ERROR_HANDLE_EOF 38\n#define ERROR_HANDLE_DISK_FULL 39\n#define ERROR_NOT_SUPPORTED 50\n#define ERROR_REM_NOT_LIST 51\n#define ERROR_DUP_NAME 52\n#define ERROR_BAD_NETPATH 53\n#define ERROR_NETWORK_BUSY 54\n#define ERROR_DEV_NOT_EXIST 55\n#define ERROR_TOO_MANY_CMDS 56\n#define ERROR_ADAP_HDW_ERR 57\n#define ERROR_BAD_NET_RESP 58\n#define ERROR_UNEXP_NET_ERR 59\n#define ERROR_BAD_REM_ADAP 60\n#define ERROR_PRINTQ_FULL 61\n#define ERROR_NO_SPOOL_SPACE 62\n#define ERROR_PRINT_CANCELLED 63\n#define ERROR_NETNAME_DELETED 64\n#define ERROR_NETWORK_ACCESS_DENIED 65\n#define ERROR_BAD_DEV_TYPE 66\n#define ERROR_BAD_NET_NAME 67\n#define ERROR_TOO_MANY_NAMES 68\n#define ERROR_TOO_MANY_SESS 69\n#define ERROR_SHARING_PAUSED 70\n#define ERROR_REQ_NOT_ACCEP 71\n#define ERROR_REDIR_PAUSED 72\n#define ERROR_FILE_EXISTS 80\n#define ERROR_CANNOT_MAKE 82\n#define ERROR_FAIL_I24 83\n#define ERROR_OUT_OF_STRUCTURES 84\n#define ERROR_ALREADY_ASSIGNED 85\n#define ERROR_INVALID_PASSWORD 86\n#define ERROR_INVALID_PARAMETER 87\n#define ERROR_NET_WRITE_FAULT 88\n#define ERROR_NO_PROC_SLOTS 89\n#define ERROR_TOO_MANY_SEMAPHORES 100\n#define ERROR_EXCL_SEM_ALREADY_OWNED 101\n#define ERROR_SEM_IS_SET 102\n#define ERROR_TOO_MANY_SEM_REQUESTS 103\n#define ERROR_INVALID_AT_INTERRUPT_TIME 104\n#define ERROR_SEM_OWNER_DIED 105\n#define ERROR_SEM_USER_LIMIT 106\n#define ERROR_DISK_CHANGE 107\n#define ERROR_DRIVE_LOCKED 108\n#define ERROR_BROKEN_PIPE 109\n#define ERROR_OPEN_FAILED 110\n#define ERROR_BUFFER_OVERFLOW 111\n#define ERROR_DISK_FULL 112\n#define ERROR_NO_MORE_SEARCH_HANDLES 113\n#define ERROR_INVALID_TARGET_HANDLE 114\n#define ERROR_INVALID_CATEGORY 117\n#define ERROR_INVALID_VERIFY_SWITCH 118\n#define ERROR_BAD_DRIVER_LEVEL 119\n#define ERROR_CALL_NOT_IMPLEMENTED 120\n#define ERROR_SEM_TIMEOUT 121\n#define ERROR_INSUFFICIENT_BUFFER 122\n#define ERROR_INVALID_NAME 123\n#define ERROR_INVALID_LEVEL 124\n#define ERROR_NO_VOLUME_LABEL 125\n#define ERROR_MOD_NOT_FOUND 126\n#define ERROR_PROC_NOT_FOUND 127\n#define ERROR_WAIT_NO_CHILDREN 128\n#define ERROR_CHILD_NOT_COMPLETE 129\n#define ERROR_DIRECT_ACCESS_HANDLE 130\n#define ERROR_NEGATIVE_SEEK 131\n#define ERROR_SEEK_ON_DEVICE 132\n#define ERROR_IS_JOIN_TARGET 133\n#define ERROR_IS_JOINED 134\n#define ERROR_IS_SUBSTED 135\n#define ERROR_NOT_JOINED 136\n#define ERROR_NOT_SUBSTED 137\n#define ERROR_JOIN_TO_JOIN 138\n#define ERROR_SUBST_TO_SUBST 139\n#define ERROR_JOIN_TO_SUBST 140\n#define ERROR_SUBST_TO_JOIN 141\n#define ERROR_BUSY_DRIVE 142\n#define ERROR_SAME_DRIVE 143\n#define ERROR_DIR_NOT_ROOT 144\n#define ERROR_DIR_NOT_EMPTY 145\n#define ERROR_IS_SUBST_PATH 146\n#define ERROR_IS_JOIN_PATH 147\n#define ERROR_PATH_BUSY 148\n#define ERROR_IS_SUBST_TARGET 149\n#define ERROR_SYSTEM_TRACE 150\n#define ERROR_INVALID_EVENT_COUNT 151\n#define ERROR_TOO_MANY_MUXWAITERS 152\n#define ERROR_INVALID_LIST_FORMAT 153\n#define ERROR_LABEL_TOO_LONG 154\n#define ERROR_TOO_MANY_TCBS 155\n#define ERROR_SIGNAL_REFUSED 156\n#define ERROR_DISCARDED 157\n#define ERROR_NOT_LOCKED 158\n#define ERROR_BAD_THREADID_ADDR 159\n#define ERROR_BAD_ARGUMENTS 160\n#define ERROR_BAD_PATHNAME 161\n#define ERROR_SIGNAL_PENDING 162\n#define ERROR_MAX_THRDS_REACHED 164\n#define ERROR_LOCK_FAILED 167\n#define ERROR_BUSY 170\n#define ERROR_CANCEL_VIOLATION 173\n#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174\n#define ERROR_INVALID_SEGMENT_NUMBER 180\n#define ERROR_INVALID_ORDINAL 182\n#define ERROR_ALREADY_EXISTS 183\n#define ERROR_INVALID_FLAG_NUMBER 186\n#define ERROR_SEM_NOT_FOUND 187\n#define ERROR_INVALID_STARTING_CODESEG 188\n#define ERROR_INVALID_STACKSEG 189\n#define ERROR_INVALID_MODULETYPE 190\n#define ERROR_INVALID_EXE_SIGNATURE 191\n#define ERROR_EXE_MARKED_INVALID 192\n#define ERROR_EXE_MACHINE_TYPE_MISMATCH 216\n#define ERROR_BAD_EXE_FORMAT 193\n#define ERROR_ITERATED_DATA_EXCEEDS_64k 194\n#define ERROR_INVALID_MINALLOCSIZE 195\n#define ERROR_DYNLINK_FROM_INVALID_RING 196\n#define ERROR_IOPL_NOT_ENABLED 197\n#define ERROR_INVALID_SEGDPL 198\n#define ERROR_AUTODATASEG_EXCEEDS_64k 199\n#define ERROR_RING2SEG_MUST_BE_MOVABLE 200\n#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM 201\n#define ERROR_INFLOOP_IN_RELOC_CHAIN 202\n#define ERROR_ENVVAR_NOT_FOUND 203\n#define ERROR_NO_SIGNAL_SENT 205\n#define ERROR_FILENAME_EXCED_RANGE 206\n#define ERROR_RING2_STACK_IN_USE 207\n#define ERROR_META_EXPANSION_TOO_LONG 208\n#define ERROR_INVALID_SIGNAL_NUMBER 209\n#define ERROR_THREAD_1_INACTIVE 210\n#define ERROR_LOCKED 212\n#define ERROR_TOO_MANY_MODULES 214\n#define ERROR_NESTING_NOT_ALLOWED 215\n#define ERROR_BAD_PIPE 230\n#define ERROR_PIPE_BUSY 231\n#define ERROR_NO_DATA 232\n#define ERROR_PIPE_NOT_CONNECTED 233\n#define ERROR_MORE_DATA 234\n#define ERROR_VC_DISCONNECTED 240\n#define ERROR_INVALID_EA_NAME 254\n#define ERROR_EA_LIST_INCONSISTENT 255\n#define ERROR_NO_MORE_ITEMS 259\n#define ERROR_CANNOT_COPY 266\n#define ERROR_DIRECTORY 267\n#define ERROR_EAS_DIDNT_FIT 275\n#define ERROR_EA_FILE_CORRUPT 276\n#define ERROR_EA_TABLE_FULL 277\n#define ERROR_INVALID_EA_HANDLE 278\n#define ERROR_EAS_NOT_SUPPORTED 282\n#define ERROR_NOT_OWNER 288\n#define ERROR_TOO_MANY_POSTS 298\n#define ERROR_PARTIAL_COPY 299\n#define ERROR_MR_MID_NOT_FOUND 317\n#define ERROR_INVALID_ADDRESS 487\n#define ERROR_ARITHMETIC_OVERFLOW 534\n#define ERROR_PIPE_CONNECTED 535\n#define ERROR_PIPE_LISTENING 536\n#define ERROR_EA_ACCESS_DENIED 994\n#define ERROR_OPERATION_ABORTED 995\n#define ERROR_IO_INCOMPLETE 996\n#define ERROR_IO_PENDING 997\n#define ERROR_NOACCESS 998\n#define ERROR_SWAPERROR 999\n#define ERROR_STACK_OVERFLOW 1001\n#define ERROR_INVALID_MESSAGE 1002\n#define ERROR_CAN_NOT_COMPLETE 1003\n#define ERROR_INVALID_FLAGS 1004\n#define ERROR_UNRECOGNIZED_VOLUME 1005\n#define ERROR_FILE_INVALID 1006\n#define ERROR_FULLSCREEN_MODE 1007\n#define ERROR_NO_TOKEN 1008\n#define ERROR_BADDB 1009\n#define ERROR_BADKEY 1010\n#define ERROR_CANTOPEN 1011\n#define ERROR_CANTREAD 1012\n#define ERROR_CANTWRITE 1013\n#define ERROR_REGISTRY_RECOVERED 1014\n#define ERROR_REGISTRY_CORRUPT 1015\n#define ERROR_REGISTRY_IO_FAILED 1016\n#define ERROR_NOT_REGISTRY_FILE 1017\n#define ERROR_KEY_DELETED 1018\n#define ERROR_NO_LOG_SPACE 1019\n#define ERROR_KEY_HAS_CHILDREN 1020\n#define ERROR_CHILD_MUST_BE_VOLATILE 1021\n#define ERROR_NOTIFY_ENUM_DIR 1022\n#define ERROR_DEPENDENT_SERVICES_RUNNING 1051\n#define ERROR_INVALID_SERVICE_CONTROL 1052\n#define ERROR_SERVICE_REQUEST_TIMEOUT 1053\n#define ERROR_SERVICE_NO_THREAD 1054\n#define ERROR_SERVICE_DATABASE_LOCKED 1055\n#define ERROR_SERVICE_ALREADY_RUNNING 1056\n#define ERROR_INVALID_SERVICE_ACCOUNT 1057\n#define ERROR_SERVICE_DISABLED 1058\n#define ERROR_CIRCULAR_DEPENDENCY 1059\n#define ERROR_SERVICE_DOES_NOT_EXIST 1060\n#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061\n#define ERROR_SERVICE_NOT_ACTIVE 1062\n#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063\n#define ERROR_EXCEPTION_IN_SERVICE 1064\n#define ERROR_DATABASE_DOES_NOT_EXIST 1065\n#define ERROR_SERVICE_SPECIFIC_ERROR 1066\n#define ERROR_PROCESS_ABORTED 1067\n#define ERROR_SERVICE_DEPENDENCY_FAIL 1068\n#define ERROR_SERVICE_LOGON_FAILED 1069\n#define ERROR_SERVICE_START_HANG 1070\n#define ERROR_INVALID_SERVICE_LOCK 1071\n#define ERROR_SERVICE_MARKED_FOR_DELETE 1072\n#define ERROR_SERVICE_EXISTS 1073\n#define ERROR_ALREADY_RUNNING_LKG 1074\n#define ERROR_SERVICE_DEPENDENCY_DELETED 1075\n#define ERROR_BOOT_ALREADY_ACCEPTED 1076\n#define ERROR_SERVICE_NEVER_STARTED 1077\n#define ERROR_DUPLICATE_SERVICE_NAME 1078\n#define ERROR_DIFFERENT_SERVICE_ACCOUNT 1079\n#define ERROR_END_OF_MEDIA 1100\n#define ERROR_FILEMARK_DETECTED 1101\n#define ERROR_BEGINNING_OF_MEDIA 1102\n#define ERROR_SETMARK_DETECTED 1103\n#define ERROR_NO_DATA_DETECTED 1104\n#define ERROR_PARTITION_FAILURE 1105\n#define ERROR_INVALID_BLOCK_LENGTH 1106\n\n#define ERROR_DEVICE_NOT_PARTITIONED 1107\n#define ERROR_UNABLE_TO_LOCK_MEDIA 1108\n#define ERROR_UNABLE_TO_UNLOAD_MEDIA 1109\n#define ERROR_MEDIA_CHANGED 1110\n#define ERROR_BUS_RESET 1111\n#define ERROR_NO_MEDIA_IN_DRIVE 1112\n#define ERROR_NO_UNICODE_TRANSLATION 1113\n#define ERROR_DLL_INIT_FAILED 1114\n#define ERROR_SHUTDOWN_IN_PROGRESS 1115\n#define ERROR_NO_SHUTDOWN_IN_PROGRESS 1116\n#define ERROR_IO_DEVICE 1117\n#define ERROR_SERIAL_NO_DEVICE 1118\n#define ERROR_IRQ_BUSY 1119\n#define ERROR_MORE_WRITES 1120\n#define ERROR_COUNTER_TIMEOUT 1121\n#define ERROR_FLOPPY_ID_MARK_NOT_FOUND 1122\n#define ERROR_FLOPPY_WRONG_CYLINDER 1123\n#define ERROR_FLOPPY_UNKNOWN_ERROR 1124\n#define ERROR_FLOPPY_BAD_REGISTERS 1125\n#define ERROR_DISK_RECALIBRATE_FAILED 1126\n#define ERROR_DISK_OPERATION_FAILED 1127\n#define ERROR_DISK_RESET_FAILED 1128\n#define ERROR_EOM_OVERFLOW 1129\n#define ERROR_NOT_ENOUGH_SERVER_MEMORY 1130\n#define ERROR_POSSIBLE_DEADLOCK 1131\n#define ERROR_MAPPED_ALIGNMENT 1132\n#define ERROR_SET_POWER_STATE_VETOED 1140\n#define ERROR_SET_POWER_STATE_FAILED 1141\n#define ERROR_TOO_MANY_LINKS 1142\n#define ERROR_OLD_WIN_VERSION 1150\n#define ERROR_APP_WRONG_OS 1151\n#define ERROR_SINGLE_INSTANCE_APP 1152\n#define ERROR_RMODE_APP 1153\n#define ERROR_INVALID_DLL 1154\n#define ERROR_NO_ASSOCIATION 1155\n#define ERROR_DDE_FAIL 1156\n#define ERROR_DLL_NOT_FOUND 1157\n#define ERROR_BAD_USERNAME 2202\n#define ERROR_NOT_CONNECTED 2250\n#define ERROR_OPEN_FILES 2401\n#define ERROR_ACTIVE_CONNECTIONS 2402\n#define ERROR_DEVICE_IN_USE 2404\n#define ERROR_BAD_DEVICE 1200\n#define ERROR_CONNECTION_UNAVAIL 1201\n#define ERROR_DEVICE_ALREADY_REMEMBERED 1202\n#define ERROR_NO_NET_OR_BAD_PATH 1203\n#define ERROR_BAD_PROVIDER 1204\n#define ERROR_CANNOT_OPEN_PROFILE 1205\n#define ERROR_BAD_PROFILE 1206\n#define ERROR_NOT_CONTAINER 1207\n#define ERROR_EXTENDED_ERROR 1208\n#define ERROR_INVALID_GROUPNAME 1209\n#define ERROR_INVALID_COMPUTERNAME 1210\n#define ERROR_INVALID_EVENTNAME 1211\n#define ERROR_INVALID_DOMAINNAME 1212\n#define ERROR_INVALID_SERVICENAME 1213\n#define ERROR_INVALID_NETNAME 1214\n#define ERROR_INVALID_SHARENAME 1215\n#define ERROR_INVALID_PASSWORDNAME 1216\n#define ERROR_INVALID_MESSAGENAME 1217\n#define ERROR_INVALID_MESSAGEDEST 1218\n#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219\n#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220\n#define ERROR_DUP_DOMAINNAME 1221\n#define ERROR_NO_NETWORK 1222\n#define ERROR_CANCELLED 1223\n#define ERROR_USER_MAPPED_FILE 1224\n#define ERROR_CONNECTION_REFUSED 1225\n#define ERROR_GRACEFUL_DISCONNECT 1226\n#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227\n#define ERROR_ADDRESS_NOT_ASSOCIATED 1228\n#define ERROR_CONNECTION_INVALID 1229\n#define ERROR_CONNECTION_ACTIVE 1230\n#define ERROR_NETWORK_UNREACHABLE 1231\n#define ERROR_HOST_UNREACHABLE 1232\n#define ERROR_PROTOCOL_UNREACHABLE 1233\n#define ERROR_PORT_UNREACHABLE 1234\n#define ERROR_REQUEST_ABORTED 1235\n#define ERROR_CONNECTION_ABORTED 1236\n#define ERROR_RETRY 1237\n#define ERROR_CONNECTION_COUNT_LIMIT 1238\n#define ERROR_LOGIN_TIME_RESTRICTION 1239\n#define ERROR_LOGIN_WKSTA_RESTRICTION 1240\n#define ERROR_INCORRECT_ADDRESS 1241\n#define ERROR_ALREADY_REGISTERED 1242\n#define ERROR_SERVICE_NOT_FOUND 1243\n#define ERROR_NOT_AUTHENTICATED 1244\n#define ERROR_NOT_LOGGED_ON 1245\n#define ERROR_CONTINUE 1246\n#define ERROR_ALREADY_INITIALIZED 1247\n#define ERROR_NO_MORE_DEVICES 1248\n#define ERROR_NOT_ALL_ASSIGNED 1300\n#define ERROR_SOME_NOT_MAPPED 1301\n#define ERROR_NO_QUOTAS_FOR_ACCOUNT 1302\n#define ERROR_LOCAL_USER_SESSION_KEY 1303\n#define ERROR_NULL_LM_PASSWORD 1304\n#define ERROR_UNKNOWN_REVISION 1305\n#define ERROR_REVISION_MISMATCH 1306\n#define ERROR_INVALID_OWNER 1307\n#define ERROR_INVALID_PRIMARY_GROUP 1308\n#define ERROR_NO_IMPERSONATION_TOKEN 1309\n#define ERROR_CANT_DISABLE_MANDATORY 1310\n#define ERROR_NO_LOGON_SERVERS 1311\n#define ERROR_NO_SUCH_LOGON_SESSION 1312\n#define ERROR_NO_SUCH_PRIVILEGE 1313\n#define ERROR_PRIVILEGE_NOT_HELD 1314\n#define ERROR_INVALID_ACCOUNT_NAME 1315\n#define ERROR_USER_EXISTS 1316\n#define ERROR_NO_SUCH_USER 1317\n#define ERROR_GROUP_EXISTS 1318\n#define ERROR_NO_SUCH_GROUP 1319\n#define ERROR_MEMBER_IN_GROUP 1320\n#define ERROR_MEMBER_NOT_IN_GROUP 1321\n#define ERROR_LAST_ADMIN 1322\n#define ERROR_WRONG_PASSWORD 1323\n#define ERROR_ILL_FORMED_PASSWORD 1324\n#define ERROR_PASSWORD_RESTRICTION 1325\n#define ERROR_LOGON_FAILURE 1326\n#define ERROR_ACCOUNT_RESTRICTION 1327\n#define ERROR_INVALID_LOGON_HOURS 1328\n#define ERROR_INVALID_WORKSTATION 1329\n#define ERROR_PASSWORD_EXPIRED 1330\n#define ERROR_ACCOUNT_DISABLED 1331\n#define ERROR_NONE_MAPPED 1332\n#define ERROR_TOO_MANY_LUIDS_REQUESTED 1333\n#define ERROR_LUIDS_EXHAUSTED 1334\n#define ERROR_INVALID_SUB_AUTHORITY 1335\n#define ERROR_INVALID_ACL 1336\n#define ERROR_INVALID_SID 1337\n#define ERROR_INVALID_SECURITY_DESCR 1338\n#define ERROR_BAD_INHERITANCE_ACL 1340\n#define ERROR_SERVER_DISABLED 1341\n#define ERROR_SERVER_NOT_DISABLED 1342\n#define ERROR_INVALID_ID_AUTHORITY 1343\n#define ERROR_ALLOTTED_SPACE_EXCEEDED 1344\n#define ERROR_INVALID_GROUP_ATTRIBUTES 1345\n#define ERROR_BAD_IMPERSONATION_LEVEL 1346\n#define ERROR_CANT_OPEN_ANONYMOUS 1347\n#define ERROR_BAD_VALIDATION_CLASS 1348\n#define ERROR_BAD_TOKEN_TYPE 1349\n#define ERROR_NO_SECURITY_ON_OBJECT 1350\n#define ERROR_CANT_ACCESS_DOMAIN_INFO 1351\n#define ERROR_INVALID_SERVER_STATE 1352\n#define ERROR_INVALID_DOMAIN_STATE 1353\n#define ERROR_INVALID_DOMAIN_ROLE 1354\n#define ERROR_NO_SUCH_DOMAIN 1355\n#define ERROR_DOMAIN_EXISTS 1356\n#define ERROR_DOMAIN_LIMIT_EXCEEDED 1357\n#define ERROR_INTERNAL_DB_CORRUPTION 1358\n#define ERROR_INTERNAL_ERROR 1359\n#define ERROR_GENERIC_NOT_MAPPED 1360\n#define ERROR_BAD_DESCRIPTOR_FORMAT 1361\n#define ERROR_NOT_LOGON_PROCESS 1362\n#define ERROR_LOGON_SESSION_EXISTS 1363\n#define ERROR_NO_SUCH_PACKAGE 1364\n#define ERROR_BAD_LOGON_SESSION_STATE 1365\n#define ERROR_LOGON_SESSION_COLLISION 1366\n#define ERROR_INVALID_LOGON_TYPE 1367\n#define ERROR_CANNOT_IMPERSONATE 1368\n#define ERROR_RXACT_INVALID_STATE 1369\n#define ERROR_RXACT_COMMIT_FAILURE 1370\n#define ERROR_SPECIAL_ACCOUNT 1371\n#define ERROR_SPECIAL_GROUP 1372\n#define ERROR_SPECIAL_USER 1373\n#define ERROR_MEMBERS_PRIMARY_GROUP 1374\n#define ERROR_TOKEN_ALREADY_IN_USE 1375\n#define ERROR_NO_SUCH_ALIAS 1376\n#define ERROR_MEMBER_NOT_IN_ALIAS 1377\n#define ERROR_MEMBER_IN_ALIAS 1378\n#define ERROR_ALIAS_EXISTS 1379\n#define ERROR_LOGON_NOT_GRANTED 1380\n#define ERROR_TOO_MANY_SECRETS 1381\n#define ERROR_SECRET_TOO_LONG 1382\n#define ERROR_INTERNAL_DB_ERROR 1383\n#define ERROR_TOO_MANY_CONTEXT_IDS 1384\n#define ERROR_LOGON_TYPE_NOT_GRANTED 1385\n#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386\n#define ERROR_NO_SUCH_MEMBER 1387\n#define ERROR_INVALID_MEMBER 1388\n#define ERROR_TOO_MANY_SIDS 1389\n#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390\n#define ERROR_NO_INHERITANCE 1391\n#define ERROR_FILE_CORRUPT 1392\n#define ERROR_DISK_CORRUPT 1393\n#define ERROR_NO_USER_SESSION_KEY 1394\n#define ERROR_LICENSE_QUOTA_EXCEEDED 1395\n#define ERROR_INVALID_WINDOW_HANDLE 1400\n#define ERROR_INVALID_MENU_HANDLE 1401\n#define ERROR_INVALID_CURSOR_HANDLE 1402\n#define ERROR_INVALID_ACCEL_HANDLE 1403\n#define ERROR_INVALID_HOOK_HANDLE 1404\n#define ERROR_INVALID_DWP_HANDLE 1405\n#define ERROR_TLW_WITH_WSCHILD 1406\n#define ERROR_CANNOT_FIND_WND_CLASS 1407\n#define ERROR_WINDOW_OF_OTHER_THREAD 1408\n#define ERROR_HOTKEY_ALREADY_REGISTERED 1409\n#define ERROR_CLASS_ALREADY_EXISTS 1410\n#define ERROR_CLASS_DOES_NOT_EXIST 1411\n#define ERROR_CLASS_HAS_WINDOWS 1412\n#define ERROR_INVALID_INDEX 1413\n#define ERROR_INVALID_ICON_HANDLE 1414\n#define ERROR_PRIVATE_DIALOG_INDEX 1415\n#define ERROR_LISTBOX_ID_NOT_FOUND 1416\n#define ERROR_NO_WILDCARD_CHARACTERS 1417\n#define ERROR_CLIPBOARD_NOT_OPEN 1418\n#define ERROR_HOTKEY_NOT_REGISTERED 1419\n#define ERROR_WINDOW_NOT_DIALOG 1420\n#define ERROR_CONTROL_ID_NOT_FOUND 1421\n#define ERROR_INVALID_COMBOBOX_MESSAGE 1422\n#define ERROR_WINDOW_NOT_COMBOBOX 1423\n#define ERROR_INVALID_EDIT_HEIGHT 1424\n#define ERROR_DC_NOT_FOUND 1425\n#define ERROR_INVALID_HOOK_FILTER 1426\n#define ERROR_INVALID_FILTER_PROC 1427\n#define ERROR_HOOK_NEEDS_HMOD 1428\n#define ERROR_GLOBAL_ONLY_HOOK 1429\n#define ERROR_JOURNAL_HOOK_SET 1430\n#define ERROR_HOOK_NOT_INSTALLED 1431\n#define ERROR_INVALID_LB_MESSAGE 1432\n#define ERROR_SETCOUNT_ON_BAD_LB 1433\n#define ERROR_LB_WITHOUT_TABSTOPS 1434\n#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435\n#define ERROR_CHILD_WINDOW_MENU 1436\n#define ERROR_NO_SYSTEM_MENU 1437\n#define ERROR_INVALID_MSGBOX_STYLE 1438\n#define ERROR_INVALID_SPI_VALUE 1439\n#define ERROR_SCREEN_ALREADY_LOCKED 1440\n#define ERROR_HWNDS_HAVE_DIFF_PARENT 1441\n#define ERROR_NOT_CHILD_WINDOW 1442\n#define ERROR_INVALID_GW_COMMAND 1443\n#define ERROR_INVALID_THREAD_ID 1444\n#define ERROR_NON_MDICHILD_WINDOW 1445\n#define ERROR_POPUP_ALREADY_ACTIVE 1446\n#define ERROR_NO_SCROLLBARS 1447\n#define ERROR_INVALID_SCROLLBAR_RANGE 1448\n#define ERROR_INVALID_SHOWWIN_COMMAND 1449\n#define ERROR_NO_SYSTEM_RESOURCES 1450\n#define ERROR_NONPAGED_SYSTEM_RESOURCES 1451\n#define ERROR_PAGED_SYSTEM_RESOURCES 1452\n#define ERROR_WORKING_SET_QUOTA 1453\n#define ERROR_PAGEFILE_QUOTA 1454\n#define ERROR_COMMITMENT_LIMIT 1455\n#define ERROR_MENU_ITEM_NOT_FOUND 1456\n#define ERROR_INVALID_KEYBOARD_HANDLE 1457\n#define ERROR_HOOK_TYPE_NOT_ALLOWED 1458\n#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459\n#define ERROR_EVENTLOG_FILE_CORRUPT 1500\n#define ERROR_EVENTLOG_CANT_START 1501\n#define ERROR_LOG_FILE_FULL 1502\n#define ERROR_EVENTLOG_FILE_CHANGED 1503\n#define RPC_S_INVALID_STRING_BINDING 1700\n#define RPC_S_WRONG_KIND_OF_BINDING 1701\n#define RPC_S_INVALID_BINDING 1702\n#define RPC_S_PROTSEQ_NOT_SUPPORTED 1703\n#define RPC_S_INVALID_RPC_PROTSEQ 1704\n#define RPC_S_INVALID_STRING_UUID 1705\n#define RPC_S_INVALID_ENDPOINT_FORMAT 1706\n#define RPC_S_INVALID_NET_ADDR 1707\n#define RPC_S_NO_ENDPOINT_FOUND 1708\n#define RPC_S_INVALID_TIMEOUT 1709\n#define RPC_S_OBJECT_NOT_FOUND 1710\n#define RPC_S_ALREADY_REGISTERED 1711\n#define RPC_S_TYPE_ALREADY_REGISTERED 1712\n#define RPC_S_ALREADY_LISTENING 1713\n#define RPC_S_NO_PROTSEQS_REGISTERED 1714\n#define RPC_S_NOT_LISTENING 1715\n#define RPC_S_UNKNOWN_MGR_TYPE 1716\n#define RPC_S_UNKNOWN_IF 1717\n#define RPC_S_NO_BINDINGS 1718\n#define RPC_S_NO_PROTSEQS 1719\n#define RPC_S_CANT_CREATE_ENDPOINT 1720\n#define RPC_S_OUT_OF_RESOURCES 1721\n#define RPC_S_SERVER_UNAVAILABLE 1722\n#define RPC_S_SERVER_TOO_BUSY 1723\n#define RPC_S_INVALID_NETWORK_OPTIONS 1724\n#define RPC_S_NO_CALL_ACTIVE 1725\n#define RPC_S_CALL_FAILED 1726\n#define RPC_S_CALL_FAILED_DNE 1727\n#define RPC_S_PROTOCOL_ERROR 1728\n#define RPC_S_UNSUPPORTED_TRANS_SYN 1730\n#define RPC_S_UNSUPPORTED_TYPE 1732\n#define RPC_S_INVALID_TAG 1733\n#define RPC_S_INVALID_BOUND 1734\n#define RPC_S_NO_ENTRY_NAME 1735\n#define RPC_S_INVALID_NAME_SYNTAX 1736\n#define RPC_S_UNSUPPORTED_NAME_SYNTAX 1737\n#define RPC_S_UUID_NO_ADDRESS 1739\n#define RPC_S_DUPLICATE_ENDPOINT 1740\n#define RPC_S_UNKNOWN_AUTHN_TYPE 1741\n#define RPC_S_MAX_CALLS_TOO_SMALL 1742\n#define RPC_S_STRING_TOO_LONG 1743\n#define RPC_S_PROTSEQ_NOT_FOUND 1744\n#define RPC_S_PROCNUM_OUT_OF_RANGE 1745\n#define RPC_S_BINDING_HAS_NO_AUTH 1746\n#define RPC_S_UNKNOWN_AUTHN_SERVICE 1747\n#define RPC_S_UNKNOWN_AUTHN_LEVEL 1748\n#define RPC_S_INVALID_AUTH_IDENTITY 1749\n#define RPC_S_UNKNOWN_AUTHZ_SERVICE 1750\n#define EPT_S_INVALID_ENTRY 1751\n#define EPT_S_CANT_PERFORM_OP 1752\n#define EPT_S_NOT_REGISTERED 1753\n#define RPC_S_NOTHING_TO_EXPORT 1754\n#define RPC_S_INCOMPLETE_NAME 1755\n#define RPC_S_INVALID_VERS_OPTION 1756\n#define RPC_S_NO_MORE_MEMBERS 1757\n#define RPC_S_NOT_ALL_OBJS_UNEXPORTED 1758\n#define RPC_S_INTERFACE_NOT_FOUND 1759\n#define RPC_S_ENTRY_ALREADY_EXISTS 1760\n#define RPC_S_ENTRY_NOT_FOUND 1761\n#define RPC_S_NAME_SERVICE_UNAVAILABLE 1762\n#define RPC_S_INVALID_NAF_ID 1763\n#define RPC_S_CANNOT_SUPPORT 1764\n#define RPC_S_NO_CONTEXT_AVAILABLE 1765\n#define RPC_S_INTERNAL_ERROR 1766\n#define RPC_S_ZERO_DIVIDE 1767\n#define RPC_S_ADDRESS_ERROR 1768\n#define RPC_S_FP_DIV_ZERO 1769\n#define RPC_S_FP_UNDERFLOW 1770\n#define RPC_S_FP_OVERFLOW 1771\n#define RPC_X_NO_MORE_ENTRIES 1772\n#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL 1773\n#define RPC_X_SS_CHAR_TRANS_SHORT_FILE 1774\n#define RPC_X_SS_IN_NULL_CONTEXT 1775\n#define RPC_X_SS_CONTEXT_DAMAGED 1777\n#define RPC_X_SS_HANDLES_MISMATCH 1778\n#define RPC_X_SS_CANNOT_GET_CALL_HANDLE 1779\n#define RPC_X_NULL_REF_POINTER 1780\n#define RPC_X_ENUM_VALUE_OUT_OF_RANGE 1781\n#define RPC_X_BYTE_COUNT_TOO_SMALL 1782\n#define RPC_X_BAD_STUB_DATA 1783\n#define ERROR_INVALID_USER_BUFFER 1784\n#define ERROR_UNRECOGNIZED_MEDIA 1785\n#define ERROR_NO_TRUST_LSA_SECRET 1786\n#define ERROR_NO_TRUST_SAM_ACCOUNT 1787\n#define ERROR_TRUSTED_DOMAIN_FAILURE 1788\n#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789\n#define ERROR_TRUST_FAILURE 1790\n#define RPC_S_CALL_IN_PROGRESS 1791\n#define ERROR_NETLOGON_NOT_STARTED 1792\n#define ERROR_ACCOUNT_EXPIRED 1793\n#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794\n#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795\n#define ERROR_UNKNOWN_PORT 1796\n#define ERROR_UNKNOWN_PRINTER_DRIVER 1797\n#define ERROR_UNKNOWN_PRINTPROCESSOR 1798\n#define ERROR_INVALID_SEPARATOR_FILE 1799\n#define ERROR_INVALID_PRIORITY 1800\n#define ERROR_INVALID_PRINTER_NAME 1801\n#define ERROR_PRINTER_ALREADY_EXISTS 1802\n#define ERROR_INVALID_PRINTER_COMMAND 1803\n#define ERROR_INVALID_DATATYPE 1804\n#define ERROR_INVALID_ENVIRONMENT 1805\n#define RPC_S_NO_MORE_BINDINGS 1806\n#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807\n#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808\n#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809\n#define ERROR_DOMAIN_TRUST_INCONSISTENT 1810\n#define ERROR_SERVER_HAS_OPEN_HANDLES 1811\n#define ERROR_RESOURCE_DATA_NOT_FOUND 1812\n#define ERROR_RESOURCE_TYPE_NOT_FOUND 1813\n#define ERROR_RESOURCE_NAME_NOT_FOUND 1814\n#define ERROR_RESOURCE_LANG_NOT_FOUND 1815\n#define ERROR_NOT_ENOUGH_QUOTA 1816\n#define RPC_S_NO_INTERFACES 1817\n#define RPC_S_CALL_CANCELLED 1818\n#define RPC_S_BINDING_INCOMPLETE 1819\n#define RPC_S_COMM_FAILURE 1820\n#define RPC_S_UNSUPPORTED_AUTHN_LEVEL 1821\n#define RPC_S_NO_PRINC_NAME 1822\n#define RPC_S_NOT_RPC_ERROR 1823\n#define RPC_S_UUID_LOCAL_ONLY 1824\n#define RPC_S_SEC_PKG_ERROR 1825\n#define RPC_S_NOT_CANCELLED 1826\n#define RPC_X_INVALID_ES_ACTION 1827\n#define RPC_X_WRONG_ES_VERSION 1828\n#define RPC_X_WRONG_STUB_VERSION 1829\n#define RPC_S_GROUP_MEMBER_NOT_FOUND 1898\n#define EPT_S_CANT_CREATE 1899\n#define RPC_S_INVALID_OBJECT 1900\n#define ERROR_INVALID_TIME 1901\n#define ERROR_INVALID_FORM_NAME 1902\n#define ERROR_INVALID_FORM_SIZE 1903\n#define ERROR_ALREADY_WAITING 1904\n#define ERROR_PRINTER_DELETED 1905\n#define ERROR_INVALID_PRINTER_STATE 1906\n#define ERROR_PASSWORD_MUST_CHANGE 1907\n#define ERROR_DOMAIN_CONTROLLER_NOT_FOUND 1908\n#define ERROR_ACCOUNT_LOCKED_OUT 1909\n#define ERROR_NO_BROWSER_SERVERS_FOUND 6118\n#define ERROR_INVALID_PIXEL_FORMAT 2000\n#define ERROR_BAD_DRIVER 2001\n#define ERROR_INVALID_WINDOW_STYLE 2002\n#define ERROR_METAFILE_NOT_SUPPORTED 2003\n#define ERROR_TRANSFORM_NOT_SUPPORTED 2004\n#define ERROR_CLIPPING_NOT_SUPPORTED 2005\n#define ERROR_UNKNOWN_PRINT_MONITOR 3000\n#define ERROR_PRINTER_DRIVER_IN_USE 3001\n#define ERROR_SPOOL_FILE_NOT_FOUND 3002\n#define ERROR_SPL_NO_STARTDOC 3003\n#define ERROR_SPL_NO_ADDJOB 3004\n#define ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED 3005\n#define ERROR_PRINT_MONITOR_ALREADY_INSTALLED 3006\n#define ERROR_INVALID_PRINT_MONITOR 3007\n#define ERROR_PRINT_MONITOR_IN_USE 3008\n#define ERROR_PRINTER_HAS_JOBS_QUEUED 3009\n#define ERROR_SUCCESS_REBOOT_REQUIRED 3010\n#define ERROR_SUCCESS_RESTART_REQUIRED 3011\n#define ERROR_WINS_INTERNAL 4000\n#define ERROR_CAN_NOT_DEL_LOCAL_WINS 4001\n#define ERROR_STATIC_INIT 4002\n#define ERROR_INC_BACKUP 4003\n#define ERROR_FULL_BACKUP 4004\n#define ERROR_REC_NON_EXISTENT 4005\n#define ERROR_RPL_NOT_ALLOWED 4006\n#define ERROR_NO_BROWSER_SERVERS_FOUND 6118\n#define FAILED(S) ((HRESULT)((S)<0))\n#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)\n#define FACILITY_WINDOWS\t8\n#define FACILITY_STORAGE\t3\n#define FACILITY_SSPI\t9\n#define FACILITY_SCARD\t16\n#define FACILITY_SETUPAPI\t15\n#define FACILITY_RPC\t1\n#define FACILITY_WIN32\t7\n#define FACILITY_CONTROL\t10\n#define FACILITY_NULL\t0\n#define FACILITY_MSMQ\t14\n#define FACILITY_MEDIASERVER\t13\n#define FACILITY_INTERNET\t12\n#define FACILITY_ITF\t4\n#define FACILITY_DISPATCH\t2\n#define FACILITY_CERT\t11\n#define FACILITY_NT_BIT 0x10000000\n#define S_OK\t0\n#define S_FALSE\t1\n#define HRESULT_FROM_NT(x)\t((HRESULT) ((x)|FACILITY_NT_BIT))\n#define HRESULT_FROM_WIN32(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)):((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)))\n#define HRESULT_SEVERITY(hr) (((hr) >> 31) & 1)\n#define SCODE_CODE(s)\t((s)&0xFFFF)\n#define GetScode(h)\t((SCODE)(h))\n#define NOERROR\tS_OK\n#define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)\n#define UNREFERENCED_PARAMETER(a)\n#define CDERR_DIALOGFAILURE 0xFFFF\n#define CDERR_GENERALCODES 0\n#define CDERR_STRUCTSIZE 1\n#define CDERR_INITIALIZATION 2\n#define CDERR_NOTEMPLATE 3\n#define CDERR_NOHINSTANCE 4\n#define CDERR_LOADSTRFAILURE 5\n#define CDERR_FINDRESFAILURE 6\n#define CDERR_LOADRESFAILURE 7\n#define CDERR_LOCKRESFAILURE 8\n#define CDERR_MEMALLOCFAILURE 9\n#define CDERR_MEMLOCKFAILURE 10\n#define CDERR_NOHOOK 0xB\n#define CDERR_REGISTERMSGFAIL 0xC\n#define PDERR_PRINTERCODES 0x1000\n#define PDERR_SETUPFAILURE 0x1001\n#define PDERR_PARSEFAILURE 0x1002\n#define PDERR_RETDEFFAILURE 0x1003\n#define PDERR_LOADDRVFAILURE 0x1004\n#define PDERR_GETDEVMODEFAIL 0x1005\n#define PDERR_INITFAILURE 0x1006\n#define PDERR_NODEVICES 0x1007\n#define PDERR_NODEFAULTPRN 0x1008\n#define PDERR_DNDMMISMATCH 0x1009\n#define PDERR_CREATEICFAILURE 0x100A\n#define PDERR_PRINTERNOTFOUND 0x100B\n#define PDERR_DEFAULTDIFFERENT 0x100C\n#define CFERR_CHOOSEFONTCODES 0x2000\n#define CFERR_NOFONTS 0x2001\n#define CFERR_MAXLESSTHANMIN 0x2002\n#define FNERR_FILENAMECODES 0x3000\n#define FNERR_SUBCLASSFAILURE 0x3001\n#define FNERR_INVALIDFILENAME 0x3002\n#define FNERR_BUFFERTOOSMALL 0x3003\n#define FRERR_FINDREPLACECODES 0x4000\n#define FRERR_BUFFERLENGTHZERO 0x4001\n#define CCERR_CHOOSECOLORCODES 0x5000\n#define\tTYPE_E_BUFFERTOOSMALL\t0x80028016\n#define\tTYPE_E_INVDATAREAD\t0x80028018\n#define\tTYPE_E_UNSUPFORMAT\t0x80028019\n#define\tTYPE_E_REGISTRYACCESS\t0x8002801C\n#define\tTYPE_E_LIBNOTREGISTERED\t0x8002801D\n#define\tTYPE_E_UNDEFINEDTYPE\t0x80028027\n#define\tTYPE_E_QUALIFIEDNAMEDISALLOWED\t0x80028028\n#define\tTYPE_E_INVALIDSTATE\t0x80028029\n#define\tTYPE_E_WRONGTYPEKIND\t0x8002802A\n#define\tTYPE_E_ELEMENTNOTFOUND\t0x8002802B\n#define\tTYPE_E_AMBIGUOUSNAME\t0x8002802C\n#define\tTYPE_E_NAMECONFLICT\t0x8002802D\n#define\tTYPE_E_UNKNOWNLCID\t0x8002802E\n#define\tTYPE_E_DLLFUNCTIONNOTFOUND\t0x8002802F\n#define\tTYPE_E_BADMODULEKIND\t0x800288BD\n#define\tTYPE_E_SIZETOOBIG\t0x800288C5\n#define\tTYPE_E_DUPLICATEID\t0x800288C6\n#define\tTYPE_E_INVALIDID\t0x800288CF\n#define\tTYPE_E_TYPEMISMATCH\t0x80028CA0\n#define\tTYPE_E_OUTOFBOUNDS\t0x80028CA1\n#define\tTYPE_E_IOERROR\t0x80028CA2\n#define\tTYPE_E_CANTCREATETMPFILE\t0x80028CA3\n#define\tTYPE_E_CANTLOADLIBRARY\t0x80029C4A\n#define\tTYPE_E_INCONSISTENTPROPFUNCS\t0x80029C83\n#define\tTYPE_E_CIRCULARTYPE\t0x80029C84\n#define REGDB_E_FIRST\t0x80040150\n#define REGDB_E_LAST\t0x8004015F\n#define REGDB_S_FIRST\t0x40150\n#define REGDB_S_LAST\t0x4015F\n#define REGDB_E_READREGDB\t_HRESULT_TYPEDEF_(0x80040150)\n#define REGDB_E_WRITEREGDB\t_HRESULT_TYPEDEF_(0x80040151)\n#define REGDB_E_KEYMISSING\t_HRESULT_TYPEDEF_(0x80040152)\n#define REGDB_E_INVALIDVALUE\t_HRESULT_TYPEDEF_(0x80040153)\n#define REGDB_E_CLASSNOTREG\t_HRESULT_TYPEDEF_(0x80040154)\n#define REGDB_E_IIDNOTREG\t_HRESULT_TYPEDEF_(0x80040155)\n#define OLE_E_FIRST ((HRESULT)0x80040000)\n#define OLE_E_LAST ((HRESULT)0x800400FF)\n#define OLE_S_FIRST ((HRESULT)0x40000)\n#define OLE_S_LAST ((HRESULT)0x400FF)\n#define OLE_E_OLEVERB _HRESULT_TYPEDEF_(0x80040000)\n#define OLE_E_ADVF _HRESULT_TYPEDEF_(0x80040001)\n#define OLE_E_ENUM_NOMORE _HRESULT_TYPEDEF_(0x80040002)\n#define OLE_E_ADVISENOTSUPPORTED _HRESULT_TYPEDEF_(0x80040003)\n#define OLE_E_NOCONNECTION _HRESULT_TYPEDEF_(0x80040004)\n#define OLE_E_NOTRUNNING _HRESULT_TYPEDEF_(0x80040005)\n#define OLE_E_NOCACHE _HRESULT_TYPEDEF_(0x80040006)\n#define OLE_E_BLANK _HRESULT_TYPEDEF_(0x80040007)\n#define OLE_E_CLASSDIFF _HRESULT_TYPEDEF_(0x80040008)\n#define OLE_E_CANT_GETMONIKER _HRESULT_TYPEDEF_(0x80040009)\n#define OLE_E_CANT_BINDTOSOURCE _HRESULT_TYPEDEF_(0x8004000A)\n#define OLE_E_STATIC _HRESULT_TYPEDEF_(0x8004000B)\n#define OLE_E_PROMPTSAVECANCELLED _HRESULT_TYPEDEF_(0x8004000C)\n#define OLE_E_INVALIDRECT _HRESULT_TYPEDEF_(0x8004000D)\n#define OLE_E_WRONGCOMPOBJ _HRESULT_TYPEDEF_(0x8004000E)\n#define OLE_E_INVALIDHWND _HRESULT_TYPEDEF_(0x8004000F)\n#define OLE_E_NOT_INPLACEACTIVE _HRESULT_TYPEDEF_(0x80040010)\n#define OLE_E_CANTCONVERT _HRESULT_TYPEDEF_(0x80040011)\n#define OLE_E_NOSTORAGE _HRESULT_TYPEDEF_(0x80040012)\n#define DV_E_FORMATETC _HRESULT_TYPEDEF_(0x80040064)\n#define DV_E_DVTARGETDEVICE _HRESULT_TYPEDEF_(0x80040065)\n#define DV_E_STGMEDIUM _HRESULT_TYPEDEF_(0x80040066)\n#define DV_E_STATDATA _HRESULT_TYPEDEF_(0x80040067)\n#define DV_E_LINDEX _HRESULT_TYPEDEF_(0x80040068)\n#define DV_E_TYMED _HRESULT_TYPEDEF_(0x80040069)\n#define DV_E_CLIPFORMAT _HRESULT_TYPEDEF_(0x8004006A)\n#define DV_E_DVASPECT _HRESULT_TYPEDEF_(0x8004006B)\n#define DV_E_DVTARGETDEVICE_SIZE _HRESULT_TYPEDEF_(0x8004006C)\n#define DV_E_NOIVIEWOBJECT _HRESULT_TYPEDEF_(0x8004006D)\n#define DRAGDROP_E_FIRST 0x80040100\n#define DRAGDROP_E_LAST 0x8004010F\n#define DRAGDROP_S_FIRST 0x40100\n#define DRAGDROP_S_LAST 0x4010F\n#define DRAGDROP_E_NOTREGISTERED _HRESULT_TYPEDEF_(0x80040100)\n#define DRAGDROP_E_ALREADYREGISTERED _HRESULT_TYPEDEF_(0x80040101)\n#define DRAGDROP_E_INVALIDHWND _HRESULT_TYPEDEF_(0x80040102)\n#define CLASSFACTORY_E_FIRST 0x80040110\n#define CLASSFACTORY_E_LAST 0x8004011F\n#define CLASSFACTORY_S_FIRST 0x40110\n#define CLASSFACTORY_S_LAST 0x4011F\n#define CLASS_E_NOAGGREGATION _HRESULT_TYPEDEF_(0x80040110)\n#define CLASS_E_CLASSNOTAVAILABLE _HRESULT_TYPEDEF_(0x80040111)\n#define CLASS_E_NOTLICENSED _HRESULT_TYPEDEF_(0x80040112)\n#define MARSHAL_E_FIRST 0x80040120\n#define MARSHAL_E_LAST 0x8004012F\n#define MARSHAL_S_FIRST 0x40120\n#define MARSHAL_S_LAST 0x4012F\n#define DATA_E_FIRST 0x80040130\n#define DATA_E_LAST 0x8004013F\n#define DATA_S_FIRST 0x40130\n#define DATA_S_LAST 0x4013F\n#define VIEW_E_FIRST 0x80040140\n#define VIEW_E_LAST 0x8004014F\n#define VIEW_S_FIRST 0x40140\n#define VIEW_S_LAST 0x4014F\n#define VIEW_E_DRAW _HRESULT_TYPEDEF_(0x80040140)\n#define REGDB_E_FIRST 0x80040150\n#define REGDB_E_LAST 0x8004015F\n#define REGDB_S_FIRST 0x40150\n#define REGDB_S_LAST 0x4015F\n#define REGDB_E_READREGDB _HRESULT_TYPEDEF_(0x80040150)\n#define REGDB_E_WRITEREGDB _HRESULT_TYPEDEF_(0x80040151)\n#define REGDB_E_KEYMISSING _HRESULT_TYPEDEF_(0x80040152)\n#define REGDB_E_INVALIDVALUE _HRESULT_TYPEDEF_(0x80040153)\n#define REGDB_E_CLASSNOTREG _HRESULT_TYPEDEF_(0x80040154)\n#define REGDB_E_IIDNOTREG _HRESULT_TYPEDEF_(0x80040155)\n#define CAT_E_FIRST 0x80040160\n#define CAT_E_LAST 0x80040161\n#define CAT_E_CATIDNOEXIST _HRESULT_TYPEDEF_(0x80040160)\n#define CAT_E_NODESCRIPTION _HRESULT_TYPEDEF_(0x80040161)\n#define CS_E_FIRST 0x80040164\n#define CS_E_LAST 0x8004016F\n#define CS_E_PACKAGE_NOTFOUND _HRESULT_TYPEDEF_(0x80040164)\n#define CS_E_NOT_DELETABLE _HRESULT_TYPEDEF_(0x80040165)\n#define CS_E_CLASS_NOTFOUND _HRESULT_TYPEDEF_(0x80040166)\n#define CS_E_INVALID_VERSION _HRESULT_TYPEDEF_(0x80040167)\n#define CS_E_NO_CLASSSTORE _HRESULT_TYPEDEF_(0x80040168)\n#define CS_E_OBJECT_NOTFOUND _HRESULT_TYPEDEF_(0x80040169)\n#define CS_E_OBJECT_ALREADY_EXISTS _HRESULT_TYPEDEF_(0x8004016A)\n#define CS_E_INVALID_PATH _HRESULT_TYPEDEF_(0x8004016B)\n#define CS_E_NETWORK_ERROR _HRESULT_TYPEDEF_(0x8004016C)\n#define CS_E_ADMIN_LIMIT_EXCEEDED _HRESULT_TYPEDEF_(0x8004016D)\n#define CS_E_SCHEMA_MISMATCH _HRESULT_TYPEDEF_(0x8004016E)\n#define CS_E_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x8004016F)\n#define CACHE_E_FIRST 0x80040170\n#define CACHE_E_LAST 0x8004017F\n#define CACHE_S_FIRST 0x40170\n#define CACHE_S_LAST 0x4017F\n#define CACHE_E_NOCACHE_UPDATED _HRESULT_TYPEDEF_(0x80040170)\n#define OLEOBJ_E_FIRST 0x80040180\n#define OLEOBJ_E_LAST 0x8004018F\n#define OLEOBJ_S_FIRST 0x40180\n#define OLEOBJ_S_LAST 0x4018F\n#define OLEOBJ_E_NOVERBS _HRESULT_TYPEDEF_(0x80040180)\n#define OLEOBJ_E_INVALIDVERB _HRESULT_TYPEDEF_(0x80040181)\n#define CLIENTSITE_E_FIRST 0x80040190\n#define CLIENTSITE_E_LAST 0x8004019F\n#define CLIENTSITE_S_FIRST 0x40190\n#define CLIENTSITE_S_LAST 0x4019F\n#define INPLACE_E_NOTUNDOABLE _HRESULT_TYPEDEF_(0x800401A0)\n#define INPLACE_E_NOTOOLSPACE _HRESULT_TYPEDEF_(0x800401A1)\n#define INPLACE_E_FIRST 0x800401A0\n#define INPLACE_E_LAST 0x800401AF\n#define INPLACE_S_FIRST 0x401A0\n#define INPLACE_S_LAST 0x401AF\n#define ENUM_E_FIRST 0x800401B0\n#define ENUM_E_LAST 0x800401BF\n#define ENUM_S_FIRST 0x401B0\n#define ENUM_S_LAST 0x401BF\n#define CONVERT10_E_FIRST 0x800401C0\n#define CONVERT10_E_LAST 0x800401CF\n#define CONVERT10_S_FIRST 0x401C0\n#define CONVERT10_S_LAST 0x401CF\n#define CONVERT10_E_OLESTREAM_GET _HRESULT_TYPEDEF_(0x800401C0)\n#define CONVERT10_E_OLESTREAM_PUT _HRESULT_TYPEDEF_(0x800401C1)\n#define CONVERT10_E_OLESTREAM_FMT _HRESULT_TYPEDEF_(0x800401C2)\n#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB _HRESULT_TYPEDEF_(0x800401C3)\n#define CONVERT10_E_STG_FMT _HRESULT_TYPEDEF_(0x800401C4)\n#define CONVERT10_E_STG_NO_STD_STREAM _HRESULT_TYPEDEF_(0x800401C5)\n#define CONVERT10_E_STG_DIB_TO_BITMAP _HRESULT_TYPEDEF_(0x800401C6)\n#define CLIPBRD_E_FIRST 0x800401D0\n#define CLIPBRD_E_LAST 0x800401DF\n#define CLIPBRD_S_FIRST 0x401D0\n#define CLIPBRD_S_LAST 0x401DF\n#define CLIPBRD_E_CANT_OPEN _HRESULT_TYPEDEF_(0x800401D0)\n#define CLIPBRD_E_CANT_EMPTY _HRESULT_TYPEDEF_(0x800401D1)\n#define CLIPBRD_E_CANT_SET _HRESULT_TYPEDEF_(0x800401D2)\n#define CLIPBRD_E_BAD_DATA _HRESULT_TYPEDEF_(0x800401D3)\n#define CLIPBRD_E_CANT_CLOSE _HRESULT_TYPEDEF_(0x800401D4)\n#define MK_E_FIRST 0x800401E0\n#define MK_E_LAST 0x800401EF\n#define MK_S_FIRST 0x401E0\n#define MK_S_LAST 0x401EF\n#define MK_E_CONNECTMANUALLY _HRESULT_TYPEDEF_(0x800401E0)\n#define MK_E_EXCEEDEDDEADLINE _HRESULT_TYPEDEF_(0x800401E1)\n#define MK_E_NEEDGENERIC _HRESULT_TYPEDEF_(0x800401E2)\n#define MK_E_UNAVAILABLE _HRESULT_TYPEDEF_(0x800401E3)\n#define MK_E_SYNTAX _HRESULT_TYPEDEF_(0x800401E4)\n#define MK_E_NOOBJECT _HRESULT_TYPEDEF_(0x800401E5)\n#define MK_E_INVALIDEXTENSION _HRESULT_TYPEDEF_(0x800401E6)\n#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED _HRESULT_TYPEDEF_(0x800401E7)\n#define MK_E_NOTBINDABLE _HRESULT_TYPEDEF_(0x800401E8)\n#define MK_E_NOTBOUND _HRESULT_TYPEDEF_(0x800401E9)\n#define MK_E_CANTOPENFILE _HRESULT_TYPEDEF_(0x800401EA)\n#define MK_E_MUSTBOTHERUSER _HRESULT_TYPEDEF_(0x800401EB)\n#define MK_E_NOINVERSE _HRESULT_TYPEDEF_(0x800401EC)\n#define MK_E_NOSTORAGE _HRESULT_TYPEDEF_(0x800401ED)\n#define MK_E_NOPREFIX _HRESULT_TYPEDEF_(0x800401EE)\n#define MK_E_ENUMERATION_FAILED _HRESULT_TYPEDEF_(0x800401EF)\n#define CO_E_FIRST 0x800401F0\n#define CO_E_LAST 0x800401FF\n#define CO_S_FIRST 0x401F0\n#define CO_S_LAST 0x401FF\n#define CO_E_NOTINITIALIZED _HRESULT_TYPEDEF_(0x800401F0)\n#define CO_E_ALREADYINITIALIZED _HRESULT_TYPEDEF_(0x800401F1)\n#define CO_E_CANTDETERMINECLASS _HRESULT_TYPEDEF_(0x800401F2)\n#define CO_E_CLASSSTRING _HRESULT_TYPEDEF_(0x800401F3)\n#define CO_E_IIDSTRING _HRESULT_TYPEDEF_(0x800401F4)\n#define CO_E_APPNOTFOUND _HRESULT_TYPEDEF_(0x800401F5)\n#define CO_E_APPSINGLEUSE _HRESULT_TYPEDEF_(0x800401F6)\n#define CO_E_ERRORINAPP _HRESULT_TYPEDEF_(0x800401F7)\n#define CO_E_DLLNOTFOUND _HRESULT_TYPEDEF_(0x800401F8)\n#define CO_E_ERRORINDLL _HRESULT_TYPEDEF_(0x800401F9)\n#define CO_E_WRONGOSFORAPP _HRESULT_TYPEDEF_(0x800401FA)\n#define CO_E_OBJNOTREG _HRESULT_TYPEDEF_(0x800401FB)\n#define CO_E_OBJISREG _HRESULT_TYPEDEF_(0x800401FC)\n#define CO_E_OBJNOTCONNECTED _HRESULT_TYPEDEF_(0x800401FD)\n#define CO_E_APPDIDNTREG _HRESULT_TYPEDEF_(0x800401FE)\n#define CO_E_RELEASED _HRESULT_TYPEDEF_(0x800401FF)\n#define OLE_S_USEREG _HRESULT_TYPEDEF_(0x40000)\n#define OLE_S_STATIC _HRESULT_TYPEDEF_(0x40001)\n#define OLE_S_MAC_CLIPFORMAT _HRESULT_TYPEDEF_(0x40002)\n#define DRAGDROP_S_DROP _HRESULT_TYPEDEF_(0x40100)\n#define DRAGDROP_S_CANCEL _HRESULT_TYPEDEF_(0x40101)\n#define DRAGDROP_S_USEDEFAULTCURSORS _HRESULT_TYPEDEF_(0x40102)\n#define DATA_S_SAMEFORMATETC _HRESULT_TYPEDEF_(0x40130)\n#define VIEW_S_ALREADY_FROZEN _HRESULT_TYPEDEF_(0x40140)\n#define CACHE_S_FORMATETC_NOTSUPPORTED _HRESULT_TYPEDEF_(0x40170)\n#define CACHE_S_SAMECACHE _HRESULT_TYPEDEF_(0x40171)\n#define CACHE_S_SOMECACHES_NOTUPDATED _HRESULT_TYPEDEF_(0x40172)\n#define OLEOBJ_S_INVALIDVERB _HRESULT_TYPEDEF_(0x40180)\n#define OLEOBJ_S_CANNOT_DOVERB_NOW _HRESULT_TYPEDEF_(0x40181)\n#define OLEOBJ_S_INVALIDHWND _HRESULT_TYPEDEF_(0x40182)\n#define INPLACE_S_TRUNCATED _HRESULT_TYPEDEF_(0x401A0)\n#define CONVERT10_S_NO_PRESENTATION _HRESULT_TYPEDEF_(0x401C0)\n#define MK_S_REDUCED_TO_SELF _HRESULT_TYPEDEF_(0x401E2)\n#define MK_S_ME _HRESULT_TYPEDEF_(0x401E4)\n#define MK_S_HIM _HRESULT_TYPEDEF_(0x401E5)\n#define MK_S_US _HRESULT_TYPEDEF_(0x401E6)\n#define MK_S_MONIKERALREADYREGISTERED _HRESULT_TYPEDEF_(0x401E7)\n#define CO_E_CLASS_CREATE_FAILED _HRESULT_TYPEDEF_(0x80080001)\n#define CO_E_SCM_ERROR _HRESULT_TYPEDEF_(0x80080002)\n#define CO_E_SCM_RPC_FAILURE _HRESULT_TYPEDEF_(0x80080003)\n#define CO_E_BAD_PATH _HRESULT_TYPEDEF_(0x80080004)\n#define CO_E_SERVER_EXEC_FAILURE _HRESULT_TYPEDEF_(0x80080005)\n#define CO_E_OBJSRV_RPC_FAILURE _HRESULT_TYPEDEF_(0x80080006)\n#define MK_E_NO_NORMALIZED _HRESULT_TYPEDEF_(0x80080007)\n#define CO_E_SERVER_STOPPING _HRESULT_TYPEDEF_(0x80080008)\n#define MEM_E_INVALID_ROOT _HRESULT_TYPEDEF_(0x80080009)\n#define MEM_E_INVALID_LINK _HRESULT_TYPEDEF_(0x80080010)\n#define MEM_E_INVALID_SIZE _HRESULT_TYPEDEF_(0x80080011)\n#define CO_S_NOTALLINTERFACES _HRESULT_TYPEDEF_(0x80012)\n#define DIGSIG_E_ENCODE\t_HRESULT_TYPEDEF_(0x800B0005)\n#define DIGSIG_E_DECODE\t_HRESULT_TYPEDEF_(0x800B0006)\n#define DIGSIG_E_EXTENSIBILITY\t_HRESULT_TYPEDEF_(0x800B0007)\n#define DIGSIG_E_CRYPTO\t_HRESULT_TYPEDEF_(0x800B0008)\n#define PERSIST_E_SIZEDEFINITE\t_HRESULT_TYPEDEF_(0x800B0009)\n#define PERSIST_E_SIZEINDEFINITE\t_HRESULT_TYPEDEF_(0x800B000A)\n#define PERSIST_E_NOTSELFSIZING\t_HRESULT_TYPEDEF_(0x800B000B)\n#define DISP_E_UNKNOWNINTERFACE _HRESULT_TYPEDEF_(0x80020001)\n#define DISP_E_MEMBERNOTFOUND _HRESULT_TYPEDEF_(0x80020003)\n#define DISP_E_PARAMNOTFOUND _HRESULT_TYPEDEF_(0x80020004)\n#define DISP_E_TYPEMISMATCH _HRESULT_TYPEDEF_(0x80020005)\n#define DISP_E_UNKNOWNNAME _HRESULT_TYPEDEF_(0x80020006)\n#define DISP_E_NONAMEDARGS _HRESULT_TYPEDEF_(0x80020007)\n#define DISP_E_BADVARTYPE _HRESULT_TYPEDEF_(0x80020008)\n#define DISP_E_EXCEPTION _HRESULT_TYPEDEF_(0x80020009)\n#define DISP_E_OVERFLOW _HRESULT_TYPEDEF_(0x8002000A)\n#define DISP_E_BADINDEX _HRESULT_TYPEDEF_(0x8002000B)\n#define DISP_E_UNKNOWNLCID _HRESULT_TYPEDEF_(0x8002000C)\n#define DISP_E_ARRAYISLOCKED _HRESULT_TYPEDEF_(0x8002000D)\n#define DISP_E_BADPARAMCOUNT _HRESULT_TYPEDEF_(0x8002000E)\n#define DISP_E_PARAMNOTOPTIONAL _HRESULT_TYPEDEF_(0x8002000F)\n#define DISP_E_BADCALLEE _HRESULT_TYPEDEF_(0x80020010)\n#define DISP_E_NOTACOLLECTION _HRESULT_TYPEDEF_(0x80020011)\n#define DISP_E_DIVBYZERO _HRESULT_TYPEDEF_(0x80020012)\n#define DISP_E_BUFFERTOOSMALL _HRESULT_TYPEDEF_(0x80020013)\n#define STG_E_INVALIDFUNCTION _HRESULT_TYPEDEF_(0x80030001)\n#define STG_E_FILENOTFOUND _HRESULT_TYPEDEF_(0x80030002)\n#define STG_E_PATHNOTFOUND _HRESULT_TYPEDEF_(0x80030003)\n#define STG_E_TOOMANYOPENFILES _HRESULT_TYPEDEF_(0x80030004)\n#define STG_E_ACCESSDENIED _HRESULT_TYPEDEF_(0x80030005)\n#define STG_E_INVALIDHANDLE _HRESULT_TYPEDEF_(0x80030006)\n#define STG_E_INSUFFICIENTMEMORY _HRESULT_TYPEDEF_(0x80030008)\n#define STG_E_INVALIDPOINTER _HRESULT_TYPEDEF_(0x80030009)\n#define STG_E_NOMOREFILES _HRESULT_TYPEDEF_(0x80030012)\n#define STG_E_DISKISWRITEPROTECTED _HRESULT_TYPEDEF_(0x80030013)\n#define STG_E_SEEKERROR _HRESULT_TYPEDEF_(0x80030019)\n#define STG_E_WRITEFAULT _HRESULT_TYPEDEF_(0x8003001D)\n#define STG_E_READFAULT _HRESULT_TYPEDEF_(0x8003001E)\n#define STG_E_SHAREVIOLATION _HRESULT_TYPEDEF_(0x80030020)\n#define STG_E_LOCKVIOLATION _HRESULT_TYPEDEF_(0x80030021)\n#define STG_E_FILEALREADYEXISTS _HRESULT_TYPEDEF_(0x80030050)\n#define STG_E_INVALIDPARAMETER _HRESULT_TYPEDEF_(0x80030057)\n#define STG_E_MEDIUMFULL _HRESULT_TYPEDEF_(0x80030070)\n#define STG_E_PROPSETMISMATCHED _HRESULT_TYPEDEF_(0x800300F0)\n#define STG_E_ABNORMALAPIEXIT _HRESULT_TYPEDEF_(0x800300FA)\n#define STG_E_INVALIDHEADER _HRESULT_TYPEDEF_(0x800300FB)\n#define STG_E_INVALIDNAME _HRESULT_TYPEDEF_(0x800300FC)\n#define STG_E_UNKNOWN _HRESULT_TYPEDEF_(0x800300FD)\n#define STG_E_UNIMPLEMENTEDFUNCTION _HRESULT_TYPEDEF_(0x800300FE)\n#define STG_E_INVALIDFLAG _HRESULT_TYPEDEF_(0x800300FF)\n#define STG_E_INUSE _HRESULT_TYPEDEF_(0x80030100)\n#define STG_E_NOTCURRENT _HRESULT_TYPEDEF_(0x80030101)\n#define STG_E_REVERTED _HRESULT_TYPEDEF_(0x80030102)\n#define STG_E_CANTSAVE _HRESULT_TYPEDEF_(0x80030103)\n#define STG_E_OLDFORMAT _HRESULT_TYPEDEF_(0x80030104)\n#define STG_E_OLDDLL _HRESULT_TYPEDEF_(0x80030105)\n#define STG_E_SHAREREQUIRED _HRESULT_TYPEDEF_(0x80030106)\n#define STG_E_NOTFILEBASEDSTORAGE _HRESULT_TYPEDEF_(0x80030107)\n#define STG_E_EXTANTMARSHALLINGS _HRESULT_TYPEDEF_(0x80030108)\n#define STG_E_DOCFILETOOLARGE _HRESULT_TYPEDEF_(0x80030111)\n#define STG_E_NOTSIMPLEFORMAT _HRESULT_TYPEDEF_(0x80030112)\n#define STG_E_INCOMPLETE _HRESULT_TYPEDEF_(0x80030201)\n#define STG_E_TERMINATED _HRESULT_TYPEDEF_(0x80030202)\n#define STG_E_DOCFILECORRUPT _HRESULT_TYPEDEF_(0x80030109)\n#define STG_E_BADBASEADDRESS _HRESULT_TYPEDEF_(0x80030110)\n#define STG_S_CONVERTED _HRESULT_TYPEDEF_(0x30200)\n#define STG_S_BLOCK _HRESULT_TYPEDEF_(0x30201)\n#define STG_S_RETRYNOW _HRESULT_TYPEDEF_(0x30202)\n#define STG_S_MONITORING _HRESULT_TYPEDEF_(0x30203)\n#define STG_S_MULTIPLEOPENS _HRESULT_TYPEDEF_(0x30204)\n#define STG_S_CONSOLIDATIONFAILED _HRESULT_TYPEDEF_(0x30205)\n#define STG_S_CANNOTCONSOLIDATE _HRESULT_TYPEDEF_(0x30206)\n#define SCHED_E_SERVICE_NOT_LOCALSYSTEM\t6200\n#define SCHED_E_TRIGGER_NOT_FOUND\t_HRESULT_TYPEDEF_(0x80041309L)\n#define SCHED_E_TASK_NOT_READY\t\t_HRESULT_TYPEDEF_(0x8004130AL)\n#define SCHED_E_TASK_NOT_RUNNING\t_HRESULT_TYPEDEF_(0x8004130BL)\n#define SCHED_E_SERVICE_NOT_INSTALLED\t_HRESULT_TYPEDEF_(0x8004130CL)\n#define SCHED_E_CANNOT_OPEN_TASK\t_HRESULT_TYPEDEF_(0x8004130DL)\n#define SCHED_E_INVALID_TASK\t\t_HRESULT_TYPEDEF_(0x8004130EL)\n#define SCHED_E_ACCOUNT_INFORMATION_NOT_SET _HRESULT_TYPEDEF_(0x8004130FL)\n#define SCHED_E_ACCOUNT_NAME_NOT_FOUND\t_HRESULT_TYPEDEF_(0x80041310L)\n#define SCHED_E_ACCOUNT_DBASE_CORRUPT\t_HRESULT_TYPEDEF_(0x80041311L)\n#define SCHED_E_NO_SECURITY_SERVICES\t_HRESULT_TYPEDEF_(0x80041312L)\n#define SCHED_E_UNKNOWN_OBJECT_VERSION\t_HRESULT_TYPEDEF_(0x80041313L)\n#define SCHED_E_UNSUPPORTED_ACCOUNT_OPTION _HRESULT_TYPEDEF_(0x80041314L)\n#define SCHED_E_SERVICE_NOT_RUNNING\t_HRESULT_TYPEDEF_(0x80041315L)\n#define CERT_E_EXPIRED _HRESULT_TYPEDEF_(0x800B0101)\n#define CERT_E_VALIDITYPERIODNESTING _HRESULT_TYPEDEF_(0x800B0102)\n#define CERT_E_ROLE _HRESULT_TYPEDEF_(0x800B0103)\n#define CERT_E_PATHLENCONST _HRESULT_TYPEDEF_(0x800B0104)\n#define CERT_E_CRITICAL _HRESULT_TYPEDEF_(0x800B0105)\n#define CERT_E_PURPOSE _HRESULT_TYPEDEF_(0x800B0106)\n#define CERT_E_ISSUERCHAINING _HRESULT_TYPEDEF_(0x800B0107)\n#define CERT_E_MALFORMED _HRESULT_TYPEDEF_(0x800B0108)\n#define CERT_E_UNTRUSTEDROOT _HRESULT_TYPEDEF_(0x800B0109)\n#define CERT_E_CHAINING _HRESULT_TYPEDEF_(0x800B010A)\n#define CERT_E_REVOKED _HRESULT_TYPEDEF_(0x800B010C)\n#define CERT_E_UNTRUSTEDTESTROOT _HRESULT_TYPEDEF_(0x800B010D)\n#define CERT_E_REVOCATION_FAILURE _HRESULT_TYPEDEF_(0x800B010E)\n#define CERT_E_CN_NO_MATCH _HRESULT_TYPEDEF_(0x800B010F)\n#define CERT_E_WRONG_USAGE _HRESULT_TYPEDEF_(0x800B0110)\n#define SEVERITY_ERROR 1\n#define OR_INVALID_OXID\t1910\n#define OR_INVALID_OID\t1911\n#define OR_INVALID_SET\t1912\n#define MAKE_SCODE(sev,fac,code) ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )\n#define HRESULT_FACILITY(hr) (((hr) >> 16) & 0x1fff)\n#define HRESULT_CODE(hr) (hr&0xFFFF)\n#define EXTERN_C extern\n#define ResultFromScode(sc) ((HRESULT) (sc))\n#define UNALIGNED\n#define WHEEL_DELTA 120\n\nenum VARENUM { VT_EMPTY=0,VT_NULL=1, VT_I2=2, VT_I4=3, VT_R4=4, VT_R8=5,\n VT_CY=6,VT_DATE=7, VT_BSTR=8, VT_DISPATCH=9, VT_ERROR=10, VT_BOOL=11,\n VT_VARIANT=12,VT_UNKNOWN=13, VT_DECIMAL=14, VT_I1=16, VT_UI1=17,\n VT_UI2=18,VT_UI4=19, VT_I8=20, VT_UI8=21, VT_INT=22, VT_UINT=23,\n VT_VOID=24,VT_HRESULT=25, VT_PTR=26, VT_SAFEARRAY=27, VT_CARRAY=28,\n VT_USERDEFINED=29,VT_LPSTR=30, VT_LPWSTR=31, VT_RECORD=36, VT_FILETIME=64,\n VT_BLOB=65,VT_STREAM=66, VT_STORAGE=67, VT_STREAMED_OBJECT=68, VT_STORED_OBJECT=69,\n VT_BLOB_OBJECT=70,VT_CF=71, VT_CLSID=72, VT_VERSIONED_STREAM=73, VT_BSTR_BLOB=0xfff,\n VT_VECTOR=0x1000,VT_ARRAY=0x2000, VT_BYREF=0x4000, VT_RESERVED=0x8000,\n VT_ILLEGAL=0xffff,VT_ILLEGALMASKED=0xfff, VT_TYPEMASK=0xfff\n};\n\n//#ifndef _VARIANT_BOOL_DEFINED\n//typedef short VARIANT_BOOL;\n//typedef short _VARIANT_BOOL;\n//#define _VARIANT_BOOL_DEFINED\n//#endif\n\n#define VARIANT_TRUE ((VARIANT_BOOL)-1)\n#define VARIANT_FALSE ((VARIANT_BOOL)0)\n\nBOOL GdiGradientFill(\n  HDC        hdc,\n  PTRIVERTEX pVertex,\n  ULONG      nVertex,\n  PVOID      pMesh,\n  ULONG      nCount,\n  ULONG      ulMode\n);\n\n#endif\n";
static u8 *  cc_headers$h_fcntl = (byte*)"/* FCNTL.H */\r\n\r\nint _setmode(int,int);\r\n\r\n#ifndef _INC_FCNTL\r\n#define _INC_FCNTL\r\n\r\n#define _O_RDONLY 0x0000\r\n#define _O_WRONLY 0x0001\r\n#define _O_RDWR 0x0002\r\n#define _O_APPEND 0x0008\r\n#define _O_CREAT 0x0100\r\n#define _O_TRUNC 0x0200\r\n#define _O_EXCL 0x0400\r\n#define _O_TEXT 0x4000\r\n#define _O_BINARY 0x8000\r\n#define _O_WTEXT 0x10000\r\n#define _O_U16TEXT 0x20000\r\n#define _O_U8TEXT 0x40000\r\n#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)\r\n\r\n#define _O_RAW _O_BINARY\r\n#define _O_NOINHERIT 0x0080\r\n#define _O_TEMPORARY 0x0040\r\n#define _O_SHORT_LIVED 0x1000\r\n\r\n#define _O_SEQUENTIAL 0x0020\r\n#define _O_RANDOM 0x0010\r\n\r\n#if !defined(NO_OLDNAMES) || defined(_POSIX)\r\n#define O_RDONLY _O_RDONLY\r\n#define O_WRONLY _O_WRONLY\r\n#define O_RDWR _O_RDWR\r\n#define O_APPEND _O_APPEND\r\n#define O_CREAT _O_CREAT\r\n#define O_TRUNC _O_TRUNC\r\n#define O_EXCL _O_EXCL\r\n#define O_TEXT _O_TEXT\r\n#define O_BINARY _O_BINARY\r\n#define O_RAW _O_BINARY\r\n#define O_TEMPORARY _O_TEMPORARY\r\n#define O_NOINHERIT _O_NOINHERIT\r\n#define O_SEQUENTIAL _O_SEQUENTIAL\r\n#define O_RANDOM _O_RANDOM\r\n#define O_ACCMODE _O_ACCMODE\r\n#endif\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_io = (byte*)"\r\n#ifndef $io\r\n#define $io\r\n\r\n#include <stdint.h>\r\n#include <wchar.h>\r\n#include <time.h>\r\n\r\n/* io.h */\r\n\r\n#define _A_NORMAL 0x00\r\n#define _A_RDONLY 0x01\r\n#define _A_HIDDEN 0x02\r\n#define _A_SYSTEM 0x04\r\n#define _A_SUBDIR 0x10\r\n#define _A_ARCH 0x20\r\n\r\n\r\n//#message \"IO included\"\r\nstruct _finddata_t {\r\n        unsigned    attrib;\r\n        time_t      time_create;\r\n        time_t      time_access;\r\n        time_t      time_write;\r\n        unsigned long    size;\r\n        char        name[260];\r\n};\r\n\r\nint _isatty(int);\r\n\r\nint _read(int, void*, unsigned int);\r\n#define read _read\r\n\r\nint _open(const char*, int, ...);\r\n#define open _open\r\n\r\nlong _lseek(int, long, int);\r\n#define lseek _lseek\r\n\r\nint _close(int);\r\n#define close _close\r\n\r\nintptr_t _get_osfhandle(int);\r\nint _open_osfhandle(intptr_t,int);\r\n\r\nint _setmode(int,int);\r\n#define setmode _setmode\r\n\r\nint _wchmod(const wchar_t*, int);\r\n\r\nint _chmod(const char *, int);\r\n#define chmod _chmod\r\n\r\nint _dup(int);\r\n#define dup _dup\r\n\r\nintptr_t _findfirst(const char*, struct _finddata_t*);\r\nint _findnext(intptr_t, struct _finddata_t*);\r\nint _findclose(intptr_t);\r\n\r\nint _access(const char*,int);\r\n#define access _access\r\n\r\nint _wunlink(const wchar_t*);\r\n\r\n\r\n#endif\r\n";
static u8 *  cc_headers$h_direct = (byte*)"#ifndef $direct\r\n#define $direct\r\n\r\ntypedef struct {\r\n unsigned int total_clusters;\r\n unsigned int avail_clusters;\r\n unsigned int sectors_per_cluster;\r\n unsigned int bytes_per_sector;\r\n} diskfree_t;\r\n\r\nint chdir(const char *);\r\nchar* _getcwd(char *, int);\r\n#define getcwd _getcwd\r\nint _mkdir(const char *);\r\nint _rmdir(const char *);\r\nint _wrmdir(const wchar_t*);\r\nint _wmkdir(const wchar_t*);\r\n\r\n#define mkdir _mkdir\r\n#define rmdir _rmdir\r\n\r\nint _chdrive(int);\r\nchar* _getdcwd(int, char *, int);\r\nwchar_t* _wgetcwd(wchar_t*, int);\r\nint _wchdir(const wchar_t*);\r\nint _getdrive(void);\r\nint _chdir(const char*);\r\n#define chdir _chdir\r\n\r\nunsigned long _getdrives(void);\r\nunsigned int _getdiskfree(unsigned int, diskfree_t*);\r\n\r\n#endif\r\n\r\n";
static u8 *  cc_headers$h_process = (byte*)"/* Header process.h */\r\n#ifndef $process\r\n#define $process\r\n\r\n#include <stdint.h>\r\n\r\n#define P_WAIT\t\t0\r\n#define P_NOWAIT\t1\r\n#define P_OVERLAY\t2\r\n#define P_DETACH\t4\r\n#define WAIT_CHILD 0\r\n#define _P_WAIT P_WAIT\r\n#define _P_NOWAIT P_NOWAIT\r\n#define _P_OVERLAY P_OVERLAY\r\n\r\nint _spawnvp(int, const char*, const char*const*);\r\n#define spawnvp _spawnvp\r\n\r\nvoid endthread(void);\r\nunsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);\r\nvoid _endthreadex(unsigned);\r\nint _cwait(int*, int, int);\r\n#define cwait _cwait\r\n//int _System(const char *cmd,int nCmdShow);\r\n\r\nintptr_t _execve(const char*, const char*const*, const char*const*);\r\n#define execve _execve\r\n\r\n//#define _WAIT_CHILD\t0\r\n//#endif\r\n#endif\r\n\r\n";
static u8 *  cc_headers$h_malloc = (byte*)"#include <stddef.h>\r\n\r\nvoid* malloc(size_t);\r\nvoid* realloc(void *, size_t);\r\nvoid  free(void *);\r\nvoid *_alloca(size_t);\r\n";
static u8 *  cc_headers$h_bcc = (byte*)"#define __attribute__(x)\n#define _WIN32\n#define WIN32\n#define __WIN32__\n#define __inline\n#define __dllimport(x)\n#define __declspec(x)\n#define __stdcall\n#define CALLBACK $callback\n#define __cdecl\n#define EXTERN_C extern\n#define DECLSPEC_IMPORT\n#define __32BIT__\n#define register\n";
static u8 *  cc_headers$h_conio = (byte*)"/* conio.h */\r\n#include <stddef.h>\r\n#include <wchar.h>\r\n\r\nint _getch(void);\r\nint _kbhit(void);\r\nwint_t _getwch(void);\r\n\r\n#define getch _getch\r\n#define kbhit _kbhit\r\n\r\nint _putch(int);\r\nint _cprintf(char *, ...);\r\nint _getche(void);\r\nint _ungetch(int);\r\n\r\n#define putch _putch\r\n#define cprintf _cprintf\r\n#define getche _getche\r\n#define ungetch _ungetch\r\n";
static u8 *  cc_headers$h_winsock2 = 
(byte*)"#ifndef _WINSOCK2_H\r\n#define _WINSOCK2_H\r\n\r\n#include <_mingw.h>\r\n#include <windows.h>\r\n\r\n#ifndef FD_SETSIZE\r\n#define FD_SETSIZE 64\r\n#endif\r\n\r\ntypedef unsigned int SOCKET;\r\n\r\ntypedef struct fd_set {\r\n  unsigned int   fd_count;\r\n  SOCKET  fd_array[FD_SETSIZE];\r\n} fd_set;\r\n\r\nextern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);\r\n\r\n#ifndef FD_CLR\r\n#define FD_CLR(fd,set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n    while (__i < ((fd_set *)(set))->fd_count-1) {\\\r\n        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\\\r\n        __i++;\\\r\n    }\\\r\n    ((fd_set*)(set))->fd_count--;\\\r\n    break;\\\r\n    }\\\r\n}\\\r\n} while (0)\r\n#endif\r\n\r\n#ifndef FD_SET\r\n/* this differs from the define in winsock.h and in cygwin sys/types.h */\r\n#define FD_SET(fd, set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n        break;\\\r\n    }\\\r\n}\\\r\nif (__i == ((fd_set *)(set))->fd_count) {\\\r\n    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\\\r\n        ((fd_set *)(set))->fd_array[__i] = (fd);\\\r\n        ((fd_set *)(set))->fd_count++;\\\r\n    }\\\r\n}\\\r\n} while(0)\r\n#endif\r\n\r\n#ifndef FD_ZERO\r\n#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)\r\n#endif\r\n\r\n#ifndef FD_ISSET\r\n#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))\r\n#endif\r\n\r\n#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */\r\n#define _TIMEVAL_DEFINED\r\nstruct timeval {\r\n    long tv_sec;\r\n    long tv_usec;\r\n};\r\n#endif\r\n\r\nstruct in_addr {\r\n    union {\r\n        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;\r\n        struct { unsigned short s_w1,s_w2; } S_un_w;\r\n        unsigned long S_addr;\r\n    } S_un;\r\n};\r\n#define s_addr  S_un.S_addr\r\n\r\nstruct sockaddr_in {\r\n    short sin_family;\r\n    unsigned short sin_port;\r\n    struct in_addr sin_addr;\r\n    char sin_zero[8];\r\n};\r\n\r\nstruct sockaddr {\r\n    unsigned short sa_family;\r\n    char sa_data[14];\r\n};\r\n\r\nstruct hostent {\r\n    char *h_name;\r\n    char **h_aliases;\r\n    short h_addrtype;\r\n    short h_length;\r\n    char **h_addr_list;\r\n};\r\n#define h_addr h_addr_list[0]\r\n\r\n#define WSADESCRIPTION_LEN  256\r\n#define WSASYS_STATUS_LEN   128\r\ntypedef struct WSAData {\r\n    WORD wVersion;\r\n    WORD wHighVersion;\r\n    char szDescription[WSADESCRIPTION_LEN+1];\r\n    char szSystemStatus[WSASYS_STATUS_LEN+1];\r\n    unsigned short iMaxSockets;\r\n    unsigned short iMaxUdpDg;\r\n    char *lpVendorInfo;\r\n} WSADATA;\r\ntypedef WSADATA *LPWSADATA;\r\n\r\n#define INVALID_SOCKET (SOCKET)(~0)\r\n#define SOCK_STREAM  1\r\n#define SO_REUSEADDR 4\r\n#define AF_INET 2\r\n#define MSG_PEEK 0x2\r\n#define INADDR_ANY (unsigned long)0x00000000\r\n#define INADDR_LOOPBACK 0x7f000001\r\n#define SOL_SOCKET 0xffff\r\n\r\n#define SD_RECEIVE  0x00\r\n#define SD_SEND     0x01\r\n#define SD_BOTH     0x02\r\n\r\n#define h_errno WSAGetLastError()\r\n\r\n#define WSABASEERR 10000\r\n#define TRY_AGAIN (WSABASEERR+1002)\r\n\r\nSOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);\r\nint __stdcall bind(SOCKET, const struct sockaddr *, int);\r\nint __stdcall closesocket(SOCKET);\r\nint __stdcall connect(SOCKET, const struct sockaddr *, int);\r\nstruct hostent *__stdcall gethostbyname(const char *);\r\nint __stdcall gethostname(char *, int);\r\nint __stdcall getpeername(SOCKET, struct sockaddr *, int *);\r\nint __stdcall getsockname(SOCKET, struct sockaddr *, int *);\r\nunsigned long __stdcall htonl(unsigned long);\r\nunsigned short __stdcall htons(unsigned short);\r\nint __stdcall listen(SOCKET, int);\r\nunsigned long __stdcall ntohl(unsigned long);\r\nunsigned short __stdcall ntohs(unsigned short);\r\nint __stdcall recv(SOCKET, char *, int, int);\r\nint __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);\r\nint __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);\r\nint __stdcall send(SOCKET, const char *, int, int);\r\nint __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);\r\nint __stdcall setsockopt(SOCKET, int, int, const char *, int);\r\nint __stdcall shutdown(SOCKET, int);\r\nint __stdcall WSACleanup(void);\r\nint __stdcall WSAGetLastError(void);\r\nint __stdcall WSAStartup(WORD, LPWSADATA);\r\n\r\nSOCKET __stdcall socket(int, int, int);\r\n\r\n#endif\r\n\r\n";
static u8 *  cc_headers$h__mingw = 
(byte*)"/*\r\n * _mingw.h\r\n *\r\n *  This file is for TinyCC and not part of the Mingw32 package.\r\n *\r\n *  THIS SOFTWARE IS NOT COPYRIGHTED\r\n *\r\n *  This source code is offered for use in the public domain. You may\r\n *  use, modify or distribute it freely.\r\n *\r\n *  This code is distributed in the hope that it will be useful but\r\n *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY\r\n *  DISCLAIMED. This includes but is not limited to warranties of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n *\r\n */\r\n\r\n#ifndef __MINGW_H\r\n#define __MINGW_H\r\n\r\n/* some winapi files define these before including _mingw.h --> */\r\n#undef __cdecl\r\n#undef _X86_\r\n#undef WIN32\r\n/* <-- */\r\n\r\n#include <stddef.h>\r\n#include <stdarg.h>\r\n\r\n#define __int8 char\r\n#define __int16 short\r\n#define __int32 int\r\n#define __int64 long long\r\n#define _HAVE_INT64\r\n\r\n#define __cdecl\r\n#define __declspec(x) __attribute__((x))\r\n#define __unaligned __attribute__((packed))\r\n#define __fastcall __attribute__((fastcall))\r\n\r\n#define __MSVCRT__ 1\r\n#undef _MSVCRT_\r\n#define __MINGW_IMPORT extern __declspec(dllimport)\r\n#define __MINGW_ATTRIB_NORETURN\r\n#define __MINGW_ATTRIB_CONST\r\n#define __MINGW_ATTRIB_DEPRECATED\r\n#define __MINGW_ATTRIB_MALLOC\r\n#define __MINGW_ATTRIB_PURE\r\n#define __MINGW_ATTRIB_NONNULL(arg)\r\n#define __MINGW_NOTHROW\r\n#define __GNUC_VA_LIST\r\n\r\n#define _CRTIMP extern\r\n#define __CRT_INLINE extern __inline__\r\n\r\n#define _CRT_ALIGN(x) __attribute__((aligned(x)))\r\n#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))\r\n#define _CRT_PACKING 8\r\n#define __CRT_UNALIGNED\r\n#define _CONST_RETURN\r\n\r\n#ifndef _TRUNCATE\r\n#define _TRUNCATE ((size_t)-1)\r\n#endif\r\n\r\n#define __CRT_STRINGIZE(_Value) #_Value\r\n#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)\r\n#define __CRT_WIDE(_String) L ## _String\r\n#define _CRT_WIDE(_String) __CRT_WIDE(_String)\r\n\r\n#ifdef _WIN64\r\n#define __stdcall\r\n#define _AMD64_ 1\r\n#define __x86_64 1\r\n#define _M_X64 100 /* Visual Studio */\r\n#define _M_AMD64 100 /* Visual Studio */\r\n#define USE_MINGW_SETJMP_TWO_ARGS\r\n#define mingw_getsp tinyc_getbp\r\n#define __TRY__\r\n#else\r\n#define __stdcall __attribute__((__stdcall__))\r\n#define _X86_ 1\r\n#define _M_IX86 300 /* Visual Studio */\r\n#define WIN32 1\r\n#define _USE_32BIT_TIME_T\r\n#ifdef __arm__\r\n#define __TRY__\r\n#else\r\n#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);\r\n#endif\r\n#endif\r\n\r\n/* in stddef.h */\r\n#define _SIZE_T_DEFINED\r\n#define _SSIZE_T_DEFINED\r\n#define _PTRDIFF_T_DEFINED\r\n#define _WCHAR_T_DEFINED\r\n#define _UINTPTR_T_DEFINED\r\n#define _INTPTR_T_DEFINED\r\n#define _INTEGRAL_MAX_BITS 64\r\n\r\n#ifndef _TIME32_T_DEFINED\r\n#define _TIME32_T_DEFINED\r\ntypedef long __time32_t;\r\n#endif\r\n\r\n#ifndef _TIME64_T_DEFINED\r\n#define _TIME64_T_DEFINED\r\ntypedef long long __time64_t;\r\n#endif\r\n\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\n#ifdef _USE_32BIT_TIME_T\r\ntypedef __time32_t time_t;\r\n#else\r\ntypedef __time64_t time_t;\r\n#endif\r\n#endif\r\n\r\n#ifndef _WCTYPE_T_DEFINED\r\n#define _WCTYPE_T_DEFINED\r\ntypedef wchar_t wctype_t;\r\n#endif\r\n\r\n#ifndef _WINT_T\r\n#define _WINT_T\r\ntypedef short wint_t;\r\n#endif\r\n\r\ntypedef int errno_t;\r\n#define _ERRCODE_DEFINED\r\n\r\ntypedef struct threadlocaleinfostruct *pthreadlocinfo;\r\ntypedef struct threadmbcinfostruct *pthreadmbcinfo;\r\ntypedef struct localeinfo_struct _locale_tstruct,*_locale_t;\r\n\r\n/* for winapi */\r\n#define _ANONYMOUS_UNION\r\n#define _ANONYMOUS_STRUCT\r\n#define DECLSPEC_NORETURN\r\n#define DECLARE_STDCALL_P(type) __stdcall type\r\n#define NOSERVICE 1\r\n#define NOMCX 1\r\n#define NOIME 1\r\n#define __INTRIN_H_\r\n#ifndef DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME1\r\n#  define DUMMYUNIONNAME2\r\n#  define DUMMYUNIONNAME3\r\n#  define DUMMYUNIONNAME4\r\n#  define DUMMYUNIONNAME5\r\n#endif\r\n#ifndef DUMMYSTRUCTNAME\r\n#  define DUMMYSTRUCTNAME\r\n#endif\r\n#ifndef WINVER\r\n# define WINVER 0x0502\r\n#endif\r\n#ifndef _WIN32_WINNT\r\n# define _WIN32_WINNT 0x502\r\n#endif\r\n\r\n#define __C89_NAMELESS\r\n#define __MINGW_EXTENSION\r\n#define WINAPI_FAMILY_PARTITION(X) 1\r\n#define MINGW_HAS_SECURE_API\r\n\r\n#endif /* __MINGW_H */\r\n";
static u8 *  cc_headers$h_windowsx = (byte*)"/* Header windowsx.h */\r\n\r\n#ifndef $windowsx\r\n#define $windowsx 1\r\n\r\n#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))\r\n#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))\r\n\r\n#endif // windowsx\r\n\r\n";
static u8 *  cc_headers$stdhdrnames[42] = {
    (byte*)"bcc.h",
    (byte*)"assert.h",
    (byte*)"ctype.h",
    (byte*)"errno.h",
    (byte*)"fenv.h",
    (byte*)"float.h",
    (byte*)"inttypes.h",
    (byte*)"stdint.h",
    (byte*)"limits.h",
    (byte*)"locale.h",
    (byte*)"_ansi.h",
    (byte*)"math.h",
    (byte*)"setjmp.h",
    (byte*)"signal.h",
    (byte*)"stdarg.h",
    (byte*)"stdbool.h",
    (byte*)"stddef.h",
    (byte*)"stdio.h",
    (byte*)"stdlib.h",
    (byte*)"_syslist.h",
    (byte*)"string.h",
    (byte*)"time.h",
    (byte*)"utime.h",
    (byte*)"unistd.h",
    (byte*)"safelib.h",
    (byte*)"wchar.h",
    (byte*)"wctype.h",
    (byte*)"sys/types.h",
    (byte*)"sys/stat.h",
    (byte*)"sys/timeb.h",
    (byte*)"sys/utime.h",
    (byte*)"malloc.h",
    (byte*)"windows.h",
    (byte*)"fcntl.h",
    (byte*)"io.h",
    (byte*)"direct.h",
    (byte*)"process.h",
    (byte*)"memory.h",
    (byte*)"conio.h",
    (byte*)"winsock2.h",
    (byte*)"_mingw.h",
    (byte*)"windowsx.h"
};
static u8 **  cc_headers$stdhdrtext[42] = {
    &cc_headers$h_bcc,
    &cc_headers$h_assert,
    &cc_headers$h_ctype,
    &cc_headers$h_errno,
    &cc_headers$h_fenv,
    &cc_headers$h_float,
    &cc_headers$h_inttypes,
    &cc_headers$h_stdint,
    &cc_headers$h_limits,
    &cc_headers$h_locale,
    &cc_headers$h__ansi,
    &cc_headers$h_math,
    &cc_headers$h_setjmp,
    &cc_headers$h_signal,
    &cc_headers$h_stdarg,
    &cc_headers$h_stdbool,
    &cc_headers$h_stddef,
    &cc_headers$h_stdio,
    &cc_headers$h_stdlib,
    &cc_headers$h__syslist,
    &cc_headers$h_string,
    &cc_headers$h_time,
    &cc_headers$h_utime,
    &cc_headers$h_unistd,
    &cc_headers$h_safelib,
    &cc_headers$h_wchar,
    &cc_headers$h_wctype,
    &cc_headers$h_systypes,
    &cc_headers$h_sysstat,
    &cc_headers$h_systimeb,
    &cc_headers$h_sysutime,
    &cc_headers$h_malloc,
    &cc_headers$h_windows,
    &cc_headers$h_fcntl,
    &cc_headers$h_io,
    &cc_headers$h_direct,
    &cc_headers$h_process,
    &cc_headers$h_memory,
    &cc_headers$h_conio,
    &cc_headers$h_winsock2,
    &cc_headers$h__mingw,
    &cc_headers$h_windowsx
};
static struct cc_decls$tokenrec *  cc_lex$tkptr = 0;
static i64 cc_lex$dowhitespace = (i64)0;
static i64 cc_lex$nincludes;
static struct cc_decls$tokenrec cc_lex$normaltkx;
static struct cc_decls$tokenrec *  cc_lex$normaltk = (struct cc_decls$tokenrec *)&cc_lex$normaltkx;
static i64 cc_lex$noexpand = (i64)0;
static struct cc_lex$stackinforec cc_lex$lx_stack[20];
static i64 cc_lex$lx_stackindex;
static i64 cc_lex$ifcondlevel = (i64)0;
static u8 *  cc_lex$headerpathlist[20];
static u8 cc_lex$headerpath[300];
static u8 *  cc_lex$lxstart;
static u8 *  cc_lex$lxsptr;
static i64 cc_lex$lxhashvalue;
static u8 *  cc_lex$lxsvalue;
static u8 cc_lex$alphamap[256];
static u8 cc_lex$digitmap[256];
static u8 cc_lex$commentmap[256];
static u8 cc_lex$linecommentmap[256];
static u8 cc_lex$spacemap[256];
static struct mlib$strbuffer *  cc_lex$destcopy;
static u8 *  cc_lex$pastedtokenlist[7000];
static i64 cc_lex$npastedtokens = (i64)0;
static i64 cc_lex$isincludefile = (i64)0;
static i64 cc_lex$firstsymbol = (i64)1;
static byte *  cc_lex$reallxsptr;
static i64 cc_lex$nhstsymbols;
static i64 cc_lex$hstthreshold;
static i64 cc_lex$lasttoken = (i64)0;
static i64 cc_lib$autotypeno = (i64)0;
static i64 cc_lib$currlineno;
static i64 cc_lib$nextafindex = (i64)0;
static struct mlib$strbuffer cc_lib$exprstrvar;
static struct mlib$strbuffer *  cc_lib$exprstr = (struct mlib$strbuffer *)&cc_lib$exprstrvar;
static struct cc_decls$unitrec *  cc_lib$unitheapptr = 0;
static i64 cc_lib$remainingunits = (i64)0;
static i64 cc_libmcl$nmemaddr;
static i64 cc_libmcl$nmem;
static struct cc_libmcl$opndrec *  cc_libmcl$commentop;
static i64 cc_libmcl$fshowfullnames = (i64)1;
static i64 cc_libmcl$fshowmsource = (i64)0;
static i64 cc_libmcl$fabsused = (i64)0;
static i64 cc_libmcl$fchsused = (i64)0;
static i64 cc_libmcl$kk0used = (i64)0;
static i64 cc_libmcl$retindex;
static i64 cc_libmcl$stackaligned;
static u8 *  cc_libmcl$mclnames[104] = {
    (byte*)"m_comment",
    (byte*)"m_blank",
    (byte*)"m_label",
    (byte*)"m_labelname",
    (byte*)"m_mov",
    (byte*)"m_push",
    (byte*)"m_pop",
    (byte*)"m_lea",
    (byte*)"m_cmovcc",
    (byte*)"m_fmov",
    (byte*)"m_iwiden",
    (byte*)"m_uwiden",
    (byte*)"m_inarrow",
    (byte*)"m_unarrow",
    (byte*)"m_call",
    (byte*)"m_ret",
    (byte*)"m_retn",
    (byte*)"m_jmp",
    (byte*)"m_jmpcc",
    (byte*)"m_exch",
    (byte*)"m_add",
    (byte*)"m_sub",
    (byte*)"m_imul",
    (byte*)"m_idiv",
    (byte*)"m_udiv",
    (byte*)"m_irem",
    (byte*)"m_urem",
    (byte*)"m_and",
    (byte*)"m_or",
    (byte*)"m_xor",
    (byte*)"m_test",
    (byte*)"m_cmp",
    (byte*)"m_shl",
    (byte*)"m_ishr",
    (byte*)"m_ushr",
    (byte*)"m_neg",
    (byte*)"m_not",
    (byte*)"m_inc",
    (byte*)"m_dec",
    (byte*)"m_setcc",
    (byte*)"m_fneg",
    (byte*)"m_fabs",
    (byte*)"m_fsqrt",
    (byte*)"m_fadd",
    (byte*)"m_fsub",
    (byte*)"m_fmul",
    (byte*)"m_fdiv",
    (byte*)"m_fcmp",
    (byte*)"m_ufix",
    (byte*)"m_ifix",
    (byte*)"m_ufloat",
    (byte*)"m_ifloat",
    (byte*)"m_fwiden",
    (byte*)"m_fnarrow",
    (byte*)"m_fmin",
    (byte*)"m_fmax",
    (byte*)"m_resb",
    (byte*)"m_db",
    (byte*)"m_dw",
    (byte*)"m_dd",
    (byte*)"m_dq",
    (byte*)"m_defstr",
    (byte*)"m_defwstr",
    (byte*)"m_align",
    (byte*)"m_segment",
    (byte*)"m_cdq",
    (byte*)"m_assem",
    (byte*)"m_end",
    (byte*)"mx_imul2",
    (byte*)"mx_sar",
    (byte*)"mx_shr",
    (byte*)"mx_div",
    (byte*)"mx_movzx",
    (byte*)"mx_movsx",
    (byte*)"mx_inot",
    (byte*)"mx_mul",
    (byte*)"mx_movd",
    (byte*)"mx_movq",
    (byte*)"mx_addss",
    (byte*)"mx_addsd",
    (byte*)"mx_subss",
    (byte*)"mx_subsd",
    (byte*)"mx_mulss",
    (byte*)"mx_mulsd",
    (byte*)"mx_divss",
    (byte*)"mx_divsd",
    (byte*)"mx_comiss",
    (byte*)"mx_comisd",
    (byte*)"mx_cvtsi2ss",
    (byte*)"mx_cvtsi2sd",
    (byte*)"mx_cvtss2sd",
    (byte*)"mx_cvtsd2ss",
    (byte*)"mx_cvttss2si",
    (byte*)"mx_cvttsd2si",
    (byte*)"mx_sqrtss",
    (byte*)"mx_sqrtsd",
    (byte*)"mx_minss",
    (byte*)"mx_maxss",
    (byte*)"mx_minsd",
    (byte*)"mx_maxsd",
    (byte*)"mx_xorps",
    (byte*)"mx_xorpd",
    (byte*)"mx_andps",
    (byte*)"mx_andpd"
};
static u8 *  cc_libmcl$opndnames[7] = {(byte*)"a_none",(byte*)"a_reg",(byte*)"a_imm",(byte*)"a_strimm",(byte*)"a_mem",(byte*)"a_code",(byte*)"a_xreg"};
static u8 *  cc_libmcl$regnames[18] = {
    (byte*)"rnone",
    (byte*)"r0",
    (byte*)"r1",
    (byte*)"r2",
    (byte*)"r3",
    (byte*)"r4",
    (byte*)"r5",
    (byte*)"r6",
    (byte*)"r7",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"rframe",
    (byte*)"rstack",
    (byte*)"rfpu"
};
static u8 *  cc_libmcl$xregnames[17] = {
    (byte*)"xnone",
    (byte*)"xr0",
    (byte*)"xr1",
    (byte*)"xr2",
    (byte*)"xr3",
    (byte*)"xr4",
    (byte*)"xr5",
    (byte*)"xr6",
    (byte*)"xr7",
    (byte*)"xr8",
    (byte*)"xr9",
    (byte*)"xr10",
    (byte*)"xr11",
    (byte*)"xr12",
    (byte*)"xr13",
    (byte*)"xr14",
    (byte*)"xr15"
};
static u8 *  cc_libmcl$condnames[22] = {
    (byte*)"ov",
    (byte*)"nov",
    (byte*)"ltu",
    (byte*)"geu",
    (byte*)"eq",
    (byte*)"ne",
    (byte*)"leu",
    (byte*)"gtu",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"lt",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"gt",
    (byte*)"flt",
    (byte*)"fge",
    (byte*)"fle",
    (byte*)"fgt",
    (byte*)"feq",
    (byte*)"fne"
};
static u8 *  cc_libmcl$asmcondnames[22] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"be",
    (byte*)"a",
    (byte*)"z",
    (byte*)"nz"
};
static u8 *  cc_libmcl$valtypenames[11] = {
    (byte*)"no_val",
    (byte*)"int_val",
    (byte*)"real_val",
    (byte*)"string_val",
    (byte*)"wstring_val",
    (byte*)"label_val",
    (byte*)"name_val",
    (byte*)"stringix_val",
    (byte*)"wstringix_val",
    (byte*)"intix_val",
    (byte*)"realix_val"
};
static struct cc_libmcl$mclrec *  cc_libmcl$mccode;
static struct cc_libmcl$mclrec *  cc_libmcl$mccodex;
static struct cc_libmcl$mclrec *  cc_libmcl$modulecode;
static i64 cc_libmcl$currsegment = (i64)0;
static i64 cc_libmcl$currzdataalign = (i64)0;
static i64 cc_libmcl$curridataalign = (i64)0;
static i64 cc_libmcl$framebytes;
static i64 cc_libmcl$parambytes;
static i64 cc_libmcl$frameoffset;
static i64 cc_libmcl$isthreadedproc;
static i64 cc_libmcl$iscallbackproc;
static i64 cc_libmcl$structretoffset;
static struct cc_libmcl$mclrec *  cc_libmcl$stacksetinstr;
static i64 cc_libmcl$currblocksize;
static i64 cc_libmcl$retbeforeblock;
static struct cc_libmcl$opndrec *  cc_libmcl$dstackopnd;
static struct cc_libmcl$opndrec *  cc_libmcl$dframeopnd;
static struct cc_libmcl$opndrec *  cc_libmcl$zero_opnd = 0;
static struct cc_decls$unitrec *  cc_libmcl$zero_unit;
static struct mlib$strbuffer cc_libmcl$sbuffer;
static struct mlib$strbuffer *  cc_libmcl$dest = (struct mlib$strbuffer *)&cc_libmcl$sbuffer;
static struct cc_decls$strec *  cc_parse$ist_symptr;
static i64 cc_parse$insidefor;
static i64 cc_parse$intypeof;
static byte cc_parse$looptypestack[64];
static i64 cc_parse$loopindex;
static struct cc_decls$caserec *  cc_parse$casevaluestack[64];
static byte cc_parse$iscallbackfnx;
static byte cc_parse$constantseen = (byte)(i64)0;
static byte cc_parse$ingeneric = (byte)(i64)0;
static byte cc_support$bytemasks[8] = {(u8)1u,(u8)2u,(u8)4u,(u8)8u,(u8)16u,(u8)32u,(u8)64u,(u8)128u};
static u8 *  cc_tables$stdtypenames[23] = {
    (byte*)"none",
    (byte*)"void",
    (byte*)"schar",
    (byte*)"short",
    (byte*)"int",
    (byte*)"llong",
    (byte*)"bool",
    (byte*)"uchar",
    (byte*)"ushort",
    (byte*)"uint",
    (byte*)"ullong",
    (byte*)"float",
    (byte*)"double",
    (byte*)"ldouble",
    (byte*)"complex",
    (byte*)"enum",
    (byte*)"ref",
    (byte*)"proc",
    (byte*)"label",
    (byte*)"array",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"tlast"
};
static byte cc_tables$stdtypewidths[23] = {
    (u8)0u,
    (u8)0u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)8u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)32u,
    (u8)64u,
    (u8)128u,
    (u8)128u,
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte cc_tables$stdtypesigned[23] = {
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte cc_tables$stdexpandtypes[23] = {
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)9u,
    (u8)9u,
    (u8)9u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte cc_tables$stdtypecat[23] = {
    (u8)0u,
    (u8)0u,
    (byte)'I',
    (byte)'I',
    (byte)'I',
    (byte)'I',
    (byte)'U',
    (byte)'U',
    (byte)'U',
    (byte)'U',
    (byte)'U',
    (byte)'R',
    (byte)'R',
    (byte)'R',
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static u8 *  cc_tables$stdtypemnames[23] = {
    (byte*)"",
    (byte*)"void",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"i64",
    (byte*)"byte",
    (byte*)"byte",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"u64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"r64",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)""
};
static u8 *  cc_tables$typespecnames[16] = {
    (byte*)"ts_void",
    (byte*)"ts_char",
    (byte*)"ts_short",
    (byte*)"ts_long",
    (byte*)"ts_int",
    (byte*)"ts_float",
    (byte*)"ts_double",
    (byte*)"ts_signed",
    (byte*)"ts_unsigned",
    (byte*)"ts_bool",
    (byte*)"ts_complex",
    (byte*)"ts_user",
    (byte*)"ts_struct",
    (byte*)"ts_union",
    (byte*)"ts_enum",
    (byte*)"ts_atomic"
};
static i32 cc_tables$typespectypes[16] = {
    (i32)(i64)1,
    (i32)(i64)2,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)4,
    (i32)(i64)11,
    (i32)(i64)12,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)6,
    (i32)(i64)14,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0
};
static byte cc_tables$typespecsizes[16] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)8u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)0u
};
static u8 *  cc_tables$pmflagnames[4] = {(byte*)"pm_normal",(byte*)"pm_notset",(byte*)"pm_empty",(byte*)"pm_variadic"};
static u8 *  cc_tables$scopenames[5] = {(byte*)"-",(byte*)"Fn",(byte*)"Loc",(byte*)"Imp",(byte*)"Exp"};
static u8 *  cc_tables$ccnames[6] = {(byte*)"open_cc",(byte*)"own_cc",(byte*)"clang_cc",(byte*)"stdcall_cc",(byte*)"callback_cc",(byte*)"dummy_cc"};
static u8 *  cc_tables$linkagenames[6] = {(byte*)"none_ss",(byte*)"static_ss",(byte*)"auto_ss",(byte*)"register_ss",(byte*)"extern_ss",(byte*)"typedef_ss"};
static u8 *  cc_tables$typequalnames[4] = {(byte*)"const_qual",(byte*)"volatile_qual",(byte*)"restrict_qual",(byte*)"atomic_qual"};
static u8 *  cc_tables$fnspecnames[3] = {(byte*)"inline_fnspec",(byte*)"noreturn_fnspec",(byte*)"callback_fnspec"};
static u8 *  cc_tables$jtagnames[79] = {
    (byte*)"j_none",
    (byte*)"j_const",
    (byte*)"j_null",
    (byte*)"j_name",
    (byte*)"j_widenmem",
    (byte*)"j_funcname",
    (byte*)"j_block",
    (byte*)"j_tempdecl",
    (byte*)"j_decl",
    (byte*)"j_callproc",
    (byte*)"j_return",
    (byte*)"j_returnx",
    (byte*)"j_assign",
    (byte*)"j_if",
    (byte*)"j_for",
    (byte*)"j_while",
    (byte*)"j_dowhile",
    (byte*)"j_goto",
    (byte*)"j_labelstmt",
    (byte*)"j_casestmt",
    (byte*)"j_defaultstmt",
    (byte*)"j_break",
    (byte*)"j_continue",
    (byte*)"j_switch",
    (byte*)"j_breaksw",
    (byte*)"&& andl",
    (byte*)"|| orl",
    (byte*)"! notl",
    (byte*)"j_istruel",
    (byte*)"j_makelist",
    (byte*)"j_exprlist",
    (byte*)"j_callfn",
    (byte*)"j_ifx",
    (byte*)"&&",
    (byte*)"==",
    (byte*)"!=",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">",
    (byte*)">=",
    (byte*)"+ add",
    (byte*)"- sub",
    (byte*)"* mul",
    (byte*)"/ div",
    (byte*)"% mod",
    (byte*)"& iand",
    (byte*)"| ior",
    (byte*)"^ ixor",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"j_dot",
    (byte*)"j_idot",
    (byte*)"j_index",
    (byte*)"ptr",
    (byte*)"addptr",
    (byte*)"subptr",
    (byte*)"addrof &",
    (byte*)"j_convert",
    (byte*)"j_scale",
    (byte*)"- neg",
    (byte*)"abs",
    (byte*)"~ inot",
    (byte*)"+=",
    (byte*)"-=",
    (byte*)"*=",
    (byte*)"/=",
    (byte*)"%=",
    (byte*)"&=",
    (byte*)"|=",
    (byte*)"^=",
    (byte*)"<<=",
    (byte*)">>=",
    (byte*)"sqrt",
    (byte*)"++ preincr",
    (byte*)"-- preincr",
    (byte*)"++ postincr",
    (byte*)"-- postdecr",
    (byte*)"cputime",
    (byte*)"j_dummy"
};
static u8 *  cc_tables$symbolnames[105] = {
    (byte*)"errorsym",
    (byte*)"dotsym",
    (byte*)"idotsym",
    (byte*)"lexhashsym",
    (byte*)"hashsym",
    (byte*)"lithashsym",
    (byte*)"hashhashsym",
    (byte*)"commasym",
    (byte*)"semisym",
    (byte*)"colonsym",
    (byte*)"assignsym",
    (byte*)"assignsym2",
    (byte*)"lbracksym",
    (byte*)"rbracksym",
    (byte*)"lsqsym",
    (byte*)"rsqsym",
    (byte*)"lcurlysym",
    (byte*)"rcurlysym",
    (byte*)"questionsym",
    (byte*)"curlsym",
    (byte*)"ellipsissym",
    (byte*)"backslashsym",
    (byte*)"addsym",
    (byte*)"subsym",
    (byte*)"mulsym",
    (byte*)"divsym",
    (byte*)"remsym",
    (byte*)"iorsym",
    (byte*)"iandsym",
    (byte*)"ixorsym",
    (byte*)"orlsym",
    (byte*)"andlsym",
    (byte*)"shlsym",
    (byte*)"shrsym",
    (byte*)"inotsym",
    (byte*)"notlsym",
    (byte*)"incrsym",
    (byte*)"decrsym",
    (byte*)"abssym",
    (byte*)"eqsym",
    (byte*)"nesym",
    (byte*)"ltsym",
    (byte*)"lesym",
    (byte*)"gesym",
    (byte*)"gtsym",
    (byte*)"addtosym",
    (byte*)"subtosym",
    (byte*)"multosym",
    (byte*)"divtosym",
    (byte*)"remtosym",
    (byte*)"iortosym",
    (byte*)"iandtosym",
    (byte*)"ixortosym",
    (byte*)"shltosym",
    (byte*)"shrtosym",
    (byte*)"sqrtsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"rawnumbersym",
    (byte*)"intconstsym",
    (byte*)"realconstsym",
    (byte*)"charconstsym",
    (byte*)"wcharconstsym",
    (byte*)"stringconstsym",
    (byte*)"wstringconstsym",
    (byte*)"whitespacesym",
    (byte*)"placeholdersym",
    (byte*)"kstrincludesym",
    (byte*)"namesym",
    (byte*)"ksourcedirsym",
    (byte*)"predefmacrosym",
    (byte*)"ktypespecsym",
    (byte*)"kifsym",
    (byte*)"kelsesym",
    (byte*)"kcasesym",
    (byte*)"kdefaultsym",
    (byte*)"kforsym",
    (byte*)"kwhilesym",
    (byte*)"kdosym",
    (byte*)"kreturnsym",
    (byte*)"kbreaksym",
    (byte*)"kcontinuesym",
    (byte*)"kgotosym",
    (byte*)"kswitchsym",
    (byte*)"kstructsym",
    (byte*)"kunionsym",
    (byte*)"klinkagesym",
    (byte*)"ktypequalsym",
    (byte*)"kfnspecsym",
    (byte*)"kalignassym",
    (byte*)"kenumsym",
    (byte*)"ksizeofsym",
    (byte*)"klengthofsym",
    (byte*)"kdefinedsym",
    (byte*)"kgenericsym",
    (byte*)"kalignofsym",
    (byte*)"kshowmodesym",
    (byte*)"kshowtypesym",
    (byte*)"ktypeofsym",
    (byte*)"kstrtypesym",
    (byte*)"kmccassertsym",
    (byte*)"kcputimesym",
    (byte*)"kconstantsym",
    (byte*)"kstructinfosym",
    (byte*)"kdummysym"
};
static u8 *  cc_tables$shortsymbolnames[105] = {
    (byte*)"",
    (byte*)".",
    (byte*)"->",
    (byte*)"#",
    (byte*)"#",
    (byte*)"#",
    (byte*)"##",
    (byte*)",",
    (byte*)";",
    (byte*)":",
    (byte*)"=",
    (byte*)":=",
    (byte*)"(",
    (byte*)")",
    (byte*)"[",
    (byte*)"]",
    (byte*)"{",
    (byte*)"}",
    (byte*)"?",
    (byte*)"~",
    (byte*)"...",
    (byte*)"\\",
    (byte*)"+",
    (byte*)"-",
    (byte*)"*",
    (byte*)"/",
    (byte*)"%",
    (byte*)"|",
    (byte*)"&",
    (byte*)"^",
    (byte*)"||",
    (byte*)"&&",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"~",
    (byte*)"!",
    (byte*)"++",
    (byte*)"--",
    (byte*)"abs",
    (byte*)"==",
    (byte*)"!=",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">=",
    (byte*)">",
    (byte*)"+=",
    (byte*)"-=",
    (byte*)"*=",
    (byte*)"/=",
    (byte*)"%=",
    (byte*)"|=",
    (byte*)"&=",
    (byte*)"^=",
    (byte*)"<<=",
    (byte*)">>=",
    (byte*)"sqrt",
    (byte*)"",
    (byte*)"",
    (byte*)"n",
    (byte*)"n",
    (byte*)"n",
    (byte*)"s",
    (byte*)"s",
    (byte*)"s",
    (byte*)"s",
    (byte*)"w",
    (byte*)"",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)""
};
static byte cc_tables$symboltojtag[105] = {
    (u8)0u,
    (u8)50u,
    (u8)51u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)12u,
    (u8)12u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)40u,
    (u8)41u,
    (u8)42u,
    (u8)43u,
    (u8)44u,
    (u8)46u,
    (u8)45u,
    (u8)47u,
    (u8)26u,
    (u8)25u,
    (u8)48u,
    (u8)49u,
    (u8)61u,
    (u8)27u,
    (u8)73u,
    (u8)74u,
    (u8)60u,
    (u8)34u,
    (u8)35u,
    (u8)36u,
    (u8)37u,
    (u8)39u,
    (u8)38u,
    (u8)62u,
    (u8)63u,
    (u8)64u,
    (u8)65u,
    (u8)66u,
    (u8)68u,
    (u8)67u,
    (u8)69u,
    (u8)70u,
    (u8)71u,
    (u8)72u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static u8 *  cc_tables$sourcedirnames[20] = {
    (byte*)"definedir",
    (byte*)"emitdir",
    (byte*)"ifdir",
    (byte*)"elifdir",
    (byte*)"elsedir",
    (byte*)"endifdir",
    (byte*)"includedir",
    (byte*)"ifdefdir",
    (byte*)"ifndefdir",
    (byte*)"undefdir",
    (byte*)"errordir",
    (byte*)"warningdir",
    (byte*)"messagedir",
    (byte*)"pausedir",
    (byte*)"debugondir",
    (byte*)"debugoffdir",
    (byte*)"showmacrodir",
    (byte*)"blankdir",
    (byte*)"linedir",
    (byte*)"pragmadir"
};
static u8 *  cc_tables$namespacenames[5] = {(byte*)"ns_none",(byte*)"ns_general",(byte*)"ns_tags",(byte*)"ns_labels",(byte*)"ns_fields"};
static u8 *  cc_tables$namenames[16] = {
    (byte*)"nullid",
    (byte*)"macroid",
    (byte*)"programid",
    (byte*)"moduleid",
    (byte*)"extmoduleid",
    (byte*)"typeid",
    (byte*)"procid",
    (byte*)"staticid",
    (byte*)"frameid",
    (byte*)"paramid",
    (byte*)"fieldid",
    (byte*)"enumid",
    (byte*)"enumtagid",
    (byte*)"structtagid",
    (byte*)"constantid",
    (byte*)"labelid"
};
static i32 cc_tables$namespaces[16] = {
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)1,
    (i32)(i64)1,
    (i32)(i64)1,
    (i32)(i64)1,
    (i32)(i64)1,
    (i32)(i64)4,
    (i32)(i64)1,
    (i32)(i64)2,
    (i32)(i64)2,
    (i32)(i64)1,
    (i32)(i64)3
};
static u8 *  cc_tables$stnames[77] = {
    (byte*)"if",
    (byte*)"else",
    (byte*)"case",
    (byte*)"default",
    (byte*)"for",
    (byte*)"do",
    (byte*)"while",
    (byte*)"return",
    (byte*)"break",
    (byte*)"continue",
    (byte*)"goto",
    (byte*)"switch",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"include",
    (byte*)"define",
    (byte*)"elif",
    (byte*)"ifdef",
    (byte*)"ifndef",
    (byte*)"endif",
    (byte*)"undef",
    (byte*)"error",
    (byte*)"warning",
    (byte*)"message",
    (byte*)"MESSAGE",
    (byte*)"pragma",
    (byte*)"line",
    (byte*)"pause",
    (byte*)"debugon",
    (byte*)"debugoff",
    (byte*)"showmacro",
    (byte*)"strinclude",
    (byte*)"auto",
    (byte*)"register",
    (byte*)"static",
    (byte*)"extern",
    (byte*)"typedef",
    (byte*)"const",
    (byte*)"volatile",
    (byte*)"restrict",
    (byte*)"_Atomic",
    (byte*)"inline",
    (byte*)"_Noreturn",
    (byte*)"$callback",
    (byte*)"_Alignas",
    (byte*)"enum",
    (byte*)"void",
    (byte*)"char",
    (byte*)"short",
    (byte*)"long",
    (byte*)"int",
    (byte*)"float",
    (byte*)"double",
    (byte*)"signed",
    (byte*)"unsigned",
    (byte*)"_Bool",
    (byte*)"_Complex",
    (byte*)"__DATE__",
    (byte*)"__FILE__",
    (byte*)"__LINE__",
    (byte*)"__TIME__",
    (byte*)"__BCC__",
    (byte*)"__func__",
    (byte*)"__FUNCTION__",
    (byte*)"sizeof",
    (byte*)"$sqrt",
    (byte*)"defined",
    (byte*)"_Generic",
    (byte*)"_Alignof",
    (byte*)"$showmode",
    (byte*)"$showtype",
    (byte*)"typeof",
    (byte*)"strtype",
    (byte*)"_Static_assert",
    (byte*)"cputime",
    (byte*)"structinfo",
    (byte*)"$$dummy"
};
static i32 cc_tables$stsymbols[77] = {
    (i32)(i64)73,
    (i32)(i64)74,
    (i32)(i64)75,
    (i32)(i64)76,
    (i32)(i64)77,
    (i32)(i64)79,
    (i32)(i64)78,
    (i32)(i64)80,
    (i32)(i64)81,
    (i32)(i64)82,
    (i32)(i64)83,
    (i32)(i64)84,
    (i32)(i64)85,
    (i32)(i64)86,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)70,
    (i32)(i64)68,
    (i32)(i64)87,
    (i32)(i64)87,
    (i32)(i64)87,
    (i32)(i64)87,
    (i32)(i64)87,
    (i32)(i64)88,
    (i32)(i64)88,
    (i32)(i64)88,
    (i32)(i64)88,
    (i32)(i64)89,
    (i32)(i64)89,
    (i32)(i64)89,
    (i32)(i64)90,
    (i32)(i64)91,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)72,
    (i32)(i64)71,
    (i32)(i64)71,
    (i32)(i64)71,
    (i32)(i64)71,
    (i32)(i64)71,
    (i32)(i64)71,
    (i32)(i64)71,
    (i32)(i64)92,
    (i32)(i64)56,
    (i32)(i64)94,
    (i32)(i64)95,
    (i32)(i64)96,
    (i32)(i64)97,
    (i32)(i64)98,
    (i32)(i64)99,
    (i32)(i64)100,
    (i32)(i64)101,
    (i32)(i64)102,
    (i32)(i64)104,
    (i32)(i64)0
};
static i32 cc_tables$stsubcodes[77] = {
    (i32)(i64)13,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)7,
    (i32)(i64)1,
    (i32)(i64)4,
    (i32)(i64)8,
    (i32)(i64)9,
    (i32)(i64)6,
    (i32)(i64)10,
    (i32)(i64)11,
    (i32)(i64)12,
    (i32)(i64)13,
    (i32)(i64)13,
    (i32)(i64)20,
    (i32)(i64)19,
    (i32)(i64)14,
    (i32)(i64)15,
    (i32)(i64)16,
    (i32)(i64)17,
    (i32)(i64)0,
    (i32)(i64)2,
    (i32)(i64)3,
    (i32)(i64)1,
    (i32)(i64)4,
    (i32)(i64)5,
    (i32)(i64)1,
    (i32)(i64)2,
    (i32)(i64)3,
    (i32)(i64)4,
    (i32)(i64)1,
    (i32)(i64)2,
    (i32)(i64)3,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)1,
    (i32)(i64)2,
    (i32)(i64)3,
    (i32)(i64)4,
    (i32)(i64)5,
    (i32)(i64)6,
    (i32)(i64)7,
    (i32)(i64)8,
    (i32)(i64)9,
    (i32)(i64)2,
    (i32)(i64)11,
    (i32)(i64)1,
    (i32)(i64)3,
    (i32)(i64)4,
    (i32)(i64)2,
    (i32)(i64)7,
    (i32)(i64)5,
    (i32)(i64)5,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0,
    (i32)(i64)0
};
static u8 *  cc_tables$convnames[14] = {
    (byte*)"no_conv",
    (byte*)"soft_c",
    (byte*)"hard_c",
    (byte*)"swiden_c",
    (byte*)"uwiden_c",
    (byte*)"sfloat_c",
    (byte*)"ufloat_c",
    (byte*)"sfix_c",
    (byte*)"ufix_c",
    (byte*)"fwiden_c",
    (byte*)"fnarrow_c",
    (byte*)"narrow_c",
    (byte*)"truncate_c",
    (byte*)"bool_c"
};
static byte cc_tables$dominantmode[32][32];
static byte cc_tables$conversionops[16][16];
static byte cc_tables$dominantsetuptable[144][3] = {
    {(u8)2u,(u8)2u,(u8)4u},
    {(u8)2u,(u8)3u,(u8)4u},
    {(u8)2u,(u8)4u,(u8)4u},
    {(u8)2u,(u8)5u,(u8)5u},
    {(u8)2u,(u8)6u,(u8)4u},
    {(u8)2u,(u8)7u,(u8)4u},
    {(u8)2u,(u8)8u,(u8)4u},
    {(u8)2u,(u8)9u,(u8)4u},
    {(u8)2u,(u8)10u,(u8)5u},
    {(u8)2u,(u8)11u,(u8)11u},
    {(u8)2u,(u8)12u,(u8)12u},
    {(u8)2u,(u8)13u,(u8)13u},
    {(u8)3u,(u8)2u,(u8)4u},
    {(u8)3u,(u8)3u,(u8)4u},
    {(u8)3u,(u8)4u,(u8)4u},
    {(u8)3u,(u8)5u,(u8)5u},
    {(u8)3u,(u8)6u,(u8)4u},
    {(u8)3u,(u8)7u,(u8)4u},
    {(u8)3u,(u8)8u,(u8)4u},
    {(u8)3u,(u8)9u,(u8)4u},
    {(u8)3u,(u8)10u,(u8)5u},
    {(u8)3u,(u8)11u,(u8)11u},
    {(u8)3u,(u8)12u,(u8)12u},
    {(u8)3u,(u8)13u,(u8)13u},
    {(u8)4u,(u8)2u,(u8)4u},
    {(u8)4u,(u8)3u,(u8)4u},
    {(u8)4u,(u8)4u,(u8)4u},
    {(u8)4u,(u8)5u,(u8)5u},
    {(u8)4u,(u8)6u,(u8)4u},
    {(u8)4u,(u8)7u,(u8)4u},
    {(u8)4u,(u8)8u,(u8)4u},
    {(u8)4u,(u8)9u,(u8)9u},
    {(u8)4u,(u8)10u,(u8)5u},
    {(u8)4u,(u8)11u,(u8)11u},
    {(u8)4u,(u8)12u,(u8)12u},
    {(u8)4u,(u8)13u,(u8)13u},
    {(u8)5u,(u8)2u,(u8)5u},
    {(u8)5u,(u8)3u,(u8)5u},
    {(u8)5u,(u8)4u,(u8)5u},
    {(u8)5u,(u8)5u,(u8)5u},
    {(u8)5u,(u8)6u,(u8)5u},
    {(u8)5u,(u8)7u,(u8)5u},
    {(u8)5u,(u8)8u,(u8)5u},
    {(u8)5u,(u8)9u,(u8)5u},
    {(u8)5u,(u8)10u,(u8)10u},
    {(u8)5u,(u8)11u,(u8)11u},
    {(u8)5u,(u8)12u,(u8)12u},
    {(u8)5u,(u8)13u,(u8)13u},
    {(u8)6u,(u8)2u,(u8)4u},
    {(u8)6u,(u8)3u,(u8)4u},
    {(u8)6u,(u8)4u,(u8)4u},
    {(u8)6u,(u8)5u,(u8)5u},
    {(u8)6u,(u8)6u,(u8)9u},
    {(u8)6u,(u8)7u,(u8)9u},
    {(u8)6u,(u8)8u,(u8)9u},
    {(u8)6u,(u8)9u,(u8)9u},
    {(u8)6u,(u8)10u,(u8)10u},
    {(u8)6u,(u8)11u,(u8)11u},
    {(u8)6u,(u8)12u,(u8)12u},
    {(u8)6u,(u8)13u,(u8)13u},
    {(u8)7u,(u8)2u,(u8)4u},
    {(u8)7u,(u8)3u,(u8)4u},
    {(u8)7u,(u8)4u,(u8)4u},
    {(u8)7u,(u8)5u,(u8)5u},
    {(u8)7u,(u8)6u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)9u},
    {(u8)7u,(u8)8u,(u8)9u},
    {(u8)7u,(u8)9u,(u8)9u},
    {(u8)7u,(u8)10u,(u8)10u},
    {(u8)7u,(u8)11u,(u8)11u},
    {(u8)7u,(u8)12u,(u8)12u},
    {(u8)7u,(u8)13u,(u8)13u},
    {(u8)8u,(u8)2u,(u8)4u},
    {(u8)8u,(u8)3u,(u8)4u},
    {(u8)8u,(u8)4u,(u8)4u},
    {(u8)8u,(u8)5u,(u8)5u},
    {(u8)8u,(u8)6u,(u8)9u},
    {(u8)8u,(u8)7u,(u8)9u},
    {(u8)8u,(u8)8u,(u8)9u},
    {(u8)8u,(u8)9u,(u8)9u},
    {(u8)8u,(u8)10u,(u8)10u},
    {(u8)8u,(u8)11u,(u8)11u},
    {(u8)8u,(u8)12u,(u8)12u},
    {(u8)8u,(u8)13u,(u8)13u},
    {(u8)9u,(u8)2u,(u8)4u},
    {(u8)9u,(u8)3u,(u8)4u},
    {(u8)9u,(u8)4u,(u8)9u},
    {(u8)9u,(u8)5u,(u8)5u},
    {(u8)9u,(u8)6u,(u8)9u},
    {(u8)9u,(u8)7u,(u8)9u},
    {(u8)9u,(u8)8u,(u8)9u},
    {(u8)9u,(u8)9u,(u8)9u},
    {(u8)9u,(u8)10u,(u8)10u},
    {(u8)9u,(u8)11u,(u8)11u},
    {(u8)9u,(u8)12u,(u8)12u},
    {(u8)9u,(u8)13u,(u8)13u},
    {(u8)10u,(u8)2u,(u8)10u},
    {(u8)10u,(u8)3u,(u8)10u},
    {(u8)10u,(u8)4u,(u8)10u},
    {(u8)10u,(u8)5u,(u8)10u},
    {(u8)10u,(u8)6u,(u8)10u},
    {(u8)10u,(u8)7u,(u8)10u},
    {(u8)10u,(u8)8u,(u8)10u},
    {(u8)10u,(u8)9u,(u8)10u},
    {(u8)10u,(u8)10u,(u8)10u},
    {(u8)10u,(u8)11u,(u8)11u},
    {(u8)10u,(u8)12u,(u8)12u},
    {(u8)10u,(u8)13u,(u8)13u},
    {(u8)11u,(u8)2u,(u8)12u},
    {(u8)11u,(u8)3u,(u8)12u},
    {(u8)11u,(u8)4u,(u8)12u},
    {(u8)11u,(u8)5u,(u8)12u},
    {(u8)11u,(u8)6u,(u8)12u},
    {(u8)11u,(u8)7u,(u8)12u},
    {(u8)11u,(u8)8u,(u8)12u},
    {(u8)11u,(u8)9u,(u8)12u},
    {(u8)11u,(u8)10u,(u8)12u},
    {(u8)11u,(u8)11u,(u8)11u},
    {(u8)11u,(u8)12u,(u8)12u},
    {(u8)11u,(u8)13u,(u8)13u},
    {(u8)12u,(u8)2u,(u8)12u},
    {(u8)12u,(u8)3u,(u8)12u},
    {(u8)12u,(u8)4u,(u8)12u},
    {(u8)12u,(u8)5u,(u8)12u},
    {(u8)12u,(u8)6u,(u8)12u},
    {(u8)12u,(u8)7u,(u8)12u},
    {(u8)12u,(u8)8u,(u8)12u},
    {(u8)12u,(u8)9u,(u8)12u},
    {(u8)12u,(u8)10u,(u8)12u},
    {(u8)12u,(u8)11u,(u8)12u},
    {(u8)12u,(u8)12u,(u8)12u},
    {(u8)12u,(u8)13u,(u8)13u},
    {(u8)13u,(u8)2u,(u8)12u},
    {(u8)13u,(u8)3u,(u8)12u},
    {(u8)13u,(u8)4u,(u8)12u},
    {(u8)13u,(u8)5u,(u8)12u},
    {(u8)13u,(u8)6u,(u8)12u},
    {(u8)13u,(u8)7u,(u8)12u},
    {(u8)13u,(u8)8u,(u8)12u},
    {(u8)13u,(u8)9u,(u8)12u},
    {(u8)13u,(u8)10u,(u8)12u},
    {(u8)13u,(u8)11u,(u8)12u},
    {(u8)13u,(u8)12u,(u8)12u},
    {(u8)13u,(u8)13u,(u8)13u}
};
static byte cc_tables$convsetuptable[144][3] = {
    {(u8)2u,(u8)2u,(u8)3u},
    {(u8)2u,(u8)3u,(u8)3u},
    {(u8)2u,(u8)4u,(u8)3u},
    {(u8)2u,(u8)5u,(u8)3u},
    {(u8)2u,(u8)6u,(u8)13u},
    {(u8)2u,(u8)7u,(u8)1u},
    {(u8)2u,(u8)8u,(u8)3u},
    {(u8)2u,(u8)9u,(u8)3u},
    {(u8)2u,(u8)10u,(u8)3u},
    {(u8)2u,(u8)11u,(u8)5u},
    {(u8)2u,(u8)12u,(u8)5u},
    {(u8)2u,(u8)13u,(u8)5u},
    {(u8)3u,(u8)2u,(u8)12u},
    {(u8)3u,(u8)3u,(u8)0u},
    {(u8)3u,(u8)4u,(u8)3u},
    {(u8)3u,(u8)5u,(u8)3u},
    {(u8)3u,(u8)6u,(u8)13u},
    {(u8)3u,(u8)7u,(u8)12u},
    {(u8)3u,(u8)8u,(u8)1u},
    {(u8)3u,(u8)9u,(u8)3u},
    {(u8)3u,(u8)10u,(u8)3u},
    {(u8)3u,(u8)11u,(u8)5u},
    {(u8)3u,(u8)12u,(u8)5u},
    {(u8)3u,(u8)13u,(u8)5u},
    {(u8)4u,(u8)2u,(u8)12u},
    {(u8)4u,(u8)3u,(u8)12u},
    {(u8)4u,(u8)4u,(u8)0u},
    {(u8)4u,(u8)5u,(u8)3u},
    {(u8)4u,(u8)6u,(u8)13u},
    {(u8)4u,(u8)7u,(u8)12u},
    {(u8)4u,(u8)8u,(u8)12u},
    {(u8)4u,(u8)9u,(u8)1u},
    {(u8)4u,(u8)10u,(u8)3u},
    {(u8)4u,(u8)11u,(u8)5u},
    {(u8)4u,(u8)12u,(u8)5u},
    {(u8)4u,(u8)13u,(u8)5u},
    {(u8)5u,(u8)2u,(u8)12u},
    {(u8)5u,(u8)3u,(u8)12u},
    {(u8)5u,(u8)4u,(u8)12u},
    {(u8)5u,(u8)5u,(u8)0u},
    {(u8)5u,(u8)6u,(u8)13u},
    {(u8)5u,(u8)7u,(u8)12u},
    {(u8)5u,(u8)8u,(u8)12u},
    {(u8)5u,(u8)9u,(u8)12u},
    {(u8)5u,(u8)10u,(u8)1u},
    {(u8)5u,(u8)11u,(u8)5u},
    {(u8)5u,(u8)12u,(u8)5u},
    {(u8)5u,(u8)13u,(u8)5u},
    {(u8)6u,(u8)2u,(u8)1u},
    {(u8)6u,(u8)3u,(u8)4u},
    {(u8)6u,(u8)4u,(u8)4u},
    {(u8)6u,(u8)5u,(u8)4u},
    {(u8)6u,(u8)6u,(u8)0u},
    {(u8)6u,(u8)7u,(u8)1u},
    {(u8)6u,(u8)8u,(u8)4u},
    {(u8)6u,(u8)9u,(u8)4u},
    {(u8)6u,(u8)10u,(u8)4u},
    {(u8)6u,(u8)11u,(u8)6u},
    {(u8)6u,(u8)12u,(u8)6u},
    {(u8)6u,(u8)13u,(u8)6u},
    {(u8)7u,(u8)2u,(u8)1u},
    {(u8)7u,(u8)3u,(u8)4u},
    {(u8)7u,(u8)4u,(u8)4u},
    {(u8)7u,(u8)5u,(u8)4u},
    {(u8)7u,(u8)6u,(u8)13u},
    {(u8)7u,(u8)7u,(u8)1u},
    {(u8)7u,(u8)8u,(u8)4u},
    {(u8)7u,(u8)9u,(u8)4u},
    {(u8)7u,(u8)10u,(u8)4u},
    {(u8)7u,(u8)11u,(u8)6u},
    {(u8)7u,(u8)12u,(u8)6u},
    {(u8)7u,(u8)13u,(u8)6u},
    {(u8)8u,(u8)2u,(u8)12u},
    {(u8)8u,(u8)3u,(u8)1u},
    {(u8)8u,(u8)4u,(u8)4u},
    {(u8)8u,(u8)5u,(u8)4u},
    {(u8)8u,(u8)6u,(u8)13u},
    {(u8)8u,(u8)7u,(u8)12u},
    {(u8)8u,(u8)8u,(u8)0u},
    {(u8)8u,(u8)9u,(u8)4u},
    {(u8)8u,(u8)10u,(u8)4u},
    {(u8)8u,(u8)11u,(u8)6u},
    {(u8)8u,(u8)12u,(u8)6u},
    {(u8)8u,(u8)13u,(u8)6u},
    {(u8)9u,(u8)2u,(u8)12u},
    {(u8)9u,(u8)3u,(u8)12u},
    {(u8)9u,(u8)4u,(u8)1u},
    {(u8)9u,(u8)5u,(u8)4u},
    {(u8)9u,(u8)6u,(u8)13u},
    {(u8)9u,(u8)7u,(u8)12u},
    {(u8)9u,(u8)8u,(u8)12u},
    {(u8)9u,(u8)9u,(u8)0u},
    {(u8)9u,(u8)10u,(u8)4u},
    {(u8)9u,(u8)11u,(u8)6u},
    {(u8)9u,(u8)12u,(u8)6u},
    {(u8)9u,(u8)13u,(u8)6u},
    {(u8)10u,(u8)2u,(u8)12u},
    {(u8)10u,(u8)3u,(u8)12u},
    {(u8)10u,(u8)4u,(u8)12u},
    {(u8)10u,(u8)5u,(u8)1u},
    {(u8)10u,(u8)6u,(u8)13u},
    {(u8)10u,(u8)7u,(u8)12u},
    {(u8)10u,(u8)8u,(u8)12u},
    {(u8)10u,(u8)9u,(u8)12u},
    {(u8)10u,(u8)10u,(u8)0u},
    {(u8)10u,(u8)11u,(u8)6u},
    {(u8)10u,(u8)12u,(u8)6u},
    {(u8)10u,(u8)13u,(u8)6u},
    {(u8)11u,(u8)2u,(u8)7u},
    {(u8)11u,(u8)3u,(u8)7u},
    {(u8)11u,(u8)4u,(u8)7u},
    {(u8)11u,(u8)5u,(u8)7u},
    {(u8)11u,(u8)6u,(u8)8u},
    {(u8)11u,(u8)7u,(u8)8u},
    {(u8)11u,(u8)8u,(u8)8u},
    {(u8)11u,(u8)9u,(u8)8u},
    {(u8)11u,(u8)10u,(u8)8u},
    {(u8)11u,(u8)11u,(u8)0u},
    {(u8)11u,(u8)12u,(u8)9u},
    {(u8)11u,(u8)13u,(u8)9u},
    {(u8)12u,(u8)2u,(u8)7u},
    {(u8)12u,(u8)3u,(u8)7u},
    {(u8)12u,(u8)4u,(u8)7u},
    {(u8)12u,(u8)5u,(u8)7u},
    {(u8)12u,(u8)6u,(u8)8u},
    {(u8)12u,(u8)7u,(u8)8u},
    {(u8)12u,(u8)8u,(u8)8u},
    {(u8)12u,(u8)9u,(u8)8u},
    {(u8)12u,(u8)10u,(u8)8u},
    {(u8)12u,(u8)11u,(u8)10u},
    {(u8)12u,(u8)12u,(u8)0u},
    {(u8)12u,(u8)13u,(u8)0u},
    {(u8)13u,(u8)2u,(u8)7u},
    {(u8)13u,(u8)3u,(u8)7u},
    {(u8)13u,(u8)4u,(u8)7u},
    {(u8)13u,(u8)5u,(u8)7u},
    {(u8)13u,(u8)6u,(u8)8u},
    {(u8)13u,(u8)7u,(u8)8u},
    {(u8)13u,(u8)8u,(u8)8u},
    {(u8)13u,(u8)9u,(u8)8u},
    {(u8)13u,(u8)10u,(u8)8u},
    {(u8)13u,(u8)11u,(u8)10u},
    {(u8)13u,(u8)12u,(u8)0u},
    {(u8)13u,(u8)13u,(u8)0u}
};
static i64 cc_tables$badexprs[34] = {
    (i64)1,
    (i64)3,
    (i64)32,
    (i64)25,
    (i64)26,
    (i64)27,
    (i64)28,
    (i64)30,
    (i64)33,
    (i64)34,
    (i64)35,
    (i64)36,
    (i64)37,
    (i64)39,
    (i64)38,
    (i64)40,
    (i64)41,
    (i64)42,
    (i64)43,
    (i64)44,
    (i64)45,
    (i64)46,
    (i64)47,
    (i64)48,
    (i64)49,
    (i64)50,
    (i64)51,
    (i64)52,
    (i64)53,
    (i64)54,
    (i64)55,
    (i64)59,
    (i64)60,
    (i64)61
};
static i64 aa_decls$lxfileno = (i64)0;
static i64 aa_decls$lxlineno = (i64)0;
static i64 aa_decls$nsourcefiles = (i64)0;
static struct aa_decls$modulerec aa_decls$moduletable[2000];
static u8 *  aa_decls$searchlibs[30];
static u8 *  aa_decls$importlibs[30];
static i64 aa_decls$nmodules;
static i64 aa_decls$nsearchlibs;
static i64 aa_decls$nimportlibs;
static struct aa_decls$strec *  aa_decls$lexhashtable[65536];
static struct aa_decls$strec *  aa_decls$dupltable[65536];
static void *  aa_decls$logdev;
static i64 aa_decls$fverbose = (i64)0;
static i64 aa_decls$fquiet = (i64)0;
static i64 aa_decls$linecount = (i64)0;
static i64 aa_decls$nundefined = (i64)0;
static i64 aa_decls$alineno = (i64)0;
static i64 aa_decls$ss_zdatalen;
static struct aa_decls$dbuffer *  aa_decls$ss_zdata;
static struct aa_decls$dbuffer *  aa_decls$ss_idata;
static struct aa_decls$dbuffer *  aa_decls$ss_code;
static struct aa_decls$relocrec *  aa_decls$ss_idatarelocs;
static struct aa_decls$relocrec *  aa_decls$ss_coderelocs;
static i64 aa_decls$ss_nidatarelocs;
static i64 aa_decls$ss_ncoderelocs;
static struct aa_decls$strec *(*aa_decls$ss_symboltable)[];
static i64 aa_decls$ss_nsymbols;
static i64 aa_decls$ss_symboltablesize;
static struct aa_decls$stlistrec *  aa_decls$globalimportlist;
static struct aa_decls$strec *  aa_decls$modulenamelist;
static i64 aa_decls$currmoduleno;
static i64 aa_disasm$nmodules;
static i64 aa_disasm$xfchsmask_pd;
static u8 *  aa_disasm$opnames[8] = {(byte*)"add",(byte*)"or",(byte*)"adc",(byte*)"sbb",(byte*)"and",(byte*)"sub",(byte*)"xor",(byte*)"cmp"};
static u8 *  aa_disasm$condnames[16] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g"
};
static u8 *  aa_disasm$addrmodenames[3] = {(byte*)"amreg",(byte*)"ammem",(byte*)"amrel"};
static i64 aa_disasm$rex;
static i64 aa_disasm$addrmode;
static i64 aa_disasm$rmreg;
static i64 aa_disasm$rmopc;
static i64 aa_disasm$ripmode;
static i64 aa_disasm$basereg;
static i64 aa_disasm$indexreg;
static i64 aa_disasm$scale;
static i64 aa_disasm$opsize;
static i64 aa_disasm$offset;
static i64 aa_disasm$offsetsize;
static i64 aa_disasm$sizeoverride;
static i64 aa_disasm$addroverride;
static i64 aa_disasm$f2override;
static i64 aa_disasm$f3override;
static u8 aa_disasm$deststr[256];
static u8 *  aa_disasm$destptr;
static byte *  aa_disasm$codeptr;
static byte aa_genss$rex;
static byte aa_genss$sizeoverride;
static byte aa_genss$addroverride;
static byte aa_genss$f2override;
static byte aa_genss$f3override;
static byte aa_genss$nowmask;
static byte aa_genss$usesizeb;
static struct aa_decls$opndrec *  aa_genss$extraparam;
static i64 aa_genss$currseg = (i64)0;
static struct aa_decls$dbuffer *  aa_genss$currdata;
static struct aa_decls$relocrec *  aa_genss$currrelocs;
static i64 aa_genss$nrelocs;
static struct aa_lib$mclrec *  aa_genss$currmcl;
static u8 *  aa_genss$opnames[8] = {(byte*)"add",(byte*)"or",(byte*)"adc",(byte*)"sbb",(byte*)"and",(byte*)"sub",(byte*)"xor",(byte*)"cmp"};
static i64 aa_lex$lxsymbol;
static i64 aa_lex$lxsubcode;
static i64 aa_lex$lxvalue;
static r64 aa_lex$lxxvalue;
static u8 *  aa_lex$lxsvalue;
static i64 aa_lex$lxlength;
static i64 aa_lex$lxhashvalue;
static byte *  aa_lex$lxsptr;
static byte *  aa_lex$lxstart;
static struct aa_decls$strec *  aa_lex$lxsymptr;
static u8 aa_lex$alphamap[256];
static u8 aa_lex$digitmap[256];
static u8 aa_lex$commentmap[256];
static u8 *  aa_lib$opndnames[7] = {(byte*)"a_none",(byte*)"a_reg",(byte*)"a_imm",(byte*)"a_mem",(byte*)"a_cond",(byte*)"a_xreg",(byte*)"a_string"};
static i64 aa_lib$currsegment = (i64)0;
static struct aa_decls$opndrec aa_lib$dstackopnd;
static struct aa_decls$opndrec aa_lib$dframeopnd;
static i64 aa_lib$labelno = (i64)0;
static struct aa_decls$opndrec *  aa_lib$zero_opnd = 0;
static struct aa_lib$mclrec *  aa_lib$mccode;
static struct aa_lib$mclrec *  aa_lib$mccodex;
static struct mlib$strbuffer aa_lib$destv;
static struct mlib$strbuffer *  aa_lib$dest = (struct mlib$strbuffer *)&aa_lib$destv;
static struct aa_decls$opndrec *  aa_lib$regtable[20][8];
static u8 *  aa_mcxdecls$mcxdirnames[14] = {
    (byte*)"pad_dir",
    (byte*)"version_dir",
    (byte*)"code_dir",
    (byte*)"idata_dir",
    (byte*)"zdata_dir",
    (byte*)"reloc_dir",
    (byte*)"dlls_dir",
    (byte*)"libs_dir",
    (byte*)"importsymbols_dir",
    (byte*)"exportsymbols_dir",
    (byte*)"exportsegs_dir",
    (byte*)"exportoffsets_dir",
    (byte*)"entry_dir",
    (byte*)"end_dir"
};
static u8 *  aa_mcxdecls$mcxrelocnames[6] = {(byte*)"no_rel",(byte*)"locabs32",(byte*)"locabs64",(byte*)"impabs32",(byte*)"impabs64",(byte*)"imprel32"};
static u8 *  aa_mcxdecls$segmentnames[5] = {(byte*)"code",(byte*)"idata",(byte*)"zdata",(byte*)"rodata",(byte*)"impdata_seg"};
static u8 *  aa_mcxdecls$dllnametable[20];
static u64 aa_mcxdecls$dllinsttable[20];
static i64 aa_mcxdecls$ndlllibs;
static u8 *  aa_mcxdecls$libnametable[20];
static struct aa_mcxdecls$librec *  aa_mcxdecls$libtable[20];
static byte aa_mcxdecls$libdefined[20];
static i64 aa_mcxdecls$nlibs;
static u8 *  aa_mcxdecls$symbolnametable[3000];
static byte aa_mcxdecls$symboldefined[3000];
static void *  aa_mcxdecls$symboladdress[3000];
static i16 aa_mcxdecls$symbollibindex[3000];
static byte aa_mcxdecls$symboldllindex[3000];
static i64 aa_mcxdecls$nsymbols;
static u8 *  aa_objdecls$relocnames[7] = {(byte*)"abs_rel",(byte*)"addr64_rel",(byte*)"addr32_rel",(byte*)"addr32nb_rel",(byte*)"rel32_rel",(byte*)"rel321_rel",(byte*)"rel8_rel"};
static u8 *  aa_objdecls$coffscopenames[3] = {(byte*)"cofflocal_scope",(byte*)"export_scope",(byte*)"import_scope"};
static struct aa_decls$strec *  aa_parse$exprlabeldef;
static i64 aa_parse$exprvalue;
static i64 aa_parse$exprtype;
static u8 *  aa_tables$symbolnames[35] = {
    (byte*)"errorsym",
    (byte*)"commasym",
    (byte*)"colonsym",
    (byte*)"dcolonsym",
    (byte*)"lsqsym",
    (byte*)"rsqsym",
    (byte*)"addsym",
    (byte*)"subsym",
    (byte*)"mulsym",
    (byte*)"eqsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"hashsym",
    (byte*)"intconstsym",
    (byte*)"realconstsym",
    (byte*)"stringconstsym",
    (byte*)"namesym",
    (byte*)"namedconstsym",
    (byte*)"fwdlocalsym",
    (byte*)"localsym",
    (byte*)"importedsym",
    (byte*)"exportedsym",
    (byte*)"kopcodesym",
    (byte*)"kregsym",
    (byte*)"kxregsym",
    (byte*)"kfregsym",
    (byte*)"kmregsym",
    (byte*)"kjmpccsym",
    (byte*)"ksetccsym",
    (byte*)"kmovccsym",
    (byte*)"kprefixsym",
    (byte*)"ksegnamesym",
    (byte*)"kimportlibsym",
    (byte*)"kimportdllsym",
    (byte*)"kdummysym"
};
static u8 *  aa_tables$mclnames[147] = {
    (byte*)"m_comment",
    (byte*)"m_blank",
    (byte*)"m_end",
    (byte*)"m_labelx",
    (byte*)"m_nop",
    (byte*)"m_param",
    (byte*)"m_assem",
    (byte*)"m_proc",
    (byte*)"m_mov",
    (byte*)"m_newmov",
    (byte*)"m_push",
    (byte*)"m_pop",
    (byte*)"m_lea",
    (byte*)"m_cmovcc",
    (byte*)"m_movd",
    (byte*)"m_movq",
    (byte*)"m_movsx",
    (byte*)"m_movzx",
    (byte*)"m_movsxd",
    (byte*)"m_call",
    (byte*)"m_ret",
    (byte*)"m_retn",
    (byte*)"m_leave",
    (byte*)"m_jmp",
    (byte*)"m_jmpcc",
    (byte*)"m_xchg",
    (byte*)"m_add",
    (byte*)"m_sub",
    (byte*)"m_adc",
    (byte*)"m_sbb",
    (byte*)"m_and",
    (byte*)"m_or",
    (byte*)"m_xor",
    (byte*)"m_newadd",
    (byte*)"m_newsub",
    (byte*)"m_test",
    (byte*)"m_imul",
    (byte*)"m_mul",
    (byte*)"m_imul2",
    (byte*)"m_imul3",
    (byte*)"m_idiv",
    (byte*)"m_div",
    (byte*)"m_cmp",
    (byte*)"m_shl",
    (byte*)"m_sar",
    (byte*)"m_shr",
    (byte*)"m_rol",
    (byte*)"m_ror",
    (byte*)"m_rcl",
    (byte*)"m_rcr",
    (byte*)"m_neg",
    (byte*)"m_not",
    (byte*)"m_inc",
    (byte*)"m_dec",
    (byte*)"m_cbw",
    (byte*)"m_cwd",
    (byte*)"m_cdq",
    (byte*)"m_cqo",
    (byte*)"m_setcc",
    (byte*)"m_bsf",
    (byte*)"m_bsr",
    (byte*)"m_sqrtsd",
    (byte*)"m_sqrtss",
    (byte*)"m_addss",
    (byte*)"m_subss",
    (byte*)"m_mulss",
    (byte*)"m_divss",
    (byte*)"m_addsd",
    (byte*)"m_subsd",
    (byte*)"m_mulsd",
    (byte*)"m_divsd",
    (byte*)"m_comiss",
    (byte*)"m_comisd",
    (byte*)"m_xorpd",
    (byte*)"m_xorps",
    (byte*)"m_andpd",
    (byte*)"m_andps",
    (byte*)"m_pxor",
    (byte*)"m_pand",
    (byte*)"m_cvtss2si",
    (byte*)"m_cvtsd2si",
    (byte*)"m_cvttss2si",
    (byte*)"m_cvttsd2si",
    (byte*)"m_cvtsi2ss",
    (byte*)"m_cvtsi2sd",
    (byte*)"m_cvtsd2ss",
    (byte*)"m_cvtss2sd",
    (byte*)"m_movdqa",
    (byte*)"m_movdqu",
    (byte*)"m_pcmpistri",
    (byte*)"m_pcmpistrm",
    (byte*)"m_fld",
    (byte*)"m_fst",
    (byte*)"m_fstp",
    (byte*)"m_fild",
    (byte*)"m_fist",
    (byte*)"m_fistp",
    (byte*)"m_fadd",
    (byte*)"m_fsub",
    (byte*)"m_fmul",
    (byte*)"m_fdiv",
    (byte*)"m_fsqrt",
    (byte*)"m_fsin",
    (byte*)"m_fcos",
    (byte*)"m_fsincos",
    (byte*)"m_fptan",
    (byte*)"m_fpatan",
    (byte*)"m_fabs",
    (byte*)"m_fchs",
    (byte*)"m_minss",
    (byte*)"m_maxss",
    (byte*)"m_minsd",
    (byte*)"m_maxsd",
    (byte*)"m_db",
    (byte*)"m_dw",
    (byte*)"m_dd",
    (byte*)"m_dq",
    (byte*)"m_segment",
    (byte*)"m_isegment",
    (byte*)"m_zsegment",
    (byte*)"m_csegment",
    (byte*)"m_align",
    (byte*)"m_resb",
    (byte*)"m_resw",
    (byte*)"m_resd",
    (byte*)"m_resq",
    (byte*)"m_xlat",
    (byte*)"m_loopnz",
    (byte*)"m_loopz",
    (byte*)"m_loopcx",
    (byte*)"m_jecxz",
    (byte*)"m_jrcxz",
    (byte*)"m_cmpsb",
    (byte*)"m_cmpsw",
    (byte*)"m_cmpsd",
    (byte*)"m_cmpsq",
    (byte*)"m_rdtsc",
    (byte*)"m_popcnt",
    (byte*)"m_finit",
    (byte*)"m_fldz",
    (byte*)"m_fld1",
    (byte*)"m_fldpi",
    (byte*)"m_fld2t",
    (byte*)"m_fld2e",
    (byte*)"m_fldlg2",
    (byte*)"m_fldln2",
    (byte*)"m_halt"
};
static byte aa_tables$mclnopnds[147] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte aa_tables$mclcodes[147] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)144u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)232u,
    (u8)195u,
    (u8)0u,
    (u8)201u,
    (u8)233u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)5u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)1u,
    (u8)6u,
    (u8)0u,
    (u8)5u,
    (u8)0u,
    (u8)5u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)7u,
    (u8)6u,
    (u8)7u,
    (u8)4u,
    (u8)7u,
    (u8)5u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)188u,
    (u8)189u,
    (u8)81u,
    (u8)81u,
    (u8)88u,
    (u8)92u,
    (u8)89u,
    (u8)94u,
    (u8)88u,
    (u8)92u,
    (u8)89u,
    (u8)94u,
    (u8)0u,
    (u8)0u,
    (u8)87u,
    (u8)87u,
    (u8)84u,
    (u8)84u,
    (u8)239u,
    (u8)219u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)102u,
    (u8)243u,
    (u8)99u,
    (u8)98u,
    (u8)0u,
    (u8)2u,
    (u8)3u,
    (u8)0u,
    (u8)2u,
    (u8)3u,
    (u8)193u,
    (u8)233u,
    (u8)201u,
    (u8)249u,
    (u8)250u,
    (u8)254u,
    (u8)255u,
    (u8)251u,
    (u8)242u,
    (u8)243u,
    (u8)225u,
    (u8)224u,
    (u8)93u,
    (u8)95u,
    (u8)93u,
    (u8)95u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)8u,
    (u8)215u,
    (u8)224u,
    (u8)225u,
    (u8)226u,
    (u8)227u,
    (u8)227u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)49u,
    (u8)0u,
    (u8)0u,
    (u8)238u,
    (u8)232u,
    (u8)235u,
    (u8)233u,
    (u8)234u,
    (u8)236u,
    (u8)237u,
    (u8)244u
};
static u8 *  aa_tables$regnames[21] = {
    (byte*)"rnone",
    (byte*)"r0",
    (byte*)"r1",
    (byte*)"r2",
    (byte*)"r3",
    (byte*)"r4",
    (byte*)"r5",
    (byte*)"r6",
    (byte*)"r7",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15",
    (byte*)"r16",
    (byte*)"r17",
    (byte*)"r18",
    (byte*)"r19"
};
static byte aa_tables$regcodes[21] = {
    (u8)0u,
    (u8)0u,
    (u8)10u,
    (u8)11u,
    (u8)7u,
    (u8)3u,
    (u8)6u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)1u,
    (u8)2u,
    (u8)8u,
    (u8)9u,
    (u8)5u,
    (u8)4u,
    (u8)4u,
    (u8)7u,
    (u8)5u,
    (u8)6u
};
static u8 *  aa_tables$dregnames[136] = {
    (byte*)"d0",
    (byte*)"d1",
    (byte*)"d2",
    (byte*)"d3",
    (byte*)"d4",
    (byte*)"d5",
    (byte*)"d6",
    (byte*)"d7",
    (byte*)"d8",
    (byte*)"d9",
    (byte*)"d10",
    (byte*)"d11",
    (byte*)"d12",
    (byte*)"d13",
    (byte*)"d14",
    (byte*)"d15",
    (byte*)"a0",
    (byte*)"a1",
    (byte*)"a2",
    (byte*)"a3",
    (byte*)"a4",
    (byte*)"a5",
    (byte*)"a6",
    (byte*)"a7",
    (byte*)"a8",
    (byte*)"a9",
    (byte*)"a10",
    (byte*)"a11",
    (byte*)"a12",
    (byte*)"a13",
    (byte*)"a14",
    (byte*)"a15",
    (byte*)"w0",
    (byte*)"w1",
    (byte*)"w2",
    (byte*)"w3",
    (byte*)"w4",
    (byte*)"w5",
    (byte*)"w6",
    (byte*)"w7",
    (byte*)"w8",
    (byte*)"w9",
    (byte*)"w10",
    (byte*)"w11",
    (byte*)"w12",
    (byte*)"w13",
    (byte*)"w14",
    (byte*)"w15",
    (byte*)"b0",
    (byte*)"b1",
    (byte*)"b2",
    (byte*)"b3",
    (byte*)"b4",
    (byte*)"b5",
    (byte*)"b6",
    (byte*)"b7",
    (byte*)"b8",
    (byte*)"b9",
    (byte*)"b10",
    (byte*)"b11",
    (byte*)"b12",
    (byte*)"b13",
    (byte*)"b14",
    (byte*)"b15",
    (byte*)"b16",
    (byte*)"b17",
    (byte*)"b18",
    (byte*)"b19",
    (byte*)"rax",
    (byte*)"rbx",
    (byte*)"rcx",
    (byte*)"rdx",
    (byte*)"rsi",
    (byte*)"rdi",
    (byte*)"rbp",
    (byte*)"rsp",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15",
    (byte*)"eax",
    (byte*)"ebx",
    (byte*)"ecx",
    (byte*)"edx",
    (byte*)"esi",
    (byte*)"edi",
    (byte*)"ebp",
    (byte*)"esp",
    (byte*)"r8d",
    (byte*)"r9d",
    (byte*)"r10d",
    (byte*)"r11d",
    (byte*)"r12d",
    (byte*)"r13d",
    (byte*)"r14d",
    (byte*)"r15d",
    (byte*)"ax",
    (byte*)"bx",
    (byte*)"cx",
    (byte*)"dx",
    (byte*)"si",
    (byte*)"di",
    (byte*)"bp",
    (byte*)"sp",
    (byte*)"r8w",
    (byte*)"r9w",
    (byte*)"r10w",
    (byte*)"r11w",
    (byte*)"r12w",
    (byte*)"r13w",
    (byte*)"r14w",
    (byte*)"r15w",
    (byte*)"al",
    (byte*)"bl",
    (byte*)"cl",
    (byte*)"dl",
    (byte*)"ah",
    (byte*)"bh",
    (byte*)"ch",
    (byte*)"dh",
    (byte*)"sil",
    (byte*)"dil",
    (byte*)"bpl",
    (byte*)"spl",
    (byte*)"r8b",
    (byte*)"r9b",
    (byte*)"r10b",
    (byte*)"r11b",
    (byte*)"r12b",
    (byte*)"r13b",
    (byte*)"r14b",
    (byte*)"r15b"
};
static byte aa_tables$regsizes[136] = {
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u
};
static byte aa_tables$regindices[136] = {
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)17u,
    (u8)18u,
    (u8)19u,
    (u8)20u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)17u,
    (u8)18u,
    (u8)19u,
    (u8)20u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u
};
static u8 *  aa_tables$xregnames[16] = {
    (byte*)"xmm0",
    (byte*)"xmm1",
    (byte*)"xmm2",
    (byte*)"xmm3",
    (byte*)"xmm4",
    (byte*)"xmm5",
    (byte*)"xmm6",
    (byte*)"xmm7",
    (byte*)"xmm8",
    (byte*)"xmm9",
    (byte*)"xmm10",
    (byte*)"xmm11",
    (byte*)"xmm12",
    (byte*)"xmm13",
    (byte*)"xmm14",
    (byte*)"xmm15"
};
static u8 *  aa_tables$fregnames[8] = {(byte*)"st0",(byte*)"st1",(byte*)"st2",(byte*)"st3",(byte*)"st4",(byte*)"st5",(byte*)"st6",(byte*)"st7"};
static u8 *  aa_tables$mregnames[8] = {(byte*)"mmx0",(byte*)"mmx1",(byte*)"mmx2",(byte*)"mmx3",(byte*)"mmx4",(byte*)"mmx5",(byte*)"mmx6",(byte*)"mmx7"};
static u8 *  aa_tables$condnames[16] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g"
};
static u8 *  aa_tables$jmpccnames[18] = {
    (byte*)"jo",
    (byte*)"jno",
    (byte*)"jb",
    (byte*)"jae",
    (byte*)"jz",
    (byte*)"jnz",
    (byte*)"jbe",
    (byte*)"ja",
    (byte*)"js",
    (byte*)"jns",
    (byte*)"jp",
    (byte*)"jnp",
    (byte*)"jl",
    (byte*)"jge",
    (byte*)"jle",
    (byte*)"jg",
    (byte*)"jc",
    (byte*)"jnc"
};
static byte aa_tables$jmpcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
static u8 *  aa_tables$setccnames[18] = {
    (byte*)"seto",
    (byte*)"setno",
    (byte*)"setb",
    (byte*)"setae",
    (byte*)"setz",
    (byte*)"setnz",
    (byte*)"setbe",
    (byte*)"seta",
    (byte*)"sets",
    (byte*)"setns",
    (byte*)"setp",
    (byte*)"setnp",
    (byte*)"setl",
    (byte*)"setge",
    (byte*)"setle",
    (byte*)"setg",
    (byte*)"setc",
    (byte*)"setnc"
};
static byte aa_tables$setcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
static u8 *  aa_tables$cmovccnames[18] = {
    (byte*)"cmovo",
    (byte*)"cmovno",
    (byte*)"cmovb",
    (byte*)"cmovae",
    (byte*)"cmovz",
    (byte*)"cmovnz",
    (byte*)"cmovbe",
    (byte*)"cmova",
    (byte*)"cmovs",
    (byte*)"cmovns",
    (byte*)"cmovp",
    (byte*)"cmovnp",
    (byte*)"cmovl",
    (byte*)"cmovge",
    (byte*)"cmovle",
    (byte*)"cmovg",
    (byte*)"cmovc",
    (byte*)"cmovnc"
};
static byte aa_tables$cmovcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
static u8 *  aa_tables$prefixnames[16] = {
    (byte*)"byte",
    (byte*)"u8",
    (byte*)"word",
    (byte*)"word16",
    (byte*)"u16",
    (byte*)"word32",
    (byte*)"dword",
    (byte*)"u32",
    (byte*)"word64",
    (byte*)"qword",
    (byte*)"u64",
    (byte*)"tword",
    (byte*)"word80",
    (byte*)"u80",
    (byte*)"word128",
    (byte*)"u128"
};
static byte aa_tables$prefixsizes[16] = {
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)10u,
    (u8)10u,
    (u8)10u,
    (u8)16u,
    (u8)16u
};
static u8 *  aa_tables$reftypenames[3] = {(byte*)"extern_ref",(byte*)"fwd_ref",(byte*)"back_ref"};
static i64 aa_writeexe$libinsttable[30];
static u8 *  aa_writeexe$libinstnames[30];
static i64 aa_writeexe$libnotable[30];
static struct aa_writeexe$basereloc *  aa_writeexe$basereloclist;
static i64 aa_writeexe$nbaserelocs;
static i64 aa_writeexe$maxrelocaddr;
static i64 aa_writeexe$blockbases[500];
static i32 aa_writeexe$blockcounts[500];
static i32 aa_writeexe$blockbytes[500];
static byte aa_writeexe$blockpadding[500];
static i64 aa_writeexe$nbaseblocks;
static i64 aa_writeexe$basetablesize;
static u64 aa_writeexe$imagebase;
static i64 aa_writeexe$imagesize;
static i64 aa_writeexe$filesize;
static i64 (*aa_writeexe$thunktable)[];
static i64 aa_writeexe$fileiatoffset;
static i64 aa_writeexe$fileiatsize;
static struct aa_decls$strec *  aa_writeexe$stentrypoint;
static struct aa_decls$strec *  aa_writeexe$stentrypoint2;
static struct aa_decls$strec *  aa_writeexe$stentrypoint3;
static struct aa_objdecls$sectionrec aa_writeexe$sectiontable[10];
static i64 aa_writeexe$nsections;
static byte *  aa_writeexe$importdir;
static struct aa_objdecls$importrec aa_writeexe$importtable[1000];
static i64 aa_writeexe$nimports;
static struct aa_objdecls$exportrec aa_writeexe$exporttable[3000];
static i64 aa_writeexe$nexports;
static u8 *  aa_writeexe$dllfilename;
static i64 aa_writeexe$isdll;
static struct aa_objdecls$dllrec aa_writeexe$dlltable[50];
static i64 aa_writeexe$ndlls;
static byte *  aa_writeexe$datastart;
static byte *  aa_writeexe$dataptr;
static u8 *  aa_writeexe$userentrypoint;
static i64 aa_writeexe$exportdirvirtaddr;
static i64 aa_writeexe$exportdirvirtsize;
static i64 aa_writeexe$exportdiroffset;
static i64 aa_writeexe$blockdirvirtaddr;
static i64 aa_writeexe$blockdirvirtsize;
static i64 aa_writeexe$blockdiroffset;
static i64 aa_writeobj$symtaboffset;
static byte *  aa_writeobj$datastart;
static byte *  aa_writeobj$dataptr;
static struct aa_objdecls$imagesymbol aa_writeobj$symboltable[13001];
static i64 aa_writeobj$nsymbols;
static i64 aa_writeobj$stoffset = (i64)0;
static u8 *  aa_writeobj$stringtable[5000];
static i64 aa_writeobj$stringlengths[5000];
static i64 aa_writeobj$nextstringoffset = (i64)0;
static i64 aa_writeobj$nstrings = (i64)0;
static void *  msysc$_fnaddresses[]= {
    &main,
    &cc_cli$compilemodules,
    &cc_cli$debugcompile,
    &cc_cli$do_loadmodule,
    &cc_cli$do_preprocess,
    &cc_cli$do_parsemodule,
    &cc_cli$do_genmcl,
    &cc_cli$do_genasm,
    &cc_cli$do_runprog,
    &cc_cli$loadmainmodule,
    &cc_cli$addmodule,
    &cc_cli$initlogfile,
    &cc_cli$closelogfile,
    &cc_cli$initdata,
    &cc_cli$initsearchdirs,
    &cc_cli$showsearchdirs,
    &cc_cli$showast,
    &cc_cli$showstflat,
    &cc_cli$showsttree,
    &cc_cli$showmcl,
    &cc_cli$showasm,
    &cc_cli$showfiles,
    &cc_cli$starttiming,
    &cc_cli$showtiming,
    &cc_cli$showlps,
    &cc_cli$getinputoptions,
    &cc_cli$do_option,
    &cc_cli$showincludepaths,
    &cc_cli$showhelp,
    &cc_cli$showextrainfo,
    &cc_cli$showcaption,
    &cc_cli$do_genlink,
    &cc_cli$resetcompiler,
    &cc_cli$addnewmodules,
    &cc_cli$writeatfile,
    &cc_cli$start,
    &cc_decls$start,
    &cc_blockmcl$do_stmt,
    &cc_blockmcl$dx_expr,
    &cc_blockmcl$loneexpr,
    &cc_blockmcl$do_assign,
    &cc_blockmcl$dx_assign,
    &cc_blockmcl$saveexpr,
    &cc_blockmcl$fsaveexpr,
    &cc_blockmcl$restoreexpr,
    &cc_blockmcl$frestoreexpr,
    &cc_blockmcl$getlvalueopnd,
    &cc_blockmcl$storeopnd,
    &cc_blockmcl$pushexpr,
    &cc_blockmcl$fpushexpr,
    &cc_blockmcl$dx_const,
    &cc_blockmcl$dx_constant,
    &cc_blockmcl$do_labeldef,
    &cc_blockmcl$do_goto,
    &cc_blockmcl$dx_add,
    &cc_blockmcl$dx_fadd,
    &cc_blockmcl$loadexpr,
    &cc_blockmcl$evalexpr,
    &cc_blockmcl$evaladdr,
    &cc_blockmcl$evalptr,
    &cc_blockmcl$floadexpr,
    &cc_blockmcl$fevalexpr,
    &cc_blockmcl$do_if,
    &cc_blockmcl$genjumpcond,
    &cc_blockmcl$gcomparejump,
    &cc_blockmcl$reversecond,
    &cc_blockmcl$do_preincr,
    &cc_blockmcl$reversemclcond,
    &cc_blockmcl$do_while,
    &cc_blockmcl$do_while1,
    &cc_blockmcl$stacklooplabels,
    &cc_blockmcl$do_dowhile,
    &cc_blockmcl$do_for,
    &cc_blockmcl$pushffparams,
    &cc_blockmcl$pushoneparam,
    &cc_blockmcl$pushfloatparam,
    &cc_blockmcl$loadfloatparam,
    &cc_blockmcl$dx_call,
    &cc_blockmcl$do_return,
    &cc_blockmcl$dx_sub,
    &cc_blockmcl$dx_mul,
    &cc_blockmcl$dx_div,
    &cc_blockmcl$dx_shl,
    &cc_blockmcl$dx_iand,
    &cc_blockmcl$dx_preincrx,
    &cc_blockmcl$dx_postincrx,
    &cc_blockmcl$makeindexopnd,
    &cc_blockmcl$mulreg,
    &cc_blockmcl$dx_ptr,
    &cc_blockmcl$dx_addptr,
    &cc_blockmcl$dx_subptr,
    &cc_blockmcl$dx_convert,
    &cc_blockmcl$do_decl,
    &cc_blockmcl$do_assignblock,
    &cc_blockmcl$dx_widen,
    &cc_blockmcl$dx_neg,
    &cc_blockmcl$dx_fneg,
    &cc_blockmcl$dx_inot,
    &cc_blockmcl$do_switch,
    &cc_blockmcl$dx_rem,
    &cc_blockmcl$dx_ifx,
    &cc_blockmcl$dx_addto,
    &cc_blockmcl$dx_faddto,
    &cc_blockmcl$dx_eq,
    &cc_blockmcl$do_exprlist,
    &cc_blockmcl$dx_exprlist,
    &cc_blockmcl$dx_shlto,
    &cc_blockmcl$dx_multo,
    &cc_blockmcl$dx_notl,
    &cc_blockmcl$dx_istruel,
    &cc_blockmcl$dx_andorl,
    &cc_blockmcl$dx_sqrt,
    &cc_blockmcl$dx_scale,
    &cc_blockmcl$dx_divto,
    &cc_blockmcl$dx_name,
    &cc_blockmcl$divreg,
    &cc_blockmcl$dx_addrof,
    &cc_blockmcl$dx_dot,
    &cc_blockmcl$loadviaptr,
    &cc_blockmcl$start,
    &cc_export$writemheader,
    &cc_export$showmacroseq,
    &cc_export$mmstr,
    &cc_export$mmleftstr,
    &cc_export$mmstrln,
    &cc_export$mmint,
    &cc_export$mmline,
    &cc_export$writefunction,
    &cc_export$mmmode,
    &cc_export$writerecord,
    &cc_export$writefnptr,
    &cc_export$fixname,
    &cc_export$start,
    &cc_genasm$codegen_writeasm,
    &cc_genasm$inita64,
    &cc_genasm$terma64,
    &cc_genasm$writetoasm,
    &cc_genasm$mcltoa64,
    &cc_genasm$passthru,
    &cc_genasm$convmcl,
    &cc_genasm$do_changeop,
    &cc_genasm$do_comment,
    &cc_genasm$do_blank,
    &cc_genasm$do_end,
    &cc_genasm$do_label,
    &cc_genasm$do_labelname,
    &cc_genasm$do_mov,
    &cc_genasm$do_push,
    &cc_genasm$do_pop,
    &cc_genasm$do_lea,
    &cc_genasm$do_cmovcc,
    &cc_genasm$do_fmov,
    &cc_genasm$do_iwiden,
    &cc_genasm$do_uwiden,
    &cc_genasm$do_inarrow,
    &cc_genasm$do_unarrow,
    &cc_genasm$do_call,
    &cc_genasm$do_ret,
    &cc_genasm$do_retn,
    &cc_genasm$do_jmp,
    &cc_genasm$do_jmpcc,
    &cc_genasm$do_exch,
    &cc_genasm$do_add,
    &cc_genasm$do_sub,
    &cc_genasm$do_imul,
    &cc_genasm$do_idiv,
    &cc_genasm$do_irem,
    &cc_genasm$do_urem,
    &cc_genasm$do_and,
    &cc_genasm$do_or,
    &cc_genasm$do_xor,
    &cc_genasm$do_test,
    &cc_genasm$do_cmp,
    &cc_genasm$do_shl,
    &cc_genasm$do_neg,
    &cc_genasm$do_not,
    &cc_genasm$do_inc,
    &cc_genasm$do_dec,
    &cc_genasm$do_setcc,
    &cc_genasm$do_fneg,
    &cc_genasm$do_fabs,
    &cc_genasm$do_fsqrt,
    &cc_genasm$do_ufix,
    &cc_genasm$do_ifix,
    &cc_genasm$do_ufloat,
    &cc_genasm$do_ifloat,
    &cc_genasm$do_db,
    &cc_genasm$do_dw,
    &cc_genasm$do_dd,
    &cc_genasm$do_dq,
    &cc_genasm$do_align,
    &cc_genasm$do_segment,
    &cc_genasm$do_assem,
    &cc_genasm$strmclasm,
    &cc_genasm$stropndx,
    &cc_genasm$strmclx,
    &cc_genasm$fgetregnamex,
    &cc_genasm$getstringname,
    &cc_genasm$getwstringname,
    &cc_genasm$getrealname,
    &cc_genasm$getsrealname,
    &cc_genasm$getdintname,
    &cc_genasm$getstringindex,
    &cc_genasm$getwstringindex,
    &cc_genasm$getrealindex,
    &cc_genasm$getdintindex,
    &cc_genasm$strvaluex,
    &cc_genasm$convertimm,
    &cc_genasm$genstringtable,
    &cc_genasm$genwstringtable,
    &cc_genasm$do_defstr,
    &cc_genasm$do_defwstr,
    &cc_genasm$genrealtable,
    &cc_genasm$gendinttable,
    &cc_genasm$writefabs,
    &cc_genasm$domclseq,
    &cc_genasm$asmstr,
    &cc_genasm$asmstrln,
    &cc_genasm$asmline,
    &cc_genasm$asmln,
    &cc_genasm$asmint,
    &cc_genasm$asmchar,
    &cc_genasm$asmterm,
    &cc_genasm$initasmline,
    &cc_genasm$getregnamex,
    &cc_genasm$genstring,
    &cc_genasm$genwstring,
    &cc_genasm$extendrealtable,
    &cc_genasm$extenddinttable,
    &cc_genasm$extendstringtable,
    &cc_genasm$start,
    &cc_genmcl$codegen_mcl,
    &cc_genmcl$genprocdef,
    &cc_genmcl$checkblockreturn,
    &cc_genmcl$dolabel,
    &cc_genmcl$dolabel_fn,
    &cc_genmcl$dostaticvar,
    &cc_genmcl$dostaticvar_fn,
    &cc_genmcl$genprocentry,
    &cc_genmcl$genidata,
    &cc_genmcl$genmainprelude,
    &cc_genmcl$start,
    &cc_headers$findheader,
    &cc_headers$writeheaders,
    &cc_headers$checkbcclib,
    &cc_headers$getbcclib,
    &cc_headers$isheaderfile,
    &cc_headers$start,
    &cc_lex$lex_preprocess_only,
    &cc_lex$lexreadtoken,
    &cc_lex$readrealnumber,
    &cc_lex$readexponent,
    &cc_lex$lxerror,
    &cc_lex$printsymbol,
    &cc_lex$lexsetup,
    &cc_lex$printstrn,
    &cc_lex$scannumber,
    &cc_lex$lookup,
    &cc_lex$gethashvalue,
    &cc_lex$inithashtable,
    &cc_lex$fillhashtable,
    &cc_lex$dolexdirective,
    &cc_lex$getlexdirective,
    &cc_lex$startlex,
    &cc_lex$endlex,
    &cc_lex$ps,
    &cc_lex$psnext,
    &cc_lex$gethashtablesize,
    &cc_lex$readlinecomment,
    &cc_lex$readblockcomment,
    &cc_lex$readhex,
    &cc_lex$readbinary,
    &cc_lex$readoctal,
    &cc_lex$readdecimal,
    &cc_lex$checknumbersuffix,
    &cc_lex$stacksourcefile,
    &cc_lex$unstacksourcefile,
    &cc_lex$getsourcefile,
    &cc_lex$lex,
    &cc_lex$shownumberstr,
    &cc_lex$addnamestr,
    &cc_lex$lxreadstring,
    &cc_lex$addlisttoken,
    &cc_lex$addlisttoken_copy,
    &cc_lex$addlist_nextlx,
    &cc_lex$addlisttoken_seq,
    &cc_lex$addlistmparam,
    &cc_lex$dodefine,
    &cc_lex$readalphanumeric,
    &cc_lex$inmacrostack,
    &cc_lex$showtokens,
    &cc_lex$lexa,
    &cc_lex$lexm,
    &cc_lex$peeklb,
    &cc_lex$peektk,
    &cc_lex$expandobjmacro,
    &cc_lex$expandfnmacro,
    &cc_lex$scantokenseq,
    &cc_lex$readmacrocall,
    &cc_lex$substituteargs,
    &cc_lex$strtoken,
    &cc_lex$strstring,
    &cc_lex$emittoken,
    &cc_lex$showtoken,
    &cc_lex$stringify,
    &cc_lex$pastetokens,
    &cc_lex$getifexpr,
    &cc_lex$evalcondexpr,
    &cc_lex$evalorexpr,
    &cc_lex$evalandexpr,
    &cc_lex$evaliorexpr,
    &cc_lex$evalixorexpr,
    &cc_lex$evaliandexpr,
    &cc_lex$evaleqexpr,
    &cc_lex$evalcmpexpr,
    &cc_lex$evalshiftexpr,
    &cc_lex$evaladdexpr,
    &cc_lex$evalmulexpr,
    &cc_lex$evalunaryexpr,
    &cc_lex$evalterm,
    &cc_lex$getifdef,
    &cc_lex$skipcode,
    &cc_lex$freetokens,
    &cc_lex$fastreadtoken,
    &cc_lex$alloctoken,
    &cc_lex$alloctokenz,
    &cc_lex$expandpredefmacro,
    &cc_lex$dopragmadir,
    &cc_lex$needspace,
    &cc_lex$dospecialinclude,
    &cc_lex$addautomodule,
    &cc_lex$setnumberoffset,
    &cc_lex$setfileno,
    &cc_lex$setfilenox,
    &cc_lex$getfileno,
    &cc_lex$getfilenox,
    &cc_lex$getnumberoffsetx,
    &cc_lex$freehashtable,
    &cc_lex$freestentry,
    &cc_lex$regenlookup,
    &cc_lex$printhashtable,
    &cc_lex$newhashtable,
    &cc_lex$old_readrealnumber,
    &cc_lex$issimpleconstmacro,
    &cc_lex$start,
    &cc_lib$newstrec,
    &cc_lib$initcclib,
    &cc_lib$printst,
    &cc_lib$printstrec,
    &cc_lib$printstflat,
    &cc_lib$createname,
    &cc_lib$createunit0,
    &cc_lib$createunit1,
    &cc_lib$createunit2,
    &cc_lib$createunit3,
    &cc_lib$createconstunit,
    &cc_lib$createstringconstunit,
    &cc_lib$createwstringconstunit,
    &cc_lib$getoptocode,
    &cc_lib$getconstvalue,
    &cc_lib$nextautotype,
    &cc_lib$createconstmode,
    &cc_lib$createrefmode,
    &cc_lib$createprocmode,
    &cc_lib$createarraymode,
    &cc_lib$createenummode,
    &cc_lib$createstructmode,
    &cc_lib$setnameptr,
    &cc_lib$printcode_all,
    &cc_lib$printcode,
    &cc_lib$printunit,
    &cc_lib$printunitlist,
    &cc_lib$getprefix,
    &cc_lib$getdottedname,
    &cc_lib$getlineinfok,
    &cc_lib$getautofieldname,
    &cc_lib$convertstring,
    &cc_lib$strexpr,
    &cc_lib$jeval,
    &cc_lib$getopcjname,
    &cc_lib$strmode,
    &cc_lib$strmode2,
    &cc_lib$istrmode,
    &cc_lib$countunits,
    &cc_lib$purgesymbol,
    &cc_lib$purgesymbollist,
    &cc_lib$purgeprocs,
    &cc_lib$purgeproc,
    &cc_lib$printmodelist,
    &cc_lib$typename,
    &cc_lib$allocunitrec,
    &cc_lib$copymode,
    &cc_lib$createnewmode,
    &cc_lib$addlistunit,
    &cc_lib$addlistdef,
    &cc_lib$addlistparam,
    &cc_lib$checksymbol,
    &cc_lib$skipsymbol,
    &cc_lib$inittypetables,
    &cc_lib$createdupldef,
    &cc_lib$createnewmoduledef,
    &cc_lib$createnewproc,
    &cc_lib$resolvename,
    &cc_lib$resolvelabel,
    &cc_lib$checkdupl,
    &cc_lib$checkdupl_inproc,
    &cc_lib$getalignment,
    &cc_lib$isexported,
    &cc_lib$isimported,
    &cc_lib$isstructunion,
    &cc_lib$getstname,
    &cc_lib$isrealcc,
    &cc_lib$isintcc,
    &cc_lib$start,
    &cc_libmcl$mclinit,
    &cc_libmcl$gettargetdata,
    &cc_libmcl$initmcdest,
    &cc_libmcl$genmc,
    &cc_libmcl$genmc_cond,
    &cc_libmcl$lastmc,
    &cc_libmcl$genmcstr,
    &cc_libmcl$newopnd,
    &cc_libmcl$duplopnd,
    &cc_libmcl$genxreg,
    &cc_libmcl$genindex,
    &cc_libmcl$writemclblock,
    &cc_libmcl$writemclcode,
    &cc_libmcl$gencomment,
    &cc_libmcl$genstrimm,
    &cc_libmcl$genwstrimm,
    &cc_libmcl$genname,
    &cc_libmcl$writemcl,
    &cc_libmcl$strmcl,
    &cc_libmcl$stropnd,
    &cc_libmcl$strvalue,
    &cc_libmcl$setsegment,
    &cc_libmcl$getprocname,
    &cc_libmcl$widenstr,
    &cc_libmcl$genassem,
    &cc_libmcl$strlabel,
    &cc_libmcl$makeindirect,
    &cc_libmcl$applyoffset,
    &cc_libmcl$applysize,
    &cc_libmcl$isframe,
    &cc_libmcl$genreturn,
    &cc_libmcl$getsizeprefix,
    &cc_libmcl$needsizeprefix,
    &cc_libmcl$changeopndsize,
    &cc_libmcl$genint,
    &cc_libmcl$genreal,
    &cc_libmcl$genimm,
    &cc_libmcl$genlabel,
    &cc_libmcl$genmem_u,
    &cc_libmcl$genmem_d,
    &cc_libmcl$genmemaddr_u,
    &cc_libmcl$genmemaddr_d,
    &cc_libmcl$genreg,
    &cc_libmcl$genireg,
    &cc_libmcl$getopndsize_u,
    &cc_libmcl$getopndsize_d,
    &cc_libmcl$getmclcond,
    &cc_libmcl$getfullname,
    &cc_libmcl$roundsizetg,
    &cc_libmcl$iscallbackfn,
    &cc_libmcl$getregname,
    &cc_libmcl$getblockname,
    &cc_libmcl$fgetregname,
    &cc_libmcl$issimple,
    &cc_libmcl$issimple0,
    &cc_libmcl$issimplepm,
    &cc_libmcl$getaregs,
    &cc_libmcl$getlregs,
    &cc_libmcl$isintconst,
    &cc_libmcl$_getnextreg,
    &cc_libmcl$getnextreg,
    &cc_libmcl$ispoweroftwo,
    &cc_libmcl$sameoperand,
    &cc_libmcl$findlastmcl,
    &cc_libmcl$genmsource,
    &cc_libmcl$roundto,
    &cc_libmcl$pushstack,
    &cc_libmcl$pushstackfp,
    &cc_libmcl$popstack,
    &cc_libmcl$definelabel,
    &cc_libmcl$createfwdlabel,
    &cc_libmcl$definefwdlabel,
    &cc_libmcl$genjumpl,
    &cc_libmcl$setalign,
    &cc_libmcl$gettypecat,
    &cc_libmcl$doblockcall,
    &cc_libmcl$getblockreg,
    &cc_libmcl$copyretvalue,
    &cc_libmcl$enterproc,
    &cc_libmcl$leaveproc,
    &cc_libmcl$start,
    &cc_parse$readmodule,
    &cc_parse$parsemodule,
    &cc_parse$readdeclspec,
    &cc_parse$istypestarter,
    &cc_parse$istypestarter_next,
    &cc_parse$readexpression,
    &cc_parse$readassignexpr,
    &cc_parse$readcondexpr,
    &cc_parse$readorlexpr,
    &cc_parse$readandlexpr,
    &cc_parse$readiorexpr,
    &cc_parse$readixorexpr,
    &cc_parse$readiandexpr,
    &cc_parse$readeqexpr,
    &cc_parse$readrelexpr,
    &cc_parse$readshiftexpr,
    &cc_parse$readaddexpr,
    &cc_parse$readmulexpr,
    &cc_parse$readterm,
    &cc_parse$readexprlist,
    &cc_parse$readmodulevar,
    &cc_parse$readframevar,
    &cc_parse$readtype,
    &cc_parse$readnamedtype,
    &cc_parse$readconstintexpr,
    &cc_parse$readinitexpr,
    &cc_parse$readinitexpr2,
    &cc_parse$pushblock,
    &cc_parse$popblock,
    &cc_parse$readcompoundstmt,
    &cc_parse$readblock,
    &cc_parse$readstatement,
    &cc_parse$readifstmt,
    &cc_parse$readforstmt,
    &cc_parse$readwhilestmt,
    &cc_parse$readdostmt,
    &cc_parse$readreturnstmt,
    &cc_parse$readgotostmt,
    &cc_parse$readswitchstmt,
    &cc_parse$readcaselabel,
    &cc_parse$readexprstmt,
    &cc_parse$readcond,
    &cc_parse$isusertype,
    &cc_parse$readlocaldecl,
    &cc_parse$createtypedef,
    &cc_parse$readparams,
    &cc_parse$readcasttype,
    &cc_parse$readfunction,
    &cc_parse$getbasesymbol,
    &cc_parse$readfunctionbody,
    &cc_parse$createnegop,
    &cc_parse$createabsop,
    &cc_parse$createsqrtop,
    &cc_parse$createinotop,
    &cc_parse$createptrop,
    &cc_parse$createincrop,
    &cc_parse$createlengthofop,
    &cc_parse$createaddrofop,
    &cc_parse$createaddop,
    &cc_parse$createsubop,
    &cc_parse$createmulop,
    &cc_parse$createdivop,
    &cc_parse$createremop,
    &cc_parse$insertunit,
    &cc_parse$eval_add,
    &cc_parse$eval_sub,
    &cc_parse$eval_mul,
    &cc_parse$eval_div,
    &cc_parse$eval_rem,
    &cc_parse$eval_convert,
    &cc_parse$coercecond,
    &cc_parse$coercebasetype,
    &cc_parse$checklvalue,
    &cc_parse$createcall,
    &cc_parse$arraytopointer,
    &cc_parse$createindexop,
    &cc_parse$readstructdecl,
    &cc_parse$checkpointertypes,
    &cc_parse$comparemode,
    &cc_parse$readenumdecl,
    &cc_parse$readenumnames,
    &cc_parse$createdotop,
    &cc_parse$mulunit,
    &cc_parse$divunit,
    &cc_parse$createassignopref,
    &cc_parse$addnewfield,
    &cc_parse$pushloop,
    &cc_parse$poploop,
    &cc_parse$addcasevalue,
    &cc_parse$roundoffset,
    &cc_parse$fixmemopnd,
    &cc_parse$docast,
    &cc_parse$coercemode,
    &cc_parse$coercemode_inplace,
    &cc_parse$dostaticassert,
    &cc_parse$createsizeofop,
    &cc_parse$readgeneric,
    &cc_parse$readstructinfosym,
    &cc_parse$getmemmode,
    &cc_parse$readstrinclude,
    &cc_parse$start,
    &cc_support$stopcompiler,
    &cc_support$mcerror,
    &cc_support$serror,
    &cc_support$serror_gen,
    &cc_support$serror_ss,
    &cc_support$serror_s,
    &cc_support$terror_gen,
    &cc_support$terror,
    &cc_support$terror_s,
    &cc_support$terror_ss,
    &cc_support$gerror_gen,
    &cc_support$gerror,
    &cc_support$gerror_s,
    &cc_support$nxerror,
    &cc_support$testelem,
    &cc_support$setelem,
    &cc_support$nextpoweroftwo,
    &cc_support$loaderror,
    &cc_support$loadfromstdin,
    &cc_support$loadsourcefile,
    &cc_support$splicelines,
    &cc_support$loadbuiltin,
    &cc_support$gs_copytostr,
    &cc_support$gs_additem,
    &cc_support$isalphanum,
    &cc_support$showmacrolineno,
    &cc_support$start,
    &cc_tables$start,
    &cc_assembler$assembler,
    &cc_assembler$loadsourcefiles,
    &cc_assembler$parsemodules,
    &cc_assembler$fixopnd,
    &cc_assembler$initall,
    &cc_assembler$loaderror,
    &cc_assembler$loaderror_s,
    &cc_assembler$addmodule,
    &cc_assembler$addsearchlib,
    &cc_assembler$getemptyst,
    &cc_assembler$findduplname,
    &cc_assembler$adddupl,
    &cc_assembler$scanglobals,
    &cc_assembler$resethashtable,
    &cc_assembler$start,
    &aa_decls$start,
    &aa_disasm$decodeinstr,
    &aa_disasm$decodetwobyteinstr,
    &aa_disasm$decodeaddr,
    &aa_disasm$readbyte,
    &aa_disasm$readsbyte,
    &aa_disasm$readword16,
    &aa_disasm$readint16,
    &aa_disasm$readword32,
    &aa_disasm$readint32,
    &aa_disasm$readint64,
    &aa_disasm$getreg,
    &aa_disasm$strreg,
    &aa_disasm$strfreg,
    &aa_disasm$printaddrmode,
    &aa_disasm$genstr,
    &aa_disasm$genintd,
    &aa_disasm$genhex,
    &aa_disasm$readimm,
    &aa_disasm$readimm8,
    &aa_disasm$strxmm,
    &aa_disasm$strmmx,
    &aa_disasm$decode8087,
    &aa_disasm$do87arith,
    &aa_disasm$do87mem,
    &aa_disasm$getsil,
    &aa_disasm$getsilx,
    &aa_disasm$start,
    &aa_genss$genss,
    &aa_genss$doinstr,
    &aa_genss$genbyte,
    &aa_genss$genword,
    &aa_genss$gendword,
    &aa_genss$genqword,
    &aa_genss$genopnd,
    &aa_genss$addrelocitem,
    &aa_genss$getstindex,
    &aa_genss$genrel32,
    &aa_genss$genabs32,
    &aa_genss$genabs64,
    &aa_genss$getrel32,
    &aa_genss$dofwdrefs,
    &aa_genss$genrex,
    &aa_genss$isbytesized,
    &aa_genss$isdwordsized,
    &aa_genss$do_push,
    &aa_genss$do_pop,
    &aa_genss$do_inc,
    &aa_genss$do_neg,
    &aa_genss$genamode,
    &aa_genss$makemodrm,
    &aa_genss$setopsize,
    &aa_genss$getdispsize,
    &aa_genss$genrmbyte,
    &aa_genss$makeam,
    &aa_genss$do_lea,
    &aa_genss$do_movsx,
    &aa_genss$checkhighreg,
    &aa_genss$do_exch,
    &aa_genss$do_movsxd,
    &aa_genss$do_imul2,
    &aa_genss$do_shift,
    &aa_genss$do_test,
    &aa_genss$do_loop,
    &aa_genss$do_jcxz,
    &aa_genss$do_setcc,
    &aa_genss$do_arithxmm,
    &aa_genss$do_logicxmm,
    &aa_genss$do_convertfloat,
    &aa_genss$do_fix,
    &aa_genss$do_float,
    &aa_genss$do_call,
    &aa_genss$do_jmp,
    &aa_genss$getcurrdatalen,
    &aa_genss$do_cmovcc,
    &aa_genss$do_fmem,
    &aa_genss$getr32bits,
    &aa_genss$genrel8,
    &aa_genss$checkshortjump,
    &aa_genss$addfwdref,
    &aa_genss$switchseg,
    &aa_genss$do_popcnt,
    &aa_genss$do_bsf,
    &aa_genss$extendsymboltable,
    &aa_genss$do_pcmpistri,
    &aa_genss$genxrm,
    &aa_genss$genrrm,
    &aa_genss$getregcode,
    &aa_genss$checkimmrange,
    &aa_genss$newgenrm,
    &aa_genss$do_mov,
    &aa_genss$do_arith,
    &aa_genss$do_movxmm,
    &aa_genss$checksize,
    &aa_genss$start,
    &aa_lex$lex,
    &aa_lex$initlex,
    &aa_lex$readreal,
    &aa_lex$readnumber,
    &aa_lex$readbinary,
    &aa_lex$readhex,
    &aa_lex$ps,
    &aa_lex$printsymbol,
    &aa_lex$clearhashtable,
    &aa_lex$inithashtable,
    &aa_lex$addreservedword,
    &aa_lex$printhashtable,
    &aa_lex$lookuplex,
    &aa_lex$initsourcefile,
    &aa_lex$addnamestr,
    &aa_lex$lxerror,
    &aa_lex$gethashvalue,
    &aa_lex$skiptoeol,
    &aa_lex$makestring,
    &aa_lex$start,
    &aa_lib$initlib,
    &aa_lib$genmc,
    &aa_lib$genmcstr,
    &aa_lib$newopnd,
    &aa_lib$genxreg,
    &aa_lib$genindex,
    &aa_lib$writemclblock,
    &aa_lib$gencomment,
    &aa_lib$genstrimm,
    &aa_lib$getsizetag,
    &aa_lib$writemcl,
    &aa_lib$strmcl,
    &aa_lib$stropnd,
    &aa_lib$strdef,
    &aa_lib$setsegment,
    &aa_lib$getsizeprefix,
    &aa_lib$needsizeprefix,
    &aa_lib$genimm_expr,
    &aa_lib$genint,
    &aa_lib$genlab,
    &aa_lib$genmem,
    &aa_lib$genreg0,
    &aa_lib$getfullname,
    &aa_lib$getregname,
    &aa_lib$xgetregname,
    &aa_lib$printst,
    &aa_lib$printstrec,
    &aa_lib$adddef,
    &aa_lib$addimport,
    &aa_lib$createlabel,
    &aa_lib$createnamedconst,
    &aa_lib$createregalias,
    &aa_lib$createxregalias,
    &aa_lib$gerror,
    &aa_lib$serror,
    &aa_lib$serror_s,
    &aa_lib$inttostr,
    &aa_lib$realtostr,
    &aa_lib$buffercreate,
    &aa_lib$bufferexpand,
    &aa_lib$buffercheck,
    &aa_lib$bufferlength,
    &aa_lib$bufferelemptr,
    &aa_lib$addbyte,
    &aa_lib$addword,
    &aa_lib$adddword,
    &aa_lib$addqword,
    &aa_lib$printmodulesymbols,
    &aa_lib$printimportsymbols,
    &aa_lib$printdupltable,
    &aa_lib$start,
    &aa_mcxdecls$start,
    &aa_objdecls$start,
    &aa_parse$readmodule,
    &aa_parse$checkundefined,
    &aa_parse$checksymbol,
    &aa_parse$readinstr,
    &aa_parse$readcondinstr,
    &aa_parse$readoperand,
    &aa_parse$readexpression,
    &aa_parse$readterm,
    &aa_parse$readreg,
    &aa_parse$readaddrmode,
    &aa_parse$start,
    &aa_tables$start,
    &aa_writeexe$writeexe,
    &aa_writeexe$genexe,
    &aa_writeexe$loadlibs,
    &aa_writeexe$initsectiontable,
    &aa_writeexe$extractlibname,
    &aa_writeexe$scanst,
    &aa_writeexe$relocdata,
    &aa_writeexe$getbaserelocs,
    &aa_writeexe$writerecordx,
    &aa_writeexe$writedosstub,
    &aa_writeexe$writepesig,
    &aa_writeexe$writepadding,
    &aa_writeexe$writefileheader,
    &aa_writeexe$writeoptheader,
    &aa_writeexe$writesectionheader,
    &aa_writeexe$writesectiondata,
    &aa_writeexe$getoffsets,
    &aa_writeexe$getsectionno,
    &aa_writeexe$writeexporttable,
    &aa_writeexe$getexporttablesize,
    &aa_writeexe$newbasereloc,
    &aa_writeexe$scanbaserelocs,
    &aa_writeexe$writebasereloctable,
    &aa_writeexe$sortexports,
    &aa_writeexe$start,
    &aa_writeobj$writess,
    &aa_writeobj$writerecord,
    &aa_writeobj$writerelocs,
    &aa_writeobj$writedata,
    &aa_writeobj$writesymboltable,
    &aa_writeobj$writestringtable,
    &aa_writeobj$makesymbol,
    &aa_writeobj$addsymbol,
    &aa_writeobj$initsymboltable,
    &aa_writeobj$strtoaux,
    &aa_writeobj$sectiontoaux,
    &aa_writeobj$addstringentry,
    &aa_writeobj$convertsymboltable,
    &aa_writeobj$writecoff,
    &aa_writeobj$start,
    &msysc$m_init,
    &msysc$m_getdotindex,
    &msysc$m_setdotindex,
    &msysc$m_getdotslice,
    &msysc$m_setdotslice,
    &msysc$m_get_nprocs,
    &msysc$m_get_nexports,
    &msysc$m_get_procname,
    &msysc$m_get_procaddr,
    &msysc$m_get_procexport,
    &msysc$pushio,
    &msysc$m_print_startfile,
    &msysc$m_print_startstr,
    &msysc$m_print_startptr,
    &msysc$m_print_startcon,
    &msysc$m_print_setfmt,
    &msysc$m_print_end,
    &msysc$m_print_ptr,
    &msysc$m_print_i64,
    &msysc$m_print_u64,
    &msysc$m_print_r64,
    &msysc$m_print_r32,
    &msysc$m_print_c8,
    &msysc$m_print_str,
    &msysc$m_print_newline,
    &msysc$m_print_nogap,
    &msysc$m_print_space,
    &msysc$printstr,
    &msysc$printstr_n,
    &msysc$printstrn_app,
    &msysc$makezstring,
    &msysc$freezstring,
    &msysc$printchar,
    &msysc$nextfmtchars,
    &msysc$strtofmt,
    &msysc$domultichar,
    &msysc$expandstr,
    &msysc$u64tostr,
    &msysc$i64tostrfmt,
    &msysc$u64tostrfmt,
    &msysc$i64mintostr,
    &msysc$strtostrfmt,
    &msysc$tostr_i64,
    &msysc$tostr_u64,
    &msysc$tostr_r64,
    &msysc$tostr_str,
    &msysc$getfmt,
    &msysc$strint,
    &msysc$getstrint,
    &msysc$strword,
    &msysc$strreal,
    &msysc$getstr,
    &msysc$initreadbuffer,
    &msysc$m_read_conline,
    &msysc$m_read_fileline,
    &msysc$m_read_strline,
    &msysc$readitem,
    &msysc$strtoint,
    &msysc$m_read_i64,
    &msysc$m_read_r64,
    &msysc$m_read_str,
    &msysc$readstr,
    &msysc$rereadln,
    &msysc$reread,
    &msysc$valint,
    &msysc$valreal,
    &msysc$iconvlcn,
    &msysc$iconvucn,
    &msysc$convlcstring,
    &msysc$convucstring,
    &msysc$m_power_i64,
    &msysc$m_intoverflow,
    &msysc$m_dotindex,
    &msysc$m_dotslice,
    &msysc$m_popdotindex,
    &msysc$m_popdotslice,
    &msysc$m_imin,
    &msysc$m_imax,
    &msysc$m_sign,
    &msysc$m_tp_i64tor64,
    &msysc$m_tp_r64toi64,
    &msysc$m_tp_reftoi64,
    &msysc$m_tp_i64toref,
    &msysc$start,
    &mlib$pcm_alloc,
    &mlib$pcm_free,
    &mlib$pcm_freeac,
    &mlib$pcm_clearmem,
    &mlib$pcm_init,
    &mlib$pcm_getac,
    &mlib$pcm_newblock,
    &mlib$pcm_round,
    &mlib$pcm_allocz,
    &mlib$pcm_copyheapstring,
    &mlib$pcm_copyheapstringn,
    &mlib$pcm_copyheapblock,
    &mlib$allocmem,
    &mlib$reallocmem,
    &mlib$abortprogram,
    &mlib$getfilesize,
    &mlib$readrandom,
    &mlib$writerandom,
    &mlib$setfilepos,
    &mlib$getfilepos,
    &mlib$readfile,
    &mlib$writefile,
    &mlib$checkfile,
    &mlib$readlinen,
    &mlib$iconvlcn,
    &mlib$iconvucn,
    &mlib$convlcstring,
    &mlib$convucstring,
    &mlib$changeext,
    &mlib$extractext,
    &mlib$extractpath,
    &mlib$extractfile,
    &mlib$extractbasefile,
    &mlib$addext,
    &mlib$pcm_alloc32,
    &mlib$pcm_free32,
    &mlib$outbyte,
    &mlib$outword16,
    &mlib$outword32,
    &mlib$outword64,
    &mlib$outstring,
    &mlib$outblock,
    &mlib$myeof,
    &mlib$strbuffer_add,
    &mlib$gs_init,
    &mlib$gs_free,
    &mlib$gs_str,
    &mlib$gs_char,
    &mlib$gs_strn,
    &mlib$gs_strvar,
    &mlib$gs_strint,
    &mlib$gs_strln,
    &mlib$gs_strsp,
    &mlib$gs_line,
    &mlib$gs_getcol,
    &mlib$gs_leftstr,
    &mlib$gs_leftint,
    &mlib$gs_padto,
    &mlib$gs_println,
    &mlib$nextcmdparamnew,
    &mlib$readnextfileitem,
    &mlib$ipadstr,
    &mlib$padstr,
    &mlib$chr,
    &mlib$cmpstring,
    &mlib$cmpstringn,
    &mlib$eqstring,
    &mlib$cmpbytes,
    &mlib$eqbytes,
    &mlib$mseed,
    &mlib$mrandom,
    &mlib$mrandomp,
    &mlib$mrandomint,
    &mlib$mrandomrange,
    &mlib$mrandomreal,
    &mlib$mrandomreal1,
    &mlib$readline,
    &mlib$findfunction,
    &mlib$roundtoblock,
    &mlib$pcm_allocnfz,
    &mlib$start,
    &mclib$start,
    &mwindows$os_init,
    &mwindows$os_execwait,
    &mwindows$os_execcmd,
    &mwindows$os_getch,
    &mwindows$os_kbhit,
    &mwindows$os_getdllinst,
    &mwindows$os_getdllprocaddr,
    &mwindows$os_initwindows,
    &mwindows$os_gxregisterclass,
    &mwindows$mainwndproc,
    &mwindows$os_setmesshandler,
    &mwindows$os_getchx,
    &mwindows$os_getos,
    &mwindows$os_gethostsize,
    &mwindows$os_shellexec,
    &mwindows$os_sleep,
    &mwindows$os_getstdin,
    &mwindows$os_getstdout,
    &mwindows$os_gethostname,
    &mwindows$os_getmpath,
    &mwindows$os_clock,
    &mwindows$os_ticks,
    &mwindows$os_hptimer,
    &mwindows$os_iswindows,
    &mwindows$os_getsystime,
    &mwindows$os_peek,
    &mwindows$os_allocexecmem,
    &mwindows$start,
    &mwindllc$os_calldllfunction,
    &mwindllc$os_pushargs,
    &mwindllc$calldll_cint,
    &mwindllc$calldll_creal,
    &mwindllc$os_dummycall,
    &mwindllc$start,
0};
static u8 *  msysc$_fnnames[]= {
    (byte*)"main",
    (byte*)"compilemodules",
    (byte*)"debugcompile",
    (byte*)"do_loadmodule",
    (byte*)"do_preprocess",
    (byte*)"do_parsemodule",
    (byte*)"do_genmcl",
    (byte*)"do_genasm",
    (byte*)"do_runprog",
    (byte*)"loadmainmodule",
    (byte*)"addmodule",
    (byte*)"initlogfile",
    (byte*)"closelogfile",
    (byte*)"initdata",
    (byte*)"initsearchdirs",
    (byte*)"showsearchdirs",
    (byte*)"showast",
    (byte*)"showstflat",
    (byte*)"showsttree",
    (byte*)"showmcl",
    (byte*)"showasm",
    (byte*)"showfiles",
    (byte*)"starttiming",
    (byte*)"showtiming",
    (byte*)"showlps",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"showincludepaths",
    (byte*)"showhelp",
    (byte*)"showextrainfo",
    (byte*)"showcaption",
    (byte*)"do_genlink",
    (byte*)"resetcompiler",
    (byte*)"addnewmodules",
    (byte*)"writeatfile",
    (byte*)"start",
    (byte*)"start",
    (byte*)"do_stmt",
    (byte*)"dx_expr",
    (byte*)"loneexpr",
    (byte*)"do_assign",
    (byte*)"dx_assign",
    (byte*)"saveexpr",
    (byte*)"fsaveexpr",
    (byte*)"restoreexpr",
    (byte*)"frestoreexpr",
    (byte*)"getlvalueopnd",
    (byte*)"storeopnd",
    (byte*)"pushexpr",
    (byte*)"fpushexpr",
    (byte*)"dx_const",
    (byte*)"dx_constant",
    (byte*)"do_labeldef",
    (byte*)"do_goto",
    (byte*)"dx_add",
    (byte*)"dx_fadd",
    (byte*)"loadexpr",
    (byte*)"evalexpr",
    (byte*)"evaladdr",
    (byte*)"evalptr",
    (byte*)"floadexpr",
    (byte*)"fevalexpr",
    (byte*)"do_if",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"reversecond",
    (byte*)"do_preincr",
    (byte*)"reversemclcond",
    (byte*)"do_while",
    (byte*)"do_while1",
    (byte*)"stacklooplabels",
    (byte*)"do_dowhile",
    (byte*)"do_for",
    (byte*)"pushffparams",
    (byte*)"pushoneparam",
    (byte*)"pushfloatparam",
    (byte*)"loadfloatparam",
    (byte*)"dx_call",
    (byte*)"do_return",
    (byte*)"dx_sub",
    (byte*)"dx_mul",
    (byte*)"dx_div",
    (byte*)"dx_shl",
    (byte*)"dx_iand",
    (byte*)"dx_preincrx",
    (byte*)"dx_postincrx",
    (byte*)"makeindexopnd",
    (byte*)"mulreg",
    (byte*)"dx_ptr",
    (byte*)"dx_addptr",
    (byte*)"dx_subptr",
    (byte*)"dx_convert",
    (byte*)"do_decl",
    (byte*)"do_assignblock",
    (byte*)"dx_widen",
    (byte*)"dx_neg",
    (byte*)"dx_fneg",
    (byte*)"dx_inot",
    (byte*)"do_switch",
    (byte*)"dx_rem",
    (byte*)"dx_ifx",
    (byte*)"dx_addto",
    (byte*)"dx_faddto",
    (byte*)"dx_eq",
    (byte*)"do_exprlist",
    (byte*)"dx_exprlist",
    (byte*)"dx_shlto",
    (byte*)"dx_multo",
    (byte*)"dx_notl",
    (byte*)"dx_istruel",
    (byte*)"dx_andorl",
    (byte*)"dx_sqrt",
    (byte*)"dx_scale",
    (byte*)"dx_divto",
    (byte*)"dx_name",
    (byte*)"divreg",
    (byte*)"dx_addrof",
    (byte*)"dx_dot",
    (byte*)"loadviaptr",
    (byte*)"start",
    (byte*)"writemheader",
    (byte*)"showmacroseq",
    (byte*)"mmstr",
    (byte*)"mmleftstr",
    (byte*)"mmstrln",
    (byte*)"mmint",
    (byte*)"mmline",
    (byte*)"writefunction",
    (byte*)"mmmode",
    (byte*)"writerecord",
    (byte*)"writefnptr",
    (byte*)"fixname",
    (byte*)"start",
    (byte*)"codegen_writeasm",
    (byte*)"inita64",
    (byte*)"terma64",
    (byte*)"writetoasm",
    (byte*)"mcltoa64",
    (byte*)"passthru",
    (byte*)"convmcl",
    (byte*)"do_changeop",
    (byte*)"do_comment",
    (byte*)"do_blank",
    (byte*)"do_end",
    (byte*)"do_label",
    (byte*)"do_labelname",
    (byte*)"do_mov",
    (byte*)"do_push",
    (byte*)"do_pop",
    (byte*)"do_lea",
    (byte*)"do_cmovcc",
    (byte*)"do_fmov",
    (byte*)"do_iwiden",
    (byte*)"do_uwiden",
    (byte*)"do_inarrow",
    (byte*)"do_unarrow",
    (byte*)"do_call",
    (byte*)"do_ret",
    (byte*)"do_retn",
    (byte*)"do_jmp",
    (byte*)"do_jmpcc",
    (byte*)"do_exch",
    (byte*)"do_add",
    (byte*)"do_sub",
    (byte*)"do_imul",
    (byte*)"do_idiv",
    (byte*)"do_irem",
    (byte*)"do_urem",
    (byte*)"do_and",
    (byte*)"do_or",
    (byte*)"do_xor",
    (byte*)"do_test",
    (byte*)"do_cmp",
    (byte*)"do_shl",
    (byte*)"do_neg",
    (byte*)"do_not",
    (byte*)"do_inc",
    (byte*)"do_dec",
    (byte*)"do_setcc",
    (byte*)"do_fneg",
    (byte*)"do_fabs",
    (byte*)"do_fsqrt",
    (byte*)"do_ufix",
    (byte*)"do_ifix",
    (byte*)"do_ufloat",
    (byte*)"do_ifloat",
    (byte*)"do_db",
    (byte*)"do_dw",
    (byte*)"do_dd",
    (byte*)"do_dq",
    (byte*)"do_align",
    (byte*)"do_segment",
    (byte*)"do_assem",
    (byte*)"strmclasm",
    (byte*)"stropndx",
    (byte*)"strmclx",
    (byte*)"fgetregnamex",
    (byte*)"getstringname",
    (byte*)"getwstringname",
    (byte*)"getrealname",
    (byte*)"getsrealname",
    (byte*)"getdintname",
    (byte*)"getstringindex",
    (byte*)"getwstringindex",
    (byte*)"getrealindex",
    (byte*)"getdintindex",
    (byte*)"strvaluex",
    (byte*)"convertimm",
    (byte*)"genstringtable",
    (byte*)"genwstringtable",
    (byte*)"do_defstr",
    (byte*)"do_defwstr",
    (byte*)"genrealtable",
    (byte*)"gendinttable",
    (byte*)"writefabs",
    (byte*)"domclseq",
    (byte*)"asmstr",
    (byte*)"asmstrln",
    (byte*)"asmline",
    (byte*)"asmln",
    (byte*)"asmint",
    (byte*)"asmchar",
    (byte*)"asmterm",
    (byte*)"initasmline",
    (byte*)"getregnamex",
    (byte*)"genstring",
    (byte*)"genwstring",
    (byte*)"extendrealtable",
    (byte*)"extenddinttable",
    (byte*)"extendstringtable",
    (byte*)"start",
    (byte*)"codegen_mcl",
    (byte*)"genprocdef",
    (byte*)"checkblockreturn",
    (byte*)"dolabel",
    (byte*)"dolabel_fn",
    (byte*)"dostaticvar",
    (byte*)"dostaticvar_fn",
    (byte*)"genprocentry",
    (byte*)"genidata",
    (byte*)"genmainprelude",
    (byte*)"start",
    (byte*)"findheader",
    (byte*)"writeheaders",
    (byte*)"checkbcclib",
    (byte*)"getbcclib",
    (byte*)"isheaderfile",
    (byte*)"start",
    (byte*)"lex_preprocess_only",
    (byte*)"lexreadtoken",
    (byte*)"readrealnumber",
    (byte*)"readexponent",
    (byte*)"lxerror",
    (byte*)"printsymbol",
    (byte*)"lexsetup",
    (byte*)"printstrn",
    (byte*)"scannumber",
    (byte*)"lookup",
    (byte*)"gethashvalue",
    (byte*)"inithashtable",
    (byte*)"fillhashtable",
    (byte*)"dolexdirective",
    (byte*)"getlexdirective",
    (byte*)"startlex",
    (byte*)"endlex",
    (byte*)"ps",
    (byte*)"psnext",
    (byte*)"gethashtablesize",
    (byte*)"readlinecomment",
    (byte*)"readblockcomment",
    (byte*)"readhex",
    (byte*)"readbinary",
    (byte*)"readoctal",
    (byte*)"readdecimal",
    (byte*)"checknumbersuffix",
    (byte*)"stacksourcefile",
    (byte*)"unstacksourcefile",
    (byte*)"getsourcefile",
    (byte*)"lex",
    (byte*)"shownumberstr",
    (byte*)"addnamestr",
    (byte*)"lxreadstring",
    (byte*)"addlisttoken",
    (byte*)"addlisttoken_copy",
    (byte*)"addlist_nextlx",
    (byte*)"addlisttoken_seq",
    (byte*)"addlistmparam",
    (byte*)"dodefine",
    (byte*)"readalphanumeric",
    (byte*)"inmacrostack",
    (byte*)"showtokens",
    (byte*)"lexa",
    (byte*)"lexm",
    (byte*)"peeklb",
    (byte*)"peektk",
    (byte*)"expandobjmacro",
    (byte*)"expandfnmacro",
    (byte*)"scantokenseq",
    (byte*)"readmacrocall",
    (byte*)"substituteargs",
    (byte*)"strtoken",
    (byte*)"strstring",
    (byte*)"emittoken",
    (byte*)"showtoken",
    (byte*)"stringify",
    (byte*)"pastetokens",
    (byte*)"getifexpr",
    (byte*)"evalcondexpr",
    (byte*)"evalorexpr",
    (byte*)"evalandexpr",
    (byte*)"evaliorexpr",
    (byte*)"evalixorexpr",
    (byte*)"evaliandexpr",
    (byte*)"evaleqexpr",
    (byte*)"evalcmpexpr",
    (byte*)"evalshiftexpr",
    (byte*)"evaladdexpr",
    (byte*)"evalmulexpr",
    (byte*)"evalunaryexpr",
    (byte*)"evalterm",
    (byte*)"getifdef",
    (byte*)"skipcode",
    (byte*)"freetokens",
    (byte*)"fastreadtoken",
    (byte*)"alloctoken",
    (byte*)"alloctokenz",
    (byte*)"expandpredefmacro",
    (byte*)"dopragmadir",
    (byte*)"needspace",
    (byte*)"dospecialinclude",
    (byte*)"addautomodule",
    (byte*)"setnumberoffset",
    (byte*)"setfileno",
    (byte*)"setfilenox",
    (byte*)"getfileno",
    (byte*)"getfilenox",
    (byte*)"getnumberoffsetx",
    (byte*)"freehashtable",
    (byte*)"freestentry",
    (byte*)"regenlookup",
    (byte*)"printhashtable",
    (byte*)"newhashtable",
    (byte*)"old_readrealnumber",
    (byte*)"issimpleconstmacro",
    (byte*)"start",
    (byte*)"newstrec",
    (byte*)"initcclib",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"printstflat",
    (byte*)"createname",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createunit3",
    (byte*)"createconstunit",
    (byte*)"createstringconstunit",
    (byte*)"createwstringconstunit",
    (byte*)"getoptocode",
    (byte*)"getconstvalue",
    (byte*)"nextautotype",
    (byte*)"createconstmode",
    (byte*)"createrefmode",
    (byte*)"createprocmode",
    (byte*)"createarraymode",
    (byte*)"createenummode",
    (byte*)"createstructmode",
    (byte*)"setnameptr",
    (byte*)"printcode_all",
    (byte*)"printcode",
    (byte*)"printunit",
    (byte*)"printunitlist",
    (byte*)"getprefix",
    (byte*)"getdottedname",
    (byte*)"getlineinfok",
    (byte*)"getautofieldname",
    (byte*)"convertstring",
    (byte*)"strexpr",
    (byte*)"jeval",
    (byte*)"getopcjname",
    (byte*)"strmode",
    (byte*)"strmode2",
    (byte*)"istrmode",
    (byte*)"countunits",
    (byte*)"purgesymbol",
    (byte*)"purgesymbollist",
    (byte*)"purgeprocs",
    (byte*)"purgeproc",
    (byte*)"printmodelist",
    (byte*)"typename",
    (byte*)"allocunitrec",
    (byte*)"copymode",
    (byte*)"createnewmode",
    (byte*)"addlistunit",
    (byte*)"addlistdef",
    (byte*)"addlistparam",
    (byte*)"checksymbol",
    (byte*)"skipsymbol",
    (byte*)"inittypetables",
    (byte*)"createdupldef",
    (byte*)"createnewmoduledef",
    (byte*)"createnewproc",
    (byte*)"resolvename",
    (byte*)"resolvelabel",
    (byte*)"checkdupl",
    (byte*)"checkdupl_inproc",
    (byte*)"getalignment",
    (byte*)"isexported",
    (byte*)"isimported",
    (byte*)"isstructunion",
    (byte*)"getstname",
    (byte*)"isrealcc",
    (byte*)"isintcc",
    (byte*)"start",
    (byte*)"mclinit",
    (byte*)"gettargetdata",
    (byte*)"initmcdest",
    (byte*)"genmc",
    (byte*)"genmc_cond",
    (byte*)"lastmc",
    (byte*)"genmcstr",
    (byte*)"newopnd",
    (byte*)"duplopnd",
    (byte*)"genxreg",
    (byte*)"genindex",
    (byte*)"writemclblock",
    (byte*)"writemclcode",
    (byte*)"gencomment",
    (byte*)"genstrimm",
    (byte*)"genwstrimm",
    (byte*)"genname",
    (byte*)"writemcl",
    (byte*)"strmcl",
    (byte*)"stropnd",
    (byte*)"strvalue",
    (byte*)"setsegment",
    (byte*)"getprocname",
    (byte*)"widenstr",
    (byte*)"genassem",
    (byte*)"strlabel",
    (byte*)"makeindirect",
    (byte*)"applyoffset",
    (byte*)"applysize",
    (byte*)"isframe",
    (byte*)"genreturn",
    (byte*)"getsizeprefix",
    (byte*)"needsizeprefix",
    (byte*)"changeopndsize",
    (byte*)"genint",
    (byte*)"genreal",
    (byte*)"genimm",
    (byte*)"genlabel",
    (byte*)"genmem_u",
    (byte*)"genmem_d",
    (byte*)"genmemaddr_u",
    (byte*)"genmemaddr_d",
    (byte*)"genreg",
    (byte*)"genireg",
    (byte*)"getopndsize_u",
    (byte*)"getopndsize_d",
    (byte*)"getmclcond",
    (byte*)"getfullname",
    (byte*)"roundsizetg",
    (byte*)"iscallbackfn",
    (byte*)"getregname",
    (byte*)"getblockname",
    (byte*)"fgetregname",
    (byte*)"issimple",
    (byte*)"issimple0",
    (byte*)"issimplepm",
    (byte*)"getaregs",
    (byte*)"getlregs",
    (byte*)"isintconst",
    (byte*)"_getnextreg",
    (byte*)"getnextreg",
    (byte*)"ispoweroftwo",
    (byte*)"sameoperand",
    (byte*)"findlastmcl",
    (byte*)"genmsource",
    (byte*)"roundto",
    (byte*)"pushstack",
    (byte*)"pushstackfp",
    (byte*)"popstack",
    (byte*)"definelabel",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"genjumpl",
    (byte*)"setalign",
    (byte*)"gettypecat",
    (byte*)"doblockcall",
    (byte*)"getblockreg",
    (byte*)"copyretvalue",
    (byte*)"enterproc",
    (byte*)"leaveproc",
    (byte*)"start",
    (byte*)"readmodule",
    (byte*)"parsemodule",
    (byte*)"readdeclspec",
    (byte*)"istypestarter",
    (byte*)"istypestarter_next",
    (byte*)"readexpression",
    (byte*)"readassignexpr",
    (byte*)"readcondexpr",
    (byte*)"readorlexpr",
    (byte*)"readandlexpr",
    (byte*)"readiorexpr",
    (byte*)"readixorexpr",
    (byte*)"readiandexpr",
    (byte*)"readeqexpr",
    (byte*)"readrelexpr",
    (byte*)"readshiftexpr",
    (byte*)"readaddexpr",
    (byte*)"readmulexpr",
    (byte*)"readterm",
    (byte*)"readexprlist",
    (byte*)"readmodulevar",
    (byte*)"readframevar",
    (byte*)"readtype",
    (byte*)"readnamedtype",
    (byte*)"readconstintexpr",
    (byte*)"readinitexpr",
    (byte*)"readinitexpr2",
    (byte*)"pushblock",
    (byte*)"popblock",
    (byte*)"readcompoundstmt",
    (byte*)"readblock",
    (byte*)"readstatement",
    (byte*)"readifstmt",
    (byte*)"readforstmt",
    (byte*)"readwhilestmt",
    (byte*)"readdostmt",
    (byte*)"readreturnstmt",
    (byte*)"readgotostmt",
    (byte*)"readswitchstmt",
    (byte*)"readcaselabel",
    (byte*)"readexprstmt",
    (byte*)"readcond",
    (byte*)"isusertype",
    (byte*)"readlocaldecl",
    (byte*)"createtypedef",
    (byte*)"readparams",
    (byte*)"readcasttype",
    (byte*)"readfunction",
    (byte*)"getbasesymbol",
    (byte*)"readfunctionbody",
    (byte*)"createnegop",
    (byte*)"createabsop",
    (byte*)"createsqrtop",
    (byte*)"createinotop",
    (byte*)"createptrop",
    (byte*)"createincrop",
    (byte*)"createlengthofop",
    (byte*)"createaddrofop",
    (byte*)"createaddop",
    (byte*)"createsubop",
    (byte*)"createmulop",
    (byte*)"createdivop",
    (byte*)"createremop",
    (byte*)"insertunit",
    (byte*)"eval_add",
    (byte*)"eval_sub",
    (byte*)"eval_mul",
    (byte*)"eval_div",
    (byte*)"eval_rem",
    (byte*)"eval_convert",
    (byte*)"coercecond",
    (byte*)"coercebasetype",
    (byte*)"checklvalue",
    (byte*)"createcall",
    (byte*)"arraytopointer",
    (byte*)"createindexop",
    (byte*)"readstructdecl",
    (byte*)"checkpointertypes",
    (byte*)"comparemode",
    (byte*)"readenumdecl",
    (byte*)"readenumnames",
    (byte*)"createdotop",
    (byte*)"mulunit",
    (byte*)"divunit",
    (byte*)"createassignopref",
    (byte*)"addnewfield",
    (byte*)"pushloop",
    (byte*)"poploop",
    (byte*)"addcasevalue",
    (byte*)"roundoffset",
    (byte*)"fixmemopnd",
    (byte*)"docast",
    (byte*)"coercemode",
    (byte*)"coercemode_inplace",
    (byte*)"dostaticassert",
    (byte*)"createsizeofop",
    (byte*)"readgeneric",
    (byte*)"readstructinfosym",
    (byte*)"getmemmode",
    (byte*)"readstrinclude",
    (byte*)"start",
    (byte*)"stopcompiler",
    (byte*)"mcerror",
    (byte*)"serror",
    (byte*)"serror_gen",
    (byte*)"serror_ss",
    (byte*)"serror_s",
    (byte*)"terror_gen",
    (byte*)"terror",
    (byte*)"terror_s",
    (byte*)"terror_ss",
    (byte*)"gerror_gen",
    (byte*)"gerror",
    (byte*)"gerror_s",
    (byte*)"nxerror",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"nextpoweroftwo",
    (byte*)"loaderror",
    (byte*)"loadfromstdin",
    (byte*)"loadsourcefile",
    (byte*)"splicelines",
    (byte*)"loadbuiltin",
    (byte*)"gs_copytostr",
    (byte*)"gs_additem",
    (byte*)"isalphanum",
    (byte*)"showmacrolineno",
    (byte*)"start",
    (byte*)"start",
    (byte*)"assembler",
    (byte*)"loadsourcefiles",
    (byte*)"parsemodules",
    (byte*)"fixopnd",
    (byte*)"initall",
    (byte*)"loaderror",
    (byte*)"loaderror_s",
    (byte*)"addmodule",
    (byte*)"addsearchlib",
    (byte*)"getemptyst",
    (byte*)"findduplname",
    (byte*)"adddupl",
    (byte*)"scanglobals",
    (byte*)"resethashtable",
    (byte*)"start",
    (byte*)"start",
    (byte*)"decodeinstr",
    (byte*)"decodetwobyteinstr",
    (byte*)"decodeaddr",
    (byte*)"readbyte",
    (byte*)"readsbyte",
    (byte*)"readword16",
    (byte*)"readint16",
    (byte*)"readword32",
    (byte*)"readint32",
    (byte*)"readint64",
    (byte*)"getreg",
    (byte*)"strreg",
    (byte*)"strfreg",
    (byte*)"printaddrmode",
    (byte*)"genstr",
    (byte*)"genintd",
    (byte*)"genhex",
    (byte*)"readimm",
    (byte*)"readimm8",
    (byte*)"strxmm",
    (byte*)"strmmx",
    (byte*)"decode8087",
    (byte*)"do87arith",
    (byte*)"do87mem",
    (byte*)"getsil",
    (byte*)"getsilx",
    (byte*)"start",
    (byte*)"genss",
    (byte*)"doinstr",
    (byte*)"genbyte",
    (byte*)"genword",
    (byte*)"gendword",
    (byte*)"genqword",
    (byte*)"genopnd",
    (byte*)"addrelocitem",
    (byte*)"getstindex",
    (byte*)"genrel32",
    (byte*)"genabs32",
    (byte*)"genabs64",
    (byte*)"getrel32",
    (byte*)"dofwdrefs",
    (byte*)"genrex",
    (byte*)"isbytesized",
    (byte*)"isdwordsized",
    (byte*)"do_push",
    (byte*)"do_pop",
    (byte*)"do_inc",
    (byte*)"do_neg",
    (byte*)"genamode",
    (byte*)"makemodrm",
    (byte*)"setopsize",
    (byte*)"getdispsize",
    (byte*)"genrmbyte",
    (byte*)"makeam",
    (byte*)"do_lea",
    (byte*)"do_movsx",
    (byte*)"checkhighreg",
    (byte*)"do_exch",
    (byte*)"do_movsxd",
    (byte*)"do_imul2",
    (byte*)"do_shift",
    (byte*)"do_test",
    (byte*)"do_loop",
    (byte*)"do_jcxz",
    (byte*)"do_setcc",
    (byte*)"do_arithxmm",
    (byte*)"do_logicxmm",
    (byte*)"do_convertfloat",
    (byte*)"do_fix",
    (byte*)"do_float",
    (byte*)"do_call",
    (byte*)"do_jmp",
    (byte*)"getcurrdatalen",
    (byte*)"do_cmovcc",
    (byte*)"do_fmem",
    (byte*)"getr32bits",
    (byte*)"genrel8",
    (byte*)"checkshortjump",
    (byte*)"addfwdref",
    (byte*)"switchseg",
    (byte*)"do_popcnt",
    (byte*)"do_bsf",
    (byte*)"extendsymboltable",
    (byte*)"do_pcmpistri",
    (byte*)"genxrm",
    (byte*)"genrrm",
    (byte*)"getregcode",
    (byte*)"checkimmrange",
    (byte*)"newgenrm",
    (byte*)"do_mov",
    (byte*)"do_arith",
    (byte*)"do_movxmm",
    (byte*)"checksize",
    (byte*)"start",
    (byte*)"lex",
    (byte*)"initlex",
    (byte*)"readreal",
    (byte*)"readnumber",
    (byte*)"readbinary",
    (byte*)"readhex",
    (byte*)"ps",
    (byte*)"printsymbol",
    (byte*)"clearhashtable",
    (byte*)"inithashtable",
    (byte*)"addreservedword",
    (byte*)"printhashtable",
    (byte*)"lookuplex",
    (byte*)"initsourcefile",
    (byte*)"addnamestr",
    (byte*)"lxerror",
    (byte*)"gethashvalue",
    (byte*)"skiptoeol",
    (byte*)"makestring",
    (byte*)"start",
    (byte*)"initlib",
    (byte*)"genmc",
    (byte*)"genmcstr",
    (byte*)"newopnd",
    (byte*)"genxreg",
    (byte*)"genindex",
    (byte*)"writemclblock",
    (byte*)"gencomment",
    (byte*)"genstrimm",
    (byte*)"getsizetag",
    (byte*)"writemcl",
    (byte*)"strmcl",
    (byte*)"stropnd",
    (byte*)"strdef",
    (byte*)"setsegment",
    (byte*)"getsizeprefix",
    (byte*)"needsizeprefix",
    (byte*)"genimm_expr",
    (byte*)"genint",
    (byte*)"genlab",
    (byte*)"genmem",
    (byte*)"genreg0",
    (byte*)"getfullname",
    (byte*)"getregname",
    (byte*)"xgetregname",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"adddef",
    (byte*)"addimport",
    (byte*)"createlabel",
    (byte*)"createnamedconst",
    (byte*)"createregalias",
    (byte*)"createxregalias",
    (byte*)"gerror",
    (byte*)"serror",
    (byte*)"serror_s",
    (byte*)"inttostr",
    (byte*)"realtostr",
    (byte*)"buffercreate",
    (byte*)"bufferexpand",
    (byte*)"buffercheck",
    (byte*)"bufferlength",
    (byte*)"bufferelemptr",
    (byte*)"addbyte",
    (byte*)"addword",
    (byte*)"adddword",
    (byte*)"addqword",
    (byte*)"printmodulesymbols",
    (byte*)"printimportsymbols",
    (byte*)"printdupltable",
    (byte*)"start",
    (byte*)"start",
    (byte*)"start",
    (byte*)"readmodule",
    (byte*)"checkundefined",
    (byte*)"checksymbol",
    (byte*)"readinstr",
    (byte*)"readcondinstr",
    (byte*)"readoperand",
    (byte*)"readexpression",
    (byte*)"readterm",
    (byte*)"readreg",
    (byte*)"readaddrmode",
    (byte*)"start",
    (byte*)"start",
    (byte*)"writeexe",
    (byte*)"genexe",
    (byte*)"loadlibs",
    (byte*)"initsectiontable",
    (byte*)"extractlibname",
    (byte*)"scanst",
    (byte*)"relocdata",
    (byte*)"getbaserelocs",
    (byte*)"writerecordx",
    (byte*)"writedosstub",
    (byte*)"writepesig",
    (byte*)"writepadding",
    (byte*)"writefileheader",
    (byte*)"writeoptheader",
    (byte*)"writesectionheader",
    (byte*)"writesectiondata",
    (byte*)"getoffsets",
    (byte*)"getsectionno",
    (byte*)"writeexporttable",
    (byte*)"getexporttablesize",
    (byte*)"newbasereloc",
    (byte*)"scanbaserelocs",
    (byte*)"writebasereloctable",
    (byte*)"sortexports",
    (byte*)"start",
    (byte*)"writess",
    (byte*)"writerecord",
    (byte*)"writerelocs",
    (byte*)"writedata",
    (byte*)"writesymboltable",
    (byte*)"writestringtable",
    (byte*)"makesymbol",
    (byte*)"addsymbol",
    (byte*)"initsymboltable",
    (byte*)"strtoaux",
    (byte*)"sectiontoaux",
    (byte*)"addstringentry",
    (byte*)"convertsymboltable",
    (byte*)"writecoff",
    (byte*)"start",
    (byte*)"m_init",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_get_nprocs",
    (byte*)"m_get_nexports",
    (byte*)"m_get_procname",
    (byte*)"m_get_procaddr",
    (byte*)"m_get_procexport",
    (byte*)"pushio",
    (byte*)"m_print_startfile",
    (byte*)"m_print_startstr",
    (byte*)"m_print_startptr",
    (byte*)"m_print_startcon",
    (byte*)"m_print_setfmt",
    (byte*)"m_print_end",
    (byte*)"m_print_ptr",
    (byte*)"m_print_i64",
    (byte*)"m_print_u64",
    (byte*)"m_print_r64",
    (byte*)"m_print_r32",
    (byte*)"m_print_c8",
    (byte*)"m_print_str",
    (byte*)"m_print_newline",
    (byte*)"m_print_nogap",
    (byte*)"m_print_space",
    (byte*)"printstr",
    (byte*)"printstr_n",
    (byte*)"printstrn_app",
    (byte*)"makezstring",
    (byte*)"freezstring",
    (byte*)"printchar",
    (byte*)"nextfmtchars",
    (byte*)"strtofmt",
    (byte*)"domultichar",
    (byte*)"expandstr",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"i64mintostr",
    (byte*)"strtostrfmt",
    (byte*)"tostr_i64",
    (byte*)"tostr_u64",
    (byte*)"tostr_r64",
    (byte*)"tostr_str",
    (byte*)"getfmt",
    (byte*)"strint",
    (byte*)"getstrint",
    (byte*)"strword",
    (byte*)"strreal",
    (byte*)"getstr",
    (byte*)"initreadbuffer",
    (byte*)"m_read_conline",
    (byte*)"m_read_fileline",
    (byte*)"m_read_strline",
    (byte*)"readitem",
    (byte*)"strtoint",
    (byte*)"m_read_i64",
    (byte*)"m_read_r64",
    (byte*)"m_read_str",
    (byte*)"readstr",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"valint",
    (byte*)"valreal",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"m_power_i64",
    (byte*)"m_intoverflow",
    (byte*)"m_dotindex",
    (byte*)"m_dotslice",
    (byte*)"m_popdotindex",
    (byte*)"m_popdotslice",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"m_sign",
    (byte*)"m_tp_i64tor64",
    (byte*)"m_tp_r64toi64",
    (byte*)"m_tp_reftoi64",
    (byte*)"m_tp_i64toref",
    (byte*)"start",
    (byte*)"pcm_alloc",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"pcm_copyheapstringn",
    (byte*)"pcm_copyheapblock",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"setfilepos",
    (byte*)"getfilepos",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword32",
    (byte*)"outword64",
    (byte*)"outstring",
    (byte*)"outblock",
    (byte*)"myeof",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparamnew",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"mseed",
    (byte*)"mrandom",
    (byte*)"mrandomp",
    (byte*)"mrandomint",
    (byte*)"mrandomrange",
    (byte*)"mrandomreal",
    (byte*)"mrandomreal1",
    (byte*)"readline",
    (byte*)"findfunction",
    (byte*)"roundtoblock",
    (byte*)"pcm_allocnfz",
    (byte*)"start",
    (byte*)"start",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_gxregisterclass",
    (byte*)"mainwndproc",
    (byte*)"os_setmesshandler",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_gethostsize",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_getmpath",
    (byte*)"os_clock",
    (byte*)"os_ticks",
    (byte*)"os_hptimer",
    (byte*)"os_iswindows",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"os_allocexecmem",
    (byte*)"start",
    (byte*)"os_calldllfunction",
    (byte*)"os_pushargs",
    (byte*)"calldll_cint",
    (byte*)"calldll_creal",
    (byte*)"os_dummycall",
    (byte*)"start",
(byte*)""};
static i64 msysc$_fnnprocs=1059;
static i64 msysc$_fnnexports;
static i64 msysc$fmtparam;
static i64 msysc$needgap = (i64)0;
static i64 msysc$outdev = (i64)1;
static void *  msysc$outchan = 0;
static u8 *  msysc$fmtstr = 0;
static void *  msysc$outchan_stack[10];
static i64 msysc$outdev_stack[10];
static u8 *  msysc$fmtstr_stack[10];
static byte msysc$needgap_stack[10];
static u8 *  msysc$ptr_stack[10];
static i64 msysc$niostack = (i64)0;
static u8 msysc$digits[16] = {
    (u8)(i64)48,
    (u8)(i64)49,
    (u8)(i64)50,
    (u8)(i64)51,
    (u8)(i64)52,
    (u8)(i64)53,
    (u8)(i64)54,
    (u8)(i64)55,
    (u8)(i64)56,
    (u8)(i64)57,
    (u8)(i64)65,
    (u8)(i64)66,
    (u8)(i64)67,
    (u8)(i64)68,
    (u8)(i64)69,
    (u8)(i64)70
};
static struct msysc$fmtrec msysc$defaultfmt = {
    (u8)0u,
    (i8)(i64)0,
    (u8)10u,
    (u8)(i64)0,
    (u8)' ',
    (u8)'f',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)'R',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)0u
};
static u8 *  msysc$rd_buffer;
static i64 msysc$rd_length;
static u8 *  msysc$rd_pos;
static u8 *  msysc$rd_lastpos;
static i64 msysc$termchar;
static i64 msysc$itemerror;
static i64 msysc$$cmdskip;
static i64 msysc$nsysparams;
static i64 msysc$ncmdparams;
static i64 msysc$nenvstrings;
static u8 *  msysc$sysparams[128];
static u8 *(*msysc$cmdparams)[];
static u8 *(*msysc$envstrings)[];
static u64 msysc$mask63 = (u64)9223372036854775807u;
static r64 msysc$offset64 = (double)9223372036854775800.;
static r64 msysc$offset32 = (double)9223372036854775800.;
static u64 mlib$allocupper[301];
static i64 mlib$alloccode;
static i64 mlib$allocbytes;
static i64 mlib$fdebug = (i64)0;
static i64 mlib$rfsize;
static u64 mlib$maxmemory;
static i64 mlib$maxalloccode;
static void *  mlib$allocbase;
static byte mlib$pcm_setup = (byte)(i64)0;
static i64 mlib$show = (i64)0;
static i64 mlib$memtotal = (i64)0;
static i64 mlib$smallmemtotal = (i64)0;
static i64 mlib$smallmemobjs = (i64)0;
static i64 mlib$maxmemtotal = (i64)0;
static i32 *  mlib$memalloctable[3];
static i32 mlib$memallocsize[3];
static byte *  mlib$pcheapstart;
static byte *  mlib$pcheapend;
static byte *  mlib$pcheapptr;
static byte mlib$sizeindextable[2049];
static u64 *  mlib$freelist[9];
static u8 *  mlib$pmnames[6] = {(byte*)"pm_end",(byte*)"pm_option",(byte*)"pm_sourcefile",(byte*)"pm_libfile",(byte*)"pm_colon",(byte*)"pm_extra"};
static u64 mlib$seed[2] = {(u64)2993073034246558322u,(u64)1617678968452121188u};
static void *  mwindows$hconsole;
static void *  mwindows$hconsolein;
static struct mwindows$input_record mwindows$lastkey;
static struct mwindows$input_record mwindows$pendkey;
static i64 mwindows$keypending;
static i64 (*mwindows$wndproc_callbackfn)(void *) = 0;
static i64 mwindows$init_flag = (i64)0;

/* PROCDEFS */
int main(int _nargs, char** _args, char** _envstrings) {
    msysc$m_init(_nargs, (void*)_args, (void*)_envstrings);

// call main-start() routines...
    cc_assembler$start();
    msysc$start();
    cc_cli$start();

        i64 pass;
        i64 nextmodule;
    cc_cli$starttiming();
    cc_cli$initdata();
    cc_cli$getinputoptions();
    if (!!((i64)cc_cli$fdebugcompiler)) {
        cc_cli$debugcompile();
        exit(0);
    }
;
    if ((cc_cli$cc_mode >= (i64)3)) {
        cc_decls$fastasm = (i64)1;
    }
;
    cc_cli$initsearchdirs();
    cc_cli$initlogfile();
    nextmodule = (i64)1;
    pass = (i64)1;
    L1 :;
    do {
        cc_cli$compilemodules(nextmodule,cc_decls$ninputfiles,(pass)++);
        nextmodule = cc_cli$addnewmodules();
L2 :;
    }
    while (!(nextmodule == (i64)0));
L3 :;
    ;
    if ((cc_cli$cc_mode >= (i64)3)) {
        cc_cli$do_genlink();
    }
;
    if ((cc_cli$cc_mode == (i64)4)) {
        cc_cli$do_runprog();
    }
;
    if (!!((i64)cc_cli$fshowtiming)) {
        cc_cli$showtiming();
    }
;
    if (!!((i64)cc_cli$fmheaders)) {
        cc_export$writemheader(cc_decls$inputfiles[((i64)1)]);
    }
;
    if (!!((i64)cc_cli$fatfile)) {
        cc_cli$writeatfile();
    }
;
    if (!!(cc_decls$fverbose)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Done.",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    exit((i64)0);
    return 0;
}

static void cc_cli$compilemodules(i64 a,i64 b,i64 pass) {
        u8 str[256];
        u8 *  ext;
        i64 m;
    if ((cc_cli$destfileext == 0)) {
        if ((cc_cli$cc_mode == (i64)1)) {
            ext = (byte*)"i";
        }
        else if (!(!!(cc_decls$fautomodules))) {
            ext = (byte*)"asm";
            if (((cc_decls$ninputfiles == (i64)1) && (cc_cli$cc_mode >= (i64)3))) {
                ext = cc_cli$linkoption;
            }
;
        }
        else {
            ext = (byte*)"asm";
        }
;
    }
    else {
        ext = cc_cli$destfileext;
    }
;
    for (m=a;m<=b;++m) {
L4 :;
        if (!!(cc_decls$fautomodules)) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"## Compiling # to # (Pass #)");
            msysc$m_print_str(((pass == (i64)1) ? (byte*)"  " : (byte*)"* "),NULL);
            msysc$m_print_i64(m,(byte*)"2");
            msysc$m_print_str(cc_decls$inputfiles[(m)],(byte*)"jl12");
            msysc$m_print_str(mlib$changeext(cc_decls$inputfiles[(m)],ext),(byte*)"jl16");
            msysc$m_print_i64(pass,NULL);
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_str(str,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else if (!(!!(cc_decls$fquiet))) {
            if ((cc_cli$cc_mode == (i64)1)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Preprocessing",NULL);
                msysc$m_print_str(cc_decls$inputfiles[(m)],NULL);
                msysc$m_print_str((byte*)"to",NULL);
                msysc$m_print_str(mlib$changeext(cc_decls$inputfiles[(m)],(byte*)"i"),NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
            else if ((cc_decls$ninputfiles == (i64)1)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Compiling",NULL);
                msysc$m_print_str(cc_decls$inputfiles[(m)],NULL);
                msysc$m_print_str((byte*)"to",NULL);
                msysc$m_print_str(mlib$changeext(cc_cli$destfilename,ext),NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
            else {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Compiling",NULL);
                msysc$m_print_str(cc_decls$inputfiles[(m)],NULL);
                msysc$m_print_str((byte*)"to",NULL);
                msysc$m_print_str(mlib$changeext(cc_decls$inputfiles[(m)],(byte*)"asm"),NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
;
        }
;
        cc_cli$do_loadmodule(m);
        if ((cc_cli$cc_mode == (i64)1)) {
            cc_cli$do_preprocess(m);
            cc_cli$resetcompiler();
            goto L5 ;
        }
;
        cc_cli$do_parsemodule(m);
        if (!(!!((i64)cc_cli$fatfile))) {
            cc_cli$do_genmcl(m);
            cc_cli$do_genasm(m);
        }
;
        if (!(!!((i64)cc_cli$fmheaders))) {
            cc_cli$resetcompiler();
        }
;
L5 :;
    }
L6 :;
    ;
}

static void cc_cli$debugcompile(void) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"DEBUG COMPILE",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_cli$initsearchdirs();
    cc_decls$logdest = (i64)2;
    cc_cli$initlogfile();
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"LOAD:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_cli$do_loadmodule((i64)1);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"PARSE",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_cli$do_parsemodule((i64)1);
    cc_cli$showast((i64)1);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"GENMCL",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_cli$do_genmcl((i64)1);
    cc_cli$showmcl((byte*)"MCL",(i64)1);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"GENASM",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_cli$do_genasm((i64)1);
    cc_cli$showasm((i64)1);
    cc_cli$showsttree((byte*)"ST",(i64)1);
    cc_cli$showstflat((byte*)"STFLAT");
    cc_cli$closelogfile();
}

static void cc_cli$do_loadmodule(i64 n) {
    if (!!(cc_decls$fverbose)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Loading:",NULL);
        msysc$m_print_str(cc_decls$inputfiles[(n)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    cc_cli$loadmainmodule(cc_decls$inputfiles[(n)]);
}

static void cc_cli$do_preprocess(i64 n) {
    cc_lex$lex_preprocess_only(cc_decls$inputfiles[(n)],(i64)1,n,(i64)cc_cli$fstdout);
}

static void cc_cli$do_parsemodule(i64 n) {
    if (!!(cc_decls$fverbose)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Parsing:",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    cc_parse$parsemodule(n);
}

static void cc_cli$do_genmcl(i64 n) {
    cc_genmcl$codegen_mcl(n);
}

static void cc_cli$do_genasm(i64 n) {
        u8 *  outfileasm;
    outfileasm = mlib$pcm_copyheapstring(mlib$changeext(cc_decls$inputfiles[(n)],(byte*)"asm"));
    cc_genasm$codegen_writeasm(n,outfileasm);
}

static void cc_cli$do_runprog(void) {
        u8 str[300];
        i64 i;
    strcpy((u8 *)str,cc_cli$destfilename);
    for (i=(i64)1;i<=cc_cli$nextraparams;++i) {
L7 :;
        strcat((u8 *)str,(byte*)" ");
        strcat((u8 *)str,cc_cli$extraparams[(i)-1]);
        if (!!(cc_cli$extravalues[(i)-1])) {
            strcat((u8 *)str,(byte*)":");
            strcat((u8 *)str,cc_cli$extravalues[(i)-1]);
        }
;
L8 :;
    }
L9 :;
    ;
    mwindows$os_execwait((u8 *)str,(i64)0,0);
}

static i64 cc_cli$loadmainmodule(u8 *filespec) {
        u8 modulename[100];
        u8 path[300];
        i64 i;
        i64 fileno;
    mlib$pcm_clearmem(&cc_decls$moduletable[((i64)0)],(i64)2040);
    cc_decls$sourcefilenames[((i64)0)] = (byte*)"<dummy file>";
    cc_decls$sourcefilepaths[((i64)0)] = (byte*)"<dummy path>";
    cc_decls$sourcefiletext[((i64)0)] = (byte*)"<sourcefile0>";
    cc_decls$sourcefilesizes[((i64)0)] = strlen(cc_decls$sourcefiletext[((i64)0)]);
    cc_decls$moduletable[((i64)0)].name = (byte*)"PROGRAM";
    cc_decls$moduletable[((i64)0)].fileno = (i64)0;
    cc_decls$stprogram = (struct cc_decls$strec *)cc_lib$createdupldef(0,(struct cc_decls$strec *)cc_lex$addnamestr((byte*)"$prog"),(i64)2);
    cc_decls$moduletable[((i64)0)].stmodule = (struct cc_decls$strec *)cc_decls$stprogram;
    if ((!(!!(mlib$checkfile(filespec))) && !(!!((i64)cc_cli$fstdin)))) {
        cc_support$loaderror((byte*)"Can't load main module: %s",filespec);
    }
;
    if (!!((i64)cc_cli$fstdin)) {
        fileno = cc_support$loadfromstdin(filespec);
    }
    else {
        fileno = cc_support$loadsourcefile(filespec,filespec);
    }
;
    strcpy((u8 *)modulename,mlib$extractbasefile(filespec));
    strcpy((u8 *)path,mlib$extractpath(filespec));
    if (!!((u64)path[((i64)1)-1])) {
        ++(cc_decls$nsearchdirs);
        for (i=cc_decls$nsearchdirs;i>=(i64)2;--i) {
L10 :;
            cc_decls$searchdirs[(i)-1] = cc_decls$searchdirs[((i - (i64)1))-1];
L11 :;
        }
L12 :;
        ;
        cc_decls$searchdirs[((i64)1)-1] = mlib$pcm_copyheapstring((u8 *)path);
    }
;
    cc_cli$addmodule((u8 *)modulename,fileno,(i64)3);
    return (i64)1;
}

static i64 cc_cli$addmodule(u8 *modulename,i64 fileno,i64 id) {
        struct cc_decls$modulerec m;
        struct cc_decls$modulerec *  pmodule;
    mlib$pcm_clearmem(&m,(i64)2040);
    m.name = mlib$pcm_copyheapstring(modulename);
    m.fileno = fileno;
    cc_decls$stmodule = (struct cc_decls$strec *)cc_lib$createnewmoduledef((struct cc_decls$strec *)cc_decls$stprogram,(struct cc_decls$strec *)cc_lex$addnamestr(m.name));
    m.stmodule = (struct cc_decls$strec *)cc_decls$stmodule;
    if ((cc_decls$nmodules >= (i64)2000)) {
        cc_support$loaderror((byte*)"Too many modules %s",modulename);
    }
;
    pmodule = (struct cc_decls$modulerec *)&cc_decls$moduletable[(++(cc_decls$nmodules))];
    (*pmodule) = m;
    (*m.stmodule).attribs.ax_moduleno = cc_decls$nmodules;
    if ((cc_decls$nmodules >= (i64)2000)) {
        cc_support$loaderror((byte*)"Too many modules %s",modulename);
    }
;
    return cc_decls$nmodules;
}

static void cc_cli$initlogfile(void) {
    if ((cc_decls$logdest==(i64)2)) {
        remove((byte*)"bcc.log");
        cc_decls$logdev = fopen((byte*)"bcc.log",(byte*)"w");
    }
    else if ((cc_decls$logdest==(i64)0) || (cc_decls$logdest==(i64)1)) {
        cc_decls$logdev = mwindows$os_getstdout();
    }
;
}

static void cc_cli$closelogfile(void) {
        u8 str[100];
    if ((cc_decls$logdest == (i64)2)) {
        fclose(cc_decls$logdev);
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"\\m\\scripts\\med.bat",NULL);
        msysc$m_print_str((byte*)"bcc.log",NULL);
        msysc$m_print_end();
        ;
        if (!!(mlib$checkfile((byte*)"cc.m"))) {
            mwindows$os_execwait((u8 *)str,(i64)1,0);
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Diagnostic outputs written to",NULL);
            msysc$m_print_str((byte*)"bcc.log",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
    }
;
}

static void cc_cli$initdata(void) {
    mlib$pcm_init();
    cc_lex$lexsetup();
    cc_lib$inittypetables();
    cc_lib$initcclib();
    cc_headers$checkbcclib();
}

static void cc_cli$initsearchdirs(void) {
        i64 i;
    cc_decls$searchdirs[(++(cc_decls$nsearchdirs))-1] = (byte*)"";
    if ((cc_decls$dointheaders == (i64)0)) {
        cc_decls$searchdirs[(++(cc_decls$nsearchdirs))-1] = (byte*)"/cx/headers/";
    }
;
    for (i=(i64)1;i<=cc_decls$nincludepaths;++i) {
L13 :;
        if (!!((u64)(*cc_decls$includepaths[(i)-1]))) {
            cc_decls$searchdirs[(++(cc_decls$nsearchdirs))-1] = cc_decls$includepaths[(i)-1];
        }
;
L14 :;
    }
L15 :;
    ;
}

static void cc_cli$showsearchdirs(void) {
        i64 i;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Include search paths:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if (!!(cc_decls$dointheaders)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"0: Internal standard headers (disable with -ext)",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    for (i=(i64)1;i<=cc_decls$nsearchdirs;++i) {
L16 :;
        if (!!((u64)(*cc_decls$searchdirs[(i)-1]))) {
            msysc$m_print_startcon();
            msysc$m_print_i64(i,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_str(cc_decls$searchdirs[(i)-1],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_i64(i,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)": .",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
L17 :;
    }
L18 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void cc_cli$showast(i64 n) {
    if (!!(cc_decls$logdest)) {
        if ((cc_decls$logdest == (i64)2)) {
            msysc$m_print_startfile(cc_decls$logdev);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        cc_lib$printcode(cc_decls$logdev,(byte*)"PROC AST",n);
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

static void cc_cli$showstflat(u8 *caption) {
    if (!!(cc_decls$logdest)) {
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_str((byte*)"PROC",NULL);
        msysc$m_print_str(caption,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lib$printstflat(cc_decls$logdev);
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

static void cc_cli$showsttree(u8 *caption,i64 n) {
    if (!!(cc_decls$logdest)) {
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_str((byte*)"PROC",NULL);
        msysc$m_print_str(caption,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lib$printst(cc_decls$logdev,(struct cc_decls$strec *)cc_decls$moduletable[(n)].stmodule,(i64)0);
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

static void cc_cli$showmcl(u8 *caption,i64 n) {
        struct mlib$strbuffer *  mclstr;
    if (!!(cc_decls$logdest)) {
        mclstr = (struct mlib$strbuffer *)cc_libmcl$writemclcode(caption,n);
        mlib$gs_println((struct mlib$strbuffer *)mclstr,cc_decls$logdev);
    }
;
}

static void cc_cli$showasm(i64 n) {
        u8 *  asmstr;
        u8 *  caption;
    caption = (byte*)"PROC ASSEMBLY LISTING";
    asmstr = cc_decls$moduletable[(n)].asmstr;
    if ((asmstr == 0)) {
        return;
    }
;
    if (!!(cc_decls$logdest)) {
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_str(caption,NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_str(asmstr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

static void cc_cli$showfiles(void) {
        i64 i;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Sourcefiles:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=cc_decls$nsourcefiles;++i) {
L19 :;
        msysc$m_print_startcon();
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((byte*)":",NULL);
        msysc$m_print_str(cc_decls$sourcefilepaths[(i)],NULL);
        msysc$m_print_str(cc_decls$sourcefilenames[(i)],NULL);
        msysc$m_print_str((byte*)"Size:",NULL);
        msysc$m_print_i64((i64)cc_decls$sourcefilesizes[(i)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L20 :;
    }
L21 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void cc_cli$starttiming(void) {
    cc_cli$progstart = mwindows$os_clock();
}

static void cc_cli$showtiming(void) {
    msysc$m_print_startcon();
    msysc$m_print_i64((mwindows$os_clock() - cc_cli$progstart),NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void cc_cli$showlps(u8 *caption,i64 t) {
}

static void cc_cli$getinputoptions(void) {
        i64 paramno;
        i64 pmtype;
        i64 sw;
        i64 ncolons;
        u8 *  name;
        u8 *  value;
        u8 *  ext;
    paramno = (i64)1;
    ncolons = (i64)0;
    L22 :;
    while (1) {
        pmtype = mlib$nextcmdparamnew(&paramno,&name,&value,(byte*)".c");
        if ((pmtype==(i64)1)) {
            mlib$convlcstring(name);
            for (sw=(i64)1;sw<=(i64)35;++sw) {
L24 :;
                if (!!(mlib$eqstring(name,cc_cli$optionnames[(sw)-1]))) {
                    cc_cli$do_option(sw,value);
                    goto L26 ;
                }
;
L25 :;
            }
            {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Unknown option:",NULL);
                msysc$m_print_str(name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)1);
            }
L26 :;
            ;
        }
        else if ((pmtype==(i64)2)) {
            if ((cc_decls$ninputfiles >= (i64)2000)) {
                cc_support$loaderror((byte*)"Too many input files",(byte*)"");
            }
;
            cc_decls$inputfiles[(++(cc_decls$ninputfiles))] = mlib$pcm_copyheapstring(name);
        }
        else if ((pmtype==(i64)3)) {
            if ((cc_decls$nlibfiles >= (i64)200)) {
                cc_support$loaderror((byte*)"Too many lib files",(byte*)"");
            }
;
            cc_decls$libfiles[(++(cc_decls$nlibfiles))] = mlib$pcm_copyheapstring(name);
        }
        else if ((pmtype==(i64)4)) {
            if ((++(ncolons) > (i64)1)) {
                name = (byte*)":";
                value = 0;
                goto L27 ;
;
            }
;
        }
        else if ((pmtype==(i64)5)) {
            //doextra:
L27 :;
;
            cc_cli$extraparams[(++(cc_cli$nextraparams))-1] = mlib$pcm_copyheapstring(name);
            cc_cli$extravalues[(cc_cli$nextraparams)-1] = mlib$pcm_copyheapstring(value);
        }
        else if ((pmtype==(i64)0)) {
            goto L23 ;
        }
;
    }
L23 :;
    ;
    if ((cc_cli$cc_mode == (i64)0)) {
        cc_cli$cc_mode = (i64)3;
    }
;
    if ((cc_cli$linkoption == 0)) {
        cc_cli$linkoption = (byte*)"exe";
    }
;
    if ((((cc_decls$ninputfiles == (i64)0) && !(!!((i64)cc_cli$fwriteheaders))) && !(!!((i64)cc_cli$fgetlib)))) {
        cc_cli$showcaption();
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Usage:",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(msysc$sysparams[((i64)1)-1],NULL);
        msysc$m_print_str((byte*)"prog[.c]                 # Compile prog.c to prog.exe",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(msysc$sysparams[((i64)1)-1],NULL);
        msysc$m_print_str((byte*)"-help                    # Show options",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(msysc$sysparams[((i64)1)-1],NULL);
        msysc$m_print_str((byte*)"-info                    # Further info",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)22);
    }
;
    if (!!((i64)cc_cli$fwriteheaders)) {
        cc_headers$writeheaders();
        exit((i64)20);
    }
;
    ext = cc_cli$linkoption;
    if ((cc_cli$cc_mode==(i64)1)) {
        ext = (byte*)"i";
    }
    else if ((cc_cli$cc_mode==(i64)2)) {
        ext = (byte*)"asm";
    }
    else {
        ext = cc_cli$linkoption;
    }
;
    if ((cc_cli$destfilename == 0)) {
        cc_cli$destfilename = mlib$pcm_copyheapstring(mlib$changeext(cc_decls$inputfiles[((i64)1)],ext));
    }
    else if (!!(mlib$eqstring(cc_cli$destfileext,(byte*)""))) {
        cc_cli$destfileext = ext;
    }
;
    if ((!!((i64)cc_cli$fmheaders) && (cc_decls$ninputfiles > (i64)1))) {
        cc_support$loaderror((byte*)"-mheaders works on one file only",(byte*)"");
    }
;
}

static void cc_cli$do_option(i64 sw,u8 *value) {
        u8 str[300];
        i64 length;
    if ((sw==(i64)4)) {
        cc_cli$linkoption = (byte*)"obj";
        cc_cli$cc_mode = (i64)3;
    }
    else if ((sw==(i64)5)) {
        cc_cli$linkoption = (byte*)"exe";
        cc_cli$cc_mode = (i64)3;
        cc_cli$fgendll = (i64)0;
    }
    else if ((sw==(i64)6)) {
        cc_cli$linkoption = (byte*)"exe";
        cc_cli$cc_mode = (i64)3;
        cc_cli$fgendll = (i64)1;
    }
    else if ((sw==(i64)1)) {
        cc_cli$cc_mode = (i64)1;
    }
    else if ((sw==(i64)2)) {
        cc_cli$linkoption = (byte*)"obj";
        cc_cli$cc_mode = (i64)3;
    }
    else if ((sw==(i64)3)) {
        cc_cli$cc_mode = (i64)2;
    }
    else if ((sw==(i64)7)) {
        cc_cli$cc_mode = (i64)4;
    }
    else if ((sw==(i64)8)) {
        cc_cli$fshowpaths = (i64)1;
    }
    else if ((sw==(i64)9)) {
        cc_cli$fshowheaders = (i64)1;
    }
    else if ((sw==(i64)12)) {
        if ((cc_decls$nincludepaths > (i64)20)) {
            cc_support$loaderror((byte*)"Too many include paths",(byte*)"");
        }
;
        length = strlen(value);
                {u64 $temp = (u64)(*((value + length) - (i64)1));
if (($temp==(u64)92u) || ($temp=='/')) {
        }
        else {
            strcpy((u8 *)str,value);
            strcat((u8 *)str,(byte*)"/");
            value = (u8 *)str;
        }
        };
        cc_decls$includepaths[(++(cc_decls$nincludepaths))-1] = mlib$pcm_copyheapstring(value);
    }
    else if ((sw==(i64)15)) {
        cc_decls$fverbose = (i64)1;
    }
    else if ((sw==(i64)16)) {
        cc_decls$fverbose = (i64)1;
    }
    else if ((sw==(i64)17)) {
        cc_decls$fquiet = (i64)1;
    }
    else if ((sw==(i64)18) || (sw==(i64)19)) {
        cc_cli$showhelp();
    }
    else if ((sw==(i64)20)) {
        cc_cli$showextrainfo();
    }
    else if ((sw==(i64)21)) {
        cc_decls$dointheaders = (i64)0;
    }
    else if ((sw==(i64)22)) {
        cc_cli$fwriteheaders = (i64)1;
    }
    else if ((sw==(i64)24)) {
        cc_cli$fgetlib = (i64)1;
    }
    else if ((sw==(i64)23)) {
        cc_decls$fmodern = (i64)0;
    }
    else if ((sw==(i64)10)) {
        cc_cli$fstdin = (i64)1;
    }
    else if ((sw==(i64)11)) {
        cc_cli$fstdout = (i64)1;
    }
    else if ((sw==(i64)13)) {
        cc_decls$fshowincludes = (i64)1;
    }
    else if ((sw==(i64)25)) {
        cc_cli$fmheaders = (i64)77;
        cc_cli$cc_mode = (i64)2;
    }
    else if ((sw==(i64)26)) {
        cc_cli$fmheaders = (i64)81;
        cc_cli$cc_mode = (i64)2;
    }
    else if ((sw==(i64)27)) {
        cc_decls$fautomodules = (i64)1;
    }
    else if ((sw==(i64)28)) {
        cc_cli$destfilename = mlib$pcm_copyheapstring(value);
        cc_cli$destfileext = mlib$pcm_copyheapstring(mlib$extractext(value,(i64)0));
    }
    else if ((sw==(i64)29)) {
        cc_cli$fatfile = (i64)1;
    }
    else if ((sw==(i64)14)) {
        cc_cli$fshowtiming = (i64)1;
    }
    else if ((sw==(i64)30)) {
        cc_cli$fdebugcompiler = (i64)1;
    }
    else if ((sw==(i64)31)) {
        cc_cli$fbcclib = (i64)1;
    }
    else if ((sw==(i64)32)) {
        cc_decls$fcallback = (i64)1;
    }
    else if ((sw==(i64)33)) {
        cc_cli$entrypointname = mlib$pcm_copyheapstring(value);
    }
    else if ((sw==(i64)34)) {
        cc_decls$flinesplicing = (i64)1;
    }
;
}

static void cc_cli$showincludepaths(void) {
        i64 i;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Include paths",NULL);
    msysc$m_print_i64(cc_decls$nincludepaths,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=cc_decls$nincludepaths;++i) {
L28 :;
        msysc$m_print_startcon();
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str(cc_decls$includepaths[(i)-1],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L29 :;
    }
L30 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void cc_cli$showhelp(void) {
    cc_cli$showcaption();
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"C Subset Compiler for 64-bit Windows\r\n\r\nNormal use:\r\n\r\n    bcc prog            Compile file prog.c to prog.exe\r\n    bcc prog.c          Same (extension is optional)\r\n    bcc a b c d.dll     Compile a.c, b.c, c.c and link with d.dll to a.exe\r\n\r\nOptions:\r\n\r\n    -e              Write preprocessed output to prog.i\r\n    -s              Compile only, to .asm\r\n    -c              Same as -obj\r\n    -exe            (DEFAULT) compile and link to .exe file\r\n\r\n    -i:path         Add include path\r\n    -ext            Don't use internal standard headers\r\n    -old            Allow features such as () parameter lists, for old programs\r\n    -out:file       Name exe file\r\n\r\n    -obj            Link to single .obj file rather .exe\r\n    -run            Link to .exe then run that program\r\n    -auto           Locate .c files matched to headers and add to modules\r\n    @file           Read further files and options from a file\r\n\r\nOther Options:\r\n\r\n    -info           Show further information\r\n    -time           Show compiler timing stats\r\n    -writeheaders   Write out internal headers as .hdr (not .h) files\r\n    -at             Create an @ file of filenames suitable for most compilers\r\n    -stdin          Read C file from console\r\n    -stdout         Write preprocessor output to console, rather than .i file\r\n",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)23);
}

static void cc_cli$showextrainfo(void) {
        static u8 *  infotext = 
(byte*)"    The 'BCC' C Compiler. Included in the one executable file:\n\n       * A compiler that produces .asm (external or internal)\n       * A minimal set of standard headers\n       * A very minimal windows.h\n       * An assembler/linker generating one .exe or .obj file\n       * The bcclib.asm file (written out as needed)\n\n    BCC only targets x64 with Win64 call convention. It will compile\n    single or multiple .c files to one .asm, .exe or .obj file:\n\n      -e    Preprocess each module to .i file\n      -s    Compile all modules to one .asm file (NOT multiple)\n      -exe  (DEFAULT) Compile all modules to one .exe file\n      -obj  Compile all modules to one .obj file (NOT multiple)\n      -c    Same as -obj\n      -run  Compile to .exe then run the new program. Provide\n            params after \" : \" (spaces needed)\n\n    When there is one output file, it will be named based on the first\n    input file. Otherwise use -out option (see bcc -help).\n\n    .obj files can be linked using gcc on Windows. This option is\n    needed to be able to generate .dll files.\n\n    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are\n    automatically included as search libraries for imported functions.\n\n    For other libraries, add .dll files to bcc command line or @ list.\n    (Note that when any .dll is specified, the default set of DLLs\n    is no longer included. You may need to explicitly specify msvcrt.dll etc.)\n    Other kinds of binary libraries (.a, .lib etc) are not supported.\n\n    (Programs using setjmp and certain internal ops will need bcclib.asm.\n    This file is automatically written by bcc if not present, and\n    automatically linked.)\n\n    Omissions, Restrictions and Bugs (highlights only as there are dozens):\n\n       * No VLAs, compound literals, designated initialisers\n       * Restrictions on complexity of data initialisers\n       * Callback functions are buggy if called from external code (not\n         compiled with bcc). Fix by adding $callback attribute to such\n         functions, or the portable #pragma $callback just before.\n         Typically, functions passed to qsort().\n";
    msysc$m_print_startcon();
    msysc$m_print_str(infotext,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)24);
}

static void cc_cli$showcaption(void) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"BCC 'C' Compiler",NULL);
    msysc$m_print_str((byte*)"6-Sep-2023",NULL);
    msysc$m_print_str((byte*)"17:23:28",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void cc_cli$do_genlink(void) {
        u8 *  asmfiles[2000];
        u8 *  dllfiles[2000];
        u8 *  assemsources[2000];
        u8 *  exefile;
        u8 *  ext;
        i64 nfiles;
        i64 i;
    nfiles = cc_decls$ninputfiles;
    for (i=(i64)1;i<=cc_decls$ninputfiles;++i) {
L31 :;
        asmfiles[(i)-1] = mlib$pcm_copyheapstring(mlib$changeext(cc_decls$inputfiles[(i)],(byte*)"asm"));
        if (!!(cc_decls$fastasm)) {
            assemsources[(i)-1] = cc_decls$moduletable[(i)].asmstr;
        }
;
L32 :;
    }
L33 :;
    ;
    if ((!(!!(mlib$eqstring(cc_cli$linkoption,(byte*)"obj"))) || !!((i64)cc_cli$fbcclib))) {
        ++(nfiles);
        asmfiles[(nfiles)-1] = (byte*)"bcclib.asm";
        if (!!(cc_decls$fastasm)) {
            assemsources[(nfiles)-1] = cc_headers$getbcclib();
        }
;
    }
;
    for (i=(i64)1;i<=cc_decls$nlibfiles;++i) {
L34 :;
        dllfiles[(i)-1] = mlib$pcm_copyheapstring(cc_decls$libfiles[(i)]);
L35 :;
    }
L36 :;
    ;
    if ((cc_cli$destfileext == 0)) {
        ext = cc_cli$linkoption;
    }
    else {
        ext = cc_cli$destfileext;
    }
;
    if (!!((i64)cc_cli$fgendll)) {
        ext = (byte*)"dll";
    }
;
    exefile = mlib$pcm_copyheapstring(mlib$changeext(cc_cli$destfilename,ext));
    if (!(!!(cc_assembler$assembler(exefile,(u8 *(*)[])&asmfiles,(u8 *(*)[])&dllfiles,nfiles,cc_decls$nlibfiles,mlib$eqstring(cc_cli$linkoption,(byte*)"obj"),(i64)(!!(cc_decls$fautomodules) || (cc_decls$ninputfiles > (i64)1)),(!!(cc_decls$fastasm) ? &assemsources : 0),cc_cli$entrypointname,(i64)cc_cli$fgendll)))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Couldn't assemble or link",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
;
}

static void cc_cli$resetcompiler(void) {
        i64 i;
    cc_lex$freehashtable();
    cc_decls$ntypes = cc_decls$ntypesreset;
    cc_genasm$nstrings = (cc_genasm$nreals = (cc_genasm$ndints = (i64)0));
    cc_decls$stprogram = (struct cc_decls$strec *)(cc_decls$stmodule = 0);
    cc_decls$currblockno = (cc_decls$nextblockno = (cc_decls$blocklevel = (i64)0));
    cc_lib$autotypeno = (i64)0;
    cc_lib$nextafindex = (i64)0;
    cc_decls$labelno = (i64)0;
    for (i=(i64)1;i<=cc_decls$nsourcefiles;++i) {
L37 :;
        if (((i64)cc_decls$sourcefilesizes[(i)] > (i64)2048)) {
            free((void *)cc_decls$sourcefiletext[(i)]);
        }
;
L38 :;
    }
L39 :;
    ;
    cc_decls$nsourcefiles = (i64)0;
    mlib$pcm_clearmem(&cc_decls$ttnamedef,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$ttbasetype,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$ttlength,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$ttconst,(i64)10000);
    mlib$pcm_clearmem(&cc_decls$ttrestrict,(i64)10000);
    mlib$pcm_clearmem(&cc_decls$ttvolatile,(i64)10000);
    mlib$pcm_clearmem(&cc_decls$ttusertype,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$tttarget,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$ttreftype,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$ttconsttype,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$ttsize,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$ttbitwidth,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$ttisref,(i64)10000);
    mlib$pcm_clearmem(&cc_decls$ttparams,(i64)80000);
    mlib$pcm_clearmem(&cc_decls$tttypedef,(i64)80000);
    cc_lib$inittypetables();
}

static i64 cc_cli$addnewmodules(void) {
        i64 nextinputfile;
        i64 n;
        i64 newfile;
        i64 i;
        i64 j;
    nextinputfile = (cc_decls$ninputfiles + (i64)1);
    n = (i64)0;
    for (i=(i64)1;i<=cc_decls$nautomodules;++i) {
L40 :;
        newfile = (i64)1;
        for (j=(i64)1;j<=cc_decls$ninputfiles;++j) {
L43 :;
            if (!!(mlib$eqstring(cc_decls$inputfiles[(j)],cc_decls$automodulenames[(i)]))) {
                newfile = (i64)0;
                goto L45 ;
            }
;
L44 :;
        }
L45 :;
        ;
        if (!!(newfile)) {
            cc_decls$inputfiles[(++(cc_decls$ninputfiles))] = cc_decls$automodulenames[(i)];
            ++(n);
        }
;
L41 :;
    }
L42 :;
    ;
    cc_decls$nautomodules = (i64)0;
    if ((n == (i64)0)) {
        return (i64)0;
    }
;
    return nextinputfile;
}

static void cc_cli$writeatfile(void) {
        void *  f;
        u8 *  file;
        i64 i;
    f = fopen((file = mlib$changeext(cc_cli$destfilename,(byte*)"")),(byte*)"w");
    if (!(!!(f))) {
        return;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Writing @ file",NULL);
    msysc$m_print_str(file,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=cc_decls$ninputfiles;++i) {
L46 :;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(cc_decls$inputfiles[(i)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L47 :;
    }
L48 :;
    ;
    for (i=(i64)1;i<=cc_decls$nlibfiles;++i) {
L49 :;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(cc_decls$libfiles[(i)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L50 :;
    }
L51 :;
    ;
    fclose(f);
}

// START
void cc_cli$start(void) {
    cc_decls$start();
    cc_blockmcl$start();
    cc_export$start();
    cc_genasm$start();
    cc_genmcl$start();
    cc_headers$start();
    cc_lex$start();
    cc_lib$start();
    cc_libmcl$start();
    cc_parse$start();
    cc_support$start();
    cc_tables$start();

}

// START
void cc_decls$start(void) {

}

void cc_blockmcl$do_stmt(struct cc_decls$unitrec *p) {
        i64 oldclineno;
        i64 value;
        i64 i;
        struct cc_decls$unitrec *  a;
        struct cc_decls$unitrec *  b;
        u8 str[256];
    if ((p == 0)) {
        return;
    }
;
    oldclineno = cc_decls$clineno;
    cc_decls$clineno = (((i64)(*p).fileno << (i64)24) + (i64)(*p).lineno);
    a = (struct cc_decls$unitrec *)(*p).a;
    b = (struct cc_decls$unitrec *)(*p).b;
    switch ((i64)(*p).tag) {
    case 6:;
        {
            L52 :;
            while (!!(a)) {
                cc_blockmcl$do_stmt(a);
                a = (struct cc_decls$unitrec *)(*a).nextunit;
L53 :;
            }
L54 :;
            ;
        }
        break;
    case 8:;
        {
            cc_blockmcl$do_decl((struct cc_decls$strec *)(*p).def);
        }
        break;
    case 31:;
        {
            cc_blockmcl$dx_call(p,a,b,(i64)1);
        }
        break;
    case 10:;
        {
            cc_blockmcl$do_return(a);
        }
        break;
    case 12:;
        {
            cc_blockmcl$do_assign(a,b);
        }
        break;
    case 13:;
        {
            cc_blockmcl$do_if(a,b,(struct cc_decls$unitrec *)(*p).c);
        }
        break;
    case 14:;
        {
            cc_blockmcl$do_for(a,b);
        }
        break;
    case 15:;
        {
            cc_blockmcl$do_while(a,b);
        }
        break;
    case 16:;
        {
            cc_blockmcl$do_dowhile(a,b);
        }
        break;
    case 17:;
        {
            cc_blockmcl$do_goto((struct cc_decls$strec *)(*p).def);
        }
        break;
    case 18:;
        {
            cc_blockmcl$do_labeldef((struct cc_decls$strec *)(*p).def);
            cc_blockmcl$do_stmt(a);
        }
        break;
    case 19:;
        {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"case");
            msysc$m_print_i64((i64)(*p).index,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_end();
            ;
            cc_libmcl$gencomment(mlib$pcm_copyheapstring((u8 *)str));
            if ((cc_blockmcl$sw_ncases == (i64)0)) {
                cc_libmcl$genmc((i64)3,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel((*cc_blockmcl$sw_labeltable)[((((*p).value - cc_blockmcl$sw_lower) + (i64)1))-1],(i64)0),0);
            }
            else {
                value = (*p).value;
                for (i=(i64)1;i<=cc_blockmcl$sw_ncases;++i) {
L55 :;
                    if (((*cc_blockmcl$sw_valuetable)[(i)-1] == value)) {
                        cc_libmcl$genmc((i64)3,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel((*cc_blockmcl$sw_labeltable)[(i)-1],(i64)0),0);
                        goto L57 ;
                    }
;
L56 :;
                }
                {
                    cc_support$gerror((byte*)"case: serial switch not found",0);
                }
L57 :;
                ;
            }
;
            cc_blockmcl$do_stmt(a);
        }
        break;
    case 20:;
        {
            cc_blockmcl$sw_defaultseen = (i64)1;
            cc_libmcl$gencomment((byte*)"default:");
            cc_libmcl$genmc((i64)3,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(cc_blockmcl$sw_defaultlabel,(i64)0),0);
            cc_blockmcl$do_stmt(a);
        }
        break;
    case 24:;
        {
            cc_libmcl$genjumpl(cc_blockmcl$sw_breaklabel);
        }
        break;
    case 21:;
        {
            cc_libmcl$genjumpl(cc_blockmcl$breakstack[(cc_blockmcl$loopindex)-1]);
        }
        break;
    case 22:;
        {
            cc_libmcl$genjumpl(cc_blockmcl$continuestack[(cc_blockmcl$loopindex)-1]);
        }
        break;
    case 23:;
        {
            cc_blockmcl$do_switch(p,a,b);
        }
        break;
    case 62:;
        {
            ++(cc_blockmcl$naddto);
            cc_blockmcl$dx_addto((i64)21,a,b,(i64)0);
        }
        break;
    case 63:;
        {
            ++(cc_blockmcl$naddto);
            cc_blockmcl$dx_addto((i64)22,a,b,(i64)0);
        }
        break;
    case 64:;
        {
            ++(cc_blockmcl$naddto);
            cc_blockmcl$dx_multo(a,b,(i64)0);
        }
        break;
    case 65:;
    case 66:;
        {
            ++(cc_blockmcl$naddto);
            cc_blockmcl$dx_divto(p,a,b,(i64)0);
        }
        break;
    case 67:;
        {
            ++(cc_blockmcl$naddto);
            cc_blockmcl$dx_addto((i64)28,a,b,(i64)0);
        }
        break;
    case 68:;
        {
            ++(cc_blockmcl$naddto);
            cc_blockmcl$dx_addto((i64)29,a,b,(i64)0);
        }
        break;
    case 69:;
        {
            ++(cc_blockmcl$naddto);
            cc_blockmcl$dx_addto((i64)30,a,b,(i64)0);
        }
        break;
    case 70:;
    case 71:;
        {
            ++(cc_blockmcl$naddto);
            cc_blockmcl$dx_shlto(p,a,b,(i64)0);
        }
        break;
    case 73:;
    case 75:;
        {
            cc_blockmcl$do_preincr(a,(i64)21,(i64)38);
        }
        break;
    case 74:;
    case 76:;
        {
            cc_blockmcl$do_preincr(a,(i64)22,(i64)39);
        }
        break;
    case 30:;
        {
            cc_blockmcl$do_exprlist(a);
        }
        break;
    default: {
        if ((((i64)(*p).tag != (i64)1) || !(!!(cc_decls$fshownames)))) {
            cc_blockmcl$loneexpr(p);
        }
;
    }
    } //SW
;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_expr(struct cc_decls$unitrec *p,i64 reg,i64 am) {
        i64 oldclineno;
        i64 m;
        struct cc_decls$unitrec *  a;
        struct cc_decls$unitrec *  b;
        struct cc_libmcl$opndrec *  tx;
    if ((p == 0)) {
        return 0;
    }
;
    if (((reg > (i64)9) && (reg < (i64)11))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"DOEXPR TOO MANY REGS?",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    oldclineno = cc_decls$clineno;
    cc_decls$clineno = (((i64)(*p).fileno << (i64)24) + (i64)(*p).lineno);
    tx = 0;
    a = (struct cc_decls$unitrec *)(*p).a;
    b = (struct cc_decls$unitrec *)(*p).b;
    m = (i64)(*p).mode;
    switch ((i64)(*p).tag) {
    case 1:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_const(p,reg);
        }
        break;
    case 3:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_name(p,reg,am);
        }
        break;
    case 4:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_widen(a,m,reg);
        }
        break;
    case 5:;
        {
            return (struct cc_libmcl$opndrec *)cc_libmcl$genmemaddr_u(p);
        }
        break;
    case 12:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_assign(a,b,reg);
        }
        break;
    case 25:;
    case 26:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_andorl(p,reg);
        }
        break;
    case 27:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_notl(a,reg);
        }
        break;
    case 28:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_istruel(a,reg);
        }
        break;
    case 30:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_exprlist(a,reg);
        }
        break;
    case 31:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_call(p,a,b,reg);
        }
        break;
    case 32:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_ifx(a,b,(struct cc_decls$unitrec *)(*p).c,reg);
        }
        break;
    case 34:;
    case 35:;
    case 36:;
    case 37:;
    case 39:;
    case 38:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_eq(p,a,b,reg);
        }
        break;
    case 40:;
        {
            if ((!!((i64)cc_decls$ttisref[((i64)(*a).mode)]) && (cc_decls$ttsize[((i64)(*b).mode)] <= (i64)4))) {
                (*b).mode = (i64)10;
            }
;
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_add(a,b,reg);
        }
        break;
    case 41:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_sub(a,b,reg);
        }
        break;
    case 42:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_mul(p,a,b,reg);
        }
        break;
    case 43:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_div(p,a,b,reg);
        }
        break;
    case 44:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_rem(p,a,b,reg);
        }
        break;
    case 45:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_iand((i64)28,a,b,reg);
        }
        break;
    case 46:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_iand((i64)29,a,b,reg);
        }
        break;
    case 47:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_iand((i64)30,a,b,reg);
        }
        break;
    case 48:;
    case 49:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_shl(p,a,b,reg);
        }
        break;
    case 53:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_ptr(p,a,reg,am);
        }
        break;
    case 54:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_addptr(p,a,b,reg,am);
        }
        break;
    case 55:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_subptr(a,b,reg,am);
        }
        break;
    case 57:;
        {
            if ((m == (i64)1)) {
                return (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,reg);
            }
            else {
                return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_convert(a,m,(i64)(*p).opcode,reg);
            }
;
        }
        break;
    case 58:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_scale(p,a,b,reg);
        }
        break;
    case 59:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_neg(a,reg);
        }
        break;
    case 61:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_inot(a,reg);
        }
        break;
    case 73:;
    case 74:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_preincrx(p,a,reg);
        }
        break;
    case 75:;
    case 76:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_postincrx(p,a,reg);
        }
        break;
    case 62:;
        {
            ++(cc_blockmcl$naddtox);
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_addto((i64)21,a,b,reg);
        }
        break;
    case 63:;
        {
            ++(cc_blockmcl$naddtox);
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_addto((i64)22,a,b,reg);
        }
        break;
    case 64:;
        {
            ++(cc_blockmcl$naddtox);
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_multo(a,b,reg);
        }
        break;
    case 65:;
    case 66:;
        {
            ++(cc_blockmcl$naddtox);
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_divto(p,a,b,reg);
        }
        break;
    case 67:;
        {
            ++(cc_blockmcl$naddtox);
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_addto((i64)28,a,b,reg);
        }
        break;
    case 68:;
        {
            ++(cc_blockmcl$naddtox);
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_addto((i64)29,a,b,reg);
        }
        break;
    case 69:;
        {
            ++(cc_blockmcl$naddtox);
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_addto((i64)30,a,b,reg);
        }
        break;
    case 70:;
    case 71:;
        {
            ++(cc_blockmcl$naddtox);
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_shlto(p,a,b,reg);
        }
        break;
    case 72:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_sqrt(a,reg);
        }
        break;
    case 56:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_addrof(p,a,reg,am);
        }
        break;
    case 50:;
        {
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_dot(p,a,b,reg,am);
        }
        break;
    default: {
        cc_support$gerror_s((byte*)"DX-EXPR: can't do tag: %s",cc_tables$jtagnames[((i64)(*p).tag)],0);
    }
    } //SW
;
    if ((tx == 0)) {
        cc_support$gerror_s((byte*)"DX-EXPR: NO RESULT: %s",cc_tables$jtagnames[((i64)(*p).tag)],0);
    }
;
    cc_decls$clineno = oldclineno;
    return (struct cc_libmcl$opndrec *)tx;
}

static void cc_blockmcl$loneexpr(struct cc_decls$unitrec *p) {
    if ((!!(p) && ((i64)(*p).tag != (i64)2))) {
        cc_blockmcl$loadexpr(p,(i64)1,(i64)0);
    }
;
}

static void cc_blockmcl$do_assign(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b) {
        struct cc_libmcl$opndrec *  lhs;
        struct cc_libmcl$opndrec *  rhs;
        i64 reg;
        i64 tx;
        {i64 $temp = cc_decls$ttsize[((i64)(*a).mode)];
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4) || ($temp==(i64)8)) {
    }
    else {
        cc_blockmcl$do_assignblock(a,b,(i64)0);
        return;
    }
    };
    reg = (i64)1;
    if (!!(cc_libmcl$issimple(a))) {
        if (!!(cc_libmcl$issimple(b))) {
            lhs = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
            if (!!(cc_libmcl$isintconst(b))) {
                rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)lhs,reg));
            }
            else {
                rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)lhs,reg),(i64)1);
            }
;
        }
        else {
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)1);
            lhs = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg));
        }
;
    }
    else {
        if (!!(cc_libmcl$issimple(b))) {
            lhs = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)lhs,reg),(i64)1);
        }
        else {
            tx = cc_blockmcl$saveexpr(b,(i64)1);
            lhs = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,(i64)1);
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)lhs,reg));
        }
;
    }
;
    cc_blockmcl$storeopnd((struct cc_libmcl$opndrec *)lhs,(struct cc_libmcl$opndrec *)rhs);
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_assign(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  lhs;
        struct cc_libmcl$opndrec *  rhs;
        struct cc_libmcl$opndrec *  rx;
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 tx;
        {i64 $temp = cc_decls$ttsize[((i64)(*a).mode)];
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4) || ($temp==(i64)8)) {
    }
    else {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$do_assignblock(a,b,reg);
    }
    };
    if (!!(cc_libmcl$issimple(a))) {
        if (!!(cc_libmcl$issimple(b))) {
            lhs = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)lhs,reg),(i64)1);
            cc_blockmcl$storeopnd((struct cc_libmcl$opndrec *)lhs,(struct cc_libmcl$opndrec *)rhs);
        }
        else {
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)1);
            lhs = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg));
            cc_blockmcl$storeopnd((struct cc_libmcl$opndrec *)lhs,(struct cc_libmcl$opndrec *)rhs);
        }
;
    }
    else {
        if (!!(cc_libmcl$issimple(b))) {
            lhs = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)lhs,reg),(i64)1);
            cc_blockmcl$storeopnd((struct cc_libmcl$opndrec *)lhs,(struct cc_libmcl$opndrec *)rhs);
        }
        else {
            tx = cc_blockmcl$saveexpr(b,(i64)1);
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,(i64)1);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
            cc_blockmcl$storeopnd((struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
            rhs = bx;
        }
;
    }
;
        {i64 $temp = (i64)(*rhs).mode;
if (($temp==(i64)1)) {
        if (((i64)(*rhs).reg != reg)) {
            rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)(*rhs).size);
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)rhs);
            return (struct cc_libmcl$opndrec *)rx;
        }
;
    }
    else if (($temp==(i64)6)) {
        if (((i64)(*rhs).reg != reg)) {
            rx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(reg,(i64)(*rhs).size);
            cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)rhs);
            return (struct cc_libmcl$opndrec *)rx;
        }
;
    }
    };
    return (struct cc_libmcl$opndrec *)rhs;
}

static i64 cc_blockmcl$saveexpr(struct cc_decls$unitrec *a,i64 reg) {
    cc_blockmcl$pushexpr(a,reg);
    return cc_decls$ttsize[((i64)(*a).mode)];
}

static i64 cc_blockmcl$fsaveexpr(struct cc_decls$unitrec *a,i64 reg) {
    cc_blockmcl$fpushexpr(a,reg);
    return cc_decls$ttsize[((i64)(*a).mode)];
}

static struct cc_libmcl$opndrec *cc_blockmcl$restoreexpr(i64 tx,i64 reg) {
        struct cc_libmcl$opndrec *  rx;
    cc_libmcl$genmc((i64)7,(struct cc_libmcl$opndrec *)(rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8)),0);
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$duplopnd((struct cc_libmcl$opndrec *)rx);
    (*rx).size = tx;
    return (struct cc_libmcl$opndrec *)rx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$frestoreexpr(i64 tx,i64 reg) {
        struct cc_libmcl$opndrec *  rx;
    cc_libmcl$genmc((i64)7,(struct cc_libmcl$opndrec *)(rx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(reg,tx)),0);
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$duplopnd((struct cc_libmcl$opndrec *)rx);
    (*rx).size = tx;
    return (struct cc_libmcl$opndrec *)rx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$getlvalueopnd(struct cc_decls$unitrec *a,i64 reg) {
    return (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,reg);
}

static void cc_blockmcl$storeopnd(struct cc_libmcl$opndrec *ax,struct cc_libmcl$opndrec *bx) {
    if (((i64)(*bx).mode == (i64)6)) {
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
    else {
                {i64 $temp = (i64)(*ax).size;
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4)) {
            bx = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)bx,(i64)(*ax).size);
        }
        };
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
;
}

static void cc_blockmcl$pushexpr(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
    if (!!(a)) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(a,reg,(i64)1);
        cc_libmcl$genmc((i64)6,(struct cc_libmcl$opndrec *)ax,0);
    }
    else {
        cc_libmcl$genmc((i64)6,(struct cc_libmcl$opndrec *)cc_libmcl$zero_opnd,0);
    }
;
}

static void cc_blockmcl$fpushexpr(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(a,reg,(i64)1);
    cc_libmcl$genmc((i64)6,(struct cc_libmcl$opndrec *)ax,0);
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_const(struct cc_decls$unitrec *p,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        i64 t;
    if ((((t = cc_decls$ttbasetype[((i64)(*p).mode)]) >= (i64)2) && (t <= (i64)10))) {
        return (struct cc_libmcl$opndrec *)cc_libmcl$genint((*p).value,cc_decls$ttsize[((i64)(*p).mode)]);
    }
    else if (((t >= (i64)11) && (t <= (i64)13))) {
        ax = (struct cc_libmcl$opndrec *)cc_libmcl$genreal((*p).xvalue,cc_decls$ttsize[((i64)(*p).mode)]);
        return (struct cc_libmcl$opndrec *)ax;
    }
    else if ((t == (i64)16)) {
        if (!!((i64)(*p).isstrconst)) {
            return (struct cc_libmcl$opndrec *)cc_libmcl$genstrimm((*p).svalue,(i64)(*p).slength);
        }
        else if (!!((i64)(*p).iswstrconst)) {
            return (struct cc_libmcl$opndrec *)cc_libmcl$genwstrimm((*p).wsvalue,(i64)(*p).wslength);
        }
;
        return (struct cc_libmcl$opndrec *)cc_libmcl$genint((*p).value,(i64)8);
    }
;
    cc_support$gerror_s((byte*)"dxconst %s",cc_lib$strmode((i64)(*p).mode,(i64)1),0);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_constant(struct cc_decls$strec *d,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        i64 t;
    if ((((t = cc_decls$ttbasetype[((i64)(*d).mode)]) >= (i64)2) && (t <= (i64)10))) {
        return (struct cc_libmcl$opndrec *)cc_libmcl$genint((*(*d).code).value,cc_decls$ttsize[((i64)(*d).mode)]);
    }
    else if (((t >= (i64)11) && (t <= (i64)13))) {
        ax = (struct cc_libmcl$opndrec *)cc_libmcl$genreal((*(*d).code).xvalue,cc_decls$ttsize[((i64)(*d).mode)]);
        return (struct cc_libmcl$opndrec *)ax;
    }
;
    cc_support$gerror_s((byte*)"dxconstant %s",cc_lib$strmode((i64)(*d).mode,(i64)1),0);
    return (struct cc_libmcl$opndrec *)ax;
}

static void cc_blockmcl$do_labeldef(struct cc_decls$strec *d) {
    cc_libmcl$genmc((i64)3,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel((i64)(*d).index,(i64)0),(struct cc_libmcl$opndrec *)cc_libmcl$genmemaddr_d((struct cc_decls$strec *)d));
}

static void cc_blockmcl$do_goto(struct cc_decls$strec *d) {
    if (((i64)(*d).index == (i64)0)) {
        cc_support$gerror_s((byte*)"Label not defined: %s",(*d).name,0);
    }
;
    cc_libmcl$genmc((i64)18,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel((i64)(*d).index,(i64)0),0);
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_add(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 tx;
    if ((cc_libmcl$gettypecat(a) == (i64)82)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_fadd((i64)21,a,b,reg);
    }
;
    if (!!(cc_libmcl$issimple(b))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else if (!!(cc_libmcl$issimple(a))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else {
        tx = cc_blockmcl$saveexpr(a,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
;
    cc_libmcl$genmc((i64)21,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_fadd(i64 opc,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 tx;
    if (!!(cc_libmcl$issimple(b))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(a,reg);
        if (((((opc == (i64)23) && ((i64)(*a).tag == (i64)3)) && ((i64)(*b).tag == (i64)3)) && ((*a).def == (*b).def))) {
            bx = ax;
        }
        else {
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$fevalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
;
    }
    else if ((!!(cc_libmcl$issimple(a)) && ((opc == (i64)21) || (opc == (i64)23)))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(b,reg);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$fevalexpr(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else {
        tx = cc_blockmcl$fsaveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(a,reg);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$frestoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
;
    if ((opc==(i64)21)) {
        cc_libmcl$genmc((i64)44,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
    else if ((opc==(i64)22)) {
        cc_libmcl$genmc((i64)45,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
    else if ((opc==(i64)23)) {
        cc_libmcl$genmc((i64)46,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
    else if ((opc==(i64)24)) {
        cc_libmcl$genmc((i64)47,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
;
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$loadexpr(struct cc_decls$unitrec *a,i64 reg,i64 isassign) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  rx;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(a,reg,(i64)1);
        {i64 $temp = (i64)(*ax).size;
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4) || ($temp==(i64)8)) {
    }
    else {
                {i64 $temp = (i64)(*ax).mode;
if (($temp==(i64)4)) {
            if (((((*ax).def == 0) && ((i64)(*ax).regix == (i64)0)) && ((*ax).value == (i64)0))) {
                return (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)(*ax).reg,(i64)8);
            }
;
            rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((reg + cc_libmcl$getaregs((struct cc_libmcl$opndrec *)ax)),(i64)8);
            cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
            return (struct cc_libmcl$opndrec *)rx;
        }
        else if (($temp==(i64)1)) {
            return (struct cc_libmcl$opndrec *)ax;
        }
        else if (($temp==(i64)2)) {
        }
        else {
            cc_support$gerror((byte*)"loadexpr block not mem/reg",0);
        }
        };
    }
    };
        {i64 $temp = (i64)(*ax).mode;
if (($temp==(i64)1)) {
        if (((i64)(*ax).reg == reg)) {
            return (struct cc_libmcl$opndrec *)ax;
        }
;
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)(*ax).size);
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
        return (struct cc_libmcl$opndrec *)rx;
    }
    else if (($temp==(i64)6)) {
        if ((!!(isassign) && ((i64)(*ax).reg == reg))) {
            return (struct cc_libmcl$opndrec *)ax;
        }
;
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)(*ax).size);
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
        return (struct cc_libmcl$opndrec *)rx;
    }
    };
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)(*ax).size);
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
    return (struct cc_libmcl$opndrec *)rx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$evalexpr(struct cc_decls$unitrec *p,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  rx;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(p,reg,(i64)1);
    if (((i64)(*ax).mode == (i64)6)) {
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)(*ax).reg,(i64)(*ax).size);
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
        return (struct cc_libmcl$opndrec *)rx;
    }
;
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$evaladdr(struct cc_decls$unitrec *p,i64 reg) {
    return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(p,reg,(i64)0);
}

static struct cc_libmcl$opndrec *cc_blockmcl$evalptr(struct cc_decls$unitrec *p,i64 reg) {
    return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(p,reg,(i64)2);
}

static struct cc_libmcl$opndrec *cc_blockmcl$floadexpr(struct cc_decls$unitrec *a,i64 xreg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  rx;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(a,xreg,(i64)1);
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(xreg,cc_libmcl$getopndsize_u(a));
        {i64 $temp = (i64)(*ax).mode;
if (($temp==(i64)6)) {
        if (((i64)(*ax).reg == xreg)) {
            return (struct cc_libmcl$opndrec *)ax;
        }
;
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
        return (struct cc_libmcl$opndrec *)rx;
    }
    else if (($temp==(i64)1)) {
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg((i64)(*ax).reg,(i64)(*ax).size);
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
        return (struct cc_libmcl$opndrec *)rx;
    }
    };
    cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
    return (struct cc_libmcl$opndrec *)rx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$fevalexpr(struct cc_decls$unitrec *p,i64 xreg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  rx;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(p,xreg,(i64)1);
    if (((i64)(*ax).mode == (i64)1)) {
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(xreg,cc_libmcl$getopndsize_u(p));
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
        return (struct cc_libmcl$opndrec *)rx;
    }
;
    return (struct cc_libmcl$opndrec *)ax;
}

static void cc_blockmcl$do_if(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,struct cc_decls$unitrec *c) {
        i64 lab1;
        i64 lab2;
    lab1 = cc_libmcl$createfwdlabel();
    cc_blockmcl$genjumpcond((i64)0,a,lab1,(i64)1);
    cc_blockmcl$do_stmt(b);
    if (!!(c)) {
        lab2 = cc_libmcl$createfwdlabel();
        cc_libmcl$genjumpl(lab2);
        cc_libmcl$definefwdlabel(lab1);
        cc_blockmcl$do_stmt(c);
        cc_libmcl$definefwdlabel(lab2);
    }
    else {
        cc_libmcl$definefwdlabel(lab1);
    }
;
}

static void cc_blockmcl$genjumpcond(i64 opc,struct cc_decls$unitrec *p,i64 lab,i64 reg) {
        struct cc_decls$unitrec *  q;
        struct cc_decls$unitrec *  r;
        i64 lab2;
        struct cc_libmcl$opndrec *  ax;
    q = (struct cc_decls$unitrec *)(*p).a;
    r = (struct cc_decls$unitrec *)(*p).b;
    switch ((i64)(*p).tag) {
    case 25:;
        {
            if ((opc==(i64)0)) {
                cc_blockmcl$genjumpcond((i64)0,q,lab,reg);
                cc_blockmcl$genjumpcond((i64)0,r,lab,reg);
            }
            else if ((opc==(i64)1)) {
                lab2 = cc_libmcl$createfwdlabel();
                cc_blockmcl$genjumpcond((i64)0,q,lab2,reg);
                cc_blockmcl$genjumpcond((i64)1,r,lab,reg);
                cc_libmcl$definefwdlabel(lab2);
            }
;
        }
        break;
    case 26:;
        {
            if ((opc==(i64)0)) {
                lab2 = cc_libmcl$createfwdlabel();
                cc_blockmcl$genjumpcond((i64)1,q,lab2,reg);
                cc_blockmcl$genjumpcond((i64)0,r,lab,reg);
                cc_libmcl$definefwdlabel(lab2);
            }
            else if ((opc==(i64)1)) {
                cc_blockmcl$genjumpcond((i64)1,q,lab,reg);
                cc_blockmcl$genjumpcond((i64)1,r,lab,reg);
            }
;
        }
        break;
    case 27:;
        {
            if ((opc==(i64)0)) {
                cc_blockmcl$genjumpcond((i64)1,q,lab,reg);
            }
            else if ((opc==(i64)1)) {
                cc_blockmcl$genjumpcond((i64)0,q,lab,reg);
            }
;
        }
        break;
    case 28:;
        {
            cc_blockmcl$genjumpcond(opc,q,lab,reg);
        }
        break;
    case 34:;
    case 35:;
    case 36:;
    case 37:;
    case 39:;
    case 38:;
        {
            cc_blockmcl$gcomparejump(opc,p,q,r,lab,reg);
        }
        break;
    case 30:;
        {
            L58 :;
            while ((!!(q) && !!((r = (struct cc_decls$unitrec *)(*q).nextunit)))) {
                cc_blockmcl$dx_expr(q,reg,(i64)1);
                q = r;
L59 :;
            }
L60 :;
            ;
            cc_blockmcl$genjumpcond(opc,q,lab,reg);
        }
        break;
    default: {
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)73)) {
            cc_blockmcl$do_preincr((struct cc_decls$unitrec *)(*p).a,(i64)21,(i64)38);
        }
        else if (($temp==(i64)74)) {
            cc_blockmcl$do_preincr((struct cc_decls$unitrec *)(*p).a,(i64)22,(i64)39);
        }
        else {
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(p,reg,(i64)0);
            cc_libmcl$genmc((i64)32,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)4));
        }
        };
        cc_libmcl$genmc_cond((i64)19,(!!(opc) ? (i64)5 : (i64)4),(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(lab,(i64)0),0);
    }
    } //SW
;
}

static void cc_blockmcl$gcomparejump(i64 jumpopc,struct cc_decls$unitrec *p,struct cc_decls$unitrec *lhs,struct cc_decls$unitrec *rhs,i64 lab,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 mclcond;
        i64 cond;
        i64 tx;
    cond = (i64)(*p).tag;
    if ((jumpopc == (i64)0)) {
        cond = cc_blockmcl$reversecond(cond);
    }
;
    mclcond = cc_libmcl$getmclcond(cond,(i64)(*lhs).mode);
    if ((mclcond==(i64)16) || (mclcond==(i64)17) || (mclcond==(i64)18) || (mclcond==(i64)19) || (mclcond==(i64)20) || (mclcond==(i64)21)) {
        if (!!(cc_libmcl$issimple(rhs))) {
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(lhs,reg);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$fevalexpr(rhs,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
        else {
            tx = cc_blockmcl$saveexpr(rhs,reg);
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(lhs,reg);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$frestoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
;
        cc_libmcl$genmc((i64)48,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
    else {
        if (!!(cc_libmcl$issimple(rhs))) {
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(lhs,reg,(i64)0);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(rhs,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
            cc_libmcl$genmc((i64)32,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
        }
        else if (!!(cc_libmcl$issimple(lhs))) {
            mclcond = cc_blockmcl$reversemclcond(mclcond);
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(rhs,reg,(i64)0);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(lhs,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
            cc_libmcl$genmc((i64)32,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
        }
        else {
            cc_blockmcl$pushexpr(rhs,reg);
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(lhs,reg,(i64)0);
            bx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg),(i64)(*ax).size);
            cc_libmcl$genmc((i64)7,(struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)bx,(i64)8),0);
            cc_libmcl$genmc((i64)32,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
        }
;
    }
;
    cc_libmcl$genmc_cond((i64)19,mclcond,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(lab,(i64)0),0);
}

static i64 cc_blockmcl$reversecond(i64 op) {
    if ((op==(i64)34)) {
        return (i64)35;
    }
    else if ((op==(i64)35)) {
        return (i64)34;
    }
    else if ((op==(i64)36)) {
        return (i64)39;
    }
    else if ((op==(i64)37)) {
        return (i64)38;
    }
    else if ((op==(i64)39)) {
        return (i64)36;
    }
    else if ((op==(i64)38)) {
        return (i64)37;
    }
;
    return (i64)0;
}

static void cc_blockmcl$do_preincr(struct cc_decls$unitrec *a,i64 addop,i64 incrop) {
        struct cc_libmcl$opndrec *  ptropnd;
        i64 size;
    ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,(i64)1);
    if (((cc_decls$ttbasetype[((i64)(*a).mode)] == (i64)16) && (cc_decls$ttsize[(cc_decls$tttarget[((i64)(*a).mode)])] != (i64)1))) {
        size = cc_decls$ttsize[(cc_decls$tttarget[((i64)(*a).mode)])];
        cc_libmcl$genmc(addop,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)cc_libmcl$genint(size,(i64)4));
    }
    else {
        cc_libmcl$genmc(incrop,(struct cc_libmcl$opndrec *)ptropnd,0);
    }
;
}

static i64 cc_blockmcl$reversemclcond(i64 cond) {
    switch (cond) {
    case 12:;
        {
            cond = (i64)15;
        }
        break;
    case 14:;
        {
            cond = (i64)13;
        }
        break;
    case 13:;
        {
            cond = (i64)14;
        }
        break;
    case 15:;
        {
            cond = (i64)12;
        }
        break;
    case 2:;
        {
            cond = (i64)7;
        }
        break;
    case 6:;
        {
            cond = (i64)3;
        }
        break;
    case 3:;
        {
            cond = (i64)6;
        }
        break;
    case 7:;
        {
            cond = (i64)2;
        }
        break;
    case 16:;
        {
            cond = (i64)19;
        }
        break;
    case 18:;
        {
            cond = (i64)17;
        }
        break;
    case 17:;
        {
            cond = (i64)18;
        }
        break;
    case 19:;
        {
            cond = (i64)16;
        }
        break;
    } //SW
;
    return cond;
}

static void cc_blockmcl$do_while(struct cc_decls$unitrec *pcond,struct cc_decls$unitrec *pbody) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
    if ((((i64)(*pcond).tag == (i64)1) && !!((*pcond).value))) {
        cc_blockmcl$do_while1(pbody);
        return;
    }
;
    lab_c = cc_libmcl$createfwdlabel();
    lab_d = cc_libmcl$createfwdlabel();
    cc_blockmcl$stacklooplabels(lab_c,lab_d);
    cc_libmcl$genjumpl(lab_c);
    lab_b = cc_libmcl$definelabel();
    cc_blockmcl$do_stmt(pbody);
    cc_libmcl$definefwdlabel(lab_c);
    cc_blockmcl$genjumpcond((i64)1,pcond,lab_b,(i64)1);
    cc_libmcl$definefwdlabel(lab_d);
    --(cc_blockmcl$loopindex);
}

static void cc_blockmcl$do_while1(struct cc_decls$unitrec *pbody) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
    lab_c = cc_libmcl$createfwdlabel();
    lab_d = cc_libmcl$createfwdlabel();
    cc_blockmcl$stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl$definelabel();
    cc_blockmcl$do_stmt(pbody);
    cc_libmcl$definefwdlabel(lab_c);
    cc_libmcl$genjumpl(lab_b);
    cc_libmcl$definefwdlabel(lab_d);
    --(cc_blockmcl$loopindex);
}

static void cc_blockmcl$stacklooplabels(i64 a,i64 b) {
    cc_blockmcl$continuestack[(++(cc_blockmcl$loopindex))-1] = a;
    cc_blockmcl$breakstack[(cc_blockmcl$loopindex)-1] = b;
}

static void cc_blockmcl$do_dowhile(struct cc_decls$unitrec *pbody,struct cc_decls$unitrec *pcond) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
    lab_c = cc_libmcl$createfwdlabel();
    lab_d = cc_libmcl$createfwdlabel();
    cc_blockmcl$stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl$definelabel();
    cc_blockmcl$do_stmt(pbody);
    cc_libmcl$definefwdlabel(lab_c);
    cc_blockmcl$genjumpcond((i64)1,pcond,lab_b,(i64)1);
    cc_libmcl$definefwdlabel(lab_d);
    --(cc_blockmcl$loopindex);
}

static void cc_blockmcl$do_for(struct cc_decls$unitrec *pinit,struct cc_decls$unitrec *pbody) {
        struct cc_decls$unitrec *  pcond;
        struct cc_decls$unitrec *  pincr;
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_cond;
    pcond = (struct cc_decls$unitrec *)(*pinit).nextunit;
    pincr = (struct cc_decls$unitrec *)(*pcond).nextunit;
    lab_c = cc_libmcl$createfwdlabel();
    lab_d = cc_libmcl$createfwdlabel();
    lab_cond = cc_libmcl$createfwdlabel();
    if (((i64)(*pinit).tag != (i64)2)) {
        cc_blockmcl$do_stmt(pinit);
    }
;
    cc_libmcl$genjumpl(lab_cond);
    cc_blockmcl$stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl$definelabel();
    cc_blockmcl$do_stmt(pbody);
    cc_libmcl$definefwdlabel(lab_c);
    cc_blockmcl$do_stmt(pincr);
    cc_libmcl$definefwdlabel(lab_cond);
    if (((i64)(*pcond).tag != (i64)2)) {
        cc_blockmcl$genjumpcond((i64)1,pcond,lab_b,(i64)1);
    }
    else {
        cc_libmcl$genjumpl(lab_b);
    }
;
    cc_libmcl$definefwdlabel(lab_d);
    --(cc_blockmcl$loopindex);
}

static i64 cc_blockmcl$pushffparams(struct cc_decls$unitrec *p,i64 variadic) {
        struct cc_libmcl$opndrec *  rx;
        struct cc_libmcl$opndrec *  fx;
        byte iscomplex[4];
        i64 i;
        i64 m;
        i64 n;
        i64 dummypush;
        i64 size;
        i64 popbytes;
        i64 ncomplex;
        struct cc_decls$unitrec *  q;
        struct cc_decls$unitrec *  paramlist[200];
    n = (i64)0;
    L61 :;
    while (!!(p)) {
        if ((n >= (i64)200)) {
            cc_support$gerror((byte*)"TOO MANY PARAMS",0);
        }
;
        ++(n);
        paramlist[(n)-1] = p;
        p = (struct cc_decls$unitrec *)(*p).nextunit;
L62 :;
    }
L63 :;
    ;
    m = (n>(i64)4?n:(i64)4);
    dummypush = (i64)0;
    if (((!!((m & (i64)1)) && !!(cc_libmcl$stackaligned)) || (((m & (i64)1) == (i64)0) && !(!!(cc_libmcl$stackaligned))))) {
        dummypush = (i64)1;
        if ((n > (i64)4)) {
            cc_libmcl$pushstack((i64)8);
        }
;
        popbytes = ((m + (i64)1) * (i64)8);
    }
    else {
        popbytes = (m * (i64)8);
    }
;
    for (i=n;i>=(i64)5;--i) {
L64 :;
        q = paramlist[(i)-1];
        if ((!!(variadic) && (cc_decls$ttbasetype[((i64)(*q).mode)] == (i64)11))) {
            cc_blockmcl$pushfloatparam(q);
        }
        else {
            cc_blockmcl$pushexpr(q,(i64)1);
        }
;
L65 :;
    }
L66 :;
    ;
    if ((!!(dummypush) && (n <= (i64)4))) {
        cc_libmcl$pushstack((i64)40);
    }
    else {
        cc_libmcl$pushstack((i64)32);
    }
;
    n = (n<(i64)4?n:(i64)4);
    if ((n == (i64)1)) {
        cc_blockmcl$pushoneparam(paramlist[(i)-1],variadic);
        return popbytes;
    }
;
    ncomplex = (i64)0;
    for (i=n;i>=(i64)1;--i) {
L67 :;
        q = paramlist[(i)-1];
        if (!!(cc_libmcl$issimplepm(q))) {
            iscomplex[(i)-1] = (i64)0;
        }
        else {
            cc_blockmcl$pushexpr(q,(i64)1);
            iscomplex[(i)-1] = (i64)1;
            ++(ncomplex);
        }
;
L68 :;
    }
L69 :;
    ;
    for (i=(i64)1;i<=n;++i) {
L70 :;
        q = paramlist[(i)-1];
        if ((cc_libmcl$gettypecat(q) != (i64)82)) {
            if (!!((i64)iscomplex[(i)-1])) {
                cc_libmcl$genmc((i64)7,(struct cc_libmcl$opndrec *)(rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((((i64)11 + i) - (i64)1),(i64)8)),0);
            }
            else {
                rx = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(q,(((i64)11 + i) - (i64)1),(i64)0);
            }
;
        }
        else {
            if ((!!(variadic) && (cc_decls$ttbasetype[((i64)(*q).mode)] == (i64)11))) {
                cc_blockmcl$loadfloatparam(q,(i - (i64)1),(i64)iscomplex[(i)-1]);
            }
            else {
                size = cc_decls$ttsize[((i64)(*q).mode)];
                if (!!((i64)iscomplex[(i)-1])) {
                    cc_libmcl$genmc((i64)7,(struct cc_libmcl$opndrec *)(rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)8)),0);
                    cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)(fx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg((((i64)1 + i) - (i64)1),size)),(struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)rx,size));
                }
                else {
                    fx = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(q,(((i64)1 + i) - (i64)1));
                }
;
                if (!!(variadic)) {
                    cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((((i64)11 + i) - (i64)1),size),(struct cc_libmcl$opndrec *)fx);
                }
;
            }
;
        }
;
L71 :;
    }
L72 :;
    ;
    return popbytes;
}

static void cc_blockmcl$pushoneparam(struct cc_decls$unitrec *q,i64 variadic) {
        struct cc_libmcl$opndrec *  fx;
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
    if ((cc_libmcl$gettypecat(q) != (i64)82)) {
        if (!!(cc_libmcl$issimple(q))) {
            cc_blockmcl$loadexpr(q,(i64)11,(i64)0);
        }
        else {
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(q,(i64)1,(i64)0);
            bx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)11,(i64)(*ax).size);
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)bx,(struct cc_libmcl$opndrec *)ax);
        }
;
    }
    else {
        fx = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(q,(i64)1);
        if (!!(variadic)) {
            cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)11,cc_decls$ttsize[((i64)(*q).mode)]),(struct cc_libmcl$opndrec *)fx);
        }
;
    }
;
}

static void cc_blockmcl$pushfloatparam(struct cc_decls$unitrec *q) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        struct cc_libmcl$opndrec *  fx;
    fx = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(q,(i64)14);
    cc_libmcl$genmc((i64)53,(struct cc_libmcl$opndrec *)(ax = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)fx,(i64)8)),(struct cc_libmcl$opndrec *)fx);
    cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)(bx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)8)),(struct cc_libmcl$opndrec *)ax);
    cc_libmcl$genmc((i64)6,(struct cc_libmcl$opndrec *)bx,0);
}

static void cc_blockmcl$loadfloatparam(struct cc_decls$unitrec *q,i64 regoffset,i64 iscomplex) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  ax32;
        struct cc_libmcl$opndrec *  fx;
        struct cc_libmcl$opndrec *  fx32;
    fx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(((i64)1 + regoffset),(i64)8);
    fx32 = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(((i64)1 + regoffset),(i64)4);
    ax = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(((i64)11 + regoffset),(i64)8);
    ax32 = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(((i64)11 + regoffset),(i64)4);
    if (!!(iscomplex)) {
        cc_libmcl$genmc((i64)7,(struct cc_libmcl$opndrec *)ax,0);
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)fx32,(struct cc_libmcl$opndrec *)ax32);
        cc_libmcl$genmc((i64)53,(struct cc_libmcl$opndrec *)fx,(struct cc_libmcl$opndrec *)fx32);
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)fx);
    }
    else {
        cc_blockmcl$floadexpr(q,((i64)1 + regoffset));
        cc_libmcl$genmc((i64)53,(struct cc_libmcl$opndrec *)fx,(struct cc_libmcl$opndrec *)fx32);
        cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)fx);
    }
;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_call(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  result;
        struct cc_libmcl$opndrec *  cx;
        struct cc_libmcl$opndrec *  sx;
        struct cc_decls$paramrec *  pm;
        i64 isfnptr;
        i64 variadic;
        i64 nparams;
        i64 retmode;
        i64 nbytes;
        i64 retsize;
        i64 m;
        i64 nregparams;
        i64 i;
    retmode = (i64)(*p).mode;
    if ((retmode == (i64)1)) {
        retmode = (i64)4;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)53)) {
        m = (i64)(*a).mode;
        L73 :;
        while ((cc_decls$ttbasetype[(m)] == (i64)16)) {
            m = cc_decls$tttarget[(m)];
L74 :;
        }
L75 :;
        ;
        pm = (struct cc_decls$paramrec *)cc_decls$ttparams[(m)];
        isfnptr = (i64)1;
    }
    else {
        pm = (struct cc_decls$paramrec *)(*(*a).def).paramlist;
        isfnptr = (i64)0;
    }
    };
    variadic = (i64)((i64)(*pm).flags == (i64)3);
    nparams = (i64)(*pm).nparams;
    nbytes = cc_blockmcl$pushffparams(b,variadic);
    retsize = cc_decls$ttsize[(retmode)];
    if ((retsize > (i64)8)) {
        cc_libmcl$doblockcall(retsize);
    }
;
    if (!(!!(isfnptr))) {
        cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cc_libmcl$genmemaddr_u(a),0);
    }
    else {
        if (!!(cc_libmcl$issimple(a))) {
            cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr((struct cc_decls$unitrec *)(*a).a,(i64)1,(i64)0),(i64)8),0);
        }
        else {
            nregparams = (nparams<(i64)4?nparams:(i64)4);
            sx = (struct cc_libmcl$opndrec *)cc_libmcl$genireg((i64)16,(i64)8);
            for (i=(i64)1;i<=nregparams;++i) {
L76 :;
                cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)sx,((i - (i64)1) * (i64)8),(i64)0),(struct cc_libmcl$opndrec *)cc_libmcl$genreg((((i64)11 + i) - (i64)1),(i64)8));
L77 :;
            }
L78 :;
            ;
            cx = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr((struct cc_decls$unitrec *)(*a).a,(i64)1,(i64)0),(i64)8);
            sx = (struct cc_libmcl$opndrec *)cc_libmcl$genireg((i64)16,(i64)8);
            for (i=(i64)1;i<=nregparams;++i) {
L79 :;
                cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((((i64)11 + i) - (i64)1),(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)sx,((i - (i64)1) * (i64)8),(i64)0));
L80 :;
            }
L81 :;
            ;
            cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cx,0);
        }
;
    }
;
    cc_libmcl$popstack(nbytes);
    if ((cc_libmcl$gettypecat(p) == (i64)82)) {
        result = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(reg,retsize);
    }
    else if ((retsize <= (i64)8)) {
        result = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,retsize);
    }
    else {
        result = (struct cc_libmcl$opndrec *)cc_libmcl$getblockreg(retsize);
    }
;
    return (struct cc_libmcl$opndrec *)result;
}

static void cc_blockmcl$do_return(struct cc_decls$unitrec *a) {
    cc_libmcl$leaveproc((*cc_decls$currproc).name);
    if (!!(a)) {
        if (!!(cc_lib$isrealcc((i64)(*a).mode))) {
            cc_blockmcl$floadexpr(a,(i64)1);
        }
        else {
            cc_blockmcl$loadexpr(a,(i64)1,(i64)0);
            if (!!(cc_libmcl$structretoffset)) {
                cc_libmcl$copyretvalue(cc_decls$ttsize[((i64)(*a).mode)]);
            }
;
        }
;
    }
;
    cc_libmcl$genreturn(cc_libmcl$framebytes,cc_libmcl$parambytes);
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_sub(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 tx;
        i64 doneg;
    if ((cc_libmcl$gettypecat(a) == (i64)82)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_fadd((i64)22,a,b,reg);
    }
;
    doneg = (i64)0;
    if (!!(cc_libmcl$issimple(b))) {
        //simplesub:
L82 :;
;
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else if (!!(cc_libmcl$issimple(a))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        doneg = (i64)1;
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
;
    cc_libmcl$genmc((i64)22,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    if (!!(doneg)) {
        cc_libmcl$genmc((i64)36,(struct cc_libmcl$opndrec *)ax,0);
    }
;
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_mul(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 x;
        i64 n;
        i64 tx;
        {i64 $temp = cc_libmcl$gettypecat(a);
if (($temp==(i64)82)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_fadd((i64)23,a,b,reg);
    }
    };
    if ((((i64)(*b).tag == (i64)1) && !!(cc_lib$isintcc((i64)(*b).mode)))) {
        x = (*b).value;
        if (!!((n = cc_libmcl$ispoweroftwo(x)))) {
            (*p).tag = (i64)48;
            (*b).value = n;
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_shl(p,a,b,reg);
        }
;
    }
;
    if (!!(cc_libmcl$issimple(b))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        if (((((i64)(*a).tag == (i64)3) && ((i64)(*b).tag == (i64)3)) && ((*a).def == (*b).def))) {
            bx = ax;
        }
        else {
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
;
    }
    else if (!!(cc_libmcl$issimple(a))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
;
    cc_libmcl$genmc((i64)23,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_div(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 opc;
        i64 n;
        i64 tx;
        {i64 $temp = cc_libmcl$gettypecat(a);
if (($temp==(i64)82)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_fadd((i64)24,a,b,reg);
    }
    else if (($temp==(i64)73)) {
        opc = (i64)24;
    }
    else {
        opc = (i64)25;
    }
    };
    if ((((i64)(*b).tag == (i64)1) && !!(cc_lib$isintcc((i64)(*b).mode)))) {
        if (!!((n = cc_libmcl$ispoweroftwo((*b).value)))) {
            (*p).tag = (i64)49;
            (*b).value = n;
            return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_shl(p,a,b,reg);
        }
;
    }
;
    if ((reg != (i64)1)) {
        cc_support$gerror((byte*)"DIV REG NOT ZERO",0);
    }
;
    if (!!(cc_libmcl$issimple(b))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        if (((i64)(*b).tag == (i64)1)) {
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg),(i64)0);
        }
        else {
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
;
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
;
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)bx,0);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_shl(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 opc;
        i64 tx;
    if (((i64)(*p).tag == (i64)48)) {
        opc = (i64)33;
    }
    else {
                {i64 $temp = cc_libmcl$gettypecat(p);
if (($temp==(i64)73)) {
            opc = (i64)34;
        }
        else {
            opc = (i64)35;
        }
        };
    }
;
    if ((!!(cc_libmcl$issimple(b)) && (reg != (i64)11))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        if (((i64)(*b).tag == (i64)1)) {
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,(i64)11);
        }
        else {
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,(i64)11,(i64)0);
        }
;
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
;
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_iand(i64 opc,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 tx;
    if (!!(cc_libmcl$issimple(b))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else if (!!(cc_libmcl$issimple(a))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
;
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_preincrx(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,i64 reg) {
        i64 opc;
        i64 size;
        struct cc_libmcl$opndrec *  ptropnd;
        struct cc_libmcl$opndrec *  result;
    ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
    opc = (i64)5;
    result = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg),cc_libmcl$getopndsize_u(p));
    if (((i64)(*result).size > (i64)(*ptropnd).size)) {
        cc_support$gerror((byte*)"PREINCRX WIDENING NEEDED",0);
    }
;
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)result,(struct cc_libmcl$opndrec *)ptropnd);
    if (((cc_decls$ttbasetype[((i64)(*a).mode)] == (i64)16) && (cc_decls$ttsize[(cc_decls$tttarget[((i64)(*a).mode)])] != (i64)1))) {
        size = cc_decls$ttsize[(cc_decls$tttarget[((i64)(*a).mode)])];
        if (((i64)(*p).tag == (i64)73)) {
            opc = (i64)21;
        }
        else {
            opc = (i64)22;
        }
;
        cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)result,(struct cc_libmcl$opndrec *)cc_libmcl$genint(size,(i64)4));
    }
    else {
        cc_libmcl$genmc((((i64)(*p).tag == (i64)73) ? (i64)38 : (i64)39),(struct cc_libmcl$opndrec *)result,0);
    }
;
    cc_blockmcl$storeopnd((struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)result);
    return (struct cc_libmcl$opndrec *)result;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_postincrx(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,i64 reg) {
        i64 opc;
        i64 size;
        struct cc_libmcl$opndrec *  ptropnd;
        struct cc_libmcl$opndrec *  result;
        struct cc_libmcl$opndrec *  rr1;
    result = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,cc_libmcl$getopndsize_u(p));
    ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,(reg + (i64)1));
    opc = (i64)5;
    if (((i64)(*result).size > (i64)(*ptropnd).size)) {
        cc_support$gerror((byte*)"POSTINCRX WIDENING NEEDED",0);
    }
;
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)(rr1 = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg) + (i64)1),cc_libmcl$getopndsize_u(p))),(struct cc_libmcl$opndrec *)ptropnd);
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)result,(struct cc_libmcl$opndrec *)rr1);
    if (((cc_decls$ttbasetype[((i64)(*a).mode)] == (i64)16) && (cc_decls$ttsize[(cc_decls$tttarget[((i64)(*a).mode)])] != (i64)1))) {
        size = cc_decls$ttsize[(cc_decls$tttarget[((i64)(*a).mode)])];
        if (((i64)(*p).tag == (i64)75)) {
            opc = (i64)21;
        }
        else {
            opc = (i64)22;
        }
;
        cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)rr1,(struct cc_libmcl$opndrec *)cc_libmcl$genint(size,(i64)4));
    }
    else {
        cc_libmcl$genmc((((i64)(*p).tag == (i64)75) ? (i64)38 : (i64)39),(struct cc_libmcl$opndrec *)rr1,0);
    }
;
    cc_blockmcl$storeopnd((struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)rr1);
    return (struct cc_libmcl$opndrec *)result;
}

static struct cc_libmcl$opndrec *cc_blockmcl$makeindexopnd(struct cc_decls$unitrec *a,struct cc_decls$unitrec *index,i64 scale,i64 size,i64 offset,i64 reg) {
        i64 mulfactor;
        i64 tx;
        i64 reg2;
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  ix;
        struct cc_libmcl$opndrec *  m;
        struct cc_decls$strec *  d;
    if ((!!(index) && ((i64)(*index).tag == (i64)1))) {
        offset += ((*index).value * scale);
        index = 0;
    }
;
    if (!!(index)) {
        if ((scale==(i64)1) || (scale==(i64)2) || (scale==(i64)4) || (scale==(i64)8)) {
            mulfactor = (i64)1;
        }
        else {
            mulfactor = scale;
            scale = (i64)1;
        }
;
    }
;
    if (((i64)(*a).tag == (i64)3)) {
        d = (struct cc_decls$strec *)(*a).def;
        if ((((i64)(*d).nameid == (i64)9) && !!(cc_lib$isstructunion((i64)(*d).mode)))) {
            goto L83 ;
;
        }
;
        if (!!(index)) {
            if ((mulfactor == (i64)1)) {
                ix = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(index,reg,(i64)0);
                m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)0,(i64)(*ix).reg,scale,offset,size,(i64)0,(struct cc_decls$strec *)d);
            }
            else {
                cc_blockmcl$loadexpr(index,reg,(i64)0);
                cc_blockmcl$mulreg(reg,mulfactor);
                m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)0,reg,scale,offset,size,(i64)0,(struct cc_decls$strec *)d);
            }
;
        }
        else {
            m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)0,(i64)0,(i64)1,offset,size,(i64)0,(struct cc_decls$strec *)d);
        }
;
    }
    else {
        //mx2:
L83 :;
;
        if (!!(index)) {
            if (!!(cc_libmcl$issimple(a))) {
                if ((mulfactor == (i64)1)) {
                    ix = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(index,reg,(i64)0);
                    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,(reg + (i64)1),(i64)0);
                    m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)(*ax).reg,(i64)(*ix).reg,scale,offset,size,(i64)0,0);
                }
                else {
                    cc_blockmcl$loadexpr(index,reg,(i64)0);
                    cc_blockmcl$mulreg(reg,mulfactor);
                    cc_blockmcl$loadexpr(a,(reg + (i64)1),(i64)0);
                    m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex((reg + (i64)1),reg,scale,offset,size,(i64)0,0);
                }
;
            }
            else if (!!(cc_libmcl$issimple(index))) {
                cc_blockmcl$loadexpr(a,reg,(i64)0);
                cc_blockmcl$loadexpr(index,(reg + (i64)1),(i64)0);
                cc_blockmcl$mulreg((reg + (i64)1),mulfactor);
                m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex(reg,(reg + (i64)1),scale,offset,size,(i64)0,0);
            }
            else {
                tx = cc_blockmcl$saveexpr(a,reg);
                ix = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(index,reg,(i64)0);
                cc_blockmcl$mulreg(reg,mulfactor);
                ax = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,(reg2 = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ix,reg)));
                m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex(reg2,reg,scale,offset,size,(i64)0,0);
            }
;
        }
        else {
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
            m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)(*ax).reg,(i64)0,scale,offset,size,(i64)0,0);
        }
;
    }
;
    return (struct cc_libmcl$opndrec *)m;
}

static void cc_blockmcl$mulreg(i64 reg,i64 x) {
        i64 n;
    if ((x > (i64)1)) {
        if (!!((n = cc_libmcl$ispoweroftwo(x)))) {
            cc_libmcl$genmc((i64)33,(struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint(n,(i64)4));
        }
        else {
            cc_libmcl$genmc((i64)23,(struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint(x,(i64)4));
        }
;
    }
;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_ptr(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,i64 reg,i64 am) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
    if ((am == (i64)0)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
    }
;
    if ((cc_decls$ttbasetype[((i64)(*p).mode)] == (i64)17)) {
        cc_support$gerror((byte*)"deref/proc",0);
    }
;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$evalptr(a,reg);
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)54) || ($temp==(i64)55)) {
        if (((i64)(*ax).mode != (i64)1)) {
            ax = (struct cc_libmcl$opndrec *)cc_libmcl$applysize((struct cc_libmcl$opndrec *)ax,cc_decls$ttsize[((i64)(*p).mode)]);
            return (struct cc_libmcl$opndrec *)ax;
        }
;
    }
    else if (($temp==(i64)56)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr((struct cc_decls$unitrec *)(*a).a,reg,am);
    }
    };
    if (((i64)(*ax).mode != (i64)1)) {
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)(bx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8)),(struct cc_libmcl$opndrec *)ax);
        ax = bx;
    }
;
    ax = (struct cc_libmcl$opndrec *)cc_libmcl$makeindirect((struct cc_libmcl$opndrec *)ax,cc_decls$ttsize[((i64)(*p).mode)]);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_addptr(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg,i64 am) {
        i64 size;
        i64 scale;
        i64 mulfactor;
        i64 reg1;
        i64 tx;
        i64 offset;
        struct cc_libmcl$opndrec *  m;
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        struct cc_libmcl$opndrec *  rx;
        struct cc_decls$unitrec *  pname;
    size = (scale = cc_decls$ttsize[(cc_decls$tttarget[((i64)(*a).mode)])]);
    if (((i64)(*p).ptrscale == (i64)0)) {
        scale = (i64)1;
    }
;
    offset = (i64)0;
    if (((i64)(*b).tag == (i64)1)) {
        (*b).value *= scale;
        offset = (*b).value;
        scale = (i64)1;
    }
;
    if ((scale==(i64)2) || (scale==(i64)4) || (scale==(i64)8)) {
        mulfactor = (i64)1;
    }
    else {
        mulfactor = scale;
        scale = (i64)1;
    }
;
    reg1 = (reg + (i64)1);
    if (((i64)(*b).tag == (i64)1)) {
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)56)) {
            pname = (struct cc_decls$unitrec *)(*a).a;
            if (((i64)(*pname).tag != (i64)3)) {
                goto L84 ;
;
            }
;
            m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)0,(i64)0,(i64)1,offset,size,(i64)0,(struct cc_decls$strec *)(*pname).def);
        }
        else {
            //other:
L84 :;
;
            cc_blockmcl$loadexpr(a,reg,(i64)0);
            m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex(reg,(i64)0,scale,(*b).value,size,(i64)0,0);
        }
        };
    }
    else if ((((i64)(*a).tag == (i64)56) && ((i64)(*(*a).a).tag == (i64)3))) {
        pname = (struct cc_decls$unitrec *)(*a).a;
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        cc_blockmcl$mulreg((i64)(*bx).reg,mulfactor);
        bx = (struct cc_libmcl$opndrec *)cc_libmcl$makeindirect((struct cc_libmcl$opndrec *)bx,size);
        (*bx).regix = (i64)(*bx).reg;
        (*bx).reg = (i64)0;
        (*bx).scale = scale;
        (*bx).def = (struct cc_decls$strec *)(*pname).def;
        if (!!(cc_libmcl$isframe((struct cc_decls$strec *)(*pname).def))) {
            (*bx).reg = (i64)15;
        }
;
        m = bx;
    }
    else if (!!(cc_libmcl$issimple(b))) {
        cc_blockmcl$loadexpr(a,reg,(i64)0);
        cc_blockmcl$loadexpr(b,reg1,(i64)0);
        cc_blockmcl$mulreg(reg1,mulfactor);
        m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex(reg,reg1,scale,(i64)0,size,(i64)0,0);
    }
    else if (!!(cc_libmcl$issimple(a))) {
        cc_blockmcl$loadexpr(b,reg,(i64)0);
        cc_blockmcl$mulreg(reg,mulfactor);
        cc_blockmcl$loadexpr(a,reg1,(i64)0);
        m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex(reg1,reg,scale,(i64)0,size,(i64)0,0);
    }
    else {
        //cxcx:
L85 :;
;
        tx = cc_blockmcl$saveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        cc_blockmcl$mulreg((i64)(*bx).reg,mulfactor);
        m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex(reg,(i64)(*bx).reg,scale,(i64)0,size,(i64)0,0);
    }
;
    if ((am==(i64)1)) {
        cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)(rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8)),(struct cc_libmcl$opndrec *)m);
        return (struct cc_libmcl$opndrec *)rx;
    }
;
    return (struct cc_libmcl$opndrec *)m;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_subptr(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg,i64 am) {
        i64 size;
        i64 scale;
        i64 mulfactor;
        i64 reg1;
        i64 tx;
        i64 offset;
        struct cc_libmcl$opndrec *  m;
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        struct cc_libmcl$opndrec *  rx;
    size = (scale = cc_decls$ttsize[(cc_decls$tttarget[((i64)(*a).mode)])]);
    if ((cc_decls$ttbasetype[((i64)(*b).mode)] == (i64)16)) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$dx_sub(a,b,reg);
        cc_blockmcl$divreg((i64)(*ax).reg,scale);
        return (struct cc_libmcl$opndrec *)ax;
    }
;
    offset = (i64)0;
    if (((i64)(*b).tag == (i64)1)) {
        (*b).value = ((*b).value * scale);
        offset = -((*b).value);
        scale = (i64)1;
    }
;
    mulfactor = scale;
    scale = (i64)1;
    reg1 = (reg + (i64)1);
    if ((((i64)(*a).tag == (i64)56) && ((i64)(*(*a).a).tag == (i64)3))) {
        a = (struct cc_decls$unitrec *)(*a).a;
    }
;
    if (((i64)(*b).tag == (i64)1)) {
        cc_blockmcl$loadexpr(a,reg,(i64)0);
        m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex(reg,(i64)0,scale,offset,size,(i64)0,0);
        if ((am == (i64)2)) {
            return (struct cc_libmcl$opndrec *)m;
        }
;
        cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)(rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8)),(struct cc_libmcl$opndrec *)m);
        return (struct cc_libmcl$opndrec *)rx;
    }
    else if (!!(cc_libmcl$issimple(b))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg1,(i64)0);
        cc_blockmcl$mulreg(reg1,mulfactor);
    }
    else if (!!(cc_libmcl$issimple(a))) {
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        cc_blockmcl$mulreg(reg,mulfactor);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg1,(i64)0);
    }
    else {
        //cxcx:
L86 :;
;
        tx = cc_blockmcl$saveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        cc_blockmcl$mulreg((i64)(*bx).reg,mulfactor);
    }
;
    m = (struct cc_libmcl$opndrec *)cc_libmcl$genindex(reg,(i64)(*bx).reg,scale,(i64)0,size,(i64)0,0);
    cc_libmcl$genmc((i64)22,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_convert(struct cc_decls$unitrec *a,i64 t,i64 opc,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  rx;
        i64 ssize;
        i64 tsize;
    ssize = cc_decls$ttsize[((i64)(*a).mode)];
    tsize = cc_decls$ttsize[(t)];
    if ((opc==(i64)7) || (opc==(i64)8) || (opc==(i64)10) || (opc==(i64)9)) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$fevalexpr(a,reg);
    }
    else {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,reg);
    }
;
    if ((opc==(i64)1)) {
        //dosoft:
L87 :;
;
        return (struct cc_libmcl$opndrec *)ax;
    }
    else if ((opc==(i64)2)) {
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,tsize);
        if ((tsize < ssize)) {
            cc_libmcl$genmc((i64)14,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
        }
        else if ((tsize > ssize)) {
            cc_libmcl$genmc((i64)12,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
        }
        else {
            return (struct cc_libmcl$opndrec *)ax;
        }
;
    }
    else if ((opc==(i64)3) || (opc==(i64)4)) {
        if (((i64)(*ax).mode == (i64)2)) {
            (*ax).size = tsize;
            return (struct cc_libmcl$opndrec *)ax;
        }
;
        if ((ssize == tsize)) {
            return (struct cc_libmcl$opndrec *)ax;
        }
;
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,tsize);
        cc_libmcl$genmc(((opc == (i64)3) ? (i64)11 : (i64)12),(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
    }
    else if ((opc==(i64)5) || (opc==(i64)6)) {
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(reg,tsize);
        cc_libmcl$genmc(((opc == (i64)5) ? (i64)52 : (i64)51),(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
    }
    else if ((opc==(i64)7) || (opc==(i64)8)) {
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,tsize);
        cc_libmcl$genmc(((opc == (i64)7) ? (i64)50 : (i64)49),(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
    }
    else if ((opc==(i64)10) || (opc==(i64)9)) {
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(reg,tsize);
        cc_libmcl$genmc(((opc == (i64)10) ? (i64)54 : (i64)53),(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
    }
    else if ((opc==(i64)11) || (opc==(i64)12)) {
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,tsize);
        cc_libmcl$genmc((i64)14,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)ax);
    }
    else {
        cc_support$gerror_s((byte*)"Convert op not implem: %s",cc_tables$convnames[(opc)],0);
    }
;
    return (struct cc_libmcl$opndrec *)rx;
}

static void cc_blockmcl$do_decl(struct cc_decls$strec *d) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_decls$unitrec *  a;
        struct cc_decls$unitrec *  dest;
        u8 str[256];
        i64 nbytes;
    a = (struct cc_decls$unitrec *)(*d).code;
    if (((i64)(*a).tag != (i64)29)) {
        if (((cc_decls$ttbasetype[((i64)(*d).mode)] == (i64)19) && ((i64)(*a).tag == (i64)1))) {
            goto L88 ;
;
        }
;
        if ((cc_libmcl$gettypecat(a) == (i64)82)) {
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(a,(i64)1);
            cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)cc_libmcl$genmem_d((struct cc_decls$strec *)d,(i64)0),(struct cc_libmcl$opndrec *)ax);
        }
        else if (((i64)(*a).tag != (i64)1)) {
                        {i64 $temp = cc_decls$ttsize[((i64)(*a).mode)];
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4) || ($temp==(i64)8)) {
                ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,(i64)1,(i64)0);
                cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genmem_d((struct cc_decls$strec *)d,(i64)0),(struct cc_libmcl$opndrec *)ax);
            }
            else {
                dest = (struct cc_decls$unitrec *)cc_lib$createname((struct cc_decls$strec *)d);
                (*dest).mode = (i64)(*d).mode;
                cc_blockmcl$do_assignblock(dest,a,(i64)1);
            }
            };
        }
        else {
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genmem_d((struct cc_decls$strec *)d,(i64)0),(struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,(i64)1));
        }
;
        return;
    }
;
    //copyl:
L88 :;
;
    nbytes = cc_decls$ttsize[((i64)(*d).mode)];
    cc_libmcl$pushstack((i64)32);
    cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)11,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genmem_d((struct cc_decls$strec *)d,(i64)0));
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"`$#.#.#");
    msysc$m_print_str((*cc_decls$currproc).name,NULL);
    msysc$m_print_str((*d).name,NULL);
    msysc$m_print_i64((i64)(*d).blockno,NULL);
    msysc$m_print_end();
    ;
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)12,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genname((u8 *)str));
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)13,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint(nbytes,(i64)4));
    cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"memcpy*"),0);
    cc_libmcl$popstack((i64)32);
}

static struct cc_libmcl$opndrec *cc_blockmcl$do_assignblock(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        struct cc_libmcl$opndrec *  rx;
        struct cc_libmcl$opndrec *  rs;
        struct cc_libmcl$opndrec *  rd;
        struct cc_libmcl$opndrec *  rcount;
        struct cc_libmcl$opndrec *  bx2;
        struct cc_libmcl$opndrec *  rsa;
        struct cc_libmcl$opndrec *  rda;
        i64 rev;
        i64 workreg;
        i64 nwords;
        i64 lab;
        i64 regcount;
        i64 regsource;
        i64 regdest;
        i64 offset;
        i64 n;
        i64 oddbytes;
        i64 reg;
        i64 $av_1;
    reg = (!!(regx) ? regx : (i64)1);
    rev = (i64)0;
    if (!!(cc_libmcl$issimple(b))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else if (!!(cc_libmcl$issimple(a))) {
        rev = (i64)1;
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(b,reg);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
    else {
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(b,reg);
        if (((i64)(*bx).mode != (i64)1)) {
            cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)(bx2 = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8)),(struct cc_libmcl$opndrec *)bx);
        }
        else {
            bx2 = bx;
        }
;
        cc_libmcl$genmc((i64)6,(struct cc_libmcl$opndrec *)bx2,0);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        cc_libmcl$genmc((i64)7,(struct cc_libmcl$opndrec *)(bx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg),(i64)8)),0);
        bx = (struct cc_libmcl$opndrec *)cc_libmcl$genireg((i64)(*bx).reg,(i64)4);
    }
;
    if (((i64)(*ax).mode == (i64)1)) {
        ax = (struct cc_libmcl$opndrec *)cc_libmcl$genireg((i64)(*ax).reg,(i64)4);
    }
;
    if (((i64)(*bx).mode == (i64)1)) {
        bx = (struct cc_libmcl$opndrec *)cc_libmcl$genireg((i64)(*bx).reg,(i64)4);
    }
;
    if (!!(rev)) {
        {struct cc_libmcl$opndrec *  temp = ax; ax = bx; bx = temp; };
    }
;
    if (((cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,(i64)0) > (i64)5) || (cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)bx,(i64)0) > (i64)5))) {
        cc_support$gerror((byte*)"ASSIGNBLOCK/REG",0);
    }
;
    workreg = (i64)5;
    n = cc_decls$ttsize[((i64)(*a).mode)];
    oddbytes = (n % (i64)8);
    n -= oddbytes;
    nwords = (n / (i64)8);
    if (((i64)1<=nwords && nwords<=(i64)4)) {
        offset = (i64)0;
        ax = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)ax,(i64)8);
        bx = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)bx,(i64)8);
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(workreg,(i64)8);
        $av_1 = nwords;
        while ($av_1-- > 0) {
L89 :;
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)bx,offset,(i64)0));
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)ax,offset,(i64)0),(struct cc_libmcl$opndrec *)rx);
            offset += (i64)8;
L90 :;
        }
L91 :;
        ;
        rs = bx;
        rd = ax;
    }
    else if ((nwords != (i64)0)) {
        lab = ++(cc_decls$labelno);
        regcount = (workreg + (i64)1);
        regsource = (regcount + (i64)1);
        regdest = (regsource + (i64)1);
        cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)(rsa = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(regsource,(i64)8)),(struct cc_libmcl$opndrec *)bx);
        cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)(rda = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(regdest,(i64)8)),(struct cc_libmcl$opndrec *)ax);
        rs = (struct cc_libmcl$opndrec *)cc_libmcl$genireg(regsource,(i64)8);
        rd = (struct cc_libmcl$opndrec *)cc_libmcl$genireg(regdest,(i64)8);
        rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(workreg,(i64)8);
        rcount = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(regcount,(i64)4);
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rcount,(struct cc_libmcl$opndrec *)cc_libmcl$genint(nwords,(i64)4));
        cc_libmcl$genmc((i64)3,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(lab,(i64)0),0);
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)rs);
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rd,(struct cc_libmcl$opndrec *)rx);
        cc_libmcl$genmc((i64)21,(struct cc_libmcl$opndrec *)rsa,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)8,(i64)4));
        cc_libmcl$genmc((i64)21,(struct cc_libmcl$opndrec *)rda,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)8,(i64)4));
        cc_libmcl$genmc((i64)39,(struct cc_libmcl$opndrec *)rcount,0);
        cc_libmcl$genmc_cond((i64)19,(i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(lab,(i64)0),0);
        offset = (i64)0;
    }
    else {
        rd = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)ax,(i64)8);
        rs = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)bx,(i64)8);
        offset = (i64)0;
    }
;
    if (!!(oddbytes)) {
        n = oddbytes;
        if ((n >= (i64)4)) {
            rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(workreg,(i64)4);
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)rs,offset,(i64)0));
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)rd,offset,(i64)0),(struct cc_libmcl$opndrec *)rx);
            n -= (i64)4;
            offset += (i64)4;
        }
;
        if ((n >= (i64)2)) {
            rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(workreg,(i64)2);
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)rs,offset,(i64)0));
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)rd,offset,(i64)0),(struct cc_libmcl$opndrec *)rx);
            n -= (i64)2;
            offset += (i64)2;
        }
;
        if ((n == (i64)1)) {
            rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(workreg,(i64)1);
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)rs,offset,(i64)0));
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)rd,offset,(i64)0),(struct cc_libmcl$opndrec *)rx);
        }
;
    }
;
    if (!!(regx)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
    }
;
    return (struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)4);
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_widen(struct cc_decls$unitrec *a,i64 m,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 opc;
    opc = ((cc_libmcl$gettypecat(a) == (i64)73) ? (i64)11 : (i64)12);
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,reg);
    if ((cc_decls$ttsize[(m)] == (i64)(*ax).size)) {
        return (struct cc_libmcl$opndrec *)ax;
    }
;
    bx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,cc_decls$ttsize[(m)]);
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)bx,(struct cc_libmcl$opndrec *)ax);
    return (struct cc_libmcl$opndrec *)bx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_neg(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
    if ((cc_libmcl$gettypecat(a) == (i64)82)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_fneg(a,reg);
    }
;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
    cc_libmcl$genmc((i64)36,(struct cc_libmcl$opndrec *)ax,0);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_fneg(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  fx;
    fx = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(a,reg);
    cc_libmcl$genmc((i64)41,(struct cc_libmcl$opndrec *)fx,0);
    return (struct cc_libmcl$opndrec *)fx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_inot(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
    cc_libmcl$genmc((i64)37,(struct cc_libmcl$opndrec *)ax,0);
    return (struct cc_libmcl$opndrec *)ax;
}

static void cc_blockmcl$do_switch(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b) {
        i64 labeltable[500];
        i64 valuetable[500];
        byte flags[500];
        i64 defaultlabel;
        i64 breakswlabel;
        i64 switchlabel;
        i64 lower;
        i64 upper;
        i64 length;
        i64 value;
        i64 ncases;
        byte serialsw;
        i64 i;
        i64 index;
        struct cc_decls$caserec *  pcase;
        struct cc_libmcl$opndrec *  ax;
        i64 (*old_labeltable)[];
        i64 (*old_valuetable)[];
        i64 old_ncases;
        i64 old_lower;
        byte old_defaultseen;
        i64 old_defaultlabel;
        i64 old_breaklabel;
    pcase = (struct cc_decls$caserec *)(*p).nextcase;
    ncases = (length = (i64)0);
    L92 :;
    while (!!(pcase)) {
        ++(ncases);
        if ((ncases > (i64)500)) {
            cc_support$gerror((byte*)"Too many cases on one switch",0);
        }
;
        valuetable[(ncases)-1] = (value = (*pcase).value);
        if ((ncases == (i64)1)) {
            lower = (upper = value);
        }
        else {
            lower = (lower<value?lower:value);
            upper = (upper>value?upper:value);
        }
;
        pcase = (struct cc_decls$caserec *)(*pcase).nextcase;
L93 :;
    }
L94 :;
    ;
    if (!!((*p).nextcase)) {
        length = ((upper - lower) + (i64)1);
    }
    else {
        length = (i64)0;
    }
;
    defaultlabel = cc_libmcl$createfwdlabel();
    breakswlabel = cc_libmcl$createfwdlabel();
    if ((length > (i64)500)) {
        serialsw = (i64)1;
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,(i64)1,(i64)0);
        for (i=(i64)1;i<=ncases;++i) {
L95 :;
            labeltable[(i)-1] = cc_libmcl$createfwdlabel();
            cc_libmcl$genmc((i64)32,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)cc_libmcl$genint(valuetable[(i)-1],(i64)4));
            cc_libmcl$genmc_cond((i64)19,(i64)4,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(labeltable[(i)-1],(i64)0),0);
L96 :;
        }
L97 :;
        ;
        cc_libmcl$genmc((i64)18,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(defaultlabel,(i64)0),0);
    }
    else if ((length == (i64)0)) {
        cc_libmcl$genmc((i64)18,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(defaultlabel,(i64)0),0);
    }
    else {
        serialsw = (i64)0;
        memset(&flags,(i32)(i64)0,(u64)length);
        for (i=(i64)1;i<=length;++i) {
L98 :;
            labeltable[(i)-1] = defaultlabel;
L99 :;
        }
L100 :;
        ;
        for (i=(i64)1;i<=ncases;++i) {
L101 :;
            value = valuetable[(i)-1];
            index = ((value - lower) + (i64)1);
            labeltable[(index)-1] = cc_libmcl$createfwdlabel();
            if (!!((i64)flags[(index)-1])) {
                cc_support$gerror_s((byte*)"Dupl case value: %d",(u8 *)value,0);
            }
;
            flags[(index)-1] = (i64)1;
L102 :;
        }
L103 :;
        ;
        switchlabel = cc_libmcl$createfwdlabel();
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,(i64)1,(i64)0);
        cc_libmcl$genmc((i64)22,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)cc_libmcl$genint(lower,(i64)4));
        cc_libmcl$genmc((i64)32,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)cc_libmcl$genint(length,(i64)4));
        cc_libmcl$genmc_cond((i64)19,(i64)3,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(defaultlabel,(i64)0),0);
        cc_libmcl$genmc((i64)18,(struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)0,(i64)1,(i64)8,(i64)0,(i64)0,switchlabel,0),0);
        cc_libmcl$setsegment((i64)73,(i64)8);
        cc_libmcl$definefwdlabel(switchlabel);
        for (i=(i64)1;i<=length;++i) {
L104 :;
            cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(labeltable[(i)-1],(i64)0),0);
L105 :;
        }
L106 :;
        ;
        cc_libmcl$setsegment((i64)67,(i64)1);
    }
;
    old_labeltable = cc_blockmcl$sw_labeltable;
    old_valuetable = cc_blockmcl$sw_valuetable;
    old_lower = cc_blockmcl$sw_lower;
    old_ncases = cc_blockmcl$sw_ncases;
    old_defaultseen = (i64)cc_blockmcl$sw_defaultseen;
    old_defaultlabel = cc_blockmcl$sw_defaultlabel;
    old_breaklabel = cc_blockmcl$sw_breaklabel;
    cc_blockmcl$sw_labeltable = (i64 (*)[])&labeltable;
    cc_blockmcl$sw_valuetable = (i64 (*)[])&valuetable;
    cc_blockmcl$sw_lower = lower;
    cc_blockmcl$sw_ncases = (!!((i64)serialsw) ? ncases : (i64)0);
    cc_blockmcl$sw_defaultseen = (i64)0;
    cc_blockmcl$sw_defaultlabel = defaultlabel;
    cc_blockmcl$sw_breaklabel = breakswlabel;
    cc_blockmcl$do_stmt(b);
    if (!(!!((i64)cc_blockmcl$sw_defaultseen))) {
        cc_libmcl$definefwdlabel(defaultlabel);
    }
;
    cc_libmcl$definefwdlabel(breakswlabel);
    cc_blockmcl$sw_labeltable = old_labeltable;
    cc_blockmcl$sw_valuetable = old_valuetable;
    cc_blockmcl$sw_lower = old_lower;
    cc_blockmcl$sw_ncases = old_ncases;
    cc_blockmcl$sw_defaultseen = (i64)old_defaultseen;
    cc_blockmcl$sw_defaultlabel = old_defaultlabel;
    cc_blockmcl$sw_breaklabel = old_breaklabel;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_rem(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 tx;
        i64 n;
        i64 opc;
        {i64 $temp = cc_libmcl$gettypecat(a);
if (($temp==(i64)73)) {
        opc = (i64)26;
    }
    else {
        opc = (i64)27;
        if ((((i64)(*b).tag == (i64)1) && !!(cc_lib$isintcc((i64)(*b).mode)))) {
            if (!!((n = cc_libmcl$ispoweroftwo((*b).value)))) {
                (*p).tag = (i64)49;
                (*b).value = ((*b).value - (i64)1);
                return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_iand((i64)28,a,b,reg);
            }
;
        }
;
    }
    };
    if ((reg != (i64)1)) {
        cc_support$gerror((byte*)"REM REG NOT ZERO",0);
    }
;
    if (!!(cc_libmcl$issimple(b))) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        if (((i64)(*b).tag == (i64)1)) {
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg),(i64)0);
        }
        else {
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
;
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
    }
;
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)bx,0);
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_ifx(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,struct cc_decls$unitrec *c,i64 reg) {
        struct cc_libmcl$opndrec *  bx;
        struct cc_libmcl$opndrec *  result;
        i64 lab1;
        i64 lab2;
        i64 isreal;
    lab1 = cc_libmcl$createfwdlabel();
    lab2 = cc_libmcl$createfwdlabel();
    isreal = (i64)(cc_libmcl$gettypecat(b) == (i64)82);
    cc_blockmcl$genjumpcond((i64)0,a,lab1,reg);
    if (!!(isreal)) {
        result = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(b,reg);
    }
    else {
        result = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
    }
;
    cc_libmcl$genjumpl(lab2);
    cc_libmcl$definefwdlabel(lab1);
    if (!!(isreal)) {
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(c,reg);
    }
    else {
        bx = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(c,reg,(i64)0);
    }
;
    cc_libmcl$definefwdlabel(lab2);
    return (struct cc_libmcl$opndrec *)result;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_addto(i64 opc,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx) {
        struct cc_libmcl$opndrec *  rhs;
        struct cc_libmcl$opndrec *  ptropnd;
        struct cc_libmcl$opndrec *  rr2;
        i64 reg;
        i64 tx;
    if ((cc_libmcl$gettypecat(b) == (i64)82)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_faddto(opc,a,b,regx);
    }
;
    reg = (!!(regx) ? regx : (i64)1);
    if (!!(cc_libmcl$issimple(b))) {
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        if ((((i64)(*b).tag == (i64)1) && ((i64)(*b).mode == (i64)4))) {
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg));
        }
        else {
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg),(i64)0);
        }
;
        rhs = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)rhs,(i64)(*ptropnd).size);
        cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)rhs);
    }
    else if (!!(cc_libmcl$issimple(a))) {
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg));
        rhs = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)rhs,(i64)(*ptropnd).size);
        cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)rhs);
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        rr2 = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg));
        rr2 = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)rr2,(i64)(*ptropnd).size);
        cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)rr2);
    }
;
    return (struct cc_libmcl$opndrec *)ptropnd;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_faddto(i64 opc,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx) {
        struct cc_libmcl$opndrec *  work;
        struct cc_libmcl$opndrec *  rhs;
        struct cc_libmcl$opndrec *  ptropnd;
        i64 reg;
        i64 tx;
    reg = (!!(regx) ? regx : (i64)1);
    if (!!(cc_libmcl$issimple(b))) {
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$fevalexpr(b,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg);
    }
    else if (!!(cc_libmcl$issimple(a))) {
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$fevalexpr(b,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$frestoreexpr(tx,reg);
        ++(reg);
    }
;
    work = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg(reg,cc_libmcl$getopndsize_u(b));
    cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)work,(struct cc_libmcl$opndrec *)ptropnd);
    if ((opc==(i64)21)) {
        opc = (i64)44;
    }
    else if ((opc==(i64)22)) {
        opc = (i64)45;
    }
    else if ((opc==(i64)23)) {
        opc = (i64)46;
    }
    else if ((opc==(i64)24)) {
        opc = (i64)47;
    }
;
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)work,(struct cc_libmcl$opndrec *)rhs);
    cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)work);
    return (struct cc_libmcl$opndrec *)ptropnd;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_eq(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        struct cc_libmcl$opndrec *  rx;
        struct cc_libmcl$opndrec *  rxb;
        i64 mclcond;
        i64 tx;
    mclcond = cc_libmcl$getmclcond((i64)(*p).tag,(i64)(*a).mode);
    if ((mclcond==(i64)20) || (mclcond==(i64)21) || (mclcond==(i64)16) || (mclcond==(i64)17) || (mclcond==(i64)18) || (mclcond==(i64)19)) {
        if (!!(cc_libmcl$issimple(b))) {
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(a,reg);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$fevalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
        else if (!!(cc_libmcl$issimple(a))) {
            mclcond = cc_blockmcl$reversemclcond(mclcond);
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(b,reg);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$fevalexpr(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
        else {
            tx = cc_blockmcl$saveexpr(b,reg);
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(a,reg);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$frestoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
;
        cc_libmcl$genmc((i64)48,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
    else {
        if (!!(cc_libmcl$issimple(b))) {
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
        else if (!!(cc_libmcl$issimple(a))) {
            mclcond = cc_blockmcl$reversemclcond(mclcond);
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,reg);
        }
        else {
            tx = cc_blockmcl$saveexpr(b,reg);
            ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
            bx = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ax,reg));
        }
;
        cc_libmcl$genmc((i64)32,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
    }
;
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)4);
    rxb = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)1);
    cc_libmcl$genmc_cond((i64)40,mclcond,(struct cc_libmcl$opndrec *)rxb,0);
    cc_libmcl$genmc((i64)12,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)rxb);
    return (struct cc_libmcl$opndrec *)rx;
}

static void cc_blockmcl$do_exprlist(struct cc_decls$unitrec *a) {
    L107 :;
    while (!!(a)) {
        cc_blockmcl$do_stmt(a);
        a = (struct cc_decls$unitrec *)(*a).nextunit;
L108 :;
    }
L109 :;
    ;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_exprlist(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
    L110 :;
    while (!!(a)) {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$dx_expr(a,reg,(i64)1);
        a = (struct cc_decls$unitrec *)(*a).nextunit;
L111 :;
    }
L112 :;
    ;
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_shlto(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx) {
        struct cc_libmcl$opndrec *  rhs;
        struct cc_libmcl$opndrec *  ptropnd;
        struct cc_libmcl$opndrec *  rr2;
        i64 reg;
        i64 tx;
        i64 opc;
    if (((i64)(*p).tag == (i64)70)) {
        opc = (i64)33;
    }
    else {
                {i64 $temp = cc_libmcl$gettypecat(p);
if (($temp==(i64)73)) {
            opc = (i64)34;
        }
        else {
            opc = (i64)35;
        }
        };
    }
;
    reg = (!!(regx) ? regx : (i64)1);
    if (!!(cc_libmcl$issimple(b))) {
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        if ((((i64)(*b).tag == (i64)1) && ((i64)(*b).mode == (i64)4))) {
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg));
        }
        else {
            rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg),(i64)0);
        }
;
        rhs = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)rhs,(i64)(*ptropnd).size);
        cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)rhs);
    }
    else if (!!(cc_libmcl$issimple(a))) {
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(b,reg,(i64)0);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg));
        rhs = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)rhs,(i64)(*ptropnd).size);
        cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)rhs);
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        rr2 = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg));
        rr2 = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)rr2,(i64)(*ptropnd).size);
        cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)rr2);
    }
;
    return (struct cc_libmcl$opndrec *)ptropnd;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_multo(struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx) {
        struct cc_libmcl$opndrec *  work;
        struct cc_libmcl$opndrec *  rhs;
        struct cc_libmcl$opndrec *  ptropnd;
        i64 reg;
        i64 tx;
        i64 sgned;
        {i64 $temp = cc_libmcl$gettypecat(b);
if (($temp==(i64)82)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_faddto((i64)23,a,b,regx);
    }
    else if (($temp==(i64)73)) {
        sgned = (i64)1;
    }
    else {
        sgned = (i64)0;
    }
    };
    reg = (!!(regx) ? regx : (i64)1);
    work = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,cc_libmcl$getopndsize_u(b));
    ++(reg);
    if (!!(cc_libmcl$issimple(b))) {
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg);
    }
    else if (!!(cc_libmcl$issimple(a))) {
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,reg);
        ++(reg);
    }
;
    cc_blockmcl$loadviaptr((struct cc_libmcl$opndrec *)work,(struct cc_libmcl$opndrec *)ptropnd,sgned);
    cc_libmcl$genmc((i64)23,(struct cc_libmcl$opndrec *)work,(struct cc_libmcl$opndrec *)rhs);
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)work,(i64)(*ptropnd).size));
    return (struct cc_libmcl$opndrec *)ptropnd;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_notl(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  rx;
        struct cc_libmcl$opndrec *  rxb;
    if (((i64)(*a).tag == (i64)27)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_istruel((struct cc_decls$unitrec *)(*a).a,reg);
    }
;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
    cc_libmcl$genmc((i64)28,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)ax);
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)4);
    rxb = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)1);
    cc_libmcl$genmc_cond((i64)40,(i64)4,(struct cc_libmcl$opndrec *)rxb,0);
    cc_libmcl$genmc((i64)12,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)rxb);
    return (struct cc_libmcl$opndrec *)rx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_istruel(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  rx;
        struct cc_libmcl$opndrec *  rxb;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
    cc_libmcl$genmc((i64)28,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)ax);
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)4);
    rxb = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)1);
    cc_libmcl$genmc_cond((i64)40,(i64)5,(struct cc_libmcl$opndrec *)rxb,0);
    cc_libmcl$genmc((i64)12,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)rxb);
    return (struct cc_libmcl$opndrec *)rx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_andorl(struct cc_decls$unitrec *p,i64 reg) {
        i64 lab1;
        i64 lab2;
        struct cc_libmcl$opndrec *  rx;
    lab1 = cc_libmcl$createfwdlabel();
    cc_blockmcl$genjumpcond((i64)0,p,lab1,(i64)1);
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)4);
    lab2 = cc_libmcl$createfwdlabel();
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)1,(i64)4));
    cc_libmcl$genjumpl(lab2);
    cc_libmcl$definefwdlabel(lab1);
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)4));
    cc_libmcl$definefwdlabel(lab2);
    return (struct cc_libmcl$opndrec *)rx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_sqrt(struct cc_decls$unitrec *a,i64 reg) {
        struct cc_libmcl$opndrec *  fx;
    fx = (struct cc_libmcl$opndrec *)cc_blockmcl$floadexpr(a,reg);
    cc_libmcl$genmc((i64)43,(struct cc_libmcl$opndrec *)fx,(struct cc_libmcl$opndrec *)fx);
    return (struct cc_libmcl$opndrec *)fx;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_scale(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        struct cc_libmcl$opndrec *  cx;
        i64 opc;
        i64 scale;
        i64 n;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$loadexpr(a,reg,(i64)0);
    scale = (i64)(*p).scale;
    opc = (i64)23;
    if ((scale < (i64)0)) {
        scale = -(scale);
        opc = (i64)24;
    }
;
    n = cc_libmcl$ispoweroftwo(scale);
    if ((n == (i64)0)) {
        bx = (struct cc_libmcl$opndrec *)cc_libmcl$genint(scale,(i64)4);
        if ((opc == (i64)23)) {
            cc_libmcl$genmc((i64)23,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
        }
        else {
            if (((i64)(*ax).reg != (i64)1)) {
                cc_support$gerror((byte*)"scale/div by non-power-of-two/not r0",0);
            }
;
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)(cx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((reg + (i64)1),(i64)(*ax).size)),(struct cc_libmcl$opndrec *)bx);
            cc_libmcl$genmc((i64)24,(struct cc_libmcl$opndrec *)cx,0);
        }
;
    }
    else {
        bx = (struct cc_libmcl$opndrec *)cc_libmcl$genint(n,(i64)4);
        if ((opc == (i64)23)) {
            cc_libmcl$genmc((i64)33,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
        }
        else {
            cc_libmcl$genmc((i64)34,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)bx);
        }
;
    }
;
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_divto(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 regx) {
        struct cc_libmcl$opndrec *  work;
        struct cc_libmcl$opndrec *  rhs;
        struct cc_libmcl$opndrec *  ptropnd;
        i64 reg;
        i64 tx;
        i64 opc;
        i64 sgned;
        {i64 $temp = cc_libmcl$gettypecat(b);
if (($temp==(i64)82)) {
        return (struct cc_libmcl$opndrec *)cc_blockmcl$dx_faddto((i64)24,a,b,regx);
    }
    else if (($temp==(i64)73)) {
        opc = (((i64)(*p).tag == (i64)65) ? (i64)24 : (i64)26);
        sgned = (i64)1;
    }
    else {
        opc = (((i64)(*p).tag == (i64)65) ? (i64)25 : (i64)27);
        sgned = (i64)0;
    }
    };
    reg = (!!(regx) ? regx : (i64)1);
    if ((reg != (i64)1)) {
        cc_support$gerror((byte*)"DIVTO: not R0",0);
    }
;
    work = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,cc_libmcl$getopndsize_u(b));
    ++(reg);
    if (!!(cc_libmcl$issimple(b))) {
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg);
    }
    else if (!!(cc_libmcl$issimple(a))) {
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(b,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)rhs,reg);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
    }
    else {
        tx = cc_blockmcl$saveexpr(b,reg);
        ptropnd = (struct cc_libmcl$opndrec *)cc_blockmcl$getlvalueopnd(a,reg);
        reg = cc_libmcl$getnextreg((struct cc_libmcl$opndrec *)ptropnd,reg);
        rhs = (struct cc_libmcl$opndrec *)cc_blockmcl$restoreexpr(tx,reg);
        ++(reg);
    }
;
    cc_blockmcl$loadviaptr((struct cc_libmcl$opndrec *)work,(struct cc_libmcl$opndrec *)ptropnd,sgned);
    cc_libmcl$genmc(opc,(struct cc_libmcl$opndrec *)rhs,0);
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)ptropnd,(struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)work,(i64)(*ptropnd).size));
    return (struct cc_libmcl$opndrec *)ptropnd;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_name(struct cc_decls$unitrec *p,i64 reg,i64 am) {
        struct cc_libmcl$opndrec *  ax;
        {i64 $temp = (i64)(*(*p).def).nameid;
if (($temp==(i64)6)) {
        return (struct cc_libmcl$opndrec *)cc_libmcl$genmemaddr_u(p);
    }
    };
    ax = (struct cc_libmcl$opndrec *)cc_libmcl$genmem_u(p,(i64)0);
    return (struct cc_libmcl$opndrec *)ax;
}

static void cc_blockmcl$divreg(i64 reg,i64 x) {
        struct cc_libmcl$opndrec *  rr2;
        i64 n;
    if ((x > (i64)1)) {
        if (!!((n = cc_libmcl$ispoweroftwo(x)))) {
            cc_libmcl$genmc((i64)34,(struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint(n,(i64)4));
        }
        else {
            if ((reg != (i64)1)) {
                cc_support$gerror((byte*)"DIVREG NOT R0",0);
            }
;
            cc_libmcl$genmc((i64)66,0,0);
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)(rr2 = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)3,(i64)8)),(struct cc_libmcl$opndrec *)cc_libmcl$genint(x,(i64)4));
            cc_libmcl$genmc((i64)24,(struct cc_libmcl$opndrec *)rr2,0);
        }
;
    }
;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_addrof(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,i64 reg,i64 am) {
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
    if (((i64)(*a).tag == (i64)3)) {
        ax = (struct cc_libmcl$opndrec *)cc_libmcl$genmem_u(a,(i64)0);
    }
    else {
        ax = (struct cc_libmcl$opndrec *)cc_blockmcl$evaladdr(a,reg);
    }
;
    if (((am != (i64)0) && ((i64)(*ax).mode != (i64)1))) {
        cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)(bx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(reg,(i64)8)),(struct cc_libmcl$opndrec *)ax);
        return (struct cc_libmcl$opndrec *)bx;
    }
;
    return (struct cc_libmcl$opndrec *)ax;
}

static struct cc_libmcl$opndrec *cc_blockmcl$dx_dot(struct cc_decls$unitrec *p,struct cc_decls$unitrec *a,struct cc_decls$unitrec *b,i64 reg,i64 am) {
        struct cc_libmcl$opndrec *  ax;
    ax = (struct cc_libmcl$opndrec *)cc_blockmcl$evalexpr(a,reg);
    ax = (struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)ax,(i64)(*p).offset,cc_decls$ttsize[((i64)(*p).mode)]);
    return (struct cc_libmcl$opndrec *)ax;
}

static void cc_blockmcl$loadviaptr(struct cc_libmcl$opndrec *w,struct cc_libmcl$opndrec *ptropnd,i64 sgned) {
    if (((i64)(*w).size <= (i64)(*ptropnd).size)) {
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)w,(struct cc_libmcl$opndrec *)ptropnd);
        return;
    }
;
    cc_libmcl$genmc((!!(sgned) ? (i64)11 : (i64)12),(struct cc_libmcl$opndrec *)w,(struct cc_libmcl$opndrec *)ptropnd);
}

// START
void cc_blockmcl$start(void) {

}

void cc_export$writemheader(u8 *infile) {
        u8 mfile[300];
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  e;
        struct cc_decls$mparamrec *  q;
        i64 i;
    strcpy(mfile,mlib$pcm_copyheapstring(mlib$changeext(infile,(((i64)cc_cli$fmheaders == (i64)77) ? (byte*)".m" : (byte*)".q"))));
    mlib$gs_init((struct mlib$strbuffer *)cc_export$mm);
    cc_export$mmstr((byte*)"importdll $");
    cc_export$mmstr(mlib$extractbasefile(infile));
    cc_export$mmstrln((byte*)" =");
    cc_decls$stmodule = (struct cc_decls$strec *)cc_decls$moduletable[((i64)1)].stmodule;
    d = (struct cc_decls$strec *)(*cc_decls$stmodule).deflist;
    L113 :;
    while (!!(d)) {
        if (!!(cc_headers$isheaderfile(cc_decls$sourcefilenames[(((i64)(*d).lineno >> (i64)24))]))) {
            d = (struct cc_decls$strec *)(*d).nextdef;
            goto L114 ;
        }
;
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)7)) {
            cc_export$mmstr((byte*)"    ");
            cc_export$mmmode((i64)(*d).mode,(i64)1);
            cc_export$mmstr((byte*)" ");
            cc_export$mmstr(cc_export$fixname((*d).name));
            if (!!((*d).code)) {
                cc_export$mmstr((byte*)" =");
                cc_export$mmstr((*cc_lib$strexpr((struct cc_decls$unitrec *)(*d).code)).strptr);
            }
;
            cc_export$mmline();
        }
        else if (($temp==(i64)6)) {
            cc_export$writefunction((struct cc_decls$strec *)d);
        }
        else if (($temp==(i64)5)) {
        }
        else if (($temp==(i64)11)) {
            cc_export$mmstr((byte*)"    const ");
            cc_export$mmleftstr(cc_export$fixname((*d).name),(i64)34);
            cc_export$mmstr((byte*)" = ");
            cc_export$mmint((i64)(*d).index);
            cc_export$mmline();
        }
        else if (($temp==(i64)1)) {
            cc_export$mmstr((byte*)"macro ");
            cc_export$mmstrln(cc_export$fixname((*d).name));
        }
        else if (($temp==(i64)13)) {
            cc_export$writerecord((i64)(*d).mode,(i64)82,(i64)1);
        }
        };
        d = (struct cc_decls$strec *)(*d).nextdef;
L114 :;
    }
L115 :;
    ;
    cc_export$mmstrln((byte*)"end");
    for (i=(i64)0;i<=cc_decls$hstmask;++i) {
L116 :;
        e = (struct cc_decls$strec *)(*cc_decls$hashtable)[(i)];
        if (((!!((*e).name) && ((i64)(*e).symbol == (i64)69)) && ((i64)(*e).nameid == (i64)1))) {
            if (!(!!(cc_headers$isheaderfile(cc_decls$sourcefilenames[(((i64)(*e).lineno >> (i64)24))])))) {
                if (!!((*e).tokenlist)) {
                    if ((((*(*e).tokenlist).nexttoken == 0) && ((i64)(*(*e).tokenlist).symbol == (i64)60 || (i64)(*(*e).tokenlist).symbol == (i64)61 || (i64)(*(*e).tokenlist).symbol == (i64)69))) {
                        cc_export$mmstr((byte*)"global const ");
                    }
                    else {
                        cc_export$mmstr((byte*)"global macro  ");
                    }
;
                    cc_export$mmstr((*e).name);
                    q = (struct cc_decls$mparamrec *)(*e).mparamlist;
                    if (!!(q)) {
                        cc_export$mmstr((byte*)"(");
                        L119 :;
                        while (!!(q)) {
                            cc_export$mmstr((*(*q).def).name);
                            if (!!((*q).nextmparam)) {
                                cc_export$mmstr((byte*)",");
                            }
;
                            q = (struct cc_decls$mparamrec *)(*q).nextmparam;
L120 :;
                        }
L121 :;
                        ;
                        cc_export$mmstr((byte*)")");
                    }
;
                    cc_export$mmstr((byte*)" = ");
                    cc_export$showmacroseq((struct cc_decls$tokenrec *)(*e).tokenlist);
                    cc_export$mmline();
                }
;
            }
;
        }
;
L117 :;
    }
L118 :;
    ;
    cc_decls$moduletable[((i64)1)].mhdrstr = (*cc_export$mm).strptr;
    if (!!(cc_decls$logdest)) {
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_str((byte*)"M HEADERS\n=========",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(cc_decls$logdev);
        msysc$m_print_str((*cc_export$mm).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Writing M Header:",NULL);
    msysc$m_print_str(mfile,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$writefile(mfile,(byte *)(*cc_export$mm).strptr,(i64)(*cc_export$mm).length);
}

static void cc_export$showmacroseq(struct cc_decls$tokenrec *tk) {
    L122 :;
    while (!!(tk)) {
        cc_lex$emittoken((struct cc_decls$tokenrec *)tk,(struct mlib$strbuffer *)cc_export$mm,(i64)0);
        tk = (struct cc_decls$tokenrec *)(*tk).nexttoken;
L123 :;
    }
L124 :;
    ;
}

static void cc_export$mmstr(u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)cc_export$mm,s);
}

static void cc_export$mmleftstr(u8 *s,i64 n) {
    mlib$gs_leftstr((struct mlib$strbuffer *)cc_export$mm,s,n,(i64)32);
}

static void cc_export$mmstrln(u8 *s) {
    mlib$gs_strln((struct mlib$strbuffer *)cc_export$mm,s);
}

static void cc_export$mmint(i64 a) {
        u8 str[32];
    msysc$getstrint(a,str);
    mlib$gs_str((struct mlib$strbuffer *)cc_export$mm,str);
}

static void cc_export$mmline(void) {
    mlib$gs_line((struct mlib$strbuffer *)cc_export$mm);
}

static void cc_export$writefunction(struct cc_decls$strec *d) {
        struct cc_decls$paramrec *  pm;
        i64 n;
        i64 isvar;
        i64 i;
    if (((i64)(*d).mode == (i64)1)) {
        cc_export$mmstr((byte*)"    proc ");
    }
    else {
        cc_export$mmstr((byte*)"    func ");
    }
;
    cc_export$mmstr((byte*)"\"");
    cc_export$mmstr((*d).name);
    cc_export$mmstr((byte*)"\"");
    cc_export$mmleftstr((byte*)" ",((i64)34 - strlen((*d).name)));
    cc_export$mmstr((byte*)"(");
    pm = (struct cc_decls$paramrec *)(*d).paramlist;
    n = (i64)(*pm).nparams;
    isvar = (i64)((i64)(*pm).flags == (i64)3);
    for (i=(i64)1;i<=n;++i) {
L125 :;
        cc_export$mmmode((i64)(*pm).mode,(i64)1);
        if (((i != n) || !!(isvar))) {
            cc_export$mmstr((byte*)",");
        }
;
        pm = (struct cc_decls$paramrec *)(*pm).nextparam;
L126 :;
    }
L127 :;
    ;
    if (!!(isvar)) {
        cc_export$mmstr((byte*)"...");
    }
;
    cc_export$mmstr((byte*)")");
    if (((i64)(*d).mode != (i64)1)) {
        cc_export$mmmode((i64)(*d).mode,(i64)1);
    }
;
    cc_export$mmline();
}

static void cc_export$mmmode(i64 m,i64 expand) {
        i64 t;
        i64 u;
    t = cc_decls$ttbasetype[(m)];
    if ((t==(i64)16)) {
        cc_export$mmstr((byte*)"ref ");
        u = cc_decls$tttarget[(m)];
        if ((cc_decls$ttbasetype[(u)] == (i64)17)) {
            cc_export$mmstr((byte*)"void");
        }
        else {
            cc_export$mmmode(cc_decls$tttarget[(m)],(i64)1);
        }
;
    }
    else if ((t==(i64)19)) {
        cc_export$mmstr((byte*)"[");
        if (!!(cc_decls$ttlength[(m)])) {
            cc_export$mmint(cc_decls$ttlength[(m)]);
        }
;
        cc_export$mmstr((byte*)"]");
        cc_export$mmmode(cc_decls$tttarget[(m)],(i64)1);
    }
    else if ((t==(i64)15)) {
        cc_export$mmstr((byte*)"int");
    }
    else if ((t==(i64)20) || (t==(i64)21)) {
        cc_export$mmstr(cc_export$fixname((*cc_decls$ttnamedef[(m)]).name));
    }
    else if ((t==(i64)17)) {
        cc_export$mmstr((byte*)"<PROC>");
    }
    else {
        cc_export$mmstr(cc_tables$stdtypemnames[(t)]);
    }
;
}

static void cc_export$writerecord(i64 m,i64 rectype,i64 level) {
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  e;
        i64 emode;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
    $av_1 = level;
    while ($av_1-- > 0) {
L128 :;
        cc_export$mmstr((byte*)"    ");
L129 :;
    }
L130 :;
    ;
    ++(level);
    d = (struct cc_decls$strec *)cc_decls$ttnamedef[(m)];
    if ((rectype == (i64)82)) {
        if (((i64)cc_cli$fmheaders == (i64)77)) {
            cc_export$mmstr((byte*)"record ");
            cc_export$mmstr(cc_export$fixname((*d).name));
            cc_export$mmstrln((byte*)" = $caligned");
        }
        else {
            cc_export$mmstr((byte*)"type ");
            cc_export$mmstr(cc_export$fixname((*d).name));
            cc_export$mmstrln((byte*)" = struct $caligned");
        }
;
    }
    else {
        cc_export$mmstrln(((rectype == (i64)83) ? (byte*)"struct" : (byte*)"union"));
    }
;
    e = (struct cc_decls$strec *)(*d).deflist;
    if ((e == 0)) {
        $av_2 = level;
        while ($av_2-- > 0) {
L131 :;
            cc_export$mmstr((byte*)"    ");
L132 :;
        }
L133 :;
        ;
        cc_export$mmstrln((byte*)"int dummy    !empty record");
    }
;
    L134 :;
    while (!!(e)) {
        emode = (i64)(*e).mode;
        $av_3 = level;
        while ($av_3-- > 0) {
L137 :;
            cc_export$mmstr((byte*)"    ");
L138 :;
        }
L139 :;
        ;
        if (!!(strchr((*e).name,(i32)'$'))) {
                        {i64 $temp = cc_decls$ttbasetype[(emode)];
if (($temp==(i64)21)) {
                cc_export$writerecord(emode,(i64)85,level);
            }
            else if (($temp==(i64)20)) {
                cc_export$writerecord(emode,(i64)83,level);
            }
            };
        }
        else {
            cc_export$mmmode((i64)(*e).mode,(i64)1);
            cc_export$mmstr((byte*)" ");
            cc_export$mmstrln(cc_export$fixname((*e).name));
        }
;
        e = (struct cc_decls$strec *)(*e).nextdef;
L135 :;
    }
L136 :;
    ;
    $av_4 = (level - (i64)1);
    while ($av_4-- > 0) {
L140 :;
        cc_export$mmstr((byte*)"    ");
L141 :;
    }
L142 :;
    ;
    cc_export$mmstrln((byte*)"end");
    cc_export$mmline();
}

static void cc_export$writefnptr(i64 m) {
        struct cc_decls$paramrec *  pm;
        i64 isvar;
        i64 n;
        i64 target;
        i64 i;
    target = cc_decls$tttarget[(m)];
    if ((target == (i64)1)) {
        cc_export$mmstr((byte*)"clang proc(");
    }
    else {
        cc_export$mmstr((byte*)"clang func(");
    }
;
    pm = (struct cc_decls$paramrec *)cc_decls$ttparams[(m)];
    n = (i64)(*pm).nparams;
    isvar = (i64)((i64)(*pm).flags == (i64)3);
    for (i=(i64)1;i<=n;++i) {
L143 :;
        cc_export$mmmode((i64)(*pm).mode,(i64)1);
        if (((i != n) || !!(isvar))) {
            cc_export$mmstr((byte*)",");
        }
;
        pm = (struct cc_decls$paramrec *)(*pm).nextparam;
L144 :;
    }
L145 :;
    ;
    if (!!(isvar)) {
        cc_export$mmstr((byte*)"...");
    }
;
    cc_export$mmstr((byte*)")");
    if ((target != (i64)1)) {
        cc_export$mmmode(target,(i64)1);
    }
;
}

static u8 *cc_export$fixname(u8 *name) {
        static u8 *  reservedwords[9] = {(byte*)"function",(byte*)"func",(byte*)"read",(byte*)"type",(byte*)"next",(byte*)"stop",(byte*)"callback",(byte*)"len",(byte*)"$dummy"};
        u8 str[128];
        i64 i;
    for (i=(i64)1;i<=(i64)9;++i) {
L146 :;
        if (!!(mlib$eqstring(reservedwords[(i)-1],name))) {
            strcpy(str,name);
            strcat(str,(byte*)"$");
            return mlib$pcm_copyheapstring(str);
        }
;
L147 :;
    }
L148 :;
    ;
    return name;
}

// START
void cc_export$start(void) {

}

i64 cc_genasm$codegen_writeasm(i64 moduleno,u8 *outfile) {
        struct cc_decls$strec *  d;
    mlib$gs_init((struct mlib$strbuffer *)cc_libmcl$dest);
    cc_genasm$inita64();
    cc_decls$stmodule = (struct cc_decls$strec *)cc_decls$moduletable[(moduleno)].stmodule;
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"!x64 output for ");
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(*cc_decls$stmodule).name);
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)".c");
    cc_genasm$writetoasm((struct cc_libmcl$mclrec *)cc_libmcl$modulecode);
    d = (struct cc_decls$strec *)(*cc_decls$stmodule).deflist;
    L149 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)6)) {
            cc_decls$currproc = (struct cc_decls$strec *)d;
            cc_genasm$writetoasm((struct cc_libmcl$mclrec *)(*d).mclcode);
        }
        };
        d = (struct cc_decls$strec *)(*d).nextdef;
L150 :;
    }
L151 :;
    ;
    cc_genasm$writefabs();
    cc_genasm$genstringtable();
    cc_genasm$genwstringtable();
    cc_genasm$genrealtable();
    cc_genasm$gendinttable();
    cc_genasm$terma64();
    if (!!(cc_decls$fastasm)) {
    }
    else {
        if (!!(cc_decls$fverbose)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Writing",NULL);
            msysc$m_print_str(outfile,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        mlib$writefile(outfile,(byte *)(*cc_libmcl$dest).strptr,(i64)(*cc_libmcl$dest).length);
    }
;
    cc_decls$moduletable[(moduleno)].asmstr = (*cc_libmcl$dest).strptr;
    return (i64)1;
}

void cc_genasm$inita64(void) {
    cc_genasm$initasmline();
    cc_genasm$stringtable = (u8 *(*)[])mlib$pcm_alloc((i64)8192);
    cc_genasm$stringlentable = (i64 (*)[])mlib$pcm_alloc((i64)8192);
    cc_genasm$realtable = (r64 (*)[])mlib$pcm_alloc((i64)128);
    cc_genasm$dinttable = (i64 (*)[])mlib$pcm_alloc((i64)128);
    cc_genasm$stringtablesize = (i64)1024;
    cc_genasm$realtablesize = (i64)16;
    cc_genasm$dinttablesize = (i64)16;
}

void cc_genasm$terma64(void) {
}

static void cc_genasm$writetoasm(struct cc_libmcl$mclrec *m) {
    L152 :;
    while (!!(m)) {
        cc_genasm$mcltoa64((struct cc_libmcl$mclrec *)m);
        m = (struct cc_libmcl$mclrec *)(*m).nextmcl;
L153 :;
    }
L154 :;
    ;
}

void cc_genasm$mcltoa64(struct cc_libmcl$mclrec *m) {
        i64 opcode;
        i64 cond;
        struct cc_libmcl$opndrec *  a;
        struct cc_libmcl$opndrec *  b;
    cc_genasm$currmcl = (struct cc_libmcl$mclrec *)m;
    opcode = (i64)(*m).opcode;
    cond = (i64)(*m).cond;
    a = (struct cc_libmcl$opndrec *)(*m).a;
    b = (struct cc_libmcl$opndrec *)(*m).b;
    switch (opcode) {
    case 1:;
        {
            cc_genasm$do_comment((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 2:;
        {
            cc_genasm$do_blank((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 68:;
        {
            cc_genasm$do_end((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 3:;
        {
            cc_genasm$do_label((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 4:;
        {
            cc_genasm$do_labelname((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 5:;
        {
            cc_genasm$do_mov((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 6:;
        {
            cc_genasm$do_push((struct cc_libmcl$opndrec *)a);
        }
        break;
    case 7:;
        {
            cc_genasm$do_pop((struct cc_libmcl$opndrec *)a);
        }
        break;
    case 8:;
        {
            cc_genasm$do_lea((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 9:;
        {
            cc_genasm$do_cmovcc((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b,cond);
        }
        break;
    case 10:;
        {
            cc_genasm$do_fmov((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 11:;
        {
            cc_genasm$do_changeop((i64)74);
        }
        break;
    case 12:;
        {
            cc_genasm$do_changeop((i64)73);
        }
        break;
    case 13:;
        {
            cc_genasm$do_inarrow((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 14:;
        {
            cc_genasm$do_unarrow((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 15:;
        {
            cc_genasm$do_call((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 16:;
        {
            cc_genasm$do_ret((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 17:;
        {
            cc_genasm$do_retn((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 18:;
        {
            cc_genasm$do_jmp((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 19:;
        {
            cc_genasm$do_jmpcc((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b,cond);
        }
        break;
    case 20:;
        {
            cc_genasm$do_exch((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 21:;
        {
            cc_genasm$do_add((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 22:;
        {
            cc_genasm$do_sub((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 23:;
        {
            cc_genasm$do_imul((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 24:;
    case 25:;
        {
            cc_genasm$do_idiv((struct cc_libmcl$opndrec *)a);
        }
        break;
    case 26:;
        {
            cc_genasm$do_irem((struct cc_libmcl$opndrec *)a);
        }
        break;
    case 27:;
        {
            cc_genasm$do_urem((struct cc_libmcl$opndrec *)a);
        }
        break;
    case 28:;
        {
            cc_genasm$do_and((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 29:;
        {
            cc_genasm$do_or((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 30:;
        {
            cc_genasm$do_xor((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 31:;
        {
            cc_genasm$do_test((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 32:;
        {
            cc_genasm$do_cmp((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 33:;
        {
            cc_genasm$do_shl((i64)33,(struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 34:;
        {
            cc_genasm$do_shl((i64)70,(struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 35:;
        {
            cc_genasm$do_shl((i64)71,(struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 36:;
        {
            cc_genasm$do_neg((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 37:;
        {
            cc_genasm$do_not((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 38:;
        {
            cc_genasm$do_inc((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 39:;
        {
            cc_genasm$do_dec((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 40:;
        {
            cc_genasm$do_setcc((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b,cond);
        }
        break;
    case 41:;
        {
            cc_genasm$do_fneg((struct cc_libmcl$opndrec *)a);
        }
        break;
    case 42:;
        {
            cc_genasm$do_fabs((struct cc_libmcl$opndrec *)a);
        }
        break;
    case 43:;
        {
            cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)95 : (i64)96));
        }
        break;
    case 44:;
        {
            if (((i64)(*b).mode == (i64)2)) {
                cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
            }
;
            cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)79 : (i64)80));
        }
        break;
    case 45:;
        {
            if (((i64)(*b).mode == (i64)2)) {
                cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
            }
;
            cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)81 : (i64)82));
        }
        break;
    case 46:;
        {
            if (((i64)(*b).mode == (i64)2)) {
                cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
            }
;
            cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)83 : (i64)84));
        }
        break;
    case 47:;
        {
            if (((i64)(*b).mode == (i64)2)) {
                cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
            }
;
            cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)85 : (i64)86));
        }
        break;
    case 48:;
        {
            if (((i64)(*b).mode == (i64)2)) {
                cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
            }
;
            cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)87 : (i64)88));
        }
        break;
    case 49:;
        {
            cc_genasm$do_ufix((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 50:;
        {
            cc_genasm$do_ifix((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 51:;
        {
            cc_genasm$do_ufloat((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 52:;
        {
            cc_genasm$do_ifloat((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 53:;
        {
            cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)0);
            cc_genasm$do_changeop((i64)91);
        }
        break;
    case 54:;
        {
            cc_genasm$do_changeop((i64)92);
        }
        break;
    case 55:;
        {
            cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)97 : (i64)99));
        }
        break;
    case 56:;
        {
            cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)98 : (i64)100));
        }
        break;
    case 58:;
        {
            cc_genasm$do_db((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 59:;
        {
            cc_genasm$do_dw((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 60:;
        {
            cc_genasm$do_dd((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 61:;
        {
            cc_genasm$do_dq((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 62:;
        {
            cc_genasm$do_defstr((*a).svalue,(i64)(*a).slength);
        }
        break;
    case 63:;
        {
            cc_genasm$do_defwstr((*a).wsvalue,(i64)(*a).wslength);
        }
        break;
    case 64:;
        {
            cc_genasm$do_align((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 65:;
        {
            cc_genasm$do_segment((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 67:;
        {
            cc_genasm$do_assem((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        }
        break;
    case 57:;
        {
            cc_genasm$convmcl();
        }
        break;
    default: {
        cc_support$gerror_s((byte*)"a64:UNKNOWN MCL OP: %s",cc_libmcl$mclnames[(opcode)-1],0);
    }
    } //SW
;
}

static void cc_genasm$passthru(i64 opc) {
    cc_genasm$strmclx((struct cc_libmcl$mclrec *)cc_genasm$currmcl);
    mlib$gs_strn((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$asmstart,(cc_genasm$asmptr - cc_genasm$asmstart));
}

static void cc_genasm$convmcl(void) {
    cc_genasm$strmclx((struct cc_libmcl$mclrec *)cc_genasm$currmcl);
    mlib$gs_strn((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$asmstart,(cc_genasm$asmptr - cc_genasm$asmstart));
}

static void cc_genasm$do_changeop(i64 opc) {
    (*cc_genasm$currmcl).opcode = opc;
    cc_genasm$convmcl();
}

static void cc_genasm$do_comment(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"! ");
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(*a).svalue);
}

static void cc_genasm$do_blank(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
}

static void cc_genasm$do_end(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)68);
}

static void cc_genasm$do_label(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)3);
}

static void cc_genasm$do_labelname(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)4);
}

static void cc_genasm$do_mov(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
        struct cc_libmcl$mclrec *  m;
    if ((((i64)(*a).mode == (i64)1) && ((i64)(*b).mode == (i64)2))) {
        cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)0);
    }
    else if ((((i64)(*a).mode == (i64)4) && ((i64)(*b).mode == (i64)2))) {
        if (((i64)(*b).size == (i64)8)) {
            cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)0);
            m = (struct cc_libmcl$mclrec *)cc_genasm$currmcl;
            cc_libmcl$initmcdest();
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)8),(struct cc_libmcl$opndrec *)b);
            cc_genasm$domclseq((struct cc_libmcl$mclrec *)cc_libmcl$mccode);
            cc_genasm$currmcl = (struct cc_libmcl$mclrec *)m;
            (*m).b = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)8);
        }
        else {
            if (((i64)(*a).size == (i64)8)) {
                cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)-1);
            }
            else {
                cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)0);
            }
;
        }
;
    }
;
    cc_genasm$convmcl();
}

static void cc_genasm$do_push(struct cc_libmcl$opndrec *a) {
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
        if (((i64)(*a).size != (i64)8)) {
            (*a).size = (i64)8;
        }
;
    }
    else if (($temp==(i64)2)) {
        cc_genasm$convertimm((struct cc_libmcl$opndrec *)a,(i64)1);
        if (((i64)(*a).size != (i64)8)) {
            (*a).size = (i64)8;
        }
;
    }
    else if (($temp==(i64)4)) {
        if (((i64)(*a).size != (i64)8)) {
            cc_libmcl$initmcdest();
                        {i64 $temp = (i64)(*a).size;
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4) || ($temp==(i64)8)) {
                cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)(*a).size),(struct cc_libmcl$opndrec *)a);
            }
            else {
                cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)8),(struct cc_libmcl$opndrec *)a);
            }
            };
            cc_libmcl$genmc((i64)6,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)8),0);
            cc_genasm$domclseq((struct cc_libmcl$mclrec *)cc_libmcl$mccode);
            return;
        }
;
    }
    else if (($temp==(i64)6)) {
        if (((i64)(*a).size == (i64)4)) {
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tmovd A13, ");
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$fgetregnamex((i64)(*a).reg));
        }
        else {
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tmovq D13, ");
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$fgetregnamex((i64)(*a).reg));
        }
;
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tpush D13");
        return;
    }
    };
    cc_genasm$convmcl();
}

static void cc_genasm$do_pop(struct cc_libmcl$opndrec *a) {
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)6)) {
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tpop D13");
        if (((i64)(*a).size == (i64)4)) {
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tmovd ");
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$fgetregnamex((i64)(*a).reg));
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)", A13");
        }
        else {
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tmovq ");
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$fgetregnamex((i64)(*a).reg));
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)", D13");
        }
;
        return;
    }
    };
    cc_genasm$convmcl();
}

static void cc_genasm$do_lea(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)8);
}

static void cc_genasm$do_cmovcc(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b,i64 cond) {
    cc_genasm$passthru((i64)9);
}

static void cc_genasm$do_fmov(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*b).mode == (i64)2)) {
        cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
    }
;
    cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)77 : (i64)78));
}

static void cc_genasm$do_iwiden(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)11);
}

static void cc_genasm$do_uwiden(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)12);
}

static void cc_genasm$do_inarrow(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)13);
}

static void cc_genasm$do_unarrow(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
        i64 asize;
    asize = (i64)(*a).size;
    if ((asize == (i64)4)) {
        (*cc_genasm$currmcl).b = (struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)b,(i64)4);
        cc_genasm$do_changeop((i64)5);
    }
    else {
        if ((((i64)(*b).mode == (i64)1) && ((i64)(*a).reg == (i64)(*b).reg))) {
        }
        else {
            cc_libmcl$initmcdest();
            cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$changeopndsize((struct cc_libmcl$opndrec *)a,(i64)(*b).size),(struct cc_libmcl$opndrec *)b);
            cc_genasm$domclseq((struct cc_libmcl$mclrec *)cc_libmcl$mccode);
        }
;
        cc_libmcl$initmcdest();
        if ((asize > (i64)2)) {
            cc_support$gerror((byte*)"unarrow 4->8?",0);
        }
;
        cc_libmcl$genmc((i64)28,(struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)cc_libmcl$genint((asize==1?(i64)255:(asize==2?(i64)65535:(i64)0)),(i64)4));
        cc_genasm$domclseq((struct cc_libmcl$mclrec *)cc_libmcl$mccode);
    }
;
}

static void cc_genasm$do_call(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)15);
}

static void cc_genasm$do_ret(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)16);
}

static void cc_genasm$do_retn(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)17);
}

static void cc_genasm$do_jmp(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)18);
}

static void cc_genasm$do_jmpcc(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b,i64 cond) {
    cc_genasm$passthru((i64)19);
}

static void cc_genasm$do_exch(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)20);
}

static void cc_genasm$do_add(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*b).mode == (i64)2)) {
        cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
    }
;
    cc_genasm$passthru((i64)21);
}

static void cc_genasm$do_sub(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*b).mode == (i64)2)) {
        cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
    }
;
    cc_genasm$passthru((i64)22);
}

static void cc_genasm$do_imul(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if ((!!(b) && !!((i64)(*b).mode))) {
        (*cc_genasm$currmcl).opcode = (i64)69;
    }
;
    if (((i64)(*b).mode == (i64)2)) {
        cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
    }
;
    cc_genasm$convmcl();
}

static void cc_genasm$do_idiv(struct cc_libmcl$opndrec *a) {
        struct cc_libmcl$opndrec *  dx;
        struct cc_libmcl$mclrec *  m;
    if (((i64)(*a).mode == (i64)2)) {
        m = (struct cc_libmcl$mclrec *)cc_genasm$currmcl;
        cc_libmcl$initmcdest();
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)(dx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)(*a).size)),(struct cc_libmcl$opndrec *)a);
        cc_genasm$domclseq((struct cc_libmcl$mclrec *)cc_libmcl$mccode);
        cc_genasm$currmcl = (struct cc_libmcl$mclrec *)m;
        (*cc_genasm$currmcl).a = (struct cc_libmcl$opndrec *)dx;
    }
;
    if (((i64)(*a).reg == (i64)12)) {
        cc_support$gerror((byte*)"asm/div/dividing by edx",0);
    }
;
    if (((i64)(*cc_genasm$currmcl).opcode == (i64)24)) {
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(((i64)(*a).size <= (i64)4) ? (byte*)"\tcdq" : (byte*)"\tcqo"));
        cc_genasm$convmcl();
    }
    else {
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\txor rdx,rdx");
        cc_genasm$do_changeop((i64)72);
    }
;
}

static void cc_genasm$do_irem(struct cc_libmcl$opndrec *a) {
    (*cc_genasm$currmcl).opcode = (i64)24;
    cc_genasm$do_idiv((struct cc_libmcl$opndrec *)a);
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\txchg rax,rdx");
}

static void cc_genasm$do_urem(struct cc_libmcl$opndrec *a) {
    (*cc_genasm$currmcl).opcode = (i64)25;
    cc_genasm$do_idiv((struct cc_libmcl$opndrec *)a);
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\txchg rax,rdx");
}

static void cc_genasm$do_and(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*b).mode == (i64)2)) {
        if (((i64)(*a).size <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295);
            cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)0);
        }
        else {
            cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
        }
;
    }
;
    cc_genasm$passthru((i64)28);
}

static void cc_genasm$do_or(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*b).mode == (i64)2)) {
        if (((i64)(*a).size <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295);
            cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)0);
        }
        else {
            cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
        }
;
    }
;
    cc_genasm$passthru((i64)29);
}

static void cc_genasm$do_xor(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*b).mode == (i64)2)) {
        if (((i64)(*a).size <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295);
            cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)0);
        }
        else {
            cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
        }
;
    }
;
    cc_genasm$passthru((i64)30);
}

static void cc_genasm$do_test(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*b).mode == (i64)2)) {
        cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
    }
;
    cc_genasm$passthru((i64)31);
}

static void cc_genasm$do_cmp(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*b).mode == (i64)2)) {
        cc_genasm$convertimm((struct cc_libmcl$opndrec *)b,(i64)1);
    }
;
    cc_genasm$passthru((i64)32);
}

static void cc_genasm$do_shl(i64 opc,struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
        i64 exchreg;
        i64 breg;
    (*cc_genasm$currmcl).opcode = opc;
        {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1)) {
        breg = (i64)(*b).reg;
        if ((((i64)(*a).mode == (i64)1) && ((i64)(*a).reg == (i64)11))) {
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\txchg D10,");
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getregnamex(breg,(i64)8));
            (*cc_genasm$currmcl).a = (struct cc_libmcl$opndrec *)cc_libmcl$genreg(breg,(i64)(*a).size);
            (*cc_genasm$currmcl).b = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)11,(i64)1);
            cc_genasm$convmcl();
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\txchg D10,");
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getregnamex(breg,(i64)8));
        }
        else {
            (*b).size = (i64)1;
            exchreg = (i64)0;
            if (((i64)(*b).reg != (i64)11)) {
                mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\txchg D10,");
                mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getregnamex((i64)(*b).reg,(i64)8));
                exchreg = (i64)(*b).reg;
                (*b).reg = (i64)11;
            }
;
            cc_genasm$convmcl();
            if (!!(exchreg)) {
                mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\txchg D10,");
                mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getregnamex(exchreg,(i64)8));
            }
;
        }
;
        return;
    }
    else if (($temp==(i64)2)) {
    }
    else if (($temp==(i64)4)) {
        cc_support$gerror((byte*)"SHL/MEM",0);
    }
    };
    cc_genasm$convmcl();
}

static void cc_genasm$do_neg(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)36);
}

static void cc_genasm$do_not(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)37);
}

static void cc_genasm$do_inc(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)38);
}

static void cc_genasm$do_dec(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)39);
}

static void cc_genasm$do_setcc(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b,i64 cond) {
    cc_genasm$passthru((i64)40);
}

static void cc_genasm$do_fneg(struct cc_libmcl$opndrec *a) {
    if (((i64)(*a).size == (i64)4)) {
        (*cc_genasm$currmcl).opcode = (i64)101;
        (*cc_genasm$currmcl).b = (struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"[fchsmask_ps]");
    }
    else {
        (*cc_genasm$currmcl).opcode = (i64)102;
        (*cc_genasm$currmcl).b = (struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"[fchsmask_pd]");
    }
;
    cc_libmcl$fchsused = (i64)1;
    cc_genasm$convmcl();
}

static void cc_genasm$do_fabs(struct cc_libmcl$opndrec *a) {
    if (((i64)(*a).size == (i64)4)) {
        (*cc_genasm$currmcl).opcode = (i64)103;
        (*cc_genasm$currmcl).b = (struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"[fabsmask_ps]");
    }
    else {
        (*cc_genasm$currmcl).opcode = (i64)104;
        (*cc_genasm$currmcl).b = (struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"[fabsmask_pd]");
    }
;
    cc_libmcl$fabsused = (i64)1;
    cc_genasm$convmcl();
}

static void cc_genasm$do_fsqrt(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)43);
}

static void cc_genasm$do_ufix(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$do_ifix((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
}

static void cc_genasm$do_ifix(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$do_changeop((((i64)(*b).size == (i64)4) ? (i64)93 : (i64)94));
}

static void cc_genasm$do_ufloat(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
        struct cc_libmcl$opndrec *  rx;
        struct cc_libmcl$opndrec *  fx;
        u8 *  name;
    rx = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)11,(i64)(*b).size);
    fx = (struct cc_libmcl$opndrec *)cc_libmcl$genxreg((i64)16,(i64)(*a).size);
    if (((i64)(*a).size == (i64)4)) {
        if (((i64)(*b).size == (i64)4)) {
            name = (byte*)"m$ufloat_r32u32*";
        }
        else {
            name = (byte*)"m$ufloat_r32u64*";
        }
;
    }
    else {
        if (((i64)(*b).size == (i64)4)) {
            name = (byte*)"m$ufloat_r64u32*";
        }
        else {
            name = (byte*)"m$ufloat_r64u64*";
        }
;
    }
;
    cc_libmcl$initmcdest();
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)rx,(struct cc_libmcl$opndrec *)b);
    cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cc_libmcl$genname(name),0);
    cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)fx);
    cc_genasm$domclseq((struct cc_libmcl$mclrec *)cc_libmcl$mccode);
}

static void cc_genasm$do_ifloat(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$do_changeop((((i64)(*a).size == (i64)4) ? (i64)89 : (i64)90));
}

static void cc_genasm$do_db(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)58);
}

static void cc_genasm$do_dw(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)59);
}

static void cc_genasm$do_dd(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$convertimm((struct cc_libmcl$opndrec *)a,(i64)0);
    cc_genasm$passthru((i64)60);
}

static void cc_genasm$do_dq(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$convertimm((struct cc_libmcl$opndrec *)a,(i64)0);
    cc_genasm$passthru((i64)61);
}

static void cc_genasm$do_align(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)64);
}

static void cc_genasm$do_segment(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_genasm$passthru((i64)65);
}

static void cc_genasm$do_assem(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(*a).svalue);
}

static void cc_genasm$strmclasm(struct cc_libmcl$mclrec *mcl) {
        struct cc_libmcl$opndrec *  a;
        struct cc_libmcl$opndrec *  b;
        i64 opcode;
        i64 cond;
        i64 sizepref;
        i64 n;
    cc_genasm$initasmline();
    opcode = (i64)(*mcl).opcode;
    cond = (i64)(*mcl).cond;
    a = (struct cc_libmcl$opndrec *)(*mcl).a;
    b = (struct cc_libmcl$opndrec *)(*mcl).b;
    if ((opcode==(i64)67)) {
        cc_genasm$asmstr((*a).svalue);
        return;
    }
    else if ((opcode==(i64)2)) {
        return;
    }
    else if ((opcode==(i64)1)) {
        cc_genasm$asmchar((i64)33);
        cc_genasm$asmstr((*a).svalue);
        return;
    }
    else if ((opcode==(i64)4)) {
        cc_genasm$asmstr((*a).svalue);
        return;
    }
    else if ((opcode==(i64)3)) {
        cc_genasm$asmchar((i64)76);
        cc_genasm$asmint((*a).value);
        cc_genasm$asmchar((i64)58);
        if (!!((i64)(*a).isglobal)) {
            cc_genasm$asmchar((i64)58);
        }
;
        if (!!(b)) {
            cc_genasm$asmstr((byte*)"\t!<");
            cc_genasm$asmstr((*(*b).def).name);
            cc_genasm$asmchar((i64)62);
        }
;
        return;
    }
;
    cc_genasm$asmchar((i64)9);
    if ((opcode==(i64)19)) {
        cc_genasm$asmchar((i64)106);
        cc_genasm$asmstr(cc_libmcl$asmcondnames[(cond)]);
    }
    else if ((opcode==(i64)40)) {
        cc_genasm$asmstr((byte*)"set");
        cc_genasm$asmstr(cc_libmcl$asmcondnames[(cond)]);
    }
    else if ((opcode==(i64)9)) {
        cc_genasm$asmstr((byte*)"cmov");
        cc_genasm$asmstr(cc_libmcl$asmcondnames[(cond)]);
    }
    else {
        cc_genasm$asmstr((cc_libmcl$mclnames[(opcode)-1] + ((opcode <= (i64)68) ? (i64)2 : (i64)3)));
    }
;
    n = (cc_genasm$asmptr - cc_genasm$asmstart);
    L155 :;
    while ((n < (i64)11)) {
        cc_genasm$asmchar((i64)32);
        ++(n);
L156 :;
    }
L157 :;
    ;
    if ((!!(a) && !!(b))) {
        sizepref = cc_libmcl$needsizeprefix(opcode,(struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        cc_genasm$stropndx((struct cc_libmcl$opndrec *)a,sizepref,(i64)0);
        cc_genasm$asmstr((byte*)",\t");
        cc_genasm$stropndx((struct cc_libmcl$opndrec *)b,sizepref,(i64)0);
    }
    else if ((!!(a) && !!((i64)(*a).mode))) {
        if ((opcode == (i64)15)) {
            cc_genasm$stropndx((struct cc_libmcl$opndrec *)a,(i64)0,(i64)0);
        }
        else {
            cc_genasm$stropndx((struct cc_libmcl$opndrec *)a,(i64)1,(i64)0);
        }
;
    }
;
}

void cc_genasm$stropndx(struct cc_libmcl$opndrec *a,i64 sizeprefix,i64 debug) {
        u8 *  plus;
        u8 *  p;
        u8 *  q;
        i64 $av_1;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
        cc_genasm$asmstr(cc_libmcl$getregname((i64)(*a).reg,(i64)(*a).size));
    }
    else if (($temp==(i64)2)) {
        cc_genasm$strvaluex((struct cc_libmcl$opndrec *)a);
    }
    else if (($temp==(i64)4)) {
        if (!!(sizeprefix)) {
            cc_genasm$asmstr(cc_libmcl$getsizeprefix((i64)(*a).size,(i64)1));
        }
;
        cc_genasm$asmchar((i64)91);
        plus = (byte*)"";
        if (!!((i64)(*a).reg)) {
            if (((!!(cc_decls$fshownames) && !!((*a).def)) && ((i64)(*a).reg == (i64)15))) {
            }
            else {
                cc_genasm$asmstr(cc_genasm$getregnamex((i64)(*a).reg,(i64)8));
                plus = (byte*)"+";
            }
;
        }
;
        if (!!((i64)(*a).regix)) {
            cc_genasm$asmstr(plus);
            cc_genasm$asmstr(cc_genasm$getregnamex((i64)(*a).regix,(i64)8));
            plus = (byte*)"+";
            if (((i64)(*a).scale > (i64)1)) {
                cc_genasm$asmchar((i64)42);
                cc_genasm$asmint((i64)(*a).scale);
            }
;
        }
;
        if ((!!((*a).def) || !!((i64)(*a).valtype))) {
            p = cc_genasm$asmptr;
            cc_genasm$asmchar((i64)32);
            q = cc_genasm$asmptr;
            cc_genasm$strvaluex((struct cc_libmcl$opndrec *)a);
            if ((((u64)(*q) != '-') && ((u64)(*plus) == '+'))) {
                (*p) = '+';
            }
;
            if (((u64)(*p) == ' ')) {
                $av_1 = ((cc_genasm$asmptr - p) - (i64)1);
                while ($av_1-- > 0) {
L158 :;
                    (*p) = (u64)(*(p + (i64)1));
                    ++(p);
L159 :;
                }
L160 :;
                ;
                --(cc_genasm$asmptr);
            }
;
        }
;
        cc_genasm$asmchar((i64)93);
    }
    else if (($temp==(i64)3)) {
        cc_genasm$asmchar((i64)47);
        cc_genasm$asmstr((*a).svalue);
        cc_genasm$asmchar((i64)47);
    }
    else if (($temp==(i64)6)) {
        cc_genasm$asmstr(cc_genasm$fgetregnamex((i64)(*a).reg));
    }
    else {
        cc_genasm$asmstr((byte*)"<BAD OPND>");
    }
    };
}

static void cc_genasm$strmclx(struct cc_libmcl$mclrec *mcl) {
    cc_genasm$strmclasm((struct cc_libmcl$mclrec *)mcl);
    (*(cc_genasm$asmptr)++) = (u64)10u;
    (*cc_genasm$asmptr) = (u64)0u;
}

static u8 *cc_genasm$fgetregnamex(i64 reg) {
        static u8 str[16];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"XMM",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64((reg - (i64)1),NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

u8 *cc_genasm$getstringname(i64 n) {
        static u8 str[16];
    if ((n == (i64)0)) {
        cc_libmcl$kk0used = (i64)1;
    }
;
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"KK",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

u8 *cc_genasm$getwstringname(i64 n) {
        static u8 str[16];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"WW",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

u8 *cc_genasm$getrealname(i64 n) {
        static u8 str[16];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"R.",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

u8 *cc_genasm$getsrealname(i64 n) {
        static u8 str[16];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"SR.",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

u8 *cc_genasm$getdintname(i64 n) {
        static u8 str[16];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"DD.",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

i64 cc_genasm$getstringindex(u8 *s,i64 length) {
    if (((s == 0) || (length == (i64)0))) {
        cc_libmcl$kk0used = (i64)1;
        return (i64)0;
    }
;
    if ((cc_genasm$nstrings >= cc_genasm$stringtablesize)) {
        cc_genasm$extendstringtable();
    }
;
    (*cc_genasm$stringtable)[(++(cc_genasm$nstrings))-1] = s;
    (*cc_genasm$stringlentable)[(cc_genasm$nstrings)-1] = length;
    return cc_genasm$nstrings;
}

i64 cc_genasm$getwstringindex(u16 *s,i64 length) {
    if ((cc_genasm$nwstrings >= (i64)1024)) {
        cc_support$gerror((byte*)"Too many wide strings",0);
    }
;
    cc_genasm$wstringtable[(++(cc_genasm$nwstrings))-1] = s;
    cc_genasm$wstringlentable[(cc_genasm$nwstrings)-1] = length;
    return cc_genasm$nwstrings;
}

static i64 cc_genasm$getrealindex(r64 x) {
    if ((cc_genasm$nreals >= cc_genasm$realtablesize)) {
        cc_genasm$extendrealtable();
    }
;
    (*cc_genasm$realtable)[(++(cc_genasm$nreals))-1] = x;
    return cc_genasm$nreals;
}

static i64 cc_genasm$getdintindex(i64 x) {
    if ((cc_genasm$ndints >= cc_genasm$dinttablesize)) {
        cc_genasm$extenddinttable();
    }
;
    (*cc_genasm$dinttable)[(++(cc_genasm$ndints))-1] = x;
    return cc_genasm$ndints;
}

static void cc_genasm$strvaluex(struct cc_libmcl$opndrec *a) {
        struct cc_decls$strec *  d;
        i64 value;
    d = (struct cc_decls$strec *)(*a).def;
    value = (*a).value;
    if (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)7)) {
            if (((i64)(*(*d).owner).nameid == (i64)6)) {
                cc_genasm$asmchar((i64)96);
                cc_genasm$asmstr((*(*d).owner).name);
                cc_genasm$asmchar((i64)46);
                cc_genasm$asmstr((*d).name);
                cc_genasm$asmchar((i64)46);
                cc_genasm$asmint((i64)(*d).blockno);
            }
            else {
                cc_genasm$asmchar((i64)96);
                cc_genasm$asmstr(cc_libmcl$getfullname((struct cc_decls$strec *)d));
                if (!!(cc_lib$isimported((struct cc_decls$strec *)d))) {
                    cc_genasm$asmchar((i64)42);
                }
;
            }
;
        }
        else if (($temp==(i64)8) || ($temp==(i64)9)) {
            if (!!(cc_decls$fshownames)) {
                cc_genasm$asmstr((*d).name);
            }
            else {
                cc_genasm$asmint((*d).offset);
            }
;
        }
        else {
            cc_genasm$asmchar((i64)96);
            cc_genasm$asmstr(cc_libmcl$getfullname((struct cc_decls$strec *)d));
            if (!!(cc_lib$isimported((struct cc_decls$strec *)d))) {
                cc_genasm$asmchar((i64)42);
            }
;
        }
        };
        if ((((i64)(*a).valtype == (i64)1) && (value != (i64)0))) {
            if ((value > (i64)0)) {
                cc_genasm$asmchar((i64)43);
            }
;
            cc_genasm$asmint(value);
        }
;
        return;
    }
;
        {i64 $temp = (i64)(*a).valtype;
if (($temp==(i64)9)) {
        cc_genasm$asmstr(cc_genasm$getdintname((i64)(*a).index));
        return;
    }
    else if (($temp==(i64)10)) {
        if (!!((i64)(*a).isfloat)) {
            cc_genasm$asmstr(cc_genasm$getsrealname((i64)(*a).index));
        }
        else {
            cc_genasm$asmstr(cc_genasm$getrealname((i64)(*a).index));
        }
;
        return;
    }
    else if (($temp==(i64)7)) {
        cc_genasm$asmstr(cc_genasm$getstringname((i64)(*a).index));
        return;
    }
    else if (($temp==(i64)8)) {
        cc_genasm$asmstr(cc_genasm$getwstringname((i64)(*a).index));
        return;
    }
    };
    cc_genasm$asmstr(cc_libmcl$strvalue((struct cc_libmcl$opndrec *)a));
}

static void cc_genasm$convertimm(struct cc_libmcl$opndrec *a,i64 sx) {
        i64 value;
    if (!!((*a).def)) {
        return;
    }
;
    value = (*a).value;
        {i64 $temp = (i64)(*a).valtype;
if (($temp==(i64)1)) {
                {i64 $temp = m$llabs(sx);
if (($temp==(i64)1)) {
            if (((i64)-2147483648<=value && value<=(i64)2147483647)) {
            }
            else {
                if ((sx < (i64)0)) {
                    cc_support$gerror((byte*)"conv/imm1",0);
                }
;
                (*a).index = cc_genasm$getdintindex(value);
                (*a).valtype = (i64)9;
                (*a).mode = (i64)4;
            }
;
        }
        else if (($temp==(i64)2)) {
            if (((i64)0<=value && value<=(i64)4294967295)) {
            }
            else {
                if ((sx < (i64)0)) {
                    cc_support$gerror((byte*)"conv/imm2",0);
                }
;
                (*a).index = cc_genasm$getdintindex(value);
                (*a).valtype = (i64)9;
                (*a).mode = (i64)4;
            }
;
        }
        };
    }
    else if (($temp==(i64)2)) {
        (*a).index = cc_genasm$getrealindex((*a).xvalue);
        (*a).valtype = (i64)10;
        (*a).mode = (i64)4;
        (*a).isfloat = (i64)((i64)(*a).size == (i64)4);
    }
    else if (($temp==(i64)3)) {
        (*a).index = cc_genasm$getstringindex((*a).svalue,(i64)(*a).slength);
        (*a).valtype = (i64)7;
    }
    else if (($temp==(i64)4)) {
        (*a).index = cc_genasm$getwstringindex((*a).wsvalue,(i64)(*a).wslength);
        (*a).valtype = (i64)8;
    }
    };
}

static void cc_genasm$genstringtable(void) {
        i64 i;
        i64 col;
    if (!((!!(cc_genasm$nstrings) || !!(cc_libmcl$kk0used)))) {
        return;
    }
;
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"!String Table");
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tsegment idata");
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\talign ");
    mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,(i64)8);
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
    if (!!(cc_libmcl$kk0used)) {
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"kk0:    db 0");
    }
;
    for (i=(i64)1;i<=cc_genasm$nstrings;++i) {
L161 :;
        col = (i64)(*cc_libmcl$dest).length;
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getstringname(i));
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)":");
        mlib$gs_padto((struct mlib$strbuffer *)cc_libmcl$dest,(i64)8,(i64)32);
        cc_genasm$genstring((*cc_genasm$stringtable)[(i)-1],(*cc_genasm$stringlentable)[(i)-1]);
L162 :;
    }
L163 :;
    ;
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
}

static void cc_genasm$genwstringtable(void) {
        i64 i;
        i64 col;
    if (!(!!(cc_genasm$nwstrings))) {
        return;
    }
;
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"!Wide String Table");
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tsegment idata");
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\talign ");
    mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,(i64)8);
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
    for (i=(i64)1;i<=cc_genasm$nwstrings;++i) {
L164 :;
        col = (i64)(*cc_libmcl$dest).length;
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getwstringname(i));
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)":");
        mlib$gs_padto((struct mlib$strbuffer *)cc_libmcl$dest,(i64)8,(i64)32);
        cc_genasm$genwstring(cc_genasm$wstringtable[(i)-1],cc_genasm$wstringlentable[(i)-1]);
L165 :;
    }
L166 :;
    ;
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
}

static void cc_genasm$do_defstr(u8 *s,i64 length) {
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\t");
    cc_genasm$genstring(s,length);
}

static void cc_genasm$do_defwstr(u16 *s,i64 length) {
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\t");
    cc_genasm$genwstring(s,length);
}

static void cc_genasm$genrealtable(void) {
        struct cc_genasm$genrealtable$fprec fp;
        r64 x;
        i64 i;
        u8 str[1282];
    if (!(!!(cc_genasm$nreals))) {
        return;
    }
;
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"!Real64 Table");
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tsegment idata");
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\talign ");
    mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,(i64)8);
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
    for (i=(i64)1;i<=cc_genasm$nreals;++i) {
L167 :;
        x = (*cc_genasm$realtable)[(i)-1];
        fp.x64 = x;
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getrealname(i));
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)":");
        mlib$gs_padto((struct mlib$strbuffer *)cc_libmcl$dest,(i64)10,(i64)32);
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"dq ");
        mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,fp.ix64);
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\t; ");
        strcpy((u8 *)str,msysc$strint(fp.ix64,(byte*)"z16H"));
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(u8 *)str);
        strcpy((u8 *)str,msysc$strreal(x,(byte*)".30g"));
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(u8 *)str);
L168 :;
    }
L169 :;
    ;
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"!Real32 Table");
    for (i=(i64)1;i<=cc_genasm$nreals;++i) {
L170 :;
        x = (*cc_genasm$realtable)[(i)-1];
        fp.x32 = (r32)x;
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getsrealname(i));
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)":");
        mlib$gs_padto((struct mlib$strbuffer *)cc_libmcl$dest,(i64)10,(i64)32);
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"dd ");
        mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,(i64)fp.ix32);
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\t; ");
        msysc$m_print_startstr(str);
        msysc$m_print_r64((r64)fp.x32,(byte*)".30g");
        msysc$m_print_end();
        ;
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(u8 *)str);
L171 :;
    }
L172 :;
    ;
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
}

static void cc_genasm$gendinttable(void) {
        i64 i;
        i64 x;
    if (!(!!(cc_genasm$ndints))) {
        return;
    }
;
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"!Int64 Table");
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tsegment idata");
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\talign ");
    mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,(i64)8);
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
    for (i=(i64)1;i<=cc_genasm$ndints;++i) {
L173 :;
        x = (*cc_genasm$dinttable)[(i)-1];
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,cc_genasm$getdintname(i));
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)":");
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"dq ");
        mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,x);
        mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
L174 :;
    }
L175 :;
    ;
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
}

static void cc_genasm$writefabs(void) {
    if ((!!(cc_libmcl$fabsused) || !!(cc_libmcl$fchsused))) {
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\tsegment idata");
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\talign 16");
        if (!!(cc_libmcl$fchsused)) {
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"fchsmask_ps:\tdq 0x80000000'80000000, 0x80000000'80000000");
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"fchsmask_pd:\tdq 0x80000000'00000000, 0x80000000'00000000");
        }
;
        if (!!(cc_libmcl$fabsused)) {
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"fabsmask_ps:\tdq 0x7fffffff'7fffffff, 0x7fffffff'7fffffff");
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"fabsmask_pd:\tdq 0x7fffffff'ffffffff, 0x7fffffff'ffffffff");
        }
;
    }
;
}

static void cc_genasm$domclseq(struct cc_libmcl$mclrec *m) {
    L176 :;
    while (!!(m)) {
        cc_genasm$mcltoa64((struct cc_libmcl$mclrec *)m);
        m = (struct cc_libmcl$mclrec *)(*m).nextmcl;
L177 :;
    }
L178 :;
    ;
}

static void cc_genasm$asmstr(u8 *s) {
    L179 :;
    while (!!((u64)(*s))) {
        (*(cc_genasm$asmptr)++) = (u64)(*(s)++);
L180 :;
    }
L181 :;
    ;
}

static void cc_genasm$asmstrln(u8 *s) {
        u8 c;
    L182 :;
    while (!!((c = (u64)(*s)))) {
        (*cc_genasm$asmptr) = (u64)c;
        ++(cc_genasm$asmptr);
        ++(s);
L183 :;
    }
L184 :;
    ;
    (*cc_genasm$asmptr) = (u64)10u;
    ++(cc_genasm$asmptr);
}

static void cc_genasm$asmline(void) {
    (*cc_genasm$asmptr) = (u64)10u;
    ++(cc_genasm$asmptr);
}

static void cc_genasm$asmln(void) {
    cc_genasm$asmline();
}

static void cc_genasm$asmint(i64 a) {
        u8 *  s;
    s = cc_genasm$asmptr;
    msysc$getstrint(a,s);
    cc_genasm$asmptr += strlen(s);
}

static void cc_genasm$asmchar(i64 c) {
    (*cc_genasm$asmptr) = (u64)c;
    ++(cc_genasm$asmptr);
}

static void cc_genasm$asmterm(void) {
    (*cc_genasm$asmptr) = (u64)0u;
}

static void cc_genasm$initasmline(void) {
    cc_genasm$asmptr = (cc_genasm$asmstart = (u8 *)cc_genasm$asmbuffer);
    cc_genasm$asmend = (u8 *)(cc_genasm$asmbuffer + (i64)20000);
}

static u8 *cc_genasm$getregnamex(i64 reg,i64 size) {
        static u8 *  regnames[8][17] = {
    {
        (byte*)"-",
        (byte*)"B0",
        (byte*)"B1",
        (byte*)"B2",
        (byte*)"B3",
        (byte*)"B4",
        (byte*)"B5",
        (byte*)"B6",
        (byte*)"B7",
        (byte*)"B8",
        (byte*)"B9",
        (byte*)"B10",
        (byte*)"B11",
        (byte*)"B12",
        (byte*)"B13",
        (byte*)"B14",
        (byte*)"B15"
},
    {
        (byte*)"-",
        (byte*)"W0",
        (byte*)"W1",
        (byte*)"W2",
        (byte*)"W3",
        (byte*)"W4",
        (byte*)"W5",
        (byte*)"W6",
        (byte*)"W7",
        (byte*)"W8",
        (byte*)"W9",
        (byte*)"W10",
        (byte*)"W11",
        (byte*)"W12",
        (byte*)"W13",
        (byte*)"W14",
        (byte*)"W15"
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        (byte*)"-",
        (byte*)"A0",
        (byte*)"A1",
        (byte*)"A2",
        (byte*)"A3",
        (byte*)"A4",
        (byte*)"A5",
        (byte*)"A6",
        (byte*)"A7",
        (byte*)"A8",
        (byte*)"A9",
        (byte*)"A10",
        (byte*)"A11",
        (byte*)"A12",
        (byte*)"A13",
        (byte*)"Aframe",
        (byte*)"Astack"
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        (byte*)"-",
        (byte*)"D0",
        (byte*)"D1",
        (byte*)"D2",
        (byte*)"D3",
        (byte*)"D4",
        (byte*)"D5",
        (byte*)"D6",
        (byte*)"D7",
        (byte*)"D8",
        (byte*)"D9",
        (byte*)"D10",
        (byte*)"D11",
        (byte*)"D12",
        (byte*)"D13",
        (byte*)"Dframe",
        (byte*)"Dstack"
}
};
    return regnames[(size)-1][(reg)];
}

static void cc_genasm$genstring(u8 *s,i64 length) {
        i64 state;
        i64 a;
        i64 $av_1;
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"db ");
    if ((length == (i64)0)) {
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"0");
        return;
    }
;
    state = (i64)0;
    $av_1 = length;
    while ($av_1-- > 0) {
L185 :;
        a = (i64)(u64)(*(s)++);
        if ((((a < (i64)32) || (a >= (i64)127)) || (a == (i64)34))) {
            if ((state == (i64)1)) {
                mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\",");
                state = (i64)0;
            }
;
            mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,a);
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)",");
        }
        else {
            if ((state == (i64)0)) {
                mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\"");
                state = (i64)1;
            }
;
            mlib$gs_char((struct mlib$strbuffer *)cc_libmcl$dest,a);
        }
;
L186 :;
    }
L187 :;
    ;
    if ((state == (i64)1)) {
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"\",");
    }
;
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"0");
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
}

static void cc_genasm$genwstring(u16 *s,i64 length) {
        i64 i;
        i64 state;
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"dw ");
    if ((length == (i64)0)) {
        mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"0");
        return;
    }
;
    state = (i64)0;
    for (i=(i64)1;i<=length;++i) {
L188 :;
        mlib$gs_strint((struct mlib$strbuffer *)cc_libmcl$dest,(i64)(*(s)++));
        mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)",");
L189 :;
    }
L190 :;
    ;
    mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"0");
    mlib$gs_line((struct mlib$strbuffer *)cc_libmcl$dest);
}

static void cc_genasm$extendrealtable(void) {
        r64 (*oldrealtable)[];
        i64 oldrealtablesize;
        i64 i;
    oldrealtablesize = cc_genasm$realtablesize;
    oldrealtable = cc_genasm$realtable;
    cc_genasm$realtablesize *= (i64)2;
    cc_genasm$realtable = (r64 (*)[])mlib$pcm_alloc(((i64)8 * cc_genasm$realtablesize));
    for (i=(i64)1;i<=cc_genasm$nreals;++i) {
L191 :;
        (*cc_genasm$realtable)[(i)-1] = (*oldrealtable)[(i)-1];
L192 :;
    }
L193 :;
    ;
    mlib$pcm_free(oldrealtable,((i64)8 * oldrealtablesize));
}

static void cc_genasm$extenddinttable(void) {
        i64 (*olddinttable)[];
        i64 olddinttablesize;
        i64 i;
    olddinttablesize = cc_genasm$dinttablesize;
    olddinttable = cc_genasm$dinttable;
    cc_genasm$dinttablesize *= (i64)2;
    cc_genasm$dinttable = (i64 (*)[])mlib$pcm_alloc(((i64)8 * cc_genasm$dinttablesize));
    for (i=(i64)1;i<=cc_genasm$ndints;++i) {
L194 :;
        (*cc_genasm$dinttable)[(i)-1] = (*olddinttable)[(i)-1];
L195 :;
    }
L196 :;
    ;
    mlib$pcm_free(olddinttable,((i64)8 * olddinttablesize));
}

static void cc_genasm$extendstringtable(void) {
        u8 *(*oldstringtable)[];
        i64 (*oldstringlentable)[];
        i64 oldstringtablesize;
        i64 i;
    oldstringtablesize = cc_genasm$stringtablesize;
    oldstringtable = cc_genasm$stringtable;
    oldstringlentable = cc_genasm$stringlentable;
    cc_genasm$stringtablesize *= (i64)2;
    cc_genasm$stringtable = (u8 *(*)[])mlib$pcm_alloc(((i64)8 * cc_genasm$stringtablesize));
    cc_genasm$stringlentable = (i64 (*)[])mlib$pcm_alloc(((i64)8 * cc_genasm$stringtablesize));
    for (i=(i64)1;i<=cc_genasm$nstrings;++i) {
L197 :;
        (*cc_genasm$stringtable)[(i)-1] = (*oldstringtable)[(i)-1];
        (*cc_genasm$stringlentable)[(i)-1] = (*oldstringlentable)[(i)-1];
L198 :;
    }
L199 :;
    ;
    mlib$pcm_free(oldstringtable,((i64)8 * oldstringtablesize));
    mlib$pcm_free(oldstringlentable,((i64)8 * oldstringtablesize));
}

// START
void cc_genasm$start(void) {

}

i64 cc_genmcl$codegen_mcl(i64 n) {
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  e;
    cc_libmcl$mclinit();
    cc_decls$stmodule = (struct cc_decls$strec *)cc_decls$moduletable[(n)].stmodule;
    d = (struct cc_decls$strec *)(*cc_decls$stmodule).deflist;
    L200 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)7)) {
            cc_genmcl$dostaticvar((struct cc_decls$strec *)d);
        }
        else if (($temp==(i64)6)) {
            e = (struct cc_decls$strec *)(*d).deflist;
            L203 :;
            while (!!(e)) {
                                {i64 $temp = (i64)(*e).nameid;
if (($temp==(i64)7)) {
                    cc_genmcl$dostaticvar_fn((struct cc_decls$strec *)e);
                }
                else if (($temp==(i64)8)) {
                    if (!!((*e).code)) {
                        if ((((i64)(*(*e).code).tag == (i64)29) || ((cc_decls$ttbasetype[((i64)(*e).mode)] == (i64)19) && ((i64)(*(*e).code).tag == (i64)1)))) {
                            cc_genmcl$dostaticvar_fn((struct cc_decls$strec *)e);
                        }
;
                    }
;
                }
                };
                e = (struct cc_decls$strec *)(*e).nextdef;
L204 :;
            }
L205 :;
            ;
        }
        };
        d = (struct cc_decls$strec *)(*d).nextdef;
L201 :;
    }
L202 :;
    ;
    cc_libmcl$modulecode = (struct cc_libmcl$mclrec *)cc_libmcl$mccode;
    d = (struct cc_decls$strec *)(*cc_decls$stmodule).deflist;
    L206 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)6)) {
            if (!!((*d).code)) {
                cc_genmcl$genprocdef((struct cc_decls$strec *)d);
            }
;
        }
        };
        d = (struct cc_decls$strec *)(*d).nextdef;
L207 :;
    }
L208 :;
    ;
    return (i64)1;
}

static void cc_genmcl$genprocdef(struct cc_decls$strec *p) {
        u8 str[256];
        i64 paramoffset;
        i64 nparams;
        struct cc_decls$strec *  d;
        i64 n;
        i64 lab;
        i64 np;
        i64 offset;
        i64 i;
        i64 ismain;
        struct cc_libmcl$opndrec *  ax;
        struct cc_libmcl$opndrec *  bx;
        i64 paramtypes[4];
    cc_libmcl$setsegment((i64)67,(i64)1);
    cc_libmcl$initmcdest();
    cc_libmcl$setalign((i64)16);
    cc_libmcl$genassem((byte*)"!------------------------------------");
    cc_decls$currproc = (struct cc_decls$strec *)p;
    cc_genmcl$dolabel((struct cc_decls$strec *)p);
    cc_libmcl$frameoffset = (i64)0;
    paramoffset = (i64)16;
    nparams = (i64)0;
    d = (struct cc_decls$strec *)(*p).deflist;
    L209 :;
    while (!!(d)) {
        switch ((i64)(*d).nameid) {
        case 8:;
            {
                cc_libmcl$frameoffset -= cc_libmcl$roundsizetg(cc_decls$ttsize[((i64)(*d).mode)]);
                (*d).offset = cc_libmcl$frameoffset;
            }
            break;
        case 9:;
            {
                (*d).offset = paramoffset;
                paramoffset += (i64)8;
                ++(nparams);
                if ((nparams <= (i64)4)) {
                    paramtypes[(nparams)-1] = (i64)(*d).mode;
                }
;
            }
            break;
        } //SW
;
        d = (struct cc_decls$strec *)(*d).nextdef;
L210 :;
    }
L211 :;
    ;
    cc_libmcl$structretoffset = (i64)0;
    cc_libmcl$stacksetinstr = 0;
    cc_libmcl$retbeforeblock = (i64)0;
    if ((cc_decls$ttsize[((i64)(*p).mode)] > (i64)8)) {
        cc_libmcl$frameoffset -= (i64)8;
        cc_libmcl$structretoffset = cc_libmcl$frameoffset;
    }
;
    cc_libmcl$currblocksize = (i64)0;
    cc_libmcl$framebytes = -(cc_libmcl$frameoffset);
    cc_libmcl$parambytes = (paramoffset - (i64)16);
    cc_libmcl$iscallbackproc = cc_libmcl$iscallbackfn((struct cc_decls$strec *)p);
    n = (i64)7;
    L212 :;
    while (!!((cc_libmcl$framebytes & n))) {
        ++(cc_libmcl$framebytes);
        --(cc_libmcl$frameoffset);
L213 :;
    }
L214 :;
    ;
    L215 :;
    while (!!((cc_libmcl$parambytes & n))) {
        ++(cc_libmcl$parambytes);
L216 :;
    }
L217 :;
    ;
    cc_libmcl$setsegment((i64)67,(i64)1);
    ismain = (i64)0;
    if (!!(mlib$eqstring((*p).name,(byte*)"main"))) {
        ismain = (i64)1;
        if (!!(cc_libmcl$parambytes)) {
            cc_genmcl$genmainprelude();
        }
;
        if (((i64)(*p).mode != (i64)4)) {
            cc_support$gerror((byte*)"main needs int return type",0);
        }
;
    }
;
    cc_genmcl$genprocentry(cc_libmcl$framebytes,cc_libmcl$parambytes);
    if (!!(nparams)) {
        np = ((i64)4<nparams?(i64)4:nparams);
        if (((i64)(*(*p).paramlist).flags == (i64)3)) {
            for (i=(np + (i64)1);i<=(i64)4;++i) {
L218 :;
                paramtypes[(i)-1] = (i64)1;
L219 :;
            }
L220 :;
            ;
            np = (i64)4;
        }
;
        offset = (i64)16;
        for (i=(i64)1;i<=np;++i) {
L221 :;
            ax = (struct cc_libmcl$opndrec *)cc_libmcl$genireg((i64)15,(i64)8);
            (*ax).value = offset;
            (*ax).valtype = (i64)1;
            if (!!(cc_lib$isrealcc(paramtypes[(i)-1]))) {
                cc_libmcl$genmc((i64)10,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)cc_libmcl$genxreg((((i64)1 + i) - (i64)1),cc_decls$ttsize[(paramtypes[(i)-1])]));
            }
            else {
                cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((((i64)11 + i) - (i64)1),(i64)8));
            }
;
            offset += (i64)8;
L222 :;
        }
L223 :;
        ;
    }
;
    if (!!(cc_libmcl$structretoffset)) {
        bx = (struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)15,(i64)0,(i64)1,cc_libmcl$structretoffset,(i64)0,(i64)0,0);
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)bx,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)10,(i64)8));
    }
;
    if (!!(cc_libmcl$iscallbackproc)) {
        strcpy((u8 *)str,(byte*)"m$pushcallback*");
        cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cc_libmcl$genname((u8 *)str),0);
    }
;
    cc_libmcl$stackaligned = (i64)1;
    cc_libmcl$retindex = (lab = cc_libmcl$createfwdlabel());
    cc_libmcl$gencomment((byte*)"-------------------------------------------------");
    cc_libmcl$enterproc((*p).name);
    cc_blockmcl$do_stmt((struct cc_decls$unitrec *)(*p).code);
    cc_libmcl$definefwdlabel(cc_libmcl$retindex);
    cc_libmcl$gencomment((byte*)"-------------------------------------------------");
    if (!!(ismain)) {
        cc_libmcl$pushstack((i64)32);
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)11,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)4));
        cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"exit*"),0);
    }
    else {
        cc_libmcl$leaveproc((*p).name);
        cc_libmcl$genreturn(cc_libmcl$framebytes,cc_libmcl$parambytes);
    }
;
    if (((i64)(*p).mode != (i64)1)) {
        if (!(!!(cc_genmcl$checkblockreturn((struct cc_decls$unitrec *)(*p).code)))) {
            if (!(!!(mlib$eqstring((*p).name,(byte*)"main")))) {
                cc_support$gerror_s((byte*)"Function needs explicit return statement: %s",(*p).name,0);
            }
;
        }
;
    }
;
    cc_libmcl$gencomment((byte*)"");
    (*p).mclcode = cc_libmcl$mccode;
}

static i64 cc_genmcl$checkblockreturn(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  e;
        i64 m;
    if (!(!!(cc_decls$fmodern))) {
        return (i64)1;
    }
;
    if ((p == 0)) {
        return (i64)0;
    }
;
    m = (i64)(*p).mode;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)10)) {
        return (i64)1;
    }
    else if (($temp==(i64)13)) {
        return (i64)(!!(cc_genmcl$checkblockreturn((struct cc_decls$unitrec *)(*p).b)) && !!(cc_genmcl$checkblockreturn((struct cc_decls$unitrec *)(*p).c)));
    }
    else if (($temp==(i64)23)) {
        return (i64)1;
        return cc_genmcl$checkblockreturn((struct cc_decls$unitrec *)(*p).b);
    }
    else if (($temp==(i64)6)) {
        e = (struct cc_decls$unitrec *)(*p).a;
        if (!!(e)) {
            L224 :;
            while ((!!(e) && !!((*e).nextunit))) {
                e = (struct cc_decls$unitrec *)(*e).nextunit;
L225 :;
            }
L226 :;
            ;
            return cc_genmcl$checkblockreturn(e);
        }
;
    }
    else if (($temp==(i64)18)) {
        return cc_genmcl$checkblockreturn((struct cc_decls$unitrec *)(*p).a);
    }
    else if (($temp==(i64)17) || ($temp==(i64)15) || ($temp==(i64)16)) {
        return (i64)1;
    }
    };
    return (i64)0;
}

static void cc_genmcl$dolabel(struct cc_decls$strec *d) {
        u8 str[256];
    strcpy((u8 *)str,(byte*)"`");
    strcat((u8 *)str,cc_libmcl$getfullname((struct cc_decls$strec *)d));
    strcat((u8 *)str,(!!(cc_lib$isexported((struct cc_decls$strec *)d)) ? (byte*)"::" : (byte*)":"));
    cc_libmcl$genmc((i64)4,(struct cc_libmcl$opndrec *)cc_libmcl$genname((u8 *)str),0);
}

static void cc_genmcl$dolabel_fn(struct cc_decls$strec *d,i64 dollar) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"`##.#.#:");
    msysc$m_print_str((!!(dollar) ? (byte*)"$" : (byte*)""),NULL);
    msysc$m_print_str((*(*d).owner).name,NULL);
    msysc$m_print_str((*d).name,NULL);
    msysc$m_print_i64((i64)(*d).blockno,NULL);
    msysc$m_print_end();
    ;
    cc_libmcl$genmc((i64)4,(struct cc_libmcl$opndrec *)cc_libmcl$genname((u8 *)str),0);
}

static void cc_genmcl$dostaticvar(struct cc_decls$strec *d) {
        i64 align;
        {i64 $temp = (i64)(*d).scope;
if (($temp==(i64)3)) {
        return;
    }
    };
    align = cc_lib$getalignment((i64)(*d).mode);
    if (!!((*d).code)) {
        cc_libmcl$setsegment((i64)73,align);
        cc_genmcl$dolabel((struct cc_decls$strec *)d);
        cc_genmcl$genidata((struct cc_decls$unitrec *)(*d).code,(i64)1,(i64)1,(i64)0);
    }
    else {
        cc_libmcl$setsegment((i64)90,align);
        cc_genmcl$dolabel((struct cc_decls$strec *)d);
        cc_libmcl$genmc((i64)57,(struct cc_libmcl$opndrec *)cc_libmcl$genint(cc_decls$ttsize[((i64)(*d).mode)],(i64)4),0);
    }
;
}

static void cc_genmcl$dostaticvar_fn(struct cc_decls$strec *d) {
        i64 align;
        {i64 $temp = (i64)(*d).scope;
if (($temp==(i64)3)) {
        cc_genmcl$dostaticvar((struct cc_decls$strec *)d);
        return;
    }
    };
    align = cc_lib$getalignment((i64)(*d).mode);
    if (!!((*d).code)) {
        cc_libmcl$setsegment((i64)73,align);
        cc_genmcl$dolabel_fn((struct cc_decls$strec *)d,(i64)((i64)(*d).nameid == (i64)8));
        cc_genmcl$genidata((struct cc_decls$unitrec *)(*d).code,(i64)1,(i64)1,(i64)0);
    }
    else {
        cc_libmcl$setsegment((i64)90,align);
        cc_genmcl$dolabel_fn((struct cc_decls$strec *)d,(i64)0);
        cc_libmcl$genmc((i64)57,(struct cc_libmcl$opndrec *)cc_libmcl$genint(cc_decls$ttsize[((i64)(*d).mode)],(i64)4),0);
    }
;
}

static void cc_genmcl$genprocentry(i64 fbytes,i64 pbytes) {
    if ((!!(fbytes) || !!(pbytes))) {
        cc_libmcl$genmc((i64)6,(struct cc_libmcl$opndrec *)cc_libmcl$dframeopnd,0);
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$dframeopnd,(struct cc_libmcl$opndrec *)cc_libmcl$dstackopnd);
        if (!!(fbytes)) {
            cc_libmcl$pushstack(cc_libmcl$roundto(fbytes,(i64)16));
        }
;
    }
    else {
        cc_libmcl$pushstack((i64)8);
    }
;
    cc_libmcl$stacksetinstr = (struct cc_libmcl$mclrec *)cc_libmcl$mccodex;
}

static void cc_genmcl$genidata(struct cc_decls$unitrec *p,i64 doterm,i64 am,i64 offset) {
        i64 t;
        i64 length;
        i64 n;
        i64 i;
        i64 offset1;
        i64 offset2;
        i64 size;
        i64 padding;
        i64 isunion;
        struct cc_decls$unitrec *  q;
        struct cc_decls$unitrec *  a;
        struct cc_decls$unitrec *  b;
        struct cc_decls$strec *  d;
        r32 sx;
        u8 str[256];
        u8 str2[16];
        struct cc_libmcl$opndrec *  ax;
        i64 $av_1;
        i64 $av_2;
    t = (i64)(*p).mode;
    a = (struct cc_decls$unitrec *)(*p).a;
    b = (struct cc_decls$unitrec *)(*p).b;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)29)) {
        n = (i64)(*p).count;
        if ((cc_decls$ttbasetype[(t)] == (i64)19)) {
            length = cc_decls$ttlength[(t)];
            q = a;
            for (i=(i64)1;i<=n;++i) {
L227 :;
                cc_genmcl$genidata(q,(i64)1,(i64)1,(i64)0);
                q = (struct cc_decls$unitrec *)(*q).nextunit;
L228 :;
            }
L229 :;
            ;
            if ((n < length)) {
                n = ((length - n) * cc_decls$ttsize[(cc_decls$tttarget[(t)])]);
                L230 :;
                while ((n >= (i64)8)) {
                    cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)8),0);
                    n -= (i64)8;
L231 :;
                }
L232 :;
                ;
                $av_1 = n;
                while ($av_1-- > 0) {
L233 :;
                    cc_libmcl$genmc((i64)58,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)4),0);
L234 :;
                }
L235 :;
                ;
            }
;
        }
        else {
            isunion = (i64)(cc_decls$ttbasetype[(t)] == (i64)21);
            d = (struct cc_decls$strec *)(*cc_decls$ttnamedef[(t)]).deflist;
            size = cc_decls$ttsize[(t)];
            offset1 = (offset2 = (i64)0);
            q = a;
            for (i=(i64)1;i<=n;++i) {
L236 :;
                cc_genmcl$genidata(q,(i64)0,(i64)1,(i64)0);
                if (((cc_decls$ttbasetype[((i64)(*q).mode)] == (i64)16) && !!((i64)(*q).strarray))) {
                    offset1 += (i64)(*q).slength;
                }
                else {
                    offset1 += cc_decls$ttsize[((i64)(*q).mode)];
                }
;
                d = (struct cc_decls$strec *)(*d).nextdef;
                if ((!!(d) && !(!!(isunion)))) {
                    offset2 = (*d).offset;
                }
                else {
                    offset2 = size;
                }
;
                padding = (offset2 - offset1);
                if ((padding > (i64)0)) {
                    padding = (offset2 - offset1);
                    if ((padding > (i64)0)) {
                        cc_libmcl$genmc((i64)57,(struct cc_libmcl$opndrec *)cc_libmcl$genint(padding,(i64)4),0);
                    }
;
                    offset1 = offset2;
                }
;
                q = (struct cc_decls$unitrec *)(*q).nextunit;
L237 :;
            }
L238 :;
            ;
            if ((offset2 < size)) {
                n = (size - offset2);
                L239 :;
                while ((n >= (i64)8)) {
                    cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)8),0);
                    n -= (i64)8;
L240 :;
                }
L241 :;
                ;
                $av_2 = n;
                while ($av_2-- > 0) {
L242 :;
                    cc_libmcl$genmc((i64)58,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)4),0);
L243 :;
                }
L244 :;
                ;
            }
;
        }
;
        return;
    }
    else if (($temp==(i64)1)) {
        if ((!!(cc_lib$isintcc(t)) || !!(cc_lib$isrealcc(t)))) {
            if ((t == (i64)11)) {
                sx = (r32)(*p).xvalue;
                cc_libmcl$genmc((i64)60,(struct cc_libmcl$opndrec *)cc_libmcl$genint(*(i64*)&sx,(i64)4),0);
            }
            else {
                cc_libmcl$genmc((cc_decls$ttsize[(t)]==1?(i64)58:(cc_decls$ttsize[(t)]==2?(i64)59:(cc_decls$ttsize[(t)]==3?(i64)0:(cc_decls$ttsize[(t)]==4?(i64)60:(cc_decls$ttsize[(t)]==5?(i64)0:(cc_decls$ttsize[(t)]==6?(i64)0:(cc_decls$ttsize[(t)]==7?(i64)0:(cc_decls$ttsize[(t)]==8?(i64)61:(i64)0)))))))),(struct cc_libmcl$opndrec *)cc_libmcl$genint((*p).value,cc_decls$ttsize[(t)]),0);
            }
;
        }
        else if ((cc_decls$ttbasetype[(t)] == (i64)16)) {
            padding = (i64)0;
            //doref:
L245 :;
;
            if (((*p).value == (i64)0)) {
                cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)8),0);
            }
            else if (!!((i64)(*p).strarray)) {
                if ((cc_decls$ttsize[(cc_decls$tttarget[(t)])] == (i64)1)) {
                    cc_libmcl$genmc((i64)62,(struct cc_libmcl$opndrec *)cc_libmcl$genstrimm((*p).svalue,(i64)(*p).slength),0);
                }
                else {
                    cc_libmcl$genmc((i64)63,(struct cc_libmcl$opndrec *)cc_libmcl$genwstrimm((*p).wsvalue,(i64)(*p).wslength),0);
                }
;
                if ((padding > (i64)0)) {
                    cc_libmcl$genmc((i64)57,(struct cc_libmcl$opndrec *)cc_libmcl$genint(padding,(i64)4),0);
                }
;
            }
            else if (!!((i64)(*p).isstrconst)) {
                cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genstrimm((*p).svalue,(i64)(*p).slength),0);
                if ((padding > (i64)0)) {
                    cc_libmcl$genmc((i64)57,(struct cc_libmcl$opndrec *)cc_libmcl$genint(padding,(i64)4),0);
                }
;
            }
            else if (!!((i64)(*p).iswstrconst)) {
                cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genwstrimm((*p).wsvalue,(i64)(*p).wslength),0);
                if ((padding > (i64)0)) {
                    cc_libmcl$genmc((i64)57,(struct cc_libmcl$opndrec *)cc_libmcl$genint(padding,(i64)4),0);
                }
;
            }
            else {
                cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genint((*p).value,(i64)4),0);
            }
;
        }
        else if ((cc_decls$ttbasetype[(t)] == (i64)19)) {
            padding = ((cc_decls$ttlength[(t)] - ((i64)(*p).slength + (i64)1)) * cc_decls$ttsize[(cc_decls$tttarget[(t)])]);
            goto L245 ;
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(cc_lib$strmode(t,(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_support$gerror((byte*)"IDATA/SCALAR",0);
        }
;
        return;
    }
    else if (($temp==(i64)3) || ($temp==(i64)5)) {
        d = (struct cc_decls$strec *)(*p).def;
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)7) || ($temp==(i64)6)) {
            ax = (struct cc_libmcl$opndrec *)cc_libmcl$genmemaddr_d((struct cc_decls$strec *)d);
            if (!!(ax)) {
                ax = (struct cc_libmcl$opndrec *)cc_libmcl$applyoffset((struct cc_libmcl$opndrec *)ax,offset,(i64)0);
            }
;
            cc_libmcl$genmc((((am == (i64)0) || (cc_decls$ttsize[((i64)(*p).mode)] == (i64)8)) ? (i64)61 : (i64)60),(struct cc_libmcl$opndrec *)ax,0);
        }
        else {
            cc_support$gerror((byte*)"Idata &frame",(struct cc_decls$unitrec *)p);
        }
        };
        return;
    }
    else if (($temp==(i64)40)) {
        if ((((i64)(*a).tag == (i64)3) && ((i64)(*b).tag == (i64)1))) {
            d = (struct cc_decls$strec *)(*a).def;
                        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)7)) {
                strcpy((u8 *)str,(byte*)"`");
                if (((i64)(*d).scope == (i64)1)) {
                    strcat((u8 *)str,(*cc_decls$currproc).name);
                    strcat((u8 *)str,(byte*)",");
                }
;
                strcat((u8 *)str,(*d).name);
                strcat((u8 *)str,(byte*)"+");
                msysc$getstrint((*b).value,(u8 *)str2);
                strcat((u8 *)str,(u8 *)str2);
                cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genname((u8 *)str),0);
            }
            else {
                cc_support$gerror((byte*)"Add/Idata &frame",0);
            }
            };
        }
        else if (((((i64)(*a).tag == (i64)1) && ((i64)(*b).tag == (i64)1)) && (cc_decls$ttbasetype[((i64)(*a).mode)] == (i64)16))) {
            msysc$m_print_startstr(str);
            msysc$m_print_i64((*a).value,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)"+",NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64((*b).value,NULL);
            msysc$m_print_end();
            ;
            cc_libmcl$genmc((i64)61,(struct cc_libmcl$opndrec *)cc_libmcl$genname((u8 *)str),0);
        }
        else {
            cc_support$gerror((byte*)"1:Runtime or unsupported expr in static data",0);
        }
;
        return;
    }
    else if (($temp==(i64)56)) {
        if (((i64)(*a).tag == (i64)53)) {
            cc_genmcl$genidata((struct cc_decls$unitrec *)(*a).a,(i64)1,(i64)1,offset);
        }
        else {
            cc_genmcl$genidata(a,(i64)1,(i64)0,offset);
        }
;
    }
    else if (($temp==(i64)54) || ($temp==(i64)55)) {
        if (((i64)(*b).tag != (i64)1)) {
            cc_support$gerror((byte*)"Complex ptr expr in static data",0);
        }
;
        cc_genmcl$genidata(a,(i64)1,(i64)1,(((*b).value * (i64)(*p).ptrscale) + offset));
    }
    else if (($temp==(i64)57)) {
        cc_genmcl$genidata(a,(i64)1,(i64)1,offset);
    }
    else {
        cc_lib$printunit(0,(struct cc_decls$unitrec *)p,(i64)0,(byte*)"*");
        cc_support$gerror((byte*)"2:Runtime expr in static data",(struct cc_decls$unitrec *)p);
    }
    };
}

static void cc_genmcl$genmainprelude(void) {
    cc_libmcl$genassem((byte*)"\tsub\tDstack,152");
    cc_libmcl$genassem((byte*)"\tsub\tDstack,8");
    cc_libmcl$genassem((byte*)"\tlea\tD0,[Dstack+8]");
    cc_libmcl$genassem((byte*)"\tpush\tD0");
    cc_libmcl$genassem((byte*)"\tsub\tDstack,32");
    cc_libmcl$genassem((byte*)"\tlea\tD0,[Dstack+196]");
    cc_libmcl$genassem((byte*)"\tmov\t[Dstack],D0");
    cc_libmcl$genassem((byte*)"\tlea\tD0,[Dstack+184]");
    cc_libmcl$genassem((byte*)"\tmov\t[Dstack+8],D0");
    cc_libmcl$genassem((byte*)"\tlea\tD0,[Dstack+176]");
    cc_libmcl$genassem((byte*)"\tmov\t[Dstack+16],D0");
    cc_libmcl$genassem((byte*)"\tmov\tA0,0");
    cc_libmcl$genassem((byte*)"\tmov\t[Dstack+24],A0");
    cc_libmcl$genassem((byte*)"\tmov\tD10,[Dstack]");
    cc_libmcl$genassem((byte*)"\tmov\tD11,[Dstack+8]");
    cc_libmcl$genassem((byte*)"\tmov\tD12,[Dstack+16]");
    cc_libmcl$genassem((byte*)"\tmov\tD13,[Dstack+24]");
    cc_libmcl$genassem((byte*)"\tcall\t__getmainargs*");
    cc_libmcl$genassem((byte*)"\tadd\tDstack,48");
    cc_libmcl$genassem((byte*)"\tsub\tDstack,32");
    cc_libmcl$genassem((byte*)"\tmov\tA0,[Dstack+180]");
    cc_libmcl$genassem((byte*)"\tmov\t[Dstack],A0");
    cc_libmcl$genassem((byte*)"\tmov\tD0,[Dstack+168]");
    cc_libmcl$genassem((byte*)"\tmov\t[Dstack+8],D0");
    cc_libmcl$genassem((byte*)"\tmov\tD10,[Dstack]");
    cc_libmcl$genassem((byte*)"\tmov\tD11,[Dstack+8]");
    cc_libmcl$genassem((byte*)"\tcall\t.main");
    cc_libmcl$genassem((byte*)"\tmov A10,A0");
    cc_libmcl$genassem((byte*)"\tcall exit*");
    cc_libmcl$gencomment((byte*)"");
    cc_libmcl$genassem((byte*)".main::");
}

// START
void cc_genmcl$start(void) {

}

u8 *cc_headers$findheader(u8 *name) {
        i64 i;
        u8 newname[256];
        u8 *  s;
        u8 *  t;
    if (!!(strchr(name,(i32)(u64)92u))) {
        s = name;
        t = (u8 *)newname;
        L246 :;
        while (!!((u64)(*s))) {
            if (((u64)(*s) == (u64)92u)) {
                (*(t)++) = '/';
            }
            else {
                (*(t)++) = (u64)(*s);
            }
;
            ++(s);
L247 :;
        }
L248 :;
        ;
        (*t) = (u64)0u;
        name = (u8 *)newname;
    }
;
    for (i=(i64)1;i<=(i64)42;++i) {
L249 :;
        if (!!(mlib$eqstring(name,cc_headers$stdhdrnames[(i)-1]))) {
            return (*cc_headers$stdhdrtext[(i)-1]);
        }
;
L250 :;
    }
L251 :;
    ;
    return (u8 *)0;
}

void cc_headers$writeheaders(void) {
        void *  f;
        u8 *  ifile;
        i64 i;
    for (i=(i64)1;i<=(i64)42;++i) {
L252 :;
        ifile = mlib$changeext(cc_headers$stdhdrnames[(i)-1],(byte*)"hdr");
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Writing internal",NULL);
        msysc$m_print_str(cc_headers$stdhdrnames[(i)-1],NULL);
        msysc$m_print_str((byte*)"as",NULL);
        msysc$m_print_str(ifile,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        f = fopen(ifile,(byte*)"wb");
        fwrite((void *)(*cc_headers$stdhdrtext[(i)-1]),(u64)1u,(u64)strlen((*cc_headers$stdhdrtext[(i)-1])),f);
        fclose(f);
L253 :;
    }
L254 :;
    ;
}

void cc_headers$checkbcclib(void) {
        void *  f;
    if (!(!!(mlib$checkfile((byte*)"bcclib.asm")))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Writing",NULL);
        msysc$m_print_str((byte*)"bcclib.asm",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        f = fopen((byte*)"bcclib.asm",(byte*)"wb");
        fwrite((void *)cc_headers$bcclibstr,(u64)1u,(u64)strlen(cc_headers$bcclibstr),f);
        fclose(f);
    }
;
}

u8 *cc_headers$getbcclib(void) {
        u8 *  s;
        i64 slen;
    slen = strlen(cc_headers$bcclibstr);
    s = (u8 *)malloc((u64)(slen + (i64)1));
    memcpy((void *)s,(void *)cc_headers$bcclibstr,(u64)(slen + (i64)1));
    return s;
}

i64 cc_headers$isheaderfile(u8 *file) {
        i64 i;
    for (i=(i64)1;i<=(i64)42;++i) {
L255 :;
        if (!!(mlib$eqstring(cc_headers$stdhdrnames[(i)-1],file))) {
            return (i64)1;
        }
;
L256 :;
    }
L257 :;
    ;
    return (i64)0;
}

// START
void cc_headers$start(void) {

}

void cc_lex$lex_preprocess_only(u8 *infile,i64 showtokens,i64 nn,i64 toconsole) {
        u8 *  psource;
        i64 ntokens;
        i64 nlines;
        i64 fileno;
        i64 size;
        i64 t;
        i64 hashtot;
        i64 symtot;
        static struct mlib$strbuffer sbuffer;
        static struct mlib$strbuffer *  dest = (struct mlib$strbuffer *)&sbuffer;
        void *  f;
        u8 outfile[300];
    cc_lex$dowhitespace = (i64)1;
    fileno = cc_support$loadsourcefile(infile,infile);
    strcpy((u8 *)outfile,mlib$changeext(infile,(byte*)"i"));
    psource = cc_decls$sourcefiletext[(fileno)];
    size = (i64)cc_decls$sourcefilesizes[(fileno)];
    nlines = (ntokens = (i64)0);
    hashtot = (symtot = (i64)0);
    t = mwindows$os_clock();
    cc_lex$destcopy = (struct mlib$strbuffer *)dest;
    mlib$gs_init((struct mlib$strbuffer *)dest);
    cc_lex$lxsptr = psource;
    cc_lex$lxstart = cc_lex$lxsptr;
    cc_decls$nextlx.lineno = (i64)1;
    cc_lex$setfileno((i64)1);
    cc_lex$ifcondlevel = (i64)0;
    cc_lex$stacksourcefile((byte*)"bcc.h",(i64)1);
    cc_decls$nextlx.symbol = (i64)57;
    L258 :;
    do {
        cc_lex$lexm();
        ++(ntokens);
        if (!!(showtokens)) {
            cc_lex$emittoken((struct cc_decls$tokenrec *)&cc_decls$nextlx,(struct mlib$strbuffer *)dest,(i64)0);
        }
;
L259 :;
    }
    while (!((i64)cc_decls$nextlx.symbol == (i64)58));
L260 :;
    ;
    if (!!(cc_lex$ifcondlevel)) {
        cc_lex$lxerror((byte*)"#endif missing");
    }
;
    if (!!(showtokens)) {
        if (!!(toconsole)) {
            mlib$gs_println((struct mlib$strbuffer *)dest,0);
        }
        else {
            f = fopen((u8 *)outfile,(byte*)"wb");
            mlib$gs_println((struct mlib$strbuffer *)dest,f);
            fclose(f);
        }
;
    }
;
}

void cc_lex$lexreadtoken(void) {
        u64 c;
        u64 hsum;
        u8 *  ss;
    cc_decls$nextlx.subcodex = (i64)0;
    L261 :;
    switch ((i64)(u64)(*(cc_lex$lxsptr)++)) {
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
        {
            //doname:
L263 :;
;
            cc_lex$lxsvalue = (cc_lex$lxsptr - (i64)1);
            hsum = (u64)(u64)(*cc_lex$lxsvalue);
            L264 :;
            while (!!((u64)cc_lex$alphamap[((i64)(c = (u64)(u64)(*(cc_lex$lxsptr)++)))])) {
                hsum = (((hsum << (i64)4) - hsum) + c);
L265 :;
            }
L266 :;
            ;
            --(cc_lex$lxsptr);
            cc_decls$nextlx.symbol = (i64)69;
            cc_decls$nextlx.length = (cc_lex$lxsptr - cc_lex$lxsvalue);
            if ((c==(u64)39u) || (c==(u64)34u)) {
                if (((i64)cc_decls$nextlx.length == (i64)1)) {
                                        {u64 $temp = (u64)(*cc_lex$lxsvalue);
if (($temp=='l') || ($temp=='L') || ($temp=='u') || ($temp=='U')) {
                        ++(cc_lex$lxsptr);
                        cc_lex$lxreadstring((i64)c,(i64)1);
                        return;
                    }
                    };
                }
;
            }
;
            cc_lex$lxhashvalue = (i64)((hsum << (i64)5) - hsum);
            ss = (u8 *)mlib$pcm_alloc(((i64)cc_decls$nextlx.length + (i64)1));
            memcpy((void *)ss,(void *)cc_lex$lxsvalue,(u64)(i64)cc_decls$nextlx.length);
            (*(ss + (i64)cc_decls$nextlx.length)) = (u64)0u;
            cc_lex$lxsvalue = ss;
            cc_lex$lookup();
            return;
        }
        break;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp==' ') || ($temp==')') || ($temp==(u64)13u) || ($temp==',') || ($temp==';')) {
                cc_decls$nextlx.symbol = (i64)60;
                cc_decls$nextlx.subcode = (i64)4;
                cc_decls$nextlx.value = (i64)((u64)(*(cc_lex$lxsptr - (i64)1)) - '0');
                cc_decls$nextlx.length = (i64)1;
                cc_lex$setnumberoffset(((cc_lex$lxsptr - (i64)1) - cc_lex$lxstart));
            }
            else {
                cc_lex$readdecimal((cc_lex$lxsptr - (i64)1));
            }
            };
            return;
        }
        break;
    case 48:;
        {
            switch ((i64)(u64)(*cc_lex$lxsptr)) {
            case 120:;
            case 88:;
                {
                    ++(cc_lex$lxsptr);
                    cc_lex$readhex((cc_lex$lxsptr - (i64)2));
                    return;
                }
                break;
            case 98:;
            case 66:;
                {
                    ++(cc_lex$lxsptr);
                    cc_lex$readbinary((cc_lex$lxsptr - (i64)2));
                    return;
                }
                break;
            case 46:;
                {
                    cc_lex$readrealnumber((cc_lex$lxsptr - (i64)1),(cc_lex$lxsptr - (i64)1),(i64)1,(i64)10);
                    return;
                }
                break;
            case 117:;
            case 85:;
            case 108:;
            case 76:;
                {
                    cc_lex$readdecimal((cc_lex$lxsptr - (i64)1));
                    return;
                }
                break;
            case 44:;
            case 41:;
            case 93:;
            case 125:;
            case 59:;
            case 32:;
            case 58:;
            case 13:;
            case 10:;
            case 38:;
            case 61:;
            case 63:;
                {
                    cc_decls$nextlx.symbol = (i64)60;
                    cc_decls$nextlx.subcode = (i64)4;
                    cc_decls$nextlx.value = (i64)0;
                    cc_decls$nextlx.length = (i64)1;
                    cc_lex$setnumberoffset(((cc_lex$lxsptr - (i64)1) - cc_lex$lxstart));
                    return;
                }
                break;
            default: {
                cc_lex$readoctal((cc_lex$lxsptr - (i64)1));
                return;
            }
            } //SW
;
        }
        break;
    case 35:;
        {
            if (((i64)cc_decls$nextlx.symbol == (i64)57)) {
                cc_decls$nextlx.symbol = (i64)4;
                return;
            }
            else if (((u64)(*cc_lex$lxsptr) == '#')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)7;
                return;
            }
            else {
                cc_decls$nextlx.symbol = (i64)5;
                return;
            }
;
        }
        break;
    case 92:;
        {
            L267 :;
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp==(u64)13u) || ($temp==(u64)10u)) {
                goto L268 ;
            }
            else if (($temp==' ') || ($temp==(u64)9u)) {
                ++(cc_lex$lxsptr);
            }
            else {
                cc_decls$nextlx.symbol = (i64)22;
                return;
            }
            }goto L267 ;
L268 :;
            ;
            (*(cc_lex$lxsptr - (i64)1)) = ' ';
            ++(cc_decls$nextlx.lineno);
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp==(u64)13u)) {
                ++(cc_lex$lxsptr);
                (*(cc_lex$lxsptr)++) = ' ';
            }
            else if (($temp==(u64)10u)) {
                (*(cc_lex$lxsptr)++) = ' ';
            }
            else {
            }
            };
        }
        break;
    case 123:;
        {
            cc_decls$nextlx.symbol = (i64)17;
            return;
        }
        break;
    case 125:;
        {
            cc_decls$nextlx.symbol = (i64)18;
            return;
        }
        break;
    case 46:;
        {
            switch ((i64)(u64)(*cc_lex$lxsptr)) {
            case 46:;
                {
                    ++(cc_lex$lxsptr);
                    if (((u64)(*cc_lex$lxsptr) == '.')) {
                        ++(cc_lex$lxsptr);
                        cc_decls$nextlx.symbol = (i64)21;
                    }
                    else {
                        --(cc_lex$lxsptr);
                        cc_decls$nextlx.symbol = (i64)2;
                        return;
                    }
;
                    return;
                }
                break;
            case 48:;
            case 49:;
            case 50:;
            case 51:;
            case 52:;
            case 53:;
            case 54:;
            case 55:;
            case 56:;
            case 57:;
                {
                    --(cc_lex$lxsptr);
                    cc_lex$readrealnumber(cc_lex$lxsptr,cc_lex$lxsptr,(i64)0,(i64)10);
                    return;
                }
                break;
            default: {
                cc_decls$nextlx.symbol = (i64)2;
                return;
            }
            } //SW
;
        }
        break;
    case 44:;
        {
            cc_decls$nextlx.symbol = (i64)8;
            return;
        }
        break;
    case 59:;
        {
            cc_decls$nextlx.symbol = (i64)9;
            return;
        }
        break;
    case 58:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)11;
            }
            else {
                cc_decls$nextlx.symbol = (i64)10;
            }
            };
            return;
        }
        break;
    case 40:;
        {
            cc_decls$nextlx.symbol = (i64)13;
            return;
        }
        break;
    case 41:;
        {
            cc_decls$nextlx.symbol = (i64)14;
            return;
        }
        break;
    case 91:;
        {
            cc_decls$nextlx.symbol = (i64)15;
            return;
        }
        break;
    case 93:;
        {
            cc_decls$nextlx.symbol = (i64)16;
            return;
        }
        break;
    case 124:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='|')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)31;
            }
            else if (($temp=='=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)51;
            }
            else {
                cc_decls$nextlx.symbol = (i64)28;
            }
            };
            return;
        }
        break;
    case 94:;
        {
            if (((u64)(*cc_lex$lxsptr) == '=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)53;
            }
            else {
                cc_decls$nextlx.symbol = (i64)30;
            }
;
            return;
        }
        break;
    case 63:;
        {
            cc_decls$nextlx.symbol = (i64)19;
            return;
        }
        break;
    case 126:;
        {
            cc_decls$nextlx.symbol = (i64)35;
            return;
        }
        break;
    case 43:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='+')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)37;
            }
            else if (($temp=='=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)46;
            }
            else {
                cc_decls$nextlx.symbol = (i64)23;
            }
            };
            return;
        }
        break;
    case 45:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='-')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)38;
            }
            else if (($temp=='>')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)3;
            }
            else if (($temp=='=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)47;
            }
            else {
                cc_decls$nextlx.symbol = (i64)24;
            }
            };
            return;
        }
        break;
    case 42:;
        {
            if (((u64)(*cc_lex$lxsptr) == '=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)48;
            }
            else {
                cc_decls$nextlx.symbol = (i64)25;
            }
;
            return;
        }
        break;
    case 47:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='/')) {
                cc_lex$readlinecomment();
                cc_decls$nextlx.symbol = (i64)57;
                cc_decls$nextlx.length = (i64)0;
                return;
            }
            else if (($temp=='*')) {
                cc_lex$readblockcomment();
            }
            else if (($temp=='=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)49;
                return;
            }
            else {
                cc_decls$nextlx.symbol = (i64)26;
                return;
            }
            };
        }
        break;
    case 37:;
        {
            if (((u64)(*cc_lex$lxsptr) == '=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)50;
            }
            else {
                cc_decls$nextlx.symbol = (i64)27;
            }
;
            return;
        }
        break;
    case 61:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='=')) {
                cc_decls$nextlx.symbol = (i64)40;
                ++(cc_lex$lxsptr);
            }
            else {
                cc_decls$nextlx.symbol = (i64)11;
            }
            };
            return;
        }
        break;
    case 60:;
        {
            switch ((i64)(u64)(*cc_lex$lxsptr)) {
            case 61:;
                {
                    ++(cc_lex$lxsptr);
                    cc_decls$nextlx.symbol = (i64)43;
                }
                break;
            case 60:;
                {
                    if (((u64)(*++(cc_lex$lxsptr)) == '=')) {
                        ++(cc_lex$lxsptr);
                        cc_decls$nextlx.symbol = (i64)54;
                    }
                    else {
                        cc_decls$nextlx.symbol = (i64)33;
                    }
;
                }
                break;
            default: {
                cc_decls$nextlx.symbol = (i64)42;
            }
            } //SW
;
            return;
        }
        break;
    case 62:;
        {
            switch ((i64)(u64)(*cc_lex$lxsptr)) {
            case 61:;
                {
                    ++(cc_lex$lxsptr);
                    cc_decls$nextlx.symbol = (i64)44;
                }
                break;
            case 62:;
                {
                    if (((u64)(*++(cc_lex$lxsptr)) == '=')) {
                        ++(cc_lex$lxsptr);
                        cc_decls$nextlx.symbol = (i64)55;
                    }
                    else {
                        cc_decls$nextlx.symbol = (i64)34;
                    }
;
                }
                break;
            default: {
                cc_decls$nextlx.symbol = (i64)45;
            }
            } //SW
;
            return;
        }
        break;
    case 38:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='&')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)32;
            }
            else if (($temp=='=')) {
                ++(cc_lex$lxsptr);
                cc_decls$nextlx.symbol = (i64)52;
            }
            else {
                cc_decls$nextlx.symbol = (i64)29;
            }
            };
            return;
        }
        break;
    case 39:;
        {
            cc_lex$lxreadstring((i64)39,(i64)0);
            return;
        }
        break;
    case 34:;
        {
            cc_lex$lxreadstring((i64)34,(i64)0);
            return;
        }
        break;
    case 32:;
    case 9:;
        {
        }
        break;
    case 10:;
        {
            ++(cc_decls$nextlx.lineno);
            cc_decls$nextlx.symbol = (i64)57;
            cc_decls$nextlx.length = (i64)0;
            if (!!(cc_lex$dowhitespace)) {
                cc_decls$nextlx.svalue = cc_lex$lxsptr;
                L269 :;
                switch ((i64)(u64)(*(cc_lex$lxsptr)++)) {
                case 32:;
                case 9:;
                    {
                    }
                    break;
                default: {
                    --(cc_lex$lxsptr);
                    goto L270 ;
                }
                } //SW
goto L269 ;
L270 :;
                ;
                cc_decls$nextlx.length = (cc_lex$lxsptr - cc_decls$nextlx.svalue);
            }
;
            return;
        }
        break;
    case 13:;
        {
        }
        break;
    case 33:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='=')) {
                cc_decls$nextlx.symbol = (i64)41;
                ++(cc_lex$lxsptr);
            }
            else {
                cc_decls$nextlx.symbol = (i64)36;
            }
            };
            return;
        }
        break;
    case 64:;
        {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"@ SEEN",NULL);
            msysc$m_print_i64((i64)cc_decls$nextlx.lineno,NULL);
            msysc$m_print_str(cc_decls$sourcefilenames[((i64)cc_decls$nextlx.fileno)],NULL);
            msysc$m_print_i64(cc_lex$lx_stackindex,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        break;
    case 0:;
        {
            //doeof:
L271 :;
;
            --(cc_lex$lxsptr);
            if (!!(cc_lex$lx_stackindex)) {
                cc_lex$unstacksourcefile();
                cc_decls$nextlx.symbol = (i64)57;
            }
            else {
                cc_decls$nextlx.symbol = (i64)58;
            }
;
            return;
        }
        break;
    case 12:;
        {
        }
        break;
    case 239:;
        {
            cc_lex$lxsptr += (i64)2;
        }
        break;
    default: {
        if (((i64)128<=(i64)(u64)(*(cc_lex$lxsptr - (i64)1)) && (i64)(u64)(*(cc_lex$lxsptr - (i64)1))<=(i64)255)) {
            goto L263 ;
;
        }
;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"ERROR CHAR",NULL);
        msysc$m_print_c8((u64)(*(cc_lex$lxsptr - (i64)1)),NULL);
        msysc$m_print_i64((i64)(u64)(*(cc_lex$lxsptr - (i64)1)),NULL);
        msysc$m_print_i64(cc_lex$lx_stackindex,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lex$lxerror((byte*)"ERROR CHAR");
        cc_decls$nextlx.symbol = (i64)1;
        return;
    }
    } //SW
goto L261 ;
L262 :;
    ;
}

static void cc_lex$readrealnumber(u8 *pstart,u8 *intstart,i64 intlen,i64 base) {
        u8 *  fractstart;
        i64 fractlen;
        i64 expon;
        i64 badexpon;
        r64 basex;
        r64 x;
        r64 expbase;
        i64 pref;
        u8 realstr[512];
        u8 *  rs;
        u8 expstr[32];
    if ((base != (i64)10)) {
        cc_lex$old_readrealnumber(pstart,intstart,intlen,base);
        return;
    }
;
    fractstart = 0;
    fractlen = (i64)0;
    expon = (i64)0;
    if (((u64)(*cc_lex$lxsptr) == '.')) {
        fractstart = ++(cc_lex$lxsptr);
        fractlen = (cc_lex$scannumber(base) - fractstart);
    }
;
    badexpon = (i64)0;
        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='e') || ($temp=='E')) {
        if ((base != (i64)16)) {
            ++(cc_lex$lxsptr);
            expon = cc_lex$readexponent(&badexpon);
        }
;
    }
    else if (($temp=='p') || ($temp=='P')) {
        if ((base == (i64)16)) {
            ++(cc_lex$lxsptr);
            expon = cc_lex$readexponent(&badexpon);
        }
;
    }
    };
    if (!!(badexpon)) {
        --(cc_lex$lxsptr);
        cc_lex$readalphanumeric(pstart);
        return;
    }
;
        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='f') || ($temp=='F') || ($temp=='l') || ($temp=='L')) {
        ++(cc_lex$lxsptr);
    }
    else {
        if (!!((u64)cc_lex$alphamap[((i64)(u64)(*cc_lex$lxsptr))])) {
            cc_lex$readalphanumeric(pstart);
            return;
        }
;
    }
    };
    if ((base == (i64)16)) {
        realstr[((i64)1)-1] = '0';
        realstr[((i64)2)-1] = 'x';
        rs = (u8 *)&realstr[((i64)3)-1];
        pref = (i64)2;
    }
    else {
        rs = (u8 *)&realstr[((i64)1)-1];
        pref = (i64)0;
    }
;
    if (((intlen + fractlen) > (i64)500)) {
        cc_lex$lxerror((byte*)"Real too long");
    }
;
    if (!!(intlen)) {
        memcpy((void *)rs,(void *)intstart,(u64)intlen);
    }
;
    if (!!(fractlen)) {
        memcpy((void *)(rs + intlen),(void *)fractstart,(u64)fractlen);
    }
;
    expbase = (basex = (r64)base);
    if ((base == (i64)10)) {
        expon -= fractlen;
    }
    else {
        expon -= (fractlen * (i64)4);
        expbase = (double)2.;
    }
;
    realstr[((((pref + intlen) + fractlen) + (i64)1))-1] = (u64)0u;
    msysc$m_print_startstr(expstr);
    msysc$m_print_str(((base == (i64)10) ? (byte*)"e" : (byte*)"p"),NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(expon,NULL);
    msysc$m_print_end();
    ;
    strcat((u8 *)realstr,(u8 *)expstr);
    if ((base != (i64)10)) {
        cc_lex$lxerror((byte*)"Non-base-10 floats temporarily unavailable");
    }
;
    x = strtod((u8 *)realstr,0);
    cc_decls$nextlx.symbol = (i64)61;
    cc_decls$nextlx.subcode = (i64)12;
    cc_decls$nextlx.xvalue = x;
    cc_lex$setnumberoffset((intstart - cc_lex$lxstart));
    cc_decls$nextlx.length = (cc_lex$lxsptr - intstart);
}

static i64 cc_lex$readexponent(i64 *badexpon) {
        u8 *  numstart;
        i64 length;
        i64 neg;
        i64 c;
        i64 a;
        i64 $av_1;
    neg = (i64)0;
        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='+')) {
        ++(cc_lex$lxsptr);
    }
    else if (($temp=='-')) {
        ++(cc_lex$lxsptr);
        neg = (i64)1;
    }
    };
    numstart = cc_lex$lxsptr;
    length = (cc_lex$scannumber((i64)10) - numstart);
    if ((length == (i64)0)) {
        (*badexpon) = (i64)1;
        return (i64)0;
    }
;
    a = (i64)0;
    $av_1 = length;
    while ($av_1-- > 0) {
L272 :;
        c = (i64)(u64)(*(numstart)++);
        a = (((a * (i64)10) + c) - (i64)48);
L273 :;
    }
L274 :;
    ;
    if (!!(neg)) {
        return -(a);
    }
    else {
        return a;
    }
;
}

static void cc_lex$lxerror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"\nLex error",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str((byte*)"in:",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(cc_decls$sourcefilepaths[(cc_lex$getfileno())],NULL);
    msysc$m_print_str((byte*)"Line:",NULL);
    msysc$m_print_i64((i64)cc_decls$nextlx.lineno,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)11);
}

void cc_lex$printsymbol(struct cc_decls$tokenrec *lp) {
        struct cc_decls$tokenrec l;
    l = (*lp);
    printf((byte*)"%-18s",cc_tables$symbolnames[((i64)l.symbol)-1]);
        {i64 $temp = (i64)l.symbol;
if (($temp==(i64)69)) {
        cc_lex$printstrn((*l.symptr).name,(i64)(*l.symptr).namelen,0);
    }
    else if (($temp==(i64)60)) {
        msysc$m_print_startcon();
        msysc$m_print_i64(l.value,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
        cc_lex$shownumberstr((struct cc_decls$tokenrec *)lp,0);
    }
    else if (($temp==(i64)61)) {
        msysc$m_print_startcon();
        msysc$m_print_r64(l.xvalue,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
        cc_lex$shownumberstr((struct cc_decls$tokenrec *)lp,0);
    }
    else if (($temp==(i64)64)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\"",NULL);
        msysc$m_print_end();
        ;
        cc_lex$printstrn(l.svalue,(i64)l.length,0);
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\"",NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)62)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"'",NULL);
        msysc$m_print_end();
        ;
        cc_lex$printstrn(l.svalue,(i64)l.length,0);
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"'",NULL);
        msysc$m_print_end();
        ;
    }
    else {
        if (!!((i64)l.subcode)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"#",NULL);
            msysc$m_print_i64((i64)l.subcode,NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    };
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void cc_lex$lexsetup(void) {
        i64 i;
    cc_lex$inithashtable();
    cc_lex$fillhashtable();
    for (i=(i64)0;i<=(i64)255;++i) {
L275 :;
        switch (i) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 36:;
        case 95:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 128:;
        case 129:;
        case 130:;
        case 131:;
        case 132:;
        case 133:;
        case 134:;
        case 135:;
        case 136:;
        case 137:;
        case 138:;
        case 139:;
        case 140:;
        case 141:;
        case 142:;
        case 143:;
        case 144:;
        case 145:;
        case 146:;
        case 147:;
        case 148:;
        case 149:;
        case 150:;
        case 151:;
        case 152:;
        case 153:;
        case 154:;
        case 155:;
        case 156:;
        case 157:;
        case 158:;
        case 159:;
        case 160:;
        case 161:;
        case 162:;
        case 163:;
        case 164:;
        case 165:;
        case 166:;
        case 167:;
        case 168:;
        case 169:;
        case 170:;
        case 171:;
        case 172:;
        case 173:;
        case 174:;
        case 175:;
        case 176:;
        case 177:;
        case 178:;
        case 179:;
        case 180:;
        case 181:;
        case 182:;
        case 183:;
        case 184:;
        case 185:;
        case 186:;
        case 187:;
        case 188:;
        case 189:;
        case 190:;
        case 191:;
        case 192:;
        case 193:;
        case 194:;
        case 195:;
        case 196:;
        case 197:;
        case 198:;
        case 199:;
        case 200:;
        case 201:;
        case 202:;
        case 203:;
        case 204:;
        case 205:;
        case 206:;
        case 207:;
        case 208:;
        case 209:;
        case 210:;
        case 211:;
        case 212:;
        case 213:;
        case 214:;
        case 215:;
        case 216:;
        case 217:;
        case 218:;
        case 219:;
        case 220:;
        case 221:;
        case 222:;
        case 223:;
        case 224:;
        case 225:;
        case 226:;
        case 227:;
        case 228:;
        case 229:;
        case 230:;
        case 231:;
        case 232:;
        case 233:;
        case 234:;
        case 235:;
        case 236:;
        case 237:;
        case 238:;
        case 239:;
        case 240:;
        case 241:;
        case 242:;
        case 243:;
        case 244:;
        case 245:;
        case 246:;
        case 247:;
        case 248:;
        case 249:;
        case 250:;
        case 251:;
        case 252:;
        case 253:;
        case 254:;
        case 255:;
            {
                cc_lex$alphamap[(i)] = (u64)1u;
            }
            break;
        } //SW
;
        switch (i) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                cc_lex$digitmap[(i)] = (u64)1u;
            }
            break;
        } //SW
;
        cc_lex$commentmap[(i)] = (u64)1u;
        cc_lex$linecommentmap[(i)] = (u64)1u;
        cc_lex$spacemap[(i)] = (u64)0u;
L276 :;
    }
L277 :;
    ;
    cc_lex$commentmap[((i64)42)] = (u64)0u;
    cc_lex$commentmap[((i64)0)] = (u64)0u;
    cc_lex$commentmap[((i64)10)] = (u64)0u;
    cc_lex$linecommentmap[((i64)0)] = (u64)0u;
    cc_lex$linecommentmap[((i64)92)] = (u64)0u;
    cc_lex$linecommentmap[((i64)10)] = (u64)0u;
    cc_lex$spacemap[((i64)32)] = (u64)1u;
    cc_lex$spacemap[((i64)9)] = (u64)1u;
    cc_lex$normaltkx.symbol = (i64)57;
    cc_lex$npastedtokens = (i64)0;
}

void cc_lex$printstrn(u8 *s,i64 length,void *f) {
    if (!!(length)) {
        if ((f == 0)) {
            msysc$m_print_startcon();
            msysc$m_print_i64(length,(byte*)"v");
            msysc$m_print_nogap();
            msysc$m_print_str(s,(byte*)".*");
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startfile(f);
            msysc$m_print_i64(length,(byte*)"v");
            msysc$m_print_nogap();
            msysc$m_print_str(s,(byte*)".*");
            msysc$m_print_end();
            ;
        }
;
    }
;
}

static u8 *cc_lex$scannumber(i64 base) {
        u8 *  dest;
        i64 c;
    dest = cc_lex$lxsptr;
    L278 :;
    switch ((c = (i64)(u64)(*(cc_lex$lxsptr)++))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            (*(dest)++) = (u64)c;
            if ((c >= ((i64)48 + base))) {
                cc_lex$lxerror((byte*)"Digit out of range");
            }
;
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
        {
            if ((base == (i64)16)) {
                (*(dest)++) = (u64)c;
            }
            else {
                --(cc_lex$lxsptr);
                goto L279 ;
            }
;
        }
        break;
    case 95:;
    case 39:;
    case 96:;
        {
        }
        break;
    default: {
        --(cc_lex$lxsptr);
        goto L279 ;
    }
    } //SW
goto L278 ;
L279 :;
    ;
    return dest;
}

static i64 cc_lex$lookup(void) {
        i64 j;
        i64 wrapped;
        i64 length;
    //retry:
L280 :;
;
    j = (cc_lex$lxhashvalue & cc_decls$hstmask);
    wrapped = (i64)0;
    L281 :;
    while (1) {
        cc_decls$nextlx.symptr = (struct cc_decls$strec *)(*cc_decls$hashtable)[(j)];
        length = (i64)(*cc_decls$nextlx.symptr).namelen;
        if (!(!!(length))) {
            goto L282 ;
        }
;
        if ((length == (i64)cc_decls$nextlx.length)) {
            if ((memcmp((void *)(*cc_decls$nextlx.symptr).name,(void *)cc_lex$lxsvalue,(u64)length) == (i64)0)) {
                return (i64)1;
            }
;
        }
;
        if ((++(j) >= cc_decls$hstsize)) {
            if (!!(wrapped)) {
                mlib$abortprogram((byte*)"HASHTABLE FULL");
            }
;
            wrapped = (i64)1;
            j = (i64)0;
        }
;
    }
L282 :;
    ;
    if ((cc_lex$nhstsymbols >= cc_lex$hstthreshold)) {
        cc_lex$newhashtable();
        cc_lex$lxhashvalue = (i64)cc_lex$gethashvalue(cc_lex$lxsvalue,(i64)cc_decls$nextlx.length);
        goto L280 ;
;
    }
;
    (*cc_decls$nextlx.symptr).name = cc_lex$lxsvalue;
    (*cc_decls$nextlx.symptr).namelen = (i64)cc_decls$nextlx.length;
    (*cc_decls$nextlx.symptr).symbol = (i64)69;
    ++(cc_lex$nhstsymbols);
    return (i64)0;
}

u64 cc_lex$gethashvalue(u8 *s,i64 length) {
        u64 hsum;
        i64 $av_1;
    if ((length == (i64)-1)) {
        length = strlen(s);
    }
;
    hsum = (u64)0u;
    $av_1 = length;
    while ($av_1-- > 0) {
L283 :;
        hsum = (((hsum << (i64)4) - hsum) + (u64)(u64)(*(s)++));
L284 :;
    }
L285 :;
    ;
    return ((hsum << (i64)5) - hsum);
}

static void cc_lex$inithashtable(void) {
        i64 i;
    cc_decls$hashtable = (struct cc_decls$strec *(*)[])mlib$pcm_alloc((cc_decls$hstsize * (i64)8));
    cc_decls$hstmask = (cc_decls$hstsize - (i64)1);
    for (i=(i64)0;i<=cc_decls$hstmask;++i) {
L286 :;
        (*cc_decls$hashtable)[(i)] = (struct cc_decls$strec *)mlib$pcm_allocz((i64)128);
L287 :;
    }
L288 :;
    ;
    cc_lex$nhstsymbols = (i64)0;
    cc_lex$hstthreshold = (((i64)6 * cc_decls$hstsize) / (i64)10);
}

static void cc_lex$fillhashtable(void) {
        i64 i;
    for (i=(i64)1;i<=(i64)77;++i) {
L289 :;
        cc_lex$lxsvalue = cc_tables$stnames[(i)-1];
        if (((i64)cc_tables$stsymbols[(i)-1] == (i64)70)) {
            cc_lex$lxsvalue = mlib$pcm_copyheapstring(cc_lex$lxsvalue);
        }
;
        cc_decls$nextlx.length = strlen(cc_lex$lxsvalue);
        cc_lex$lxhashvalue = (i64)cc_lex$gethashvalue(cc_lex$lxsvalue,(i64)cc_decls$nextlx.length);
        if (!!(cc_lex$lookup())) {
            msysc$m_print_startcon();
            msysc$m_print_str(cc_tables$stnames[(i)-1],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mlib$abortprogram((byte*)"Duplicate symbol table entry");
        }
;
        (*cc_decls$nextlx.symptr).symbol = (i64)cc_tables$stsymbols[(i)-1];
        (*cc_decls$nextlx.symptr).subcode = (i64)cc_tables$stsubcodes[(i)-1];
L290 :;
    }
L291 :;
    ;
}

static i64 cc_lex$dolexdirective(void) {
        struct cc_decls$strec *  d;
        u8 *  p;
        u8 *  pstart;
        u8 *  s;
        i64 cond;
        i64 c;
        i64 syshdr;
        i64 dir;
        i64 length;
        i64 allowmacros;
        u8 filename[300];
    pstart = cc_lex$lxsptr;
    dir = cc_lex$getlexdirective();
    if ((dir == (i64)0)) {
        cc_lex$printstrn(pstart,(cc_lex$lxsptr - pstart),0);
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lex$lxerror((byte*)"Invalid # directive");
    }
;
    if ((dir==(i64)7)) {
        cc_lex$isincludefile = (i64)1;
        L292 :;
        while ((((u64)(*cc_lex$lxsptr) == ' ') || ((i64)(u64)(*cc_lex$lxsptr) == (i64)9))) {
            ++(cc_lex$lxsptr);
L293 :;
        }
L294 :;
        ;
        allowmacros = (i64)((u64)(*cc_lex$lxsptr) != '<');
        cc_lex$lexm();
        cc_lex$isincludefile = (i64)0;
        if (((i64)cc_decls$nextlx.symbol == (i64)42)) {
            syshdr = (i64)1;
            p = (u8 *)filename;
            if (!!(allowmacros)) {
                L295 :;
                while (1) {
                    cc_lex$lexm();
                                        {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)58) || ($temp==(i64)57)) {
                        cc_lex$lxerror((byte*)"Bad include file");
                    }
                    else if (($temp==(i64)45)) {
                        goto L296 ;
                    }
                    else {
                        s = cc_lex$strtoken((struct cc_decls$tokenrec *)&cc_decls$nextlx,&length);
                        memcpy((void *)p,(void *)s,(u64)length);
                        p += length;
                    }
                    };
                }
L296 :;
                ;
            }
            else {
                L297 :;
                while (1) {
                    c = (i64)(u64)(*(cc_lex$lxsptr)++);
                    if ((c==(i64)62)) {
                        goto L298 ;
                    }
                    else if ((c==(i64)10) || (c==(i64)0)) {
                        cc_lex$lxerror((byte*)"include: > expected");
                    }
                    else {
                        (*(p)++) = (u64)c;
                    }
;
                }
L298 :;
                ;
            }
;
            (*p) = (u64)0u;
        }
        else if (((i64)cc_decls$nextlx.symbol == (i64)64)) {
            syshdr = (i64)0;
            strcpy((u8 *)filename,cc_decls$nextlx.svalue);
        }
        else {
            cc_lex$lxerror((byte*)"include?");
        }
;
        cc_lex$lexm();
        if (!!(cc_decls$fshowincludes)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"INCLUDE",NULL);
            msysc$m_print_str(filename,NULL);
            msysc$m_print_str((byte*)"FROM",NULL);
            msysc$m_print_str(cc_decls$sourcefilepaths[(cc_lex$getfileno())],NULL);
            msysc$m_print_i64((i64)cc_decls$nextlx.lineno,NULL);
            msysc$m_print_str((byte*)"NSOURCEFILES=",NULL);
            msysc$m_print_i64(cc_decls$nsourcefiles,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        ++(cc_lex$nincludes);
        cc_lex$stacksourcefile((u8 *)filename,syshdr);
        if (!(!!(syshdr))) {
            cc_lex$addautomodule((u8 *)filename,cc_lex$getfileno());
        }
;
    }
    else if ((dir==(i64)1)) {
        cc_lex$dodefine();
    }
    else if ((dir==(i64)10)) {
        cc_lex$lexreadtoken();
        if (((i64)cc_decls$nextlx.symbol != (i64)69)) {
            cc_lex$lxerror((byte*)"undef: name expected");
        }
;
        d = (struct cc_decls$strec *)cc_decls$nextlx.symptr;
        if (((i64)(*d).nameid != (i64)1)) {
        }
        else {
            (*d).nameid = (i64)0;
            (*d).symbol = (i64)(*cc_decls$nextlx.symptr).oldsymbol;
            (*d).mparamlist = 0;
            (*d).attribs.ax_flmacro = (i64)0;
        }
;
    }
    else if ((dir==(i64)8)) {
        cond = cc_lex$getifdef();
        goto L299 ;
;
    }
    else if ((dir==(i64)9)) {
        cond = (i64)!(!!(cc_lex$getifdef()));
        goto L299 ;
;
    }
    else if ((dir==(i64)3)) {
        cond = cc_lex$getifexpr();
        //doif:
L299 :;
;
        ++(cc_lex$ifcondlevel);
        if (!!(cond)) {
            return (i64)0;
        }
        else {
            //doskipcode:
L300 :;
;
            dir = cc_lex$skipcode();
            if ((dir==(i64)4)) {
                cond = cc_lex$getifexpr();
                if (!!(cond)) {
                    return (i64)0;
                }
;
                goto L300 ;
;
            }
            else if ((dir==(i64)5)) {
            }
            else if ((dir==(i64)6)) {
                --(cc_lex$ifcondlevel);
            }
;
        }
;
    }
    else if ((dir==(i64)4) || (dir==(i64)5)) {
        if (!(!!(cc_lex$ifcondlevel))) {
            cc_lex$lxerror((byte*)"#if missing/elif/else");
        }
;
        L301 :;
        do {
            dir = cc_lex$skipcode();
L302 :;
        }
        while (!(dir == (i64)6));
L303 :;
        ;
        --(cc_lex$ifcondlevel);
    }
    else if ((dir==(i64)6)) {
        if (!(!!(cc_lex$ifcondlevel))) {
            cc_lex$lxerror((byte*)"#if missing/endif");
        }
;
        --(cc_lex$ifcondlevel);
    }
    else if ((dir==(i64)18)) {
    }
    else if ((dir==(i64)19)) {
        L304 :;
        do {
            cc_lex$lexreadtoken();
L305 :;
        }
        while (!((i64)cc_decls$nextlx.symbol == (i64)57));
L306 :;
        ;
    }
    else if ((dir==(i64)11)) {
        cc_lex$lexm();
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"#ERROR:",NULL);
        msysc$m_print_end();
        ;
        cc_lex$showtoken((struct cc_decls$tokenrec *)&cc_decls$nextlx);
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lex$lxerror((byte*)"ABORTING");
        goto L307 ;
;
    }
    else if ((dir==(i64)13)) {
        cc_lex$lexm();
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"#MESSAGE ",NULL);
        msysc$m_print_end();
        ;
        if (((i64)cc_decls$nextlx.symbol == (i64)57)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)" Line",NULL);
            msysc$m_print_i64(((i64)cc_decls$nextlx.lineno + (i64)1),NULL);
            msysc$m_print_str(cc_decls$sourcefilenames[(cc_lex$getfileno())],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else {
            cc_lex$showtoken((struct cc_decls$tokenrec *)&cc_decls$nextlx);
            msysc$m_print_startcon();
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        goto L307 ;
;
    }
    else if ((dir==(i64)12) || (dir==(i64)14)) {
        cc_lex$lexm();
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"#WARNING:",NULL);
        msysc$m_print_end();
        ;
        cc_lex$showtoken((struct cc_decls$tokenrec *)&cc_decls$nextlx);
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        //dowarning2:
L307 :;
;
        L308 :;
        while ((((i64)cc_decls$nextlx.symbol != (i64)57) && ((i64)cc_decls$nextlx.symbol != (i64)58))) {
            cc_lex$lexm();
L309 :;
        }
L310 :;
        ;
        if ((dir == (i64)14)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Press key...",NULL);
            msysc$m_print_end();
            ;
            mwindows$os_getch();
            msysc$m_print_startcon();
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
    }
    else if ((dir==(i64)20)) {
        cc_lex$dopragmadir();
    }
    else if ((dir==(i64)15)) {
        cc_decls$debug = (i64)1;
    }
    else if ((dir==(i64)16)) {
        cc_decls$debug = (i64)0;
    }
    else if ((dir==(i64)17)) {
        cc_lex$lexreadtoken();
        if (((i64)cc_decls$nextlx.symbol == (i64)69)) {
            d = (struct cc_decls$strec *)cc_decls$nextlx.symptr;
            msysc$m_print_startcon();
            msysc$m_print_i64((i64)cc_decls$nextlx.lineno,NULL);
            msysc$m_print_str(cc_decls$sourcefilenames[(cc_lex$getfileno())],NULL);
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"SHOW MACRO",NULL);
            msysc$m_print_str(cc_lib$getstname((struct cc_decls$strec *)d),NULL);
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_end();
            ;
            if (((i64)(*d).nameid == (i64)1)) {
                cc_lex$showtokens((byte*)"tokens:",(struct cc_decls$tokenrec *)(*d).tokenlist);
                msysc$m_print_startcon();
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
            else {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"not a macro",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Not a name",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
    }
    else {
        //skip:
L311 :;
;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"DIRECTIVE NOT IMPL:",NULL);
        msysc$m_print_str(cc_tables$sourcedirnames[(dir)-1],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lex$lxsptr = pstart;
        cc_decls$nextlx.symbol = (i64)4;
        return (i64)1;
        cc_lex$lxerror((byte*)"Directive not implemented");
    }
;
    return (i64)0;
}

static i64 cc_lex$getlexdirective(void) {
        struct cc_decls$strec *  d;
    cc_lex$lexreadtoken();
        {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)69)) {
    }
    else if (($temp==(i64)57)) {
        return (i64)18;
    }
    else if (($temp==(i64)60)) {
        L312 :;
        do {
            cc_lex$lexreadtoken();
L313 :;
        }
        while (!(((i64)cc_decls$nextlx.symbol == (i64)57) || ((i64)cc_decls$nextlx.symbol == (i64)58)));
L314 :;
        ;
        return (i64)18;
    }
    else {
        return (i64)0;
    }
    };
        {i64 $temp = (i64)(*cc_decls$nextlx.symptr).symbol;
if (($temp==(i64)70)) {
        return (i64)(*cc_decls$nextlx.symptr).subcode;
    }
    else if (($temp==(i64)73)) {
        return (i64)3;
    }
    else if (($temp==(i64)74)) {
        return (i64)5;
    }
    else if (($temp==(i64)57)) {
        return (i64)18;
    }
    };
    d = (struct cc_decls$strec *)cc_decls$nextlx.symptr;
    if (((i64)(*d).nameid == (i64)1)) {
        if (((i64)(*d).oldsymbol == (i64)70)) {
            return (i64)(*d).subcode;
        }
;
    }
;
    return (i64)0;
}

void cc_lex$startlex(u8 *caption,i64 fileno) {
    cc_lex$ifcondlevel = (i64)0;
    cc_lex$lx_stackindex = (i64)0;
    cc_lex$noexpand = (i64)0;
    cc_lex$normaltk = (struct cc_decls$tokenrec *)&cc_lex$normaltkx;
    cc_lex$lx_stackindex = (i64)0;
    cc_lex$ifcondlevel = (i64)0;
    cc_lex$firstsymbol = (i64)1;
    cc_lex$npastedtokens = (i64)0;
    cc_lex$isincludefile = (i64)0;
    cc_lex$tkptr = 0;
    cc_lex$lxstart = (cc_lex$lxsptr = cc_decls$sourcefiletext[(fileno)]);
    cc_lex$setfileno(fileno);
    cc_decls$nextlx.lineno = (i64)1;
    cc_decls$nextlx.numberoffset = (i64)0;
    cc_decls$nextlx.symbol = (i64)57;
    cc_decls$nextlx.subcode = (i64)0;
    cc_lex$lex();
}

void cc_lex$endlex(void) {
    if (!!(cc_lex$ifcondlevel)) {
        msysc$m_print_startcon();
        msysc$m_print_i64(cc_lex$ifcondlevel,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lex$lxerror((byte*)"#endif missing");
    }
;
}

void cc_lex$ps(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":::",NULL);
    msysc$m_print_end();
    ;
    cc_lex$printsymbol((struct cc_decls$tokenrec *)&cc_decls$lx);
}

void cc_lex$psnext(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":##",NULL);
    msysc$m_print_end();
    ;
    cc_lex$printsymbol((struct cc_decls$tokenrec *)&cc_decls$nextlx);
}

i64 cc_lex$gethashtablesize(void) {
        i64 i;
        i64 n;
    n = (i64)0;
    for (i=(i64)0;i<=cc_decls$hstmask;++i) {
L315 :;
        if (!!((*(*cc_decls$hashtable)[(i)]).name)) {
            ++(n);
        }
;
L316 :;
    }
L317 :;
    ;
    return n;
}

static void cc_lex$readlinecomment(void) {
    L318 :;
    while (1) {
        L320 :;
        while (!!((u64)cc_lex$linecommentmap[((i64)(u64)(*++(cc_lex$lxsptr)))])) {
L321 :;
        }
L322 :;
        ;
                {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp==(u64)10u)) {
            ++(cc_lex$lxsptr);
            goto L319 ;
        }
        else if (($temp==(u64)0u)) {
            goto L319 ;
        }
        else if (($temp==(u64)92u)) {
            ++(cc_lex$lxsptr);
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp==(u64)13u)) {
                cc_lex$lxsptr += (i64)2;
                ++(cc_decls$nextlx.lineno);
            }
            else if (($temp==(u64)10u)) {
                ++(cc_lex$lxsptr);
                ++(cc_decls$nextlx.lineno);
            }
            };
        }
        };
    }
L319 :;
    ;
    ++(cc_decls$nextlx.lineno);
}

static void cc_lex$readblockcomment(void) {
    L323 :;
    while (1) {
        L325 :;
        while (!!((u64)cc_lex$commentmap[((i64)(u64)(*++(cc_lex$lxsptr)))])) {
L326 :;
        }
L327 :;
        ;
                {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp==(u64)10u)) {
            ++(cc_decls$nextlx.lineno);
        }
        else if (($temp==(u64)0u)) {
            cc_lex$lxerror((byte*)"block comment eof");
        }
        else if (($temp=='*')) {
            if (((u64)(*(cc_lex$lxsptr + (i64)1)) == '/')) {
                cc_lex$lxsptr += (i64)2;
                goto L324 ;
            }
;
        }
        };
    }
L324 :;
    ;
}

static void cc_lex$readhex(u8 *pstart) {
        u64 aa;
        u64 c;
        i64 length;
        i64 leading;
        i64 ll;
        i64 usigned;
        u8 *  p;
    aa = (u64)0u;
    p = cc_lex$lxsptr;
    leading = (i64)1;
    ll = (usigned = (i64)0);
    length = (i64)0;
    L328 :;
    switch ((i64)(c = (u64)(u64)(*(cc_lex$lxsptr)++))) {
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            leading = (i64)0;
            aa = (u64)(((i64)aa * (i64)16) + (i64)(c - (u64)48u));
            ++(length);
        }
        break;
    case 48:;
        {
            if (!!(leading)) {
                ++(p);
            }
            else {
                ++(length);
                aa = (u64)((i64)aa * (i64)16);
            }
;
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
        {
            leading = (i64)0;
            ++(length);
            aa = (u64)((i64)(aa * (u64)16u) + ((i64)(c - (u64)65u) + (i64)10));
        }
        break;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
        {
            leading = (i64)0;
            ++(length);
            aa = (u64)((i64)(aa * (u64)16u) + ((i64)(c - (u64)97u) + (i64)10));
        }
        break;
    case 46:;
    case 80:;
    case 112:;
        {
            --(cc_lex$lxsptr);
            cc_lex$readrealnumber(pstart,p,(cc_lex$lxsptr - p),(i64)16);
            return;
        }
        break;
    case 76:;
    case 108:;
        {
            ++(ll);
            if ((ll > (i64)2)) {
                cc_lex$lxerror((byte*)"-LL?");
            }
;
        }
        break;
    case 85:;
    case 117:;
        {
            if (!!(usigned)) {
                cc_lex$lxerror((byte*)"-U?");
            }
;
            usigned = (i64)1;
        }
        break;
    default: {
        --(cc_lex$lxsptr);
        goto L329 ;
    }
    } //SW
goto L328 ;
L329 :;
    ;
    cc_lex$setnumberoffset((pstart - cc_lex$lxstart));
    cc_decls$nextlx.length = (cc_lex$lxsptr - pstart);
    if ((length > (i64)16)) {
        cc_lex$lxerror((byte*)"Overflow in hex number");
    }
;
    cc_decls$nextlx.symbol = (i64)60;
    if ((aa > (u64)9223372036854775807u)) {
        cc_decls$nextlx.subcode = (i64)10;
    }
    else if ((aa > (u64)4294967295u)) {
        cc_decls$nextlx.subcode = (i64)5;
    }
    else if ((aa > (u64)2147483647u)) {
        cc_decls$nextlx.subcode = (i64)9;
    }
    else {
        cc_decls$nextlx.subcode = (i64)4;
    }
;
    cc_decls$nextlx.value = (i64)aa;
    cc_lex$checknumbersuffix();
}

static void cc_lex$readbinary(u8 *pstart) {
        u64 aa;
        i64 c;
        i64 length;
        i64 leading;
        u8 *  p;
        i64 $av_1;
    aa = (u64)0u;
    p = cc_lex$lxsptr;
    leading = (i64)1;
    L330 :;
    switch ((c = (i64)(u64)(*(cc_lex$lxsptr)++))) {
    case 49:;
        {
            leading = (i64)0;
        }
        break;
    case 48:;
        {
            if (!!(leading)) {
                ++(p);
            }
;
        }
        break;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            cc_lex$lxerror((byte*)"Binary bad digit");
        }
        break;
    case 46:;
        {
            cc_lex$lxerror((byte*)"Binary fp");
        }
        break;
    default: {
        --(cc_lex$lxsptr);
        goto L331 ;
    }
    } //SW
goto L330 ;
L331 :;
    ;
    length = (cc_lex$lxsptr - p);
    cc_lex$setnumberoffset((pstart - cc_lex$lxstart));
    cc_decls$nextlx.length = (cc_lex$lxsptr - pstart);
    if ((length > (i64)64)) {
        cc_lex$lxerror((byte*)"Overflow in binary number");
    }
;
    $av_1 = length;
    while ($av_1-- > 0) {
L332 :;
        aa = (u64)((((i64)aa * (i64)2) + (i64)(u64)(*(p)++)) - (i64)48);
L333 :;
    }
L334 :;
    ;
    cc_decls$nextlx.symbol = (i64)60;
    cc_decls$nextlx.subcode = (i64)4;
    if ((aa >= (u64)2147483647u)) {
        cc_decls$nextlx.subcode = (i64)5;
    }
;
    cc_decls$nextlx.value = (i64)aa;
    cc_lex$checknumbersuffix();
}

static void cc_lex$readoctal(u8 *pstart) {
        u64 aa;
        i64 c;
        i64 length;
        i64 res;
        i64 leading;
        i64 ll;
        i64 usigned;
        u8 *  p;
        i64 $av_1;
    aa = (u64)0u;
    p = cc_lex$lxsptr;
    leading = (i64)1;
    ll = (usigned = (i64)0);
    length = (i64)0;
    L335 :;
    switch ((c = (i64)(u64)(*(cc_lex$lxsptr)++))) {
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
        {
            leading = (i64)0;
            ++(length);
        }
        break;
    case 48:;
        {
            if (!!(leading)) {
                ++(p);
            }
            else {
                ++(length);
            }
;
        }
        break;
    case 46:;
        {
            --(cc_lex$lxsptr);
            cc_lex$readrealnumber(pstart,p,(cc_lex$lxsptr - p),(i64)10);
            return;
        }
        break;
    case 76:;
    case 108:;
        {
            ++(ll);
            if ((ll > (i64)2)) {
                cc_lex$lxerror((byte*)"-LL?");
            }
;
        }
        break;
    case 85:;
    case 117:;
        {
            if (!!(usigned)) {
                cc_lex$lxerror((byte*)"-U?");
            }
;
            usigned = (i64)1;
        }
        break;
    default: {
        if (!!((u64)cc_lex$alphamap[(c)])) {
            //doalpha:
L337 :;
;
            cc_lex$readalphanumeric(pstart);
            return;
        }
;
        --(cc_lex$lxsptr);
        goto L336 ;
    }
    } //SW
goto L335 ;
L336 :;
    ;
    cc_lex$setnumberoffset((pstart - cc_lex$lxstart));
    cc_decls$nextlx.length = (cc_lex$lxsptr - pstart);
    if (((length > (i64)22) || ((length == (i64)22) && ((res = mlib$cmpstringn(p,(byte*)"1777777777777777777777",(i64)22)) > (i64)0)))) {
        cc_lex$lxerror((byte*)"Overflow in octal number");
    }
;
    $av_1 = length;
    while ($av_1-- > 0) {
L338 :;
        aa = (u64)((((i64)aa * (i64)8) + (i64)(u64)(*(p)++)) - (i64)48);
L339 :;
    }
L340 :;
    ;
    cc_decls$nextlx.symbol = (i64)60;
    cc_decls$nextlx.subcode = (i64)4;
    if ((aa >= (u64)2147483647u)) {
        cc_decls$nextlx.subcode = (i64)5;
    }
;
    cc_decls$nextlx.value = (i64)aa;
    cc_lex$checknumbersuffix();
}

static void cc_lex$readdecimal(u8 *pstart) {
        u64 aa;
        i64 c;
        i64 length;
        i64 res;
        byte ll;
        byte usigned;
        u8 *  p;
        i64 $av_1;
    aa = (u64)0u;
    ll = (usigned = (i64)0);
    p = --(cc_lex$lxsptr);
    L341 :;
    while (!!((u64)cc_lex$digitmap[((i64)(u64)(*++(cc_lex$lxsptr)))])) {
L342 :;
    }
L343 :;
    ;
    L344 :;
    while (((u64)(*p) == '0')) {
        ++(p);
L345 :;
    }
L346 :;
    ;
    length = (cc_lex$lxsptr - p);
    L347 :;
    switch ((c = (i64)(u64)(*(cc_lex$lxsptr)++))) {
    case 46:;
    case 69:;
    case 101:;
        {
            --(cc_lex$lxsptr);
            cc_lex$readrealnumber(pstart,p,(cc_lex$lxsptr - p),(i64)10);
            return;
        }
        break;
    case 76:;
    case 108:;
        {
            ++(ll);
            if (((i64)ll > (i64)2)) {
                cc_lex$lxerror((byte*)"-LL?");
            }
;
        }
        break;
    case 85:;
    case 117:;
        {
            if (!!((i64)usigned)) {
                cc_lex$lxerror((byte*)"-U?");
            }
;
            usigned = (i64)1;
        }
        break;
    default: {
        if (!!((u64)cc_lex$alphamap[(c)])) {
            cc_lex$readalphanumeric(pstart);
            return;
        }
;
        --(cc_lex$lxsptr);
        goto L348 ;
    }
    } //SW
goto L347 ;
L348 :;
    ;
    cc_lex$setnumberoffset((pstart - cc_lex$lxstart));
    cc_decls$nextlx.length = (cc_lex$lxsptr - pstart);
    if (((length > (i64)20) || ((length == (i64)20) && ((res = mlib$cmpstringn(p,(byte*)"18446744073709551615",(i64)20)) > (i64)0)))) {
        cc_lex$lxerror((byte*)"Overflow in decimal number");
    }
;
    $av_1 = length;
    while ($av_1-- > 0) {
L349 :;
        aa = ((aa * (u64)10u) + (u64)((u64)(*(p)++) - '0'));
L350 :;
    }
L351 :;
    ;
    cc_decls$nextlx.symbol = (i64)60;
    cc_decls$nextlx.subcode = (i64)4;
    if (((i64)ll==(i64)0) || ((i64)ll==(i64)1)) {
        if (!!((i64)usigned)) {
            if ((aa >= (u64)4294967295u)) {
                cc_decls$nextlx.subcode = (i64)10;
            }
            else {
                cc_decls$nextlx.subcode = (i64)9;
            }
;
        }
        else {
            if ((aa >= (u64)2147483647u)) {
                cc_decls$nextlx.subcode = (i64)5;
            }
;
        }
;
    }
    else {
        if (!!((i64)usigned)) {
            cc_decls$nextlx.subcode = (i64)10;
        }
        else {
            cc_decls$nextlx.subcode = (i64)5;
        }
;
    }
;
    cc_decls$nextlx.value = (i64)aa;
}

static i64 cc_lex$checknumbersuffix(void) {
        u8 c;
    L352 :;
    switch ((i64)(c = (u64)(*(cc_lex$lxsptr)++))) {
    case 76:;
    case 108:;
    case 117:;
    case 85:;
        {
        }
        break;
    default: {
        if (!!((u64)cc_lex$alphamap[((i64)(u64)c)])) {
        }
;
        --(cc_lex$lxsptr);
        goto L353 ;
    }
    } //SW
goto L352 ;
L353 :;
    ;
    return (i64)4;
}

static void cc_lex$stacksourcefile(u8 *file,i64 syshdr) {
        i64 fileno;
        struct cc_lex$stackinforec info;
        u8 fullpath[500];
    fileno = cc_lex$getsourcefile(file,syshdr);
    if ((fileno == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str(file,NULL);
        msysc$m_print_i64(strlen(file),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lex$lxerror((byte*)"Can't find include file");
    }
;
    if ((cc_lex$lx_stackindex >= (i64)20)) {
        cc_lex$lxerror((byte*)"Too many nested includes");
    }
;
    ++(cc_lex$lx_stackindex);
    fullpath[((i64)1)-1] = (u64)0u;
    if ((cc_lex$lx_stackindex > (i64)1)) {
        strcpy((u8 *)fullpath,cc_lex$headerpathlist[((cc_lex$lx_stackindex - (i64)1))-1]);
    }
;
    if (!!((u64)cc_lex$headerpath[((i64)1)-1])) {
        strcat((u8 *)fullpath,mlib$pcm_copyheapstring((u8 *)cc_lex$headerpath));
    }
;
    cc_lex$headerpathlist[(cc_lex$lx_stackindex)-1] = mlib$pcm_copyheapstring((u8 *)fullpath);
    info.startptr = cc_lex$lxstart;
    info.sptr = cc_lex$lxsptr;
    info.lineno = (i64)cc_decls$nextlx.lineno;
    info.fileno = cc_lex$getfileno();
    cc_lex$lx_stack[(cc_lex$lx_stackindex)-1] = info;
    cc_lex$lxstart = (cc_lex$lxsptr = cc_decls$sourcefiletext[(fileno)]);
    cc_lex$setfileno(fileno);
    cc_decls$nextlx.lineno = (i64)1;
}

static void cc_lex$unstacksourcefile(void) {
        u8 *  path;
        struct cc_lex$stackinforec info;
    path = cc_lex$headerpathlist[(cc_lex$lx_stackindex)-1];
    mlib$pcm_free((void *)path,strlen(path));
    info = cc_lex$lx_stack[((cc_lex$lx_stackindex)--)-1];
    cc_lex$lxstart = info.startptr;
    cc_lex$lxsptr = info.sptr;
    cc_decls$nextlx.lineno = (i64)info.lineno;
    cc_lex$setfileno((i64)info.fileno);
}

static i64 cc_lex$getsourcefile(u8 *file,i64 syshdr) {
        static u8 filespec[300];
        u8 *  hdrtext;
        i64 i;
    cc_lex$headerpath[((i64)1)-1] = (u64)0u;
    strcpy((u8 *)filespec,file);
    mlib$convlcstring((u8 *)filespec);
    for (i=(i64)1;i<=cc_decls$nsourcefiles;++i) {
L354 :;
        if (!!(mlib$eqstring((u8 *)filespec,cc_decls$sourcefilenames[(i)]))) {
            return i;
        }
;
L355 :;
    }
L356 :;
    ;
    if (!!(cc_decls$dointheaders)) {
        hdrtext = cc_headers$findheader((u8 *)filespec);
        if (!!(hdrtext)) {
            return cc_support$loadbuiltin((u8 *)filespec,hdrtext);
        }
;
    }
;
    strcpy((u8 *)cc_lex$headerpath,mlib$extractpath(file));
    if ((((u64)cc_lex$headerpath[((i64)1)-1] == '/') || (((u64)cc_lex$headerpath[((i64)2)-1] == ':') && ((u64)cc_lex$headerpath[((i64)3)-1] == '/')))) {
        if (!!(mlib$checkfile(file))) {
            return cc_support$loadsourcefile(file,file);
        }
;
        return (i64)0;
    }
;
    for (i=cc_lex$lx_stackindex;i>=(i64)1;--i) {
L357 :;
        strcpy((u8 *)filespec,cc_lex$headerpathlist[(i)-1]);
        strcat((u8 *)filespec,file);
        if (!!(mlib$checkfile((u8 *)filespec))) {
            return cc_support$loadsourcefile((u8 *)filespec,file);
        }
;
L358 :;
    }
L359 :;
    ;
    for (i=(i64)1;i<=cc_decls$nsearchdirs;++i) {
L360 :;
        strcpy((u8 *)filespec,cc_decls$searchdirs[(i)-1]);
        strcat((u8 *)filespec,file);
        if (!!(mlib$checkfile((u8 *)filespec))) {
            strcpy((u8 *)cc_lex$headerpath,mlib$extractpath((u8 *)filespec));
            return cc_support$loadsourcefile((u8 *)filespec,file);
        }
;
L361 :;
    }
L362 :;
    ;
    return (i64)0;
}

void cc_lex$lex(void) {
    //reenter:
L363 :;
;
    cc_decls$lx = cc_decls$nextlx;
    cc_lex$lexm();
    if ((((i64)cc_decls$lx.symbol == (i64)69) && (cc_lex$lx_stackindex == (i64)0))) {
        (*((*cc_decls$lx.symptr).name + (i64)cc_decls$lx.length)) = (u64)0u;
    }
;
    L364 :;
        {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)69)) {
        cc_decls$nextlx.symbol = (i64)(*cc_decls$nextlx.symptr).symbol;
        if (((i64)cc_decls$nextlx.symbol == (i64)70)) {
            cc_decls$nextlx.symbol = (i64)69;
        }
;
        cc_decls$nextlx.subcode = (i64)(*cc_decls$nextlx.symptr).subcode;
        return;
    }
    else if (($temp==(i64)57)) {
        cc_lex$lexm();
    }
    else {
        return;
    }
    }goto L364 ;
L365 :;
    ;
}

static void cc_lex$shownumberstr(struct cc_decls$tokenrec *l,void *f) {
        u8 *  s;
    if (!!(cc_lex$getfilenox((struct cc_decls$tokenrec *)l))) {
        s = (cc_decls$sourcefiletext[(cc_lex$getfilenox((struct cc_decls$tokenrec *)l))] + cc_lex$getnumberoffsetx((struct cc_decls$tokenrec *)l));
    }
    else {
        s = cc_lex$pastedtokenlist[((i64)(*l).pasteno)-1];
    }
;
    cc_lex$printstrn(s,(i64)(*l).length,f);
}

struct cc_decls$strec *cc_lex$addnamestr(u8 *name) {
        struct cc_decls$tokenrec oldlx;
        struct cc_decls$strec *  symptr;
    oldlx = cc_decls$nextlx;
    cc_decls$nextlx.length = strlen(name);
    cc_lex$lxhashvalue = (i64)cc_lex$gethashvalue(name,(i64)cc_decls$nextlx.length);
    cc_lex$lxsvalue = (u8 *)mlib$pcm_alloc(((i64)cc_decls$nextlx.length + (i64)1));
    memcpy((void *)cc_lex$lxsvalue,(void *)name,(u64)((i64)cc_decls$nextlx.length + (i64)1));
    cc_lex$lookup();
    symptr = (struct cc_decls$strec *)cc_decls$nextlx.symptr;
    cc_decls$nextlx = oldlx;
    return (struct cc_decls$strec *)symptr;
}

static void cc_lex$lxreadstring(i64 termchar,i64 fwide) {
        u8 str[2048];
        u8 *  dest;
        u8 *  ws;
        u16 *  wd;
        u16 *  wd0;
        i64 c;
        i64 d;
        i64 length;
        i64 useheap;
        i64 $av_1;
        i64 $av_2;
    if ((termchar == (i64)34)) {
        cc_decls$nextlx.symbol = (!!(fwide) ? (i64)65 : (i64)64);
    }
    else {
        cc_decls$nextlx.symbol = (i64)62;
    }
;
    cc_decls$nextlx.svalue = cc_lex$lxsptr;
    if (((cc_lex$lx_stackindex == (i64)0) && !(!!(fwide)))) {
        dest = cc_lex$lxsptr;
        ws = dest;
        useheap = (i64)0;
    }
    else {
        dest = (u8 *)str;
        ws = dest;
        useheap = (i64)1;
    }
;
    length = (i64)0;
    L366 :;
    while (1) {
        switch ((c = (i64)(u64)(*(cc_lex$lxsptr)++))) {
        case 92:;
            {
                if (!!(cc_lex$isincludefile)) {
                    c = (i64)47;
                    goto L368 ;
;
                }
;
                c = (i64)(u64)(*(cc_lex$lxsptr)++);
                //reenter:
L369 :;
;
                switch (c) {
                case 97:;
                    {
                        c = (i64)7;
                    }
                    break;
                case 98:;
                    {
                        c = (i64)8;
                    }
                    break;
                case 102:;
                    {
                        c = (i64)12;
                    }
                    break;
                case 110:;
                    {
                        c = (i64)10;
                    }
                    break;
                case 114:;
                    {
                        c = (i64)13;
                    }
                    break;
                case 116:;
                    {
                        c = (i64)9;
                    }
                    break;
                case 118:;
                    {
                        c = (i64)11;
                    }
                    break;
                case 120:;
                    {
                        c = (i64)0;
                        L370 :;
                        while (1) {
                            switch ((d = (i64)(u64)(*(cc_lex$lxsptr)++))) {
                            case 65:;
                            case 66:;
                            case 67:;
                            case 68:;
                            case 69:;
                            case 70:;
                                {
                                    c = ((((c * (i64)16) + d) - (i64)65) + (i64)10);
                                }
                                break;
                            case 97:;
                            case 98:;
                            case 99:;
                            case 100:;
                            case 101:;
                            case 102:;
                                {
                                    c = ((((c * (i64)16) + d) - (i64)97) + (i64)10);
                                }
                                break;
                            case 48:;
                            case 49:;
                            case 50:;
                            case 51:;
                            case 52:;
                            case 53:;
                            case 54:;
                            case 55:;
                            case 56:;
                            case 57:;
                                {
                                    c = (((c * (i64)16) + d) - (i64)48);
                                }
                                break;
                            default: {
                                --(cc_lex$lxsptr);
                                goto L371 ;
                            }
                            } //SW
;
                        }
L371 :;
                        ;
                    }
                    break;
                case 48:;
                case 49:;
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                    {
                        c -= (i64)48;
                        $av_1 = (i64)2;
                        while ($av_1-- > 0) {
L372 :;
                            switch ((d = (i64)(u64)(*(cc_lex$lxsptr)++))) {
                            case 48:;
                            case 49:;
                            case 50:;
                            case 51:;
                            case 52:;
                            case 53:;
                            case 54:;
                            case 55:;
                                {
                                    c = (((c * (i64)8) + d) - (i64)48);
                                }
                                break;
                            default: {
                                --(cc_lex$lxsptr);
                                goto L374 ;
                            }
                            } //SW
;
L373 :;
                        }
L374 :;
                        ;
                    }
                    break;
                case 34:;
                    {
                        c = (i64)34;
                    }
                    break;
                case 92:;
                    {
                        c = (i64)92;
                    }
                    break;
                case 39:;
                    {
                        c = (i64)39;
                    }
                    break;
                case 13:;
                    {
                        ++(cc_decls$nextlx.lineno);
                        if (((i64)(u64)(*cc_lex$lxsptr) == (i64)10)) {
                            ++(cc_lex$lxsptr);
                        }
;
                        goto L366 ;
                    }
                    break;
                case 10:;
                    {
                        goto L366 ;
                    }
                    break;
                } //SW
;
            }
            break;
        case 34:;
        case 39:;
            {
                if ((c == termchar)) {
                    goto L367 ;
                }
;
            }
            break;
        case 0:;
            {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"NEXTLX.LINENO=",NULL);
                msysc$m_print_i64((i64)cc_decls$nextlx.lineno,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                cc_lex$lxerror((byte*)"String not terminated");
            }
            break;
        } //SW
;
        //normalchar:
L368 :;
;
        if (!(!!(useheap))) {
            (*(dest)++) = (u64)c;
        }
        else if ((++(length) < (i64)2048)) {
            (*(dest)++) = (u64)c;
        }
        else {
            cc_lex$lxerror((byte*)"Local str too long");
        }
;
    }
L367 :;
    ;
    (*dest) = (u64)0u;
    if (!!(fwide)) {
        wd0 = (wd = (u16 *)mlib$pcm_alloc(((length * (i64)2) + (i64)2)));
        $av_2 = length;
        while ($av_2-- > 0) {
L375 :;
            (*(wd)++) = (i64)(u64)(*(ws)++);
L376 :;
        }
L377 :;
        ;
        (*wd) = (i64)0;
        cc_decls$nextlx.svalue = (u8 *)wd0;
    }
    else if (!!(useheap)) {
        cc_decls$nextlx.length = length;
        cc_decls$nextlx.svalue = (u8 *)mlib$pcm_alloc((length + (i64)1));
        memcpy((void *)cc_decls$nextlx.svalue,str,(u64)(length + (i64)1));
    }
    else {
        cc_decls$nextlx.length = (dest - cc_decls$nextlx.svalue);
    }
;
}

static void cc_lex$addlisttoken(struct cc_decls$tokenrec **ulist,struct cc_decls$tokenrec **ulistx,struct cc_decls$tokenrec *p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = (struct cc_decls$tokenrec *)p);
    }
    else {
        (*(*ulistx)).nexttoken = (struct cc_decls$tokenrec *)p;
    }
;
    (*p).nexttoken = 0;
    (*ulistx) = (struct cc_decls$tokenrec *)p;
}

static void cc_lex$addlisttoken_copy(struct cc_decls$tokenrec **ulist,struct cc_decls$tokenrec **ulistx,struct cc_decls$tokenrec *q) {
        struct cc_decls$tokenrec *  p;
    p = (struct cc_decls$tokenrec *)cc_lex$alloctoken();
    (*p) = (*q);
    (*p).nexttoken = 0;
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = (struct cc_decls$tokenrec *)p);
    }
    else {
        (*(*ulistx)).nexttoken = (struct cc_decls$tokenrec *)p;
    }
;
    (*p).nexttoken = 0;
    (*ulistx) = (struct cc_decls$tokenrec *)p;
}

static void cc_lex$addlist_nextlx(struct cc_decls$tokenrec **ulist,struct cc_decls$tokenrec **ulistx) {
        struct cc_decls$tokenrec *  p;
    p = (struct cc_decls$tokenrec *)cc_lex$alloctoken();
    (*p) = cc_decls$nextlx;
    (*p).nexttoken = 0;
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = (struct cc_decls$tokenrec *)p);
    }
    else {
        (*(*ulistx)).nexttoken = (struct cc_decls$tokenrec *)p;
    }
;
    (*p).nexttoken = 0;
    (*ulistx) = (struct cc_decls$tokenrec *)p;
}

static void cc_lex$addlisttoken_seq(struct cc_decls$tokenrec **ulist,struct cc_decls$tokenrec **ulistx,struct cc_decls$tokenrec *seq) {
        struct cc_decls$tokenrec *  tk;
    L378 :;
    while (!!(seq)) {
        tk = (struct cc_decls$tokenrec *)cc_lex$alloctoken();
        (*tk) = (*seq);
        if (((*ulist) == 0)) {
            (*ulist) = ((*ulistx) = (struct cc_decls$tokenrec *)tk);
        }
        else {
            (*(*ulistx)).nexttoken = (struct cc_decls$tokenrec *)tk;
        }
;
        (*tk).nexttoken = 0;
        (*ulistx) = (struct cc_decls$tokenrec *)tk;
        seq = (struct cc_decls$tokenrec *)(*seq).nexttoken;
L379 :;
    }
L380 :;
    ;
}

static void cc_lex$addlistmparam(struct cc_decls$mparamrec **ulist,struct cc_decls$mparamrec **ulistx,struct cc_decls$mparamrec *p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = (struct cc_decls$mparamrec *)p);
    }
    else {
        (*(*ulistx)).nextmparam = (struct cc_decls$mparamrec *)p;
    }
;
    (*ulistx) = (struct cc_decls$mparamrec *)p;
}

static void cc_lex$dodefine(void) {
        struct cc_decls$mparamrec *  stlist;
        struct cc_decls$mparamrec *  stlistx;
        struct cc_decls$mparamrec *  p;
        struct cc_decls$mparamrec *  q;
        struct cc_decls$strec *  stname;
        struct cc_decls$strec *  d;
        struct cc_decls$tokenrec *  tklist;
        struct cc_decls$tokenrec *  tklistx;
        struct cc_decls$tokenrec *  tk;
        i64 nparams;
        i64 ntokens;
        i64 paramno;
    cc_lex$lexreadtoken();
    if (((i64)cc_decls$nextlx.symbol != (i64)69)) {
        cc_lex$lxerror((byte*)"define: name expected");
    }
;
    stname = (struct cc_decls$strec *)cc_decls$nextlx.symptr;
    (*stname).lineno = ((i64)cc_decls$nextlx.lineno + (cc_lex$getfileno() << (i64)24));
    (*stname).oldsymbol = (i64)(*stname).symbol;
    (*stname).symbol = (i64)69;
    (*stname).nameid = (i64)1;
    nparams = (i64)0;
    if (((u64)(*cc_lex$lxsptr) == '(')) {
        ++(cc_lex$lxsptr);
        stlist = (stlistx = 0);
        (*stname).attribs.ax_flmacro = (i64)1;
        cc_lex$lexreadtoken();
        L381 :;
        while (1) {
                        {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)69)) {
                d = (struct cc_decls$strec *)cc_decls$nextlx.symptr;
                p = stlist;
                L383 :;
                while (!!(p)) {
                    if (((*p).def == d)) {
                        cc_lex$lxerror((byte*)"Dupl macro param");
                    }
;
                    p = (struct cc_decls$mparamrec *)(*p).nextmparam;
L384 :;
                }
L385 :;
                ;
                q = (struct cc_decls$mparamrec *)mlib$pcm_alloc((i64)16);
                (*q).def = (struct cc_decls$strec *)d;
                (*q).nextmparam = 0;
                cc_lex$addlistmparam((struct cc_decls$mparamrec **)&stlist,(struct cc_decls$mparamrec **)&stlistx,(struct cc_decls$mparamrec *)q);
                ++(nparams);
                cc_lex$lexreadtoken();
                if (((i64)cc_decls$nextlx.symbol == (i64)8)) {
                    cc_lex$lexreadtoken();
                }
;
            }
            else if (($temp==(i64)14)) {
                goto L382 ;
            }
            else if (($temp==(i64)21)) {
                d = (struct cc_decls$strec *)cc_lex$addnamestr((byte*)"__VA_ARGS__");
                (*stname).attribs.ax_varparams = (i64)1;
                cc_lex$lexreadtoken();
                if (((i64)cc_decls$nextlx.symbol != (i64)14)) {
                    cc_lex$lxerror((byte*)"')' expected");
                }
;
                q = (struct cc_decls$mparamrec *)mlib$pcm_alloc((i64)16);
                (*q).def = (struct cc_decls$strec *)d;
                (*q).nextmparam = 0;
                cc_lex$addlistmparam((struct cc_decls$mparamrec **)&stlist,(struct cc_decls$mparamrec **)&stlistx,(struct cc_decls$mparamrec *)q);
                ++(nparams);
                goto L382 ;
            }
            else {
                cc_lex$lxerror((byte*)"macro params?");
            }
            };
        }
L382 :;
        ;
        (*stname).mparamlist = (struct cc_decls$mparamrec *)stlist;
    }
;
    tklist = (tklistx = 0);
    ntokens = (i64)0;
    L386 :;
    while (1) {
        cc_lex$lexreadtoken();
                {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)57) || ($temp==(i64)58)) {
            goto L387 ;
        }
        else if (($temp==(i64)69)) {
            p = (struct cc_decls$mparamrec *)(*stname).mparamlist;
            paramno = (i64)1;
            L388 :;
            while (!!(p)) {
                if (((*p).def == cc_decls$nextlx.symptr)) {
                    cc_decls$nextlx.flags |= (u8)2u;
                    cc_decls$nextlx.paramno = paramno;
                    goto L390 ;
                }
;
                p = (struct cc_decls$mparamrec *)(*p).nextmparam;
                ++(paramno);
L389 :;
            }
L390 :;
            ;
            if ((cc_decls$nextlx.symptr == stname)) {
                cc_decls$nextlx.flags |= (u8)1u;
            }
;
        }
        };
        ++(ntokens);
        tk = (struct cc_decls$tokenrec *)cc_lex$alloctoken();
        (*tk) = cc_decls$nextlx;
        cc_lex$addlisttoken((struct cc_decls$tokenrec **)&tklist,(struct cc_decls$tokenrec **)&tklistx,(struct cc_decls$tokenrec *)tk);
    }
L387 :;
    ;
    (*stname).tokenlist = (struct cc_decls$tokenrec *)tklist;
    (*stname).attribs.ax_nparams = nparams;
}

static void cc_lex$readalphanumeric(u8 *pstart) {
    L391 :;
    while (!!((u64)cc_lex$alphamap[((i64)(u64)(*(cc_lex$lxsptr)++))])) {
L392 :;
    }
L393 :;
    ;
    --(cc_lex$lxsptr);
    cc_decls$nextlx.svalue = pstart;
    cc_decls$nextlx.symbol = (i64)59;
    cc_decls$nextlx.length = (cc_lex$lxsptr - pstart);
}

static i64 cc_lex$inmacrostack(struct cc_decls$strec *d,struct cc_decls$tokenrec *macrostack) {
    L394 :;
    while (!!(macrostack)) {
        if (((*macrostack).symptr == d)) {
            return (i64)1;
        }
;
        macrostack = (struct cc_decls$tokenrec *)(*macrostack).nexttoken;
L395 :;
    }
L396 :;
    ;
    return (i64)0;
}

static void cc_lex$showtokens(u8 *caption,struct cc_decls$tokenrec *tk) {
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)"<",NULL);
    msysc$m_print_end();
    ;
    L397 :;
    while (!!(tk)) {
        cc_lex$showtoken((struct cc_decls$tokenrec *)tk);
        tk = (struct cc_decls$tokenrec *)(*tk).nexttoken;
L398 :;
    }
L399 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)">",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void cc_lex$lexa(struct cc_decls$tokenrec **tk) {
    if (((*tk) == cc_lex$normaltk)) {
        cc_lex$lexreadtoken();
        return;
    }
;
    if (((*tk) == 0)) {
        cc_decls$nextlx.symbol = (i64)58;
        return;
    }
;
    cc_decls$nextlx = (*(*tk));
    (*tk) = (struct cc_decls$tokenrec *)(*(*tk)).nexttoken;
}

static void cc_lex$lexm(void) {
        struct cc_decls$strec *  d;
        static i64 doreset = (i64)0;
        i64 newlineno;
    L400 :;
    while (1) {
        if (!!(cc_lex$tkptr)) {
            cc_decls$nextlx = (*cc_lex$tkptr);
            cc_lex$tkptr = (struct cc_decls$tokenrec *)(*cc_lex$tkptr).nexttoken;
            if ((cc_lex$tkptr == 0)) {
                if (((((i64)cc_decls$nextlx.symbol == (i64)69) && ((i64)(*cc_decls$nextlx.symptr).nameid == (i64)1)) && !!(cc_lex$peeklb()))) {
                    cc_lex$setfileno(cc_decls$sfileno);
                    cc_decls$nextlx.lineno = cc_decls$slineno;
                    doreset = (i64)0;
                    goto L402 ;
;
                }
;
                doreset = (i64)1;
            }
;
            return;
        }
;
        if (!!(doreset)) {
            cc_lex$setfileno(cc_decls$sfileno);
            cc_decls$nextlx.lineno = cc_decls$slineno;
            doreset = (i64)0;
        }
;
        if (!!(cc_lex$firstsymbol)) {
            cc_lex$firstsymbol = (i64)0;
            cc_lex$dospecialinclude();
        }
;
        cc_lex$lexreadtoken();
        //test1:
L402 :;
;
                {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)4)) {
            if (!!(cc_lex$dolexdirective())) {
                return;
            }
;
            goto L400 ;
        }
        else if (($temp==(i64)69)) {
            d = (struct cc_decls$strec *)cc_decls$nextlx.symptr;
                        {i64 $temp = (i64)(*d).symbol;
if (($temp==(i64)71)) {
                cc_decls$sfileno = cc_lex$getfileno();
                cc_decls$slineno = (i64)cc_decls$nextlx.lineno;
                cc_lex$expandpredefmacro((i64)(*d).subcode,(struct cc_decls$tokenrec *)&cc_decls$nextlx,cc_decls$slineno);
                doreset = (i64)1;
                return;
            }
            else {
                if ((((i64)(*d).nameid != (i64)1) || !!(cc_lex$noexpand))) {
                    return;
                }
;
            }
            };
        }
        else {
            return;
        }
        };
        cc_decls$sfileno = cc_lex$getfileno();
        cc_decls$slineno = (i64)cc_decls$nextlx.lineno;
        if (!!((i64)(*d).attribs.ax_flmacro)) {
            if (!(!!(cc_lex$peeklb()))) {
                return;
            }
;
            cc_lex$tkptr = (struct cc_decls$tokenrec *)cc_lex$expandfnmacro((struct cc_decls$strec *)d,0,&cc_lex$normaltk,(i64)1,&newlineno);
            cc_decls$slineno = newlineno;
        }
        else {
            cc_lex$tkptr = (struct cc_decls$tokenrec *)cc_lex$expandobjmacro((struct cc_decls$strec *)d,0,&cc_lex$normaltk,(i64)1);
        }
;
        if ((cc_lex$tkptr == 0)) {
            doreset = (i64)1;
        }
;
    }
L401 :;
    ;
}

static i64 cc_lex$peeklb(void) {
    if ((((u64)(*cc_lex$lxsptr) == '(') || (((u64)(*cc_lex$lxsptr) == ' ') && ((u64)(*(cc_lex$lxsptr + (i64)1)) == '(')))) {
        return (i64)1;
    }
;
    return (i64)0;
}

static i64 cc_lex$peektk(struct cc_decls$tokenrec *tk) {
    tk = (struct cc_decls$tokenrec *)(*tk).nexttoken;
    if ((tk == 0)) {
        return (i64)0;
    }
;
    if (((i64)(*tk).symbol == (i64)13)) {
        return (i64)1;
    }
;
    return (i64)0;
}

static struct cc_decls$tokenrec *cc_lex$expandobjmacro(struct cc_decls$strec *m,struct cc_decls$tokenrec *macrostack,struct cc_decls$tokenrec **tksource,i64 frombaselevel) {
        struct cc_decls$tokenrec *  tk;
        struct cc_decls$tokenrec *  p;
        struct cc_decls$tokenrec *  repl;
        struct cc_decls$tokenrec newmacro;
        i64 iscomplex;
        i64 useshh;
        i64 expanded;
        struct cc_decls$strec *  d;
    p = (tk = (struct cc_decls$tokenrec *)(*m).tokenlist);
    iscomplex = (useshh = (i64)0);
    L403 :;
    while (!!(p)) {
        if (((i64)(*p).symbol == (i64)69)) {
            d = (struct cc_decls$strec *)(*p).symptr;
            if ((((i64)(*d).nameid == (i64)1) || ((i64)(*d).symbol == (i64)71))) {
                iscomplex = (i64)1;
                goto L405 ;
            }
;
        }
        else if (((i64)(*p).symbol == (i64)7)) {
            iscomplex = (useshh = (i64)1);
            goto L405 ;
        }
;
        p = (struct cc_decls$tokenrec *)(*p).nexttoken;
L404 :;
    }
L405 :;
    ;
    if (!(!!(iscomplex))) {
        return (struct cc_decls$tokenrec *)tk;
    }
;
    newmacro.symptr = (struct cc_decls$strec *)m;
    newmacro.nexttoken = (struct cc_decls$tokenrec *)macrostack;
    if (!!(useshh)) {
        repl = (struct cc_decls$tokenrec *)cc_lex$substituteargs((struct cc_decls$strec *)m,0,0,(i64)0,0);
    }
    else {
        repl = (struct cc_decls$tokenrec *)(*m).tokenlist;
    }
;
    tk = (struct cc_decls$tokenrec *)cc_lex$scantokenseq((struct cc_decls$tokenrec *)repl,(struct cc_decls$tokenrec *)&newmacro,&expanded);
    return (struct cc_decls$tokenrec *)tk;
}

static struct cc_decls$tokenrec *cc_lex$expandfnmacro(struct cc_decls$strec *m,struct cc_decls$tokenrec *macrostack,struct cc_decls$tokenrec **tksource,i64 frombaselevel,i64 *endlineno) {
        struct cc_decls$tokenrec *  args[200];
        struct cc_decls$tokenrec *  expargs[200];
        struct cc_decls$tokenrec *  repl;
        struct cc_decls$tokenrec newmacro;
        i64 nargs;
        i64 i;
        i64 expanded;
    nargs = cc_lex$readmacrocall((struct cc_decls$strec *)m,(struct cc_decls$tokenrec *(*)[])&args,tksource);
    if (!!(frombaselevel)) {
        (*endlineno) = (i64)cc_decls$nextlx.lineno;
    }
;
    for (i=(i64)1;i<=nargs;++i) {
L406 :;
        expargs[(i)-1] = 0;
L407 :;
    }
L408 :;
    ;
    repl = (struct cc_decls$tokenrec *)cc_lex$substituteargs((struct cc_decls$strec *)m,(struct cc_decls$tokenrec *(*)[])&args,(struct cc_decls$tokenrec *(*)[])&expargs,nargs,(struct cc_decls$tokenrec *)macrostack);
    newmacro.symptr = (struct cc_decls$strec *)m;
    newmacro.nexttoken = (struct cc_decls$tokenrec *)macrostack;
    repl = (struct cc_decls$tokenrec *)cc_lex$scantokenseq((struct cc_decls$tokenrec *)repl,(struct cc_decls$tokenrec *)&newmacro,&expanded);
    return (struct cc_decls$tokenrec *)repl;
}

static struct cc_decls$tokenrec *cc_lex$scantokenseq(struct cc_decls$tokenrec *tk,struct cc_decls$tokenrec *macrostack,i64 *expanded) {
        struct cc_decls$tokenrec *  newtk;
        struct cc_decls$tokenrec *  newtkx;
        struct cc_decls$tokenrec *  expandtk;
        struct cc_decls$tokenrec *  oldtk;
        struct cc_decls$strec *  m;
        i64 noexpandflag;
        i64 simple;
        i64 dummy;
    //reenter:
L409 :;
;
    (*expanded) = (i64)0;
    newtk = (newtkx = 0);
    noexpandflag = (i64)0;
    simple = (i64)1;
    oldtk = (struct cc_decls$tokenrec *)tk;
    L410 :;
    while (!!(tk)) {
                {i64 $temp = (i64)(*tk).symbol;
if (($temp==(i64)69)) {
            if ((((i64)(*(*tk).symptr).nameid == (i64)1) || ((i64)(*(*tk).symptr).symbol == (i64)71))) {
                simple = (i64)0;
                goto L412 ;
            }
;
        }
        };
        if ((tk == 0)) {
            goto L412 ;
        }
;
        tk = (struct cc_decls$tokenrec *)(*tk).nexttoken;
L411 :;
    }
L412 :;
    ;
    if (!!(simple)) {
        return (struct cc_decls$tokenrec *)oldtk;
    }
;
    tk = (struct cc_decls$tokenrec *)oldtk;
    L413 :;
    while (!!(tk)) {
                {i64 $temp = (i64)(*tk).symbol;
if (($temp==(i64)69)) {
            m = (struct cc_decls$strec *)(*tk).symptr;
            if ((((i64)(*m).nameid == (i64)1) && !(!!(noexpandflag)))) {
                if ((!!(((i64)(*tk).flags & (i64)4)) || !!(cc_lex$noexpand))) {
                    goto L416 ;
;
                }
;
                if (!!(cc_lex$inmacrostack((struct cc_decls$strec *)m,(struct cc_decls$tokenrec *)macrostack))) {
                    cc_lex$addlisttoken_copy((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)tk);
                    (*newtkx).flags |= (u8)4u;
                    goto L417 ;
;
                }
;
                simple = (i64)0;
                if (!!((i64)(*m).attribs.ax_flmacro)) {
                    if (!(!!(cc_lex$peektk((struct cc_decls$tokenrec *)tk)))) {
                        goto L416 ;
;
                    }
;
                    cc_lex$lexa(&tk);
                    expandtk = (struct cc_decls$tokenrec *)cc_lex$expandfnmacro((struct cc_decls$strec *)m,(struct cc_decls$tokenrec *)macrostack,&tk,(i64)1,&dummy);
                    cc_lex$addlisttoken_seq((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)expandtk);
                    (*expanded) = (i64)1;
                    goto L414 ;
                }
                else {
                    expandtk = (struct cc_decls$tokenrec *)cc_lex$expandobjmacro((struct cc_decls$strec *)m,(struct cc_decls$tokenrec *)macrostack,&tk,(i64)0);
                    (*expanded) = (i64)1;
                    cc_lex$addlisttoken_seq((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)expandtk);
                }
;
            }
            else if (((i64)(*m).symbol == (i64)94)) {
                noexpandflag = (i64)1;
                goto L416 ;
;
            }
            else if (((i64)(*m).symbol == (i64)71)) {
                expandtk = (struct cc_decls$tokenrec *)cc_lex$alloctokenz();
                cc_lex$expandpredefmacro((i64)(*m).subcode,(struct cc_decls$tokenrec *)expandtk,cc_decls$slineno);
                cc_lex$addlisttoken_copy((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)expandtk);
                goto L418 ;
;
            }
            else {
                noexpandflag = (i64)0;
                goto L416 ;
;
            }
;
        }
        else {
            //simpletoken:
L416 :;
;
            cc_lex$addlisttoken_copy((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)tk);
        }
        };
        //skip:
L417 :;
;
        if ((tk == 0)) {
            goto L415 ;
        }
;
        //skip2:
L418 :;
;
        tk = (struct cc_decls$tokenrec *)(*tk).nexttoken;
L414 :;
    }
L415 :;
    ;
    if (!!((*expanded))) {
        tk = (struct cc_decls$tokenrec *)newtk;
        goto L409 ;
;
    }
;
    return (struct cc_decls$tokenrec *)newtk;
}

static i64 cc_lex$readmacrocall(struct cc_decls$strec *d,struct cc_decls$tokenrec *(*args)[],struct cc_decls$tokenrec **tksource) {
        i64 nparams;
        i64 lbcount;
        i64 paramno;
        i64 nargs;
        i64 usesvargs;
        i64 varg;
        struct cc_decls$tokenrec *  tklist;
        struct cc_decls$tokenrec *  tklistx;
    cc_lex$lexa(tksource);
    if (((i64)cc_decls$nextlx.symbol != (i64)13)) {
        cc_lex$lxerror((byte*)"rmc: no '('");
    }
;
    nparams = (i64)(*d).attribs.ax_nparams;
    nargs = (i64)0;
    if ((nparams == (i64)0)) {
        cc_lex$lexa(tksource);
        if (((i64)cc_decls$nextlx.symbol != (i64)14)) {
            cc_lex$lxerror((byte*)"rmc: ')' expected");
        }
;
        return (i64)0;
    }
;
    paramno = (i64)1;
    lbcount = (i64)1;
    tklist = (tklistx = 0);
    usesvargs = (i64)(*d).attribs.ax_varparams;
    varg = (i64)0;
    L419 :;
    while (1) {
        if (((paramno == nparams) && !!(usesvargs))) {
            varg = (i64)1;
        }
;
        cc_lex$lexa(tksource);
                {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)8)) {
            if (((lbcount == (i64)1) && !(!!(varg)))) {
                if ((tklist == 0)) {
                    tklist = (struct cc_decls$tokenrec *)cc_lex$alloctokenz();
                    cc_lex$setfilenox((struct cc_decls$tokenrec *)tklist,cc_lex$getfileno());
                    (*tklist).symbol = (i64)67;
                }
;
                (*args)[(paramno)-1] = (struct cc_decls$tokenrec *)tklist;
                tklist = (tklistx = 0);
                ++(paramno);
            }
            else {
                goto L421 ;
;
            }
;
        }
        else if (($temp==(i64)58)) {
            cc_lex$lxerror((byte*)"EOS in macro call");
        }
        else if (($temp==(i64)13)) {
            ++(lbcount);
            goto L421 ;
;
        }
        else if (($temp==(i64)14)) {
            if ((lbcount > (i64)1)) {
                --(lbcount);
                cc_lex$addlist_nextlx((struct cc_decls$tokenrec **)&tklist,(struct cc_decls$tokenrec **)&tklistx);
            }
            else {
                if ((tklist == 0)) {
                    tklist = (struct cc_decls$tokenrec *)cc_lex$alloctokenz();
                    cc_lex$setfilenox((struct cc_decls$tokenrec *)tklist,cc_lex$getfileno());
                    (*tklist).symbol = (i64)67;
                }
;
                (*args)[(paramno)-1] = (struct cc_decls$tokenrec *)tklist;
                goto L420 ;
            }
;
        }
        else {
            //addtoken:
L421 :;
;
            cc_lex$addlist_nextlx((struct cc_decls$tokenrec **)&tklist,(struct cc_decls$tokenrec **)&tklistx);
        }
        };
    }
L420 :;
    ;
    if ((paramno != nparams)) {
        if ((((paramno + (i64)1) == nparams) && !!(usesvargs))) {
            (*args)[(nparams)-1] = 0;
        }
        else {
            cc_lex$lxerror((byte*)"Wrong # macro params");
        }
;
    }
;
    return nparams;
}

static struct cc_decls$tokenrec *cc_lex$substituteargs(struct cc_decls$strec *m,struct cc_decls$tokenrec *(*args)[],struct cc_decls$tokenrec *(*expargs)[],i64 nargs,struct cc_decls$tokenrec *macrostack) {
        struct cc_decls$mparamrec *  params;
        struct cc_decls$tokenrec *  seq;
        struct cc_decls$tokenrec *  seqstart;
        struct cc_decls$tokenrec *  lasttoken;
        struct cc_decls$tokenrec *  newtk;
        struct cc_decls$tokenrec *  newtkx;
        struct cc_decls$tokenrec *  niltk;
        struct cc_decls$tokenrec *  tkexp;
        struct cc_decls$tokenrec tk;
        i64 n;
        i64 i;
        i64 expanded;
        struct cc_decls$tokenrec *  hhpoints[250];
        i64 nhashhash;
    params = (struct cc_decls$mparamrec *)(*m).mparamlist;
    seq = (seqstart = (struct cc_decls$tokenrec *)(*m).tokenlist);
    newtk = (newtkx = 0);
    nhashhash = (i64)0;
    lasttoken = 0;
    L422 :;
    while (!!(seq)) {
                {i64 $temp = (i64)(*seq).symbol;
if (($temp==(i64)5)) {
            if (!!(nargs)) {
                seq = (struct cc_decls$tokenrec *)(*seq).nexttoken;
                if ((seq == 0)) {
                    cc_lex$lxerror((byte*)"# at end");
                }
;
                if (!(!!(((i64)(*seq).flags & (i64)2)))) {
                    cc_lex$lxerror((byte*)"# not followed by param");
                }
;
                n = (i64)(*seq).paramno;
                cc_lex$stringify((struct cc_decls$tokenrec *)(*args)[(n)-1],(struct cc_decls$tokenrec *)&tk);
                cc_lex$addlisttoken_copy((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)&tk);
            }
            else {
                cc_lex$addlisttoken((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)seq);
                (*newtkx).symbol = (i64)6;
            }
;
        }
        else if (($temp==(i64)7)) {
            if ((seq == seqstart)) {
                cc_lex$lxerror((byte*)"## at start");
            }
;
            if ((nhashhash >= (i64)250)) {
                cc_lex$lxerror((byte*)"Too many ##");
            }
;
            hhpoints[(++(nhashhash))-1] = (struct cc_decls$tokenrec *)newtkx;
        }
        else {
            if (((((i64)(*seq).symbol == (i64)69) && !!(((i64)(*seq).flags & (i64)2))) && !!(nargs))) {
                n = (i64)(*seq).paramno;
                if (((!!((*seq).nexttoken) && ((i64)(*(*seq).nexttoken).symbol == (i64)7)) || (!!(lasttoken) && ((i64)(*lasttoken).symbol == (i64)7)))) {
                    cc_lex$addlisttoken_seq((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)(*args)[(n)-1]);
                }
                else {
                    tkexp = (struct cc_decls$tokenrec *)(*expargs)[(n)-1];
                    if ((tkexp == 0)) {
                        tkexp = (struct cc_decls$tokenrec *)((*expargs)[(n)-1] = (struct cc_decls$tokenrec *)cc_lex$scantokenseq((struct cc_decls$tokenrec *)(*args)[(n)-1],(struct cc_decls$tokenrec *)macrostack,&expanded));
                    }
;
                    cc_lex$addlisttoken_seq((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)tkexp);
                }
;
            }
            else {
                //doother:
L425 :;
;
                cc_lex$addlisttoken_copy((struct cc_decls$tokenrec **)&newtk,(struct cc_decls$tokenrec **)&newtkx,(struct cc_decls$tokenrec *)seq);
            }
;
        }
        };
        lasttoken = seq;
        seq = (struct cc_decls$tokenrec *)(*seq).nexttoken;
L423 :;
    }
L424 :;
    ;
    if (!!(nhashhash)) {
        niltk = 0;
        for (i=(i64)1;i<=nhashhash;++i) {
L426 :;
            cc_lex$pastetokens((struct cc_decls$tokenrec *)hhpoints[(i)-1],((i < nhashhash) ? &hhpoints[((i + (i64)1))-1] : &niltk));
L427 :;
        }
L428 :;
        ;
    }
;
    return (struct cc_decls$tokenrec *)newtk;
}

static u8 *cc_lex$strtoken(struct cc_decls$tokenrec *lp,i64 *length) {
        u8 *  name;
        u8 *  s;
        struct cc_decls$tokenrec l;
    l = (*lp);
        {i64 $temp = (i64)l.symbol;
if (($temp==(i64)69)) {
        //doname:
L429 :;
;
        (*length) = (i64)(*l.symptr).namelen;
        return (*l.symptr).name;
    }
    else if (($temp==(i64)60) || ($temp==(i64)61)) {
        (*length) = (i64)l.length;
        if (!!(cc_lex$getfilenox((struct cc_decls$tokenrec *)&l))) {
            return (cc_decls$sourcefiletext[(cc_lex$getfilenox((struct cc_decls$tokenrec *)&l))] + cc_lex$getnumberoffsetx((struct cc_decls$tokenrec *)&l));
        }
        else {
            return cc_lex$pastedtokenlist[((i64)l.pasteno)-1];
        }
;
    }
    else if (($temp==(i64)59)) {
        (*length) = (i64)l.length;
        return l.svalue;
    }
    else if (($temp==(i64)64) || ($temp==(i64)65)) {
        s = cc_lex$strstring(l.svalue,(i64)l.length,length,(i64)34);
        return s;
    }
    else if (($temp==(i64)62)) {
        s = cc_lex$strstring(l.svalue,(i64)l.length,length,(i64)39);
        return s;
    }
    else if (($temp==(i64)57)) {
        if (!!(cc_lex$dowhitespace)) {
            (*length) = ((i64)l.length + (i64)1);
            s = (u8 *)mlib$pcm_alloc((*length));
            (*s) = (u64)10u;
            memcpy((void *)(s + (i64)1),(void *)l.svalue,(u64)(i64)l.length);
        }
        else {
            (*length) = (i64)1;
            return (byte*)"\n";
        }
;
        return s;
    }
    else if (($temp==(i64)58)) {
        (*length) = (i64)0;
        return (byte*)"";
    }
    else if (($temp==(i64)72) || ($temp==(i64)88) || ($temp==(i64)87) || ($temp==(i64)89)) {
        goto L429 ;
;
    }
    else {
        name = cc_tables$shortsymbolnames[((i64)l.symbol)-1];
        if (!!(((*length) = strlen(name)))) {
            if (((u64)(*name) != 'k')) {
                return name;
            }
            else {
                (*length) = strlen((cc_tables$symbolnames[((i64)l.symbol)-1] + (i64)1));
                return (cc_tables$symbolnames[((i64)l.symbol)-1] + (i64)1);
            }
;
        }
        else {
            return (byte*)"";
        }
;
    }
    };
    return (byte*)"";
}

static u8 *cc_lex$strstring(u8 *s,i64 length,i64 *newlength,i64 quotechar) {
        u8 *  t;
        u8 *  u;
    t = (u = (u8 *)mlib$pcm_alloc(((length * (i64)2) + (i64)4)));
    if (!!(quotechar)) {
        (*u) = (u64)quotechar;
        ++(u);
    }
;
    cc_lib$convertstring(s,u,length);
    (*newlength) = strlen(t);
    if (!!(quotechar)) {
        (*(t + (*newlength))) = (u64)quotechar;
        ++((*newlength));
    }
;
    return t;
}

void cc_lex$emittoken(struct cc_decls$tokenrec *lp,struct mlib$strbuffer *dest,i64 forcespace) {
        i64 length;
        u8 *  s;
    if ((((i64)(*lp).symbol == (i64)57) && (cc_lex$lasttoken == (i64)57))) {
        return;
    }
;
    s = cc_lex$strtoken((struct cc_decls$tokenrec *)lp,&length);
    if ((!!(forcespace) || !!(cc_lex$needspace(cc_lex$lasttoken,(i64)(*lp).symbol)))) {
        mlib$gs_char((struct mlib$strbuffer *)dest,(i64)32);
    }
;
    mlib$gs_strn((struct mlib$strbuffer *)dest,s,length);
    cc_lex$lasttoken = (i64)(*lp).symbol;
}

void cc_lex$showtoken(struct cc_decls$tokenrec *lp) {
        static struct mlib$strbuffer buffer;
        static struct mlib$strbuffer *  dest = (struct mlib$strbuffer *)&buffer;
    mlib$gs_init((struct mlib$strbuffer *)dest);
    cc_lex$emittoken((struct cc_decls$tokenrec *)lp,(struct mlib$strbuffer *)dest,(i64)0);
    msysc$m_print_startcon();
    msysc$m_print_i64((i64)(*dest).length,(byte*)"v");
    msysc$m_print_nogap();
    msysc$m_print_str((*dest).strptr,(byte*)".*");
    msysc$m_print_end();
    ;
}

static void cc_lex$stringify(struct cc_decls$tokenrec *seq,struct cc_decls$tokenrec *dest) {
        u8 *  s;
        i64 length;
        i64 addspace;
        static struct mlib$strbuffer buffer;
        static struct mlib$strbuffer *  deststr = (struct mlib$strbuffer *)&buffer;
    (*dest).symbol = (i64)64;
    (*dest).nexttoken = 0;
    if (((*seq).nexttoken == 0)) {
        s = cc_lex$strtoken((struct cc_decls$tokenrec *)seq,&length);
        (*dest).length = length;
        (*dest).svalue = s;
        return;
    }
;
    mlib$gs_init((struct mlib$strbuffer *)deststr);
    cc_lex$lasttoken = (i64)0;
    addspace = (i64)0;
    L430 :;
    while (!!(seq)) {
        cc_lex$emittoken((struct cc_decls$tokenrec *)seq,(struct mlib$strbuffer *)deststr,addspace);
        addspace = (i64)1;
        seq = (struct cc_decls$tokenrec *)(*seq).nexttoken;
L431 :;
    }
L432 :;
    ;
    (*dest).length = length;
    (*dest).svalue = (*deststr).strptr;
    (*dest).length = (i64)(*deststr).length;
}

static void cc_lex$pastetokens(struct cc_decls$tokenrec *tk,struct cc_decls$tokenrec **tknext) {
        struct cc_decls$tokenrec *  tk2;
        i64 length1;
        i64 length2;
        u8 *  s;
        u8 *  t;
        u8 *  u;
        struct cc_decls$tokenrec oldtoken;
        struct cc_decls$tokenrec token;
        u8 *  oldlxsptr;
        i64 oldlx_stackindex;
    tk2 = (struct cc_decls$tokenrec *)(*tk).nexttoken;
    if ((tk2 == (*tknext))) {
        (*tknext) = tk;
    }
;
    (*tk).nexttoken = (*tk2).nexttoken;
    if (((i64)(*tk).symbol == (i64)67)) {
        if (((i64)(*tk2).symbol == (i64)67)) {
        }
        else {
            (*tk) = (*tk2);
        }
;
    }
    else if (((i64)(*tk2).symbol == (i64)67)) {
    }
    else {
        s = cc_lex$strtoken((struct cc_decls$tokenrec *)tk,&length1);
        t = cc_lex$strtoken((struct cc_decls$tokenrec *)tk2,&length2);
        u = (u8 *)mlib$pcm_alloc((length1 + length2));
        memcpy((void *)u,(void *)s,(u64)length1);
        memcpy((void *)(u + length1),(void *)t,(u64)length2);
        (*((u + length1) + length2)) = (u64)0u;
        if ((cc_lex$npastedtokens >= (i64)7000)) {
            cc_lex$lxerror((byte*)"Too many pasted tokens");
        }
;
        cc_lex$pastedtokenlist[(++(cc_lex$npastedtokens))-1] = u;
        oldtoken = cc_decls$nextlx;
        oldlxsptr = cc_lex$lxsptr;
        oldlx_stackindex = cc_lex$lx_stackindex;
        cc_lex$lxsptr = u;
        cc_lex$lx_stackindex = (i64)0;
        cc_lex$setfileno((i64)0);
        cc_decls$nextlx.lineno = (i64)0;
        cc_lex$lexreadtoken();
        token = cc_decls$nextlx;
        cc_lex$lexreadtoken();
        if (((i64)cc_decls$nextlx.symbol != (i64)58)) {
        }
;
        cc_decls$nextlx = oldtoken;
        cc_lex$lxsptr = oldlxsptr;
        cc_lex$lx_stackindex = oldlx_stackindex;
        token.nexttoken = (*tk).nexttoken;
        cc_lex$setfilenox((struct cc_decls$tokenrec *)&token,(i64)0);
        token.pasteno = cc_lex$npastedtokens;
        token.flags |= (u8)8u;
        (*tk) = token;
    }
;
}

static i64 cc_lex$getifexpr(void) {
        i64 sx;
        i64 x;
    cc_lex$lexm();
    x = cc_lex$evalcondexpr(&sx);
    if (((i64)cc_decls$nextlx.symbol != (i64)57)) {
        cc_lex$lxerror((byte*)"#if:eol expected");
    }
;
    return (i64)(x != (i64)0);
}

static i64 cc_lex$evalcondexpr(i64 *sx) {
        i64 x;
        i64 y;
        i64 z;
        i64 sy;
        i64 sz;
    x = cc_lex$evalorexpr(sx);
    if (((i64)cc_decls$nextlx.symbol == (i64)19)) {
        cc_lex$lexm();
        y = cc_lex$evalcondexpr(&sy);
        if (((i64)cc_decls$nextlx.symbol != (i64)10)) {
            cc_lex$lxerror((byte*)": expected");
        }
;
        cc_lex$lexm();
        z = cc_lex$evalcondexpr(&sz);
        if (!!(x)) {
            (*sx) = sy;
            x = y;
        }
        else {
            (*sx) = sz;
            x = z;
        }
;
    }
;
    return x;
}

static i64 cc_lex$evalorexpr(i64 *sx) {
        i64 x;
        i64 y;
        i64 sy;
    x = cc_lex$evalandexpr(sx);
    L433 :;
    while (((i64)cc_decls$nextlx.symbol == (i64)31)) {
        cc_lex$lexm();
        y = cc_lex$evalandexpr(&sy);
        x = ((!!(x) || !!(y)) ? (i64)1 : (i64)0);
L434 :;
    }
L435 :;
    ;
    return x;
}

static i64 cc_lex$evalandexpr(i64 *sx) {
        i64 x;
        i64 y;
        i64 sy;
    x = cc_lex$evaliorexpr(sx);
    L436 :;
    while (((i64)cc_decls$nextlx.symbol == (i64)32)) {
        cc_lex$lexm();
        y = cc_lex$evaliorexpr(&sy);
        x = ((!!(x) && !!(y)) ? (i64)1 : (i64)0);
L437 :;
    }
L438 :;
    ;
    return x;
}

static i64 cc_lex$evaliorexpr(i64 *sx) {
        i64 x;
        i64 sy;
    x = cc_lex$evalixorexpr(sx);
    L439 :;
    while (((i64)cc_decls$nextlx.symbol == (i64)28)) {
        cc_lex$lexm();
        x |= cc_lex$evalixorexpr(&sy);
L440 :;
    }
L441 :;
    ;
    return x;
}

static i64 cc_lex$evalixorexpr(i64 *sx) {
        i64 x;
        i64 sy;
    x = cc_lex$evaliandexpr(sx);
    L442 :;
    while (((i64)cc_decls$nextlx.symbol == (i64)30)) {
        cc_lex$lexm();
        x ^= cc_lex$evaliandexpr(&sy);
L443 :;
    }
L444 :;
    ;
    return x;
}

static i64 cc_lex$evaliandexpr(i64 *sx) {
        i64 x;
        i64 sy;
    x = cc_lex$evaleqexpr(sx);
    L445 :;
    while (((i64)cc_decls$nextlx.symbol == (i64)29)) {
        cc_lex$lexm();
        x &= cc_lex$evaleqexpr(&sy);
L446 :;
    }
L447 :;
    ;
    return x;
}

static i64 cc_lex$evaleqexpr(i64 *sx) {
        i64 x;
        i64 y;
        i64 sy;
        i64 opc;
    x = cc_lex$evalcmpexpr(sx);
    L448 :;
    while ((((opc = (i64)cc_decls$nextlx.symbol) == (i64)40) || (opc == (i64)41))) {
        cc_lex$lexm();
        y = cc_lex$evalcmpexpr(&sy);
        if ((opc==(i64)40)) {
            x = (i64)(x == y);
        }
        else if ((opc==(i64)41)) {
            x = (i64)(x != y);
        }
;
L449 :;
    }
L450 :;
    ;
    return x;
}

static i64 cc_lex$evalcmpexpr(i64 *sx) {
        i64 x;
        i64 y;
        i64 sy;
        i64 opc;
    x = cc_lex$evalshiftexpr(sx);
    L451 :;
    while ((((((opc = (i64)cc_decls$nextlx.symbol) == (i64)42) || (opc == (i64)43)) || (opc == (i64)44)) || (opc == (i64)45))) {
        cc_lex$lexm();
        y = cc_lex$evalshiftexpr(&sy);
        if ((opc==(i64)42)) {
            x = (i64)(x < y);
        }
        else if ((opc==(i64)43)) {
            x = (i64)(x <= y);
        }
        else if ((opc==(i64)44)) {
            x = (i64)(x >= y);
        }
        else if ((opc==(i64)45)) {
            x = (i64)(x > y);
        }
;
L452 :;
    }
L453 :;
    ;
    return x;
}

static i64 cc_lex$evalshiftexpr(i64 *sx) {
        i64 x;
        i64 y;
        i64 sy;
        i64 opc;
    x = cc_lex$evaladdexpr(sx);
    L454 :;
    while ((((opc = (i64)cc_decls$nextlx.symbol) == (i64)33) || (opc == (i64)34))) {
        cc_lex$lexm();
        y = cc_lex$evaladdexpr(&sy);
        if ((opc==(i64)34)) {
            x = (x >> y);
        }
        else if ((opc==(i64)33)) {
            x = (x << y);
        }
;
L455 :;
    }
L456 :;
    ;
    return x;
}

static i64 cc_lex$evaladdexpr(i64 *sx) {
        i64 x;
        i64 y;
        i64 sy;
        i64 opc;
    x = cc_lex$evalmulexpr(sx);
    L457 :;
    while ((((opc = (i64)cc_decls$nextlx.symbol) == (i64)23) || (opc == (i64)24))) {
        cc_lex$lexm();
        y = cc_lex$evalmulexpr(&sy);
        if ((opc==(i64)23)) {
            x += y;
        }
        else if ((opc==(i64)24)) {
            x -= y;
        }
;
L458 :;
    }
L459 :;
    ;
    return x;
}

static i64 cc_lex$evalmulexpr(i64 *sx) {
        i64 x;
        i64 y;
        i64 sy;
        i64 opc;
    x = cc_lex$evalunaryexpr(sx);
    L460 :;
    while (((((opc = (i64)cc_decls$nextlx.symbol) == (i64)25) || (opc == (i64)26)) || (opc == (i64)27))) {
        cc_lex$lexm();
        y = cc_lex$evalunaryexpr(&sy);
        if (((y == (i64)0) && (opc != (i64)25))) {
            cc_lex$lxerror((byte*)"#if:div by zero");
        }
;
        if ((opc==(i64)25)) {
            x *= y;
        }
        else if ((opc==(i64)26)) {
            x = (x / y);
        }
        else if ((opc==(i64)27)) {
            x = (x % y);
        }
;
L461 :;
    }
L462 :;
    ;
    return x;
}

static i64 cc_lex$evalunaryexpr(i64 *sx) {
        i64 x;
        i64 opc;
        {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)23) || ($temp==(i64)24) || ($temp==(i64)36) || ($temp==(i64)35)) {
        opc = (i64)cc_decls$nextlx.symbol;
        cc_lex$lexm();
        x = cc_lex$evalunaryexpr(sx);
        if ((opc==(i64)23)) {
            return x;
        }
        else if ((opc==(i64)24)) {
            return -(x);
        }
        else if ((opc==(i64)36)) {
            return (i64)!(!!(x));
        }
        else if ((opc==(i64)35)) {
            return ~(x);
        }
;
    }
    };
    return cc_lex$evalterm(sx);
}

static i64 cc_lex$evalterm(i64 *sx) {
        i64 res;
        i64 lb;
    (*sx) = (i64)1;
        {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)69)) {
                {i64 $temp = (i64)(*cc_decls$nextlx.symptr).symbol;
if (($temp==(i64)94)) {
            cc_lex$noexpand = (i64)1;
            lb = (i64)0;
            cc_lex$lexm();
            if (((i64)cc_decls$nextlx.symbol == (i64)13)) {
                lb = (i64)1;
                cc_lex$lexm();
            }
;
            if (((i64)cc_decls$nextlx.symbol != (i64)69)) {
                cc_lex$lxerror((byte*)"defined?");
            }
;
            res = (i64)((i64)(*cc_decls$nextlx.symptr).nameid == (i64)1);
            cc_lex$lexm();
            if (!!(lb)) {
                if (((i64)cc_decls$nextlx.symbol != (i64)14)) {
                    cc_lex$lxerror((byte*)"')' expected");
                }
;
                cc_lex$lexm();
            }
;
            cc_lex$noexpand = (i64)0;
        }
        else if (($temp==(i64)92)) {
            cc_lex$lexm();
            if (((i64)cc_decls$nextlx.symbol != (i64)13)) {
                cc_lex$lxerror((byte*)"'(' expected");
            }
;
            cc_lex$lexm();
            if (((i64)cc_decls$nextlx.symbol != (i64)69)) {
                cc_lex$lxerror((byte*)"name expected");
            }
;
                        {i64 $temp = (i64)(*cc_decls$nextlx.symptr).symbol;
if (($temp==(i64)72)) {
                res = (i64)cc_tables$typespecsizes[((i64)(*cc_decls$nextlx.symptr).subcode)-1];
            }
            else {
                cc_lex$lxerror((byte*)"sizeof2");
            }
            };
            cc_lex$lexm();
            if (((i64)cc_decls$nextlx.symbol != (i64)14)) {
                cc_lex$lxerror((byte*)"')' expected");
            }
;
            cc_lex$lexm();
        }
        else {
            cc_lex$lexm();
            return (i64)0;
        }
        };
    }
    else if (($temp==(i64)60)) {
        res = cc_decls$nextlx.value;
        cc_lex$lexm();
    }
    else if (($temp==(i64)62)) {
        if (((i64)cc_decls$nextlx.length == (i64)0)) {
            res = (i64)0;
        }
        else {
            res = (i64)(u64)(*cc_decls$nextlx.svalue);
        }
;
        cc_lex$lexm();
    }
    else if (($temp==(i64)13)) {
        cc_lex$lexm();
        res = cc_lex$evalcondexpr(sx);
        if (((i64)cc_decls$nextlx.symbol != (i64)14)) {
            cc_lex$lxerror((byte*)") expected");
        }
;
        cc_lex$lexm();
    }
    else {
        cc_lex$printsymbol((struct cc_decls$tokenrec *)&cc_decls$nextlx);
        cc_lex$printstrn(cc_decls$nextlx.svalue,(i64)cc_decls$nextlx.length,0);
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lex$lxerror((byte*)"evalterm?");
    }
    };
    return res;
}

static i64 cc_lex$getifdef(void) {
        i64 res;
        struct cc_decls$strec *  d;
    cc_lex$noexpand = (i64)1;
    cc_lex$lexreadtoken();
    cc_lex$noexpand = (i64)0;
    if (((i64)cc_decls$nextlx.symbol != (i64)69)) {
        cc_lex$lxerror((byte*)"Name expected");
    }
;
    d = (struct cc_decls$strec *)cc_decls$nextlx.symptr;
    res = (i64)0;
    if (((i64)(*d).nameid == (i64)1)) {
        res = (i64)1;
    }
    else if (((i64)(*d).symbol == (i64)71)) {
        res = (i64)1;
    }
;
    cc_lex$lexreadtoken();
    if (((i64)cc_decls$nextlx.symbol != (i64)57)) {
        cc_lex$lxerror((byte*)"EOL expected");
    }
;
    return res;
}

static i64 cc_lex$skipcode(void) {
        i64 level;
        i64 dir;
    level = (i64)0;
    L463 :;
    while (1) {
        cc_lex$fastreadtoken();
                {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)4)) {
            dir = cc_lex$getlexdirective();
            if ((dir==(i64)3) || (dir==(i64)8) || (dir==(i64)9)) {
                ++(level);
            }
            else if ((dir==(i64)4) || (dir==(i64)5)) {
                if ((level == (i64)0)) {
                    return dir;
                }
;
            }
            else if ((dir==(i64)6)) {
                if ((level == (i64)0)) {
                    return dir;
                }
;
                --(level);
            }
;
        }
        else if (($temp==(i64)58)) {
            cc_lex$lxerror((byte*)"#if:Unexpected eof");
        }
        };
    }
L464 :;
    ;
    return (i64)0;
}

static void cc_lex$freetokens(struct cc_decls$tokenrec *tk) {
        struct cc_decls$tokenrec *  nexttk;
    L465 :;
    while (!!(tk)) {
        nexttk = (struct cc_decls$tokenrec *)(*tk).nexttoken;
        tk = (struct cc_decls$tokenrec *)nexttk;
L466 :;
    }
L467 :;
    ;
}

void cc_lex$fastreadtoken(void) {
        i64 c;
        i64 dodir;
        u8 *  p;
    cc_decls$nextlx.subcodex = (i64)0;
    L468 :;
    switch ((c = (i64)(u64)(*(cc_lex$lxsptr)++))) {
    case 35:;
        {
            p = (cc_lex$lxsptr - (i64)2);
            dodir = (i64)0;
            L470 :;
            while ((p >= cc_lex$lxstart)) {
                                {u64 $temp = (u64)(*p);
if (($temp==(u64)10u)) {
                    dodir = (i64)1;
                    goto L472 ;
                }
                else if (($temp==(u64)9u) || ($temp==' ')) {
                }
                else {
                    goto L472 ;
                }
                };
                --(p);
L471 :;
            }
L472 :;
            ;
            if ((!!(dodir) || (p < cc_lex$lxstart))) {
                cc_decls$nextlx.symbol = (i64)4;
                return;
            }
            else if (((u64)(*cc_lex$lxsptr) == '#')) {
                ++(cc_lex$lxsptr);
            }
;
        }
        break;
    case 47:;
        {
                        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='/')) {
                cc_lex$readlinecomment();
            }
            else if (($temp=='*')) {
                cc_lex$readblockcomment();
            }
            };
        }
        break;
    case 39:;
        {
            cc_lex$lxreadstring((i64)39,(i64)0);
        }
        break;
    case 34:;
        {
            cc_lex$lxreadstring((i64)34,(i64)0);
        }
        break;
    case 13:;
        {
            ++(cc_decls$nextlx.lineno);
            cc_decls$nextlx.symbol = (i64)57;
            cc_decls$nextlx.length = (i64)0;
            ++(cc_lex$lxsptr);
        }
        break;
    case 10:;
        {
            ++(cc_decls$nextlx.lineno);
            cc_decls$nextlx.symbol = (i64)57;
            cc_decls$nextlx.length = (i64)0;
        }
        break;
    case 0:;
        {
            --(cc_lex$lxsptr);
            if (!!(cc_lex$lx_stackindex)) {
                cc_lex$unstacksourcefile();
            }
            else {
                cc_decls$nextlx.symbol = (i64)58;
                return;
            }
;
        }
        break;
    case 12:;
        {
        }
        break;
    default: {
    }
    } //SW
goto L468 ;
L469 :;
    ;
}

static struct cc_decls$tokenrec *cc_lex$alloctoken(void) {
        struct cc_decls$tokenrec *  tk;
    tk = (struct cc_decls$tokenrec *)mlib$pcm_alloc((i64)32);
    return (struct cc_decls$tokenrec *)tk;
}

static struct cc_decls$tokenrec *cc_lex$alloctokenz(void) {
        struct cc_decls$tokenrec *  tk;
    tk = (struct cc_decls$tokenrec *)mlib$pcm_alloc((i64)32);
    (*tk).nexttoken = 0;
    return (struct cc_decls$tokenrec *)tk;
}

static void cc_lex$expandpredefmacro(i64 pdmcode,struct cc_decls$tokenrec *tk,i64 lineno) {
        u8 str[256];
        static u8 *  monthnames[12] = {
    (byte*)"Jan",
    (byte*)"Feb",
    (byte*)"Mar",
    (byte*)"Apr",
    (byte*)"May",
    (byte*)"Jun",
    (byte*)"Jul",
    (byte*)"Aug",
    (byte*)"Sep",
    (byte*)"Oct",
    (byte*)"Nov",
    (byte*)"Dec"
};
        struct mwindows$rsystemtime tm;
        u8 *  s;
        i64 fileno;
    if (!!(cc_lex$noexpand)) {
        return;
    }
;
    if ((pdmcode==(i64)1)) {
        mwindows$os_getsystime((struct mwindows$rsystemtime *)&tm);
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#-#-#");
        msysc$m_print_i64((i64)tm.day,NULL);
        msysc$m_print_str(monthnames[((i64)tm.month)-1],NULL);
        msysc$m_print_i64((i64)tm.year,(byte*)"4");
        msysc$m_print_end();
        ;
        (*tk).symbol = (i64)64;
        (*tk).svalue = mlib$pcm_copyheapstring((u8 *)str);
    }
    else if ((pdmcode==(i64)2)) {
        mwindows$os_getsystime((struct mwindows$rsystemtime *)&tm);
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#:#:#");
        msysc$m_print_i64((i64)tm.hour,(byte*)"2");
        msysc$m_print_i64((i64)tm.minute,(byte*)"z2");
        msysc$m_print_i64((i64)tm.second,(byte*)"z2");
        msysc$m_print_end();
        ;
        (*tk).symbol = (i64)64;
        (*tk).svalue = mlib$pcm_copyheapstring((u8 *)str);
    }
    else if ((pdmcode==(i64)3)) {
        (*tk).symbol = (i64)64;
        fileno = cc_lex$getfilenox((struct cc_decls$tokenrec *)tk);
        if ((fileno == (i64)0)) {
            fileno = cc_decls$sfileno;
        }
;
        if (!!(cc_decls$sfileno)) {
            (*tk).svalue = cc_decls$sourcefilenames[(cc_decls$sfileno)];
        }
        else {
            (*tk).svalue = (byte*)"(File not available)";
        }
;
    }
    else if ((pdmcode==(i64)5)) {
        (*tk).symbol = (i64)64;
        if (!!(cc_decls$currproc)) {
            (*tk).svalue = (*cc_decls$currproc).name;
        }
        else {
            (*tk).svalue = (byte*)"???";
        }
;
    }
    else if ((pdmcode==(i64)4)) {
        (*tk).symbol = (i64)60;
        (*tk).value = lineno;
    }
    else if ((pdmcode==(i64)8)) {
        (*tk).symbol = (i64)60;
        (*tk).value = (i64)1;
    }
    else if ((pdmcode==(i64)7)) {
        (*tk).symbol = (i64)60;
        (*tk).value = (i64)1;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_i64(pdmcode,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lex$lxerror((byte*)"PDM");
    }
;
    if (((i64)(*tk).symbol == (i64)64)) {
        (*tk).length = strlen((*tk).svalue);
        (*tk).subcode = cc_decls$trefchar;
    }
    else {
        (*tk).subcode = (i64)4;
        s = (u8 *)mlib$pcm_alloc((i64)16);
        msysc$getstrint((*tk).value,s);
        (*tk).length = strlen(s);
        if ((cc_lex$npastedtokens >= (i64)7000)) {
            cc_lex$lxerror((byte*)"2:Too many pasted tokens");
        }
;
        cc_lex$pastedtokenlist[(++(cc_lex$npastedtokens))-1] = s;
        cc_lex$setfilenox((struct cc_decls$tokenrec *)tk,(i64)0);
        (*tk).pasteno = cc_lex$npastedtokens;
    }
;
}

static void cc_lex$dopragmadir(void) {
    cc_lex$lexm();
    if (((i64)cc_decls$nextlx.symbol == (i64)69)) {
        if ((memcmp((void *)(*cc_decls$nextlx.symptr).name,(byte*)"pack",(u64)4u) == (i64)0)) {
            cc_lex$lexm();
            if (((i64)cc_decls$nextlx.symbol != (i64)13)) {
                cc_lex$lxerror((byte*)"'(' expected");
            }
;
            cc_lex$lexm();
            if (((i64)cc_decls$nextlx.symbol == (i64)60)) {
                                {i64 $temp = cc_decls$nextlx.value;
if (($temp==(i64)1)) {
                    cc_decls$structpadding = (i64)0;
                }
                else {
                    goto L473 ;
;
                    cc_lex$lxerror((byte*)"Only pack(1) or () allowed");
                }
                };
                cc_lex$lexm();
            }
            else if (((i64)cc_decls$nextlx.symbol == (i64)14)) {
                cc_decls$structpadding = (i64)1;
            }
;
        }
        else if ((memcmp((void *)(*cc_decls$nextlx.symptr).name,(byte*)"$callback",(u64)9u) == (i64)0)) {
            cc_decls$callbackflag = (i64)1;
        }
;
    }
;
    //finish:
L473 :;
;
    L474 :;
    while ((((i64)cc_decls$nextlx.symbol != (i64)57) && ((i64)cc_decls$nextlx.symbol != (i64)58))) {
        cc_lex$lexm();
L475 :;
    }
L476 :;
    ;
}

static i64 cc_lex$needspace(i64 a,i64 b) {
        u8 *  aname;
        u8 *  bname;
    if ((a == (i64)0)) {
        return (i64)0;
    }
;
    aname = cc_tables$shortsymbolnames[(a)-1];
    bname = cc_tables$shortsymbolnames[(b)-1];
        {u64 $temp = (u64)(*bname);
if (($temp=='n') || ($temp=='k')) {
                {u64 $temp = (u64)(*aname);
if (($temp=='n') || ($temp=='k')) {
            return (i64)1;
        }
        };
    }
    else if (($temp=='-') || ($temp=='+')) {
                {u64 $temp = (u64)(*aname);
if (($temp=='-') || ($temp=='+')) {
            return (i64)1;
        }
        };
    }
    };
    return (i64)0;
}

void cc_lex$dospecialinclude(void) {
    ++(cc_lex$nincludes);
    cc_lex$stacksourcefile((byte*)"bcc.h",(i64)1);
    if (!!(cc_decls$dheaderfile)) {
        cc_lex$stacksourcefile(cc_decls$dheaderfile,(i64)1);
    }
;
}

static void cc_lex$addautomodule(u8 *headername,i64 fileno) {
        u8 *  cfilename;
        u8 *  headerfile;
        i64 present;
        i64 i;
    headerfile = cc_decls$sourcefilepaths[(fileno)];
    if (!(!!(cc_decls$fautomodules))) {
        return;
    }
;
    if (!!(mlib$eqstring(mlib$extractext(headerfile,(i64)0),(byte*)"c"))) {
        return;
    }
;
    cfilename = mlib$changeext(headerfile,(byte*)"c");
    if (!!(mlib$checkfile(cfilename))) {
        present = (i64)1;
        for (i=(i64)1;i<=cc_decls$nautomodules;++i) {
L477 :;
            if (!!(mlib$eqstring(cc_decls$automodulenames[(i)],cfilename))) {
                present = (i64)0;
                goto L479 ;
            }
;
L478 :;
        }
L479 :;
        ;
        if (!!(present)) {
            cc_decls$automodulenames[(++(cc_decls$nautomodules))] = mlib$pcm_copyheapstring(cfilename);
        }
;
    }
;
}

static void cc_lex$setnumberoffset(i64 offset) {
    cc_decls$nextlx.numberoffset = (((i64)cc_decls$nextlx.numberoffset & (i64)4278190080) | (offset & (i64)16777215));
}

static void cc_lex$setfileno(i64 fileno) {
    cc_decls$nextlx.fileno = (fileno & (i64)255);
    cc_decls$nextlx.numberoffset = (((i64)cc_decls$nextlx.numberoffset & (i64)16777215) | ((fileno & (i64)65280) << (i64)16));
}

static void cc_lex$setfilenox(struct cc_decls$tokenrec *tk,i64 fileno) {
    (*tk).fileno = (fileno & (i64)255);
    (*tk).numberoffset = (((i64)(*tk).numberoffset & (i64)16777215) | ((fileno & (i64)65280) << (i64)16));
}

static i64 cc_lex$getfileno(void) {
    return ((((i64)cc_decls$nextlx.numberoffset >> (i64)24) << (i64)8) | (i64)cc_decls$nextlx.fileno);
}

static i64 cc_lex$getfilenox(struct cc_decls$tokenrec *tk) {
    return ((((i64)(*tk).numberoffset >> (i64)24) << (i64)8) | (i64)(*tk).fileno);
}

static i64 cc_lex$getnumberoffsetx(struct cc_decls$tokenrec *tk) {
    return ((i64)(*tk).numberoffset & (i64)16777215);
}

void cc_lex$freehashtable(void) {
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  e;
        struct cc_decls$strec *  f;
        i64 i;
    for (i=(i64)0;i<=cc_decls$hstmask;++i) {
L480 :;
        d = (struct cc_decls$strec *)(*cc_decls$hashtable)[(i)];
        if ((!!((*d).name) && ((i64)(*d).symbol == (i64)69))) {
            if (((i64)(*d).nameid == (i64)1)) {
                cc_lex$freetokens((struct cc_decls$tokenrec *)(*d).tokenlist);
            }
;
            f = (struct cc_decls$strec *)(*d).nextdupl;
            L483 :;
            while (!!(f)) {
                cc_lex$freestentry((struct cc_decls$strec *)f);
                e = (struct cc_decls$strec *)(*f).nextdupl;
                mlib$pcm_free(f,(i64)128);
                f = e;
L484 :;
            }
L485 :;
            ;
            mlib$pcm_clearmem((*cc_decls$hashtable)[(i)],(i64)128);
        }
        else if (!!((*d).name)) {
            (*d).nextdupl = 0;
        }
;
L481 :;
    }
L482 :;
    ;
}

static void cc_lex$freestentry(struct cc_decls$strec *d) {
}

static void cc_lex$regenlookup(struct cc_decls$strec *d) {
        i64 j;
        i64 wrapped;
        i64 length;
        struct cc_decls$strec *  e;
    j = ((i64)cc_lex$gethashvalue((*d).name,(i64)(*d).namelen) & cc_decls$hstmask);
    wrapped = (i64)0;
    L486 :;
    while (1) {
        e = (struct cc_decls$strec *)(*cc_decls$hashtable)[(j)];
        length = (i64)(*e).namelen;
        if (!(!!(length))) {
            mlib$pcm_free((*cc_decls$hashtable)[(j)],(i64)128);
            (*cc_decls$hashtable)[(j)] = (struct cc_decls$strec *)d;
            ++(cc_lex$nhstsymbols);
            return;
        }
;
        if ((length == (i64)(*d).namelen)) {
            if ((memcmp((void *)(*e).name,(void *)(*d).name,(u64)length) == (i64)0)) {
                cc_lex$lxerror((byte*)"regenhst dupl?");
            }
;
        }
;
        if ((++(j) >= cc_decls$hstsize)) {
            if (!!(wrapped)) {
                mlib$abortprogram((byte*)"REGENHST FULL?");
            }
;
            wrapped = (i64)1;
            j = (i64)0;
        }
;
    }
L487 :;
    ;
}

static void cc_lex$printhashtable(u8 *caption) {
        struct cc_decls$strec *  d;
        i64 $av_1;
        i64 i;
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
        ($av_1 = (cc_decls$hstsize - (i64)1));
    for (i=(i64)0;i<=$av_1;++i) {
L488 :;
        d = (struct cc_decls$strec *)(*cc_decls$hashtable)[(i)];
        if (!!((*d).name)) {
            msysc$m_print_startcon();
            msysc$m_print_i64(i,NULL);
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_str((*d).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_i64(i,NULL);
            msysc$m_print_str((byte*)": ----",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
L489 :;
    }
L490 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void cc_lex$newhashtable(void) {
        struct cc_decls$strec *(*oldhashtable)[];
        i64 oldhstsize;
        struct cc_decls$strec *  d;
        i64 $av_1;
        i64 i;
    oldhashtable = (struct cc_decls$strec *(*)[])cc_decls$hashtable;
    oldhstsize = cc_decls$hstsize;
    cc_decls$hstsize *= (i64)2;
    cc_decls$hstmask = (cc_decls$hstsize - (i64)1);
    cc_lex$nhstsymbols = (i64)0;
    cc_lex$hstthreshold = (((i64)6 * cc_decls$hstsize) / (i64)10);
    cc_decls$hashtable = (struct cc_decls$strec *(*)[])mlib$pcm_alloc((cc_decls$hstsize * (i64)8));
    for (i=(i64)0;i<=cc_decls$hstmask;++i) {
L491 :;
        (*cc_decls$hashtable)[(i)] = (struct cc_decls$strec *)mlib$pcm_allocz((i64)128);
L492 :;
    }
L493 :;
    ;
        ($av_1 = (oldhstsize - (i64)1));
    for (i=(i64)0;i<=$av_1;++i) {
L494 :;
        d = (struct cc_decls$strec *)(*oldhashtable)[(i)];
        if (!!((*d).name)) {
            cc_lex$regenlookup((struct cc_decls$strec *)d);
        }
;
L495 :;
    }
L496 :;
    ;
    mlib$pcm_free(oldhashtable,(oldhstsize * (i64)8));
}

static void cc_lex$old_readrealnumber(u8 *pstart,u8 *intstart,i64 intlen,i64 base) {
        u8 *  fractstart;
        i64 fractlen;
        i64 expon;
        i64 i;
        i64 c;
        i64 badexpon;
        r64 basex;
        r64 x;
        r64 expbase;
        u8 realstr[500];
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
    fractstart = 0;
    fractlen = (i64)0;
    expon = (i64)0;
    if (((u64)(*cc_lex$lxsptr) == '.')) {
        fractstart = ++(cc_lex$lxsptr);
        fractlen = (cc_lex$scannumber(base) - fractstart);
    }
;
    badexpon = (i64)0;
        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='e') || ($temp=='E')) {
        if ((base != (i64)16)) {
            ++(cc_lex$lxsptr);
            expon = cc_lex$readexponent(&badexpon);
        }
;
    }
    else if (($temp=='p') || ($temp=='P')) {
        if ((base == (i64)16)) {
            ++(cc_lex$lxsptr);
            expon = cc_lex$readexponent(&badexpon);
        }
;
    }
    };
    if (!!(badexpon)) {
        --(cc_lex$lxsptr);
        cc_lex$readalphanumeric(pstart);
        return;
    }
;
        {u64 $temp = (u64)(*cc_lex$lxsptr);
if (($temp=='f') || ($temp=='F') || ($temp=='l') || ($temp=='L')) {
        ++(cc_lex$lxsptr);
    }
    else {
        if (!!((u64)cc_lex$alphamap[((i64)(u64)(*cc_lex$lxsptr))])) {
            cc_lex$readalphanumeric(pstart);
            return;
        }
;
    }
    };
    if (((intlen + fractlen) > (i64)500)) {
        cc_lex$lxerror((byte*)"Real too long");
    }
;
    if (!!(intlen)) {
        memcpy(&realstr,(void *)intstart,(u64)intlen);
    }
;
    if (!!(fractlen)) {
        memcpy((&realstr[((i64)1)-1] + intlen),(void *)fractstart,(u64)fractlen);
    }
;
    expbase = (basex = (r64)base);
    if ((base == (i64)10)) {
        expon -= fractlen;
    }
    else {
        expon -= (fractlen * (i64)4);
        expbase = (double)2.;
    }
;
    x = (double)0.;
        ($av_1 = (intlen + fractlen));
    for (i=(i64)1;i<=$av_1;++i) {
L497 :;
        c = (i64)(u64)realstr[(i)-1];
        if (((c >= (i64)48) && (c <= (i64)57))) {
            x = ((x * basex) + (r64)(c - (i64)48));
        }
        else if ((c > (i64)97)) {
            x = ((((x * basex) + (r64)c) - (r64)'a') + (double)10.);
        }
        else {
            x = ((((x * basex) + (r64)c) - (r64)'A') + (double)10.);
        }
;
L498 :;
    }
L499 :;
    ;
    if ((expon >= (i64)0)) {
        $av_2 = expon;
        while ($av_2-- > 0) {
L500 :;
            x *= expbase;
L501 :;
        }
L502 :;
        ;
    }
    else {
        $av_3 = -(expon);
        while ($av_3-- > 0) {
L503 :;
            x /= expbase;
L504 :;
        }
L505 :;
        ;
    }
;
    cc_decls$nextlx.symbol = (i64)61;
    cc_decls$nextlx.subcode = (i64)12;
    cc_decls$nextlx.xvalue = x;
    cc_lex$setnumberoffset((intstart - cc_lex$lxstart));
    cc_decls$nextlx.length = (cc_lex$lxsptr - intstart);
}

i64 cc_lex$issimpleconstmacro(struct cc_decls$strec *m) {
        struct cc_decls$tokenrec *  tk;
        static u8 *  specialnames[3] = {(byte*)"stdin",(byte*)"stdout",(byte*)"stderr"};
        i64 i;
    for (i=(i64)1;i<=(i64)3;++i) {
L506 :;
        if (!!(mlib$eqstring(specialnames[(i)-1],(*m).name))) {
            return (i64)2;
        }
;
L507 :;
    }
L508 :;
    ;
    tk = (struct cc_decls$tokenrec *)(*m).tokenlist;
    if ((!!(tk) && ((*tk).nexttoken == 0))) {
        if ((((i64)(*tk).symbol == (i64)60) || ((i64)(*tk).symbol == (i64)61))) {
            return (i64)1;
        }
;
    }
;
    return (i64)0;
}

// START
void cc_lex$start(void) {

}

static struct cc_decls$strec *cc_lib$newstrec(void) {
        struct cc_decls$strec *  p;
    p = (struct cc_decls$strec *)mlib$pcm_alloc((i64)128);
    memset(p,(i32)(i64)0,(u64)128u);
    (*p).lineno = ((i64)cc_decls$lx.lineno + ((i64)cc_decls$lx.fileno << (i64)24));
    (*p).attribs.ax_moduleno = cc_decls$currmoduleno;
    return (struct cc_decls$strec *)p;
}

void cc_lib$initcclib(void) {
}

void cc_lib$printst(void *f,struct cc_decls$strec *p,i64 level) {
        struct cc_decls$strec *  q;
    if (((i64)(*p).symbol != (i64)69)) {
        cc_support$mcerror((byte*)"PRINTST not name");
    }
;
    cc_lib$printstrec(f,(struct cc_decls$strec *)p,level);
    q = (struct cc_decls$strec *)(*p).deflist;
    L509 :;
    while ((q != 0)) {
        cc_lib$printst(f,(struct cc_decls$strec *)q,(level + (i64)1));
        q = (struct cc_decls$strec *)(*q).nextdef;
L510 :;
    }
L511 :;
    ;
}

static void cc_lib$printstrec(void *f,struct cc_decls$strec *p,i64 level) {
        struct cc_decls$attribrec attrs;
        struct mlib$strbuffer v;
        struct mlib$strbuffer *  d;
        i64 col;
        i64 offset;
        u8 str[256];
        struct cc_decls$paramrec *  pm;
        i64 $av_1;
    d = (struct mlib$strbuffer *)&v;
    mlib$gs_init((struct mlib$strbuffer *)d);
    offset = (i64)0;
    $av_1 = level;
    while ($av_1-- > 0) {
L512 :;
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"    ");
        offset += (i64)4;
L513 :;
    }
L514 :;
    ;
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)":");
    if (!!((i64)(*p).blockno)) {
        msysc$m_print_startstr(str);
        msysc$m_print_str((*p).name,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)".",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64((i64)(*p).blockno,NULL);
        msysc$m_print_end();
        ;
        mlib$gs_leftstr((struct mlib$strbuffer *)d,(u8 *)str,((i64)28 - offset),(i64)45);
    }
    else {
        mlib$gs_leftstr((struct mlib$strbuffer *)d,(*p).name,((i64)28 - offset),(i64)45);
    }
;
    mlib$gs_leftstr((struct mlib$strbuffer *)d,cc_tables$namenames[((i64)(*p).nameid)],(i64)12,(i64)46);
    col = mlib$gs_getcol((struct mlib$strbuffer *)d);
    attrs = (*p).attribs;
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"[");
    mlib$gs_str((struct mlib$strbuffer *)d,cc_tables$scopenames[((i64)(*p).scope)]);
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" ");
    if (!!((i64)attrs.ax_static)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Stat");
    }
;
    if (!!((i64)attrs.ax_align)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"@@");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)attrs.ax_align);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" ");
    }
;
    if (!!((i64)attrs.ax_varparams)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Var ");
    }
;
    if (!!((i64)attrs.ax_used)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Used ");
    }
;
    if (!!((i64)attrs.ax_forward)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Fwd ");
    }
;
    if (!!((i64)attrs.ax_frame)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Frm ");
    }
;
    if (!!((i64)attrs.ax_autovar)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"AV ");
    }
;
    if (!!((i64)attrs.ax_nparams)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"Pm:# ");
        msysc$m_print_i64((i64)attrs.ax_nparams,NULL);
        msysc$m_print_end();
        ;
        mlib$gs_str((struct mlib$strbuffer *)d,(u8 *)str);
    }
;
    if (!!((i64)attrs.ax_moduleno)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"M# ");
        msysc$m_print_i64((i64)attrs.ax_moduleno,NULL);
        msysc$m_print_end();
        ;
        mlib$gs_str((struct mlib$strbuffer *)d,(u8 *)str);
    }
;
    if (!!((i64)attrs.ax_equals)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"= ");
    }
;
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"]");
    mlib$gs_padto((struct mlib$strbuffer *)d,(col + (i64)10),(i64)61);
    if (!!((*p).owner)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"(#)");
        msysc$m_print_str((*(*p).owner).name,NULL);
        msysc$m_print_end();
        ;
        mlib$gs_leftstr((struct mlib$strbuffer *)d,(u8 *)str,(i64)18,(i64)32);
    }
    else {
        mlib$gs_leftstr((struct mlib$strbuffer *)d,(byte*)"()",(i64)18,(i64)32);
    }
;
        {i64 $temp = (i64)(*p).mode;
if (($temp==(i64)1)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Void ");
    }
    else {
        mlib$gs_strsp((struct mlib$strbuffer *)d,cc_lib$strmode((i64)(*p).mode,(i64)1));
    }
    };
        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)10)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Offset:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(*p).offset);
    }
    else if (($temp==(i64)8) || ($temp==(i64)9)) {
        if (!!((*p).code)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"=");
            mlib$gs_strvar((struct mlib$strbuffer *)d,(struct mlib$strbuffer *)cc_lib$strexpr((struct cc_decls$unitrec *)(*p).code));
        }
;
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" Offset: ");
        mlib$gs_strint((struct mlib$strbuffer *)d,(*p).offset);
    }
    else if (($temp==(i64)6)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Index:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).index);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" Address:");
        msysc$m_print_startstr(str);
        msysc$m_print_ptr((*p).address,NULL);
        msysc$m_print_end();
        ;
        mlib$gs_str((struct mlib$strbuffer *)d,(u8 *)str);
        if (!!((i64)(*p).attribs.ax_callback)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"<callback fn>");
        }
;
    }
    else if (($temp==(i64)11)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Enum:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).index);
    }
    else if (($temp==(i64)7)) {
        if (!!((*p).code)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"=");
            mlib$gs_strvar((struct mlib$strbuffer *)d,(struct mlib$strbuffer *)cc_lib$strexpr((struct cc_decls$unitrec *)(*p).code));
        }
;
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"STATIC********");
    }
    };
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" ");
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Lineno:");
    mlib$gs_strint((struct mlib$strbuffer *)d,((i64)(*p).lineno & (i64)16777215));
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" ");
    mlib$gs_str((struct mlib$strbuffer *)d,cc_decls$sourcefilenames[(((i64)(*p).lineno >> (i64)24))]);
    if (((i64)(*p).nameid == (i64)6)) {
        mlib$gs_line((struct mlib$strbuffer *)d);
        pm = (struct cc_decls$paramrec *)(*p).paramlist;
        L515 :;
        while (!!(pm)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"\t\tParam: ");
            mlib$gs_leftstr((struct mlib$strbuffer *)d,(!!((*pm).def) ? (*(*pm).def).name : (byte*)"Anon"),(i64)10,(i64)45);
            mlib$gs_str((struct mlib$strbuffer *)d,cc_tables$pmflagnames[((i64)(*pm).flags)]);
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" Mode:");
            mlib$gs_str((struct mlib$strbuffer *)d,cc_lib$strmode((i64)(*pm).mode,(i64)1));
            mlib$gs_line((struct mlib$strbuffer *)d);
            pm = (struct cc_decls$paramrec *)(*pm).nextparam;
L516 :;
        }
L517 :;
        ;
    }
;
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" MODE:");
    mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).mode);
    mlib$gs_println((struct mlib$strbuffer *)d,f);
    if (!!((*p).code)) {
                {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)8) || ($temp==(i64)7)) {
            cc_lib$printunit(f,(struct cc_decls$unitrec *)(*p).code,(i64)-3,(byte*)"*");
        }
        };
    }
;
}

void cc_lib$printstflat(void *f) {
        i64 i;
        struct cc_decls$strec *  p;
        i64 $av_1;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"GLOBAL SYMBOL TABLE:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
        ($av_1 = (cc_decls$hstsize - (i64)1));
    for (i=(i64)0;i<=$av_1;++i) {
L518 :;
        p = (struct cc_decls$strec *)(*cc_decls$hashtable)[(i)];
        if (!!((*p).name)) {
                        {i64 $temp = (i64)(*p).symbol;
if (($temp==(i64)69) || ($temp==(i64)72) || ($temp==(i64)70)) {
                msysc$m_print_startfile(f);
                msysc$m_print_i64(i,NULL);
                msysc$m_print_ptr(p,NULL);
                msysc$m_print_str((byte*)":",NULL);
                msysc$m_print_str(cc_lib$getstname((struct cc_decls$strec *)p),NULL);
                msysc$m_print_str(cc_tables$symbolnames[((i64)(*p).symbol)-1],NULL);
                msysc$m_print_str(cc_tables$namenames[((i64)(*p).nameid)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                p = (struct cc_decls$strec *)(*p).nextdupl;
                L521 :;
                while (!!(p)) {
                    msysc$m_print_startfile(f);
                    msysc$m_print_str((byte*)"\t",NULL);
                    msysc$m_print_ptr(p,NULL);
                    msysc$m_print_str(cc_lib$getstname((struct cc_decls$strec *)p),NULL);
                    msysc$m_print_str(cc_tables$symbolnames[((i64)(*p).symbol)-1],NULL);
                    msysc$m_print_str(cc_tables$namenames[((i64)(*p).nameid)],NULL);
                    msysc$m_print_ptr((*p).prevdupl,NULL);
                    msysc$m_print_end();
                    ;
                    msysc$m_print_startfile(f);
                    msysc$m_print_str((byte*)"(From",NULL);
                    msysc$m_print_str((!!((*p).owner) ? cc_lib$getstname((struct cc_decls$strec *)(*p).owner) : (byte*)"-"),NULL);
                    msysc$m_print_nogap();
                    msysc$m_print_str((byte*)")",NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    p = (struct cc_decls$strec *)(*p).nextdupl;
L522 :;
                }
L523 :;
                ;
            }
            };
        }
;
L519 :;
    }
L520 :;
    ;
}

struct cc_decls$unitrec *cc_lib$createname(struct cc_decls$strec *p) {
        struct cc_decls$unitrec *  u;
    u = (struct cc_decls$unitrec *)cc_lib$allocunitrec();
    (*u).tag = (i64)3;
    (*u).def = (struct cc_decls$strec *)p;
    (*u).simple = (i64)1;
    return (struct cc_decls$unitrec *)u;
}

struct cc_decls$unitrec *cc_lib$createunit0(i64 tag) {
        struct cc_decls$unitrec *  u;
    u = (struct cc_decls$unitrec *)cc_lib$allocunitrec();
    (*u).tag = tag;
    return (struct cc_decls$unitrec *)u;
}

struct cc_decls$unitrec *cc_lib$createunit1(i64 tag,struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  u;
    u = (struct cc_decls$unitrec *)cc_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = (struct cc_decls$unitrec *)p;
    return (struct cc_decls$unitrec *)u;
}

struct cc_decls$unitrec *cc_lib$createunit2(i64 tag,struct cc_decls$unitrec *p,struct cc_decls$unitrec *q) {
        struct cc_decls$unitrec *  u;
    u = (struct cc_decls$unitrec *)cc_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = (struct cc_decls$unitrec *)p;
    (*u).b = (struct cc_decls$unitrec *)q;
    return (struct cc_decls$unitrec *)u;
}

struct cc_decls$unitrec *cc_lib$createunit3(i64 tag,struct cc_decls$unitrec *p,struct cc_decls$unitrec *q,struct cc_decls$unitrec *r) {
        struct cc_decls$unitrec *  u;
    u = (struct cc_decls$unitrec *)cc_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = (struct cc_decls$unitrec *)p;
    (*u).b = (struct cc_decls$unitrec *)q;
    (*u).c = (struct cc_decls$unitrec *)r;
    return (struct cc_decls$unitrec *)u;
}

struct cc_decls$unitrec *cc_lib$createconstunit(u64 a,i64 t) {
        struct cc_decls$unitrec *  u;
    u = (struct cc_decls$unitrec *)cc_lib$allocunitrec();
    (*u).tag = (i64)1;
    (*u).value = (i64)a;
    (*u).mode = t;
    (*u).simple = (i64)1;
    return (struct cc_decls$unitrec *)u;
}

struct cc_decls$unitrec *cc_lib$createstringconstunit(u8 *s,i64 length) {
        struct cc_decls$unitrec *  u;
    u = (struct cc_decls$unitrec *)cc_lib$allocunitrec();
    (*u).tag = (i64)1;
    (*u).svalue = s;
    (*u).mode = cc_decls$trefchar;
    if ((length == (i64)-1)) {
        (*u).slength = strlen(s);
    }
    else {
        (*u).slength = length;
    }
;
    (*u).isstrconst = (i64)1;
    (*u).simple = (i64)1;
    return (struct cc_decls$unitrec *)u;
}

struct cc_decls$unitrec *cc_lib$createwstringconstunit(u16 *s,i64 length) {
        struct cc_decls$unitrec *  u;
    u = (struct cc_decls$unitrec *)cc_lib$allocunitrec();
    (*u).tag = (i64)1;
    (*u).wsvalue = s;
    (*u).mode = cc_decls$trefwchar;
    (*u).wslength = length;
    (*u).iswstrconst = (i64)1;
    (*u).simple = (i64)1;
    return (struct cc_decls$unitrec *)u;
}

i64 cc_lib$getoptocode(i64 opc) {
        static i16 opctotable[79];
        i64 opcto;
        i64 i;
        u8 str[20];
    opcto = (i64)opctotable[(opc)];
    if (!!(opcto)) {
        return opcto;
    }
;
    strcpy((u8 *)str,cc_tables$jtagnames[(opc)]);
    strcat((u8 *)str,(byte*)"to");
    for (i=(i64)0;i<=(i64)78;++i) {
L524 :;
        if (!!(mlib$eqstring(cc_tables$jtagnames[(i)],(u8 *)str))) {
            opctotable[(opc)] = i;
            return i;
        }
;
L525 :;
    }
L526 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str(cc_tables$jtagnames[(opc)],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_support$serror((byte*)"Can't find -to version");
    return (i64)0;
}

i64 cc_lib$getconstvalue(struct cc_decls$unitrec *p,i64 id) {
    if ((!!(p) && ((i64)(*p).tag == (i64)1))) {
        return (*p).value;
    }
;
    cc_support$serror((byte*)"GCV Not constant");
    return (i64)0;
}

u8 *cc_lib$nextautotype(void) {
        static u8 str[32];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"$T",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(++(cc_lib$autotypeno),NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

i64 cc_lib$createconstmode(i64 m) {
        i64 newm;
    if (!!((i64)cc_decls$ttconst[(m)])) {
        return m;
    }
;
    if (!!(cc_decls$ttconsttype[(m)])) {
        return cc_decls$ttconsttype[(m)];
    }
;
    newm = cc_lib$copymode(m);
    cc_decls$ttconsttype[(m)] = newm;
    cc_decls$ttconst[(newm)] = (i64)1;
    cc_decls$ttconsttype[(newm)] = m;
    return newm;
}

i64 cc_lib$createrefmode(i64 m) {
        i64 newm;
    if (!!(cc_decls$ttreftype[(m)])) {
        return cc_decls$ttreftype[(m)];
    }
;
    newm = cc_lib$createnewmode((i64)16);
    cc_decls$ttreftype[(m)] = newm;
    cc_decls$tttarget[(newm)] = m;
    cc_decls$ttisref[(newm)] = (i64)1;
    return newm;
}

i64 cc_lib$createprocmode(i64 m,struct cc_decls$paramrec *pm) {
        i64 newm;
    newm = cc_lib$createnewmode((i64)17);
    cc_decls$ttparams[(newm)] = (struct cc_decls$paramrec *)pm;
    cc_decls$tttarget[(newm)] = m;
    return newm;
}

i64 cc_lib$createarraymode(i64 m,i64 length) {
        i64 newm;
    newm = cc_lib$createnewmode((i64)19);
    cc_decls$tttarget[(newm)] = m;
    cc_decls$ttlength[(newm)] = length;
    cc_decls$ttsize[(newm)] = (length * cc_decls$ttsize[(m)]);
    return newm;
}

i64 cc_lib$createenummode(struct cc_decls$strec *e) {
        i64 newm;
    newm = cc_lib$createnewmode((i64)15);
    cc_decls$ttnamedef[(newm)] = (struct cc_decls$strec *)e;
    return newm;
}

i64 cc_lib$createstructmode(struct cc_decls$strec *s,i64 smode) {
        i64 newm;
    newm = cc_lib$createnewmode(smode);
    cc_decls$ttnamedef[(newm)] = (struct cc_decls$strec *)s;
    return newm;
}

void cc_lib$setnameptr(struct cc_decls$unitrec *p) {
    (*(*p).def).code = (struct cc_decls$unitrec *)p;
}

void cc_lib$printcode_all(void *f,u8 *caption) {
        i64 i;
    for (i=(i64)1;i<=cc_decls$nmodules;++i) {
L527 :;
        cc_lib$printcode(f,caption,i);
L528 :;
    }
L529 :;
    ;
}

void cc_lib$printcode(void *f,u8 *caption,i64 n) {
        struct cc_decls$strec *  p;
    p = (struct cc_decls$strec *)(*cc_decls$moduletable[(n)].stmodule).deflist;
    msysc$m_print_startfile(f);
    msysc$m_print_str(caption,NULL);
    msysc$m_print_str((byte*)"MODULE:",NULL);
    msysc$m_print_str(cc_decls$moduletable[(n)].name,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    L530 :;
    while (!!(p)) {
                {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)6)) {
            if (!!((*p).code)) {
                msysc$m_print_startfile(f);
                msysc$m_print_str((*p).name,NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)"=",NULL);
                msysc$m_print_str(cc_tables$scopenames[((i64)(*p).scope)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                cc_lib$printunit(f,(struct cc_decls$unitrec *)(*p).code,(i64)0,(byte*)"1");
                msysc$m_print_startfile(f);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
;
        }
        };
        p = (struct cc_decls$strec *)(*p).nextdef;
L531 :;
    }
L532 :;
    ;
}

void cc_lib$printunit(void *dev,struct cc_decls$unitrec *p,i64 level,u8 *prefix) {
        struct cc_decls$strec *  d;
        i64 t;
        i64 n;
        i64 lincr;
        u8 *  idname;
        struct cc_decls$caserec *  pc;
    if ((p == 0)) {
        return;
    }
;
    if (((i64)(*p).tag >= (i64)78)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"print unit: bad tag",NULL);
        msysc$m_print_i64((i64)(*p).tag,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)30);
    }
;
    if (!!((i64)(*p).lineno)) {
        cc_lib$currlineno = (i64)(*p).lineno;
    }
;
    lincr = (i64)1;
    if ((level < (i64)0)) {
        lincr = (i64)-1;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"             ",NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startfile(dev);
    msysc$m_print_str(cc_lib$getprefix(m$llabs(level),prefix,(struct cc_decls$unitrec *)p),NULL);
    msysc$m_print_end();
    ;
    idname = cc_tables$jtagnames[((i64)(*p).tag)];
    if (((u64)(*idname) == 'j')) {
        idname += (i64)2;
    }
;
    msysc$m_print_startfile(dev);
    msysc$m_print_str(idname,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)": ",NULL);
    msysc$m_print_end();
    ;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)3) || ($temp==(i64)5)) {
        d = (struct cc_decls$strec *)(*p).def;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_str(cc_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_end();
        ;
        if (!!((*d).code)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" {",NULL);
            msysc$m_print_nogap();
            msysc$m_print_str(cc_tables$jtagnames[((i64)(*(*d).code).tag)],NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)"}",NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(cc_lib$getdottedname((struct cc_decls$strec *)d),NULL);
        msysc$m_print_end();
        ;
        if (!!((*p).c)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" Lastcall:",NULL);
            msysc$m_print_ptr((*p).c,NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if (($temp==(i64)7) || ($temp==(i64)8) || ($temp==(i64)17)) {
        d = (struct cc_decls$strec *)(*p).def;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_str(cc_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(dev);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lib$printunit(dev,(struct cc_decls$unitrec *)(*d).code,(level + lincr),(byte*)"1");
        return;
    }
    else if (($temp==(i64)17)) {
        d = (struct cc_decls$strec *)(*p).def;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_str(cc_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)18)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*(*p).def).name,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)19)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"Index:",NULL);
        msysc$m_print_i64((i64)(*p).index,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)1)) {
        t = (i64)(*p).mode;
        if ((t == cc_decls$trefchar)) {
            if (!(!!((i64)(*p).isstrconst))) {
                goto L533 ;
;
            }
;
            //dostring:
L534 :;
;
            if (((i64)(*p).slength > (i64)256)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)"\"",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)"(LONGSTR)",NULL);
                msysc$m_print_str((byte*)"\" *",NULL);
                msysc$m_print_nogap();
                msysc$m_print_i64((i64)(*p).slength,NULL);
                msysc$m_print_end();
                ;
            }
            else {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)"\"",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((*p).svalue,NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)"\" *",NULL);
                msysc$m_print_nogap();
                msysc$m_print_i64((i64)(*p).slength,NULL);
                msysc$m_print_end();
                ;
            }
;
        }
        else if ((t == cc_decls$trefwchar)) {
            if (!(!!((i64)(*p).iswstrconst))) {
                goto L533 ;
;
            }
;
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)"\"",NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)"(WSTRING)",NULL);
            msysc$m_print_str((byte*)"\" *",NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64((i64)(*p).wslength,NULL);
            msysc$m_print_end();
            ;
        }
        else if (((t >= (i64)2) && (t <= (i64)5))) {
            msysc$m_print_startfile(dev);
            msysc$m_print_i64((*p).value,NULL);
            msysc$m_print_end();
            ;
        }
        else if (((t >= (i64)7) && (t <= (i64)10))) {
            msysc$m_print_startfile(dev);
            msysc$m_print_u64((*p).uvalue,NULL);
            msysc$m_print_end();
            ;
        }
        else if (!!(cc_lib$isrealcc(t))) {
            msysc$m_print_startfile(dev);
            msysc$m_print_r64((*p).xvalue,NULL);
            msysc$m_print_end();
            ;
        }
        else if ((cc_decls$ttbasetype[(t)] == (i64)16)) {
            if (!!((i64)(*p).isstrconst)) {
                goto L534 ;
;
            }
;
            //doref:
L533 :;
;
            msysc$m_print_startfile(dev);
            msysc$m_print_ptr((void *)(*p).value,NULL);
            msysc$m_print_end();
            ;
        }
        else if ((cc_decls$ttbasetype[(t)] == (i64)19)) {
            if (!!((i64)(*p).isstrconst)) {
                goto L534 ;
;
            }
;
            cc_support$serror((byte*)"PRINTUNIT/CONST/aRRAY");
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(cc_lib$typename(t),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_support$serror((byte*)"PRINTUNIT BAD CONST");
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(cc_lib$strmode(t,(i64)1),NULL);
        msysc$m_print_end();
        ;
        if (!!((i64)(*p).isstrconst)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)"<STRCONST>",NULL);
            msysc$m_print_end();
            ;
        }
;
        if (!!((i64)(*p).iswstrconst)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)"<WSTRCONST>",NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if (($temp==(i64)57)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str(cc_tables$convnames[((i64)(*p).opcode)],NULL);
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
        if (!!((i64)(*p).convmem)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)"Mem:",NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str(cc_lib$typename((i64)(*(*p).a).mode),NULL);
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" => ",NULL);
        msysc$m_print_end();
        ;
        if (!!((i64)(*p).convtomem)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)"Mem:",NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str(cc_lib$typename((i64)(*p).mode),NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)58)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"Scale:",NULL);
        msysc$m_print_i64((i64)(*p).scale,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)54) || ($temp==(i64)55)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"Ptrscale:",NULL);
        msysc$m_print_i64((i64)(*p).ptrscale,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)23)) {
        pc = (struct cc_decls$caserec *)(*p).nextcase;
        n = (i64)0;
        L535 :;
        while (!!(pc)) {
            ++(n);
            pc = (struct cc_decls$caserec *)(*pc).nextcase;
L536 :;
        }
L537 :;
        ;
        msysc$m_print_startfile(dev);
        msysc$m_print_ptr((*p).nextcase,NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)31)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" Aparams:",NULL);
        msysc$m_print_i64((i64)(*p).aparams,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)53)) {
    }
    else if (($temp==(i64)50)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" Offset:",NULL);
        msysc$m_print_i64((i64)(*p).offset,NULL);
        msysc$m_print_end();
        ;
    }
    };
    if (!!((i64)(*p).alength)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" ALENGTH=",NULL);
        msysc$m_print_i64((i64)(*p).alength,NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_lib$printunitlist(dev,(struct cc_decls$unitrec *)(*p).a,(level + lincr),(byte*)"1");
    cc_lib$printunitlist(dev,(struct cc_decls$unitrec *)(*p).b,(level + lincr),(byte*)"2");
    if (((i64)(*p).tag != (i64)6)) {
        cc_lib$printunitlist(dev,(struct cc_decls$unitrec *)(*p).c,(level + lincr),(byte*)"3");
    }
;
}

static void cc_lib$printunitlist(void *dev,struct cc_decls$unitrec *p,i64 level,u8 *prefix) {
    if ((p == 0)) {
        return;
    }
;
    L538 :;
    while (!!(p)) {
        cc_lib$printunit(dev,(struct cc_decls$unitrec *)p,level,prefix);
        p = (struct cc_decls$unitrec *)(*p).nextunit;
L539 :;
    }
L540 :;
    ;
}

static u8 *cc_lib$getprefix(i64 level,u8 *prefix,struct cc_decls$unitrec *p) {
        static u8 str[512];
        u8 indentstr[512];
        u8 *  modestr;
        i64 length;
        i64 $av_1;
    indentstr[((i64)1)-1] = (u64)0u;
    if ((level > (i64)10)) {
        level = (i64)10;
    }
;
    strcpy((u8 *)indentstr,(byte*)"-----------------------");
    modestr = cc_lib$strmode((i64)(*p).mode,(i64)0);
    length = strlen(modestr);
    if ((length < strlen((u8 *)indentstr))) {
        memcpy(indentstr,(void *)modestr,(u64)length);
    }
    else {
        strcpy((u8 *)indentstr,modestr);
    }
;
    $av_1 = level;
    while ($av_1-- > 0) {
L541 :;
        strcat((u8 *)indentstr,(byte*)"|---");
L542 :;
    }
L543 :;
    ;
    strcpy((u8 *)str,cc_lib$getlineinfok());
    strcat((u8 *)str,(u8 *)indentstr);
    strcat((u8 *)str,prefix);
    if (!!((u64)(*prefix))) {
        strcat((u8 *)str,(byte*)" ");
    }
;
    return (u8 *)str;
}

u8 *cc_lib$getdottedname(struct cc_decls$strec *p) {
        static u8 str[256];
        u8 str2[256];
        struct cc_decls$strec *  owner;
    strcpy((u8 *)str,(*p).name);
    owner = (struct cc_decls$strec *)(*p).owner;
    L544 :;
    while ((!!(owner) && ((i64)(*owner).nameid != (i64)2))) {
        strcpy((u8 *)str2,(u8 *)str);
        strcpy((u8 *)str,(*owner).name);
        strcat((u8 *)str,(byte*)".");
        strcat((u8 *)str,(u8 *)str2);
        owner = (struct cc_decls$strec *)(*owner).owner;
L545 :;
    }
L546 :;
    ;
    if (!!((i64)(*p).blockno)) {
        msysc$m_print_startstr(str2);
        msysc$m_print_str((byte*)".",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64((i64)(*p).blockno,NULL);
        msysc$m_print_end();
        ;
        strcat((u8 *)str,(u8 *)str2);
    }
;
    return (u8 *)str;
}

static u8 *cc_lib$getlineinfok(void) {
        static u8 str[40];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"# ");
    msysc$m_print_i64(cc_lib$currlineno,(byte*)"z5");
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

struct cc_decls$strec *cc_lib$getautofieldname(void) {
        u8 str[32];
        u8 *  name;
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"$F",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(++(cc_lib$nextafindex),NULL);
    msysc$m_print_end();
    ;
    name = mlib$pcm_copyheapstring((u8 *)str);
    return (struct cc_decls$strec *)cc_lex$addnamestr(name);
}

void cc_lib$convertstring(u8 *s,u8 *t,i64 length) {
        i64 c;
        u8 str[20];
        u8 *  t0;
        i64 $av_1;
    if ((length == (i64)-1)) {
        length = strlen(s);
    }
;
    t0 = t;
    $av_1 = length;
    while ($av_1-- > 0) {
L547 :;
        c = (i64)(u64)(*(s)++);
        switch (c) {
        case 34:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = '"';
            }
            break;
        case 39:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = (u64)39u;
            }
            break;
        case 10:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'n';
            }
            break;
        case 13:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'r';
            }
            break;
        case 9:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 't';
            }
            break;
        case 92:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = (u64)92u;
            }
            break;
        case 7:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'a';
            }
            break;
        case 8:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'b';
            }
            break;
        case 12:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'f';
            }
            break;
        case 11:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'v';
            }
            break;
        default: {
            if (((c < (i64)32) || (c >= (i64)127))) {
                msysc$m_print_startstr(str);
                msysc$m_print_setfmt((byte*)"\\#o");
                msysc$m_print_i64(c,(byte*)"z3");
                msysc$m_print_end();
                ;
                (*(t)++) = (u64)str[((i64)1)-1];
                (*(t)++) = (u64)str[((i64)2)-1];
                (*(t)++) = (u64)str[((i64)3)-1];
                (*(t)++) = (u64)str[((i64)4)-1];
            }
            else {
                (*(t)++) = (u64)c;
            }
;
        }
        } //SW
;
L548 :;
    }
L549 :;
    ;
    (*t) = (u64)0u;
}

struct mlib$strbuffer *cc_lib$strexpr(struct cc_decls$unitrec *p) {
    mlib$gs_init((struct mlib$strbuffer *)cc_lib$exprstr);
    cc_lib$jeval((struct mlib$strbuffer *)cc_lib$exprstr,(struct cc_decls$unitrec *)p);
    return (struct mlib$strbuffer *)cc_lib$exprstr;
}

static void cc_lib$jeval(struct mlib$strbuffer *dest,struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        u8 str[16000];
        i64 lb;
        i64 t;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        if (((t = (i64)(*p).mode) == cc_decls$trefchar)) {
            if (((i64)(*p).slength == (i64)0)) {
                goto L550 ;
;
            }
;
            if (!(!!((i64)(*p).isstrconst))) {
                goto L550 ;
;
            }
;
            if (((i64)(*p).slength > (i64)8000)) {
                strcpy((u8 *)str,(byte*)"LONGSTR)");
            }
            else {
                cc_lib$convertstring((*p).svalue,(u8 *)str,(i64)-1);
            }
;
            cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"\"");
            cc_support$gs_additem((struct mlib$strbuffer *)dest,(u8 *)str);
            cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"\"");
            return;
        }
        else if (((t >= (i64)2) && (t <= (i64)5))) {
            msysc$getstrint((*p).value,(u8 *)str);
        }
        else if (((t >= (i64)7) && (t <= (i64)10))) {
            strcpy((u8 *)str,msysc$strword((*p).uvalue,0));
        }
        else if (((t == (i64)12) || (t == (i64)11))) {
            strcpy((u8 *)str,msysc$strreal((*p).xvalue,0));
        }
        else {
                        {i64 $temp = cc_decls$ttbasetype[((i64)(*p).mode)];
if (($temp==(i64)16)) {
                //doref:
L550 :;
;
                msysc$m_print_startstr(str);
                msysc$m_print_ptr((void *)(*p).svalue,NULL);
                msysc$m_print_end();
                ;
            }
            else if (($temp==(i64)19)) {
                strcpy((u8 *)str,(byte*)"ARRAY");
            }
            else {
                msysc$m_print_startcon();
                msysc$m_print_str(cc_lib$typename((i64)(*p).mode),NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                cc_support$nxerror((byte*)"EVAL/CONST",(struct cc_decls$unitrec *)p);
            }
            };
        }
;
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(u8 *)str);
    }
    else if (($temp==(i64)3)) {
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(*(*p).def).name);
    }
    else if (($temp==(i64)5)) {
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"&");
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(*(*p).def).name);
    }
    else if (($temp==(i64)25) || ($temp==(i64)26) || ($temp==(i64)33) || ($temp==(i64)34) || ($temp==(i64)35) || ($temp==(i64)36) || ($temp==(i64)37) || ($temp==(i64)38) || ($temp==(i64)39) || ($temp==(i64)40) || ($temp==(i64)41) || ($temp==(i64)42) || ($temp==(i64)43) || ($temp==(i64)44) || ($temp==(i64)45) || ($temp==(i64)46) || ($temp==(i64)47) || ($temp==(i64)48) || ($temp==(i64)49) || ($temp==(i64)62) || ($temp==(i64)63) || ($temp==(i64)64) || ($temp==(i64)65) || ($temp==(i64)66) || ($temp==(i64)67) || ($temp==(i64)68) || ($temp==(i64)69) || ($temp==(i64)70) || ($temp==(i64)71)) {
        strcpy((u8 *)str,cc_lib$getopcjname((i64)(*p).tag));
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(u8 *)str);
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).b);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
    }
    else if (($temp==(i64)59) || ($temp==(i64)60) || ($temp==(i64)61) || ($temp==(i64)27) || ($temp==(i64)28)) {
        strcpy((u8 *)str,cc_lib$getopcjname((i64)(*p).tag));
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(u8 *)str);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
    }
    else if (($temp==(i64)31)) {
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
        q = (struct cc_decls$unitrec *)(*p).b;
        L551 :;
        while (!!(q)) {
            cc_lib$jeval(dest,(struct cc_decls$unitrec *)q);
            q = (struct cc_decls$unitrec *)(*q).nextunit;
            if (!!(q)) {
                cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)",");
            }
;
L552 :;
        }
L553 :;
        ;
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
    }
    else if (($temp==(i64)50)) {
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)".");
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"???");
    }
    else if (($temp==(i64)51)) {
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"->");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).b);
    }
    else if (($temp==(i64)29) || ($temp==(i64)30)) {
        lb = (i64)((i64)(*p).tag == (i64)30);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(!!(lb) ? (byte*)"(" : (byte*)"{"));
        q = (struct cc_decls$unitrec *)(*p).a;
        L554 :;
        while (!!(q)) {
            cc_lib$jeval(dest,(struct cc_decls$unitrec *)q);
            q = (struct cc_decls$unitrec *)(*q).nextunit;
            if (!!(q)) {
                cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)",");
            }
;
L555 :;
        }
L556 :;
        ;
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(!!(lb) ? (byte*)")" : (byte*)"}"));
    }
    else if (($temp==(i64)12)) {
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"=");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).b);
    }
    else if (($temp==(i64)32)) {
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"?");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).b);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)":");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).c);
    }
    else if (($temp==(i64)57)) {
        cc_support$gs_additem((struct mlib$strbuffer *)dest,cc_lib$strmode((i64)(*p).mode,(i64)1));
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
    }
    else if (($temp==(i64)53)) {
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"*(");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        if (!!((*p).b)) {
            cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"+");
            cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).b);
        }
;
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
    }
    else if (($temp==(i64)6)) {
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"<JBLOCK>");
    }
    else if (($temp==(i64)73)) {
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"++");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
    }
    else if (($temp==(i64)74)) {
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"--");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
    }
    else if (($temp==(i64)75)) {
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"++");
    }
    else if (($temp==(i64)76)) {
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        cc_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"--");
    }
    else if (($temp==(i64)2)) {
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"<nullunit>");
    }
    else if (($temp==(i64)58)) {
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"scale((");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        if (((i64)(*p).scale > (i64)0)) {
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)")*");
            mlib$gs_strint((struct mlib$strbuffer *)dest,(i64)(*p).scale);
        }
        else {
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)")/");
            mlib$gs_strint((struct mlib$strbuffer *)dest,-((i64)(*p).scale));
        }
;
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)")");
    }
    else if (($temp==(i64)54)) {
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"(");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"+");
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).b);
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)")");
    }
    else if (($temp==(i64)4)) {
        cc_lib$jeval(dest,(struct cc_decls$unitrec *)(*p).a);
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(cc_tables$jtagnames[((i64)(*p).tag)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"<CAN'T DO JEVAL>");
    }
    };
}

u8 *cc_lib$getopcjname(i64 opc) {
        static u8 str[20];
        u8 *  name;
        u8 *  s;
    name = cc_tables$jtagnames[(opc)];
    s = strchr(name,(i32)' ');
    if (!!(s)) {
        memcpy(str,(void *)name,(u64)(s - name));
        str[(((s - name) + (i64)1))-1] = (u64)0u;
        return (u8 *)str;
    }
    else {
        return name;
    }
;
}

u8 *cc_lib$strmode(i64 m,i64 expand) {
        static u8 str[16384];
    cc_lib$istrmode(m,expand,(u8 *)str);
    return (u8 *)str;
}

u8 *cc_lib$strmode2(i64 m,i64 expand) {
        static u8 str[16384];
    cc_lib$istrmode(m,expand,(u8 *)str);
    return (u8 *)str;
}

void cc_lib$istrmode(i64 m,i64 expand,u8 *dest) {
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  q;
        i64 needcomma;
        i64 i;
        i64 target;
        i64 t;
        i64 n;
        struct mlib$strbuffer sxx;
        struct mlib$strbuffer *  xx;
        struct cc_decls$paramrec *  pm;
    xx = (struct mlib$strbuffer *)&sxx;
    if ((m < (i64)22)) {
        strcpy(dest,cc_lib$typename(m));
        return;
    }
;
    t = cc_decls$ttbasetype[(m)];
    if ((t==(i64)16)) {
        if (!!((i64)cc_decls$ttconst[(m)])) {
            strcpy(dest,(byte*)"const ref ");
        }
        else {
            strcpy(dest,(byte*)"ref ");
        }
;
        target = cc_decls$tttarget[(m)];
        if (((target >= (i64)0) && (cc_decls$ttbasetype[(cc_decls$tttarget[(m)])] == (i64)20))) {
            strcat(dest,cc_lib$typename(cc_decls$tttarget[(m)]));
        }
        else {
            cc_lib$istrmode(cc_decls$tttarget[(m)],(i64)0,(dest + strlen(dest)));
        }
;
    }
    else if ((t==(i64)19)) {
        if (!!(cc_decls$ttlength[(m)])) {
            msysc$m_print_startstr(dest);
            msysc$m_print_setfmt((byte*)"[#]");
            msysc$m_print_i64(cc_decls$ttlength[(m)],NULL);
            msysc$m_print_end();
            ;
        }
        else {
            strcpy(dest,(byte*)"[]");
        }
;
        cc_lib$istrmode(cc_decls$tttarget[(m)],(i64)0,(dest + strlen(dest)));
    }
    else if ((t==(i64)15)) {
        strcpy(dest,(byte*)"enum ");
        strcat(dest,cc_lib$typename(m));
    }
    else if ((t==(i64)20) || (t==(i64)21)) {
        if (!(!!(expand))) {
            strcpy(dest,cc_lib$typename(m));
            return;
        }
;
        strcpy(dest,cc_lib$typename(cc_decls$ttbasetype[(m)]));
        strcat(dest,(byte*)"(");
        d = (struct cc_decls$strec *)cc_decls$ttnamedef[(m)];
        needcomma = (i64)0;
        q = (struct cc_decls$strec *)(*d).deflist;
        L557 :;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat(dest,(byte*)",");
            }
;
            needcomma = (i64)1;
            cc_lib$istrmode((i64)(*q).mode,(i64)0,(dest + strlen(dest)));
            strcat(dest,(byte*)" ");
            strcat(dest,(*q).name);
            q = (struct cc_decls$strec *)(*q).nextdef;
L558 :;
        }
L559 :;
        ;
        strcat(dest,(byte*)")");
    }
    else if ((t==(i64)1)) {
        strcpy(dest,cc_lib$typename(m));
    }
    else if ((t==(i64)17)) {
        strcpy(dest,(byte*)"proc(");
        pm = (struct cc_decls$paramrec *)cc_decls$ttparams[(m)];
        n = (i64)(*pm).nparams;
        for (i=(i64)1;i<=n;++i) {
L560 :;
            cc_lib$istrmode((i64)(*pm).mode,(i64)0,(dest + strlen(dest)));
            if ((i != n)) {
                strcat(dest,(byte*)",");
            }
;
            pm = (struct cc_decls$paramrec *)(*pm).nextparam;
L561 :;
        }
L562 :;
        ;
        strcat(dest,(byte*)")");
        cc_lib$istrmode(cc_decls$tttarget[(m)],(i64)0,(dest + strlen(dest)));
    }
    else {
        if ((t < (i64)22)) {
            strcpy(dest,cc_lib$typename(m));
            return;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(cc_lib$typename(m),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_support$mcerror((byte*)"NEWSTRMODE");
        }
;
    }
;
}

i64 cc_lib$countunits(struct cc_decls$unitrec *p) {
        i64 n;
    n = (i64)0;
    L563 :;
    while (!!(p)) {
        ++(n);
        p = (struct cc_decls$unitrec *)(*p).nextunit;
L564 :;
    }
L565 :;
    ;
    return n;
}

static void cc_lib$purgesymbol(struct cc_decls$strec *p,struct cc_decls$strec *prev,i64 del) {
        struct cc_decls$strec *  q;
        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)10)) {
        return;
    }
    };
    cc_lib$purgesymbollist((struct cc_decls$strec *)(*p).deflist,(i64)0,del);
    if (!!(prev)) {
        (*prev).nextdef = (*p).nextdef;
    }
    else {
        (*(*p).owner).deflist = (struct cc_decls$strec *)(*p).nextdef;
    }
;
    q = (struct cc_decls$strec *)(*p).prevdupl;
    (*q).nextdupl = (*p).nextdupl;
    if (!!(del)) {
        mlib$pcm_free(p,(i64)128);
    }
;
}

void cc_lib$purgesymbollist(struct cc_decls$strec *p,i64 ismodule,i64 del) {
    cc_support$serror((byte*)"PURGESYMBOL");
}

void cc_lib$purgeprocs(struct cc_decls$strec *p,i64 del) {
    L566 :;
    while (!!(p)) {
        if (((i64)(*p).nameid == (i64)6)) {
            cc_lib$purgeproc((struct cc_decls$strec *)p,del);
        }
;
        p = (struct cc_decls$strec *)(*p).nextdef;
L567 :;
    }
L568 :;
    ;
}

void cc_lib$purgeproc(struct cc_decls$strec *p,i64 del) {
        struct cc_decls$strec *  q;
        struct cc_decls$strec *  prev;
        struct cc_decls$strec *  r;
    q = (struct cc_decls$strec *)(*p).deflist;
    prev = 0;
    L569 :;
    while (!!(q)) {
        r = (struct cc_decls$strec *)(*q).nextdef;
        if (((i64)(*q).nameid == (i64)8)) {
            cc_lib$purgesymbol((struct cc_decls$strec *)q,(struct cc_decls$strec *)prev,del);
        }
        else {
            prev = q;
        }
;
        q = r;
L570 :;
    }
L571 :;
    ;
}

void cc_lib$printmodelist(void *f) {
        u8 *  mstr;
        struct mlib$strbuffer destv;
        struct mlib$strbuffer *  dest;
        i64 m;
    dest = (struct mlib$strbuffer *)&destv;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"MODELIST",NULL);
    msysc$m_print_i64(cc_decls$ntypes,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$gs_init((struct mlib$strbuffer *)dest);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"#",(i64)4,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"Name",(i64)13,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"Base",(i64)13,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"Bit",(i64)3,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"Target",(i64)14,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"Len",(i64)4,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"Size",(i64)5,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"C",(i64)3,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"R",(i64)3,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"V",(i64)3,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"@Cnst",(i64)5,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"@Ref",(i64)5,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"Tag",(i64)8,(i64)32);
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"Mode",(i64)32,(i64)32);
    mlib$gs_println((struct mlib$strbuffer *)dest,f);
    for (m=(i64)0;m<=cc_decls$ntypes;++m) {
L572 :;
        mlib$gs_init((struct mlib$strbuffer *)dest);
        mlib$gs_leftint((struct mlib$strbuffer *)dest,m,(i64)4,(i64)32);
        mlib$gs_leftstr((struct mlib$strbuffer *)dest,cc_lib$typename(m),(i64)13,(i64)32);
        mlib$gs_leftstr((struct mlib$strbuffer *)dest,cc_lib$typename(cc_decls$ttbasetype[(m)]),(i64)13,(i64)32);
        mlib$gs_leftint((struct mlib$strbuffer *)dest,cc_decls$ttbitwidth[(m)],(i64)3,(i64)32);
        if (!!(cc_decls$tttarget[(m)])) {
            mlib$gs_leftint((struct mlib$strbuffer *)dest,cc_decls$tttarget[(m)],(i64)3,(i64)32);
            mlib$gs_leftstr((struct mlib$strbuffer *)dest,cc_lib$typename(cc_decls$tttarget[(m)]),(i64)11,(i64)32);
        }
        else {
            mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"-",(i64)14,(i64)32);
        }
;
                {i64 $temp = cc_decls$ttbasetype[(m)];
if (($temp==(i64)19) || ($temp==(i64)20) || ($temp==(i64)21)) {
            mlib$gs_leftint((struct mlib$strbuffer *)dest,cc_decls$ttlength[(m)],(i64)4,(i64)32);
        }
        else {
            mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"",(i64)4,(i64)32);
        }
        };
        mlib$gs_leftint((struct mlib$strbuffer *)dest,cc_decls$ttsize[(m)],(i64)5,(i64)32);
        mlib$gs_leftint((struct mlib$strbuffer *)dest,(i64)cc_decls$ttconst[(m)],(i64)3,(i64)32);
        mlib$gs_leftint((struct mlib$strbuffer *)dest,(i64)cc_decls$ttrestrict[(m)],(i64)3,(i64)32);
        mlib$gs_leftint((struct mlib$strbuffer *)dest,(i64)cc_decls$ttvolatile[(m)],(i64)3,(i64)32);
        mlib$gs_leftint((struct mlib$strbuffer *)dest,cc_decls$ttconsttype[(m)],(i64)5,(i64)32);
        mlib$gs_leftint((struct mlib$strbuffer *)dest,cc_decls$ttreftype[(m)],(i64)5,(i64)32);
        if (!!(cc_decls$ttnamedef[(m)])) {
            mlib$gs_leftstr((struct mlib$strbuffer *)dest,(*cc_decls$ttnamedef[(m)]).name,(i64)8,(i64)32);
        }
        else {
            mlib$gs_leftstr((struct mlib$strbuffer *)dest,(byte*)"-",(i64)8,(i64)32);
        }
;
        mstr = cc_lib$strmode(m,(i64)1);
        if ((strlen(mstr) < (i64)16)) {
            mlib$gs_str((struct mlib$strbuffer *)dest,mstr);
        }
        else {
            mlib$gs_println((struct mlib$strbuffer *)dest,f);
            mlib$gs_init((struct mlib$strbuffer *)dest);
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"\t\t");
            mlib$gs_str((struct mlib$strbuffer *)dest,mstr);
        }
;
        mlib$gs_println((struct mlib$strbuffer *)dest,f);
L573 :;
    }
L574 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

u8 *cc_lib$typename(i64 m) {
        i64 basem;
        static u8 str[300];
    basem = cc_decls$ttbasetype[(m)];
    if ((basem==(i64)20) || (basem==(i64)21)) {
        strcpy((u8 *)str,((basem == (i64)20) ? (byte*)"struct " : (byte*)"union "));
        if (!!(cc_decls$ttnamedef[(m)])) {
            strcat((u8 *)str,(*cc_decls$ttnamedef[(m)]).name);
        }
;
        return (u8 *)str;
    }
    else if ((basem==(i64)19)) {
        return (byte*)"<array>";
    }
    else if ((basem==(i64)15)) {
        if (!!(cc_decls$ttnamedef[(m)])) {
            return (*cc_decls$ttnamedef[(m)]).name;
        }
;
        return (byte*)"<enum>";
    }
    else {
        if (!!((i64)cc_decls$ttconst[(m)])) {
            strcpy((u8 *)str,(byte*)"const ");
            strcat((u8 *)str,cc_tables$stdtypenames[(basem)]);
            return (u8 *)str;
        }
;
        return cc_tables$stdtypenames[(basem)];
    }
;
    return (byte*)"";
}

struct cc_decls$unitrec *cc_lib$allocunitrec(void) {
        struct cc_decls$unitrec *  p;
    if (!!((cc_lib$remainingunits)--)) {
        p = (struct cc_decls$unitrec *)cc_lib$unitheapptr;
        ++(cc_lib$unitheapptr);
        (*p).lineno = (i64)cc_decls$lx.lineno;
        if (((i64)cc_decls$lx.fileno <= (i64)255)) {
            (*p).fileno = (i64)cc_decls$lx.fileno;
        }
;
        return (struct cc_decls$unitrec *)p;
    }
;
    p = (struct cc_decls$unitrec *)(cc_lib$unitheapptr = (struct cc_decls$unitrec *)mlib$pcm_alloc((i64)3200000));
    memset(p,(i32)(i64)0,(u64)3200000u);
    cc_lib$remainingunits = (i64)49999;
    ++(cc_lib$unitheapptr);
    (*p).lineno = (i64)cc_decls$lx.lineno;
    if (((i64)cc_decls$lx.fileno <= (i64)255)) {
        (*p).fileno = (i64)cc_decls$lx.fileno;
    }
;
    return (struct cc_decls$unitrec *)p;
}

static i64 cc_lib$copymode(i64 m) {
    if ((cc_decls$ntypes >= (i64)10000)) {
        cc_support$serror((byte*)"Too many types");
    }
;
    ++(cc_decls$ntypes);
    cc_decls$ttnamedef[(cc_decls$ntypes)] = cc_decls$ttnamedef[(m)];
    cc_decls$ttbasetype[(cc_decls$ntypes)] = cc_decls$ttbasetype[(m)];
    cc_decls$ttlength[(cc_decls$ntypes)] = cc_decls$ttlength[(m)];
    cc_decls$ttconst[(cc_decls$ntypes)] = (i64)cc_decls$ttconst[(m)];
    cc_decls$ttrestrict[(cc_decls$ntypes)] = (i64)cc_decls$ttrestrict[(m)];
    cc_decls$ttvolatile[(cc_decls$ntypes)] = (i64)cc_decls$ttvolatile[(m)];
    cc_decls$ttusertype[(cc_decls$ntypes)] = cc_decls$ttusertype[(m)];
    cc_decls$ttsize[(cc_decls$ntypes)] = cc_decls$ttsize[(m)];
    cc_decls$ttbitwidth[(cc_decls$ntypes)] = cc_decls$ttbitwidth[(m)];
    cc_decls$tttarget[(cc_decls$ntypes)] = cc_decls$tttarget[(m)];
    cc_decls$ttparams[(cc_decls$ntypes)] = cc_decls$ttparams[(m)];
    cc_decls$ttisref[(cc_decls$ntypes)] = (i64)cc_decls$ttisref[(m)];
    return cc_decls$ntypes;
}

static i64 cc_lib$createnewmode(i64 m) {
    if ((cc_decls$ntypes >= (i64)10000)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"STRMODE(M)=",NULL);
        msysc$m_print_str(cc_lib$strmode(m,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_support$serror((byte*)"Too many types/cnm");
    }
;
    ++(cc_decls$ntypes);
    cc_decls$ttbasetype[(cc_decls$ntypes)] = m;
    cc_decls$ttsize[(cc_decls$ntypes)] = cc_decls$ttsize[(m)];
    cc_decls$ttbitwidth[(cc_decls$ntypes)] = cc_decls$ttbitwidth[(m)];
    return cc_decls$ntypes;
}

void cc_lib$addlistunit(struct cc_decls$unitrec **ulist,struct cc_decls$unitrec **ulistx,struct cc_decls$unitrec *p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = (struct cc_decls$unitrec *)p);
    }
    else {
        (*(*ulistx)).nextunit = (struct cc_decls$unitrec *)p;
    }
;
    (*p).nextunit = 0;
    (*ulistx) = (struct cc_decls$unitrec *)p;
}

void cc_lib$addlistdef(struct cc_decls$strec **ulist,struct cc_decls$strec **ulistx,struct cc_decls$strec *p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = (struct cc_decls$strec *)p);
    }
    else {
        (*(*ulistx)).nextdef = (struct cc_decls$strec *)p;
    }
;
    (*p).nextdef = 0;
    (*ulistx) = (struct cc_decls$strec *)p;
}

void cc_lib$addlistparam(struct cc_decls$paramrec **ulist,struct cc_decls$paramrec **ulistx,struct cc_decls$paramrec *p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = (struct cc_decls$paramrec *)p);
    }
    else {
        (*(*ulistx)).nextparam = (struct cc_decls$paramrec *)p;
    }
;
    (*p).nextparam = 0;
    (*ulistx) = (struct cc_decls$paramrec *)p;
}

void cc_lib$checksymbol(i64 symbol) {
        u8 str[256];
    if (((i64)cc_decls$lx.symbol != symbol)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"# expected, not #");
        msysc$m_print_str(cc_tables$symbolnames[(symbol)-1],NULL);
        msysc$m_print_str(cc_tables$symbolnames[((i64)cc_decls$lx.symbol)-1],NULL);
        msysc$m_print_end();
        ;
        if (((i64)cc_decls$lx.symbol == (i64)69)) {
            strcat((u8 *)str,(byte*)" \"");
            strcat((u8 *)str,cc_lib$getstname((struct cc_decls$strec *)cc_decls$lx.symptr));
            strcat((u8 *)str,(byte*)"\"");
        }
;
        cc_support$serror((u8 *)str);
    }
;
}

void cc_lib$skipsymbol(i64 symbol) {
    if (((i64)cc_decls$lx.symbol != symbol)) {
        cc_lib$checksymbol(symbol);
    }
;
    cc_lex$lex();
}

void cc_lib$inittypetables(void) {
        i64 i;
        i64 size;
        i64 bitsize;
        i64 s;
        i64 t;
        i64 u;
    for (i=(i64)0;i<=(i64)21;++i) {
L575 :;
        cc_decls$ttbasetype[(i)] = i;
        bitsize = (i64)cc_tables$stdtypewidths[(i)];
        size = (bitsize / (i64)8);
        cc_decls$ttsize[(i)] = size;
        cc_decls$ttbitwidth[(i)] = bitsize;
L576 :;
    }
L577 :;
    ;
    cc_decls$ntypes = (i64)21;
    cc_decls$trefchar = cc_lib$createrefmode((i64)2);
    cc_decls$trefwchar = cc_lib$createrefmode((i64)8);
    for (i=(i64)1;i<=(i64)144;++i) {
L578 :;
        s = (i64)cc_tables$dominantsetuptable[(i)-1][((i64)1)-1];
        t = (i64)cc_tables$dominantsetuptable[(i)-1][((i64)2)-1];
        u = (i64)cc_tables$dominantsetuptable[(i)-1][((i64)3)-1];
        cc_tables$dominantmode[(s)][(t)] = u;
L579 :;
    }
L580 :;
    ;
    for (i=(i64)1;i<=(i64)144;++i) {
L581 :;
        s = (i64)cc_tables$convsetuptable[(i)-1][((i64)1)-1];
        t = (i64)cc_tables$convsetuptable[(i)-1][((i64)2)-1];
        u = (i64)cc_tables$convsetuptable[(i)-1][((i64)3)-1];
        cc_tables$conversionops[(s)][(t)] = u;
L582 :;
    }
L583 :;
    ;
    cc_decls$ntypesreset = cc_decls$ntypes;
}

struct cc_decls$strec *cc_lib$createdupldef(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 id) {
        struct cc_decls$strec *  p;
        struct cc_decls$strec *  q;
    p = (struct cc_decls$strec *)cc_lib$newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (i64)(*symptr).namelen;
    (*p).symbol = (i64)69;
    (*p).owner = (struct cc_decls$strec *)owner;
    (*p).nameid = id;
    (*p).namespace = (i64)cc_tables$namespaces[(id)];
    if (!!((q = (struct cc_decls$strec *)(*symptr).nextdupl))) {
        (*q).prevdupl = (struct cc_decls$strec *)p;
    }
;
    (*p).nextdupl = (struct cc_decls$strec *)q;
    (*p).prevdupl = (struct cc_decls$strec *)symptr;
    (*symptr).nextdupl = (struct cc_decls$strec *)p;
    if (!!(owner)) {
        if (((*owner).deflist == 0)) {
            (*owner).deflist = (struct cc_decls$strec *)((*owner).deflistx = (struct cc_decls$strec *)p);
        }
        else {
            (*(*owner).deflistx).nextdef = (struct cc_decls$strec *)p;
            (*owner).deflistx = (struct cc_decls$strec *)p;
        }
;
    }
;
    return (struct cc_decls$strec *)p;
}

struct cc_decls$strec *cc_lib$createnewmoduledef(struct cc_decls$strec *owner,struct cc_decls$strec *symptr) {
        struct cc_decls$strec *  p;
    p = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)owner,(struct cc_decls$strec *)symptr,(i64)3);
    return (struct cc_decls$strec *)p;
}

struct cc_decls$strec *cc_lib$createnewproc(struct cc_decls$strec *owner,struct cc_decls$strec *symptr) {
        struct cc_decls$strec *  p;
        struct cc_decls$strec *  q;
    p = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)owner,(struct cc_decls$strec *)symptr,(i64)6);
    q = p;
    L584 :;
    while (!!((q = (struct cc_decls$strec *)(*q).nextdupl))) {
        if (((*q).owner == owner)) {
            msysc$m_print_startcon();
            msysc$m_print_str((*q).name,NULL);
            msysc$m_print_str((byte*)"in",NULL);
            msysc$m_print_str((*owner).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_support$serror((byte*)"Dupl proc name");
        }
;
L585 :;
    }
L586 :;
    ;
    return (struct cc_decls$strec *)p;
}

struct cc_decls$strec *cc_lib$resolvename(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 ns,i64 blockno) {
        i64 nsblock;
        struct cc_decls$strec *  d;
        i64 nloops;
    if (((i64)(*symptr).nameid > (i64)1)) {
        return (struct cc_decls$strec *)symptr;
    }
;
    if ((ns == (i64)3)) {
        return (struct cc_decls$strec *)cc_lib$resolvelabel((struct cc_decls$strec *)owner,(struct cc_decls$strec *)symptr);
    }
;
    if ((!!(blockno) && ((i64)cc_decls$blockcounts[(blockno)] == (i64)0))) {
        blockno = (i64)cc_decls$blockowner[(blockno)];
    }
;
    nloops = (i64)0;
    L587 :;
    while (1) {
        nsblock = ((ns << (i64)16) | blockno);
        d = (struct cc_decls$strec *)symptr;
        L589 :;
        while (!!((d = (struct cc_decls$strec *)(*d).nextdupl))) {
            if (((((i64)(*owner).nameid == (i64)6) && ((*d).owner != owner)) && ((i64)(*(*d).owner).nameid == (i64)6))) {
                goto L591 ;
            }
;
            if ((((*d).owner == owner) && ((i64)(*d).nsblock == nsblock))) {
                return (struct cc_decls$strec *)d;
            }
;
L590 :;
        }
L591 :;
        ;
        if ((blockno == (i64)0)) {
                        {i64 $temp = (i64)(*owner).nameid;
if (($temp==(i64)6)) {
                owner = (struct cc_decls$strec *)cc_decls$stmodule;
                goto L587 ;
            }
            else if (($temp==(i64)13)) {
                owner = (struct cc_decls$strec *)(*owner).owner;
                if ((owner == 0)) {
                    return 0;
                }
;
            }
            else {
                return 0;
            }
            };
        }
        else if (((blockno = (i64)cc_decls$blockowner[(blockno)]) == (i64)0)) {
            owner = (struct cc_decls$strec *)cc_decls$stmodule;
        }
;
    }
L588 :;
    ;
    return (struct cc_decls$strec *)0;
}

struct cc_decls$strec *cc_lib$resolvelabel(struct cc_decls$strec *owner,struct cc_decls$strec *symptr) {
        struct cc_decls$strec *  d;
    d = (struct cc_decls$strec *)symptr;
    L592 :;
    while (!!((d = (struct cc_decls$strec *)(*d).nextdupl))) {
        if (((((i64)(*owner).nameid == (i64)6) && ((*d).owner != owner)) && ((i64)(*(*d).owner).nameid == (i64)6))) {
            goto L594 ;
        }
;
        if ((((*d).owner == owner) && ((i64)(*d).namespace == (i64)3))) {
            return (struct cc_decls$strec *)d;
        }
;
L593 :;
    }
L594 :;
    ;
    return (struct cc_decls$strec *)0;
}

struct cc_decls$strec *cc_lib$checkdupl(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 ns,i64 blockno) {
        i64 nsblock;
        struct cc_decls$strec *  d;
    d = (struct cc_decls$strec *)symptr;
    nsblock = ((ns << (i64)16) | blockno);
    L595 :;
    while (!!((d = (struct cc_decls$strec *)(*d).nextdupl))) {
        if ((((*d).owner == owner) && ((i64)(*d).nsblock == nsblock))) {
            return (struct cc_decls$strec *)d;
        }
;
L596 :;
    }
L597 :;
    ;
    return (struct cc_decls$strec *)0;
}

struct cc_decls$strec *cc_lib$checkdupl_inproc(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 ns,i64 blockno) {
        i64 nsblock;
        struct cc_decls$strec *  d;
    d = (struct cc_decls$strec *)symptr;
    nsblock = ((ns << (i64)16) | blockno);
    L598 :;
    while ((!!((d = (struct cc_decls$strec *)(*d).nextdupl)) && ((*d).owner == owner))) {
        if (((i64)(*d).nsblock == nsblock)) {
            return (struct cc_decls$strec *)d;
        }
;
L599 :;
    }
L600 :;
    ;
    return (struct cc_decls$strec *)0;
}

i64 cc_lib$getalignment(i64 m) {
        i64 a;
        {i64 $temp = cc_decls$ttbasetype[(m)];
if (($temp==(i64)19)) {
        return cc_lib$getalignment(cc_decls$tttarget[(m)]);
    }
    else if (($temp==(i64)20) || ($temp==(i64)21)) {
        a = (i64)(*cc_decls$ttnamedef[(m)]).attribs.ax_align;
        if ((a == (i64)0)) {
            return (i64)16;
        }
;
        return a;
    }
    };
    a = cc_decls$ttsize[(m)];
    if ((a==(i64)1) || (a==(i64)2) || (a==(i64)4) || (a==(i64)8)) {
        return a;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str(cc_lib$strmode(m,(i64)1),NULL);
    msysc$m_print_i64(a,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_support$serror((byte*)"GETALIGN SIZE NOT 1248");
    return (i64)0;
}

i64 cc_lib$isexported(struct cc_decls$strec *d) {
    if (((i64)(*d).nameid == (i64)6)) {
        if ((!!((*d).code) && (((i64)(*d).scope == (i64)3) || ((i64)(*d).scope == (i64)4)))) {
            return (i64)1;
        }
;
    }
    else {
        if (((i64)(*d).scope == (i64)4)) {
            return (i64)1;
        }
;
    }
;
    return (i64)0;
}

i64 cc_lib$isimported(struct cc_decls$strec *d) {
    if (((i64)(*d).nameid == (i64)6)) {
        if ((((*d).code == 0) && (((i64)(*d).scope == (i64)3) || ((i64)(*d).scope == (i64)4)))) {
            return (i64)1;
        }
;
    }
    else {
        if (((i64)(*d).scope == (i64)3)) {
            return (i64)1;
        }
;
    }
;
    return (i64)0;
}

i64 cc_lib$isstructunion(i64 m) {
        {i64 $temp = cc_decls$ttbasetype[(m)];
if (($temp==(i64)20) || ($temp==(i64)21)) {
                {i64 $temp = cc_decls$ttsize[(m)];
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4) || ($temp==(i64)8)) {
        }
        else {
            return (i64)1;
        }
        };
    }
    };
    return (i64)0;
}

u8 *cc_lib$getstname(struct cc_decls$strec *d) {
        static u8 name[256];
    memcpy(name,(void *)(*d).name,(u64)(i64)(*d).namelen);
    name[(((i64)(*d).namelen + (i64)1))-1] = (u64)0u;
    return (u8 *)name;
}

i64 cc_lib$isrealcc(i64 m) {
    m = cc_decls$ttbasetype[(m)];
    return (i64)((i64)11<=m && m<=(i64)13);
}

i64 cc_lib$isintcc(i64 m) {
    m = cc_decls$ttbasetype[(m)];
    return (i64)((i64)2<=m && m<=(i64)10);
}

// START
void cc_lib$start(void) {

}

void cc_libmcl$mclinit(void) {
    cc_libmcl$zero_opnd = (struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)4);
    cc_libmcl$zero_unit = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)0u,(i64)4);
    (*cc_libmcl$zero_unit).mode = (i64)4;
    cc_libmcl$dframeopnd = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)15,(i64)8);
    cc_libmcl$dstackopnd = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)16,(i64)8);
    cc_libmcl$initmcdest();
}

i64 cc_libmcl$gettargetdata(i64 f64) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"GETTARGETDATA",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    return (i64)1;
}

void cc_libmcl$initmcdest(void) {
    cc_libmcl$mccode = (cc_libmcl$mccodex = 0);
}

void cc_libmcl$genmc(i64 opcode,struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
        struct cc_libmcl$mclrec *  m;
        struct cc_libmcl$mclrec *  oldm;
    m = (struct cc_libmcl$mclrec *)mlib$pcm_alloc((i64)32);
    (*m).lineno = cc_decls$clineno;
    (*m).opcode = opcode;
    (*m).a = (struct cc_libmcl$opndrec *)a;
    (*m).b = (struct cc_libmcl$opndrec *)b;
    if ((opcode==(i64)5)) {
        if ((((!!(a) && ((i64)(*a).mode == (i64)1)) && !!(b)) && ((i64)(*b).mode == (i64)4))) {
            oldm = (struct cc_libmcl$mclrec *)cc_libmcl$mccodex;
            if ((((!!(oldm) && ((i64)(*oldm).opcode == (i64)5)) && ((i64)(*(*oldm).a).mode == (i64)4)) && ((i64)(*(*oldm).b).mode == (i64)1))) {
                if ((!!(cc_libmcl$sameoperand((struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)(*oldm).b)) && !!(cc_libmcl$sameoperand((struct cc_libmcl$opndrec *)(*oldm).a,(struct cc_libmcl$opndrec *)b)))) {
                    return;
                }
;
            }
;
        }
;
    }
    else if ((opcode==(i64)18)) {
                {i64 $temp = (i64)(*cc_libmcl$mccodex).opcode;
if (($temp==(i64)16) || ($temp==(i64)17) || ($temp==(i64)18)) {
            return;
        }
        };
    }
    else if ((opcode==(i64)6) || (opcode==(i64)7)) {
        cc_libmcl$stackaligned ^= (i64)1;
    }
;
    if (!!(cc_libmcl$mccode)) {
        (*cc_libmcl$mccodex).nextmcl = (struct cc_libmcl$mclrec *)m;
        cc_libmcl$mccodex = (struct cc_libmcl$mclrec *)m;
    }
    else {
        cc_libmcl$mccode = (cc_libmcl$mccodex = (struct cc_libmcl$mclrec *)m);
    }
;
}

void cc_libmcl$genmc_cond(i64 opcode,i64 cond,struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    cc_libmcl$genmc(opcode,(struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
    (*cc_libmcl$mccodex).cond = cond;
}

struct cc_libmcl$mclrec *cc_libmcl$lastmc(void) {
    return (struct cc_libmcl$mclrec *)cc_libmcl$mccodex;
}

void cc_libmcl$genmcstr(i64 opcode,u8 *s) {
    cc_libmcl$genmc(opcode,(struct cc_libmcl$opndrec *)cc_libmcl$genstrimm(s,(i64)-1),0);
}

static struct cc_libmcl$opndrec *cc_libmcl$newopnd(void) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)mlib$pcm_allocz((i64)32);
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$duplopnd(struct cc_libmcl$opndrec *a) {
        struct cc_libmcl$opndrec *  b;
    b = (struct cc_libmcl$opndrec *)mlib$pcm_alloc((i64)32);
    (*b) = (*a);
    return (struct cc_libmcl$opndrec *)b;
}

struct cc_libmcl$opndrec *cc_libmcl$genxreg(i64 xreg,i64 size) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)6;
    (*a).reg = xreg;
    (*a).size = size;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genindex(i64 areg,i64 ireg,i64 scale,i64 offset,i64 size,i64 labno,struct cc_decls$strec *def) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)4;
    (*a).reg = areg;
    (*a).regix = ireg;
    (*a).scale = scale;
    (*a).size = (!!(size) ? size : scale);
    (*a).value = offset;
    if (!!(offset)) {
        (*a).valtype = (i64)1;
    }
;
    (*a).def = (struct cc_decls$strec *)def;
    if (!!(labno)) {
        (*a).valtype = (i64)5;
        (*a).value = labno;
    }
    else if ((!!(def) && !!(cc_libmcl$isframe((struct cc_decls$strec *)def)))) {
        if (!!(areg)) {
            cc_support$gerror((byte*)"gen/index/areg",0);
        }
;
        (*a).reg = (i64)15;
    }
;
    return (struct cc_libmcl$opndrec *)a;
}

static void cc_libmcl$writemclblock(struct cc_libmcl$mclrec *m) {
        i64 i;
    i = (i64)1;
    L601 :;
    while (!!(m)) {
        cc_libmcl$writemcl(i,(struct cc_libmcl$mclrec *)m);
        ++(i);
        m = (struct cc_libmcl$mclrec *)(*m).nextmcl;
L602 :;
    }
L603 :;
    ;
}

struct mlib$strbuffer *cc_libmcl$writemclcode(u8 *caption,i64 nmodule) {
        struct cc_decls$strec *  d;
    mlib$gs_init((struct mlib$strbuffer *)cc_libmcl$dest);
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,caption);
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"---------------------------------------------");
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"MODULE CODE");
    cc_libmcl$writemclblock((struct cc_libmcl$mclrec *)cc_libmcl$modulecode);
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"---------------------------------------------");
    d = (struct cc_decls$strec *)(*cc_decls$moduletable[(nmodule)].stmodule).deflist;
    L604 :;
    while (!!(d)) {
        if ((((i64)(*d).nameid == (i64)6) && !!((*d).mclcode))) {
            mlib$gs_str((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"PROC:");
            mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(*d).name);
            cc_libmcl$writemclblock((struct cc_libmcl$mclrec *)(*d).mclcode);
        }
;
        d = (struct cc_decls$strec *)(*d).nextdef;
L605 :;
    }
L606 :;
    ;
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,(byte*)"---------------------------------------------");
    return (struct mlib$strbuffer *)cc_libmcl$dest;
}

void cc_libmcl$gencomment(u8 *s) {
    if (((s == 0) || ((i64)(u64)(*s) == (i64)0))) {
        cc_libmcl$genmc((i64)2,0,0);
    }
    else {
        cc_libmcl$genmcstr((i64)1,s);
    }
;
}

struct cc_libmcl$opndrec *cc_libmcl$genstrimm(u8 *s,i64 length) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)2;
    if ((length < (i64)0)) {
        length = strlen(s);
    }
;
    (*a).svalue = (u8 *)mlib$pcm_alloc((length + (i64)1));
    memcpy((void *)(*a).svalue,(void *)s,(u64)(length + (i64)1));
    (*a).valtype = (i64)3;
    (*a).size = (i64)8;
    (*a).slength = length;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genwstrimm(u16 *s,i64 length) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)2;
    (*a).wsvalue = (u16 *)mlib$pcm_alloc(((length * (i64)2) + (i64)2));
    memcpy((*a).wsvalue,s,(u64)((length + (i64)1) * (i64)2));
    (*a).valtype = (i64)4;
    (*a).size = (i64)8;
    (*a).slength = length;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genname(u8 *s) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)2;
    (*a).svalue = mlib$pcm_copyheapstring(s);
    (*a).valtype = (i64)6;
    (*a).size = (i64)8;
    return (struct cc_libmcl$opndrec *)a;
}

static void cc_libmcl$writemcl(i64 index,struct cc_libmcl$mclrec *mcl) {
    mlib$gs_strln((struct mlib$strbuffer *)cc_libmcl$dest,cc_libmcl$strmcl((struct cc_libmcl$mclrec *)mcl));
}

u8 *cc_libmcl$strmcl(struct cc_libmcl$mclrec *mcl) {
        static u8 str[512];
        u8 opnds[512];
        u8 opnd2[256];
        u8 opcname[128];
        struct cc_libmcl$opndrec *  a;
        struct cc_libmcl$opndrec *  b;
        i64 opcode;
        i64 cond;
        i64 sizepref;
    opcode = (i64)(*mcl).opcode;
    cond = (i64)(*mcl).cond;
    a = (struct cc_libmcl$opndrec *)(*mcl).a;
    b = (struct cc_libmcl$opndrec *)(*mcl).b;
    if ((opcode==(i64)67)) {
        return (*a).svalue;
    }
    else if ((opcode==(i64)2)) {
        return (byte*)"";
    }
    else if ((opcode==(i64)1)) {
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)";",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((*a).svalue,NULL);
        msysc$m_print_end();
        ;
        return (u8 *)str;
    }
    else if ((opcode==(i64)4)) {
        strcpy((u8 *)str,(*a).svalue);
        return (u8 *)str;
    }
    else if ((opcode==(i64)3)) {
        if (!!(b)) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"L#:#\t<#>");
            msysc$m_print_i64((*a).value,NULL);
            msysc$m_print_str((!!((i64)(*a).isglobal) ? (byte*)":" : (byte*)""),NULL);
            msysc$m_print_str((*(*b).def).name,NULL);
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"L#:#");
            msysc$m_print_i64((*a).value,NULL);
            msysc$m_print_str((!!((i64)(*a).isglobal) ? (byte*)":" : (byte*)""),NULL);
            msysc$m_print_end();
            ;
        }
;
        return (u8 *)str;
    }
;
    if ((opcode==(i64)19)) {
        msysc$m_print_startstr(opcname);
        msysc$m_print_str((byte*)"j",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(cc_libmcl$asmcondnames[(cond)],NULL);
        msysc$m_print_end();
        ;
    }
    else if ((opcode==(i64)40)) {
        msysc$m_print_startstr(opcname);
        msysc$m_print_str((byte*)"set",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(cc_libmcl$asmcondnames[(cond)],NULL);
        msysc$m_print_end();
        ;
    }
    else if ((opcode==(i64)9)) {
        msysc$m_print_startstr(opcname);
        msysc$m_print_str((byte*)"cmov",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(cc_libmcl$asmcondnames[(cond)],NULL);
        msysc$m_print_end();
        ;
    }
    else {
        strcpy((u8 *)opcname,(cc_libmcl$mclnames[(opcode)-1] + (i64)2));
    }
;
    mlib$ipadstr((u8 *)opcname,(i64)11,(byte*)" ");
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"\t",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(opcname,NULL);
    msysc$m_print_end();
    ;
    if ((!!(a) && !!(b))) {
        sizepref = cc_libmcl$needsizeprefix(opcode,(struct cc_libmcl$opndrec *)a,(struct cc_libmcl$opndrec *)b);
        strcpy((u8 *)opnd2,cc_libmcl$stropnd((struct cc_libmcl$opndrec *)b,sizepref,(i64)0));
        msysc$m_print_startstr(opnds);
        msysc$m_print_setfmt((byte*)"#,\t#");
        msysc$m_print_str(cc_libmcl$stropnd((struct cc_libmcl$opndrec *)a,sizepref,(i64)0),NULL);
        msysc$m_print_str(opnd2,NULL);
        msysc$m_print_end();
        ;
    }
    else if ((!!(a) && !!((i64)(*a).mode))) {
        if ((opcode == (i64)15)) {
            strcpy((u8 *)opnds,cc_libmcl$stropnd((struct cc_libmcl$opndrec *)a,(i64)0,(i64)0));
        }
        else {
            strcpy((u8 *)opnds,cc_libmcl$stropnd((struct cc_libmcl$opndrec *)a,(i64)1,(i64)0));
        }
;
    }
    else {
        opnds[((i64)1)-1] = (u64)0u;
    }
;
    if (!!((u64)opnds[((i64)1)-1])) {
        strcat((u8 *)str,(u8 *)opnds);
    }
;
    return (u8 *)str;
}

u8 *cc_libmcl$stropnd(struct cc_libmcl$opndrec *a,i64 sizeprefix,i64 debug) {
        static u8 str[512];
        u8 str2[128];
        u8 *  plus;
        u8 *  t;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
        return cc_libmcl$getregname((i64)(*a).reg,(i64)(*a).size);
    }
    else if (($temp==(i64)2)) {
        return cc_libmcl$strvalue((struct cc_libmcl$opndrec *)a);
    }
    else if (($temp==(i64)4)) {
        msysc$m_print_startstr(str);
        msysc$m_print_str(cc_libmcl$getsizeprefix((i64)(*a).size,sizeprefix),NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)"[",NULL);
        msysc$m_print_end();
        ;
        plus = (byte*)"";
        if (!!((i64)(*a).reg)) {
            strcat((u8 *)str,cc_libmcl$getregname((i64)(*a).reg,(i64)8));
            plus = (byte*)"+";
        }
;
        if (!!((i64)(*a).regix)) {
            strcat((u8 *)str,plus);
            strcat((u8 *)str,cc_libmcl$getregname((i64)(*a).regix,(i64)8));
            plus = (byte*)"+";
            if (((i64)(*a).scale > (i64)1)) {
                msysc$m_print_startstr(str2);
                msysc$m_print_str((byte*)"*",NULL);
                msysc$m_print_nogap();
                msysc$m_print_i64((i64)(*a).scale,NULL);
                msysc$m_print_end();
                ;
                strcat((u8 *)str,(u8 *)str2);
            }
;
        }
;
        if ((!!((*a).def) || !!((i64)(*a).valtype))) {
            t = cc_libmcl$strvalue((struct cc_libmcl$opndrec *)a);
            if (((u64)(*t) != '-')) {
                strcat((u8 *)str,plus);
            }
;
            strcat((u8 *)str,t);
        }
;
        strcat((u8 *)str,(byte*)"]");
    }
    else if (($temp==(i64)3)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"/#/*#");
        msysc$m_print_str((*a).svalue,NULL);
        msysc$m_print_i64((i64)(*a).slength,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)6)) {
        return cc_libmcl$fgetregname((i64)(*a).reg,(i64)(*a).size);
    }
    else {
        return (byte*)"<BAD OPND>";
    }
    };
    return (u8 *)str;
}

u8 *cc_libmcl$strvalue(struct cc_libmcl$opndrec *a) {
        static u8 str[512];
        u8 str2[128];
        struct cc_decls$strec *  def;
        i64 value;
    def = (struct cc_decls$strec *)(*a).def;
    value = (*a).value;
    if (!!(def)) {
                {i64 $temp = (i64)(*def).nameid;
if (($temp==(i64)7)) {
            if (((i64)(*(*def).owner).nameid == (i64)6)) {
                msysc$m_print_startstr(str);
                msysc$m_print_setfmt((byte*)"`#.#.#");
                msysc$m_print_str((*(*def).owner).name,NULL);
                msysc$m_print_str((*def).name,NULL);
                msysc$m_print_i64((i64)(*def).blockno,NULL);
                msysc$m_print_end();
                ;
            }
            else {
                strcpy((u8 *)str,cc_libmcl$getfullname((struct cc_decls$strec *)def));
                if (!!(cc_lib$isimported((struct cc_decls$strec *)def))) {
                    strcat((u8 *)str,(byte*)"*");
                }
;
            }
;
        }
        else if (($temp==(i64)8) || ($temp==(i64)9)) {
            strcpy((u8 *)str,cc_libmcl$getfullname((struct cc_decls$strec *)def));
        }
        else {
            strcpy((u8 *)str,cc_libmcl$getfullname((struct cc_decls$strec *)def));
            if (!!(cc_lib$isimported((struct cc_decls$strec *)def))) {
                strcat((u8 *)str,(byte*)"*");
            }
;
        }
        };
        if ((((i64)(*a).valtype == (i64)1) && (value != (i64)0))) {
            msysc$m_print_startstr(str2);
            msysc$m_print_str(((value > (i64)0) ? (byte*)"+" : (byte*)""),NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64(value,NULL);
            msysc$m_print_end();
            ;
            strcat((u8 *)str,(u8 *)str2);
        }
;
        return (u8 *)str;
    }
;
        {i64 $temp = (i64)(*a).valtype;
if (($temp==(i64)1) || ($temp==(i64)9)) {
        msysc$getstrint(value,(u8 *)str);
    }
    else if (($temp==(i64)2) || ($temp==(i64)10)) {
        msysc$m_print_startstr(str);
        msysc$m_print_r64((*a).xvalue,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)3) || ($temp==(i64)7)) {
        if (((strlen((*a).svalue) + (i64)4) < (i64)512)) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"\"#\"*#");
            msysc$m_print_str((*a).svalue,NULL);
            msysc$m_print_i64((i64)(*a).slength,NULL);
            msysc$m_print_end();
            ;
        }
        else {
            return (byte*)"<LONGSTR>";
        }
;
    }
    else if (($temp==(i64)4) || ($temp==(i64)8)) {
        return (byte*)"<WSTRING>";
    }
    else if (($temp==(i64)6)) {
        return (*a).svalue;
    }
    else if (($temp==(i64)5)) {
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"L",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64(value,NULL);
        msysc$m_print_end();
        ;
    }
    else {
        str[((i64)1)-1] = (u64)0u;
    }
    };
    return (u8 *)str;
}

void cc_libmcl$setsegment(i64 seg,i64 align) {
    if ((seg == cc_libmcl$currsegment)) {
        return;
    }
;
    if ((seg==(i64)73)) {
        cc_libmcl$genmc((i64)65,(struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"idata"),0);
    }
    else if ((seg==(i64)90)) {
        cc_libmcl$genmc((i64)65,(struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"zdata"),0);
    }
    else if ((seg==(i64)67)) {
        cc_libmcl$genmc((i64)65,(struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"code"),0);
    }
    else if ((seg==(i64)82)) {
        cc_libmcl$genmc((i64)65,(struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"rodata"),0);
    }
;
    cc_libmcl$currsegment = seg;
    cc_libmcl$currzdataalign = (cc_libmcl$curridataalign = (i64)0);
    cc_libmcl$setalign(align);
}

u8 *cc_libmcl$getprocname(struct cc_decls$strec *d) {
    if (!!(mlib$eqstring((*d).name,(byte*)"main"))) {
        return (byte*)"main";
    }
    else if (!!(mlib$eqstring((*d).name,(byte*)"start"))) {
        return (byte*)"start";
    }
    else {
        return cc_lib$getdottedname((struct cc_decls$strec *)d);
    }
;
    return (byte*)"";
}

i64 cc_libmcl$widenstr(u8 *s,i64 w) {
    L607 :;
    while ((strlen(s) >= (w - (i64)2))) {
        w += (i64)8;
L608 :;
    }
L609 :;
    ;
    return w;
}

void cc_libmcl$genassem(u8 *s) {
    cc_libmcl$genmcstr((i64)67,s);
}

u8 *cc_libmcl$strlabel(i64 n) {
        static u8 str[16];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"L",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

struct cc_libmcl$opndrec *cc_libmcl$makeindirect(struct cc_libmcl$opndrec *a,i64 size) {
        struct cc_libmcl$opndrec *  b;
    b = (struct cc_libmcl$opndrec *)cc_libmcl$duplopnd((struct cc_libmcl$opndrec *)a);
        {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1)) {
        (*b).mode = (i64)4;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"STROPND(B)=",NULL);
        msysc$m_print_str(cc_libmcl$stropnd((struct cc_libmcl$opndrec *)b,(i64)0,(i64)0),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_support$gerror((byte*)"makeind",0);
    }
    };
    if (!!(size)) {
        (*b).size = size;
    }
;
    return (struct cc_libmcl$opndrec *)b;
}

struct cc_libmcl$opndrec *cc_libmcl$applyoffset(struct cc_libmcl$opndrec *a,i64 offset,i64 size) {
        struct cc_libmcl$opndrec *  b;
    if (((offset == (i64)0) && (size == (i64)0))) {
        return (struct cc_libmcl$opndrec *)a;
    }
;
    b = (struct cc_libmcl$opndrec *)cc_libmcl$duplopnd((struct cc_libmcl$opndrec *)a);
    (*b).value += offset;
    (*b).valtype = (i64)1;
    if (!!(size)) {
        (*b).size = size;
    }
;
    return (struct cc_libmcl$opndrec *)b;
}

struct cc_libmcl$opndrec *cc_libmcl$applysize(struct cc_libmcl$opndrec *a,i64 size) {
    if (((i64)(*a).size != size)) {
        a = (struct cc_libmcl$opndrec *)cc_libmcl$duplopnd((struct cc_libmcl$opndrec *)a);
        (*a).size = size;
    }
;
    return (struct cc_libmcl$opndrec *)a;
}

i64 cc_libmcl$isframe(struct cc_decls$strec *d) {
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)8) || ($temp==(i64)9)) {
        return (i64)1;
    }
    };
    return (i64)0;
}

void cc_libmcl$genreturn(i64 fbytes,i64 pbytes) {
        u8 str[256];
        i64 iscallback;
    iscallback = cc_libmcl$iscallbackfn((struct cc_decls$strec *)cc_decls$currproc);
    cc_libmcl$retbeforeblock = (i64)1;
    if ((!!(fbytes) || !!(pbytes))) {
        if (!!(fbytes)) {
            cc_libmcl$popstack(cc_libmcl$roundto(fbytes,(i64)16));
        }
;
        cc_libmcl$genmc((i64)7,(struct cc_libmcl$opndrec *)cc_libmcl$dframeopnd,0);
        if (!!(iscallback)) {
            strcpy((u8 *)str,(byte*)"\tcall m$popcallback*");
            cc_libmcl$genassem((u8 *)str);
        }
;
        cc_libmcl$genmc((i64)16,0,0);
    }
    else {
        if (!!(iscallback)) {
            strcpy((u8 *)str,(byte*)"\tcall m$popcallback*");
            cc_libmcl$genassem((u8 *)str);
        }
;
        cc_libmcl$popstack((i64)8);
        cc_libmcl$genmc((i64)16,0,0);
    }
;
    cc_libmcl$stackaligned = (i64)1;
}

u8 *cc_libmcl$getsizeprefix(i64 size,i64 enable) {
    if (!(!!(enable))) {
        return (byte*)"";
    }
;
    if ((size==(i64)1)) {
        return (byte*)"byte ";
    }
    else if ((size==(i64)2)) {
        return (byte*)"word16 ";
    }
    else if ((size==(i64)4)) {
        return (byte*)"word32 ";
    }
    else if ((size==(i64)8)) {
        return (byte*)"word64 ";
    }
;
    return (byte*)"N:";
}

i64 cc_libmcl$needsizeprefix(i64 opcode,struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if ((opcode==(i64)12) || (opcode==(i64)11) || (opcode==(i64)74) || (opcode==(i64)73) || (opcode==(i64)89) || (opcode==(i64)90)) {
        return (i64)1;
    }
    else if ((opcode==(i64)50)) {
        return (i64)1;
    }
    else if ((opcode==(i64)33) || (opcode==(i64)71) || (opcode==(i64)70)) {
        if (((i64)(*a).mode == (i64)4)) {
            return (i64)1;
        }
;
        return (i64)0;
    }
;
    if ((((((i64)(*a).mode == (i64)1) || ((i64)(*a).mode == (i64)6)) || ((i64)(*b).mode == (i64)1)) || ((i64)(*b).mode == (i64)6))) {
        return (i64)0;
    }
;
    return (i64)1;
}

struct cc_libmcl$opndrec *cc_libmcl$changeopndsize(struct cc_libmcl$opndrec *a,i64 size) {
        struct cc_libmcl$opndrec *  b;
    if (((i64)(*a).size != size)) {
        b = (struct cc_libmcl$opndrec *)cc_libmcl$duplopnd((struct cc_libmcl$opndrec *)a);
        (*b).size = size;
        return (struct cc_libmcl$opndrec *)b;
    }
;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genint(i64 x,i64 size) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)2;
    (*a).value = x;
    (*a).valtype = (i64)1;
    (*a).size = size;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genreal(r64 x,i64 size) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)2;
    (*a).xvalue = x;
    (*a).valtype = (i64)2;
    (*a).size = size;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genimm(struct cc_decls$unitrec *p,i64 size) {
        struct cc_libmcl$opndrec *  a;
        i64 t;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)2;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        t = (i64)(*p).mode;
        if (!!(cc_lib$isintcc(t))) {
            (*a).value = (*p).value;
            (*a).valtype = (i64)1;
            (*a).size = (!!(size) ? size : cc_decls$ttsize[(t)]);
        }
        else if (!!(cc_lib$isrealcc(t))) {
            (*a).xvalue = (*p).xvalue;
            (*a).valtype = (i64)2;
            (*a).size = (!!(size) ? size : cc_decls$ttsize[(t)]);
        }
        else {
            cc_support$gerror((byte*)"GENIMM/MODE?",0);
        }
;
    }
    else if (($temp==(i64)3)) {
        (*a).def = (struct cc_decls$strec *)(*p).def;
        (*a).size = cc_decls$ttsize[((i64)(*(*p).def).mode)];
    }
    else {
        cc_support$gerror((byte*)"genimm/unit",0);
    }
    };
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genlabel(i64 x,i64 isglobal) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).size = (i64)8;
    (*a).mode = (i64)2;
    (*a).value = x;
    (*a).valtype = (i64)5;
    (*a).isglobal = isglobal;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genmem_u(struct cc_decls$unitrec *p,i64 size) {
    return (struct cc_libmcl$opndrec *)cc_libmcl$genmem_d((struct cc_decls$strec *)(*p).def,cc_decls$ttsize[((i64)(*p).mode)]);
}

struct cc_libmcl$opndrec *cc_libmcl$genmem_d(struct cc_decls$strec *d,i64 size) {
        struct cc_libmcl$opndrec *  a;
    ++(cc_libmcl$nmem);
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)4;
    if ((!!(cc_libmcl$isframe((struct cc_decls$strec *)d)) && !!(cc_libmcl$fshowfullnames))) {
        (*a).reg = (i64)15;
    }
;
    (*a).def = (struct cc_decls$strec *)d;
    (*a).size = (!!(size) ? size : cc_decls$ttsize[((i64)(*d).mode)]);
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genmemaddr_u(struct cc_decls$unitrec *p) {
    return (struct cc_libmcl$opndrec *)cc_libmcl$genmemaddr_d((struct cc_decls$strec *)(*p).def);
}

struct cc_libmcl$opndrec *cc_libmcl$genmemaddr_d(struct cc_decls$strec *d) {
        struct cc_libmcl$opndrec *  a;
    ++(cc_libmcl$nmemaddr);
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)2;
    if ((!!(cc_libmcl$isframe((struct cc_decls$strec *)d)) && !!(cc_libmcl$fshowfullnames))) {
        (*a).reg = (i64)15;
    }
;
    (*a).def = (struct cc_decls$strec *)d;
    (*a).size = (i64)8;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genreg(i64 reg,i64 size) {
        static i64 isnormal[9] = {(i64)0,(i64)1,(i64)1,(i64)0,(i64)1,(i64)0,(i64)0,(i64)0,(i64)1};
        struct cc_libmcl$opndrec *  a;
    if (((size <= (i64)8) && !!(isnormal[(size)]))) {
        a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
        (*a).mode = (i64)1;
        (*a).reg = reg;
        (*a).size = size;
    }
    else {
        cc_support$gerror((byte*)"GENREG/BLOCK SIZE",0);
    }
;
    return (struct cc_libmcl$opndrec *)a;
}

struct cc_libmcl$opndrec *cc_libmcl$genireg(i64 reg,i64 size) {
        struct cc_libmcl$opndrec *  a;
    a = (struct cc_libmcl$opndrec *)cc_libmcl$newopnd();
    (*a).mode = (i64)4;
    (*a).reg = reg;
    (*a).size = size;
    return (struct cc_libmcl$opndrec *)a;
}

i64 cc_libmcl$getopndsize_u(struct cc_decls$unitrec *p) {
    return cc_decls$ttsize[((i64)(*p).mode)];
}

i64 cc_libmcl$getopndsize_d(struct cc_decls$strec *d) {
    return cc_decls$ttsize[((i64)(*d).mode)];
}

i64 cc_libmcl$getmclcond(i64 opc,i64 m) {
        i64 signedx;
    signedx = (i64)cc_tables$stdtypesigned[(cc_decls$ttbasetype[(m)])];
    if (!!(cc_lib$isrealcc(m))) {
        if ((opc==(i64)36)) {
            return (i64)16;
        }
        else if ((opc==(i64)37)) {
            return (i64)18;
        }
        else if ((opc==(i64)39)) {
            return (i64)17;
        }
        else if ((opc==(i64)38)) {
            return (i64)19;
        }
        else if ((opc==(i64)34)) {
            return (i64)20;
        }
        else if ((opc==(i64)35)) {
            return (i64)21;
        }
;
    }
    else {
        if ((opc==(i64)36)) {
            return (!!(signedx) ? (i64)12 : (i64)2);
        }
        else if ((opc==(i64)37)) {
            return (!!(signedx) ? (i64)14 : (i64)6);
        }
        else if ((opc==(i64)39)) {
            return (!!(signedx) ? (i64)13 : (i64)3);
        }
        else if ((opc==(i64)38)) {
            return (!!(signedx) ? (i64)15 : (i64)7);
        }
        else if ((opc==(i64)34)) {
            return (i64)4;
        }
        else if ((opc==(i64)35)) {
            return (i64)5;
        }
;
    }
;
    return (i64)0;
}

u8 *cc_libmcl$getfullname(struct cc_decls$strec *d) {
    return (*d).name;
}

i64 cc_libmcl$roundsizetg(i64 size) {
    L610 :;
    while (!!((size & (i64)7))) {
        ++(size);
L611 :;
    }
L612 :;
    ;
    return size;
}

i64 cc_libmcl$iscallbackfn(struct cc_decls$strec *p) {
    return (i64)(*p).attribs.ax_callback;
}

u8 *cc_libmcl$getregname(i64 reg,i64 size) {
        static u8 *  prefix[8] = {(byte*)"B",(byte*)"W",(byte*)"",(byte*)"A",(byte*)"",(byte*)"",(byte*)"",(byte*)"D"};
        static u8 str[32];
        u8 str2[16];
        u8 *  rs;
    if ((size > (i64)8)) {
        return (byte*)"DBIG";
    }
;
    if ((reg==(i64)0)) {
        return (byte*)"-";
    }
    else if ((reg==(i64)15)) {
        rs = (byte*)"frame";
    }
    else if ((reg==(i64)16)) {
        rs = (byte*)"stack";
    }
    else {
        msysc$getstrint((reg - (i64)1),(u8 *)str2);
        rs = (u8 *)str2;
    }
;
    msysc$m_print_startstr(str);
    msysc$m_print_str(prefix[(size)-1],NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(rs,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

u8 *cc_libmcl$getblockname(i64 reg,i64 size) {
        static u8 str[32];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"N#(#)");
    msysc$m_print_i64((reg - (i64)1),NULL);
    msysc$m_print_i64(size,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

u8 *cc_libmcl$fgetregname(i64 reg,i64 size) {
        static u8 str[32];
    msysc$m_print_startstr(str);
    msysc$m_print_str(((size == (i64)8) ? (byte*)"DX" : (byte*)"SX"),NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64((reg - (i64)1),NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

i64 cc_libmcl$issimple(struct cc_decls$unitrec *p) {
    if ((u64)0u) {
        return (i64)0;
    }
;
    return cc_libmcl$issimple0(p,(i64)0);
}

static i64 cc_libmcl$issimple0(struct cc_decls$unitrec *p,i64 level) {
        struct cc_decls$unitrec *  a;
    ++(level);
    if ((level > (i64)5)) {
        return (i64)0;
    }
;
    a = (struct cc_decls$unitrec *)(*p).a;
    switch ((i64)(*p).tag) {
    case 1:;
    case 3:;
    case 5:;
        {
            return (i64)1;
        }
        break;
    case 53:;
        {
            if ((((i64)(*a).tag == (i64)54) || ((i64)(*a).tag == (i64)55))) {
                if ((!!(cc_libmcl$issimple0((struct cc_decls$unitrec *)(*a).a,level)) && !!(cc_libmcl$issimple0((struct cc_decls$unitrec *)(*a).b,level)))) {
                    return (i64)1;
                }
;
            }
            else {
                return cc_libmcl$issimple0(a,level);
            }
;
        }
        break;
    case 40:;
    case 41:;
    case 45:;
    case 46:;
    case 47:;
        {
            //dobin:
L613 :;
;
            if ((!!(cc_libmcl$issimple0(a,level)) && !!(cc_libmcl$issimple0((struct cc_decls$unitrec *)(*p).b,level)))) {
                return (i64)1;
            }
;
        }
        break;
    case 42:;
        {
            if ((cc_libmcl$gettypecat(p) == (i64)73)) {
                goto L613 ;
;
            }
;
        }
        break;
    case 57:;
        {
                        {i64 $temp = (i64)(*p).opcode;
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)3) || ($temp==(i64)4)) {
                return cc_libmcl$issimple0(a,level);
            }
            };
        }
        break;
    case 56:;
        {
            return cc_libmcl$issimple0(a,level);
        }
        break;
    case 50:;
        {
            return cc_libmcl$issimple0(a,level);
        }
        break;
    case 48:;
    case 49:;
        {
            if ((!!(cc_libmcl$issimple0(a,level)) && ((i64)(*(*p).b).tag == (i64)1))) {
                return (i64)1;
            }
;
        }
        break;
    } //SW
;
    return (i64)0;
}

i64 cc_libmcl$issimplepm(struct cc_decls$unitrec *p) {
    if ((u64)0u) {
        return (i64)0;
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1) || ($temp==(i64)3)) {
        return (i64)1;
    }
    };
    return (i64)0;
}

i64 cc_libmcl$getaregs(struct cc_libmcl$opndrec *ax) {
        i64 n;
        {i64 $temp = (i64)(*ax).mode;
if (($temp==(i64)1)) {
        return (i64)1;
    }
    else if (($temp==(i64)4)) {
        n = (i64)0;
        if ((!!((i64)(*ax).reg) && ((i64)(*ax).reg != (i64)15))) {
            ++(n);
        }
;
        if (!!((i64)(*ax).regix)) {
            ++(n);
        }
;
        return n;
    }
    else if (($temp==(i64)6)) {
        return (i64)0;
    }
    else {
        cc_support$gerror((byte*)"getaregs",0);
    }
    };
    return (i64)0;
}

i64 cc_libmcl$getlregs(struct cc_libmcl$opndrec *ax) {
        {i64 $temp = (i64)(*ax).mode;
if (($temp==(i64)1) || ($temp==(i64)6)) {
        return (i64)1;
    }
    else if (($temp==(i64)4)) {
        if (((!!((i64)(*ax).reg) && ((i64)(*ax).reg != (i64)15)) || !!((i64)(*ax).regix))) {
            return (i64)1;
        }
;
    }
    else if (($temp==(i64)2)) {
        return (i64)0;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(cc_libmcl$opndnames[((i64)(*ax).mode)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_support$gerror((byte*)"getlregs",0);
    }
    };
    return (i64)0;
}

i64 cc_libmcl$isintconst(struct cc_decls$unitrec *p) {
    if ((((i64)(*p).tag == (i64)1) && !!(cc_lib$isintcc((i64)(*p).mode)))) {
        return (i64)1;
    }
;
    return (i64)0;
}

i64 cc_libmcl$_getnextreg(struct cc_libmcl$opndrec *ax,i64 reg) {
        i64 maxreg;
        i64 r;
        i64 rix;
    r = (i64)(*ax).reg;
    rix = (i64)(*ax).regix;
        {i64 $temp = (i64)(*ax).mode;
if (($temp==(i64)1) || ($temp==(i64)6)) {
        if ((r < (i64)15)) {
            return ((r + (i64)1) + (i64)1);
        }
;
    }
    else if (($temp==(i64)4)) {
        maxreg = (i64)0;
        if (((r >= (i64)15) && (rix > (i64)15))) {
        }
        else if ((r > (i64)15)) {
            maxreg = rix;
        }
        else if ((rix > (i64)15)) {
            maxreg = r;
        }
        else {
            if ((r != (i64)15)) {
                maxreg = (r>rix?r:rix);
            }
            else {
                maxreg = rix;
            }
;
        }
;
        if (!!(maxreg)) {
            return (maxreg + (i64)1);
        }
;
    }
    };
    if ((reg == (i64)0)) {
        reg = (i64)1;
    }
;
    return reg;
}

i64 cc_libmcl$getnextreg(struct cc_libmcl$opndrec *ax,i64 r) {
        static i64 maxreg = (i64)0;
        i64 reg;
    reg = cc_libmcl$_getnextreg((struct cc_libmcl$opndrec *)ax,r);
    if ((reg > maxreg)) {
        maxreg = reg;
    }
;
    return reg;
}

i64 cc_libmcl$ispoweroftwo(i64 x) {
        i64 a;
        i64 n;
        i64 $av_1;
    a = (i64)1;
    n = (i64)0;
    $av_1 = (i64)30;
    while ($av_1-- > 0) {
L614 :;
        ++(n);
        a = (a << (i64)1);
        if ((a == x)) {
            return n;
        }
;
L615 :;
    }
L616 :;
    ;
    return (i64)0;
}

static i64 cc_libmcl$sameoperand(struct cc_libmcl$opndrec *a,struct cc_libmcl$opndrec *b) {
    if (((i64)(*a).mode != (i64)(*b).mode)) {
        return (i64)0;
    }
;
    if (((i64)(*a).size != (i64)(*b).size)) {
        return (i64)0;
    }
;
    if (((*a).value != (*b).value)) {
        return (i64)0;
    }
;
    if (((i64)(*a).reg != (i64)(*b).reg)) {
        return (i64)0;
    }
;
    if (((i64)(*a).regix != (i64)(*b).regix)) {
        return (i64)0;
    }
;
    if (((i64)(*a).valtype != (i64)(*b).valtype)) {
        return (i64)0;
    }
;
    if (((i64)(*a).scale != (i64)(*b).scale)) {
        return (i64)0;
    }
;
    if ((((!!((*a).def) && !!((*b).def)) && ((*a).def == (*b).def)) && ((*a).value == (*b).value))) {
        return (i64)1;
    }
    else if (((((*a).def == 0) && ((*b).def == 0)) && ((*a).value == (*b).value))) {
        return (i64)1;
    }
;
    return (i64)0;
}

static struct cc_libmcl$mclrec *cc_libmcl$findlastmcl(void) {
    cc_support$gerror((byte*)"FINDLASTMCL",0);
    return (struct cc_libmcl$mclrec *)0;
}

void cc_libmcl$genmsource(i64 lineno) {
}

i64 cc_libmcl$roundto(i64 a,i64 n) {
    --(n);
    L617 :;
    while (!!((a & n))) {
        ++(a);
L618 :;
    }
L619 :;
    ;
    return a;
}

void cc_libmcl$pushstack(i64 n) {
    if (!!(n)) {
        cc_libmcl$genmc((i64)22,(struct cc_libmcl$opndrec *)cc_libmcl$dstackopnd,(struct cc_libmcl$opndrec *)cc_libmcl$genint(n,(i64)4));
        if (!!((n & (i64)8))) {
            cc_libmcl$stackaligned ^= (i64)1;
        }
;
    }
;
}

void cc_libmcl$pushstackfp(i64 n) {
        i64 $av_1;
    if (!!(n)) {
        cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)0,(i64)4));
        $av_1 = (n / (i64)8);
        while ($av_1-- > 0) {
L620 :;
            cc_libmcl$genmc((i64)6,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)14,(i64)8),0);
L621 :;
        }
L622 :;
        ;
        if (!!((n & (i64)8))) {
            cc_libmcl$stackaligned ^= (i64)1;
        }
;
    }
;
}

void cc_libmcl$popstack(i64 n) {
    if (!!(n)) {
        cc_libmcl$genmc((i64)21,(struct cc_libmcl$opndrec *)cc_libmcl$dstackopnd,(struct cc_libmcl$opndrec *)cc_libmcl$genint(n,(i64)4));
        if (!!((n & (i64)8))) {
            cc_libmcl$stackaligned ^= (i64)1;
        }
;
    }
;
}

i64 cc_libmcl$definelabel(void) {
    cc_libmcl$genmc((i64)3,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(++(cc_decls$labelno),(i64)0),0);
    return cc_decls$labelno;
}

i64 cc_libmcl$createfwdlabel(void) {
    return ++(cc_decls$labelno);
}

void cc_libmcl$definefwdlabel(i64 lab) {
    cc_libmcl$genmc((i64)3,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(lab,(i64)0),0);
}

void cc_libmcl$genjumpl(i64 lab) {
    cc_libmcl$genmc((i64)18,(struct cc_libmcl$opndrec *)cc_libmcl$genlabel(lab,(i64)0),0);
}

void cc_libmcl$setalign(i64 align) {
    if ((align > (i64)1)) {
        cc_libmcl$genmc((i64)64,(struct cc_libmcl$opndrec *)cc_libmcl$genint(align,(i64)4),0);
    }
;
}

i64 cc_libmcl$gettypecat(struct cc_decls$unitrec *a) {
    return (i64)cc_tables$stdtypecat[(cc_decls$ttbasetype[((i64)(*a).mode)])];
}

void cc_libmcl$doblockcall(i64 size) {
        struct cc_libmcl$opndrec *  ax;
    if (!!(cc_libmcl$retbeforeblock)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"RB.",NULL);
        msysc$m_print_str((*cc_decls$currproc).name,NULL);
        msysc$m_print_end();
        ;
        cc_support$gerror((byte*)"Block call after return",0);
    }
;
    L623 :;
    while (!!((size & (i64)15))) {
        ++(size);
L624 :;
    }
L625 :;
    ;
    if ((cc_libmcl$currblocksize == (i64)0)) {
        cc_libmcl$currblocksize = size;
        cc_libmcl$frameoffset -= size;
        cc_libmcl$framebytes += size;
        (*(*cc_libmcl$stacksetinstr).b).value = cc_libmcl$roundto(cc_libmcl$framebytes,(i64)16);
    }
    else if ((cc_libmcl$currblocksize < size)) {
        cc_libmcl$frameoffset -= (size - cc_libmcl$currblocksize);
        cc_libmcl$framebytes += (size - cc_libmcl$currblocksize);
        cc_libmcl$currblocksize = size;
        (*(*cc_libmcl$stacksetinstr).b).value = cc_libmcl$roundto(cc_libmcl$framebytes,(i64)16);
    }
;
    ax = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)10,(i64)8);
    cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)ax,(struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)15,(i64)0,(i64)1,cc_libmcl$frameoffset,(i64)0,(i64)0,0));
}

struct cc_libmcl$opndrec *cc_libmcl$getblockreg(i64 size) {
        struct cc_libmcl$opndrec *  ax;
    L626 :;
    while (!!((size & (i64)15))) {
        ++(size);
L627 :;
    }
L628 :;
    ;
    if ((cc_libmcl$currblocksize < size)) {
        cc_support$gerror((byte*)"getblockreg?",0);
    }
;
    cc_libmcl$genmc((i64)8,(struct cc_libmcl$opndrec *)(ax = (struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)1,(i64)8)),(struct cc_libmcl$opndrec *)cc_libmcl$genindex((i64)15,(i64)0,(i64)1,cc_libmcl$frameoffset,(i64)0,(i64)0,0));
    return (struct cc_libmcl$opndrec *)ax;
}

void cc_libmcl$copyretvalue(i64 size) {
        u8 str[256];
    cc_libmcl$genassem((byte*)";-----------");
    cc_libmcl$genassem((byte*)"\tpush d0");
    cc_libmcl$genassem((byte*)"\tpush d0");
    cc_libmcl$genassem((byte*)"\tsub dstack,32");
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"\tmov d10,[dframe#]");
    msysc$m_print_i64(cc_libmcl$structretoffset,NULL);
    msysc$m_print_end();
    ;
    cc_libmcl$genassem((u8 *)str);
    cc_libmcl$genassem((byte*)"\tmov d11,d0");
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"\tmov d12,",NULL);
    msysc$m_print_i64(size,NULL);
    msysc$m_print_end();
    ;
    cc_libmcl$genassem((u8 *)str);
    cc_libmcl$genassem((byte*)"\tcall memcpy*");
    cc_libmcl$genassem((byte*)"\tadd dstack,32");
    cc_libmcl$genassem((byte*)"\tpop d0");
    cc_libmcl$genassem((byte*)"\tpop d0");
    cc_libmcl$genassem((byte*)";-----------");
}

void cc_libmcl$enterproc(u8 *name) {
    return;
    if ((!!(mlib$eqstring(name,(byte*)"$showentry")) || !!(mlib$eqstring(name,(byte*)"$showreturn")))) {
        return;
    }
;
    cc_libmcl$genmc((i64)22,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)16,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)32,(i64)4));
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)11,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genstrimm(name,(i64)-1));
    cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"$showentry*"),0);
    cc_libmcl$genmc((i64)21,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)16,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)32,(i64)4));
}

void cc_libmcl$leaveproc(u8 *name) {
    return;
    if ((!!(mlib$eqstring(name,(byte*)"$showentry")) || !!(mlib$eqstring(name,(byte*)"$showreturn")))) {
        return;
    }
;
    cc_libmcl$genmc((i64)22,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)16,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)32,(i64)4));
    cc_libmcl$genmc((i64)5,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)11,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genstrimm(name,(i64)-1));
    cc_libmcl$genmc((i64)15,(struct cc_libmcl$opndrec *)cc_libmcl$genname((byte*)"$showreturn*"),0);
    cc_libmcl$genmc((i64)21,(struct cc_libmcl$opndrec *)cc_libmcl$genreg((i64)16,(i64)8),(struct cc_libmcl$opndrec *)cc_libmcl$genint((i64)32,(i64)4));
}

// START
void cc_libmcl$start(void) {

}

static void cc_parse$readmodule(void) {
        i64 linkage;
        i64 m;
        i64 mbase;
        i64 commaseen;
        i64 wasdef;
        struct cc_decls$strec *  d;
        struct cc_decls$paramrec *  pm;
        i64 t;
        i64 nitems;
        i64 wasenum;
    L629 :;
    while (((i64)cc_decls$lx.symbol != (i64)58)) {
        nitems = (i64)0;
                {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)98)) {
            cc_lex$lex();
            t = cc_parse$readcasttype(&d,(i64)0,&pm,(i64)1,0);
            cc_lib$skipsymbol((i64)9);
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Type is:",NULL);
            msysc$m_print_str(cc_lib$strmode(t,(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            goto L630 ;
        }
        else if (($temp==(i64)101)) {
            nitems = (i64)1;
        }
        else if (($temp==(i64)9)) {
            cc_support$serror((byte*)"Extra semicolon 2");
        }
        };
        wasenum = (i64)cc_decls$lx.symbol;
        if (((i64)cc_decls$lx.symbol == (i64)101)) {
            nitems = (i64)1;
        }
;
        mbase = cc_parse$readdeclspec((struct cc_decls$strec *)cc_decls$stmodule,&linkage);
        commaseen = (i64)0;
        L632 :;
                {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)69) || ($temp==(i64)25) || ($temp==(i64)13)) {
            ++(nitems);
            m = cc_parse$readtype((struct cc_decls$strec *)cc_decls$stmodule,&d,mbase,&pm);
            if ((d == 0)) {
                cc_support$serror((byte*)"Var name expected");
            }
;
            if ((linkage == (i64)5)) {
                if (!!(pm)) {
                    m = cc_lib$createprocmode(m,(struct cc_decls$paramrec *)pm);
                }
;
                d = (struct cc_decls$strec *)cc_parse$createtypedef((struct cc_decls$strec *)cc_decls$stmodule,(struct cc_decls$strec *)d,m);
                cc_parse$constantseen = (i64)0;
            }
            else if (!!(pm)) {
                //readfn:
L634 :;
;
                if ((((i64)cc_decls$lx.symbol == (i64)17) && !!(commaseen))) {
                    cc_support$serror((byte*)"fn def after comma");
                }
;
                d = (struct cc_decls$strec *)cc_parse$readfunction((struct cc_decls$strec *)d,m,linkage,(struct cc_decls$paramrec *)pm,&wasdef);
                if (!!(wasdef)) {
                    goto L633 ;
                }
;
            }
            else if ((cc_decls$ttbasetype[(m)] == (i64)17)) {
                pm = (struct cc_decls$paramrec *)cc_decls$ttparams[(m)];
                m = cc_decls$tttarget[(m)];
                cc_parse$constantseen = (i64)0;
                goto L634 ;
;
            }
            else {
                d = (struct cc_decls$strec *)cc_parse$readmodulevar((struct cc_decls$strec *)d,m,linkage);
                cc_parse$constantseen = (i64)0;
            }
;
                        {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)8)) {
                commaseen = (i64)1;
                cc_lex$lex();
            }
            else {
                cc_lib$skipsymbol((i64)9);
                goto L633 ;
            }
            };
        }
        else if (($temp==(i64)103)) {
            cc_parse$constantseen = (i64)1;
            cc_lex$lex();
            goto L630 ;
        }
        else if (($temp==(i64)104)) {
            cc_parse$readstructinfosym();
        }
        else {
                        {i64 $temp = cc_decls$ttbasetype[(mbase)];
if (($temp==(i64)15) || ($temp==(i64)20) || ($temp==(i64)21)) {
                cc_lib$skipsymbol((i64)9);
                goto L633 ;
            }
            else if (($temp==(i64)4)) {
                cc_lib$skipsymbol((i64)9);
                goto L633 ;
            }
            else {
                cc_support$serror_s((byte*)"Decl error %s",cc_lib$typename(mbase));
            }
            };
        }
        }goto L632 ;
L633 :;
        ;
        if (((nitems == (i64)0) && !!(cc_decls$fmodern))) {
                        {i64 $temp = cc_decls$ttbasetype[(mbase)];
if (($temp==(i64)20) || ($temp==(i64)21) || ($temp==(i64)15)) {
            }
            else {
                if ((wasenum != (i64)91)) {
                    msysc$m_print_startcon();
                    msysc$m_print_str((byte*)"STRMODE(MBASE)=",NULL);
                    msysc$m_print_str(cc_lib$strmode(mbase,(i64)1),NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    cc_support$serror((byte*)"Empty declaration");
                }
;
            }
            };
        }
;
L630 :;
    }
L631 :;
    ;
}

i64 cc_parse$parsemodule(i64 n) {
        struct cc_decls$strec *  owner;
    cc_parse$loopindex = (cc_parse$iscallbackfnx = (cc_parse$constantseen = (cc_parse$ingeneric = (i64)0)));
    cc_parse$ist_symptr = 0;
    memset(&cc_parse$casevaluestack,(i32)(i64)0,(u64)512u);
    cc_lex$startlex((byte*)"PARSETEST",cc_decls$moduletable[(n)].fileno);
    owner = (struct cc_decls$strec *)cc_decls$stmodule;
    cc_decls$currproc = 0;
    cc_parse$loopindex = (i64)0;
    cc_lex$lex();
    cc_parse$readmodule();
    cc_lex$endlex();
    return (i64)1;
}

static i64 cc_parse$readdeclspec(struct cc_decls$strec *owner,i64 *linkage) {
        struct cc_parse$readdeclspec$declrec d;
        struct cc_decls$unitrec *  p;
        i64 t;
        i64 mod;
        i64 m;
        i64 fstruct;
        struct cc_decls$strec *  e;
        struct cc_decls$paramrec *  pm2;
    memset(&d,(i32)(i64)0,(u64)15u);
    fstruct = (mod = (i64)0);
    L635 :;
    switch ((i64)cc_decls$lx.symbol) {
    case 72:;
        {
            switch ((i64)cc_decls$lx.subcode) {
            case 5:;
            case 2:;
            case 6:;
            case 7:;
            case 10:;
            case 1:;
                {
                    if (!!((i64)d.typeno)) {
                        if (!!(fstruct)) {
                            cc_lib$checksymbol((i64)9);
                        }
                        else {
                            goto L637 ;
;
                        }
;
                    }
;
                    d.typeno = (i64)cc_tables$typespectypes[((i64)cc_decls$lx.subcode)-1];
                }
                break;
            case 3:;
                {
                    if (((!!((i64)d.isshort) || !!((i64)d.islong)) || !!((i64)d.isllong))) {
                        goto L637 ;
;
                    }
;
                    d.isshort = (mod = (i64)1);
                }
                break;
            case 4:;
                {
                    if ((!!((i64)d.isllong) || !!((i64)d.isshort))) {
                        goto L637 ;
;
                    }
                    else if (!!((i64)d.islong)) {
                        d.islong = (i64)0;
                        d.isllong = (i64)1;
                    }
                    else {
                        d.islong = (i64)1;
                    }
;
                    mod = (i64)1;
                }
                break;
            case 8:;
                {
                    if ((!!((i64)d.issigned) || !!((i64)d.isunsigned))) {
                        goto L637 ;
;
                    }
;
                    d.issigned = (mod = (i64)1);
                }
                break;
            case 9:;
                {
                    if ((!!((i64)d.issigned) || !!((i64)d.isunsigned))) {
                        goto L637 ;
;
                    }
;
                    d.isunsigned = (mod = (i64)1);
                }
                break;
            case 11:;
                {
                    if (((!!((i64)d.typeno) && ((i64)d.typeno != (i64)11)) && ((i64)d.typeno != (i64)12))) {
                        goto L637 ;
;
                    }
;
                    d.typeno = (i64)14;
                }
                break;
            default: {
                //tserror:
L637 :;
;
                cc_support$serror_s((byte*)"declspec/ts %s",cc_tables$typespecnames[((i64)cc_decls$lx.subcode)-1]);
            }
            } //SW
;
            cc_lex$lex();
        }
        break;
    case 88:;
        {
                        {i64 $temp = (i64)cc_decls$lx.subcode;
if (($temp==(i64)1)) {
                d.isconst = (i64)1;
            }
            else if (($temp==(i64)2)) {
                d.isvolatile = (i64)1;
            }
            else if (($temp==(i64)3)) {
                d.isrestrict = (i64)1;
            }
            };
            cc_lex$lex();
        }
        break;
    case 87:;
        {
            if (!!((i64)d.linkage)) {
                cc_support$serror((byte*)"Dual storage spec");
            }
;
            d.linkage = (i64)cc_decls$lx.subcode;
            cc_lex$lex();
        }
        break;
    case 89:;
        {
                        {i64 $temp = (i64)cc_decls$lx.subcode;
if (($temp==(i64)1)) {
                d.isinline = (i64)1;
            }
            else if (($temp==(i64)3)) {
                cc_decls$callbackflag = (i64)1;
            }
            };
            cc_lex$lex();
        }
        break;
    case 85:;
    case 86:;
        {
            if (!!((i64)d.typeno)) {
                cc_support$serror((byte*)"struct?");
            }
;
            d.typeno = cc_parse$readstructdecl((struct cc_decls$strec *)owner);
            d.isusertype = (i64)1;
            fstruct = (i64)1;
        }
        break;
    case 91:;
        {
            if (!!((i64)d.typeno)) {
                cc_support$serror((byte*)"enum?");
            }
;
            cc_parse$readenumdecl((struct cc_decls$strec *)owner);
            d.typeno = (i64)4;
            d.isusertype = (i64)1;
        }
        break;
    case 69:;
        {
            if ((!(!!((i64)d.typeno)) && !!((m = cc_parse$isusertype((struct cc_decls$strec *)owner))))) {
                if (!!(mod)) {
                    d.typeno = (i64)4;
                    goto L636 ;
                }
;
                d.typeno = m;
                d.isusertype = (i64)1;
                cc_lex$lex();
            }
            else {
                if ((((i64)d.typeno == (i64)0) && !(!!(mod)))) {
                    cc_support$serror_s((byte*)"Implicit decls not allowed: %s",(*cc_decls$lx.symptr).name);
                }
;
                if (((i64)d.typeno == (i64)0)) {
                    d.typeno = (i64)4;
                }
;
                goto L636 ;
            }
;
        }
        break;
    case 99:;
        {
            cc_lex$lex();
            cc_lib$skipsymbol((i64)13);
                        {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)72)) {
                //domode:
L638 :;
;
                d.typeno = cc_parse$readcasttype(&e,(i64)0,&pm2,(i64)1,0);
                cc_lib$skipsymbol((i64)14);
            }
            else if (($temp==(i64)69)) {
                e = (struct cc_decls$strec *)cc_lib$resolvename((!!(cc_decls$currproc) ? cc_decls$currproc : cc_decls$stmodule),(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)1,cc_decls$currblockno);
                if ((!!(e) && ((i64)(*e).nameid == (i64)5))) {
                    goto L638 ;
;
                }
;
                goto L639 ;
;
            }
            else {
                //doexpr:
L639 :;
;
                cc_parse$intypeof = (i64)1;
                p = cc_parse$readexpression();
                cc_parse$intypeof = (i64)0;
                cc_lib$skipsymbol((i64)14);
                if ((!!((i64)d.typeno) || !!(mod))) {
                    cc_support$serror((byte*)"typeof");
                }
;
                d.typeno = (i64)(*p).mode;
            }
            };
        }
        break;
    case 101:;
        {
            cc_parse$dostaticassert();
        }
        break;
    default: {
        goto L636 ;
    }
    } //SW
goto L635 ;
L636 :;
    ;
    t = (!!((i64)d.typeno) ? (i64)d.typeno : (i64)4);
    if (!(!!((i64)d.isusertype))) {
        if ((t==(i64)4)) {
            if (!!((i64)d.isshort)) {
                t = (!!((i64)d.isunsigned) ? (i64)8 : (i64)3);
            }
            else if (!!((i64)d.islong)) {
                if (!!(cc_decls$wintarget)) {
                    t = (!!((i64)d.isunsigned) ? (i64)9 : (i64)4);
                }
                else {
                    t = (!!((i64)d.isunsigned) ? (i64)10 : (i64)5);
                }
;
            }
            else if (!!((i64)d.isllong)) {
                t = (!!((i64)d.isunsigned) ? (i64)10 : (i64)5);
            }
            else if (!!((i64)d.isunsigned)) {
                t = (i64)9;
            }
;
        }
        else if ((t==(i64)2)) {
            if (((!!((i64)d.isshort) || !!((i64)d.islong)) || !!((i64)d.isllong))) {
                cc_support$serror((byte*)"char decl?");
            }
;
            t = (!!((i64)d.isunsigned) ? (i64)7 : (i64)2);
        }
        else if ((t==(i64)12)) {
            if ((((!!((i64)d.isshort) || !!((i64)d.isllong)) || !!((i64)d.issigned)) || !!((i64)d.isunsigned))) {
                cc_support$serror((byte*)"dbl decl?");
            }
;
        }
        else if ((t==(i64)14)) {
            if ((((!!((i64)d.isshort) || !!((i64)d.isllong)) || !!((i64)d.issigned)) || !!((i64)d.isunsigned))) {
                cc_support$serror((byte*)"Complex?");
            }
;
        }
        else {
            if (!!(mod)) {
                cc_support$serror((byte*)"declspec/float");
            }
;
        }
;
    }
;
    if (!!((i64)d.isconst)) {
        t = cc_lib$createconstmode(t);
    }
;
    (*linkage) = (i64)d.linkage;
    return t;
}

static i64 cc_parse$istypestarter(void) {
        struct cc_decls$strec *  d;
    switch ((i64)cc_decls$lx.symbol) {
    case 72:;
        {
            return (i64)1;
        }
        break;
    case 88:;
        {
            return (i64)1;
        }
        break;
    case 69:;
        {
            d = (struct cc_decls$strec *)cc_lib$resolvename((!!(cc_decls$currproc) ? cc_decls$currproc : cc_decls$stmodule),(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)1,cc_decls$currblockno);
            if (!!(d)) {
                cc_decls$lx.symptr = (struct cc_decls$strec *)d;
                return (i64)((i64)(*d).nameid == (i64)5);
            }
;
        }
        break;
    case 85:;
    case 86:;
    case 91:;
        {
            return (i64)1;
        }
        break;
    } //SW
;
    return (i64)0;
}

static i64 cc_parse$istypestarter_next(void) {
        struct cc_decls$strec *  d;
    switch ((i64)cc_decls$nextlx.symbol) {
    case 72:;
        {
            return (i64)1;
        }
        break;
    case 88:;
        {
            return (i64)1;
        }
        break;
    case 69:;
        {
            d = (struct cc_decls$strec *)cc_lib$resolvename((!!(cc_decls$currproc) ? cc_decls$currproc : cc_decls$stmodule),(struct cc_decls$strec *)cc_decls$nextlx.symptr,(i64)1,cc_decls$currblockno);
            if (!!(d)) {
                cc_decls$nextlx.symptr = (struct cc_decls$strec *)d;
                return (i64)((i64)(*d).nameid == (i64)5);
            }
;
        }
        break;
    case 85:;
    case 86:;
    case 91:;
        {
            return (i64)1;
        }
        break;
    } //SW
;
    return (i64)0;
}

static struct cc_decls$unitrec *cc_parse$readexpression(void) {
        struct cc_decls$unitrec *  p;
        struct cc_decls$unitrec *  ulist;
        struct cc_decls$unitrec *  ulistx;
        {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)9) || ($temp==(i64)14)) {
        return cc_parse$readterm();
    }
    };
    p = cc_parse$readassignexpr();
    if (((i64)cc_decls$lx.symbol == (i64)8)) {
        ulist = (ulistx = 0);
        L640 :;
        while (1) {
            cc_lib$addlistunit((struct cc_decls$unitrec **)&ulist,(struct cc_decls$unitrec **)&ulistx,(struct cc_decls$unitrec *)p);
            if (((i64)cc_decls$lx.symbol != (i64)8)) {
                goto L641 ;
            }
;
            cc_lex$lex();
            p = cc_parse$readassignexpr();
        }
L641 :;
        ;
        p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)30,(struct cc_decls$unitrec *)ulist);
        if (!!(ulistx)) {
            (*p).mode = (i64)(*ulistx).mode;
        }
;
        return p;
    }
;
    return p;
}

static struct cc_decls$unitrec *cc_parse$readassignexpr(void) {
        struct cc_decls$unitrec *  p;
        struct cc_decls$unitrec *  q;
        struct cc_decls$unitrec *  r;
        i64 opc;
        i64 oldpmode;
        {i64 $temp = (i64)cc_decls$nextlx.symbol;
if (($temp==(i64)8) || ($temp==(i64)9) || ($temp==(i64)14)) {
        return cc_parse$readterm();
    }
    else if (($temp==(i64)11)) {
        p = cc_parse$readterm();
        opc = (i64)cc_decls$lx.symbol;
        goto L642 ;
;
    }
    };
    p = cc_parse$readcondexpr();
    switch ((opc = (i64)cc_decls$lx.symbol)) {
    case 11:;
    case 48:;
    case 49:;
    case 50:;
    case 46:;
    case 47:;
    case 54:;
    case 55:;
    case 52:;
    case 53:;
    case 51:;
        {
            //gotp:
L642 :;
;
            cc_lex$lex();
            oldpmode = (i64)(*p).mode;
            cc_parse$checklvalue(p,(i64)1);
            q = cc_parse$readassignexpr();
            if (!!((i64)cc_decls$ttisref[((i64)(*p).mode)])) {
                return cc_parse$createassignopref(opc,p,q);
            }
;
            q = cc_parse$coercemode(q,oldpmode);
            if (!!((i64)cc_decls$ttconst[(oldpmode)])) {
                cc_support$terror((byte*)"Modifying read-only var");
            }
;
            if ((((i64)(*q).tag == (i64)57) && (opc == (i64)11))) {
                (*q).convtomem = (i64)1;
            }
;
            if ((((i64)(*p).tag == (i64)53) && ((i64)(*(*p).a).tag == (i64)1))) {
                cc_support$terror((byte*)"Modifying constant?");
            }
;
            r = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)cc_tables$symboltojtag[(opc)-1],(struct cc_decls$unitrec *)p,(struct cc_decls$unitrec *)q);
            (*r).mode = oldpmode;
            return r;
        }
        break;
    } //SW
;
    return p;
}

static struct cc_decls$unitrec *cc_parse$readcondexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
        struct cc_decls$unitrec *  pcond;
        i64 s;
        i64 t;
        i64 u;
    pcond = cc_parse$readorlexpr();
    if (((i64)cc_decls$lx.symbol == (i64)19)) {
        cc_parse$coercecond(pcond);
        cc_lex$lex();
        x = cc_parse$readexpression();
        cc_lib$skipsymbol((i64)10);
        y = cc_parse$readcondexpr();
        if (!!((u = (i64)cc_tables$dominantmode[((s = cc_decls$ttbasetype[((i64)(*x).mode)]))][((t = cc_decls$ttbasetype[((i64)(*y).mode)]))]))) {
            x = cc_parse$coercemode(x,u);
            y = cc_parse$coercemode(y,u);
            if (((((i64)(*pcond).tag == (i64)1) && ((i64)(*x).tag == (i64)1)) && ((i64)(*y).tag == (i64)1))) {
                return (!!((*pcond).value) ? x : y);
            }
;
        }
        else if (((s == (i64)16) && (t == (i64)16))) {
            u = (i64)(*x).mode;
        }
        else if (((((s == (i64)16) && (t == (i64)4)) && ((i64)(*y).tag == (i64)1)) && ((*y).value == (i64)0))) {
            u = (i64)(*x).mode;
            cc_parse$coercemode(y,u);
        }
        else if (((((s == (i64)4) && (t == (i64)16)) && ((i64)(*x).tag == (i64)1)) && ((*x).value == (i64)0))) {
            u = (i64)(*y).mode;
            cc_parse$coercemode(x,u);
        }
        else if (((s == (i64)20) && (t == (i64)20))) {
            u = (i64)(*x).mode;
        }
        else if (((s == (i64)21) && (t == (i64)21))) {
            u = (i64)(*x).mode;
        }
        else if ((s==t && t==(i64)1)) {
            u = (i64)1;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(cc_lib$strmode((i64)(*x).mode,(i64)1),NULL);
            msysc$m_print_str(cc_lib$strmode((i64)(*y).mode,(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_support$terror((byte*)"?: incompatible types");
        }
;
        pcond = (struct cc_decls$unitrec *)cc_lib$createunit3((i64)32,(struct cc_decls$unitrec *)pcond,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*pcond).mode = u;
    }
;
    return pcond;
}

static struct cc_decls$unitrec *cc_parse$readorlexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
    x = cc_parse$readandlexpr();
    L643 :;
    while (((i64)cc_decls$lx.symbol == (i64)31)) {
        cc_lex$lex();
        y = cc_parse$readandlexpr();
        cc_parse$coercecond(x);
        cc_parse$coercecond(y);
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            (*x).value = ((!!((*x).value) || !!((*y).value)) ? (i64)1 : (i64)0);
            goto L644 ;
        }
;
        x = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)26,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*x).mode = (i64)4;
L644 :;
    }
L645 :;
    ;
    return x;
}

static struct cc_decls$unitrec *cc_parse$readandlexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
    x = cc_parse$readiorexpr();
    L646 :;
    while (((i64)cc_decls$lx.symbol == (i64)32)) {
        cc_lex$lex();
        y = cc_parse$readiorexpr();
        cc_parse$coercecond(x);
        cc_parse$coercecond(y);
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            (*x).value = ((!!((*x).value) && !!((*y).value)) ? (i64)1 : (i64)0);
            goto L647 ;
        }
;
        x = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)25,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*x).mode = (i64)4;
L647 :;
    }
L648 :;
    ;
    return x;
}

static struct cc_decls$unitrec *cc_parse$readiorexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
        i64 u;
    x = cc_parse$readixorexpr();
    L649 :;
    while (((i64)cc_decls$lx.symbol == (i64)28)) {
        cc_lex$lex();
        y = cc_parse$readixorexpr();
        if (!!((u = (i64)cc_tables$dominantmode[(cc_decls$ttbasetype[((i64)(*x).mode)])][(cc_decls$ttbasetype[((i64)(*y).mode)])]))) {
            if ((u >= (i64)11)) {
                cc_support$terror((byte*)"float|float");
            }
;
            x = cc_parse$coercemode(x,u);
            y = cc_parse$coercemode(y,u);
        }
        else {
            cc_support$terror((byte*)"invalid | operands");
        }
;
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value |= (*y).value;
                goto L650 ;
            }
;
        }
;
        x = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)46,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*x).mode = u;
L650 :;
    }
L651 :;
    ;
    return x;
}

static struct cc_decls$unitrec *cc_parse$readixorexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
        i64 u;
    x = cc_parse$readiandexpr();
    L652 :;
    while (((i64)cc_decls$lx.symbol == (i64)30)) {
        cc_lex$lex();
        y = cc_parse$readiandexpr();
        if (!!((u = (i64)cc_tables$dominantmode[(cc_decls$ttbasetype[((i64)(*x).mode)])][(cc_decls$ttbasetype[((i64)(*y).mode)])]))) {
            if ((u >= (i64)11)) {
                cc_support$terror((byte*)"float^float");
            }
;
            x = cc_parse$coercemode(x,u);
            y = cc_parse$coercemode(y,u);
        }
        else {
            cc_support$terror((byte*)"invalid ^ operands");
        }
;
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value ^= (*y).value;
                goto L653 ;
            }
;
        }
;
        x = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)47,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*x).mode = u;
L653 :;
    }
L654 :;
    ;
    return x;
}

static struct cc_decls$unitrec *cc_parse$readiandexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
        i64 u;
    x = cc_parse$readeqexpr();
    L655 :;
    while (((i64)cc_decls$lx.symbol == (i64)29)) {
        cc_lex$lex();
        y = cc_parse$readeqexpr();
        if (!!((u = (i64)cc_tables$dominantmode[(cc_decls$ttbasetype[((i64)(*x).mode)])][(cc_decls$ttbasetype[((i64)(*y).mode)])]))) {
            if ((u >= (i64)11)) {
                cc_support$terror((byte*)"float&float");
            }
;
            x = cc_parse$coercemode(x,u);
            y = cc_parse$coercemode(y,u);
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(cc_lib$strmode((i64)(*x).mode,(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_str(cc_lib$strmode((i64)(*y).mode,(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_support$terror((byte*)"invalid & operands");
        }
;
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value &= (*y).value;
                goto L656 ;
            }
;
        }
;
        x = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)45,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*x).mode = u;
L656 :;
    }
L657 :;
    ;
    return x;
}

static struct cc_decls$unitrec *cc_parse$readeqexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
        i64 opc;
        i64 s;
        i64 t;
        i64 u;
        i64 ss;
        i64 tt;
    x = cc_parse$readrelexpr();
    L658 :;
    while ((((opc = (i64)cc_decls$lx.symbol) == (i64)40) || (opc == (i64)41))) {
        cc_lex$lex();
        y = cc_parse$readrelexpr();
        if (!!((u = (i64)cc_tables$dominantmode[((s = cc_decls$ttbasetype[((i64)(*x).mode)]))][((t = cc_decls$ttbasetype[((i64)(*y).mode)]))]))) {
            x = cc_parse$coercemode(x,u);
            y = cc_parse$coercemode(y,u);
        }
        else if (((s == (i64)16) && (t == (i64)16))) {
            if (((ss = cc_decls$tttarget[((i64)(*x).mode)]) != (tt = cc_decls$tttarget[((i64)(*y).mode)]))) {
                if (((ss != (i64)1) && (tt != (i64)1))) {
                    if (!(!!(cc_parse$checkpointertypes((i64)(*x).mode,(i64)(*y).mode,(i64)1)))) {
                        msysc$m_print_startcon();
                        msysc$m_print_str((byte*)"STRMODE(X.MODE)=",NULL);
                        msysc$m_print_str(cc_lib$strmode((i64)(*x).mode,(i64)1),NULL);
                        msysc$m_print_str(cc_lib$strmode((i64)(*y).mode,(i64)1),NULL);
                        msysc$m_print_newline();
                        msysc$m_print_end();
                        ;
                        cc_support$terror((byte*)"Comparing distinct pointers/eq");
                    }
;
                }
;
            }
;
        }
        else if (((s == (i64)16) && (t == (i64)4))) {
            if ((((i64)(*y).tag != (i64)1) || ((*y).value != (i64)0))) {
                cc_support$terror((byte*)"Can't compare pointer to int");
            }
;
        }
        else if (((s == (i64)4) && (t == (i64)16))) {
            if ((((i64)(*x).tag != (i64)1) || ((*x).value != (i64)0))) {
                cc_support$terror((byte*)"Can't compare pointer to int2");
            }
;
        }
        else {
            cc_support$terror((byte*)"invalid == operands");
        }
;
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10) || (u==(i64)0)) {
                if ((opc == (i64)40)) {
                    (*x).value = (i64)((*x).value == (*y).value);
                }
                else {
                    (*x).value = (i64)((*x).value != (*y).value);
                }
;
                goto L659 ;
            }
;
        }
;
        x = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)cc_tables$symboltojtag[(opc)-1],(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*x).mode = (i64)4;
L659 :;
    }
L660 :;
    ;
    return x;
}

static struct cc_decls$unitrec *cc_parse$readrelexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
        i64 opc;
        i64 s;
        i64 t;
        i64 u;
        i64 a;
        i64 b;
        i64 c;
        u64 aa;
        u64 bb;
        u64 cc;
    x = cc_parse$readshiftexpr();
    L661 :;
    while ((((((opc = (i64)cc_decls$lx.symbol) == (i64)42) || (opc == (i64)43)) || (opc == (i64)44)) || (opc == (i64)45))) {
        cc_lex$lex();
        y = cc_parse$readshiftexpr();
        if (!!((u = (i64)cc_tables$dominantmode[((s = cc_decls$ttbasetype[((i64)(*x).mode)]))][((t = cc_decls$ttbasetype[((i64)(*y).mode)]))]))) {
            x = cc_parse$coercemode(x,u);
            y = cc_parse$coercemode(y,u);
        }
        else if (((s == (i64)16) && (t == (i64)16))) {
            if (!(!!(cc_parse$checkpointertypes((i64)(*x).mode,(i64)(*y).mode,(i64)1)))) {
                cc_support$terror((byte*)"Comparing distinct pointers/rel");
            }
;
        }
        else {
            cc_support$terror((byte*)"invalid rel operands");
        }
;
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            a = (*x).value;
            b = (*y).value;
            if ((u==(i64)4) || (u==(i64)5)) {
                if ((opc==(i64)42)) {
                    c = (i64)(a < b);
                }
                else if ((opc==(i64)43)) {
                    c = (i64)(a <= b);
                }
                else if ((opc==(i64)44)) {
                    c = (i64)(a >= b);
                }
                else {
                    c = (i64)(a > b);
                }
;
                (*x).value = c;
                goto L662 ;
            }
            else if ((u==(i64)9) || (u==(i64)10)) {
                aa = (u64)(*x).value;
                bb = (u64)(*y).value;
                if ((opc==(i64)42)) {
                    cc = (u64)(aa < bb);
                }
                else if ((opc==(i64)43)) {
                    cc = (u64)(aa <= bb);
                }
                else if ((opc==(i64)44)) {
                    cc = (u64)(aa >= bb);
                }
                else {
                    cc = (u64)(aa > bb);
                }
;
                (*x).value = (i64)cc;
                goto L662 ;
            }
;
        }
;
        x = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)cc_tables$symboltojtag[(opc)-1],(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*x).mode = (i64)4;
L662 :;
    }
L663 :;
    ;
    return x;
}

static struct cc_decls$unitrec *cc_parse$readshiftexpr(void) {
        struct cc_decls$unitrec *  x;
        struct cc_decls$unitrec *  y;
        i64 opc;
        i64 u;
    x = cc_parse$readaddexpr();
    L664 :;
    while ((((opc = (i64)cc_decls$lx.symbol) == (i64)33) || (opc == (i64)34))) {
        cc_lex$lex();
        y = cc_parse$readaddexpr();
        cc_parse$coercebasetype(x);
        if (!((((u = cc_decls$ttbasetype[((i64)(*x).mode)]) >= (i64)2) && (u <= (i64)10)))) {
            cc_support$terror((byte*)"shift:Not an int");
        }
;
        y = cc_parse$coercemode(y,(i64)4);
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5)) {
                if ((opc == (i64)33)) {
                    (*x).value = ((*x).value << (*y).value);
                }
                else {
                    (*x).value = ((*x).value >> (*y).value);
                }
;
                goto L665 ;
            }
            else if ((u==(i64)9) || (u==(i64)10)) {
                if ((opc == (i64)33)) {
                    (*x).uvalue = ((*x).uvalue << (*y).value);
                }
                else {
                    (*x).uvalue = ((*x).uvalue >> (*y).value);
                }
;
                goto L665 ;
            }
;
        }
;
        x = (struct cc_decls$unitrec *)cc_lib$createunit2(((opc == (i64)33) ? (i64)48 : (i64)49),(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*x).mode = u;
L665 :;
    }
L666 :;
    ;
    return x;
}

static struct cc_decls$unitrec *cc_parse$readaddexpr(void) {
        struct cc_decls$unitrec *  p;
        struct cc_decls$unitrec *  q;
        i64 opc;
    p = cc_parse$readmulexpr();
    L667 :;
    while ((((opc = (i64)cc_decls$lx.symbol) == (i64)23) || (opc == (i64)24))) {
        cc_lex$lex();
        q = cc_parse$readmulexpr();
        if ((opc == (i64)23)) {
            p = cc_parse$createaddop(p,q);
        }
        else {
            p = cc_parse$createsubop(p,q);
        }
;
L668 :;
    }
L669 :;
    ;
    return p;
}

static struct cc_decls$unitrec *cc_parse$readmulexpr(void) {
        struct cc_decls$unitrec *  p;
        struct cc_decls$unitrec *  q;
        i64 opc;
    p = cc_parse$readterm();
    L670 :;
    while (((((opc = (i64)cc_decls$lx.symbol) == (i64)25) || (opc == (i64)26)) || (opc == (i64)27))) {
        cc_lex$lex();
        q = cc_parse$readterm();
        if ((opc==(i64)25)) {
            p = cc_parse$createmulop(p,q);
        }
        else if ((opc==(i64)26)) {
            p = cc_parse$createdivop(p,q);
        }
        else if ((opc==(i64)27)) {
            p = cc_parse$createremop(p,q);
        }
;
L671 :;
    }
L672 :;
    ;
    return p;
}

static struct cc_decls$unitrec *cc_parse$readterm(void) {
        struct cc_decls$unitrec *  p;
        struct cc_decls$unitrec *  q;
        i64 t;
        i64 opc;
        i64 shift;
        i64 newlen;
        i64 slength;
        i64 fwide;
        u8 *  pbyte;
        i64 a;
        struct cc_decls$strec *  d;
        u8 *  ss;
        u8 *  s;
        struct cc_decls$paramrec *  pm;
        i64 $av_1;
    switch ((i64)cc_decls$lx.symbol) {
    case 60:;
    case 61:;
        {
            p = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)cc_decls$lx.value,(i64)cc_decls$lx.subcode);
            cc_lex$lex();
        }
        break;
    case 69:;
        {
            if (((i64)(*cc_decls$lx.symptr).nameid <= (i64)1)) {
                d = (struct cc_decls$strec *)cc_lib$resolvename((!!(cc_decls$currproc) ? cc_decls$currproc : cc_decls$stmodule),(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)1,cc_decls$currblockno);
                if ((d == 0)) {
                    cc_support$serror_s((byte*)"Undefined name \"%s\"",cc_lib$getstname((struct cc_decls$strec *)cc_decls$lx.symptr));
                }
;
            }
            else {
                d = (struct cc_decls$strec *)cc_decls$lx.symptr;
            }
;
            (*d).attribs.ax_used = (i64)1;
                        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)11)) {
                p = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)(i64)(*d).index,(i64)4);
            }
            else if (($temp==(i64)14)) {
                p = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)(*(*d).code).value,(i64)(*d).mode);
            }
            else if (($temp==(i64)6)) {
                if (((i64)cc_decls$nextlx.symbol != (i64)13)) {
                    p = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)5);
                    (*p).def = (struct cc_decls$strec *)d;
                    (*p).mode = cc_lib$createrefmode(cc_lib$createprocmode((i64)(*d).mode,(struct cc_decls$paramrec *)(*d).paramlist));
                }
                else {
                    goto L673 ;
;
                }
;
            }
            else {
                //doname:
L673 :;
;
                p = (struct cc_decls$unitrec *)cc_lib$createname((struct cc_decls$strec *)d);
                (*p).mode = (t = (i64)(*d).mode);
                if ((cc_decls$ttbasetype[(t)] == (i64)19)) {
                    if (!(!!(cc_parse$intypeof))) {
                        (*p).alength = cc_decls$ttlength[(t)];
                        p = cc_parse$createaddrofop(p);
                        (*p).mode = cc_lib$createrefmode(cc_decls$tttarget[(t)]);
                    }
;
                }
                else if (((((i64)(*d).nameid != (i64)6) && ((i64)(*d).nameid != (i64)14)) && (cc_decls$ttsize[(t)] < (i64)4))) {
                    cc_parse$fixmemopnd(p);
                }
                else if (((i64)(*d).nameid == (i64)9)) {
                    if (!!(cc_lib$isstructunion((i64)(*p).mode))) {
                        (*p).lineno = (i64)cc_decls$lx.lineno;
                        (*p).mode = cc_lib$createrefmode((i64)(*p).mode);
                        p = cc_parse$createptrop(p);
                        (*p).mode = (i64)(*d).mode;
                    }
;
                }
;
            }
            };
            (*p).lineno = (i64)cc_decls$lx.lineno;
            cc_lex$lex();
        }
        break;
    case 64:;
    case 65:;
        {
            fwide = (i64)((i64)cc_decls$lx.symbol == (i64)65);
            s = cc_decls$lx.svalue;
            slength = (i64)cc_decls$lx.length;
            L674 :;
            while (((i64)cc_decls$nextlx.symbol == (i64)64)) {
                newlen = (slength + (i64)cc_decls$nextlx.length);
                ss = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
                memcpy((void *)ss,(void *)s,(u64)slength);
                memcpy((void *)(ss + slength),(void *)cc_decls$nextlx.svalue,(u64)(i64)cc_decls$nextlx.length);
                (*(ss + newlen)) = (u64)0u;
                s = ss;
                slength = newlen;
                cc_lex$lex();
L675 :;
            }
L676 :;
            ;
            if (!!(fwide)) {
                p = (struct cc_decls$unitrec *)cc_lib$createwstringconstunit((u16 *)s,slength);
                (*p).wslength = slength;
                (*p).mode = cc_decls$trefwchar;
            }
            else {
                p = (struct cc_decls$unitrec *)cc_lib$createstringconstunit(s,slength);
                (*p).slength = slength;
                (*p).mode = cc_decls$trefchar;
            }
;
            cc_lex$lex();
        }
        break;
    case 68:;
        {
            p = cc_parse$readstrinclude();
        }
        break;
    case 62:;
        {
            a = (i64)0;
            shift = (i64)0;
            pbyte = cc_decls$lx.svalue;
            if (((i64)cc_decls$lx.length > (i64)8)) {
                cc_support$serror((byte*)"char const too long");
            }
;
            $av_1 = (i64)cc_decls$lx.length;
            while ($av_1-- > 0) {
L677 :;
                a = (a | (i64)((u64)(u64)(*pbyte) << shift));
                shift += (i64)8;
                ++(pbyte);
L678 :;
            }
L679 :;
            ;
            p = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)a,(((i64)cc_decls$lx.length <= (i64)4) ? (i64)4 : (i64)5));
            cc_lex$lex();
        }
        break;
    case 23:;
        {
            cc_lex$lex();
            p = cc_parse$readterm();
        }
        break;
    case 24:;
        {
            cc_lex$lex();
            p = cc_parse$createnegop(cc_parse$readterm());
        }
        break;
    case 36:;
        {
            cc_lex$lex();
            p = cc_parse$readterm();
            cc_parse$coercecond(p);
            p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)27,(struct cc_decls$unitrec *)p);
            (*p).mode = (i64)4;
            if ((((i64)(*(*p).a).tag == (i64)27) && ((i64)(*(*(*p).a).a).tag == (i64)27))) {
                (*p).a = (*(*(*p).a).a).a;
            }
;
        }
        break;
    case 35:;
        {
            cc_lex$lex();
            p = cc_parse$createinotop(cc_parse$readterm());
        }
        break;
    case 29:;
        {
            cc_lex$lex();
            if (((i64)cc_decls$lx.symbol == (i64)25)) {
                cc_lex$lex();
                p = cc_parse$readterm();
            }
            else {
                p = cc_parse$createaddrofop(cc_parse$readterm());
            }
;
        }
        break;
    case 32:;
        {
            cc_support$serror((byte*)"rt/&&label");
        }
        break;
    case 25:;
        {
            cc_lex$lex();
            p = cc_parse$createptrop(cc_parse$readterm());
        }
        break;
    case 37:;
    case 38:;
        {
            opc = (i64)cc_tables$symboltojtag[((i64)cc_decls$lx.symbol)-1];
            cc_lex$lex();
            p = cc_parse$createincrop(opc,cc_parse$readterm());
        }
        break;
    case 39:;
        {
            cc_lex$lex();
            cc_lib$skipsymbol((i64)13);
            p = cc_parse$createabsop(cc_parse$readexpression());
            cc_lib$skipsymbol((i64)14);
        }
        break;
    case 56:;
        {
            cc_lex$lex();
            cc_lib$skipsymbol((i64)13);
            p = cc_parse$createsqrtop(cc_parse$readexpression());
            cc_lib$skipsymbol((i64)14);
        }
        break;
    case 13:;
        {
            cc_lex$lex();
            if (!!(cc_parse$istypestarter())) {
                t = cc_parse$readcasttype(&d,(i64)0,&pm,(i64)1,0);
                cc_lib$skipsymbol((i64)14);
                if (((i64)cc_decls$lx.symbol == (i64)17)) {
                    cc_support$serror((byte*)"rt/compound lit");
                }
                else {
                    p = cc_parse$docast(cc_parse$readterm(),t,(i64)1,(i64)0);
                }
;
            }
            else {
                p = cc_parse$readexpression();
                cc_lib$skipsymbol((i64)14);
            }
;
        }
        break;
    case 92:;
        {
            cc_lex$lex();
            if (((i64)cc_decls$lx.symbol == (i64)13)) {
                if (!!(cc_parse$istypestarter_next())) {
                    cc_lex$lex();
                    t = cc_parse$readcasttype(&d,(i64)0,&pm,(i64)1,0);
                    cc_lib$skipsymbol((i64)14);
                    p = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)cc_decls$ttsize[(t)],(i64)10);
                }
                else {
                    p = cc_parse$readterm();
                    p = cc_parse$createsizeofop(p);
                }
;
            }
            else {
                p = cc_parse$createsizeofop(cc_parse$readterm());
            }
;
        }
        break;
    case 93:;
        {
            cc_lex$lex();
            if (((i64)cc_decls$lx.symbol == (i64)13)) {
                cc_lex$lex();
                if (!!(cc_parse$istypestarter())) {
                    t = cc_parse$readcasttype(&d,(i64)0,&pm,(i64)1,0);
                    cc_lib$skipsymbol((i64)14);
                    p = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)cc_decls$ttlength[(t)],(i64)4);
                }
                else {
                    p = cc_parse$readexpression();
                    cc_lib$skipsymbol((i64)14);
                    p = cc_parse$createlengthofop(p);
                }
;
            }
            else {
                p = cc_parse$createlengthofop(cc_parse$readterm());
            }
;
        }
        break;
    case 95:;
        {
            p = cc_parse$readgeneric();
        }
        break;
    case 96:;
        {
            cc_support$serror((byte*)"rt/alignof");
        }
        break;
    case 100:;
        {
            cc_lex$lex();
            cc_lib$skipsymbol((i64)13);
            t = cc_parse$readcasttype(&d,(i64)0,&pm,(i64)1,0);
            cc_lib$skipsymbol((i64)14);
            p = (struct cc_decls$unitrec *)cc_lib$createstringconstunit(mlib$pcm_copyheapstring(cc_lib$strmode(t,(i64)1)),(i64)-1);
        }
        break;
    case 102:;
        {
            p = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)77);
            (*p).mode = (i64)5;
            cc_lex$lex();
        }
        break;
    default: {
        cc_lex$ps((byte*)"RT");
        cc_support$serror((byte*)"Readterm?");
    }
    } //SW
;
    L680 :;
    switch ((i64)cc_decls$lx.symbol) {
    case 15:;
        {
            cc_lex$lex();
            q = cc_parse$readexpression();
            cc_lib$skipsymbol((i64)16);
            p = cc_parse$createindexop(p,q);
        }
        break;
    case 2:;
    case 3:;
        {
            opc = (i64)cc_tables$symboltojtag[((i64)cc_decls$lx.symbol)-1];
            cc_lex$lex();
            cc_lib$checksymbol((i64)69);
            d = (struct cc_decls$strec *)cc_decls$lx.symptr;
            cc_lex$lex();
            p = cc_parse$createdotop(opc,p,(struct cc_decls$strec *)d);
        }
        break;
    case 13:;
        {
            cc_lex$lex();
            if (((i64)cc_decls$lx.symbol == (i64)14)) {
                q = 0;
                cc_lex$lex();
            }
            else {
                q = cc_parse$readexprlist(0);
                cc_lib$skipsymbol((i64)14);
            }
;
            p = cc_parse$createcall(p,q);
        }
        break;
    case 37:;
        {
            cc_lex$lex();
            p = cc_parse$createincrop((i64)75,p);
        }
        break;
    case 38:;
        {
            cc_lex$lex();
            p = cc_parse$createincrop((i64)76,p);
        }
        break;
    default: {
        goto L681 ;
    }
    } //SW
goto L680 ;
L681 :;
    ;
    return p;
}

static struct cc_decls$unitrec *cc_parse$readexprlist(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  ulist;
        struct cc_decls$unitrec *  ulistx;
    ulist = (ulistx = p);
    L682 :;
    while (1) {
        p = cc_parse$readassignexpr();
        cc_lib$addlistunit((struct cc_decls$unitrec **)&ulist,(struct cc_decls$unitrec **)&ulistx,(struct cc_decls$unitrec *)p);
        if (((i64)cc_decls$lx.symbol != (i64)8)) {
            goto L683 ;
        }
;
        cc_lex$lex();
    }
L683 :;
    ;
    return ulist;
}

static struct cc_decls$strec *cc_parse$readmodulevar(struct cc_decls$strec *d,i64 m,i64 linkage) {
        struct cc_decls$strec *  e;
        i64 scope;
        i64 emode;
    e = (struct cc_decls$strec *)cc_lib$checkdupl((struct cc_decls$strec *)cc_decls$stmodule,(struct cc_decls$strec *)d,(i64)1,(i64)0);
    if (!!(e)) {
        if (((i64)(*e).nameid != (i64)7)) {
            cc_support$serror_ss((byte*)"var: name in use %s %s",(*e).name,cc_tables$namenames[((i64)(*e).nameid)]);
        }
;
        emode = (i64)(*e).mode;
        if ((emode != m)) {
            if (!(!!(cc_parse$comparemode(emode,m)))) {
                //redef:
L684 :;
;
                cc_support$serror_s((byte*)"var: redefining %s",(*e).name);
            }
;
                        {i64 $temp = cc_decls$ttbasetype[(emode)];
if (($temp==(i64)19)) {
                if ((cc_decls$ttlength[(emode)] == (i64)0)) {
                    (*e).mode = m;
                }
                else if ((!!(cc_decls$ttlength[(m)]) && (cc_decls$ttlength[(emode)] != cc_decls$ttlength[(m)]))) {
                    goto L684 ;
;
                }
;
            }
            };
        }
;
        d = (struct cc_decls$strec *)e;
        scope = (i64)(*d).scope;
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        }
        else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        }
;
    }
    else {
        d = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)cc_decls$stmodule,(struct cc_decls$strec *)d,(!!((i64)cc_parse$constantseen) ? (i64)14 : (i64)7));
        (*d).mode = m;
        if ((linkage==(i64)1)) {
            scope = (i64)2;
        }
        else if ((linkage==(i64)4)) {
            scope = (i64)3;
        }
        else {
            scope = (i64)4;
        }
;
    }
;
    if (((i64)cc_decls$lx.symbol == (i64)11)) {
        if (!!((*d).code)) {
            cc_support$serror_s((byte*)"Can't init twice %s",(*d).name);
        }
;
        if ((scope == (i64)3)) {
            cc_support$serror_s((byte*)"Can't init extern %s",(*d).name);
        }
;
        cc_lex$lex();
        (*d).code = (struct cc_decls$unitrec *)cc_parse$readinitexpr((struct cc_decls$strec *)cc_decls$stmodule,(i64)(*d).mode);
        if (((i64)(*d).nameid == (i64)14)) {
            if (!(((i64)2<=cc_decls$ttbasetype[((i64)(*d).mode)] && cc_decls$ttbasetype[((i64)(*d).mode)]<=(i64)13))) {
                cc_support$serror((byte*)"constant only for int/float");
            }
;
            if (((i64)(*(*d).code).tag != (i64)1)) {
                cc_support$serror((byte*)"constant expr must be constant");
            }
;
        }
;
    }
    else if (!!((i64)cc_parse$constantseen)) {
        cc_support$serror((byte*)"constant must be initialised");
    }
;
    (*d).scope = scope;
    return (struct cc_decls$strec *)d;
}

static struct cc_decls$strec *cc_parse$readframevar(struct cc_decls$strec *d,i64 m,i64 linkage) {
        struct cc_decls$strec *  e;
        i64 scope;
        i64 id;
    e = (struct cc_decls$strec *)cc_lib$checkdupl_inproc((struct cc_decls$strec *)cc_decls$currproc,(struct cc_decls$strec *)d,(i64)1,cc_decls$currblockno);
    if (!!(e)) {
        cc_support$serror_s((byte*)"var: name in use %s",(*e).name);
        d = (struct cc_decls$strec *)e;
        scope = (i64)(*d).scope;
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        }
        else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        }
;
    }
    else {
        id = (i64)8;
        scope = (i64)1;
        if ((linkage==(i64)1)) {
            id = (i64)7;
        }
        else if ((linkage==(i64)4)) {
            scope = (i64)3;
            id = (i64)7;
        }
;
        d = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)cc_decls$currproc,(struct cc_decls$strec *)d,id);
        (*d).mode = m;
        (*d).blockno = cc_decls$currblockno;
        cc_decls$blockcounts[(cc_decls$currblockno)] = (i64)1;
    }
;
    if (((i64)cc_decls$lx.symbol == (i64)11)) {
        if (!!((*d).code)) {
            cc_support$serror_s((byte*)"Can't init twice %s",(*d).name);
        }
;
        if ((scope == (i64)3)) {
            cc_support$serror_s((byte*)"Can't init extern %s",(*d).name);
        }
;
        cc_lex$lex();
        (*d).code = (struct cc_decls$unitrec *)cc_parse$readinitexpr((struct cc_decls$strec *)cc_decls$currproc,(i64)(*d).mode);
    }
;
    (*d).scope = scope;
    return (struct cc_decls$strec *)d;
}

static i64 cc_parse$readtype(struct cc_decls$strec *owner,struct cc_decls$strec **d,i64 m,struct cc_decls$paramrec **pm) {
        i64 modtype[32];
        void *  modvalue[32];
        i64 nmodifiers;
        i64 i;
    nmodifiers = (i64)0;
    (*pm) = 0;
    cc_parse$readnamedtype((struct cc_decls$strec *)owner,d,&modtype,&modvalue,&nmodifiers);
    for (i=nmodifiers;i>=(i64)1;--i) {
L685 :;
                {i64 $temp = modtype[(i)-1];
if (($temp==(i64)65)) {
            m = cc_lib$createarraymode(m,(i64)modvalue[(i)-1]);
        }
        else if (($temp==(i64)82)) {
            m = cc_lib$createrefmode(m);
        }
        else if (($temp==(i64)67)) {
            m = cc_lib$createconstmode(m);
        }
        else if (($temp==(i64)70)) {
            if ((i == (i64)1)) {
                (*pm) = (struct cc_decls$paramrec *)modvalue[((i64)1)-1];
            }
            else {
                m = cc_lib$createprocmode(m,(struct cc_decls$paramrec *)modvalue[(i)-1]);
            }
;
        }
        };
L686 :;
    }
L687 :;
    ;
    return m;
}

static void cc_parse$readnamedtype(struct cc_decls$strec *owner,struct cc_decls$strec **d,i64 (*modtype)[],void *(*modvalue)[],i64 *nmodifiers) {
        i64 length;
        i64 fconst[32];
        i64 nrefs;
        struct cc_decls$unitrec *  pdim;
    (*d) = 0;
    nrefs = (i64)0;
    if (((i64)cc_decls$lx.symbol == (i64)89)) {
        cc_lex$lex();
    }
;
    L688 :;
    while (((i64)cc_decls$lx.symbol == (i64)25)) {
        ++(nrefs);
        fconst[(nrefs)-1] = (i64)0;
        cc_lex$lex();
        L691 :;
        while (((i64)cc_decls$lx.symbol == (i64)88)) {
                        {i64 $temp = (i64)cc_decls$lx.subcode;
if (($temp==(i64)1)) {
                fconst[(nrefs)-1] = (i64)1;
            }
            else if (($temp==(i64)2) || ($temp==(i64)3)) {
            }
            else {
                cc_support$serror((byte*)"rnt1");
            }
            };
            cc_lex$lex();
L692 :;
        }
L693 :;
        ;
L689 :;
    }
L690 :;
    ;
        {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)69)) {
        (*d) = (struct cc_decls$strec *)cc_decls$lx.symptr;
        cc_lex$lex();
    }
    else if (($temp==(i64)13)) {
        cc_lex$lex();
        cc_parse$readnamedtype(owner,d,modtype,modvalue,nmodifiers);
        cc_lib$skipsymbol((i64)14);
    }
    };
    L694 :;
        {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)15)) {
        cc_lex$lex();
        if (((i64)cc_decls$lx.symbol == (i64)16)) {
            length = (i64)0;
        }
        else {
            pdim = cc_parse$readassignexpr();
            if (((i64)(*pdim).tag == (i64)1)) {
                length = (*pdim).value;
            }
            else {
                cc_support$serror((byte*)"Can't do VLAs");
            }
;
            cc_lib$checksymbol((i64)16);
        }
;
        if ((length < (i64)0)) {
            cc_support$terror((byte*)"Negative array dim");
        }
;
        cc_lex$lex();
        (*modtype)[(++((*nmodifiers)))-1] = (i64)65;
        (*modvalue)[((*nmodifiers))-1] = (void *)length;
    }
    else if (($temp==(i64)13)) {
        cc_lex$lex();
        (*modtype)[(++((*nmodifiers)))-1] = (i64)70;
        (*modvalue)[((*nmodifiers))-1] = cc_parse$readparams((struct cc_decls$strec *)owner);
    }
    else {
        goto L695 ;
    }
    }goto L694 ;
L695 :;
    ;
    L696 :;
    while (!!(nrefs)) {
        if (!!(fconst[(nrefs)-1])) {
            (*modtype)[(++((*nmodifiers)))-1] = (i64)67;
        }
;
        (*modtype)[(++((*nmodifiers)))-1] = (i64)82;
        --(nrefs);
L697 :;
    }
L698 :;
    ;
}

static i64 cc_parse$readconstintexpr(void) {
        struct cc_decls$unitrec *  p;
    p = cc_parse$readassignexpr();
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        return (*p).value;
    }
    else {
        cc_support$serror_s((byte*)"readconstint %s",cc_tables$jtagnames[((i64)(*p).tag)]);
    }
    };
    return (i64)0;
}

static struct cc_decls$unitrec *cc_parse$readinitexpr(struct cc_decls$strec *owner,i64 m) {
        struct cc_decls$unitrec *  p;
    p = cc_parse$readinitexpr2((struct cc_decls$strec *)owner,m,(i64)1);
    return p;
}

static struct cc_decls$unitrec *cc_parse$readinitexpr2(struct cc_decls$strec *owner,i64 m,i64 istop) {
        struct cc_decls$unitrec *  ulist;
        struct cc_decls$unitrec *  ulistx;
        struct cc_decls$unitrec *  p;
        i64 mbase;
        i64 melem;
        i64 mm;
        i64 dim;
        i64 count;
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  e;
        i64 braces;
    mbase = cc_decls$ttbasetype[(m)];
    count = (i64)0;
    if (((i64)cc_decls$lx.symbol == (i64)17)) {
        cc_lex$lex();
        count = (i64)0;
        if ((mbase==(i64)19)) {
            dim = cc_decls$ttlength[(m)];
            if ((!(!!(istop)) && (dim == (i64)0))) {
                cc_support$terror((byte*)"init/0-size array");
            }
;
            melem = cc_decls$tttarget[(m)];
            if (((cc_decls$ttbasetype[(melem)] == (i64)7) && ((i64)cc_decls$lx.symbol == (i64)64))) {
                braces = (i64)1;
                goto L699 ;
;
            }
;
        }
        else if ((mbase==(i64)20) || (mbase==(i64)21)) {
            d = (struct cc_decls$strec *)cc_decls$ttnamedef[(m)];
            e = (struct cc_decls$strec *)(*d).deflist;
            if ((e == 0)) {
                cc_support$terror((byte*)"init/Empty struct");
            }
;
            melem = (i64)(*e).mode;
        }
        else {
            p = cc_parse$readassignexpr();
            p = cc_parse$coercemode(p,m);
            cc_lib$skipsymbol((i64)18);
            return p;
        }
;
        ulist = (ulistx = 0);
        L700 :;
        while (1) {
            p = cc_parse$readinitexpr2(owner,melem,(i64)0);
            ++(count);
            if ((mbase==(i64)19)) {
                if ((!!(dim) && (count > dim))) {
                    cc_support$terror((byte*)"Too many array elems");
                }
;
                if ((((cc_decls$ttbasetype[(melem)] == (i64)19) && (cc_decls$ttbasetype[(cc_decls$tttarget[(melem)])] == (i64)7)) && ((i64)(*p).mode == cc_decls$trefchar))) {
                }
                else {
                    p = cc_parse$coercemode(p,melem);
                }
;
            }
            else if ((mbase==(i64)20)) {
                mm = (i64)(*e).mode;
                if ((((cc_decls$ttbasetype[(mm)] == (i64)19) && (cc_decls$ttbasetype[(cc_decls$tttarget[(mm)])] == (i64)7)) && ((i64)(*p).mode == cc_decls$trefchar))) {
                }
                else {
                    p = cc_parse$coercemode(p,mm);
                }
;
                e = (struct cc_decls$strec *)(*e).nextdef;
                if ((e == 0)) {
                    if ((((i64)cc_decls$lx.symbol == (i64)8) && ((i64)cc_decls$nextlx.symbol != (i64)18))) {
                        cc_support$terror((byte*)"Too many struct elems");
                    }
;
                }
                else {
                    melem = (i64)(*e).mode;
                }
;
            }
            else if ((mbase==(i64)21)) {
                p = cc_parse$coercemode(p,melem);
                ulist = (ulistx = p);
                goto L702 ;
;
            }
;
            cc_lib$addlistunit((struct cc_decls$unitrec **)&ulist,(struct cc_decls$unitrec **)&ulistx,(struct cc_decls$unitrec *)p);
            if (((i64)cc_decls$lx.symbol != (i64)8)) {
                goto L701 ;
            }
;
            if (((i64)cc_decls$nextlx.symbol == (i64)18)) {
                cc_lex$lex();
                goto L701 ;
            }
;
            cc_lex$lex();
        }
L701 :;
        ;
        if (((mbase == (i64)19) && (dim == (i64)0))) {
            cc_decls$ttlength[(m)] = count;
            cc_decls$ttsize[(m)] = (count * cc_decls$ttsize[(melem)]);
        }
;
        //donestruct:
L702 :;
;
        cc_lib$skipsymbol((i64)18);
        p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)29,(struct cc_decls$unitrec *)ulist);
        (*p).count = count;
        (*p).mode = m;
    }
    else {
        braces = (i64)0;
        if ((mbase==(i64)19)) {
            //doarraystring:
L699 :;
;
            if ((((((i64)cc_decls$lx.symbol != (i64)64) && ((i64)cc_decls$lx.symbol != (i64)65)) && ((i64)cc_decls$lx.symbol != (i64)68)) && (cc_decls$tttarget[(m)] != (i64)7))) {
                cc_support$terror((byte*)"{} initialiser expected");
            }
;
            p = cc_parse$readassignexpr();
            if (((i64)(*p).tag == (i64)1)) {
                (*p).strarray = (i64)1;
            }
;
                        {i64 $temp = (i64)(*p).mode;
if (($temp==cc_decls$trefchar)) {
            }
            else if (($temp==cc_decls$trefwchar)) {
            }
            else {
                cc_support$terror((byte*)"Array init");
            }
            };
            (*p).mode = m;
            if (((dim = cc_decls$ttlength[(m)]) == (i64)0)) {
                cc_decls$ttlength[(m)] = (cc_decls$ttsize[(m)] = ((i64)(*p).slength + (i64)1));
            }
            else {
                if (((i64)(*p).slength > dim)) {
                    cc_support$terror((byte*)"Init str too long");
                }
;
            }
;
            if (!!(braces)) {
                cc_lib$skipsymbol((i64)18);
            }
;
            return p;
        }
;
        p = cc_parse$readassignexpr();
        p = cc_parse$coercemode(p,m);
    }
;
    return p;
}

static void cc_parse$pushblock(void) {
        i64 n;
        i64 m;
    if ((cc_decls$blocklevel >= (i64)100)) {
        cc_support$serror((byte*)"Too many block levels");
    }
;
    if ((cc_decls$nextblockno >= (i64)2100)) {
        cc_support$serror((byte*)"Too many blocks");
    }
;
    ++(cc_decls$blocklevel);
    ++(cc_decls$nextblockno);
    n = cc_decls$currblockno;
    m = cc_decls$blocklevel;
    L703 :;
    while ((!!(m) && ((i64)cc_decls$blockcounts[((i64)cc_decls$blockstack[(m)])] == (i64)0))) {
        --(m);
        n = (i64)cc_decls$blockstack[(m)];
L704 :;
    }
L705 :;
    ;
    cc_decls$blockowner[(cc_decls$nextblockno)] = n;
    cc_decls$currblockno = (cc_decls$blockstack[(cc_decls$blocklevel)] = cc_decls$nextblockno);
    cc_decls$blockcounts[(cc_decls$currblockno)] = (i64)0;
}

static void cc_parse$popblock(void) {
    cc_decls$currblockno = (i64)cc_decls$blockstack[(--(cc_decls$blocklevel))];
}

static struct cc_decls$unitrec *cc_parse$readcompoundstmt(i64 params) {
        struct cc_decls$unitrec *  ulist;
        struct cc_decls$unitrec *  ulistx;
        struct cc_decls$unitrec *  p;
        struct cc_decls$unitrec *  q;
    ulist = (ulistx = 0);
    cc_lex$lex();
    cc_parse$pushblock();
    if (!!(params)) {
        cc_decls$blockcounts[((i64)1)] = (i64)1;
    }
;
    L706 :;
    while (((i64)cc_decls$lx.symbol != (i64)18)) {
        p = cc_parse$readstatement();
        if ((p == 0)) {
            goto L707 ;
        }
;
        if (((i64)(*p).tag == (i64)7)) {
            L709 :;
            do {
                q = (struct cc_decls$unitrec *)(*p).nextunit;
                if ((!!((*(*p).def).code) && ((i64)(*(*p).def).nameid != (i64)7))) {
                    (*p).tag = (i64)8;
                    (*p).nextunit = 0;
                    cc_lib$addlistunit((struct cc_decls$unitrec **)&ulist,(struct cc_decls$unitrec **)&ulistx,(struct cc_decls$unitrec *)p);
                }
;
                p = q;
L710 :;
            }
            while (!(p == 0));
L711 :;
            ;
        }
        else {
            cc_lib$addlistunit((struct cc_decls$unitrec **)&ulist,(struct cc_decls$unitrec **)&ulistx,(struct cc_decls$unitrec *)p);
        }
;
L707 :;
    }
L708 :;
    ;
    cc_lex$lex();
    cc_parse$popblock();
    return (struct cc_decls$unitrec *)cc_lib$createunit3((i64)6,(struct cc_decls$unitrec *)ulist,0,(struct cc_decls$unitrec *)ulistx);
}

static struct cc_decls$unitrec *cc_parse$readblock(i64 ifelse) {
    if ((u64)1u) {
        return cc_parse$readstatement();
    }
;
    if ((((i64)cc_decls$lx.symbol == (i64)73) && !!(ifelse))) {
        return cc_parse$readstatement();
    }
;
    if (((i64)cc_decls$lx.symbol != (i64)17)) {
        cc_support$serror((byte*)"{...} statement expected");
    }
;
    return cc_parse$readcompoundstmt((i64)0);
}

static struct cc_decls$unitrec *cc_parse$readstatement(void) {
        struct cc_decls$unitrec *  p;
        struct mlib$strbuffer *  ss;
        struct cc_decls$strec *  d;
        i64 index;
    switch ((i64)cc_decls$lx.symbol) {
    case 73:;
        {
            return cc_parse$readifstmt();
        }
        break;
    case 77:;
        {
            return cc_parse$readforstmt();
        }
        break;
    case 78:;
        {
            return cc_parse$readwhilestmt();
        }
        break;
    case 79:;
        {
            return cc_parse$readdostmt();
        }
        break;
    case 80:;
        {
            return cc_parse$readreturnstmt();
        }
        break;
    case 84:;
        {
            return cc_parse$readswitchstmt();
        }
        break;
    case 17:;
        {
            return cc_parse$readcompoundstmt((i64)0);
        }
        break;
    case 83:;
        {
            return cc_parse$readgotostmt();
        }
        break;
    case 81:;
        {
            if (!!(cc_parse$loopindex)) {
                if (((i64)cc_parse$looptypestack[(cc_parse$loopindex)-1] == (i64)76)) {
                    p = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)21);
                    cc_lex$lex();
                }
                else {
                    p = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)24);
                    cc_lex$lex();
                }
;
            }
            else {
                cc_support$serror((byte*)"break outside loop/sw");
            }
;
        }
        break;
    case 82:;
        {
            index = cc_parse$loopindex;
            L712 :;
            while ((!!(index) && ((i64)cc_parse$looptypestack[(index)-1] != (i64)76))) {
                --(index);
L713 :;
            }
L714 :;
            ;
            if ((index == (i64)0)) {
                cc_support$serror((byte*)"continue outside loop");
            }
;
            p = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)22);
            cc_lex$lex();
        }
        break;
    case 75:;
        {
            return cc_parse$readcaselabel();
        }
        break;
    case 76:;
        {
            cc_lex$lex();
            cc_lib$skipsymbol((i64)10);
            return (struct cc_decls$unitrec *)cc_lib$createunit1((i64)20,(struct cc_decls$unitrec *)cc_parse$readstatement());
        }
        break;
    case 97:;
        {
            cc_lex$lex();
            p = cc_parse$readexpression();
            ss = (struct mlib$strbuffer *)cc_lib$strexpr((struct cc_decls$unitrec *)p);
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Mode is:",NULL);
            msysc$m_print_str((*ss).strptr,NULL);
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_str(cc_lib$strmode((i64)(*p).mode,(i64)1),NULL);
            msysc$m_print_str((byte*)"\ton line",NULL);
            msysc$m_print_i64((i64)cc_decls$lx.lineno,NULL);
            msysc$m_print_str((byte*)"Size is",NULL);
            msysc$m_print_i64(cc_decls$ttsize[((i64)(*p).mode)],NULL);
            msysc$m_print_end();
            ;
            if (!!((i64)cc_decls$ttisref[((i64)(*p).mode)])) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)" target size",NULL);
                msysc$m_print_i64(cc_decls$ttsize[(cc_decls$tttarget[((i64)(*p).mode)])],NULL);
                msysc$m_print_end();
                ;
            }
;
            msysc$m_print_startcon();
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        break;
    case 101:;
        {
            cc_parse$dostaticassert();
        }
        break;
    case 9:;
        {
            cc_lex$lex();
            return 0;
        }
        break;
    case 69:;
        {
            if (((i64)cc_decls$nextlx.symbol == (i64)10)) {
                p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)18,0);
                d = (struct cc_decls$strec *)cc_lib$resolvename((struct cc_decls$strec *)cc_decls$currproc,(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)3,(i64)0);
                if (!!(d)) {
                    if (!!((i64)(*d).index)) {
                        msysc$m_print_startcon();
                        msysc$m_print_str((*cc_decls$lx.symptr).name,NULL);
                        msysc$m_print_newline();
                        msysc$m_print_end();
                        ;
                        cc_support$terror((byte*)"Duplicate label");
                    }
                    else {
                        (*d).index = ++(cc_decls$labelno);
                    }
;
                }
                else {
                    d = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)cc_decls$currproc,(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)15);
                    (*d).mode = (i64)1;
                    (*d).index = ++(cc_decls$labelno);
                }
;
                (*p).def = (struct cc_decls$strec *)d;
                cc_lex$lex();
                cc_lex$lex();
                if (((i64)cc_decls$lx.symbol == (i64)18)) {
                }
                else if ((!!(cc_parse$istypestarter()) || ((i64)cc_decls$lx.symbol == (i64)87))) {
                }
                else {
                    (*p).a = (struct cc_decls$unitrec *)cc_parse$readstatement();
                }
;
                return p;
            }
            else {
                cc_parse$ist_symptr = 0;
                if (!!(cc_parse$isusertype((struct cc_decls$strec *)cc_decls$currproc))) {
                    goto L715 ;
;
                }
;
                if (!!(cc_parse$ist_symptr)) {
                    cc_decls$lx.symptr = (struct cc_decls$strec *)cc_parse$ist_symptr;
                }
;
                p = cc_parse$readexpression();
            }
;
        }
        break;
    case 72:;
    case 88:;
    case 87:;
    case 89:;
    case 85:;
    case 86:;
    case 91:;
    case 99:;
        {
            //doreaddecl:
L715 :;
;
            return cc_parse$readlocaldecl();
            cc_parse$constantseen = (i64)0;
        }
        break;
    default: {
        p = cc_parse$readexpression();
    }
    } //SW
;
    cc_lib$skipsymbol((i64)9);
    return p;
}

static struct cc_decls$unitrec *cc_parse$readifstmt(void) {
        struct cc_decls$unitrec *  pcond;
        struct cc_decls$unitrec *  pbody;
        struct cc_decls$unitrec *  pelse;
    cc_lex$lex();
    pcond = cc_parse$readcond();
    cc_parse$coercecond(pcond);
    pbody = cc_parse$readblock((i64)0);
    pelse = 0;
    if (((i64)cc_decls$lx.symbol == (i64)74)) {
        cc_lex$lex();
        pelse = cc_parse$readblock((i64)1);
    }
;
    return (struct cc_decls$unitrec *)cc_lib$createunit3((i64)13,(struct cc_decls$unitrec *)pcond,(struct cc_decls$unitrec *)pbody,(struct cc_decls$unitrec *)pelse);
}

static struct cc_decls$unitrec *cc_parse$readforstmt(void) {
        struct cc_decls$unitrec *  pinit;
        struct cc_decls$unitrec *  pcond;
        struct cc_decls$unitrec *  pincr;
        struct cc_decls$unitrec *  pbody;
        struct cc_decls$unitrec *  ulist;
        struct cc_decls$unitrec *  ulistx;
        struct cc_decls$unitrec *  p;
        i64 linkage;
        i64 hasblock;
        i64 m;
        i64 mbase;
        struct cc_decls$paramrec *  pm;
        struct cc_decls$strec *  d;
    cc_lex$lex();
    cc_lib$skipsymbol((i64)13);
    hasblock = (i64)0;
    if (((i64)cc_decls$lx.symbol != (i64)9)) {
        if (!!(cc_parse$istypestarter())) {
            hasblock = (i64)1;
            cc_parse$pushblock();
            mbase = cc_parse$readdeclspec((struct cc_decls$strec *)cc_decls$currproc,&linkage);
            ulist = (ulistx = 0);
            L716 :;
                        {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)69) || ($temp==(i64)25) || ($temp==(i64)13)) {
                m = cc_parse$readtype((struct cc_decls$strec *)cc_decls$currproc,&d,mbase,&pm);
                if ((d == 0)) {
                    cc_support$serror((byte*)"Var name expected");
                }
;
                if (((linkage == (i64)5) || !!(pm))) {
                    cc_support$serror((byte*)"Not allowed in for stmt");
                }
;
                cc_parse$insidefor = (i64)1;
                d = (struct cc_decls$strec *)cc_parse$readframevar((struct cc_decls$strec *)d,m,linkage);
                cc_parse$insidefor = (i64)0;
                if (!!((*d).code)) {
                    p = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)8);
                    (*p).def = (struct cc_decls$strec *)d;
                    cc_lib$addlistunit((struct cc_decls$unitrec **)&ulist,(struct cc_decls$unitrec **)&ulistx,(struct cc_decls$unitrec *)p);
                }
;
                                {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)8)) {
                    cc_lex$lex();
                }
                else {
                    goto L717 ;
                }
                };
            }
            else {
                cc_support$serror((byte*)"For decl error");
            }
            }goto L716 ;
L717 :;
            ;
            pinit = (struct cc_decls$unitrec *)cc_lib$createunit3((i64)6,(struct cc_decls$unitrec *)ulist,0,(struct cc_decls$unitrec *)ulistx);
        }
        else {
            pinit = cc_parse$readexpression();
        }
;
    }
    else {
        pinit = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)2);
    }
;
    cc_lib$skipsymbol((i64)9);
    if (((i64)cc_decls$lx.symbol != (i64)9)) {
        pcond = cc_parse$readexpression();
        cc_parse$coercecond(pcond);
    }
    else {
        pcond = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)2);
    }
;
    cc_lib$skipsymbol((i64)9);
    if (((i64)cc_decls$lx.symbol != (i64)14)) {
        pincr = cc_parse$readexprstmt();
    }
    else {
        pincr = 0;
    }
;
    cc_lib$skipsymbol((i64)14);
    cc_parse$pushloop((i64)76);
    pbody = cc_parse$readblock((i64)0);
    cc_parse$poploop();
    if (!!(hasblock)) {
        cc_parse$popblock();
    }
;
    (*pinit).nextunit = (struct cc_decls$unitrec *)pcond;
    (*pcond).nextunit = (struct cc_decls$unitrec *)pincr;
    return (struct cc_decls$unitrec *)cc_lib$createunit2((i64)14,(struct cc_decls$unitrec *)pinit,(struct cc_decls$unitrec *)pbody);
}

static struct cc_decls$unitrec *cc_parse$readwhilestmt(void) {
        struct cc_decls$unitrec *  pcond;
        struct cc_decls$unitrec *  pbody;
    cc_lex$lex();
    pcond = cc_parse$readcond();
    cc_parse$coercecond(pcond);
    cc_parse$pushloop((i64)76);
    pbody = cc_parse$readblock((i64)0);
    cc_parse$poploop();
    return (struct cc_decls$unitrec *)cc_lib$createunit2((i64)15,(struct cc_decls$unitrec *)pcond,(struct cc_decls$unitrec *)pbody);
}

static struct cc_decls$unitrec *cc_parse$readdostmt(void) {
        struct cc_decls$unitrec *  pbody;
        struct cc_decls$unitrec *  pcond;
    cc_lex$lex();
    cc_parse$pushloop((i64)76);
    pbody = cc_parse$readblock((i64)0);
    cc_parse$poploop();
    cc_lib$skipsymbol((i64)78);
    pcond = cc_parse$readcond();
    cc_parse$coercecond(pcond);
    cc_lib$skipsymbol((i64)9);
    return (struct cc_decls$unitrec *)cc_lib$createunit2((i64)16,(struct cc_decls$unitrec *)pbody,(struct cc_decls$unitrec *)pcond);
}

static struct cc_decls$unitrec *cc_parse$readreturnstmt(void) {
        struct cc_decls$unitrec *  p;
    cc_lex$lex();
    p = 0;
    if (((i64)cc_decls$lx.symbol != (i64)9)) {
        if (((i64)(*cc_decls$currproc).mode == (i64)1)) {
            cc_support$terror((byte*)"Can't return value in void function");
        }
;
        p = cc_parse$readexpression();
        p = cc_parse$coercemode(p,(i64)(*cc_decls$currproc).mode);
        cc_lib$checksymbol((i64)9);
    }
    else if (((i64)(*cc_decls$currproc).mode != (i64)1)) {
        cc_support$terror((byte*)"Return value needed");
    }
;
    cc_lex$lex();
    return (struct cc_decls$unitrec *)cc_lib$createunit1((i64)10,(struct cc_decls$unitrec *)p);
}

static struct cc_decls$unitrec *cc_parse$readgotostmt(void) {
        struct cc_decls$strec *  d;
        struct cc_decls$unitrec *  p;
    cc_lex$lex();
    cc_lib$checksymbol((i64)69);
    d = (struct cc_decls$strec *)cc_lib$resolvename((struct cc_decls$strec *)cc_decls$currproc,(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)3,(i64)0);
    if ((d == 0)) {
        d = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)cc_decls$currproc,(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)15);
        (*d).mode = (i64)1;
    }
;
    p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)17,0);
    (*p).def = (struct cc_decls$strec *)d;
    cc_lex$lex();
    cc_lib$skipsymbol((i64)9);
    return p;
}

static struct cc_decls$unitrec *cc_parse$readswitchstmt(void) {
        struct cc_decls$unitrec *  pindex;
        struct cc_decls$unitrec *  pstmt;
        struct cc_decls$unitrec *  p;
    cc_lex$lex();
    pindex = cc_parse$readcond();
    cc_parse$coercemode(pindex,(i64)4);
    cc_parse$pushloop((i64)83);
    pstmt = cc_parse$readblock((i64)0);
    p = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)23,(struct cc_decls$unitrec *)pindex,(struct cc_decls$unitrec *)pstmt);
    (*p).nextcase = (struct cc_decls$caserec *)cc_parse$casevaluestack[(cc_parse$loopindex)-1];
    cc_parse$poploop();
    return p;
}

static struct cc_decls$unitrec *cc_parse$readcaselabel(void) {
        struct cc_decls$unitrec *  p;
        i64 value;
    cc_lex$lex();
    value = cc_parse$readconstintexpr();
    cc_lib$skipsymbol((i64)10);
    p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)19,(struct cc_decls$unitrec *)cc_parse$readstatement());
    (*p).value = value;
    cc_parse$addcasevalue(value);
    return p;
}

static struct cc_decls$unitrec *cc_parse$readexprstmt(void) {
    return cc_parse$readexpression();
}

static struct cc_decls$unitrec *cc_parse$readcond(void) {
        struct cc_decls$unitrec *  pcond;
    cc_lib$skipsymbol((i64)13);
    pcond = cc_parse$readexpression();
    cc_lib$skipsymbol((i64)14);
    return pcond;
}

static i64 cc_parse$isusertype(struct cc_decls$strec *owner) {
        struct cc_decls$strec *  d;
    d = (struct cc_decls$strec *)cc_lib$resolvename((struct cc_decls$strec *)owner,(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)1,cc_decls$currblockno);
    if (!!(d)) {
        if (((i64)(*d).nameid == (i64)5)) {
            return (i64)(*d).mode;
        }
;
        cc_parse$ist_symptr = (struct cc_decls$strec *)d;
    }
;
    return (i64)0;
}

static struct cc_decls$unitrec *cc_parse$readlocaldecl(void) {
        i64 m;
        i64 mbase;
        i64 linkage;
        i64 nitems;
        i64 wasenum;
        i64 wasdef;
        struct cc_decls$strec *  d;
        struct cc_decls$unitrec *  ulist;
        struct cc_decls$unitrec *  ulistx;
        struct cc_decls$unitrec *  p;
        struct cc_decls$paramrec *  pm;
    ulist = (ulistx = 0);
    wasenum = (i64)cc_decls$lx.symbol;
    mbase = cc_parse$readdeclspec((struct cc_decls$strec *)cc_decls$currproc,&linkage);
    nitems = (i64)0;
    L718 :;
        {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)69) || ($temp==(i64)25) || ($temp==(i64)13)) {
        ++(nitems);
        m = cc_parse$readtype((struct cc_decls$strec *)cc_decls$currproc,&d,mbase,&pm);
        if ((d == 0)) {
            cc_support$serror((byte*)"Var name expected");
        }
;
        if ((linkage == (i64)5)) {
            d = (struct cc_decls$strec *)cc_parse$createtypedef((struct cc_decls$strec *)cc_decls$currproc,(struct cc_decls$strec *)d,m);
        }
        else if (!!(pm)) {
            if (((i64)cc_decls$lx.symbol == (i64)17)) {
                cc_support$serror((byte*)"Nested function");
            }
;
            d = (struct cc_decls$strec *)cc_parse$readfunction((struct cc_decls$strec *)d,m,linkage,(struct cc_decls$paramrec *)pm,&wasdef);
        }
        else {
            d = (struct cc_decls$strec *)cc_parse$readframevar((struct cc_decls$strec *)d,m,linkage);
            p = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)7);
            (*p).def = (struct cc_decls$strec *)d;
            cc_lib$addlistunit((struct cc_decls$unitrec **)&ulist,(struct cc_decls$unitrec **)&ulistx,(struct cc_decls$unitrec *)p);
        }
;
                {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)8)) {
            cc_lex$lex();
        }
        else {
            cc_lib$skipsymbol((i64)9);
            goto L719 ;
        }
        };
    }
    else {
                {i64 $temp = cc_decls$ttbasetype[(mbase)];
if (($temp==(i64)15) || ($temp==(i64)20) || ($temp==(i64)21)) {
            cc_lib$skipsymbol((i64)9);
            goto L719 ;
        }
        else if (($temp==(i64)4)) {
            cc_lib$skipsymbol((i64)9);
            goto L719 ;
        }
        else {
            cc_support$serror_s((byte*)"Local decl error %s",cc_lib$typename(m));
        }
        };
    }
    }goto L718 ;
L719 :;
    ;
    if (((nitems == (i64)0) && !!(cc_decls$fmodern))) {
                {i64 $temp = cc_decls$ttbasetype[(mbase)];
if (($temp==(i64)20) || ($temp==(i64)21) || ($temp==(i64)15)) {
        }
        else {
            if ((wasenum != (i64)91)) {
                cc_support$serror((byte*)"Empty local declaration");
            }
;
        }
        };
    }
;
    return ulist;
}

static struct cc_decls$strec *cc_parse$createtypedef(struct cc_decls$strec *owner,struct cc_decls$strec *symptr,i64 mode) {
        struct cc_decls$strec *  d;
    d = (struct cc_decls$strec *)cc_lib$checkdupl((struct cc_decls$strec *)owner,(struct cc_decls$strec *)symptr,(i64)1,cc_decls$currblockno);
    if (!!(d)) {
        if (((i64)(*d).nameid != (i64)5)) {
            cc_support$serror_s((byte*)"Typedef name in use %s",(*d).name);
        }
;
        if (((i64)(*d).mode != mode)) {
            if (!(!!(cc_parse$comparemode((i64)(*d).mode,mode)))) {
                cc_support$serror_s((byte*)"Typedef redefined or can't match types %s",(*d).name);
            }
;
        }
;
        return (struct cc_decls$strec *)d;
    }
;
    d = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)owner,(struct cc_decls$strec *)symptr,(i64)5);
    (*d).mode = mode;
    cc_decls$tttypedef[(mode)] = (struct cc_decls$strec *)d;
    (*d).blockno = cc_decls$currblockno;
    cc_decls$blockcounts[(cc_decls$currblockno)] = (i64)1;
    return (struct cc_decls$strec *)d;
}

static struct cc_decls$paramrec *cc_parse$readparams(struct cc_decls$strec *owner) {
        struct cc_decls$paramrec *  ulist;
        struct cc_decls$paramrec *  ulistx;
        struct cc_decls$paramrec *  pm;
        struct cc_decls$paramrec *  q;
        i64 m;
        i64 lastbasetype;
        i64 nparams;
        i64 variadic;
        i64 flags;
        i64 nnames;
        struct cc_decls$strec *  d;
        i64 names;
        i64 nonames;
        i64 reported;
    ulist = (ulistx = 0);
    variadic = (nparams = (nnames = (i64)0));
    if (!!(cc_decls$callbackflag)) {
        cc_parse$iscallbackfnx = (i64)1;
        cc_decls$callbackflag = (i64)0;
    }
;
    lastbasetype = (i64)1;
    names = (i64)0;
    nonames = (i64)0;
    reported = (i64)0;
    ++(cc_decls$nallprocs);
    L720 :;
    while (((i64)cc_decls$lx.symbol != (i64)14)) {
        if (((i64)cc_decls$lx.symbol == (i64)21)) {
            variadic = (i64)1;
            cc_lex$lex();
            goto L722 ;
        }
;
        if (!!(cc_parse$istypestarter())) {
            m = cc_parse$readcasttype(&d,(i64)1,&pm,(i64)1,&lastbasetype);
            if (!!(pm)) {
                m = cc_lib$createrefmode(cc_lib$createprocmode(m,(struct cc_decls$paramrec *)pm));
            }
;
        }
        else {
            if ((lastbasetype == (i64)1)) {
                cc_support$serror((byte*)"Param type missing or misspelt");
            }
;
            m = cc_parse$readcasttype(&d,(i64)1,&pm,lastbasetype,0);
        }
;
                {i64 $temp = cc_decls$ttbasetype[(m)];
if (($temp==(i64)19)) {
            m = cc_lib$createrefmode(cc_decls$tttarget[(m)]);
        }
        else if (($temp==(i64)17)) {
            m = cc_lib$createrefmode(cc_lib$createprocmode(m,(struct cc_decls$paramrec *)cc_decls$ttparams[(m)]));
        }
        };
        pm = (struct cc_decls$paramrec *)mlib$pcm_allocz((i64)24);
        (*pm).def = (struct cc_decls$strec *)d;
        (*pm).mode = m;
        ++(nparams);
        if (!!(d)) {
            names = (i64)1;
        }
        else {
            nonames = (i64)1;
        }
;
        if (((!!(names) && !!(nonames)) && !(!!(reported)))) {
            ++(cc_decls$nmixed);
            reported = (i64)1;
        }
;
        if (!!(d)) {
            ++(nnames);
            q = ulist;
            L723 :;
            while (!!(q)) {
                if (((*q).def == d)) {
                    cc_support$serror_ss((byte*)"Param name reused %s %s",(*d).name,cc_tables$namenames[((i64)(*d).nameid)]);
                }
;
                q = (struct cc_decls$paramrec *)(*q).nextparam;
L724 :;
            }
L725 :;
            ;
        }
;
        cc_lib$addlistparam((struct cc_decls$paramrec **)&ulist,(struct cc_decls$paramrec **)&ulistx,(struct cc_decls$paramrec *)pm);
                {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)8)) {
            cc_lex$lex();
        }
        else if (($temp==(i64)21) || ($temp==(i64)14)) {
        }
        else {
            cc_support$serror((byte*)"bad symbol in paramlist");
        }
        };
L721 :;
    }
L722 :;
    ;
    flags = (i64)0;
    cc_lib$skipsymbol((i64)14);
    if (!!(variadic)) {
        flags = (i64)3;
    }
    else if ((nparams == (i64)0)) {
        if (!!(cc_decls$fmodern)) {
            cc_support$terror((byte*)"() Params not allowed");
        }
        else {
            flags = (i64)1;
        }
;
    }
    else if (((nparams == (i64)1) && (m == (i64)1))) {
        flags = (i64)2;
        nparams = (i64)0;
        (*ulist).mode = (i64)0;
    }
;
    if ((ulist == 0)) {
        ulist = (struct cc_decls$paramrec *)mlib$pcm_allocz((i64)24);
    }
;
    (*ulist).nparams = nparams;
    (*ulist).flags = flags;
    return (struct cc_decls$paramrec *)ulist;
}

static i64 cc_parse$readcasttype(struct cc_decls$strec **d,i64 allowname,struct cc_decls$paramrec **pm,i64 m,i64 *mbase) {
        struct cc_decls$strec *  owner;
        i64 linkage;
    owner = (struct cc_decls$strec *)(!!(cc_decls$currproc) ? cc_decls$currproc : cc_decls$stmodule);
    linkage = (i64)0;
    (*d) = 0;
    if ((m == (i64)1)) {
        m = cc_parse$readdeclspec((struct cc_decls$strec *)owner,&linkage);
        if (!!(mbase)) {
            (*mbase) = m;
        }
;
    }
;
    (*pm) = 0;
        {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)69) || ($temp==(i64)25) || ($temp==(i64)13) || ($temp==(i64)15)) {
        m = cc_parse$readtype((struct cc_decls$strec *)owner,d,m,pm);
        if ((!!((*d)) && !(!!(allowname)))) {
            cc_support$serror_s((byte*)"NAME not allowed in cast type %s",(*(*d)).name);
        }
;
    }
    };
    return m;
}

static struct cc_decls$strec *cc_parse$readfunction(struct cc_decls$strec *d,i64 m,i64 linkage,struct cc_decls$paramrec *pm,i64 *wasdef) {
        struct cc_decls$strec *  f;
        struct cc_decls$strec *  owner;
        i64 scope;
        i64 line;
    line = (i64)cc_decls$lx.lineno;
    owner = (struct cc_decls$strec *)cc_decls$stmodule;
    (*wasdef) = (i64)0;
    f = (struct cc_decls$strec *)cc_lib$checkdupl((struct cc_decls$strec *)owner,(struct cc_decls$strec *)d,(i64)1,(i64)0);
    if (!!(f)) {
        if (((i64)(*f).nameid != (i64)6)) {
            cc_support$serror_s((byte*)"fn: name in use %s",(*d).name);
        }
;
        d = (struct cc_decls$strec *)f;
        scope = (i64)(*d).scope;
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        }
        else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        }
;
    }
    else {
        d = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)owner,(struct cc_decls$strec *)d,(i64)6);
        (*d).mode = m;
        if ((linkage==(i64)1)) {
            scope = (i64)2;
        }
        else if ((linkage==(i64)4)) {
            scope = (i64)3;
        }
        else {
            scope = (i64)4;
        }
;
    }
;
    if ((!!((i64)cc_parse$iscallbackfnx) || !!(cc_decls$fcallback))) {
        (*d).attribs.ax_callback = (i64)1;
        cc_parse$iscallbackfnx = (i64)0;
    }
;
    (*d).paramlist = (struct cc_decls$paramrec *)pm;
    (*d).scope = scope;
    if (((i64)cc_decls$lx.symbol == (i64)17)) {
        (*wasdef) = (i64)1;
        if (!!((*d).code)) {
            cc_support$serror_s((byte*)"Can't define function twice %s",(*d).name);
        }
;
        if ((scope == (i64)3)) {
        }
;
        cc_parse$readfunctionbody((struct cc_decls$strec *)d);
        if (((i64)cc_decls$lx.symbol == (i64)9)) {
            cc_support$serror((byte*)"; after function def");
        }
;
    }
;
    return (struct cc_decls$strec *)d;
}

static struct cc_decls$strec *cc_parse$getbasesymbol(struct cc_decls$strec *e) {
    L726 :;
    while (!!((*e).prevdupl)) {
        e = (struct cc_decls$strec *)(*e).prevdupl;
L727 :;
    }
L728 :;
    ;
    return (struct cc_decls$strec *)e;
}

static void cc_parse$readfunctionbody(struct cc_decls$strec *f) {
        struct cc_decls$strec *  e;
        struct cc_decls$unitrec *  p;
        struct cc_decls$paramrec *  pm;
        i64 pmcount;
        i64 $av_1;
    cc_decls$currproc = (struct cc_decls$strec *)f;
    cc_decls$nextblockno = (cc_decls$currblockno = (i64)0);
    pmcount = (i64)0;
    pm = (struct cc_decls$paramrec *)(*f).paramlist;
    $av_1 = (i64)(*pm).nparams;
    while ($av_1-- > 0) {
L729 :;
        if (((*pm).def == 0)) {
        }
        else {
            e = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)f,(struct cc_decls$strec *)(*pm).def,(i64)9);
            (*e).blockno = (i64)1;
            (*e).mode = (i64)(*pm).mode;
        }
;
        pm = (struct cc_decls$paramrec *)(*pm).nextparam;
        pmcount = (i64)1;
L730 :;
    }
L731 :;
    ;
    p = cc_parse$readcompoundstmt(pmcount);
    (*cc_decls$currproc).code = (struct cc_decls$unitrec *)p;
    cc_decls$currproc = 0;
}

static struct cc_decls$unitrec *cc_parse$createnegop(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
    t = (i64)(*p).mode;
    if (((i64)(*p).tag == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5) || (t==(i64)10)) {
            (*p).value = -((*p).value);
            return p;
        }
        else if ((t==(i64)9)) {
            (*p).value = (-((*p).value) & (i64)4294967295);
            return p;
        }
        else if ((t==(i64)12)) {
            (*p).xvalue = -((*p).xvalue);
            return p;
        }
;
    }
;
    //retry:
L732 :;
;
    if (((t >= (i64)2) && (t <= (i64)13))) {
        cc_parse$coercebasetype(p);
        q = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)59,(struct cc_decls$unitrec *)p);
    }
    else if (!!((i64)cc_decls$ttconst[(t)])) {
        t = cc_decls$ttconsttype[(t)];
        goto L732 ;
;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(cc_lib$strmode(t,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_support$terror((byte*)"neg bad type");
    }
;
    (*q).mode = (i64)(*p).mode;
    return q;
}

static struct cc_decls$unitrec *cc_parse$createabsop(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
    t = (i64)(*p).mode;
    if (((i64)(*p).tag == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5)) {
            (*p).value = m$llabs((*p).value);
            return p;
        }
;
    }
;
    if (!!(cc_lib$isintcc(t))) {
        cc_parse$coercebasetype(p);
        q = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)60,(struct cc_decls$unitrec *)p);
    }
    else {
        cc_support$terror((byte*)"abs bad type");
    }
;
    (*q).mode = (i64)(*p).mode;
    return q;
}

static struct cc_decls$unitrec *cc_parse$createsqrtop(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
    t = (i64)(*p).mode;
    if (((i64)(*p).tag == (i64)1)) {
        if ((t==(i64)11) || (t==(i64)12)) {
            (*p).value = (i64)sqrt((*p).xvalue);
            return p;
        }
;
    }
;
    cc_parse$coercemode(p,(i64)12);
    q = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)72,(struct cc_decls$unitrec *)p);
    (*q).mode = (i64)12;
    return q;
}

static struct cc_decls$unitrec *cc_parse$createinotop(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
    t = cc_decls$ttbasetype[((i64)(*p).mode)];
    if (((i64)(*p).tag == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
            (*p).value = ~((*p).value);
            return p;
        }
;
    }
;
    if (!!(cc_lib$isintcc(t))) {
        cc_parse$coercebasetype(p);
        q = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)61,(struct cc_decls$unitrec *)p);
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(cc_lib$strmode(t,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_support$terror((byte*)"! bad type");
    }
;
    (*q).mode = (i64)(*p).mode;
    return q;
}

static struct cc_decls$unitrec *cc_parse$createptrop(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
        i64 m;
    if (!(!!((i64)cc_decls$ttisref[((t = (i64)(*p).mode))]))) {
        cc_lib$printunit(0,(struct cc_decls$unitrec *)p,(i64)0,(byte*)"*");
        cc_support$terror((byte*)"* not pointer");
    }
;
    m = cc_decls$tttarget[(t)];
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)56)) {
        q = (struct cc_decls$unitrec *)(*p).a;
        if (!!((i64)(*p).alength)) {
            (*q).mode = cc_decls$tttarget[((i64)(*p).mode)];
        }
;
        return q;
    }
    };
    q = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)53,(struct cc_decls$unitrec *)p);
    (*q).mode = m;
    q = cc_parse$arraytopointer(q);
    cc_parse$fixmemopnd(q);
    return q;
}

static struct cc_decls$unitrec *cc_parse$createincrop(i64 opc,struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
    t = (i64)(*p).mode;
    cc_parse$checklvalue(p,(i64)1);
    if (!(((!!(cc_lib$isintcc(t)) && (t != (i64)6)) || !!((i64)cc_decls$ttisref[(t)])))) {
        cc_support$terror((byte*)"++ bad type");
    }
;
    q = (struct cc_decls$unitrec *)cc_lib$createunit1(opc,(struct cc_decls$unitrec *)p);
    (*q).mode = (i64)(*p).mode;
    return q;
}

static struct cc_decls$unitrec *cc_parse$createlengthofop(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
        i64 size;
    t = (i64)(*p).mode;
    switch ((i64)(*p).tag) {
    case 3:;
        {
            size = cc_decls$ttlength[((i64)(*(*p).def).mode)];
        }
        break;
    case 1:;
        {
            if ((t == cc_decls$trefchar)) {
                size = ((i64)(*p).slength + (i64)1);
            }
            else {
                size = cc_decls$ttlength[(t)];
            }
;
        }
        break;
    case 53:;
        {
            if ((!!((i64)cc_decls$ttisref[(t)]) && !!((i64)(*p).alength))) {
                size = (cc_decls$ttlength[(cc_decls$tttarget[(t)])] * (i64)(*p).alength);
            }
            else {
                size = cc_decls$ttlength[(t)];
            }
;
        }
        break;
    case 4:;
        {
            return cc_parse$createsizeofop((struct cc_decls$unitrec *)(*p).a);
        }
        break;
    default: {
        size = cc_decls$ttlength[(t)];
    }
    } //SW
;
    q = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)size,(i64)4);
    return q;
}

static struct cc_decls$unitrec *cc_parse$createaddrofop(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
        i64 alength;
    alength = (i64)0;
    //restartx:
L733 :;
;
    t = (i64)(*p).mode;
    switch ((i64)(*p).tag) {
    case 3:;
        {
            if (!!((i64)(*p).alength)) {
                t = (i64)(*(*p).def).mode;
                alength = (i64)(*p).alength;
            }
;
        }
        break;
    case 56:;
        {
            if ((((i64)(*(*p).a).tag == (i64)3) && !!((i64)(*(*p).a).alength))) {
                (*p).mode = cc_lib$createrefmode((i64)(*(*(*p).a).def).mode);
                (*p).alength = (i64)(*(*p).a).alength;
                return p;
            }
;
        }
        break;
    case 50:;
        {
            q = (struct cc_decls$unitrec *)(*p).a;
            if ((((i64)(*q).tag == (i64)53) && ((i64)(*(*q).a).tag == (i64)1))) {
                p = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)((i64)(*p).offset + (*(*q).a).value),(i64)4);
                return p;
            }
;
            goto L734 ;
;
        }
        break;
    case 54:;
        {
            if (!!((i64)(*p).alength)) {
                (*p).mode = cc_lib$createrefmode(cc_lib$createarraymode(cc_decls$tttarget[((i64)(*p).mode)],(i64)(*p).alength));
                return p;
            }
;
        }
        break;
    case 4:;
        {
            p = (struct cc_decls$unitrec *)(*p).a;
            goto L733 ;
;
        }
        break;
    case 5:;
        {
            return p;
        }
        break;
    default: {
        //cad1:
L734 :;
;
        cc_parse$checklvalue(p,(i64)0);
    }
    } //SW
;
    p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)56,(struct cc_decls$unitrec *)p);
    (*p).mode = cc_lib$createrefmode(t);
    (*p).alength = alength;
    return p;
}

static struct cc_decls$unitrec *cc_parse$createaddop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y) {
        struct cc_decls$unitrec *  z;
        i64 s;
        i64 t;
        i64 u;
        i64 opc;
        i64 elemsize;
    s = cc_decls$ttbasetype[(cc_parse$getmemmode(x))];
    t = cc_decls$ttbasetype[(cc_parse$getmemmode(y))];
    opc = (i64)40;
    if (!!((u = (i64)cc_tables$dominantmode[(s)][(t)]))) {
        x = cc_parse$coercemode(x,u);
        y = cc_parse$coercemode(y,u);
    }
    else if ((s == (i64)16)) {
        //doaddref:
L735 :;
;
        u = (i64)(*x).mode;
        elemsize = cc_decls$ttsize[(cc_decls$tttarget[(u)])];
        if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
            (*x).value += ((*y).value * elemsize);
            return x;
        }
;
        y = cc_parse$coercemode(y,(i64)5);
        z = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)54,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
        (*z).mode = u;
        (*z).ptrscale = elemsize;
        return z;
    }
    else if ((t == (i64)16)) {
        {struct cc_decls$unitrec *  temp = x; x = y; y = temp; };
        goto L735 ;
;
    }
    else {
        cc_support$terror((byte*)"Sub bad types");
    }
;
    if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
        return cc_parse$eval_add(opc,x,y,u);
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = u;
    return z;
}

static struct cc_decls$unitrec *cc_parse$createsubop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y) {
        struct cc_decls$unitrec *  z;
        i64 s;
        i64 t;
        i64 u;
        i64 opc;
        i64 elemsize;
    s = cc_decls$ttbasetype[(cc_parse$getmemmode(x))];
    t = cc_decls$ttbasetype[(cc_parse$getmemmode(y))];
    opc = (i64)41;
    if (!!((u = (i64)cc_tables$dominantmode[(s)][(t)]))) {
        x = cc_parse$coercemode(x,u);
        y = cc_parse$coercemode(y,u);
    }
    else if ((s == (i64)16)) {
        if ((t != (i64)16)) {
            u = (i64)(*x).mode;
            elemsize = cc_decls$ttsize[(cc_decls$tttarget[(u)])];
            y = cc_parse$coercemode(y,(i64)5);
            z = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)55,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
            (*z).mode = u;
            (*z).ptrscale = elemsize;
            return z;
        }
        else {
            if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
                (*x).value -= ((*y).value / cc_decls$ttsize[(cc_decls$tttarget[((i64)(*x).mode)])]);
                (*x).mode = (i64)4;
                return x;
            }
            else {
                z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
                (*z).mode = (i64)5;
                z = cc_parse$divunit(z,cc_decls$tttarget[((i64)(*x).mode)]);
                (*z).mode = (i64)5;
                return z;
            }
;
        }
;
        y = cc_parse$mulunit(y,cc_decls$tttarget[((i64)(*x).mode)]);
    }
    else {
        cc_support$terror((byte*)"Sub bad types");
    }
;
    if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
        return cc_parse$eval_sub(opc,x,y,u);
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = u;
    return z;
}

static struct cc_decls$unitrec *cc_parse$createmulop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y) {
        struct cc_decls$unitrec *  z;
        i64 s;
        i64 t;
        i64 u;
        i64 opc;
    s = cc_decls$ttbasetype[(cc_parse$getmemmode(x))];
    t = cc_decls$ttbasetype[(cc_parse$getmemmode(y))];
    opc = (i64)42;
    if (!!((u = (i64)cc_tables$dominantmode[(s)][(t)]))) {
        x = cc_parse$coercemode(x,u);
        y = cc_parse$coercemode(y,u);
    }
    else {
        cc_support$terror((byte*)"Mul bad types");
    }
;
    if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
        return cc_parse$eval_mul(opc,x,y,u);
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = u;
    return z;
}

static struct cc_decls$unitrec *cc_parse$createdivop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y) {
        struct cc_decls$unitrec *  z;
        i64 s;
        i64 t;
        i64 u;
        i64 opc;
    s = cc_decls$ttbasetype[(cc_parse$getmemmode(x))];
    t = cc_decls$ttbasetype[(cc_parse$getmemmode(y))];
    opc = (i64)43;
    if (!!((u = (i64)cc_tables$dominantmode[(s)][(t)]))) {
        x = cc_parse$coercemode(x,u);
        y = cc_parse$coercemode(y,u);
    }
    else {
        cc_support$terror((byte*)"Div bad types");
    }
;
    if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
        return cc_parse$eval_div(opc,x,y,u);
    }
    else if ((((i64)(*y).tag == (i64)1) && (u == (i64)12))) {
        opc = (i64)42;
        (*y).xvalue = ((double)1. / (*y).xvalue);
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = u;
    return z;
}

static struct cc_decls$unitrec *cc_parse$createremop(struct cc_decls$unitrec *x,struct cc_decls$unitrec *y) {
        struct cc_decls$unitrec *  z;
        i64 s;
        i64 t;
        i64 u;
        i64 opc;
    s = cc_decls$ttbasetype[((i64)(*x).mode)];
    t = cc_decls$ttbasetype[((i64)(*y).mode)];
    opc = (i64)44;
    if (!!((u = (i64)cc_tables$dominantmode[(s)][(t)]))) {
        if (((u == (i64)12) || (u == (i64)11))) {
            u = (i64)4;
        }
;
        x = cc_parse$coercemode(x,u);
        y = cc_parse$coercemode(y,u);
    }
    else {
        cc_support$terror((byte*)"Rem bad types");
    }
;
    if ((((i64)(*x).tag == (i64)1) && ((i64)(*y).tag == (i64)1))) {
        return cc_parse$eval_rem(opc,x,y,u);
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = u;
    return z;
}

static void cc_parse$insertunit(struct cc_decls$unitrec *p,i64 tag) {
        struct cc_decls$unitrec *  q;
    q = (struct cc_decls$unitrec *)cc_lib$createunit0((i64)0);
    (*q) = (*p);
    (*p).tag = tag;
    (*p).a = (struct cc_decls$unitrec *)q;
    (*p).b = (struct cc_decls$unitrec *)((*p).c = 0);
    (*p).lineno = (i64)(*q).lineno;
    (*p).simple = (i64)0;
    (*p).nextunit = (*q).nextunit;
    (*q).nextunit = 0;
}

static struct cc_decls$unitrec *cc_parse$eval_add(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t) {
        struct cc_decls$unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
        (*x).value += (*y).value;
        return x;
    }
    else if ((t==(i64)12)) {
        (*x).xvalue += (*y).xvalue;
        return x;
    }
    else {
        if ((cc_decls$ttbasetype[(t)] == (i64)16)) {
            (*x).value += ((*y).value * cc_decls$ttsize[(cc_decls$tttarget[(t)])]);
            return x;
        }
;
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = t;
    return z;
}

static struct cc_decls$unitrec *cc_parse$eval_sub(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t) {
        struct cc_decls$unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
        (*x).value -= (*y).value;
        return x;
    }
    else if ((t==(i64)12)) {
        (*x).xvalue -= (*y).xvalue;
        return x;
    }
    else {
        if ((cc_decls$ttbasetype[(t)] == (i64)16)) {
            if ((cc_decls$ttbasetype[((i64)(*y).mode)] == (i64)16)) {
                cc_support$terror((byte*)"EVALSUB/REF");
            }
;
            return x;
        }
;
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = t;
    return z;
}

static struct cc_decls$unitrec *cc_parse$eval_mul(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t) {
        struct cc_decls$unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)3) || (t==(i64)2)) {
        (*x).value *= (*y).value;
        return x;
    }
    else if ((t==(i64)9) || (t==(i64)10) || (t==(i64)8) || (t==(i64)7)) {
        (*x).uvalue = ((*x).uvalue * (*y).uvalue);
        return x;
    }
    else if ((t==(i64)12)) {
        (*x).xvalue *= (*y).xvalue;
        return x;
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = t;
    return z;
}

static struct cc_decls$unitrec *cc_parse$eval_div(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t) {
        struct cc_decls$unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5)) {
        if (((*y).value == (i64)0)) {
            cc_support$serror((byte*)"div 0");
        }
;
        (*x).value = ((*x).value / (*y).value);
        return x;
    }
    else if ((t==(i64)9) || (t==(i64)10)) {
        if (((*y).value == (i64)0)) {
            cc_support$serror((byte*)"div 0");
        }
;
        (*x).uvalue = ((*x).uvalue / (*y).uvalue);
        return x;
    }
    else if ((t==(i64)12)) {
        (*x).xvalue /= (*y).xvalue;
        return x;
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = t;
    return z;
}

static struct cc_decls$unitrec *cc_parse$eval_rem(i64 opc,struct cc_decls$unitrec *x,struct cc_decls$unitrec *y,i64 t) {
        struct cc_decls$unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5)) {
        if (((*y).value == (i64)0)) {
            cc_support$serror((byte*)"rem 0");
        }
;
        (*x).value = ((*x).value % (*y).value);
        return x;
    }
;
    z = (struct cc_decls$unitrec *)cc_lib$createunit2(opc,(struct cc_decls$unitrec *)x,(struct cc_decls$unitrec *)y);
    (*z).mode = t;
    return z;
}

static i64 cc_parse$eval_convert(struct cc_decls$unitrec *p,i64 t,i64 opc) {
        i64 s;
    if ((opc == (i64)1)) {
        //dosoft:
L736 :;
;
        (*p).mode = t;
        return (i64)1;
    }
;
    s = (i64)(*p).mode;
    if ((s == t)) {
        return (i64)1;
    }
;
    if ((s==(i64)4) || (s==(i64)3) || (s==(i64)2) || (s==(i64)5)) {
        if ((t==(i64)12) || (t==(i64)11)) {
            (*p).xvalue = (r64)(*p).value;
            (*p).mode = t;
            return (i64)1;
        }
        else if ((t==(i64)10) || (t==(i64)5) || (t==(i64)9) || (t==(i64)4) || (t==(i64)3) || (t==(i64)2) || (t==(i64)7) || (t==(i64)8)) {
            //dotrunc:
L737 :;
;
                        {i64 $temp = cc_decls$ttsize[(t)];
if (($temp==(i64)1)) {
                (*p).value &= (i64)255;
                if (!!((i64)cc_tables$stdtypesigned[(t)])) {
                    (*p).value = (i64)(i8)(*p).value;
                }
;
            }
            else if (($temp==(i64)2)) {
                (*p).value &= (i64)65535;
                if (!!((i64)cc_tables$stdtypesigned[(t)])) {
                    (*p).value = (i64)(i16)(*p).value;
                }
;
            }
            else if (($temp==(i64)4)) {
                (*p).value = ((*p).value & (i64)4294967295);
            }
            };
            goto L736 ;
;
        }
;
        if (!!((i64)cc_decls$ttisref[(t)])) {
            (*p).mode = t;
            return (i64)1;
        }
;
    }
    else if ((s==(i64)9) || (s==(i64)7) || (s==(i64)8) || (s==(i64)10)) {
        if ((t==(i64)12) || (t==(i64)11)) {
            return (i64)0;
            (*p).mode = t;
            return (i64)1;
        }
        else if ((t==(i64)10) || (t==(i64)5) || (t==(i64)4) || (t==(i64)9) || (t==(i64)10) || (t==(i64)8) || (t==(i64)2) || (t==(i64)7) || (t==(i64)3)) {
            goto L737 ;
;
        }
;
        if (!!((i64)cc_decls$ttisref[(t)])) {
            (*p).mode = t;
            return (i64)1;
        }
;
    }
    else if ((s==(i64)12)) {
        if ((t==(i64)4) || (t==(i64)5)) {
            (*p).value = (i64)(*p).xvalue;
            (*p).mode = t;
            return (i64)1;
        }
        else if ((t==(i64)9) || (t==(i64)10)) {
            (*p).value = (i64)(*p).xvalue;
            (*p).mode = t;
            return (i64)1;
        }
        else if ((t==(i64)11)) {
            (*p).mode = (i64)11;
            return (i64)1;
        }
;
    }
    else {
        if (!!((i64)cc_decls$ttisref[((i64)(*p).mode)])) {
            if (!(!!((i64)(*p).isstrconst))) {
                if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
                    (*p).mode = t;
                    return (i64)1;
                }
;
            }
;
        }
;
    }
;
    return (i64)0;
}

static void cc_parse$coercecond(struct cc_decls$unitrec *p) {
        i64 t;
    if (((t = (i64)(*p).mode) == (i64)4)) {
        return;
    }
;
    //retry:
L738 :;
;
        {i64 $temp = cc_decls$ttbasetype[(t)];
if (($temp==(i64)11) || ($temp==(i64)12) || ($temp==(i64)16)) {
        goto L739 ;
;
    }
    else {
        if (!!(cc_lib$isintcc(t))) {
            //doint:
L739 :;
;
            if ((((i64)(*p).tag == (i64)1) && !!((*p).value))) {
                (*p).value = (i64)1;
            }
            else if ((((i64)(*p).tag == (i64)1) && !(!!((*p).value)))) {
                (*p).value = (i64)0;
            }
            else {
                cc_parse$insertunit(p,(i64)28);
            }
;
        }
        else if (!!((i64)cc_decls$ttconst[(t)])) {
            t = cc_decls$ttconsttype[(t)];
            goto L738 ;
;
        }
        else {
            cc_support$serror_s((byte*)"Invalid condition %s",cc_lib$strmode(t,(i64)1));
        }
;
    }
    };
    (*p).mode = (i64)4;
}

static void cc_parse$coercebasetype(struct cc_decls$unitrec *p) {
        i64 t;
    if ((((t = (i64)(*p).mode) >= (i64)2) && (t <= (i64)3))) {
        p = cc_parse$coercemode(p,(i64)4);
    }
    else if (((t >= (i64)6) && (t <= (i64)8))) {
        p = cc_parse$coercemode(p,(i64)9);
    }
;
}

static void cc_parse$checklvalue(struct cc_decls$unitrec *p,i64 assign) {
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)3)) {
        if (((i64)(*(*p).def).nameid == (i64)14)) {
            cc_support$serror((byte*)"'constant' name can't be lvalue");
        }
;
    }
    else if (($temp==(i64)53)) {
    }
    else if (($temp==(i64)5)) {
        if (!!(assign)) {
            goto L740 ;
;
        }
;
    }
    else if (($temp==(i64)4)) {
                {i64 $temp = (i64)(*(*p).a).tag;
if (($temp==(i64)3) || ($temp==(i64)53) || ($temp==(i64)50)) {
            (*p) = (*(*p).a);
        }
        else {
            cc_support$terror((byte*)"CHECKLV/WIDEN");
        }
        };
    }
    else if (($temp==(i64)50)) {
    }
    else if (($temp==(i64)1)) {
        if (!(!!((i64)cc_decls$ttisref[((i64)(*p).mode)]))) {
            goto L740 ;
;
        }
;
    }
    else if (($temp==(i64)57)) {
        if (!!(assign)) {
            goto L740 ;
;
        }
;
    }
    else {
        //notlv:
L740 :;
;
        cc_lib$printunit(0,(struct cc_decls$unitrec *)p,(i64)0,(byte*)"*");
        cc_support$terror_s((byte*)"Not lvalue: %s",cc_tables$jtagnames[((i64)(*p).tag)]);
    }
    };
}

static struct cc_decls$unitrec *cc_parse$createcall(struct cc_decls$unitrec *p,struct cc_decls$unitrec *q) {
        struct cc_decls$unitrec *  r;
        struct cc_decls$unitrec *  s;
        struct cc_decls$unitrec *  u;
        struct cc_decls$strec *  d;
        struct cc_decls$paramrec *  pm;
        i64 i;
        i64 nparams;
        i64 aparams;
        i64 retmode;
        i64 mproc;
        i64 c;
        u8 str[1024];
        u8 *  ss;
        u8 *  tt;
        u8 *  uu;
        struct mlib$strbuffer *  exprstr;
        i64 $av_1;
    d = 0;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)53)) {
        //doptr:
L741 :;
;
        mproc = (i64)(*p).mode;
        L742 :;
        while ((cc_decls$ttbasetype[(mproc)] == (i64)16)) {
            r = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)53,(struct cc_decls$unitrec *)p);
            mproc = cc_decls$tttarget[(mproc)];
            (*r).mode = mproc;
            p = r;
L743 :;
        }
L744 :;
        ;
        if ((cc_decls$ttbasetype[(mproc)] != (i64)17)) {
            cc_support$serror_s((byte*)"Not function pointer: %s",cc_lib$typename(mproc));
        }
;
        pm = (struct cc_decls$paramrec *)cc_decls$ttparams[(mproc)];
        retmode = cc_decls$tttarget[(mproc)];
    }
    else if (($temp==(i64)3) || ($temp==(i64)5)) {
        d = (struct cc_decls$strec *)(*p).def;
        if (((i64)(*d).nameid == (i64)6)) {
            pm = (struct cc_decls$paramrec *)(*d).paramlist;
            retmode = (i64)(*d).mode;
        }
        else {
            goto L741 ;
;
        }
;
    }
    else if (($temp==(i64)50) || ($temp==(i64)31) || ($temp==(i64)32) || ($temp==(i64)57)) {
        r = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)53,(struct cc_decls$unitrec *)p);
        (*r).mode = cc_decls$tttarget[((i64)(*p).mode)];
        p = r;
        goto L741 ;
;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"JTAGNAMES[P^.TAG]=",NULL);
        msysc$m_print_str(cc_tables$jtagnames[((i64)(*p).tag)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_lib$printunit(0,(struct cc_decls$unitrec *)p,(i64)0,(byte*)"*");
        cc_support$serror((byte*)"ccall?");
    }
    };
    nparams = (i64)(*pm).nparams;
    aparams = (i64)0;
    s = q;
    L745 :;
    while (!!(s)) {
        ++(aparams);
        s = (struct cc_decls$unitrec *)(*s).nextunit;
L746 :;
    }
L747 :;
    ;
    if ((aparams < nparams)) {
        cc_support$terror((byte*)"Too few args");
    }
    else if ((((aparams > nparams) && ((i64)(*pm).flags != (i64)3)) && ((i64)(*pm).flags != (i64)1))) {
        if (((i64)(*pm).flags != (i64)1)) {
            msysc$m_print_startcon();
            msysc$m_print_i64(aparams,NULL);
            msysc$m_print_i64(nparams,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_support$terror((byte*)"Too many args");
        }
        else if (!!(cc_decls$fmodern)) {
            cc_support$terror((byte*)"Can't call () param function");
        }
;
    }
;
    s = q;
    for (i=(i64)1;i<=aparams;++i) {
L748 :;
        if ((i <= nparams)) {
            cc_parse$coercemode_inplace(s,(i64)(*pm).mode);
            pm = (struct cc_decls$paramrec *)(*pm).nextparam;
        }
        else {
            if (((i64)(*s).mode == (i64)1)) {
                cc_support$terror((byte*)"Variadic param is void");
            }
;
            cc_parse$coercebasetype(s);
        }
;
        s = (struct cc_decls$unitrec *)(*s).nextunit;
L749 :;
    }
L750 :;
    ;
    r = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)31,(struct cc_decls$unitrec *)p,(struct cc_decls$unitrec *)q);
    (*r).mode = retmode;
    (*r).aparams = aparams;
    if (((((!!(d) && !!(mlib$eqstring((*d).name,(byte*)"printf"))) && !!(q)) && ((i64)(*q).tag == (i64)1)) && ((i64)(*q).slength < (i64)512))) {
        ss = (*q).svalue;
        tt = (u8 *)str;
        u = (struct cc_decls$unitrec *)(*q).nextunit;
        L751 :;
        while (!!((c = (i64)(u64)(*(ss)++)))) {
            if ((((c == (i64)37) && ((u64)(*ss) == 'v' || (u64)(*ss) == '=')) && !!(u))) {
                if (((u64)(*ss) == '=')) {
                    ++(ss);
                    exprstr = (struct mlib$strbuffer *)cc_lib$strexpr((struct cc_decls$unitrec *)u);
                    uu = (*exprstr).strptr;
                    mlib$convucstring(uu);
                    $av_1 = (i64)(*exprstr).length;
                    while ($av_1-- > 0) {
L754 :;
                        (*(tt)++) = (u64)(*(uu)++);
L755 :;
                    }
L756 :;
                    ;
                    (*(tt)++) = '=';
                }
;
                ++(ss);
                (*(tt)++) = '%';
                                {i64 $temp = cc_decls$ttbasetype[((i64)(*u).mode)];
if (($temp==(i64)4)) {
                    (*(tt)++) = 'd';
                }
                else if (($temp==(i64)5)) {
                    (*(tt)++) = 'l';
                    (*(tt)++) = 'l';
                    (*(tt)++) = 'd';
                }
                else if (($temp==(i64)9)) {
                    (*(tt)++) = 'u';
                }
                else if (($temp==(i64)10)) {
                    (*(tt)++) = 'l';
                    (*(tt)++) = 'l';
                    (*(tt)++) = 'u';
                }
                else if (($temp==(i64)11) || ($temp==(i64)12) || ($temp==(i64)13)) {
                    (*(tt)++) = 'f';
                }
                else if (($temp==(i64)16)) {
                    if ((cc_decls$tttarget[((i64)(*u).mode)] == (i64)2)) {
                        (*(tt)++) = 's';
                    }
                    else if (((i64)(*u).tag == (i64)5)) {
                        (*(tt)++) = 's';
                        (*u).tag = (i64)1;
                        (*u).svalue = (*(*u).def).name;
                        (*u).slength = strlen((*u).svalue);
                        (*u).mode = cc_decls$trefchar;
                        (*u).isstrconst = (i64)1;
                        (*u).simple = (i64)1;
                    }
                    else {
                        (*(tt)++) = 'p';
                    }
;
                }
                else {
                    (*(tt)++) = 'v';
                }
                };
                u = (struct cc_decls$unitrec *)(*u).nextunit;
            }
            else {
                (*(tt)++) = (u64)c;
            }
;
L752 :;
        }
L753 :;
        ;
        (*tt) = (u64)0u;
        (*q).svalue = mlib$pcm_copyheapstring((u8 *)str);
        (*q).slength = strlen((u8 *)str);
    }
;
    return r;
}

static struct cc_decls$unitrec *cc_parse$arraytopointer(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 offset;
        i64 t;
        i64 elemmode;
        i64 refmode;
    t = (i64)(*p).mode;
    elemmode = cc_decls$tttarget[(t)];
    if ((cc_decls$ttbasetype[(t)] == (i64)19)) {
        refmode = cc_lib$createrefmode(elemmode);
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)53)) {
            p = (struct cc_decls$unitrec *)(*p).a;
        }
        else if (($temp==(i64)50)) {
            offset = (i64)(*p).offset;
            (*p).tag = (i64)54;
            (*p).ptrscale = (i64)0;
            q = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)56,(struct cc_decls$unitrec *)(*p).a);
            (*q).mode = refmode;
            (*p).a = (struct cc_decls$unitrec *)q;
            (*p).b = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)offset,(i64)4);
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"ATP:",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_lib$printunit(0,(struct cc_decls$unitrec *)p,(i64)0,(byte*)"*");
            cc_support$terror((byte*)"ATP?");
        }
        };
        (*p).mode = refmode;
        (*p).alength = cc_decls$ttlength[(t)];
    }
;
    return p;
}

static struct cc_decls$unitrec *cc_parse$createindexop(struct cc_decls$unitrec *p,struct cc_decls$unitrec *q) {
        struct cc_decls$unitrec *  a;
    a = cc_parse$createaddop(p,q);
    return cc_parse$createptrop(a);
}

static i64 cc_parse$readstructdecl(struct cc_decls$strec *owner) {
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  e;
        struct cc_decls$strec *  currrecord;
        struct cc_decls$strec *  ulist;
        struct cc_decls$strec *  ulistx;
        struct cc_decls$strec *  tagowner;
        i64 funion;
        i64 linkage;
        i64 mbase;
        i64 m;
        i64 offset;
        i64 recsize;
        i64 maxsize;
        i64 maxalignment;
        i64 alignment;
        i64 size;
        struct cc_decls$paramrec *  pm;
        struct cc_decls$fieldrec *  fieldlist;
    funion = (i64)((i64)cc_decls$lx.symbol == (i64)86);
    cc_lex$lex();
    tagowner = (struct cc_decls$strec *)(!!(cc_decls$currproc) ? cc_decls$currproc : cc_decls$stmodule);
    if (((i64)cc_decls$lx.symbol == (i64)17)) {
        d = (struct cc_decls$strec *)cc_lex$addnamestr(cc_lib$nextautotype());
    }
    else {
        cc_lib$checksymbol((i64)69);
        d = (struct cc_decls$strec *)cc_decls$lx.symptr;
        cc_lex$lex();
        if (((i64)cc_decls$lx.symbol != (i64)17)) {
            e = (struct cc_decls$strec *)cc_lib$resolvename((struct cc_decls$strec *)tagowner,(struct cc_decls$strec *)d,(i64)2,cc_decls$currblockno);
            if (!!(e)) {
                if (((i64)(*e).nameid != (i64)13)) {
                    cc_support$serror_s((byte*)"Struct tag in use %s",(*e).name);
                }
;
                return (i64)(*e).mode;
            }
;
            e = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)tagowner,(struct cc_decls$strec *)d,(i64)13);
            (*e).mode = cc_lib$createstructmode((struct cc_decls$strec *)e,(!!(funion) ? (i64)21 : (i64)20));
            (*e).blockno = cc_decls$currblockno;
            cc_decls$blockcounts[(cc_decls$currblockno)] = (i64)1;
            return (i64)(*e).mode;
        }
;
    }
;
    e = (struct cc_decls$strec *)cc_lib$checkdupl((struct cc_decls$strec *)tagowner,(struct cc_decls$strec *)d,(i64)2,cc_decls$currblockno);
    if (!!(e)) {
        if (((i64)(*e).nameid != (i64)13)) {
            cc_support$serror_s((byte*)"Struct tag in use %s",(*e).name);
        }
;
        if (!!((*e).deflist)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Prev",NULL);
            msysc$m_print_i64(((i64)(*e).lineno & (i64)1677215),NULL);
            msysc$m_print_str(cc_decls$sourcefilenames[(((i64)(*e).lineno >> (i64)24))],NULL);
            msysc$m_print_str(cc_decls$sourcefilepaths[(((i64)(*e).lineno >> (i64)24))],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_support$serror_s((byte*)"Redefining struct %s",(*e).name);
        }
;
    }
    else {
        e = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)tagowner,(struct cc_decls$strec *)d,(i64)13);
        (*e).mode = cc_lib$createstructmode((struct cc_decls$strec *)e,(!!(funion) ? (i64)21 : (i64)20));
        (*e).blockno = cc_decls$currblockno;
        cc_decls$blockcounts[(cc_decls$currblockno)] = (i64)1;
    }
;
    cc_lex$lex();
    currrecord = e;
    ulist = (ulistx = 0);
    offset = (maxsize = (recsize = (i64)0));
    maxalignment = (i64)1;
    fieldlist = 0;
    m = (i64)-1;
    L757 :;
    while (((i64)cc_decls$lx.symbol != (i64)18)) {
        mbase = cc_parse$readdeclspec((struct cc_decls$strec *)currrecord,&linkage);
        L760 :;
                {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)69) || ($temp==(i64)25) || ($temp==(i64)13)) {
            m = cc_parse$readtype((struct cc_decls$strec *)currrecord,&d,mbase,&pm);
            if ((d == 0)) {
                cc_support$serror((byte*)"Field name expected");
            }
;
            if (((linkage == (i64)5) || !!(pm))) {
                cc_support$serror((byte*)"typedef or function inside struct");
            }
;
            e = (struct cc_decls$strec *)cc_lib$checkdupl((struct cc_decls$strec *)currrecord,(struct cc_decls$strec *)d,(i64)4,(i64)0);
            if (!!(e)) {
                cc_support$serror_s((byte*)"member name in use %s",(*e).name);
            }
;
            if ((linkage != (i64)0)) {
                cc_support$serror((byte*)"Can't use ss in struct");
            }
;
            //addanonfield:
L762 :;
;
            d = (struct cc_decls$strec *)cc_lib$createdupldef(0,(struct cc_decls$strec *)d,(i64)10);
            (*d).mode = m;
            cc_lib$addlistdef((struct cc_decls$strec **)&ulist,(struct cc_decls$strec **)&ulistx,(struct cc_decls$strec *)d);
            (*currrecord).deflist = (struct cc_decls$strec *)ulist;
            (*currrecord).deflistx = (struct cc_decls$strec *)ulistx;
            (*d).owner = (struct cc_decls$strec *)currrecord;
            alignment = cc_lib$getalignment(m);
            if ((alignment > maxalignment)) {
                maxalignment = alignment;
            }
;
            (*d).offset = cc_parse$roundoffset(offset,alignment);
            size = cc_decls$ttsize[(m)];
            recsize += ((*d).offset - offset);
            offset = (*d).offset;
            cc_parse$addnewfield(&fieldlist,(struct cc_decls$strec *)d,offset);
            if (!!(funion)) {
                maxsize = (maxsize>size?maxsize:size);
            }
            else {
                offset += size;
                recsize += size;
            }
;
            if (((i64)cc_decls$lx.symbol == (i64)10)) {
                cc_lex$lex();
                cc_parse$readassignexpr();
            }
;
                        {i64 $temp = (i64)cc_decls$lx.symbol;
if (($temp==(i64)8)) {
                cc_lex$lex();
            }
            else {
                cc_lib$skipsymbol((i64)9);
                goto L761 ;
            }
            };
        }
        else if (($temp==(i64)10)) {
            cc_lex$lex();
            cc_parse$readassignexpr();
            cc_lib$skipsymbol((i64)9);
            goto L761 ;
        }
        else {
                        {i64 $temp = cc_decls$ttbasetype[(mbase)];
if (($temp==(i64)20) || ($temp==(i64)21)) {
                d = (struct cc_decls$strec *)cc_lib$getautofieldname();
                m = mbase;
                goto L762 ;
;
            }
            else {
                if ((m == (i64)-1)) {
                    cc_support$serror((byte*)"Struct decl error");
                }
                else {
                    cc_support$serror_s((byte*)"Struct decl error %s",cc_lib$typename(m));
                }
;
            }
            };
        }
        }goto L760 ;
L761 :;
        ;
L758 :;
    }
L759 :;
    ;
    cc_lib$skipsymbol((i64)18);
    (*currrecord).nextfield = (struct cc_decls$fieldrec *)fieldlist;
    cc_decls$ttsize[((i64)(*currrecord).mode)] = cc_parse$roundoffset((!!(funion) ? maxsize : recsize),maxalignment);
    (*currrecord).attribs.ax_align = maxalignment;
    return (i64)(*currrecord).mode;
}

static i64 cc_parse$checkpointertypes(i64 s,i64 t,i64 hard) {
        i64 starget;
        i64 ttarget;
        i64 sconst;
        i64 tconst;
    starget = cc_decls$tttarget[(s)];
    ttarget = cc_decls$tttarget[(t)];
    sconst = (i64)0;
    tconst = (i64)0;
    if (!!((i64)cc_decls$ttconst[(starget)])) {
        starget = cc_decls$ttconsttype[(starget)];
        sconst = (i64)1;
    }
;
    if (!!((i64)cc_decls$ttconst[(ttarget)])) {
        ttarget = cc_decls$ttconsttype[(ttarget)];
        tconst = (i64)1;
    }
;
    if (((!(!!(hard)) && !!(sconst)) && !(!!(tconst)))) {
        msysc$m_print_startcon();
        msysc$m_print_str(cc_lib$strmode(s,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str(cc_lib$strmode(t,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        cc_support$terror((byte*)"const to non-const pointer");
    }
;
    if ((starget == ttarget)) {
        return (i64)1;
    }
;
    s = starget;
    t = ttarget;
    if (((cc_decls$ttbasetype[(s)] == (i64)1) || (cc_decls$ttbasetype[(t)] == (i64)1))) {
        return (i64)1;
    }
;
    if ((!!((i64)cc_decls$ttisref[(s)]) && !!((i64)cc_decls$ttisref[(t)]))) {
        return cc_parse$checkpointertypes(s,t,hard);
    }
    else if (((cc_decls$ttbasetype[(s)] == (i64)19) && (cc_decls$ttbasetype[(t)] == (i64)19))) {
        if ((cc_decls$ttlength[(s)] != cc_decls$ttlength[(t)])) {
            if ((!!(cc_decls$ttlength[(s)]) && !!(cc_decls$ttlength[(t)]))) {
                return (i64)0;
            }
;
        }
;
        starget = cc_decls$tttarget[(s)];
        ttarget = cc_decls$tttarget[(t)];
        if ((starget == ttarget)) {
            return (i64)1;
        }
;
        if ((!!((i64)cc_decls$ttisref[(starget)]) && !!((i64)cc_decls$ttisref[(ttarget)]))) {
            return cc_parse$checkpointertypes(starget,ttarget,hard);
        }
;
        if (((cc_decls$ttbasetype[(starget)] == (i64)19) && (cc_decls$ttbasetype[(ttarget)] == (i64)19))) {
            return cc_parse$checkpointertypes(starget,ttarget,hard);
        }
;
    }
    else if (((cc_decls$ttbasetype[(s)] == (i64)17) && (cc_decls$ttbasetype[(t)] == (i64)17))) {
        return (i64)1;
    }
;
    return (i64)0;
}

static i64 cc_parse$comparemode(i64 s,i64 t) {
    if ((s == t)) {
        return (i64)1;
    }
;
    if (((cc_decls$ttbasetype[(s)] == (i64)19) && (cc_decls$ttbasetype[(s)] == (i64)19))) {
        if ((cc_parse$comparemode(cc_decls$tttarget[(s)],cc_decls$tttarget[(t)]) == (i64)0)) {
            return (i64)0;
        }
;
        if ((((cc_decls$ttlength[(s)] == (i64)0) || (cc_decls$ttlength[(t)] == (i64)0)) || (cc_decls$ttlength[(s)] == cc_decls$ttlength[(t)]))) {
            return (i64)1;
        }
;
    }
;
    return (i64)0;
}

static i64 cc_parse$readenumdecl(struct cc_decls$strec *owner) {
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  e;
    cc_lex$lex();
    if (((i64)cc_decls$lx.symbol == (i64)17)) {
        cc_parse$readenumnames((struct cc_decls$strec *)owner);
        return (i64)15;
    }
;
    cc_lib$checksymbol((i64)69);
    d = (struct cc_decls$strec *)cc_decls$lx.symptr;
    cc_lex$lex();
    if (((i64)cc_decls$lx.symbol != (i64)17)) {
        e = (struct cc_decls$strec *)cc_lib$checkdupl((struct cc_decls$strec *)owner,(struct cc_decls$strec *)d,(i64)2,cc_decls$currblockno);
        if (!!(e)) {
            if (((i64)(*e).nameid != (i64)12)) {
                cc_support$serror_s((byte*)"Enum tag in use %s",(*e).name);
            }
;
        }
;
        e = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)owner,(struct cc_decls$strec *)d,(i64)12);
        (*e).mode = cc_lib$createenummode((struct cc_decls$strec *)e);
        (*e).blockno = cc_decls$currblockno;
        cc_decls$blockcounts[(cc_decls$currblockno)] = (i64)1;
        return (i64)(*e).mode;
    }
;
    e = (struct cc_decls$strec *)cc_lib$checkdupl((struct cc_decls$strec *)owner,(struct cc_decls$strec *)d,(i64)2,cc_decls$currblockno);
    if (!!(e)) {
        if (((i64)(*e).nameid != (i64)12)) {
            cc_support$serror_s((byte*)"Enum tag in use %s",(*e).name);
        }
;
        if (!!((*e).deflist)) {
            cc_support$serror_s((byte*)"Redefining enum %s",(*e).name);
        }
;
    }
    else {
        e = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)owner,(struct cc_decls$strec *)d,(i64)12);
        (*e).mode = cc_lib$createenummode((struct cc_decls$strec *)e);
        (*e).blockno = cc_decls$currblockno;
        cc_decls$blockcounts[(cc_decls$currblockno)] = (i64)1;
    }
;
    cc_parse$readenumnames((struct cc_decls$strec *)owner);
    cc_decls$ttnamedef[((i64)(*e).mode)] = (struct cc_decls$strec *)e;
    return (i64)(*e).mode;
}

static void cc_parse$readenumnames(struct cc_decls$strec *owner) {
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  ulist;
        struct cc_decls$strec *  ulistx;
        i64 enumseq;
    ulist = (ulistx = 0);
    enumseq = (i64)0;
    cc_lex$lex();
        {i64 $temp = (i64)(*owner).nameid;
if (($temp==(i64)6) || ($temp==(i64)3)) {
    }
    else {
        owner = (struct cc_decls$strec *)(!!(cc_decls$currproc) ? cc_decls$currproc : cc_decls$stmodule);
    }
    };
    L763 :;
    while (((i64)cc_decls$lx.symbol == (i64)69)) {
        d = (struct cc_decls$strec *)cc_lib$checkdupl((struct cc_decls$strec *)owner,(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)1,cc_decls$currblockno);
        if (!!(d)) {
            cc_support$serror_s((byte*)"enum name reused %s",(*d).name);
        }
;
        d = (struct cc_decls$strec *)cc_lib$createdupldef((struct cc_decls$strec *)owner,(struct cc_decls$strec *)cc_decls$lx.symptr,(i64)11);
        cc_lex$lex();
        if (((i64)cc_decls$lx.symbol == (i64)11)) {
            cc_lex$lex();
            enumseq = cc_parse$readconstintexpr();
        }
;
        (*d).index = enumseq;
        (*d).blockno = cc_decls$currblockno;
        cc_decls$blockcounts[(cc_decls$currblockno)] = (i64)1;
        ++(enumseq);
        if (((i64)cc_decls$lx.symbol == (i64)8)) {
            cc_lex$lex();
        }
;
L764 :;
    }
L765 :;
    ;
    cc_lib$skipsymbol((i64)18);
}

static struct cc_decls$unitrec *cc_parse$createdotop(i64 opc,struct cc_decls$unitrec *p,struct cc_decls$strec *d) {
        struct cc_decls$unitrec *  poffset;
        struct cc_decls$strec *  f;
        struct cc_decls$strec *  prec;
        struct cc_decls$strec *  gend;
        i64 m;
        i64 offset;
        struct cc_decls$fieldrec *  fl;
    m = (i64)(*p).mode;
    if ((opc == (i64)51)) {
        if (!(!!((i64)cc_decls$ttisref[(m)]))) {
            cc_support$serror((byte*)"-> needs pointer");
        }
;
        m = cc_decls$tttarget[(m)];
    }
;
        {i64 $temp = cc_decls$ttbasetype[(m)];
if (($temp==(i64)20) || ($temp==(i64)21)) {
    }
    else {
        cc_support$serror((byte*)". -> not a struct");
    }
    };
    prec = (struct cc_decls$strec *)cc_decls$ttnamedef[(m)];
    f = (struct cc_decls$strec *)d;
    L766 :;
    while (!!((f = (struct cc_decls$strec *)(*f).nextdupl))) {
        if (((*f).owner == prec)) {
            offset = (*f).offset;
            goto L768 ;
        }
;
L767 :;
    }
L768 :;
    ;
    if (!(!!(f))) {
        gend = (struct cc_decls$strec *)d;
        L769 :;
        while (!!((*gend).prevdupl)) {
            gend = (struct cc_decls$strec *)(*gend).prevdupl;
L770 :;
        }
L771 :;
        ;
        fl = (struct cc_decls$fieldrec *)(*prec).nextfield;
        L772 :;
        while (!!(fl)) {
            if (((*fl).gendef == gend)) {
                f = (struct cc_decls$strec *)(*fl).def;
                offset = (*fl).offset;
                goto L774 ;
            }
;
            fl = (struct cc_decls$fieldrec *)(*fl).nextfield;
L773 :;
        }
L774 :;
        ;
    }
;
    if (!(!!(f))) {
        cc_support$terror_ss((byte*)"Not a field of struct %s %s",(*d).name,cc_lib$strmode(m,(i64)1));
    }
;
    poffset = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)offset,(i64)4);
    if ((opc == (i64)51)) {
        p = cc_parse$createptrop(p);
    }
;
    p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)50,(struct cc_decls$unitrec *)p);
    (*p).offset = offset;
    (*p).mode = (i64)(*f).mode;
    p = cc_parse$arraytopointer(p);
    cc_parse$fixmemopnd(p);
    return p;
}

static struct cc_decls$unitrec *cc_parse$mulunit(struct cc_decls$unitrec *p,i64 elemtype) {
        i64 elemsize;
    if (((elemsize = cc_decls$ttsize[(elemtype)]) != (i64)1)) {
        if (((i64)(*p).tag == (i64)1)) {
            (*p).value = ((*p).value * elemsize);
        }
        else {
            p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)58,(struct cc_decls$unitrec *)p);
            (*p).scale = elemsize;
            (*p).mode = (i64)5;
        }
;
    }
;
    return p;
}

static struct cc_decls$unitrec *cc_parse$divunit(struct cc_decls$unitrec *p,i64 elemtype) {
        i64 elemsize;
    if (((elemsize = cc_decls$ttsize[(elemtype)]) != (i64)1)) {
        if (((i64)(*p).tag == (i64)1)) {
            (*p).value = ((*p).value / elemsize);
        }
        else {
            p = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)58,(struct cc_decls$unitrec *)p);
            (*p).scale = -(elemsize);
            (*p).mode = (i64)5;
        }
;
    }
;
    return p;
}

static struct cc_decls$unitrec *cc_parse$createassignopref(i64 opc,struct cc_decls$unitrec *p,struct cc_decls$unitrec *q) {
        i64 pmode;
        i64 qmode;
        i64 rmode;
        i64 elemmode;
        struct cc_decls$unitrec *  r;
    pmode = (rmode = (i64)(*p).mode);
    elemmode = cc_decls$tttarget[(pmode)];
    qmode = (i64)(*q).mode;
    if ((opc==(i64)11)) {
        q = cc_parse$coercemode(q,pmode);
        r = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)12,(struct cc_decls$unitrec *)p,(struct cc_decls$unitrec *)q);
    }
    else if ((opc==(i64)46)) {
        if (!!((i64)cc_decls$ttisref[(qmode)])) {
            cc_support$serror((byte*)"ptr+=ptr");
        }
;
        q = cc_parse$coercemode(q,(i64)5);
        r = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)62,(struct cc_decls$unitrec *)p,(struct cc_decls$unitrec *)cc_parse$mulunit(q,elemmode));
    }
    else if ((opc==(i64)47)) {
        if (!!((i64)cc_decls$ttisref[(qmode)])) {
            if (!(!!(cc_parse$comparemode(pmode,qmode)))) {
                cc_support$serror((byte*)"-= refs don't match");
            }
;
            r = cc_parse$divunit((struct cc_decls$unitrec *)cc_lib$createunit2((i64)41,(struct cc_decls$unitrec *)p,(struct cc_decls$unitrec *)q),elemmode);
            rmode = (i64)4;
        }
        else {
            r = (struct cc_decls$unitrec *)cc_lib$createunit2((i64)63,(struct cc_decls$unitrec *)p,(struct cc_decls$unitrec *)cc_parse$mulunit(q,elemmode));
        }
;
    }
    else {
        cc_support$serror((byte*)"Not allowed on ptrs");
    }
;
    (*r).mode = rmode;
    return r;
}

static void cc_parse$addnewfield(struct cc_decls$fieldrec **flist,struct cc_decls$strec *d,i64 offset) {
        struct cc_decls$strec *  e;
        struct cc_decls$fieldrec *  f;
    if (((u64)(*(*d).name) != '$')) {
        f = (struct cc_decls$fieldrec *)mlib$pcm_allocz((i64)32);
        (*f).def = (struct cc_decls$strec *)d;
        L775 :;
        while (!!((*d).prevdupl)) {
            d = (struct cc_decls$strec *)(*d).prevdupl;
L776 :;
        }
L777 :;
        ;
        (*f).gendef = (struct cc_decls$strec *)d;
        (*f).offset = offset;
        (*f).nextfield = (struct cc_decls$fieldrec *)(*flist);
        (*flist) = (struct cc_decls$fieldrec *)f;
    }
    else {
        e = (struct cc_decls$strec *)(*cc_decls$ttnamedef[((i64)(*d).mode)]).deflist;
        L778 :;
        while (!!(e)) {
            cc_parse$addnewfield(flist,(struct cc_decls$strec *)e,(offset + (*e).offset));
            e = (struct cc_decls$strec *)(*e).nextdef;
L779 :;
        }
L780 :;
        ;
    }
;
}

static void cc_parse$pushloop(i64 looptype) {
    if ((cc_parse$loopindex >= (i64)64)) {
        cc_support$serror((byte*)"Too many nested loop or switch");
    }
;
    ++(cc_parse$loopindex);
    cc_parse$looptypestack[(cc_parse$loopindex)-1] = looptype;
    cc_parse$casevaluestack[(cc_parse$loopindex)-1] = 0;
}

static void cc_parse$poploop(void) {
    if (!!(cc_parse$loopindex)) {
        --(cc_parse$loopindex);
    }
    else {
        cc_support$serror((byte*)"poploop?");
    }
;
}

static void cc_parse$addcasevalue(i64 value) {
        struct cc_decls$caserec *  p;
        i64 index;
    index = cc_parse$loopindex;
    L781 :;
    while ((!!(index) && ((i64)cc_parse$looptypestack[(index)-1] != (i64)83))) {
        --(index);
L782 :;
    }
L783 :;
    ;
    if ((index == (i64)0)) {
        cc_support$serror((byte*)"case not inside switch stmt");
    }
;
    p = (struct cc_decls$caserec *)mlib$pcm_alloc((i64)16);
    (*p).value = value;
    (*p).nextcase = (struct cc_decls$caserec *)cc_parse$casevaluestack[(index)-1];
    cc_parse$casevaluestack[(index)-1] = (struct cc_decls$caserec *)p;
}

static i64 cc_parse$roundoffset(i64 offset,i64 alignment) {
        i64 mask;
    if (!!(cc_decls$structpadding)) {
        if ((alignment == (i64)1)) {
            return offset;
        }
;
        mask = (alignment - (i64)1);
        L784 :;
        while (!!((offset & mask))) {
            ++(offset);
L785 :;
        }
L786 :;
        ;
    }
;
    return offset;
}

static void cc_parse$fixmemopnd(struct cc_decls$unitrec *p) {
        i64 t;
    if (!!((i64)cc_parse$ingeneric)) {
        return;
    }
;
        {i64 $temp = (t = cc_decls$ttbasetype[((i64)(*p).mode)]);
if (($temp==(i64)2) || ($temp==(i64)3)) {
        cc_parse$insertunit(p,(i64)4);
        (*p).mode = (i64)4;
    }
    else if (($temp==(i64)7) || ($temp==(i64)8) || ($temp==(i64)6)) {
        cc_parse$insertunit(p,(i64)4);
        (*p).mode = (i64)9;
    }
    };
}

static struct cc_decls$unitrec *cc_parse$docast(struct cc_decls$unitrec *p,i64 t,i64 hard,i64 inplace) {
        struct cc_decls$unitrec *  q;
        i64 s;
        i64 opc;
    s = (i64)(*p).mode;
    //retry:
L787 :;
;
    if ((s == t)) {
        return p;
    }
;
    opc = (i64)0;
    if (((s < (i64)16) && (t < (i64)16))) {
        opc = (i64)cc_tables$conversionops[(s)][(t)];
    }
    else if ((!!((i64)cc_decls$ttisref[(s)]) && !!((i64)cc_decls$ttisref[(t)]))) {
        if (!!(cc_parse$checkpointertypes(s,t,hard))) {
            (*p).mode = t;
            return p;
        }
;
    }
    else if (!!((i64)cc_decls$ttconst[(s)])) {
        s = cc_decls$ttconsttype[(s)];
        goto L787 ;
;
    }
    else if (!!((i64)cc_decls$ttconst[(t)])) {
        t = cc_decls$ttconsttype[(t)];
        goto L787 ;
;
    }
    else if ((((!!((i64)cc_decls$ttisref[(t)]) && !!(cc_lib$isintcc(s))) && ((i64)(*p).tag == (i64)1)) && ((*p).value == (i64)0))) {
        opc = (i64)1;
    }
;
    if ((opc == (i64)0)) {
        if (!(!!(hard))) {
            msysc$m_print_startcon();
            msysc$m_print_str(cc_lib$strmode(s,(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_str(cc_lib$strmode(t,(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            cc_lib$printunit(0,(struct cc_decls$unitrec *)p,(i64)0,(byte*)"*");
            cc_support$terror_ss((byte*)"Can't do conversion %s => %s",cc_lib$typename(s),cc_lib$typename(t));
        }
;
        opc = (i64)2;
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        if (!!(cc_parse$eval_convert(p,t,opc))) {
            return p;
        }
;
    }
    else if (($temp==(i64)5)) {
        (*p).mode = t;
        return p;
    }
    else if (($temp==(i64)40)) {
        if ((((i64)(*(*p).a).tag == (i64)1) && ((i64)(*(*p).b).tag == (i64)1))) {
            (*p).value = ((*(*p).a).value + (*(*p).b).value);
            (*p).mode = t;
            (*p).tag = (i64)1;
            return p;
        }
;
    }
    };
    if (!!(inplace)) {
        cc_parse$insertunit(p,(i64)57);
        (*p).mode = t;
        (*p).opcode = opc;
        return 0;
    }
    else {
        q = (struct cc_decls$unitrec *)cc_lib$createunit1((i64)57,(struct cc_decls$unitrec *)p);
        (*q).opcode = opc;
        (*q).mode = t;
    }
;
    return q;
}

static struct cc_decls$unitrec *cc_parse$coercemode(struct cc_decls$unitrec *p,i64 t) {
    if (((i64)(*p).mode == t)) {
        return p;
    }
;
    cc_parse$docast(p,t,(i64)0,(i64)1);
    return p;
}

static void cc_parse$coercemode_inplace(struct cc_decls$unitrec *p,i64 t) {
    if (((i64)(*p).mode == t)) {
        return;
    }
;
    cc_parse$docast(p,t,(i64)0,(i64)1);
}

static void cc_parse$dostaticassert(void) {
        i64 x;
        u8 str[256];
    cc_lex$lex();
    cc_lib$skipsymbol((i64)13);
    x = cc_parse$readconstintexpr();
    cc_lib$skipsymbol((i64)8);
    cc_lib$checksymbol((i64)64);
    if (!(!!(x))) {
        memcpy(str,(void *)cc_decls$lx.svalue,(u64)(i64)cc_decls$lx.length);
        str[(((i64)cc_decls$lx.length + (i64)1))-1] = (u64)0u;
        cc_support$serror((u8 *)str);
    }
;
    cc_lex$lex();
    cc_lib$skipsymbol((i64)14);
}

static struct cc_decls$unitrec *cc_parse$createsizeofop(struct cc_decls$unitrec *p) {
        struct cc_decls$unitrec *  q;
        i64 t;
        i64 size;
    t = (i64)(*p).mode;
    switch ((i64)(*p).tag) {
    case 3:;
        {
            if (!!((i64)(*p).alength)) {
                size = (cc_decls$ttsize[((i64)(*(*p).def).mode)] / (i64)(*p).alength);
            }
            else {
                size = cc_decls$ttsize[((i64)(*(*p).def).mode)];
            }
;
        }
        break;
    case 1:;
        {
            if ((t==cc_decls$trefchar)) {
                size = ((i64)(*p).slength + (i64)1);
            }
            else if ((t==cc_decls$trefwchar)) {
                size = (((i64)(*p).wslength + (i64)1) * (i64)2);
            }
            else {
                size = cc_decls$ttsize[(t)];
            }
;
        }
        break;
    case 53:;
        {
            if ((!!((i64)cc_decls$ttisref[(t)]) && !!((i64)(*p).alength))) {
                size = (cc_decls$ttsize[(cc_decls$tttarget[(t)])] * (i64)(*p).alength);
            }
            else {
                size = cc_decls$ttsize[(t)];
            }
;
        }
        break;
    case 54:;
        {
            if (!!((i64)(*p).alength)) {
                size = (cc_decls$ttsize[(cc_decls$tttarget[(t)])] * (i64)(*p).alength);
            }
            else {
                goto L788 ;
;
            }
;
        }
        break;
    case 56:;
        {
            if ((((i64)(*(*p).a).tag == (i64)3) && !!((i64)(*(*p).a).alength))) {
                size = cc_decls$ttsize[((i64)(*(*(*p).a).def).mode)];
            }
;
        }
        break;
    case 4:;
        {
            return cc_parse$createsizeofop((struct cc_decls$unitrec *)(*p).a);
        }
        break;
    default: {
        //cad1:
L788 :;
;
        size = cc_decls$ttsize[(t)];
    }
    } //SW
;
    q = (struct cc_decls$unitrec *)cc_lib$createconstunit((u64)size,(i64)10);
    return q;
}

static struct cc_decls$unitrec *cc_parse$readgeneric(void) {
        struct cc_decls$unitrec *  pexpr;
        struct cc_decls$unitrec *  pmatch;
        struct cc_decls$unitrec *  p;
        struct cc_decls$paramrec *  pm;
        i64 m;
        i64 t;
        i64 def;
        i64 oldingeneric;
        i64 count;
        struct cc_decls$strec *  d;
    cc_lex$lex();
    cc_lib$checksymbol((i64)13);
    cc_lex$lex();
    oldingeneric = (i64)cc_parse$ingeneric;
    cc_parse$ingeneric = (i64)1;
    pexpr = cc_parse$readassignexpr();
    cc_parse$ingeneric = oldingeneric;
    m = (i64)(*pexpr).mode;
    pmatch = 0;
    def = (i64)0;
    count = (i64)0;
    cc_lib$checksymbol((i64)8);
    L789 :;
    do {
        cc_lex$lex();
        if (((i64)cc_decls$lx.symbol == (i64)76)) {
            if (!!(def)) {
                cc_support$serror((byte*)"generic/default twice");
            }
;
            def = (i64)1;
            if ((count == (i64)0)) {
                t = (i64)-1;
            }
            else {
                t = (i64)-2;
            }
;
            cc_lex$lex();
        }
        else {
            t = cc_parse$readcasttype(&d,(i64)0,&pm,(i64)1,0);
        }
;
        cc_lib$checksymbol((i64)10);
        cc_lex$lex();
        p = cc_parse$readassignexpr();
        if (((t == (i64)-1) || (t == m))) {
            pmatch = p;
            ++(count);
        }
;
L790 :;
    }
    while (!((i64)cc_decls$lx.symbol != (i64)8));
L791 :;
    ;
    cc_lib$checksymbol((i64)14);
    cc_lex$lex();
    if (!(!!(pmatch))) {
        cc_support$serror((byte*)"Generic: no type match");
    }
;
    if ((count > (i64)1)) {
        cc_support$serror((byte*)"Generic: multiple types match");
    }
;
    return pmatch;
}

static void cc_parse$readstructinfosym(void) {
        struct cc_decls$strec *  d;
        struct cc_decls$strec *  e;
        struct cc_decls$paramrec *  pm;
        i64 m;
        i64 nfields;
        void *  f;
        u8 *  name;
        u8 str[256];
    cc_lex$lex();
    m = cc_parse$readcasttype(&d,(i64)0,&pm,(i64)1,0);
    if ((cc_decls$ttbasetype[(m)] != (i64)20)) {
        cc_support$serror((byte*)"Struct type expected");
    }
;
    d = (struct cc_decls$strec *)cc_decls$tttypedef[(m)];
    e = (struct cc_decls$strec *)(*d).deflist;
    nfields = (i64)0;
    L792 :;
    while (!!(e)) {
        ++(nfields);
        e = (struct cc_decls$strec *)(*e).nextdef;
L793 :;
    }
L794 :;
    ;
    name = (*d).name;
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"$",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(name,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)"_info.h",NULL);
    msysc$m_print_end();
    ;
    f = fopen((u8 *)str,(byte*)"w");
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"memberinfo_t $",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(name,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)"[] = {",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    e = (struct cc_decls$strec *)(*cc_decls$ttnamedef[(m)]).deflist;
    nfields = (i64)0;
    L795 :;
    while (!!(e)) {
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"    {\"#\", #,#,#,#,#,#}#");
        msysc$m_print_str((*e).name,NULL);
        msysc$m_print_i64((i64)(*e).mode,NULL);
        msysc$m_print_i64(cc_decls$ttbasetype[((i64)(*e).mode)],NULL);
        msysc$m_print_i64(cc_decls$tttarget[((i64)(*e).mode)],NULL);
        msysc$m_print_i64(cc_decls$ttsize[((i64)(*e).mode)],NULL);
        msysc$m_print_i64((*e).offset,NULL);
        msysc$m_print_i64((i64)0,NULL);
        msysc$m_print_str((!!((*e).nextdef) ? (byte*)"," : (byte*)""),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        ++(nfields);
        e = (struct cc_decls$strec *)(*e).nextdef;
L796 :;
    }
L797 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"};",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"enum {$#_length = #};",NULL);
    msysc$m_print_str(name,NULL);
    msysc$m_print_i64(nfields,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    fclose(f);
}

static i64 cc_parse$getmemmode(struct cc_decls$unitrec *p) {
    if (((i64)(*p).tag == (i64)4)) {
        return (i64)(*(*p).a).mode;
    }
    else {
        return (i64)(*p).mode;
    }
;
}

static struct cc_decls$unitrec *cc_parse$readstrinclude(void) {
        struct cc_decls$unitrec *  p;
        u8 *  text;
    cc_lex$lex();
    cc_lib$checksymbol((i64)13);
    cc_lex$lex();
    p = cc_parse$readexpression();
    cc_lib$checksymbol((i64)14);
    cc_lex$lex();
    if ((((i64)(*p).tag != (i64)1) || ((i64)(*p).mode != cc_decls$trefchar))) {
        cc_support$serror((byte*)"String const expected");
    }
;
    text = (u8 *)mlib$readfile((*p).svalue);
    if (!(!!(text))) {
        cc_support$serror_s((byte*)"Can't read strinclude file: %s",(*p).svalue);
    }
;
    return (struct cc_decls$unitrec *)cc_lib$createstringconstunit(text,mlib$rfsize);
}

// START
void cc_parse$start(void) {

}

static void cc_support$stopcompiler(u8 *filename,i64 lineno) {
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

void cc_support$mcerror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"\nMC Error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)40);
}

void cc_support$serror(u8 *mess) {
    cc_support$serror_gen(mess);
}

void cc_support$serror_gen(u8 *mess) {
    if (!!(cc_decls$currproc)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\nIn function",NULL);
        msysc$m_print_str((*cc_decls$currproc).name,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"On line",NULL);
    msysc$m_print_i64((i64)cc_decls$lx.lineno,NULL);
    msysc$m_print_str((byte*)"in file",NULL);
    msysc$m_print_str(cc_decls$sourcefilepaths[((i64)cc_decls$lx.fileno)],NULL);
    msysc$m_print_str(cc_decls$sourcefilenames[((i64)cc_decls$lx.fileno)],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_support$showmacrolineno();
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"**** Syntax Error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str((byte*)"****",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_support$stopcompiler(cc_decls$sourcefilepaths[((i64)cc_decls$lx.fileno)],(i64)cc_decls$lx.lineno);
}

void cc_support$serror_ss(u8 *mess,u8 *a,u8 *b) {
        u8 str[256];
    sprintf((u8 *)str,mess,a,b);
    cc_support$serror_gen((u8 *)str);
}

void cc_support$serror_s(u8 *mess,u8 *a) {
        u8 str[256];
    sprintf((u8 *)str,mess,a);
    cc_support$serror_gen((u8 *)str);
}

void cc_support$terror_gen(u8 *mess) {
    if (!!(cc_decls$currproc)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\nIn function",NULL);
        msysc$m_print_str((*cc_decls$currproc).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Type error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str((byte*)"on line",NULL);
    msysc$m_print_i64((i64)cc_decls$lx.lineno,NULL);
    msysc$m_print_str(cc_decls$sourcefilepaths[((i64)cc_decls$lx.fileno)],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_support$showmacrolineno();
    cc_support$stopcompiler(cc_decls$sourcefilepaths[((i64)cc_decls$lx.fileno)],(i64)cc_decls$lx.lineno);
}

void cc_support$terror(u8 *mess) {
    cc_support$terror_gen(mess);
}

void cc_support$terror_s(u8 *mess,u8 *a) {
        u8 str[256];
    sprintf((u8 *)str,mess,a);
    cc_support$terror_gen((u8 *)str);
}

void cc_support$terror_ss(u8 *mess,u8 *a,u8 *b) {
        u8 str[256];
    sprintf((u8 *)str,mess,a,b);
    cc_support$terror_gen((u8 *)str);
}

void cc_support$gerror_gen(u8 *mess,struct cc_decls$unitrec *p) {
        i64 lineno;
        i64 fileno;
    if (!!(p)) {
        lineno = (i64)(*p).lineno;
        fileno = (i64)(*p).fileno;
    }
    else {
        lineno = cc_decls$clineno;
        fileno = (lineno >> (i64)24);
    }
;
    if (!!(cc_decls$currproc)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"In function",NULL);
        msysc$m_print_str((*cc_decls$currproc).name,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"On line",NULL);
    msysc$m_print_i64((lineno & (i64)16777215),NULL);
    msysc$m_print_str((byte*)"in file",NULL);
    msysc$m_print_str(cc_decls$sourcefilepaths[(fileno)],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"**** Code Gen Error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str((byte*)"****",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_support$stopcompiler(cc_decls$sourcefilepaths[(fileno)],lineno);
}

void cc_support$gerror(u8 *mess,struct cc_decls$unitrec *p) {
    cc_support$gerror_gen(mess,(struct cc_decls$unitrec *)p);
}

void cc_support$gerror_s(u8 *mess,u8 *s,struct cc_decls$unitrec *p) {
        u8 str[256];
    sprintf((u8 *)str,mess,s);
    cc_support$gerror_gen((u8 *)str,(struct cc_decls$unitrec *)p);
}

void cc_support$nxerror(u8 *mess,struct cc_decls$unitrec *p) {
        i64 lineno;
    if (!!(p)) {
        lineno = (i64)(*p).lineno;
    }
    else {
        lineno = (i64)0;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"NX error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str((byte*)"on line",NULL);
    msysc$m_print_i64(lineno,NULL);
    msysc$m_print_str((*cc_decls$stmodule).name,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    cc_support$stopcompiler((*cc_decls$stmodule).name,lineno);
}

i64 cc_support$testelem(byte (*p)[],i64 n) {
    if (!!(((i64)(*p)[((n >> (i64)3))] & (i64)cc_support$bytemasks[((n & (i64)7))]))) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

void cc_support$setelem(byte (*p)[],i64 n) {
    (*p)[((n >> (i64)3))] |= (byte)(i64)cc_support$bytemasks[((n & (i64)7))];
}

i64 cc_support$nextpoweroftwo(i64 x) {
        i64 a;
    if ((x == (i64)0)) {
        return (i64)0;
    }
;
    a = (i64)1;
    L798 :;
    while ((a < x)) {
        a <<= (i64)1;
L799 :;
    }
L800 :;
    ;
    return a;
}

void cc_support$loaderror(u8 *mess,u8 *mess2) {
        u8 str[512];
    sprintf((u8 *)str,mess,mess2);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Load Error:",NULL);
    msysc$m_print_str(str,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Stopping",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)45);
}

i64 cc_support$loadfromstdin(u8 *file) {
        u8 src[30000];
        u8 *  p;
        i64 n;
        i64 c;
    if ((cc_decls$nsourcefiles > (i64)2000)) {
        cc_support$loaderror((byte*)"Too many source files",(byte*)"");
    }
;
    ++(cc_decls$nsourcefiles);
    cc_decls$sourcefilepaths[(cc_decls$nsourcefiles)] = mlib$pcm_copyheapstring(file);
    cc_decls$sourcefilenames[(cc_decls$nsourcefiles)] = mlib$pcm_copyheapstring(file);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Reading from stdin. Finish with Ctrl-Z:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    p = (u8 *)src;
    n = (i64)0;
    L801 :;
    while (((c = getchar()) != (i64)-1)) {
        (*(p)++) = (u64)c;
        if ((++(n) >= (i64)30000)) {
            cc_support$loaderror((byte*)"stdin overflow",(byte*)"");
        }
;
L802 :;
    }
L803 :;
    ;
    (*p) = (u64)0u;
    cc_decls$sourcefiletext[(cc_decls$nsourcefiles)] = mlib$pcm_copyheapstring((u8 *)src);
    cc_decls$sourcefilesizes[(cc_decls$nsourcefiles)] = strlen((u8 *)src);
    return cc_decls$nsourcefiles;
}

i64 cc_support$loadsourcefile(u8 *file,u8 *shortfile) {
        u8 *  s;
    if ((cc_decls$nsourcefiles > (i64)2000)) {
        cc_support$loaderror((byte*)"Too many source files",(byte*)"");
    }
;
    ++(cc_decls$nsourcefiles);
    cc_decls$sourcefilepaths[(cc_decls$nsourcefiles)] = mlib$pcm_copyheapstring(file);
    cc_decls$sourcefilenames[(cc_decls$nsourcefiles)] = mlib$pcm_copyheapstring(shortfile);
    s = (u8 *)mlib$readfile(file);
    if (!(!!(s))) {
        cc_support$loaderror((byte*)"LSF can't load ",file);
    }
;
    if (!!(cc_decls$flinesplicing)) {
        s = cc_support$splicelines(s);
    }
;
    cc_decls$sourcefiletext[(cc_decls$nsourcefiles)] = s;
    cc_decls$sourcefilesizes[(cc_decls$nsourcefiles)] = mlib$rfsize;
    (*(s + mlib$rfsize)) = (u64)0u;
    return cc_decls$nsourcefiles;
}

static u8 *cc_support$splicelines(u8 *s) {
        u8 *  t;
        u8 *  u;
    t = (u = (u8 *)mlib$pcm_alloc((strlen(s) + (i64)1)));
    L804 :;
    while (!!((u64)(*s))) {
        if ((((u64)(*s) == (u64)92u) && ((i64)(u64)(*(s + (i64)1)) == (i64)10))) {
            s += (i64)2;
        }
        else if (((((u64)(*s) == (u64)92u) && ((i64)(u64)(*(s + (i64)1)) == (i64)13)) && ((i64)(u64)(*(s + (i64)2)) == (i64)10))) {
            s += (i64)3;
        }
        else {
            (*(t)++) = (u64)(*(s)++);
        }
;
        (*t) = (u64)0u;
L805 :;
    }
L806 :;
    ;
    return u;
}

i64 cc_support$loadbuiltin(u8 *shortfile,u8 *hdrtext) {
    if ((cc_decls$nsourcefiles > (i64)2000)) {
        cc_support$loaderror((byte*)"Too many source files",(byte*)"");
    }
;
    ++(cc_decls$nsourcefiles);
    cc_decls$sourcefilepaths[(cc_decls$nsourcefiles)] = (byte*)"<builtin>";
    cc_decls$sourcefilenames[(cc_decls$nsourcefiles)] = mlib$pcm_copyheapstring(shortfile);
    cc_decls$sourcefiletext[(cc_decls$nsourcefiles)] = mlib$pcm_copyheapstring(hdrtext);
    cc_decls$sourcefilesizes[(cc_decls$nsourcefiles)] = strlen(hdrtext);
    return cc_decls$nsourcefiles;
}

static void cc_support$gs_copytostr(struct mlib$strbuffer *source,u8 *s) {
    if (!!((i64)(*source).length)) {
        memcpy((void *)s,(void *)(*source).strptr,(u64)(i64)(*source).length);
        (*(s + (i64)(*source).length)) = (u64)0u;
    }
    else {
        (*s) = (u64)0u;
    }
;
}

void cc_support$gs_additem(struct mlib$strbuffer *dest,u8 *s) {
        u8 *  d;
        i64 lastchar;
        i64 nextchar;
    d = (*dest).strptr;
    if (!!((i64)(*dest).length)) {
        lastchar = (i64)(u64)(*((d + (i64)(*dest).length) - (i64)1));
        nextchar = (i64)(u64)(*s);
        if ((!!(cc_support$isalphanum(lastchar)) && !!(cc_support$isalphanum(nextchar)))) {
            mlib$strbuffer_add((struct mlib$strbuffer *)dest,(byte*)" ",(i64)-1);
        }
;
    }
;
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,(i64)-1);
}

static i64 cc_support$isalphanum(i64 c) {
    if (((((c >= (i64)65) && (c <= (i64)90)) || ((c >= (i64)97) && (c <= (i64)122))) || ((c >= (i64)48) && (c <= (i64)57)))) {
        return (i64)1;
    }
;
    return (i64)0;
}

static void cc_support$showmacrolineno(void) {
    if (!!(cc_decls$slineno)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\t(Last macro invoked near line",NULL);
        msysc$m_print_i64(cc_decls$slineno,NULL);
        msysc$m_print_str((byte*)"in file",NULL);
        msysc$m_print_str(cc_decls$sourcefilenames[(cc_decls$sfileno)],NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)")",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

// START
void cc_support$start(void) {

}

// START
void cc_tables$start(void) {

}

i64 cc_assembler$assembler(u8 *outputfile,u8 *(*asmfiles)[],u8 *(*dllfiles)[],i64 nasmfiles,i64 ndllfiles,i64 fobj,i64 fcaption,u8 *(*assemsources)[],u8 *entrypointname,i64 fgendll) {
        i64 i;
    cc_assembler$initall();
    for (i=(i64)1;i<=nasmfiles;++i) {
L807 :;
        cc_assembler$addmodule((*asmfiles)[(i)-1]);
L808 :;
    }
L809 :;
    ;
    aa_decls$nsearchlibs = (i64)0;
    aa_decls$searchlibs[(++(aa_decls$nsearchlibs))-1] = (byte*)"msvcrt";
    aa_decls$searchlibs[(++(aa_decls$nsearchlibs))-1] = (byte*)"gdi32";
    aa_decls$searchlibs[(++(aa_decls$nsearchlibs))-1] = (byte*)"user32";
    aa_decls$searchlibs[(++(aa_decls$nsearchlibs))-1] = (byte*)"kernel32";
    for (i=(i64)1;i<=ndllfiles;++i) {
L810 :;
        cc_assembler$addsearchlib((*dllfiles)[(i)-1]);
L811 :;
    }
L812 :;
    ;
    if ((aa_decls$nmodules == (i64)0)) {
        cc_assembler$loaderror((byte*)"No input files specified");
    }
;
    if (!!(fcaption)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Assembling to",NULL);
        msysc$m_print_str(outputfile,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    cc_assembler$loadsourcefiles(assemsources);
    cc_assembler$parsemodules();
    if (!!(fobj)) {
        aa_genss$genss();
        aa_writeobj$writess(outputfile);
    }
    else {
        aa_genss$genss();
        aa_writeexe$initsectiontable();
        aa_writeexe$genexe(entrypointname,(byte*)"",fgendll);
        aa_writeexe$writeexe(outputfile,(i64)0);
    }
;
    return (i64)1;
}

static void cc_assembler$loadsourcefiles(u8 *(*assemsources)[]) {
        i64 i;
        u8 *  source;
    for (i=(i64)1;i<=aa_decls$nmodules;++i) {
L813 :;
        if (!!(assemsources)) {
            source = (*assemsources)[(i)-1];
        }
        else {
            source = (u8 *)mlib$readfile(aa_decls$moduletable[(i)-1].filename);
            if ((source == 0)) {
                cc_assembler$loaderror_s((byte*)"Can't load file: %s",aa_decls$moduletable[(i)-1].filename);
            }
;
        }
;
        aa_decls$moduletable[(i)-1].source = source;
L814 :;
    }
L815 :;
    ;
}

static void cc_assembler$parsemodules(void) {
        i64 i;
        struct aa_lib$mclrec *  m;
    for (i=(i64)1;i<=aa_decls$nmodules;++i) {
L816 :;
        aa_decls$currmoduleno = i;
        aa_decls$modulenamelist = 0;
        aa_parse$readmodule(i);
        aa_parse$checkundefined();
        if (!!(aa_decls$nundefined)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Couldn't assemble - press key",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            exit((i64)1);
        }
;
        cc_assembler$scanglobals();
        cc_assembler$resethashtable();
L817 :;
    }
L818 :;
    ;
    m = (struct aa_lib$mclrec *)aa_lib$mccode;
    L819 :;
    while (!!(m)) {
        cc_assembler$fixopnd((struct aa_decls$opndrec *)(*m).a);
        cc_assembler$fixopnd((struct aa_decls$opndrec *)(*m).b);
        m = (struct aa_lib$mclrec *)(*m).nextmcl;
L820 :;
    }
L821 :;
    ;
}

static void cc_assembler$fixopnd(struct aa_decls$opndrec *a) {
        struct aa_decls$strec *  d;
    if ((a == 0)) {
        return;
    }
;
    if (!!((*a).labeldef)) {
        d = (struct aa_decls$strec *)(*a).labeldef;
        if (!!((*d).basedef)) {
            (*a).labeldef = (struct aa_decls$strec *)(*d).basedef;
        }
;
    }
;
}

static void cc_assembler$initall(void) {
    aa_lex$initlex();
    aa_lib$initlib();
}

static void cc_assembler$loaderror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"\nError:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

static void cc_assembler$loaderror_s(u8 *mess,u8 *s) {
        u8 str[256];
    strcpy((u8 *)str,mess);
    strcat((u8 *)str,mess);
    cc_assembler$loaderror((u8 *)str);
}

static void cc_assembler$addmodule(u8 *name) {
    if ((aa_decls$nmodules >= (i64)2000)) {
        cc_assembler$loaderror((byte*)"Too many modules");
    }
;
    ++(aa_decls$nmodules);
    aa_decls$moduletable[(aa_decls$nmodules)-1].filename = mlib$pcm_copyheapstring(name);
    aa_decls$moduletable[(aa_decls$nmodules)-1].name = mlib$pcm_copyheapstring(mlib$extractfile(name));
    aa_decls$moduletable[(aa_decls$nmodules)-1].source = (byte*)"<empty>";
}

static void cc_assembler$addsearchlib(u8 *name) {
        u8 str[300];
    if ((aa_decls$nsearchlibs >= (i64)30)) {
        cc_assembler$loaderror((byte*)"Too many libraries");
    }
;
    ++(aa_decls$nsearchlibs);
    strcpy((u8 *)str,name);
    str[((strlen(name) - (i64)3))-1] = (u64)0u;
    aa_decls$searchlibs[(aa_decls$nsearchlibs)-1] = mlib$pcm_copyheapstring((u8 *)str);
}

static struct aa_decls$strec *cc_assembler$getemptyst(struct aa_decls$strec *d) {
        struct aa_decls$strec *  dnew;
    if (!!((i64)(*d).ksymbol)) {
        dnew = (struct aa_decls$strec *)mlib$pcm_allocz((i64)128);
        (*dnew).name = (*d).name;
        (*dnew).namelen = (i64)(*d).namelen;
        (*dnew).ksymbol = (i64)(*d).ksymbol;
        (*dnew).subcode = (i64)(*d).subcode;
        (*dnew).regsize = (i64)(*d).regsize;
        return (struct aa_decls$strec *)dnew;
    }
;
    return (struct aa_decls$strec *)0;
}

static struct aa_decls$strec *cc_assembler$findduplname(struct aa_decls$strec *d) {
        struct aa_decls$strec *  e;
    if (!!((*d).basedef)) {
        return (struct aa_decls$strec *)(*d).basedef;
    }
;
    e = (struct aa_decls$strec *)aa_decls$dupltable[((i64)(*d).htfirstindex)];
    L822 :;
    while (!!(e)) {
        if ((((i64)(*d).namelen == (i64)(*e).namelen) && (memcmp((void *)(*d).name,(void *)(*e).name,(u64)(i64)(*d).namelen) == (i64)0))) {
            (*d).basedef = (struct aa_decls$strec *)e;
            return (struct aa_decls$strec *)e;
        }
;
        e = (struct aa_decls$strec *)(*e).nextdupl;
L823 :;
    }
L824 :;
    ;
    return (struct aa_decls$strec *)0;
}

static void cc_assembler$adddupl(struct aa_decls$strec *d) {
    (*d).nextdupl = (struct aa_decls$strec *)aa_decls$dupltable[((i64)(*d).htfirstindex)];
    aa_decls$dupltable[((i64)(*d).htfirstindex)] = (struct aa_decls$strec *)d;
}

static void cc_assembler$scanglobals(void) {
        struct aa_decls$strec *  d;
        struct aa_decls$strec *  e;
    d = (struct aa_decls$strec *)aa_decls$modulenamelist;
    L825 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).symbol;
if (($temp==(i64)21)) {
            e = (struct aa_decls$strec *)cc_assembler$findduplname((struct aa_decls$strec *)d);
            if (!!(e)) {
                                {i64 $temp = (i64)(*e).symbol;
if (($temp==(i64)21)) {
                }
                else if (($temp==(i64)22)) {
                    (*d).symbol = (i64)22;
                    (*d).reftype = ((*e).reftype = (i64)1);
                }
                };
            }
            else {
                aa_lib$addimport((struct aa_decls$strec *)d);
                cc_assembler$adddupl((struct aa_decls$strec *)d);
            }
;
        }
        else if (($temp==(i64)22)) {
            e = (struct aa_decls$strec *)cc_assembler$findduplname((struct aa_decls$strec *)d);
            if (!!(e)) {
                                {i64 $temp = (i64)(*e).symbol;
if (($temp==(i64)21)) {
                    (*e).symbol = (i64)22;
                    (*d).reftype = ((*e).reftype = (i64)1);
                }
                else if (($temp==(i64)22)) {
                    msysc$m_print_startcon();
                    msysc$m_print_str(aa_decls$moduletable[((i64)(*d).moduleno)-1].name,NULL);
                    msysc$m_print_str((*d).name,NULL);
                    msysc$m_print_i64((i64)(*d).htindex,NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    msysc$m_print_startcon();
                    msysc$m_print_str(aa_decls$moduletable[((i64)(*e).moduleno)-1].name,NULL);
                    msysc$m_print_str((*e).name,NULL);
                    msysc$m_print_i64((i64)(*e).htindex,NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    aa_lib$serror_s((byte*)"Multiply-defined global: %s",(*d).name);
                }
                };
            }
            else {
                e = d;
                aa_lib$addimport((struct aa_decls$strec *)d);
                cc_assembler$adddupl((struct aa_decls$strec *)d);
            }
;
        }
        };
        d = (struct aa_decls$strec *)(*d).nextdef;
L826 :;
    }
L827 :;
    ;
}

static void cc_assembler$resethashtable(void) {
        struct aa_decls$strec *  d;
    d = (struct aa_decls$strec *)aa_decls$modulenamelist;
    L828 :;
    while (!!(d)) {
        aa_decls$lexhashtable[((i64)(*d).htindex)] = (struct aa_decls$strec *)cc_assembler$getemptyst((struct aa_decls$strec *)d);
        d = (struct aa_decls$strec *)(*d).nextdef;
L829 :;
    }
L830 :;
    ;
    aa_decls$modulenamelist = 0;
}

// START
void cc_assembler$start(void) {
    aa_decls$start();
    aa_disasm$start();
    aa_genss$start();
    aa_lex$start();
    aa_lib$start();
    aa_mcxdecls$start();
    aa_objdecls$start();
    aa_parse$start();
    aa_tables$start();
    aa_writeexe$start();
    aa_writeobj$start();

}

// START
void aa_decls$start(void) {

}

u8 *aa_disasm$decodeinstr(byte **cptr,byte *baseaddr) {
        i64 n;
        i64 w;
        i64 opc;
        i64 reg;
        i64 op;
        byte *  pstart;
        static u8 str[256];
        u8 str2[128];
        i64 $av_1;
        i64 $av_2;
    aa_disasm$deststr[((i64)1)-1] = (u64)0u;
    pstart = (aa_disasm$codeptr = (*cptr));
    aa_disasm$rex = (i64)0;
    aa_disasm$opsize = (i64)1;
    aa_disasm$f2override = (aa_disasm$f3override = (aa_disasm$sizeoverride = (aa_disasm$addroverride = (i64)0)));
    aa_disasm$basereg = (aa_disasm$indexreg = (aa_disasm$offset = (i64)0));
    //retry:
L831 :;
;
    switch ((opc = (i64)(*(aa_disasm$codeptr)++))) {
    case 0:;
    case 1:;
    case 8:;
    case 9:;
    case 16:;
    case 17:;
    case 24:;
    case 25:;
    case 32:;
    case 33:;
    case 40:;
    case 41:;
    case 48:;
    case 49:;
    case 56:;
    case 57:;
        {
            op = (opc >> (i64)3);
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$getsil(&aa_disasm$rmreg);
            aa_disasm$genstr(aa_disasm$opnames[(op)]);
            aa_disasm$printaddrmode((i64)0);
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
        }
        break;
    case 2:;
    case 3:;
    case 10:;
    case 11:;
    case 18:;
    case 19:;
    case 26:;
    case 27:;
    case 34:;
    case 35:;
    case 42:;
    case 43:;
    case 50:;
    case 51:;
    case 58:;
    case 59:;
        {
            op = (opc >> (i64)3);
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$genstr(aa_disasm$opnames[(op)]);
            aa_disasm$genstr((byte*)" ");
            aa_disasm$getsil(&aa_disasm$rmreg);
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 4:;
    case 5:;
    case 12:;
    case 13:;
    case 20:;
    case 21:;
    case 28:;
    case 29:;
    case 36:;
    case 37:;
    case 44:;
    case 45:;
    case 52:;
    case 53:;
    case 60:;
    case 61:;
        {
            aa_disasm$genstr(aa_disasm$opnames[((opc >> (i64)3))]);
            aa_disasm$genstr((byte*)" ");
            if (!!((opc & (i64)1))) {
                aa_disasm$opsize = (i64)4;
                if (!!(aa_disasm$sizeoverride)) {
                    aa_disasm$opsize = (i64)2;
                }
;
                if (!!((aa_disasm$rex & (i64)8))) {
                    aa_disasm$opsize = (i64)8;
                }
;
            }
;
            aa_disasm$genstr(aa_disasm$strreg((i64)1,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genintd(aa_disasm$readimm());
        }
        break;
    case 15:;
        {
            aa_disasm$decodetwobyteinstr();
        }
        break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
        {
            aa_disasm$rex = opc;
            goto L831 ;
;
        }
        break;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
        {
            reg = aa_disasm$getreg((opc & (i64)7),(aa_disasm$rex & (i64)1));
            aa_disasm$genstr((byte*)"push ");
            aa_disasm$genstr(aa_disasm$strreg(reg,(i64)8));
        }
        break;
    case 88:;
    case 89:;
    case 90:;
    case 91:;
    case 92:;
    case 93:;
    case 94:;
    case 95:;
        {
            reg = aa_disasm$getreg((opc & (i64)7),(aa_disasm$rex & (i64)1));
            aa_disasm$genstr((byte*)"pop ");
            aa_disasm$genstr(aa_disasm$strreg(reg,(i64)8));
        }
        break;
    case 99:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((byte*)"movsxd ");
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = (i64)4;
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 102:;
        {
            aa_disasm$sizeoverride = (i64)1;
            goto L831 ;
;
        }
        break;
    case 103:;
        {
            aa_disasm$addroverride = (i64)1;
            goto L831 ;
;
        }
        break;
    case 104:;
        {
            aa_disasm$genstr((byte*)"push ");
            if (!!(aa_disasm$sizeoverride)) {
                aa_disasm$genintd(aa_disasm$readint16());
            }
            else {
                aa_disasm$genintd(aa_disasm$readint32());
            }
;
        }
        break;
    case 106:;
        {
            aa_disasm$genstr((byte*)"push ");
            aa_disasm$genintd(aa_disasm$readsbyte());
        }
        break;
    case 105:;
    case 107:;
        {
            aa_disasm$decodeaddr((i64)1);
            if ((aa_disasm$basereg != aa_disasm$rmreg)) {
                aa_disasm$genstr((byte*)"imul3");
                aa_disasm$genstr((byte*)" ");
                aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
                aa_disasm$genstr((byte*)", ");
            }
            else {
                aa_disasm$genstr((byte*)"imul2");
            }
;
            aa_disasm$printaddrmode((i64)0);
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = (!!((opc & (i64)2)) ? (i64)1 : aa_disasm$opsize);
            aa_disasm$genintd(aa_disasm$readimm());
        }
        break;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    case 125:;
    case 126:;
    case 127:;
        {
            aa_disasm$genstr((byte*)"j");
            aa_disasm$genstr(aa_disasm$condnames[((opc & (i64)15))]);
            aa_disasm$genstr((byte*)" ");
            aa_disasm$genintd(aa_disasm$readsbyte());
        }
        break;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
        {
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$genstr(aa_disasm$opnames[(aa_disasm$rmopc)]);
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$printaddrmode((i64)0);
            aa_disasm$genstr((byte*)", ");
            if ((opc != (i64)131)) {
                aa_disasm$genintd(aa_disasm$readimm());
            }
            else {
                aa_disasm$genintd(aa_disasm$readsbyte());
            }
;
        }
        break;
    case 132:;
    case 133:;
        {
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$getsil(&aa_disasm$rmreg);
            aa_disasm$genstr((byte*)"test ");
            aa_disasm$printaddrmode((i64)0);
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
        }
        break;
    case 134:;
    case 135:;
        {
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$genstr((byte*)"exch2 ");
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$getsil(&aa_disasm$rmreg);
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)",");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 136:;
    case 137:;
        {
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$genstr((byte*)"mov");
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$getsil(&aa_disasm$rmreg);
            aa_disasm$printaddrmode((i64)0);
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
        }
        break;
    case 138:;
    case 139:;
        {
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$genstr((byte*)"mov ");
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$getsil(&aa_disasm$rmreg);
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 141:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((byte*)"lea ");
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 143:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$opsize = (i64)1;
            aa_disasm$genstr((byte*)"pop");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 144:;
        {
            if (!!(aa_disasm$rex)) {
                goto L832 ;
;
            }
;
            aa_disasm$genstr((byte*)"nop");
        }
        break;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
        {
            //doexch:
L832 :;
;
            reg = ((opc & (i64)7) + (i64)1);
            if (!!((aa_disasm$rex & (i64)1))) {
                reg += (i64)8;
            }
;
            aa_disasm$opsize = (!!(aa_disasm$sizeoverride) ? (i64)2 : (i64)4);
            if (!!((aa_disasm$rex & (i64)8))) {
                aa_disasm$opsize = (i64)8;
            }
;
            aa_disasm$genstr((byte*)"xchg ");
            aa_disasm$genstr(aa_disasm$strreg((i64)1,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genstr(aa_disasm$strreg(reg,aa_disasm$opsize));
        }
        break;
    case 152:;
        {
            if (!!(aa_disasm$sizeoverride)) {
                aa_disasm$genstr((byte*)"cbw");
            }
            else {
                aa_disasm$genstr((byte*)"cbw???");
            }
;
        }
        break;
    case 153:;
        {
            if (!!(aa_disasm$sizeoverride)) {
                aa_disasm$genstr((byte*)"cwd");
            }
            else if (!!((aa_disasm$rex & (i64)8))) {
                aa_disasm$genstr((byte*)"cqo");
            }
            else {
                aa_disasm$genstr((byte*)"cdq");
            }
;
        }
        break;
    case 155:;
        {
            aa_disasm$genstr((byte*)"wait");
        }
        break;
    case 156:;
        {
            aa_disasm$genstr((byte*)"pushf");
        }
        break;
    case 157:;
        {
            aa_disasm$genstr((byte*)"popf");
        }
        break;
    case 158:;
        {
            aa_disasm$genstr((byte*)"sahf");
        }
        break;
    case 159:;
        {
            aa_disasm$genstr((byte*)"lahf");
        }
        break;
    case 164:;
    case 165:;
    case 166:;
    case 167:;
    case 170:;
    case 171:;
    case 172:;
    case 173:;
    case 174:;
    case 175:;
        {
            aa_disasm$genstr((((opc >> (i64)1) & (i64)7)==1?(byte*)"?":(((opc >> (i64)1) & (i64)7)==2?(byte*)"movs":(((opc >> (i64)1) & (i64)7)==3?(byte*)"cmps":(((opc >> (i64)1) & (i64)7)==4?(byte*)"?":(((opc >> (i64)1) & (i64)7)==5?(byte*)"stos":(((opc >> (i64)1) & (i64)7)==6?(byte*)"lods":(((opc >> (i64)1) & (i64)7)==7?(byte*)"scas":(byte*)"?"))))))));
            if (((opc & (i64)1) == (i64)0)) {
                aa_disasm$genstr((byte*)"b");
            }
            else {
                if (!!((aa_disasm$rex & (i64)8))) {
                    aa_disasm$genstr((byte*)"q");
                }
                else if (!!(aa_disasm$sizeoverride)) {
                    aa_disasm$genstr((byte*)"w");
                }
                else {
                    aa_disasm$genstr((byte*)"d");
                }
;
            }
;
        }
        break;
    case 168:;
    case 169:;
        {
            aa_disasm$genstr((byte*)"test ");
            if (!!((opc & (i64)1))) {
                aa_disasm$opsize = (!!(aa_disasm$sizeoverride) ? (i64)2 : (i64)4);
                if (!!((aa_disasm$rex & (i64)8))) {
                    aa_disasm$opsize = (i64)8;
                }
;
            }
;
            aa_disasm$genstr(aa_disasm$strreg((i64)1,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genintd(aa_disasm$readimm());
        }
        break;
    case 176:;
    case 177:;
    case 178:;
    case 179:;
    case 180:;
    case 181:;
    case 182:;
    case 183:;
    case 184:;
    case 185:;
    case 186:;
    case 187:;
    case 188:;
    case 189:;
    case 190:;
    case 191:;
        {
            reg = ((opc & (i64)7) + (i64)1);
            if (!!((aa_disasm$rex & (i64)1))) {
                reg += (i64)8;
            }
;
            if (!!((opc & (i64)8))) {
                aa_disasm$opsize = (!!(aa_disasm$sizeoverride) ? (i64)2 : (i64)4);
                if (!!((aa_disasm$rex & (i64)8))) {
                    aa_disasm$opsize = (i64)8;
                }
;
            }
;
            aa_disasm$genstr((byte*)"mov ");
            aa_disasm$getsil(&reg);
            aa_disasm$genstr(aa_disasm$strreg(reg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genintd(aa_disasm$readimm8());
        }
        break;
    case 192:;
    case 193:;
    case 208:;
    case 209:;
    case 210:;
    case 211:;
        {
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$genstr(((aa_disasm$rmopc + (i64)1)==1?(byte*)"rol":((aa_disasm$rmopc + (i64)1)==2?(byte*)"ror":((aa_disasm$rmopc + (i64)1)==3?(byte*)"rcl":((aa_disasm$rmopc + (i64)1)==4?(byte*)"rcr":((aa_disasm$rmopc + (i64)1)==5?(byte*)"shl":((aa_disasm$rmopc + (i64)1)==6?(byte*)"shr":((aa_disasm$rmopc + (i64)1)==7?(byte*)"?":((aa_disasm$rmopc + (i64)1)==8?(byte*)"sar":(byte*)"?")))))))));
            aa_disasm$printaddrmode((i64)0);
            if ((opc <= (i64)193)) {
                aa_disasm$genstr((byte*)", ");
                aa_disasm$genintd(aa_disasm$readbyte());
            }
            else {
                aa_disasm$genstr((!!((opc & (i64)2)) ? (byte*)", cl" : (byte*)", 1"));
            }
;
        }
        break;
    case 194:;
        {
            aa_disasm$genstr((byte*)"retn ");
            aa_disasm$genintd((i64)aa_disasm$readword16());
        }
        break;
    case 195:;
        {
            aa_disasm$genstr((byte*)"ret");
        }
        break;
    case 198:;
    case 199:;
        {
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$genstr((byte*)"mov");
            aa_disasm$printaddrmode((i64)0);
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genintd(aa_disasm$readimm());
        }
        break;
    case 215:;
        {
            aa_disasm$genstr((byte*)"xlat");
        }
        break;
    case 216:;
    case 217:;
    case 218:;
    case 219:;
    case 220:;
    case 221:;
    case 222:;
    case 223:;
        {
            aa_disasm$decode8087((opc & (i64)7));
        }
        break;
    case 224:;
        {
            aa_disasm$genstr((byte*)"loopnz ");
            aa_disasm$genintd(aa_disasm$readsbyte());
        }
        break;
    case 225:;
        {
            aa_disasm$genstr((byte*)"loopz ");
            aa_disasm$genintd(aa_disasm$readsbyte());
        }
        break;
    case 226:;
        {
            aa_disasm$genstr((byte*)"loop ");
            aa_disasm$genintd(aa_disasm$readsbyte());
        }
        break;
    case 227:;
        {
            if (!!(aa_disasm$addroverride)) {
                aa_disasm$genstr((byte*)"jecxz ");
            }
            else {
                aa_disasm$genstr((byte*)"jrcxz ");
            }
;
            aa_disasm$genintd(aa_disasm$readsbyte());
        }
        break;
    case 232:;
        {
            aa_disasm$genstr((byte*)"call ");
            aa_disasm$genintd(aa_disasm$readint32());
        }
        break;
    case 233:;
        {
            aa_disasm$genstr((byte*)"[4] jmp ");
            aa_disasm$genintd(aa_disasm$readint32());
        }
        break;
    case 235:;
        {
            aa_disasm$genstr((byte*)"jmp ");
            aa_disasm$genintd(aa_disasm$readsbyte());
        }
        break;
    case 242:;
        {
            if ((((i64)(*aa_disasm$codeptr) != (i64)15) && (((i64)(*aa_disasm$codeptr) < (i64)64) && ((i64)(*aa_disasm$codeptr) > (i64)79)))) {
                aa_disasm$genstr((byte*)"repne");
            }
            else {
                aa_disasm$f2override = (i64)1;
                goto L831 ;
;
            }
;
        }
        break;
    case 243:;
        {
            if ((((i64)(*aa_disasm$codeptr) != (i64)15) && (((i64)(*aa_disasm$codeptr) < (i64)64) && ((i64)(*aa_disasm$codeptr) > (i64)79)))) {
                aa_disasm$genstr((byte*)"repe");
            }
            else {
                aa_disasm$f3override = (i64)1;
                goto L831 ;
;
            }
;
        }
        break;
    case 244:;
        {
        }
        break;
    case 246:;
    case 247:;
        {
            aa_disasm$decodeaddr((opc & (i64)1));
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$genstr(((aa_disasm$rmopc + (i64)1)==1?(byte*)"test":((aa_disasm$rmopc + (i64)1)==2?(byte*)"?":((aa_disasm$rmopc + (i64)1)==3?(byte*)"not":((aa_disasm$rmopc + (i64)1)==4?(byte*)"neg":((aa_disasm$rmopc + (i64)1)==5?(byte*)"mul":((aa_disasm$rmopc + (i64)1)==6?(byte*)"imul":((aa_disasm$rmopc + (i64)1)==7?(byte*)"div":((aa_disasm$rmopc + (i64)1)==8?(byte*)"idiv":(byte*)"?")))))))));
            aa_disasm$printaddrmode((i64)0);
            if ((aa_disasm$rmopc == (i64)0)) {
                if ((aa_disasm$opsize == (i64)8)) {
                    aa_disasm$opsize = (i64)4;
                }
;
                aa_disasm$genstr((byte*)", ");
                aa_disasm$genintd(aa_disasm$readimm());
            }
;
        }
        break;
    case 254:;
        {
            w = (i64)0;
            goto L833 ;
;
        }
        break;
    case 255:;
        {
            w = (i64)1;
            //doff:
L833 :;
;
            aa_disasm$decodeaddr(w);
            if ((aa_disasm$rmopc==(i64)0)) {
                aa_disasm$getsilx(&aa_disasm$basereg);
                aa_disasm$genstr((byte*)"inc");
            }
            else if ((aa_disasm$rmopc==(i64)1)) {
                aa_disasm$getsilx(&aa_disasm$basereg);
                aa_disasm$genstr((byte*)"dec");
            }
            else if ((aa_disasm$rmopc==(i64)2)) {
                aa_disasm$opsize = (i64)8;
                aa_disasm$genstr((byte*)"icall");
            }
            else if ((aa_disasm$rmopc==(i64)4)) {
                aa_disasm$opsize = (i64)8;
                aa_disasm$genstr((byte*)"jmp");
            }
            else if ((aa_disasm$rmopc==(i64)6)) {
                aa_disasm$opsize = (i64)8;
                aa_disasm$genstr((byte*)"push");
            }
            else {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"FFxx?",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
;
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    default: {
        aa_disasm$genstr((byte*)"Unknown opcode: ");
        aa_disasm$genhex(opc);
    }
    } //SW
;
    msysc$m_print_startstr(str);
    msysc$m_print_ptr(baseaddr,(byte*)"z6h");
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)": ",NULL);
    msysc$m_print_end();
    ;
    n = (aa_disasm$codeptr - pstart);
    $av_1 = n;
    while ($av_1-- > 0) {
L834 :;
        msysc$m_print_startstr(str2);
        msysc$m_print_i64((i64)(*(pstart)++),(byte*)"z2H");
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
        strcat((u8 *)str,(u8 *)str2);
L835 :;
    }
L836 :;
    ;
    $av_2 = ((i64)14 - n);
    while ($av_2-- > 0) {
L837 :;
        strcat((u8 *)str,(byte*)"-- ");
L838 :;
    }
L839 :;
    ;
    strcat((u8 *)str,(u8 *)aa_disasm$deststr);
    (*cptr) = aa_disasm$codeptr;
    return (u8 *)str;
}

static void aa_disasm$decodetwobyteinstr(void) {
        i64 opc;
        i64 rhssize;
        i64 third;
        i64 imm;
        u8 *  opcstr;
    switch ((opc = (i64)(*(aa_disasm$codeptr)++))) {
    case 42:;
        {
            aa_disasm$decodeaddr((i64)1);
            if (!!(aa_disasm$f3override)) {
                aa_disasm$genstr((byte*)"cvtsi2ss ");
            }
            else {
                aa_disasm$genstr((byte*)"cvtsi2sd ");
            }
;
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 44:;
        {
            aa_disasm$decodeaddr((i64)1);
            if (!!(aa_disasm$f3override)) {
                aa_disasm$genstr((byte*)"cvttss2si ");
                rhssize = (i64)4;
            }
            else {
                aa_disasm$genstr((byte*)"cvttsd2si ");
                rhssize = (i64)8;
            }
;
            if (!!((aa_disasm$rex & (i64)8))) {
                aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,(i64)8));
            }
            else {
                aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,(i64)4));
            }
;
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = rhssize;
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 45:;
        {
            aa_disasm$decodeaddr((i64)1);
            if (!!(aa_disasm$f3override)) {
                aa_disasm$genstr((byte*)"cvtss2si ");
                rhssize = (i64)4;
            }
            else {
                aa_disasm$genstr((byte*)"cvtsd2si ");
                rhssize = (i64)8;
            }
;
            if (!!((aa_disasm$rex & (i64)8))) {
                aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,(i64)8));
            }
            else {
                aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,(i64)4));
            }
;
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = rhssize;
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 47:;
        {
            aa_disasm$decodeaddr((i64)1);
            if (!!(aa_disasm$sizeoverride)) {
                aa_disasm$opsize = (i64)8;
                aa_disasm$genstr((byte*)"comisd ");
            }
            else {
                aa_disasm$opsize = (i64)4;
                aa_disasm$genstr((byte*)"comiss ");
            }
;
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 58:;
        {
            third = (i64)(*(aa_disasm$codeptr)++);
            if ((third==(i64)99)) {
                aa_disasm$genstr((byte*)"pcmpistri ");
            }
            else if ((third==(i64)98)) {
                aa_disasm$genstr((byte*)"pcmpistrm ");
            }
            else {
                aa_disasm$genstr((byte*)"Unknown opcode 2-byte opcode: 0F ");
                aa_disasm$genhex(opc);
                return;
            }
;
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)1);
            aa_disasm$genstr((byte*)", ");
            imm = (i64)(*(aa_disasm$codeptr)++);
            aa_disasm$genintd(imm);
        }
        break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((byte*)"cmov");
            aa_disasm$genstr(aa_disasm$condnames[((opc & (i64)15))]);
            aa_disasm$genstr((byte*)" ");
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 81:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$opsize = (!!(aa_disasm$f3override) ? (i64)4 : (i64)8);
            aa_disasm$genstr(((aa_disasm$opsize == (i64)4) ? (byte*)"sqrtss " : (byte*)"sqrtsd "));
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 84:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((!!(aa_disasm$sizeoverride) ? (byte*)"andpd " : (byte*)"andps "));
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = (!!(aa_disasm$sizeoverride) ? (i64)8 : (i64)4);
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 87:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((!!(aa_disasm$sizeoverride) ? (byte*)"xorpd " : (byte*)"xorps "));
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = (!!(aa_disasm$sizeoverride) ? (i64)8 : (i64)4);
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 88:;
        {
            opcstr = (byte*)"adds";
            //doarith:
L840 :;
;
            aa_disasm$genstr(opcstr);
            aa_disasm$decodeaddr((i64)1);
            if (!!(aa_disasm$f2override)) {
                aa_disasm$opsize = (i64)8;
                aa_disasm$genstr((byte*)"d ");
            }
            else {
                aa_disasm$opsize = (i64)4;
                aa_disasm$genstr((byte*)"s ");
            }
;
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 89:;
        {
            opcstr = (byte*)"muls";
            goto L840 ;
;
        }
        break;
    case 90:;
        {
            aa_disasm$decodeaddr((i64)1);
            if (!!(aa_disasm$f3override)) {
                aa_disasm$genstr((byte*)"cvtss2sd ");
                rhssize = (i64)4;
            }
            else {
                aa_disasm$genstr((byte*)"cvtsd2ss ");
                rhssize = (i64)8;
            }
;
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = rhssize;
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 92:;
        {
            opcstr = (byte*)"subs";
            goto L840 ;
;
        }
        break;
    case 93:;
        {
            opcstr = (byte*)"mins";
            goto L840 ;
;
        }
        break;
    case 94:;
        {
            opcstr = (byte*)"divs";
            goto L840 ;
;
        }
        break;
    case 95:;
        {
            opcstr = (byte*)"maxs";
            goto L840 ;
;
        }
        break;
    case 110:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$opsize = (!!((aa_disasm$rex & (i64)8)) ? (i64)8 : (i64)4);
            aa_disasm$genstr(((aa_disasm$opsize == (i64)4) ? (byte*)"movd " : (byte*)"movq "));
            if (!!(aa_disasm$sizeoverride)) {
                aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            }
            else {
                aa_disasm$genstr(aa_disasm$strmmx(aa_disasm$rmreg));
            }
;
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 111:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$opsize = (i64)16;
            if (!!(aa_disasm$sizeoverride)) {
                aa_disasm$genstr((byte*)"movdqa ");
            }
            else if (!!(aa_disasm$f3override)) {
                aa_disasm$genstr((byte*)"movdqu ");
            }
            else {
                aa_disasm$genstr((byte*)"No 66/F3 ");
            }
;
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 126:;
        {
            aa_disasm$decodeaddr((i64)1);
            if (!!(aa_disasm$f3override)) {
                aa_disasm$opsize = (i64)8;
                aa_disasm$genstr((byte*)"movq ");
                aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
                aa_disasm$genstr((byte*)", ");
                aa_disasm$printaddrmode((i64)1);
            }
            else if (!!((aa_disasm$rex & (i64)8))) {
                aa_disasm$opsize = (i64)8;
                aa_disasm$genstr((byte*)"movq ");
                aa_disasm$printaddrmode((i64)0);
                aa_disasm$genstr((byte*)", ");
                aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            }
            else {
                aa_disasm$opsize = (i64)4;
                aa_disasm$genstr((byte*)"movd ");
                aa_disasm$printaddrmode((i64)0);
                aa_disasm$genstr((byte*)", ");
                if (!!(aa_disasm$sizeoverride)) {
                    aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
                }
                else {
                    aa_disasm$genstr(aa_disasm$strmmx(aa_disasm$rmreg));
                }
;
            }
;
        }
        break;
    case 127:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$opsize = (i64)16;
            if (!!(aa_disasm$sizeoverride)) {
                aa_disasm$genstr((byte*)"movdqa ");
            }
            else if (!!(aa_disasm$f3override)) {
                aa_disasm$genstr((byte*)"movdqu ");
            }
            else {
                aa_disasm$genstr((byte*)"No 66/F3 ");
            }
;
            aa_disasm$printaddrmode((i64)1);
            aa_disasm$genstr((byte*)", ");
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
        }
        break;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    case 132:;
    case 133:;
    case 134:;
    case 135:;
    case 136:;
    case 137:;
    case 138:;
    case 139:;
    case 140:;
    case 141:;
    case 142:;
    case 143:;
        {
            aa_disasm$genstr((byte*)"[long] j");
            aa_disasm$genstr(aa_disasm$condnames[((opc & (i64)15))]);
            aa_disasm$genstr((byte*)" ");
            if (!!(aa_disasm$sizeoverride)) {
                aa_disasm$genintd(aa_disasm$readint16());
            }
            else {
                aa_disasm$genintd(aa_disasm$readint32());
            }
;
        }
        break;
    case 144:;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
    case 152:;
    case 153:;
    case 154:;
    case 155:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
        {
            aa_disasm$decodeaddr((i64)0);
            aa_disasm$genstr((byte*)"set");
            aa_disasm$genstr(aa_disasm$condnames[((opc & (i64)15))]);
            aa_disasm$genstr((byte*)" ");
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 175:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((byte*)"imul ");
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 182:;
    case 183:;
    case 190:;
    case 191:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr(((opc < (i64)190) ? (byte*)"movzx " : (byte*)"movsx "));
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = (!!((opc & (i64)1)) ? (i64)2 : (i64)1);
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 184:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((byte*)"popcnt ");
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 188:;
    case 189:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr(((opc == (i64)188) ? (byte*)"bsf " : (byte*)"bsr "));
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$rmreg,aa_disasm$opsize));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$printaddrmode((i64)0);
        }
        break;
    case 214:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$opsize = (i64)8;
            aa_disasm$genstr((byte*)"movq ");
            aa_disasm$printaddrmode((i64)1);
            aa_disasm$genstr((byte*)",");
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
        }
        break;
    case 219:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((byte*)"pand ");
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = (i64)8;
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    case 239:;
        {
            aa_disasm$decodeaddr((i64)1);
            aa_disasm$genstr((byte*)"pxor ");
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$rmreg));
            aa_disasm$genstr((byte*)", ");
            aa_disasm$opsize = (i64)8;
            aa_disasm$printaddrmode((i64)1);
        }
        break;
    default: {
        //error:
L841 :;
;
        aa_disasm$genstr((byte*)"Unknown opcode 2-byte opcode: 0F ");
        aa_disasm$genhex(opc);
    }
    } //SW
;
}

static void aa_disasm$decodeaddr(i64 w) {
        i64 modrm;
        i64 xxx;
        i64 mode;
        i64 sib;
        i64 rm;
    aa_disasm$basereg = (aa_disasm$indexreg = (i64)0);
    aa_disasm$scale = (i64)1;
    aa_disasm$offset = (i64)0;
    aa_disasm$ripmode = (i64)0;
    if (!!(w)) {
        aa_disasm$opsize = (!!(aa_disasm$sizeoverride) ? (i64)2 : (i64)4);
        if (!!((aa_disasm$rex & (i64)8))) {
            aa_disasm$opsize = (i64)8;
        }
;
    }
    else {
        aa_disasm$opsize = (i64)1;
    }
;
    modrm = (i64)(*(aa_disasm$codeptr)++);
    mode = (modrm >> (i64)6);
    xxx = ((modrm >> (i64)3) & (i64)7);
    rm = (modrm & (i64)7);
    if ((mode == (i64)3)) {
        aa_disasm$basereg = (rm + (i64)1);
        aa_disasm$addrmode = (i64)1;
    }
    else if ((rm != (i64)4)) {
        if (((mode == (i64)0) && (rm == (i64)5))) {
            aa_disasm$offset = aa_disasm$readint32();
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"RIP?",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            aa_disasm$ripmode = (i64)1;
            aa_disasm$addrmode = (i64)2;
        }
        else {
            aa_disasm$basereg = (rm + (i64)1);
            aa_disasm$addrmode = (i64)2;
            if ((mode==(i64)1)) {
                aa_disasm$offset = aa_disasm$readsbyte();
            }
            else if ((mode==(i64)2)) {
                aa_disasm$offset = aa_disasm$readint32();
            }
;
        }
;
    }
    else {
        aa_disasm$addrmode = (i64)2;
        sib = aa_disasm$readbyte();
        aa_disasm$indexreg = (((sib >> (i64)3) & (i64)7) + (i64)1);
        aa_disasm$basereg = ((sib & (i64)7) + (i64)1);
        aa_disasm$scale = (((sib >> (i64)6) + (i64)1)==1?(i64)1:(((sib >> (i64)6) + (i64)1)==2?(i64)2:(((sib >> (i64)6) + (i64)1)==3?(i64)4:(((sib >> (i64)6) + (i64)1)==4?(i64)8:(i64)0))));
        if ((((mode == (i64)0) && (aa_disasm$basereg == (i64)6)) && (aa_disasm$indexreg == (i64)5))) {
            aa_disasm$indexreg = (aa_disasm$basereg = (i64)0);
            aa_disasm$offset = aa_disasm$readint32();
        }
        else if (((mode == (i64)0) && (aa_disasm$basereg == (i64)6))) {
            aa_disasm$basereg = (i64)0;
            aa_disasm$offset = aa_disasm$readint32();
        }
        else if (((mode == (i64)0) && (aa_disasm$indexreg == (i64)5))) {
            aa_disasm$indexreg = (i64)0;
        }
        else {
            if ((mode==(i64)1)) {
                aa_disasm$offset = aa_disasm$readsbyte();
            }
            else if ((mode==(i64)2)) {
                aa_disasm$offset = aa_disasm$readint32();
            }
;
            if ((aa_disasm$indexreg == (i64)5)) {
                aa_disasm$indexreg = (i64)0;
            }
;
        }
;
    }
;
    if ((!!(aa_disasm$basereg) && !!((aa_disasm$rex & (i64)1)))) {
        aa_disasm$basereg += (i64)8;
    }
;
    if ((!!(aa_disasm$indexreg) && !!((aa_disasm$rex & (i64)2)))) {
        aa_disasm$indexreg += (i64)8;
    }
;
    aa_disasm$rmreg = (xxx + (i64)1);
    if (!!((aa_disasm$rex & (i64)4))) {
        aa_disasm$rmreg += (i64)8;
    }
;
    aa_disasm$rmopc = xxx;
}

static i64 aa_disasm$readbyte(void) {
    return (i64)(*(aa_disasm$codeptr)++);
}

static i64 aa_disasm$readsbyte(void) {
    return (i64)(*(i8 *)(aa_disasm$codeptr)++);
}

static u64 aa_disasm$readword16(void) {
        u64 a;
    a = (u64)(i64)(*(u16 *)aa_disasm$codeptr);
    aa_disasm$codeptr += (i64)2;
    return a;
}

static i64 aa_disasm$readint16(void) {
        i64 a;
    a = (i64)(*(i16 *)aa_disasm$codeptr);
    aa_disasm$codeptr += (i64)2;
    return a;
}

static u64 aa_disasm$readword32(void) {
        u64 a;
    a = (u64)(i64)(*(u32 *)aa_disasm$codeptr);
    aa_disasm$codeptr += (i64)4;
    return a;
}

static i64 aa_disasm$readint32(void) {
        i64 a;
    a = (i64)(*(i32 *)aa_disasm$codeptr);
    aa_disasm$codeptr += (i64)4;
    return a;
}

static i64 aa_disasm$readint64(void) {
        i64 a;
    a = (*(i64 *)aa_disasm$codeptr);
    aa_disasm$codeptr += (i64)8;
    return a;
}

static i64 aa_disasm$getreg(i64 regcode,i64 upper) {
    if (!!(upper)) {
        return ((regcode + (i64)8) + (i64)1);
    }
;
    return (regcode + (i64)1);
}

u8 *aa_disasm$strreg(i64 reg,i64 opsize) {
        static u8 *  regnames8[20] = {
    (byte*)"al",
    (byte*)"cl",
    (byte*)"dl",
    (byte*)"bl",
    (byte*)"spl",
    (byte*)"bpl",
    (byte*)"sil",
    (byte*)"dil",
    (byte*)"r8b",
    (byte*)"r9b",
    (byte*)"r10b",
    (byte*)"r11b",
    (byte*)"r12b",
    (byte*)"r13b",
    (byte*)"r14b",
    (byte*)"r15b",
    (byte*)"ah",
    (byte*)"bh",
    (byte*)"ch",
    (byte*)"dh"
};
        static u8 *  regnames16[16] = {
    (byte*)"ax",
    (byte*)"cx",
    (byte*)"dx",
    (byte*)"bx",
    (byte*)"sp",
    (byte*)"bp",
    (byte*)"si",
    (byte*)"di",
    (byte*)"r8w",
    (byte*)"r9w",
    (byte*)"r10w",
    (byte*)"r11w",
    (byte*)"r12w",
    (byte*)"r13w",
    (byte*)"r14w",
    (byte*)"r15w"
};
        static u8 *  regnames32[16] = {
    (byte*)"eax",
    (byte*)"ecx",
    (byte*)"edx",
    (byte*)"ebx",
    (byte*)"esp",
    (byte*)"ebp",
    (byte*)"esi",
    (byte*)"edi",
    (byte*)"r8d",
    (byte*)"r9d",
    (byte*)"r10d",
    (byte*)"r11d",
    (byte*)"r12d",
    (byte*)"r13d",
    (byte*)"r14d",
    (byte*)"r15d"
};
        static u8 *  regnames64[16] = {
    (byte*)"rax",
    (byte*)"rcx",
    (byte*)"rdx",
    (byte*)"rbx",
    (byte*)"rsp",
    (byte*)"rbp",
    (byte*)"rsi",
    (byte*)"rdi",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15"
};
        static u8 *  mregnames8[20] = {
    (byte*)"B0",
    (byte*)"B10",
    (byte*)"B11",
    (byte*)"B4",
    (byte*)"B15",
    (byte*)"B14",
    (byte*)"B5",
    (byte*)"B3",
    (byte*)"B12",
    (byte*)"B13",
    (byte*)"B1",
    (byte*)"B2",
    (byte*)"B6",
    (byte*)"B7",
    (byte*)"B8",
    (byte*)"B9",
    (byte*)"B16",
    (byte*)"B18",
    (byte*)"B19",
    (byte*)"B17"
};
        static u8 *  mregnames16[16] = {
    (byte*)"W0",
    (byte*)"W10",
    (byte*)"W11",
    (byte*)"W4",
    (byte*)"Wsp",
    (byte*)"Wbp",
    (byte*)"W5",
    (byte*)"W3",
    (byte*)"W12",
    (byte*)"W13",
    (byte*)"W1",
    (byte*)"W2",
    (byte*)"W6",
    (byte*)"W7",
    (byte*)"W8",
    (byte*)"W9"
};
        static u8 *  mregnames32[16] = {
    (byte*)"A0",
    (byte*)"A10",
    (byte*)"A11",
    (byte*)"A4",
    (byte*)"Astack",
    (byte*)"Aframe",
    (byte*)"A5",
    (byte*)"A3",
    (byte*)"A12",
    (byte*)"A13",
    (byte*)"A1",
    (byte*)"A2",
    (byte*)"A6",
    (byte*)"A7",
    (byte*)"A8",
    (byte*)"A9"
};
        static u8 *  mregnames64[16] = {
    (byte*)"D0",
    (byte*)"D10",
    (byte*)"D11",
    (byte*)"D4",
    (byte*)"Dstack",
    (byte*)"Dframe",
    (byte*)"D5",
    (byte*)"D3",
    (byte*)"D12",
    (byte*)"D13",
    (byte*)"D1",
    (byte*)"D2",
    (byte*)"D6",
    (byte*)"D7",
    (byte*)"D8",
    (byte*)"D9"
};
    if ((reg == (i64)0)) {
        return (byte*)"<>";
    }
;
    if ((u64)0u) {
        if ((opsize==(i64)1)) {
            return mregnames8[(reg)-1];
        }
        else if ((opsize==(i64)2)) {
            return mregnames16[(reg)-1];
        }
        else if ((opsize==(i64)4)) {
            return mregnames32[(reg)-1];
        }
        else if ((opsize==(i64)8)) {
            return mregnames64[(reg)-1];
        }
;
    }
    else {
        if ((opsize==(i64)1)) {
            return regnames8[(reg)-1];
        }
        else if ((opsize==(i64)2)) {
            return regnames16[(reg)-1];
        }
        else if ((opsize==(i64)4)) {
            return regnames32[(reg)-1];
        }
        else if ((opsize==(i64)8)) {
            return regnames64[(reg)-1];
        }
;
    }
;
    return (byte*)"";
}

static u8 *aa_disasm$strfreg(i64 freg) {
        static u8 *  fregnames[8] = {(byte*)"st0",(byte*)"st1",(byte*)"st2",(byte*)"st3",(byte*)"st4",(byte*)"st5",(byte*)"st6",(byte*)"st7"};
    return fregnames[(freg)-1];
}

static void aa_disasm$printaddrmode(i64 xmm) {
        u8 *  plus;
        i64 addrsize;
    aa_disasm$genstr((byte*)" ");
    if ((aa_disasm$addrmode==(i64)1)) {
        if (!!(xmm)) {
            aa_disasm$genstr(aa_disasm$strxmm(aa_disasm$basereg));
        }
        else {
            aa_disasm$getsilx(&aa_disasm$basereg);
            aa_disasm$genstr(aa_disasm$strreg(aa_disasm$basereg,aa_disasm$opsize));
        }
;
        return;
    }
;
    if ((aa_disasm$opsize==(i64)1)) {
        aa_disasm$genstr((byte*)"byte ");
    }
    else if ((aa_disasm$opsize==(i64)2)) {
        aa_disasm$genstr((byte*)"word ");
    }
    else if ((aa_disasm$opsize==(i64)4)) {
        aa_disasm$genstr((byte*)"dword ");
    }
    else if ((aa_disasm$opsize==(i64)8)) {
        aa_disasm$genstr((byte*)"qword ");
    }
    else if ((aa_disasm$opsize==(i64)10)) {
        aa_disasm$genstr((byte*)"tword ");
    }
    else if ((aa_disasm$opsize==(i64)16)) {
        aa_disasm$genstr((byte*)"oword ");
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"///OPSIZE",NULL);
        msysc$m_print_i64(aa_disasm$opsize,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if (!!(aa_disasm$ripmode)) {
        aa_disasm$genstr((byte*)"rip:");
    }
;
    aa_disasm$genstr((byte*)"[");
    plus = (byte*)"";
    addrsize = (!!(aa_disasm$addroverride) ? (i64)4 : (i64)8);
    if (!!(aa_disasm$basereg)) {
        aa_disasm$genstr(aa_disasm$strreg(aa_disasm$basereg,addrsize));
        plus = (byte*)"+";
    }
;
    if (!!(aa_disasm$indexreg)) {
        aa_disasm$genstr(plus);
        aa_disasm$genstr(aa_disasm$strreg(aa_disasm$indexreg,addrsize));
        aa_disasm$genstr((byte*)"<INDEX>");
        if ((aa_disasm$scale > (i64)1)) {
            aa_disasm$genstr((byte*)"*");
            aa_disasm$genintd(aa_disasm$scale);
        }
;
        plus = (byte*)"+";
    }
;
    if ((!!(aa_disasm$offset) || ((aa_disasm$basereg == (i64)0) && (aa_disasm$indexreg == (i64)0)))) {
        if (((aa_disasm$basereg == (i64)0) && (aa_disasm$indexreg == (i64)0))) {
            aa_disasm$genhex(aa_disasm$offset);
        }
        else {
            if ((aa_disasm$offset > (i64)0)) {
                aa_disasm$genstr(plus);
            }
;
            aa_disasm$genintd(aa_disasm$offset);
        }
;
    }
;
    aa_disasm$genstr((byte*)"]");
}

static void aa_disasm$genstr(u8 *s) {
    strcat((u8 *)aa_disasm$deststr,s);
}

static void aa_disasm$genintd(i64 a) {
    aa_disasm$genstr(msysc$strint(a,0));
}

static void aa_disasm$genhex(i64 a) {
    aa_disasm$genstr(msysc$strint(a,(byte*)"h"));
}

static i64 aa_disasm$readimm(void) {
    if ((aa_disasm$opsize==(i64)1)) {
        return aa_disasm$readsbyte();
    }
    else if ((aa_disasm$opsize==(i64)2)) {
        return aa_disasm$readint16();
    }
    else if ((aa_disasm$opsize==(i64)4) || (aa_disasm$opsize==(i64)8)) {
        return aa_disasm$readint32();
    }
;
    return (i64)0;
}

static i64 aa_disasm$readimm8(void) {
    if ((aa_disasm$opsize < (i64)8)) {
        return aa_disasm$readimm();
    }
;
    return aa_disasm$readint64();
}

static u8 *aa_disasm$strxmm(i64 reg) {
        static u8 str[32];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"xmm",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64((reg - (i64)1),NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

static u8 *aa_disasm$strmmx(i64 reg) {
        static u8 str[32];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"mmx",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64((reg - (i64)1),NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

static void aa_disasm$decode8087(i64 ttt) {
        byte bb;
        i64 longopc;
        i64 freg;
        i64 shortopc;
    bb = (i64)(*(aa_disasm$codeptr)++);
    longopc = ((ttt << (i64)8) + (i64)bb);
    freg = (((i64)bb & (i64)7) + (i64)1);
    if ((longopc==(i64)1753)) {
        aa_disasm$genstr((byte*)"fcompp");
    }
    else if ((longopc==(i64)484)) {
        aa_disasm$genstr((byte*)"ftst");
    }
    else if ((longopc==(i64)485)) {
        aa_disasm$genstr((byte*)"fxam");
    }
    else if ((longopc==(i64)494)) {
        aa_disasm$genstr((byte*)"fldz");
    }
    else if ((longopc==(i64)488)) {
        aa_disasm$genstr((byte*)"fld1");
    }
    else if ((longopc==(i64)491)) {
        aa_disasm$genstr((byte*)"fldpi");
    }
    else if ((longopc==(i64)489)) {
        aa_disasm$genstr((byte*)"fldl2t");
    }
    else if ((longopc==(i64)490)) {
        aa_disasm$genstr((byte*)"fldl2e");
    }
    else if ((longopc==(i64)492)) {
        aa_disasm$genstr((byte*)"fldlg2");
    }
    else if ((longopc==(i64)493)) {
        aa_disasm$genstr((byte*)"fldln2");
    }
    else if ((longopc==(i64)506)) {
        aa_disasm$genstr((byte*)"fsqrt");
    }
    else if ((longopc==(i64)510)) {
        aa_disasm$genstr((byte*)"fsin");
    }
    else if ((longopc==(i64)511)) {
        aa_disasm$genstr((byte*)"fcos");
    }
    else if ((longopc==(i64)507)) {
        aa_disasm$genstr((byte*)"fsincos");
    }
    else if ((longopc==(i64)509)) {
        aa_disasm$genstr((byte*)"fscale");
    }
    else if ((longopc==(i64)504)) {
        aa_disasm$genstr((byte*)"fprem");
    }
    else if ((longopc==(i64)508)) {
        aa_disasm$genstr((byte*)"frndint");
    }
    else if ((longopc==(i64)500)) {
        aa_disasm$genstr((byte*)"fxtract");
    }
    else if ((longopc==(i64)481)) {
        aa_disasm$genstr((byte*)"fabs");
    }
    else if ((longopc==(i64)480)) {
        aa_disasm$genstr((byte*)"fchs");
    }
    else if ((longopc==(i64)498)) {
        aa_disasm$genstr((byte*)"fptan");
    }
    else if ((longopc==(i64)499)) {
        aa_disasm$genstr((byte*)"fpatan");
    }
    else if ((longopc==(i64)496)) {
        aa_disasm$genstr((byte*)"f2xm1");
    }
    else if ((longopc==(i64)497)) {
        aa_disasm$genstr((byte*)"fyl2x");
    }
    else if ((longopc==(i64)505)) {
        aa_disasm$genstr((byte*)"fyl2xp1");
    }
    else if ((longopc==(i64)995)) {
        aa_disasm$genstr((byte*)"finit");
    }
    else if ((longopc==(i64)992)) {
        aa_disasm$genstr((byte*)"feni");
    }
    else if ((longopc==(i64)993)) {
        aa_disasm$genstr((byte*)"fdisi");
    }
    else if ((longopc==(i64)994)) {
        aa_disasm$genstr((byte*)"fclex");
    }
    else if ((longopc==(i64)503)) {
        aa_disasm$genstr((byte*)"fincstp");
    }
    else if ((longopc==(i64)502)) {
        aa_disasm$genstr((byte*)"fdecstp");
    }
    else if ((longopc==(i64)464)) {
        aa_disasm$genstr((byte*)"fnop");
    }
    else {
                {i64 $temp = (longopc & (i64)2040);
if (($temp==(i64)448)) {
            aa_disasm$genstr((byte*)"fld ");
            aa_disasm$genstr(aa_disasm$strfreg(freg));
        }
        else if (($temp==(i64)1488)) {
            aa_disasm$genstr((byte*)"fst ");
            aa_disasm$genstr(aa_disasm$strfreg(freg));
        }
        else if (($temp==(i64)1496)) {
            aa_disasm$genstr((byte*)"fstp ");
            aa_disasm$genstr(aa_disasm$strfreg(freg));
        }
        else if (($temp==(i64)456)) {
            aa_disasm$genstr((byte*)"fxch ");
            aa_disasm$genstr(aa_disasm$strfreg(freg));
        }
        else if (($temp==(i64)208)) {
            aa_disasm$genstr((byte*)"fcom ");
            aa_disasm$genstr(aa_disasm$strfreg(freg));
        }
        else if (($temp==(i64)216)) {
            aa_disasm$genstr((byte*)"fcomp ");
            aa_disasm$genstr(aa_disasm$strfreg(freg));
        }
        else if (($temp==(i64)1472)) {
            aa_disasm$genstr((byte*)"ffree ");
            aa_disasm$genstr(aa_disasm$strfreg(freg));
        }
        else {
                        {i64 $temp = (longopc & (i64)504);
if (($temp==(i64)192)) {
                aa_disasm$do87arith((byte*)"fadd",ttt,freg);
            }
            else if (($temp==(i64)224)) {
                aa_disasm$do87arith((byte*)"fsub",ttt,freg);
            }
            else if (($temp==(i64)232)) {
                aa_disasm$do87arith((byte*)"fsubr",ttt,freg);
            }
            else if (($temp==(i64)200)) {
                aa_disasm$do87arith((byte*)"fmul",ttt,freg);
            }
            else if (($temp==(i64)240)) {
                aa_disasm$do87arith((byte*)"fdiv",ttt,freg);
            }
            else if (($temp==(i64)248)) {
                aa_disasm$do87arith((byte*)"fdivr",ttt,freg);
            }
            else {
                --(aa_disasm$codeptr);
                aa_disasm$decodeaddr((i64)0);
                shortopc = ((ttt << (i64)3) + aa_disasm$rmopc);
                if ((shortopc==(i64)61)) {
                    aa_disasm$do87mem((byte*)"fld",(i64)4);
                }
                else if ((shortopc==(i64)29)) {
                    aa_disasm$do87mem((byte*)"fld",(i64)5);
                }
                else if ((shortopc==(i64)60)) {
                    aa_disasm$do87mem((byte*)"fldbcd",(i64)-1);
                }
                else if ((shortopc==(i64)63)) {
                    aa_disasm$do87mem((byte*)"fstp",(i64)4);
                }
                else if ((shortopc==(i64)31)) {
                    aa_disasm$do87mem((byte*)"fstp",(i64)5);
                }
                else if ((shortopc==(i64)62)) {
                    aa_disasm$do87mem((byte*)"fstpbcd",(i64)-1);
                }
                else if ((shortopc==(i64)13)) {
                    aa_disasm$do87mem((byte*)"fldcw",(i64)-1);
                }
                else if ((shortopc==(i64)15)) {
                    aa_disasm$do87mem((byte*)"fstcw",(i64)-1);
                }
                else if ((shortopc==(i64)47)) {
                    aa_disasm$do87mem((byte*)"fstsw",(i64)-1);
                }
                else if ((shortopc==(i64)14)) {
                    aa_disasm$do87mem((byte*)"fstenv",(i64)-1);
                }
                else if ((shortopc==(i64)12)) {
                    aa_disasm$do87mem((byte*)"fldenv",(i64)-1);
                }
                else if ((shortopc==(i64)46)) {
                    aa_disasm$do87mem((byte*)"fsave",(i64)-1);
                }
                else if ((shortopc==(i64)44)) {
                    aa_disasm$do87mem((byte*)"frstor",(i64)-1);
                }
                else {
                                        {i64 $temp = (shortopc & (i64)15);
if (($temp==(i64)8)) {
                        aa_disasm$do87mem((byte*)"fld",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)10)) {
                        aa_disasm$do87mem((byte*)"fst",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)11)) {
                        aa_disasm$do87mem((byte*)"fstp",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)2)) {
                        aa_disasm$do87mem((byte*)"fcom",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)3)) {
                        aa_disasm$do87mem((byte*)"fcomp",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)0)) {
                        aa_disasm$do87mem((byte*)"fadd",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)4)) {
                        aa_disasm$do87mem((byte*)"fsub",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)5)) {
                        aa_disasm$do87mem((byte*)"fsubr",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)1)) {
                        aa_disasm$do87mem((byte*)"fmul",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)6)) {
                        aa_disasm$do87mem((byte*)"fdiv",(ttt >> (i64)1));
                    }
                    else if (($temp==(i64)7)) {
                        aa_disasm$do87mem((byte*)"fdivr",(ttt >> (i64)1));
                    }
                    else {
                        aa_disasm$genstr((byte*)"UNKNOWN x87 OPCODE");
                    }
                    };
                }
;
            }
            };
        }
        };
    }
;
}

static void aa_disasm$do87arith(u8 *opcstr,i64 ttt,i64 freg) {
        i64 d;
        i64 p;
    d = (ttt & (i64)4);
    p = (ttt & (i64)2);
    aa_disasm$genstr(opcstr);
    if (!!(p)) {
        aa_disasm$genstr((byte*)"p");
    }
;
    aa_disasm$genstr((byte*)" ");
    if ((d == (i64)0)) {
        aa_disasm$genstr((byte*)"st0, ");
        aa_disasm$genstr(aa_disasm$strfreg(freg));
    }
    else {
        aa_disasm$genstr(aa_disasm$strfreg(freg));
        aa_disasm$genstr((byte*)", st0");
    }
;
}

static void aa_disasm$do87mem(u8 *opcstr,i64 mf) {
    aa_disasm$genstr((byte*)"f");
    if ((mf==(i64)0)) {
        aa_disasm$opsize = (i64)4;
    }
    else if ((mf==(i64)1)) {
        aa_disasm$genstr((byte*)"i");
        aa_disasm$opsize = (i64)4;
    }
    else if ((mf==(i64)2)) {
        aa_disasm$opsize = (i64)8;
    }
    else if ((mf==(i64)3)) {
        aa_disasm$genstr((byte*)"i");
        aa_disasm$opsize = (i64)2;
    }
    else if ((mf==(i64)4)) {
        aa_disasm$genstr((byte*)"i");
        aa_disasm$opsize = (i64)8;
    }
    else if ((mf==(i64)5)) {
        aa_disasm$opsize = (i64)10;
    }
;
    aa_disasm$genstr((opcstr + (i64)1));
    aa_disasm$genstr((byte*)" ");
    aa_disasm$printaddrmode((i64)0);
}

static void aa_disasm$getsil(i64 *reg) {
    if (((((aa_disasm$opsize == (i64)1) && !(!!(aa_disasm$rex))) && ((*reg) >= (i64)5)) && ((*reg) <= (i64)8))) {
                {i64 $temp = (*reg);
if (($temp==(i64)5)) {
            (*reg) = (i64)17;
        }
        else if (($temp==(i64)6)) {
            (*reg) = (i64)19;
        }
        else if (($temp==(i64)7)) {
            (*reg) = (i64)20;
        }
        else if (($temp==(i64)8)) {
            (*reg) = (i64)18;
        }
        };
    }
;
}

static void aa_disasm$getsilx(i64 *reg) {
    if ((((((aa_disasm$addrmode == (i64)1) && (aa_disasm$opsize == (i64)1)) && (aa_disasm$rex == (i64)0)) && ((*reg) >= (i64)5)) && ((*reg) <= (i64)8))) {
                {i64 $temp = (*reg);
if (($temp==(i64)5)) {
            (*reg) = (i64)17;
        }
        else if (($temp==(i64)6)) {
            (*reg) = (i64)19;
        }
        else if (($temp==(i64)7)) {
            (*reg) = (i64)20;
        }
        else if (($temp==(i64)8)) {
            (*reg) = (i64)18;
        }
        };
    }
;
}

// START
void aa_disasm$start(void) {

}

void aa_genss$genss(void) {
        i64 index;
        struct aa_lib$mclrec *  m;
    aa_decls$ss_zdatalen = (i64)0;
    aa_decls$ss_zdata = (struct aa_decls$dbuffer *)aa_lib$buffercreate((i64)1024);
    aa_decls$ss_idata = (struct aa_decls$dbuffer *)aa_lib$buffercreate((i64)1024);
    aa_decls$ss_code = (struct aa_decls$dbuffer *)aa_lib$buffercreate((i64)1024);
    aa_decls$ss_idatarelocs = 0;
    aa_decls$ss_coderelocs = 0;
    aa_decls$ss_nsymbols = (i64)0;
    aa_genss$switchseg((i64)1);
    aa_decls$alineno = (i64)9999;
    aa_genss$extraparam = 0;
    m = (struct aa_lib$mclrec *)aa_lib$mccode;
    index = (i64)0;
    L842 :;
    while (!!(m)) {
        aa_decls$alineno = (i64)(*m).lineno;
        aa_genss$doinstr((struct aa_lib$mclrec *)m,++(index));
        m = (struct aa_lib$mclrec *)(*m).nextmcl;
L843 :;
    }
L844 :;
    ;
    aa_genss$switchseg((i64)0);
    if (!!(aa_lib$bufferlength((struct aa_decls$dbuffer *)aa_decls$ss_zdata))) {
        aa_lib$gerror((byte*)"Zdata contains code or data");
    }
;
}

static void aa_genss$doinstr(struct aa_lib$mclrec *m,i64 index) {
        struct aa_decls$opndrec *  a;
        struct aa_decls$opndrec *  b;
        struct aa_decls$strec *  d;
        i64 x;
        i64 offset;
        i64 shortjmp;
        i64 n;
        i64 $av_1;
        i64 $av_2;
    aa_genss$currmcl = (struct aa_lib$mclrec *)m;
    aa_lib$buffercheck((struct aa_decls$dbuffer *)aa_genss$currdata,(i64)1024);
    aa_genss$rex = (aa_genss$sizeoverride = (aa_genss$addroverride = (aa_genss$f2override = (aa_genss$f3override = (aa_genss$nowmask = (aa_genss$usesizeb = (i64)0))))));
    a = (struct aa_decls$opndrec *)(*m).a;
    b = (struct aa_decls$opndrec *)(*m).b;
    switch ((i64)(*m).opcode) {
    case 4:;
        {
            d = (struct aa_decls$strec *)(*a).labeldef;
            (*d).reftype = (i64)2;
            (*d).segment = aa_genss$currseg;
            (*d).offset = aa_genss$getcurrdatalen((i64)6);
            if (((i64)(*d).symbol == (i64)22)) {
                aa_genss$getstindex((struct aa_decls$strec *)d);
            }
;
            aa_genss$dofwdrefs((struct aa_decls$strec *)d);
        }
        break;
    case 20:;
        {
            aa_genss$do_call((struct aa_decls$opndrec *)a);
        }
        break;
    case 24:;
        {
            aa_genss$do_jmp((struct aa_decls$opndrec *)a,(struct aa_lib$mclrec *)m);
        }
        break;
    case 25:;
        {
            offset = aa_genss$getrel32((struct aa_decls$strec *)(*b).labeldef,(aa_genss$getcurrdatalen((i64)7) + (i64)1));
            if ((offset < (i64)0)) {
                if ((offset < (i64)-126)) {
                    aa_genss$genbyte((i64)15);
                    aa_genss$genbyte(((i64)128 + (*a).value));
                    aa_genss$gendword((offset - (i64)4));
                }
                else {
                    aa_genss$genbyte(((i64)112 + (*(*m).a).value));
                    aa_genss$genbyte(offset);
                }
;
            }
            else {
                shortjmp = aa_genss$checkshortjump((struct aa_lib$mclrec *)m,(struct aa_decls$strec *)(*b).labeldef);
                if (!(!!(shortjmp))) {
                    aa_genss$genbyte((i64)15);
                    aa_genss$genbyte(((i64)128 + (*a).value));
                    aa_genss$genrel32((struct aa_decls$opndrec *)b);
                }
                else {
                    aa_genss$genbyte(((i64)112 + (*a).value));
                    aa_genss$genrel8((struct aa_decls$opndrec *)b);
                }
;
            }
;
        }
        break;
    case 114:;
        {
            aa_genss$genopnd((struct aa_decls$opndrec *)a,(i64)1);
        }
        break;
    case 115:;
        {
            aa_genss$genopnd((struct aa_decls$opndrec *)a,(i64)2);
        }
        break;
    case 116:;
        {
            aa_genss$genopnd((struct aa_decls$opndrec *)a,(i64)4);
        }
        break;
    case 117:;
        {
            aa_genss$genopnd((struct aa_decls$opndrec *)a,(i64)8);
        }
        break;
    case 118:;
        {
            aa_genss$switchseg((*a).value);
        }
        break;
    case 5:;
    case 147:;
        {
            aa_genss$genbyte((i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 55:;
        {
            aa_genss$genbyte((i64)102);
            aa_genss$genbyte((i64)152);
        }
        break;
    case 56:;
        {
            aa_genss$genbyte((i64)102);
            aa_genss$genbyte((i64)153);
        }
        break;
    case 57:;
        {
            aa_genss$genbyte((i64)153);
        }
        break;
    case 58:;
        {
            aa_genss$genbyte((i64)72);
            aa_genss$genbyte((i64)153);
        }
        break;
    case 21:;
        {
            aa_genss$genbyte((i64)195);
        }
        break;
    case 23:;
        {
            aa_genss$genbyte((i64)201);
        }
        break;
    case 22:;
        {
            if (((i64)(*a).mode != (i64)2)) {
                aa_lib$gerror((byte*)"retn?");
            }
;
            aa_genss$genbyte((i64)194);
            aa_genss$genword((*a).value);
        }
        break;
    case 11:;
        {
            aa_genss$do_push((struct aa_decls$opndrec *)a);
        }
        break;
    case 12:;
        {
            aa_genss$do_pop((struct aa_decls$opndrec *)a);
        }
        break;
    case 53:;
    case 54:;
        {
            aa_genss$do_inc((struct aa_decls$opndrec *)a,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 51:;
    case 52:;
    case 38:;
    case 37:;
    case 42:;
    case 41:;
        {
            aa_genss$do_neg((struct aa_decls$opndrec *)a,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 27:;
    case 28:;
    case 31:;
    case 32:;
    case 33:;
    case 29:;
    case 30:;
    case 43:;
        {
            aa_genss$do_arith((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 9:;
        {
            aa_genss$do_mov((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        break;
    case 13:;
        {
            aa_genss$do_lea((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        break;
    case 17:;
        {
            aa_genss$do_movsx((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)190);
        }
        break;
    case 18:;
        {
            aa_genss$do_movsx((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)182);
        }
        break;
    case 19:;
        {
            aa_genss$do_movsxd((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        break;
    case 26:;
        {
            aa_genss$do_exch((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        break;
    case 39:;
        {
            aa_genss$do_imul2((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        break;
    case 123:;
    case 124:;
    case 125:;
    case 126:;
        {
            if (((i64)(*a).mode == (i64)2)) {
                n = ((*a).value * (i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
                aa_lib$buffercheck((struct aa_decls$dbuffer *)aa_genss$currdata,n);
                if ((aa_genss$currseg==(i64)1)) {
                    $av_1 = n;
                    while ($av_1-- > 0) {
L845 :;
                        aa_genss$genbyte((i64)144);
L846 :;
                    }
L847 :;
                    ;
                }
                else if ((aa_genss$currseg==(i64)2)) {
                    $av_2 = n;
                    while ($av_2-- > 0) {
L848 :;
                        aa_genss$genbyte((i64)0);
L849 :;
                    }
L850 :;
                    ;
                }
                else {
                    aa_decls$ss_zdatalen += n;
                }
;
            }
            else {
                aa_lib$gerror((byte*)"resb?");
            }
;
        }
        break;
    case 122:;
        {
            if (((i64)(*a).mode == (i64)2)) {
                x = (*a).value;
                if (((x < (i64)1) || (x > (i64)16384))) {
                    aa_lib$gerror((byte*)"align2");
                }
;
                if ((aa_genss$currseg != (i64)3)) {
                    L851 :;
                    while (!!((aa_lib$bufferlength((struct aa_decls$dbuffer *)aa_genss$currdata) % x))) {
                        aa_genss$genbyte(((aa_genss$currseg == (i64)1) ? (i64)144 : (i64)0));
L852 :;
                    }
L853 :;
                    ;
                }
                else {
                    L854 :;
                    while (!!((aa_decls$ss_zdatalen % x))) {
                        ++(aa_decls$ss_zdatalen);
L855 :;
                    }
L856 :;
                    ;
                }
;
            }
            else {
                aa_lib$gerror((byte*)"align?");
            }
;
        }
        break;
    case 44:;
    case 46:;
    case 45:;
    case 47:;
    case 48:;
    case 49:;
    case 50:;
        {
            aa_genss$do_shift((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 36:;
        {
            aa_genss$do_test((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        break;
    case 130:;
    case 129:;
    case 128:;
        {
            aa_genss$do_loop((struct aa_decls$opndrec *)a,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 131:;
        {
            aa_genss$do_jcxz((struct aa_decls$opndrec *)a,(i64)4);
        }
        break;
    case 132:;
        {
            aa_genss$do_jcxz((struct aa_decls$opndrec *)a,(i64)8);
        }
        break;
    case 127:;
        {
            aa_genss$genbyte((i64)215);
        }
        break;
    case 59:;
        {
            aa_genss$do_setcc((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        break;
    case 15:;
        {
            aa_genss$do_movxmm((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)4);
        }
        break;
    case 16:;
        {
            aa_genss$do_movxmm((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)8);
        }
        break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 63:;
    case 110:;
    case 111:;
        {
            aa_genss$do_arithxmm((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)243,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 62:;
    case 112:;
    case 113:;
        {
            aa_genss$do_arithxmm((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)242,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 72:;
        {
            aa_genss$do_arithxmm((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)0,(i64)47);
        }
        break;
    case 73:;
        {
            aa_genss$do_arithxmm((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)102,(i64)47);
        }
        break;
    case 77:;
    case 75:;
        {
            aa_genss$do_logicxmm((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1],(i64)4);
        }
        break;
    case 76:;
    case 74:;
    case 79:;
    case 78:;
        {
            aa_genss$do_logicxmm((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1],(i64)8);
        }
        break;
    case 90:;
    case 91:;
        {
            aa_genss$do_pcmpistri((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)(*m).c,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 87:;
        {
            aa_genss$do_convertfloat((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)243);
        }
        break;
    case 86:;
        {
            aa_genss$do_convertfloat((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)242);
        }
        break;
    case 80:;
        {
            aa_genss$do_fix((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)243,(i64)45);
        }
        break;
    case 81:;
        {
            aa_genss$do_fix((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)242,(i64)45);
        }
        break;
    case 82:;
        {
            aa_genss$do_fix((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)243,(i64)44);
        }
        break;
    case 83:;
        {
            aa_genss$do_fix((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)242,(i64)44);
        }
        break;
    case 84:;
        {
            aa_genss$do_float((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)243);
        }
        break;
    case 85:;
        {
            aa_genss$do_float((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)242);
        }
        break;
    case 6:;
        {
            aa_genss$extraparam = (struct aa_decls$opndrec *)a;
        }
        break;
    case 14:;
        {
            aa_genss$do_cmovcc((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)aa_genss$extraparam,(struct aa_decls$opndrec *)b);
        }
        break;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
        {
            aa_genss$genbyte((i64)217);
            aa_genss$genbyte((i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 92:;
    case 93:;
    case 94:;
        {
            aa_genss$do_fmem((struct aa_decls$opndrec *)a,(i64)1,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 95:;
    case 96:;
    case 97:;
        {
            aa_genss$do_fmem((struct aa_decls$opndrec *)a,(i64)0,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
        {
            aa_genss$genbyte((i64)222);
            aa_genss$genbyte((i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 133:;
        {
            aa_genss$genbyte((i64)166);
        }
        break;
    case 134:;
        {
            aa_genss$genbyte((i64)102);
            aa_genss$genbyte((i64)167);
        }
        break;
    case 135:;
        {
            aa_genss$genbyte((i64)167);
        }
        break;
    case 136:;
        {
            aa_genss$genbyte((i64)72);
            aa_genss$genbyte((i64)167);
        }
        break;
    case 137:;
        {
            aa_genss$genbyte((i64)15);
            aa_genss$genbyte((i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 139:;
        {
            aa_genss$genbyte((i64)219);
            aa_genss$genbyte((i64)227);
        }
        break;
    case 140:;
    case 141:;
    case 142:;
    case 143:;
    case 144:;
    case 145:;
    case 146:;
        {
            aa_genss$genbyte((i64)217);
            aa_genss$genbyte((i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 138:;
        {
            aa_genss$do_popcnt((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        break;
    case 60:;
    case 61:;
        {
            aa_genss$do_bsf((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b,(i64)aa_tables$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"*** CAN'T DO OPCODE",NULL);
        msysc$m_print_str(aa_tables$mclnames[((i64)(*m).opcode)-1],NULL);
        msysc$m_print_str((byte*)"line",NULL);
        msysc$m_print_i64(aa_decls$alineno,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    } //SW
;
}

static void aa_genss$genbyte(i64 x) {
    (*((*aa_genss$currdata).pcurr)++) = x;
}

static void aa_genss$genword(i64 x) {
    aa_lib$addword((struct aa_decls$dbuffer *)aa_genss$currdata,x);
}

static void aa_genss$gendword(i64 x) {
    aa_lib$adddword((struct aa_decls$dbuffer *)aa_genss$currdata,x);
}

static void aa_genss$genqword(i64 x) {
    aa_lib$addqword((struct aa_decls$dbuffer *)aa_genss$currdata,x);
}

static void aa_genss$genopnd(struct aa_decls$opndrec *a,i64 size) {
        u8 *  s;
        i64 x;
        i64 length;
    if ((size == (i64)0)) {
        size = (i64)(*a).size;
    }
;
    switch ((i64)(*a).mode) {
    case 2:;
    case 3:;
        {
        }
        break;
    case 6:;
        {
            s = (*a).svalue;
            length = strlen(s);
            if ((length > (i64)100)) {
                aa_lib$buffercheck((struct aa_decls$dbuffer *)aa_genss$currdata,msysc$m_imax((i64)1024,(length + (i64)1)));
            }
;
            L857 :;
            while (!!((u64)(*s))) {
                aa_genss$genbyte((i64)(u64)(*(s)++));
L858 :;
            }
L859 :;
            ;
            return;
        }
        break;
    default: {
        aa_lib$gerror((byte*)"GENOPND/bad opnd");
    }
    } //SW
;
    if ((!!((*a).labeldef) && (size <= (i64)2))) {
        aa_lib$gerror((byte*)"8/16-BIT RELOC");
    }
;
    if ((size==(i64)1)) {
        aa_genss$genbyte((*a).value);
    }
    else if ((size==(i64)2)) {
        aa_genss$genword((*a).value);
    }
    else if ((size==(i64)4)) {
        if (!!((*a).labeldef)) {
            aa_genss$genabs32((struct aa_decls$opndrec *)a);
        }
        else {
            if (!!((i64)(*a).valtype)) {
                aa_genss$gendword(aa_genss$getr32bits((*a).xvalue));
            }
            else {
                aa_genss$gendword((*a).value);
            }
;
        }
;
    }
    else if ((size==(i64)8)) {
        if (!!((*a).labeldef)) {
            aa_genss$genabs64((struct aa_decls$opndrec *)a);
        }
        else {
            x = (*a).value;
            if (!!((i64)(*a).valtype)) {
                aa_genss$genqword(x);
            }
            else {
                aa_genss$genqword(x);
            }
;
        }
;
    }
;
}

static void aa_genss$addrelocitem(i64 reloctype,struct aa_decls$strec *d) {
        struct aa_decls$relocrec *  r;
        i64 stindex;
        i64 adjust;
    stindex = aa_genss$getstindex((struct aa_decls$strec *)d);
    adjust = (i64)4;
    if ((reloctype == (i64)1)) {
        adjust = (i64)8;
    }
;
    r = (struct aa_decls$relocrec *)mlib$pcm_alloc((i64)32);
    (*r).nextreloc = (struct aa_decls$relocrec *)aa_genss$currrelocs;
    (*r).reloctype = reloctype;
    (*r).offset = (aa_genss$getcurrdatalen((i64)1) - adjust);
    (*r).stindex = stindex;
    ++(aa_genss$nrelocs);
    aa_genss$currrelocs = (struct aa_decls$relocrec *)r;
}

static i64 aa_genss$getstindex(struct aa_decls$strec *d) {
    if (((i64)(*d).stindex == (i64)0)) {
        if ((aa_decls$ss_nsymbols >= aa_decls$ss_symboltablesize)) {
            aa_genss$extendsymboltable();
        }
;
        (*d).stindex = ++(aa_decls$ss_nsymbols);
        (*aa_decls$ss_symboltable)[((i64)(*d).stindex)-1] = (struct aa_decls$strec *)d;
    }
;
    return (i64)(*d).stindex;
}

static void aa_genss$genrel32(struct aa_decls$opndrec *a) {
        struct aa_decls$strec *  d;
    d = (struct aa_decls$strec *)(*a).labeldef;
    if ((d == 0)) {
        aa_genss$gendword((*a).value);
        return;
    }
;
        {i64 $temp = (i64)(*d).reftype;
if (($temp==(i64)2)) {
        if (((i64)(*d).segment != aa_genss$currseg)) {
            aa_lib$gerror((byte*)"Rel label across segments");
        }
;
        aa_genss$gendword(((i64)(*d).offset - (aa_genss$getcurrdatalen((i64)2) + (i64)4)));
    }
    else if (($temp==(i64)1)) {
        (*d).fwdrefs = (struct aa_decls$fwdrec *)aa_genss$addfwdref((struct aa_decls$fwdrec *)(*d).fwdrefs,aa_genss$getcurrdatalen((i64)3),(i64)4,(i64)0);
        aa_genss$gendword((i64)0);
    }
    else {
        aa_genss$gendword((*a).value);
        aa_genss$addrelocitem((i64)4,(struct aa_decls$strec *)d);
    }
    };
}

static void aa_genss$genabs32(struct aa_decls$opndrec *a) {
        struct aa_decls$strec *  d;
    d = (struct aa_decls$strec *)(*a).labeldef;
        {i64 $temp = (i64)(*d).reftype;
if (($temp==(i64)2)) {
        aa_genss$gendword(((i64)(*d).offset + (*a).value));
        aa_genss$addrelocitem((i64)2,(struct aa_decls$strec *)d);
    }
    else if (($temp==(i64)1)) {
        (*d).fwdrefs = (struct aa_decls$fwdrec *)aa_genss$addfwdref((struct aa_decls$fwdrec *)(*d).fwdrefs,aa_genss$getcurrdatalen((i64)4),(i64)2,aa_genss$currseg);
        aa_genss$gendword((*a).value);
        aa_genss$addrelocitem((i64)2,(struct aa_decls$strec *)d);
    }
    else {
        aa_genss$gendword((*a).value);
        aa_genss$addrelocitem((i64)2,(struct aa_decls$strec *)d);
    }
    };
}

static void aa_genss$genabs64(struct aa_decls$opndrec *a) {
        struct aa_decls$strec *  d;
    d = (struct aa_decls$strec *)(*a).labeldef;
        {i64 $temp = (i64)(*d).reftype;
if (($temp==(i64)2)) {
        aa_genss$genqword(((i64)(*d).offset + (*a).value));
        aa_genss$addrelocitem((i64)1,(struct aa_decls$strec *)d);
    }
    else if (($temp==(i64)1)) {
        (*d).fwdrefs = (struct aa_decls$fwdrec *)aa_genss$addfwdref((struct aa_decls$fwdrec *)(*d).fwdrefs,aa_genss$getcurrdatalen((i64)5),(i64)2,aa_genss$currseg);
        aa_genss$genqword((*a).value);
        aa_genss$addrelocitem((i64)1,(struct aa_decls$strec *)d);
    }
    else {
        aa_genss$genqword((*a).value);
        aa_genss$addrelocitem((i64)1,(struct aa_decls$strec *)d);
    }
    };
}

static i64 aa_genss$getrel32(struct aa_decls$strec *d,i64 offset) {
    if (((i64)(*d).reftype == (i64)2)) {
        if (((i64)(*d).segment != aa_genss$currseg)) {
            aa_lib$gerror((byte*)"Rel label across segments2");
        }
;
        return ((i64)(*d).offset - (offset + (i64)1));
    }
    else {
        return (i64)2147483647;
    }
;
}

static void aa_genss$dofwdrefs(struct aa_decls$strec *d) {
        struct aa_decls$fwdrec *  f;
        i64 offset;
        byte *  p8;
        i32 *  p32;
        i64 *  p64;
        struct aa_decls$dbuffer *  data;
    if (((*d).fwdrefs == 0)) {
        return;
    }
;
    f = (struct aa_decls$fwdrec *)(*d).fwdrefs;
    L860 :;
    while (!!(f)) {
        offset = (i64)(*f).offset;
                {i64 $temp = (i64)(*f).reltype;
if (($temp==(i64)4)) {
            p32 = (i32 *)aa_lib$bufferelemptr((struct aa_decls$dbuffer *)aa_genss$currdata,offset);
            (*p32) = (((i64)(*d).offset - offset) - (i64)4);
        }
        else if (($temp==(i64)2) || ($temp==(i64)1)) {
                        {i64 $temp = (i64)(*f).seg;
if (($temp==(i64)1)) {
                data = (struct aa_decls$dbuffer *)aa_decls$ss_code;
            }
            else if (($temp==(i64)3)) {
                aa_lib$gerror((byte*)"Fwd ref in zdata");
            }
            else if (($temp==(i64)2)) {
                data = (struct aa_decls$dbuffer *)aa_decls$ss_idata;
            }
            };
            p32 = (i32 *)aa_lib$bufferelemptr((struct aa_decls$dbuffer *)data,offset);
            if (((i64)(*f).reltype == (i64)2)) {
                (*p32) = ((i64)(*p32) + (i64)(*d).offset);
            }
            else {
                p64 = (i64 *)p32;
                (*p64) = ((*p64) + (i64)(*d).offset);
            }
;
        }
        else if (($temp==(i64)6)) {
            p8 = (byte *)aa_lib$bufferelemptr((struct aa_decls$dbuffer *)aa_genss$currdata,offset);
            (*p8) = (((i64)(*d).offset - offset) - (i64)1);
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(aa_objdecls$relocnames[((i64)(*f).reltype)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            aa_lib$gerror((byte*)"DOFWDREFS/CAN'T DO RELTYPE");
        }
        };
        f = (struct aa_decls$fwdrec *)(*f).nextfwd;
L861 :;
    }
L862 :;
    ;
}

static void aa_genss$genrex(void) {
    if (!!((i64)aa_genss$f2override)) {
        aa_genss$genbyte((i64)242);
    }
;
    if (!!((i64)aa_genss$f3override)) {
        aa_genss$genbyte((i64)243);
    }
;
    if (!!((i64)aa_genss$sizeoverride)) {
        aa_genss$genbyte((i64)102);
    }
;
    if (!!((i64)aa_genss$addroverride)) {
        aa_genss$genbyte((i64)103);
    }
;
    if (!!((i64)aa_genss$nowmask)) {
        aa_genss$rex = msysc$m_setdotindex(aa_genss$rex,(i64)3,(u64)0u);
    }
;
    if (!!((i64)aa_genss$rex)) {
        aa_genss$genbyte((((i64)aa_genss$rex & (i64)15) + (i64)64));
    }
;
}

static i64 aa_genss$isbytesized(i64 x) {
    return (i64)((i64)-128<=x && x<=(i64)127);
}

static i64 aa_genss$isdwordsized(i64 x) {
    return (i64)((i64)-2147483648<=x && x<=(i64)2147483647);
}

static void aa_genss$do_push(struct aa_decls$opndrec *a) {
        i64 code;
    if (((i64)(*a).size == (i64)0)) {
        (*a).size = (i64)8;
    }
;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
        if (((i64)(*a).size != (i64)8)) {
            aa_lib$gerror((byte*)"pushreg not 64-bit");
        }
;
        code = aa_genss$getregcode((i64)(*a).reg,(i64)1,(i64)0);
        aa_genss$rex = msysc$m_setdotindex(aa_genss$rex,(i64)3,(u64)0u);
        aa_genss$genrex();
        aa_genss$genbyte(((i64)80 + code));
    }
    else if (($temp==(i64)2)) {
        if (!!((*a).labeldef)) {
            aa_genss$genbyte((i64)104);
            aa_genss$genopnd((struct aa_decls$opndrec *)a,(i64)4);
        }
        else if (!!(aa_genss$isbytesized((*a).value))) {
            aa_genss$genbyte((i64)106);
            aa_genss$genbyte((*a).value);
        }
        else if (!!(aa_genss$isdwordsized((*a).value))) {
            aa_genss$genbyte((i64)104);
            aa_genss$gendword((*a).value);
        }
        else {
            aa_lib$gerror((byte*)"push imm value too large");
        }
;
    }
    else if (($temp==(i64)3)) {
        if (((i64)(*a).size != (i64)8)) {
            aa_lib$gerror((byte*)"push not 64-bit");
        }
;
        aa_genss$genxrm((i64)255,(i64)6,(struct aa_decls$opndrec *)a);
    }
    else {
        aa_lib$gerror((byte*)"push opnd?");
    }
    };
}

static void aa_genss$do_pop(struct aa_decls$opndrec *a) {
        i64 code;
    if (((i64)(*a).size == (i64)0)) {
        (*a).size = (i64)8;
    }
;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
        if (((i64)(*a).size != (i64)8)) {
            aa_lib$gerror((byte*)"popreg not 64-bit");
        }
;
        code = aa_genss$getregcode((i64)(*a).reg,(i64)1,(i64)0);
        aa_genss$genrex();
        aa_genss$genbyte(((i64)88 + code));
    }
    else if (($temp==(i64)3)) {
        if (((i64)(*a).size != (i64)8)) {
            aa_lib$gerror((byte*)"pop not 64-bit");
        }
;
        aa_genss$genxrm((i64)143,(i64)0,(struct aa_decls$opndrec *)a);
    }
    else {
        aa_lib$gerror((byte*)"pop opnd?");
    }
    };
}

static void aa_genss$do_inc(struct aa_decls$opndrec *a,i64 code) {
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1) || ($temp==(i64)3)) {
        aa_genss$genxrm((((i64)(*a).size == (i64)1) ? (i64)254 : (i64)255),code,(struct aa_decls$opndrec *)a);
    }
    else {
        aa_lib$gerror((byte*)"inc/opnd?");
    }
    };
}

static void aa_genss$do_neg(struct aa_decls$opndrec *a,i64 code) {
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1) || ($temp==(i64)3)) {
        aa_genss$genxrm((((i64)(*a).size == (i64)1) ? (i64)246 : (i64)247),code,(struct aa_decls$opndrec *)a);
    }
    else {
        aa_lib$gerror((byte*)"neg/div/etc opnd?");
    }
    };
}

static void aa_genss$genamode(struct aa_decls$opndrec *a,i64 am) {
        i64 sib;
        i64 mode;
        i64 dispsize;
    sib = (am >> (i64)16);
    mode = ((am >> (i64)8) & (i64)255);
    dispsize = (am & (i64)255);
    aa_genss$genbyte(mode);
    if ((sib >= (i64)0)) {
        aa_genss$genbyte(sib);
    }
;
    if ((dispsize==(i64)0)) {
    }
    else if ((dispsize==(i64)1)) {
        aa_genss$genbyte((*a).value);
    }
    else if ((dispsize==(i64)4)) {
        if (!!((*a).labeldef)) {
            aa_genss$genabs32((struct aa_decls$opndrec *)a);
        }
        else {
            aa_genss$gendword((*a).value);
        }
;
    }
    else {
        aa_lib$gerror((byte*)"genamode size 2/8");
    }
;
}

static i64 aa_genss$makemodrm(i64 mode,i64 opc,i64 rm) {
    return (((mode << (i64)6) + (opc << (i64)3)) + rm);
}

static void aa_genss$setopsize(struct aa_decls$opndrec *a) {
        {i64 $temp = (i64)(*a).size;
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)2)) {
        aa_genss$sizeoverride = (i64)1;
    }
    else if (($temp==(i64)8)) {
        aa_genss$rex |= (u8)8u;
    }
    else if (($temp==(i64)4)) {
    }
    else if (($temp==(i64)16)) {
    }
    else {
        aa_lib$gerror((byte*)"Operand size not set");
    }
    };
}

static i64 aa_genss$getdispsize(struct aa_decls$opndrec *a,i64 mand) {
    if (!!((*a).labeldef)) {
        return (i64)4;
    }
;
    if ((!!((*a).value) || !!(mand))) {
        if (!!(aa_genss$isbytesized((*a).value))) {
            return (i64)1;
        }
        else {
            return (i64)4;
        }
;
    }
    else {
        return (i64)0;
    }
;
}

static void aa_genss$genrmbyte(i64 mode,i64 opc,i64 rm) {
    aa_genss$genbyte((((mode << (i64)6) + (opc << (i64)3)) + rm));
}

static i64 aa_genss$makeam(i64 m,i64 s,i64 d) {
    return (((s << (i64)16) + (m << (i64)8)) + d);
}

static void aa_genss$do_lea(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
    if (!((((i64)(*a).mode == (i64)1) && ((i64)(*b).mode == (i64)3)))) {
        aa_lib$gerror((byte*)"LEA not reg/mem");
    }
;
    if (((i64)(*a).size < (i64)4)) {
        aa_lib$gerror((byte*)"LEA size error");
    }
;
    aa_genss$genrrm((i64)141,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_movsx(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 opc) {
    if (((i64)(*a).mode != (i64)1)) {
        aa_lib$gerror((byte*)"movsx not reg");
    }
;
    if ((((i64)(*a).size == (i64)8) && ((i64)(*b).size == (i64)4))) {
        if ((opc == (i64)190)) {
            aa_genss$do_movsxd((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        else {
            a = (struct aa_decls$opndrec *)aa_lib$regtable[((i64)(*a).reg)-1][((i64)4)-1];
            aa_genss$do_mov((struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
;
        return;
    }
;
    if ((((i64)(*a).size == (i64)1) || ((i64)(*a).size <= (i64)(*b).size))) {
        aa_lib$gerror((byte*)"movsx size error");
    }
;
    if (((opc == (i64)182) && ((i64)(*b).size == (i64)4))) {
        aa_lib$gerror((byte*)"movsx 4=>8 bytes?");
    }
;
        {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1)) {
    }
    else if (($temp==(i64)3)) {
        if (((i64)(*b).size == (i64)0)) {
            aa_lib$gerror((byte*)"movsx need size prefix");
        }
;
        if (((i64)(*b).size == (i64)8)) {
            aa_lib$gerror((byte*)"movsx size 8");
        }
;
    }
    else {
        aa_lib$gerror((byte*)"movsx not reg/mem");
    }
    };
    aa_genss$genrrm(((i64)3840 + (((i64)(*b).size == (i64)1) ? opc : (opc + (i64)1))),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$checkhighreg(struct aa_decls$opndrec *a) {
    if (((i64)(*a).mode == (i64)1)) {
                {i64 $temp = (i64)(*a).reg;
if (($temp==(i64)6) || ($temp==(i64)4) || ($temp==(i64)15) || ($temp==(i64)16)) {
            aa_genss$rex |= (u8)64u;
        }
        };
    }
;
}

static void aa_genss$do_exch(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
        i64 regcode;
    if ((((((i64)(*a).mode == (i64)1) && ((i64)(*b).mode == (i64)1)) && (((i64)(*a).reg == (i64)1) || ((i64)(*b).reg == (i64)1))) && ((i64)(*a).size != (i64)1))) {
        if (((i64)(*a).reg != (i64)1)) {
            {struct aa_decls$opndrec *  temp = a; a = b; b = temp; };
        }
;
        if (((i64)(*a).size != (i64)(*b).size)) {
            aa_lib$gerror((byte*)"exch size");
        }
;
        aa_genss$setopsize((struct aa_decls$opndrec *)a);
        regcode = aa_genss$getregcode((i64)(*b).reg,(i64)1,(i64)0);
        aa_genss$genrex();
        aa_genss$genbyte(((i64)144 + regcode));
        return;
    }
;
    if (((i64)(*a).mode == (i64)3)) {
        {struct aa_decls$opndrec *  temp = a; a = b; b = temp; };
    }
;
    if (!((((i64)(*a).mode == (i64)1) && (((i64)(*b).mode == (i64)1) || ((i64)(*b).mode == (i64)3))))) {
        aa_lib$gerror((byte*)"exch opnds");
    }
;
    if ((((i64)(*b).size == (i64)0) && ((i64)(*b).mode == (i64)3))) {
        (*b).size = (i64)(*a).size;
    }
;
    if (((i64)(*a).size != (i64)(*b).size)) {
        aa_lib$gerror((byte*)"exch size");
    }
;
    aa_genss$genrrm((((i64)(*a).size == (i64)1) ? (i64)134 : (i64)135),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_movsxd(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
    if ((((i64)(*b).mode == (i64)3) && ((i64)(*b).size == (i64)0))) {
        (*b).size = (i64)4;
    }
;
    if ((((i64)(*a).size != (i64)8) || ((i64)(*b).size > (i64)4))) {
        aa_lib$gerror((byte*)"movsxd size");
    }
;
    if ((((i64)(*a).mode != (i64)1) || (((i64)(*b).mode != (i64)1) && ((i64)(*b).mode != (i64)3)))) {
        aa_lib$gerror((byte*)"movsxd opnds");
    }
;
    aa_genss$genrrm((i64)99,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_imul2(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
        i64 opc;
        i64 value;
    if (((i64)(*a).mode != (i64)1)) {
        aa_lib$gerror((byte*)"imul2 opnds");
    }
;
    if (((i64)(*b).size == (i64)0)) {
        (*b).size = (i64)(*a).size;
    }
;
    if (((i64)(*a).size == (i64)1)) {
        aa_lib$gerror((byte*)"imul2 byte");
    }
;
        {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1) || ($temp==(i64)3)) {
        if (((i64)(*a).size != (i64)(*b).size)) {
            aa_lib$gerror((byte*)"imul2 size");
        }
;
        aa_genss$genrrm((i64)4015,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
    }
    else if (($temp==(i64)2)) {
        if (!!((*b).labeldef)) {
            aa_lib$gerror((byte*)"mul/label");
        }
;
        value = (*b).value;
        if (((i64)-128<=value && value<=(i64)127)) {
            opc = (i64)107;
        }
        else {
            opc = (i64)105;
        }
;
        aa_genss$genrrm(opc,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)a);
        if (((i64)-128<=value && value<=(i64)127)) {
            aa_genss$genbyte(value);
        }
        else if (((i64)(*a).size == (i64)2)) {
            aa_genss$genword(value);
        }
        else {
            aa_genss$gendword(value);
        }
;
    }
    else {
        aa_lib$gerror((byte*)"imul2 opnds");
    }
    };
}

static void aa_genss$do_shift(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 code) {
        i64 w;
        i64 opc;
        i64 needdisp;
    if ((((i64)(*a).mode != (i64)1) && ((i64)(*a).mode != (i64)3))) {
        aa_lib$gerror((byte*)"shift opnds1?");
    }
;
    if (!!((*b).labeldef)) {
        aa_lib$gerror((byte*)"shift/label");
    }
;
    w = (((i64)(*a).size == (i64)1) ? (i64)0 : (i64)1);
    needdisp = (i64)0;
        {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)2)) {
        if (((*b).value == (i64)1)) {
            opc = ((i64)208 + w);
        }
        else {
            opc = ((i64)192 + w);
            needdisp = (i64)1;
        }
;
    }
    else if (($temp==(i64)1)) {
        if ((((i64)(*b).reg != (i64)11) || ((i64)(*b).size != (i64)1))) {
            aa_lib$gerror((byte*)"cl or b10 needed");
        }
;
        opc = ((i64)210 + w);
    }
    else {
        aa_lib$gerror((byte*)"shift opnds2?");
    }
    };
    aa_genss$genxrm(opc,code,(struct aa_decls$opndrec *)a);
    if (!!(needdisp)) {
        aa_genss$genbyte((*b).value);
    }
;
}

static void aa_genss$do_test(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
        i64 value;
    if (((((i64)(*a).mode == (i64)1) && ((i64)(*a).reg == (i64)1)) && ((i64)(*b).mode == (i64)2))) {
        value = (*b).value;
                {i64 $temp = (i64)(*a).size;
if (($temp==(i64)1)) {
            aa_genss$genbyte((i64)168);
            aa_genss$genbyte(value);
        }
        else if (($temp==(i64)2)) {
            aa_genss$genbyte((i64)102);
            aa_genss$genbyte((i64)169);
            aa_genss$genword(value);
        }
        else if (($temp==(i64)4)) {
            aa_genss$genbyte((i64)169);
            aa_genss$gendword(value);
        }
        else {
            aa_genss$genbyte((i64)72);
            aa_genss$genbyte((i64)169);
            aa_genss$gendword(value);
        }
        };
    }
    else if (((((i64)(*a).mode == (i64)1) || ((i64)(*a).mode == (i64)3)) && ((i64)(*b).mode == (i64)2))) {
        aa_genss$genxrm((((i64)(*a).size == (i64)1) ? (i64)246 : (i64)247),(i64)0,(struct aa_decls$opndrec *)a);
                {i64 $temp = (i64)(*a).size;
if (($temp==(i64)1)) {
            aa_genss$genbyte(value);
        }
        else if (($temp==(i64)2)) {
            aa_genss$genword(value);
        }
        else {
            aa_genss$gendword(value);
        }
        };
    }
    else if ((((i64)(*a).mode == (i64)1 || (i64)(*a).mode == (i64)3) && ((i64)(*b).mode == (i64)1))) {
        //domemreg:
L863 :;
;
        aa_genss$genrrm((((i64)(*a).size == (i64)1) ? (i64)132 : (i64)133),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
    }
    else if ((((i64)(*a).mode == (i64)1) && ((i64)(*b).mode == (i64)3))) {
        {struct aa_decls$opndrec *  temp = a; a = b; b = temp; };
        goto L863 ;
;
    }
    else {
        aa_lib$gerror((byte*)"test opnds");
    }
;
}

static void aa_genss$do_loop(struct aa_decls$opndrec *a,i64 opc) {
        i64 offset;
    offset = aa_genss$getrel32((struct aa_decls$strec *)(*a).labeldef,(aa_genss$getcurrdatalen((i64)9) + (i64)1));
    if ((offset < (i64)0)) {
        if ((offset < (i64)-126)) {
            aa_lib$gerror((byte*)"loop jmp out of range");
        }
;
        aa_genss$genbyte(opc);
        aa_genss$genbyte(offset);
    }
    else {
        aa_lib$gerror((byte*)"Can't do loopxx fwd jump");
    }
;
}

static void aa_genss$do_jcxz(struct aa_decls$opndrec *a,i64 opsize) {
        i64 offset;
    offset = aa_genss$getrel32((struct aa_decls$strec *)(*a).labeldef,(aa_genss$getcurrdatalen((i64)10) + (i64)1));
    if ((offset < (i64)0)) {
        if ((offset < (i64)-126)) {
            aa_lib$gerror((byte*)"jcxz jmp out of range");
        }
;
        if ((opsize == (i64)4)) {
            aa_genss$genbyte((i64)103);
        }
;
        aa_genss$genbyte((i64)227);
        aa_genss$genbyte(offset);
    }
    else {
        aa_lib$gerror((byte*)"Can't do jcxz fwd jump");
    }
;
}

static void aa_genss$do_setcc(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
    if ((!(((i64)(*b).mode == (i64)1 || (i64)(*b).mode == (i64)3)) || ((i64)(*b).size > (i64)1))) {
        aa_lib$gerror((byte*)"setcc opnd/size");
    }
;
    aa_genss$genxrm(((i64)3984 + (*a).value),(i64)0,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_arithxmm(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 prefix,i64 opc) {
    if ((((i64)(*a).mode != (i64)5) || (((i64)(*b).mode != (i64)5) && ((i64)(*b).mode != (i64)3)))) {
        aa_lib$gerror((byte*)"arithxmm opnds");
    }
;
    if (!!(prefix)) {
        aa_genss$genbyte(prefix);
    }
;
    aa_genss$genrrm(((i64)3840 + opc),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_logicxmm(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 opc,i64 size) {
    if ((((i64)(*a).mode != (i64)5) || (((i64)(*b).mode != (i64)5) && ((i64)(*b).mode != (i64)3)))) {
        aa_lib$gerror((byte*)"logicxmm opnds");
    }
;
    if ((size == (i64)8)) {
        aa_genss$genbyte((i64)102);
    }
;
    aa_genss$genrrm(((i64)3840 + opc),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_convertfloat(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 prefix) {
    if ((((i64)(*a).mode != (i64)5) || (((i64)(*b).mode != (i64)5) && ((i64)(*b).mode != (i64)3)))) {
        aa_lib$gerror((byte*)"convertfloat opnds");
    }
;
    aa_genss$genbyte(prefix);
    aa_genss$nowmask = (i64)1;
    aa_genss$genrrm((i64)3930,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_fix(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 prefix,i64 opc) {
    if ((((i64)(*a).mode != (i64)1) || (((i64)(*b).mode != (i64)5) && ((i64)(*b).mode != (i64)3)))) {
        aa_lib$gerror((byte*)"fix opnds");
    }
;
    aa_genss$checksize((struct aa_decls$opndrec *)a,(i64)4,(i64)8);
    (*b).size = ((prefix == (i64)243) ? (i64)4 : (i64)8);
    aa_genss$genbyte(prefix);
    aa_genss$genrrm(((i64)3840 + opc),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_float(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 prefix) {
    if ((((i64)(*a).mode != (i64)5) || (((i64)(*b).mode != (i64)1) && ((i64)(*b).mode != (i64)3)))) {
        aa_lib$gerror((byte*)"float opnds");
    }
;
    aa_genss$checksize((struct aa_decls$opndrec *)b,(i64)4,(i64)8);
    (*a).size = ((prefix == (i64)243) ? (i64)4 : (i64)8);
    aa_genss$genbyte(prefix);
    aa_genss$usesizeb = (i64)1;
    aa_genss$genrrm((i64)3882,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_call(struct aa_decls$opndrec *a) {
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)2)) {
        aa_genss$genbyte((i64)232);
        aa_genss$genrel32((struct aa_decls$opndrec *)a);
    }
    else {
                {i64 $temp = (i64)(*a).size;
if (($temp==(i64)0)) {
            (*a).size = (i64)8;
        }
        else if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4)) {
            aa_lib$gerror((byte*)"call[]size");
        }
        };
        aa_genss$genxrm((i64)255,(i64)2,(struct aa_decls$opndrec *)a);
    }
    };
}

static void aa_genss$do_jmp(struct aa_decls$opndrec *a,struct aa_lib$mclrec *m) {
        i64 offset;
        i64 shortjmp;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)2)) {
        offset = aa_genss$getrel32((struct aa_decls$strec *)(*a).labeldef,(aa_genss$getcurrdatalen((i64)11) + (i64)1));
        if (((offset < (i64)0) && (offset > (i64)-126))) {
            aa_genss$genbyte((i64)235);
            aa_genss$genbyte(offset);
        }
        else {
            shortjmp = (i64)0;
            if ((offset > (i64)0)) {
                shortjmp = aa_genss$checkshortjump((struct aa_lib$mclrec *)m,(struct aa_decls$strec *)(*a).labeldef);
            }
;
            if (!(!!(shortjmp))) {
                aa_genss$genbyte((i64)233);
                aa_genss$genrel32((struct aa_decls$opndrec *)a);
            }
            else {
                aa_genss$genbyte((i64)235);
                aa_genss$genrel8((struct aa_decls$opndrec *)a);
            }
;
        }
;
    }
    else {
                {i64 $temp = (i64)(*a).size;
if (($temp==(i64)0)) {
            (*a).size = (i64)8;
        }
        else if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4)) {
            aa_lib$gerror((byte*)"jmp[]size");
        }
        };
        aa_genss$genxrm((i64)255,(i64)4,(struct aa_decls$opndrec *)a);
    }
    };
}

static i64 aa_genss$getcurrdatalen(i64 id) {
    if ((aa_genss$currseg == (i64)3)) {
        return aa_decls$ss_zdatalen;
    }
;
    return aa_lib$bufferlength((struct aa_decls$dbuffer *)aa_genss$currdata);
}

static void aa_genss$do_cmovcc(struct aa_decls$opndrec *c,struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
    if ((((i64)(*a).size != (i64)(*b).size) && !!((i64)(*b).size))) {
        aa_lib$gerror((byte*)"Opnd size mismatch");
    }
;
    if (((i64)(*a).size == (i64)1)) {
        aa_lib$gerror((byte*)"cmov/byte");
    }
;
    aa_genss$genrrm(((i64)3904 + (*c).value),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_fmem(struct aa_decls$opndrec *a,i64 freal,i64 code) {
        i64 mf;
    if (((i64)(*a).mode != (i64)3)) {
        aa_lib$gerror((byte*)"fmem/not mem");
    }
;
    if (!!(freal)) {
                {i64 $temp = (i64)(*a).size;
if (($temp==(i64)4)) {
            mf = (i64)0;
        }
        else if (($temp==(i64)8)) {
            mf = (i64)2;
        }
        else if (($temp==(i64)10) || ($temp==(i64)16)) {
            mf = (i64)1;
            if ((code==(i64)0)) {
                code = (i64)5;
            }
            else if ((code==(i64)3)) {
                code = (i64)7;
            }
            else {
                aa_lib$gerror((byte*)"r80 not allowed");
            }
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"SIZE=",NULL);
            msysc$m_print_i64((i64)(*a).size,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            aa_lib$gerror((byte*)"fmem size");
        }
        };
    }
    else {
                {i64 $temp = (i64)(*a).size;
if (($temp==(i64)2)) {
            mf = (i64)3;
        }
        else if (($temp==(i64)4)) {
            mf = (i64)1;
        }
        else if (($temp==(i64)8)) {
            mf = (i64)3;
            if ((code==(i64)0)) {
                code = (i64)5;
            }
            else if ((code==(i64)3)) {
                code = (i64)7;
            }
            else {
                aa_lib$gerror((byte*)"fst i64?");
            }
;
        }
        else {
            aa_lib$gerror((byte*)"fmem int size");
        }
        };
    }
;
    aa_genss$genxrm(((i64)217 + (mf << (i64)1)),code,(struct aa_decls$opndrec *)a);
}

static i64 aa_genss$getr32bits(r64 x) {
        r32 sx;
    sx = (r32)x;
    return *(i64*)&sx;
}

static void aa_genss$genrel8(struct aa_decls$opndrec *a) {
        struct aa_decls$strec *  d;
    d = (struct aa_decls$strec *)(*a).labeldef;
    if (((i64)(*d).reftype == (i64)1)) {
        (*d).fwdrefs = (struct aa_decls$fwdrec *)aa_genss$addfwdref((struct aa_decls$fwdrec *)(*d).fwdrefs,aa_genss$getcurrdatalen((i64)3),(i64)6,(i64)0);
        aa_genss$genbyte((i64)0);
    }
    else {
        aa_lib$gerror((byte*)"genrel8");
    }
;
}

static i64 aa_genss$checkshortjump(struct aa_lib$mclrec *m,struct aa_decls$strec *d) {
        i64 n;
    n = (i64)0;
    m = (struct aa_lib$mclrec *)(*m).nextmcl;
    L864 :;
    while ((!!(m) && (n <= (i64)8))) {
        ++(n);
        if ((((i64)(*m).opcode == (i64)4) && ((*(*m).a).labeldef == d))) {
            return (i64)1;
        }
;
        m = (struct aa_lib$mclrec *)(*m).nextmcl;
L865 :;
    }
L866 :;
    ;
    return (i64)0;
}

static struct aa_decls$fwdrec *aa_genss$addfwdref(struct aa_decls$fwdrec *p,i64 offset,i64 reltype,i64 seg) {
        struct aa_decls$fwdrec *  q;
    q = (struct aa_decls$fwdrec *)mlib$pcm_alloc((i64)16);
    (*q).nextfwd = (struct aa_decls$fwdrec *)p;
    (*q).offset = offset;
    (*q).reltype = reltype;
    (*q).seg = seg;
    return (struct aa_decls$fwdrec *)q;
}

static void aa_genss$switchseg(i64 newseg) {
    if ((newseg == aa_genss$currseg)) {
        return;
    }
;
    if ((aa_genss$currseg==(i64)1)) {
        aa_decls$ss_coderelocs = (struct aa_decls$relocrec *)aa_genss$currrelocs;
        aa_decls$ss_ncoderelocs = aa_genss$nrelocs;
    }
    else if ((aa_genss$currseg==(i64)2)) {
        aa_decls$ss_idatarelocs = (struct aa_decls$relocrec *)aa_genss$currrelocs;
        aa_decls$ss_nidatarelocs = aa_genss$nrelocs;
    }
;
    aa_genss$currseg = newseg;
    if ((aa_genss$currseg==(i64)1)) {
        aa_genss$currdata = (struct aa_decls$dbuffer *)aa_decls$ss_code;
        aa_genss$currrelocs = (struct aa_decls$relocrec *)aa_decls$ss_coderelocs;
        aa_genss$nrelocs = aa_decls$ss_ncoderelocs;
    }
    else if ((aa_genss$currseg==(i64)2)) {
        aa_genss$currdata = (struct aa_decls$dbuffer *)aa_decls$ss_idata;
        aa_genss$currrelocs = (struct aa_decls$relocrec *)aa_decls$ss_idatarelocs;
        aa_genss$nrelocs = aa_decls$ss_nidatarelocs;
    }
    else if ((aa_genss$currseg==(i64)3)) {
        aa_genss$currdata = (struct aa_decls$dbuffer *)aa_decls$ss_zdata;
    }
;
}

static void aa_genss$do_popcnt(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
    if (((i64)(*b).mode == (i64)3)) {
        if (((i64)(*b).size == (i64)0)) {
            (*b).size = (i64)8;
        }
;
    }
;
    aa_genss$f3override = (i64)1;
    aa_genss$genrrm((i64)4024,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$do_bsf(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 opc) {
    if (((i64)(*b).mode == (i64)3)) {
        if (((i64)(*b).size == (i64)0)) {
            (*b).size = (i64)8;
        }
;
    }
;
    if (((i64)(*a).size != (i64)(*b).size)) {
        aa_lib$gerror((byte*)"bsf size");
    }
;
    aa_genss$genrrm(((i64)3840 + opc),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static void aa_genss$extendsymboltable(void) {
        struct aa_decls$strec *(*oldsymboltable)[];
        i64 oldsymboltablesize;
        i64 i;
    oldsymboltablesize = aa_decls$ss_symboltablesize;
    oldsymboltable = (struct aa_decls$strec *(*)[])aa_decls$ss_symboltable;
    aa_decls$ss_symboltablesize *= (i64)2;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"EXTENDING SYMBOL TABLE TO",NULL);
    msysc$m_print_i64(aa_decls$ss_symboltablesize,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    aa_decls$ss_symboltable = (struct aa_decls$strec *(*)[])mlib$pcm_alloc(((i64)8 * aa_decls$ss_symboltablesize));
    for (i=(i64)1;i<=aa_decls$ss_nsymbols;++i) {
L867 :;
        (*aa_decls$ss_symboltable)[(i)-1] = (struct aa_decls$strec *)(*oldsymboltable)[(i)-1];
L868 :;
    }
L869 :;
    ;
    mlib$pcm_free(oldsymboltable,((i64)8 * oldsymboltablesize));
}

static void aa_genss$do_pcmpistri(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 c,i64 opc) {
    if ((((i64)(*a).mode != (i64)5) || (((i64)(*b).mode != (i64)5) && ((i64)(*b).mode != (i64)3)))) {
        aa_lib$gerror((byte*)"pcmpistrx opnds");
    }
;
    (*a).size = ((*b).size = (i64)8);
    aa_genss$sizeoverride = (i64)1;
    aa_genss$nowmask = (i64)1;
    aa_genss$genrrm((i64)997987,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
    aa_genss$genbyte(c);
}

static void aa_genss$genxrm(i64 opcode,i64 code,struct aa_decls$opndrec *b) {
        i64 am;
    aa_genss$setopsize((struct aa_decls$opndrec *)b);
    am = aa_genss$newgenrm((i64)0,code,b,(i64)0);
        {i64 $temp = (i64)(*aa_genss$currmcl).opcode;
if (($temp==(i64)11) || ($temp==(i64)12)) {
        aa_genss$rex = msysc$m_setdotindex(aa_genss$rex,(i64)3,(u64)0u);
    }
    };
    aa_genss$genrex();
    if (!!((opcode & (i64)16711680))) {
        aa_genss$genbyte(((opcode >> (i64)16) & (i64)255));
    }
;
    if (!!((opcode & (i64)65280))) {
        aa_genss$genbyte(((opcode >> (i64)8) & (i64)255));
    }
;
    aa_genss$genbyte(opcode);
    aa_genss$genamode((struct aa_decls$opndrec *)b,am);
}

static void aa_genss$genrrm(i64 opcode,struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
        i64 am;
    aa_genss$setopsize((struct aa_decls$opndrec *)a);
    if (!!((i64)aa_genss$usesizeb)) {
        aa_genss$rex = msysc$m_setdotindex(aa_genss$rex,(i64)3,(u64)0u);
        if (((i64)(*b).size == (i64)8)) {
            aa_genss$rex |= (u8)8u;
        }
;
    }
;
    aa_genss$checkhighreg((struct aa_decls$opndrec *)a);
    am = aa_genss$newgenrm((i64)(*a).reg,(i64)0,b,(i64)((i64)(*a).mode == (i64)5));
    aa_genss$genrex();
    if (!!((opcode & (i64)16711680))) {
        aa_genss$genbyte(((opcode >> (i64)16) & (i64)255));
    }
;
    if (!!((opcode & (i64)65280))) {
        aa_genss$genbyte(((opcode >> (i64)8) & (i64)255));
    }
;
    aa_genss$genbyte(opcode);
    aa_genss$genamode((struct aa_decls$opndrec *)b,am);
}

static i64 aa_genss$getregcode(i64 reg,i64 mask,i64 isxreg) {
        i64 regcode;
    if (!(!!(isxreg))) {
        regcode = (i64)aa_tables$regcodes[(reg)];
    }
    else {
        regcode = (reg - (i64)1);
    }
;
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        aa_genss$rex |= (byte)mask;
    }
;
    return regcode;
}

static void aa_genss$checkimmrange(i64 value,i64 size) {
    if ((size==(i64)1)) {
        if (!(((i64)-128<=value && value<=(i64)255))) {
            aa_lib$gerror((byte*)"exceeding byte value");
        }
;
    }
    else if ((size==(i64)2)) {
        if (!(((i64)-32768<=value && value<=(i64)65535))) {
            aa_lib$gerror((byte*)"exceeding word16 value");
        }
;
    }
    else {
        if (!(((i64)-2147483648<=value && value<=(i64)4294967295))) {
            aa_lib$gerror((byte*)"2:exceeding word32 value");
        }
;
    }
;
}

static i64 aa_genss$newgenrm(i64 reg,i64 opc,struct aa_decls$opndrec *b,i64 isxreg) {
        static i64 scaletable[8] = {(i64)0,(i64)1,(i64)0,(i64)2,(i64)0,(i64)0,(i64)0,(i64)3};
        i64 mode;
        i64 rm;
        i64 scale;
        i64 dispsize;
        i64 needsib;
        i64 sib;
        i64 index;
        i64 base;
        i64 regix;
    mode = (rm = (i64)0);
    scale = (i64)0;
    dispsize = (i64)0;
    needsib = (i64)0;
    sib = (i64)-1;
    if ((((i64)(*b).mode == (i64)3) && ((i64)(*b).addrsize == (i64)4))) {
        aa_genss$addroverride = (i64)1;
    }
;
    if (!!(reg)) {
        opc = aa_genss$getregcode(reg,(i64)4,isxreg);
    }
;
        {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1) || ($temp==(i64)5)) {
        rm = aa_genss$getregcode((i64)(*b).reg,(i64)1,(i64)((i64)(*b).mode == (i64)5));
        aa_genss$checkhighreg((struct aa_decls$opndrec *)b);
        return aa_genss$makeam(aa_genss$makemodrm((i64)3,opc,rm),sib,dispsize);
    }
    else if (($temp==(i64)3)) {
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"OPNDNAMES[B.MODE]=",NULL);
        msysc$m_print_str(aa_lib$opndnames[((i64)(*b).mode)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        aa_lib$gerror((byte*)"genrm not mem");
    }
    };
    reg = (i64)(*b).reg;
    regix = (i64)(*b).regix;
    if ((reg==regix && regix==(i64)0)) {
        mode = (i64)0;
        rm = (i64)4;
        scale = (i64)1;
        index = (i64)4;
        base = (i64)5;
        dispsize = (i64)4;
    }
    else if ((((i64)(*b).scale <= (i64)1) && (regix == (i64)0))) {
        dispsize = aa_genss$getdispsize((struct aa_decls$opndrec *)b,(i64)0);
        if (!!(dispsize)) {
            mode = ((dispsize == (i64)1) ? (i64)1 : (i64)2);
        }
;
        rm = (base = aa_genss$getregcode(reg,(i64)1,(i64)0));
        if ((rm != (i64)4)) {
            if (((rm == (i64)5) && (dispsize == (i64)0))) {
                mode = (i64)1;
                dispsize = (i64)1;
            }
;
            index = (i64)0;
        }
        else {
            index = (i64)4;
            scale = (i64)1;
        }
;
    }
    else if ((!!(regix) && (reg == (i64)0))) {
        dispsize = (i64)4;
        mode = (i64)0;
        rm = (i64)4;
        scale = (!!((i64)(*b).scale) ? (i64)(*b).scale : (i64)1);
        base = (i64)5;
        index = aa_genss$getregcode(regix,(i64)2,(i64)0);
        if ((regix == (i64)16)) {
            aa_lib$gerror((byte*)"Scaled rstack?");
        }
;
    }
    else {
        dispsize = aa_genss$getdispsize((struct aa_decls$opndrec *)b,(i64)0);
        if (!!(dispsize)) {
            mode = ((dispsize == (i64)1) ? (i64)1 : (i64)2);
        }
;
        rm = (i64)4;
        scale = (!!((i64)(*b).scale) ? (i64)(*b).scale : (i64)1);
        if ((reg == (i64)0)) {
            base = (i64)5;
        }
        else {
            if (((reg == (i64)15 || reg == (i64)8) && (dispsize == (i64)0))) {
                mode = (i64)1;
                dispsize = (i64)1;
            }
;
            base = aa_genss$getregcode(reg,(i64)1,(i64)0);
        }
;
        if ((regix == (i64)0)) {
            index = (i64)4;
        }
        else {
            index = aa_genss$getregcode(regix,(i64)2,(i64)0);
        }
;
        if ((!!(regix) && !(!!(reg)))) {
            dispsize = (i64)4;
        }
;
        if (((regix == (i64)16) && (scale > (i64)1))) {
            aa_lib$gerror((byte*)"Can't scale rstack");
        }
;
    }
;
    if (!!(scale)) {
        sib = (((scaletable[(scale)-1] << (i64)6) + (index << (i64)3)) + base);
    }
;
    return aa_genss$makeam(aa_genss$makemodrm(mode,opc,rm),sib,dispsize);
}

static void aa_genss$do_mov(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
        i64 regcode;
        i64 opc;
        i64 value;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
                {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1) || ($temp==(i64)3)) {
            if ((((i64)(*a).size != (i64)(*b).size) && !!((i64)(*b).size))) {
                aa_lib$gerror((byte*)"Opnd size mismatch");
            }
;
            aa_genss$genrrm((((i64)(*a).size == (i64)1) ? (i64)138 : (i64)139),(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        else if (($temp==(i64)2)) {
            value = (*b).value;
            regcode = aa_genss$getregcode((i64)(*a).reg,(i64)1,(i64)0);
            aa_genss$setopsize((struct aa_decls$opndrec *)a);
            if ((!!((*b).labeldef) && ((i64)(*a).size <= (i64)2))) {
                aa_lib$gerror((byte*)"mov imm?");
            }
;
                        {i64 $temp = (i64)(*a).size;
if (($temp==(i64)1)) {
                if (!(((i64)-128<=value && value<=(i64)255))) {
                    aa_lib$gerror((byte*)"exceeding byte value");
                }
;
                aa_genss$genrex();
                aa_genss$genbyte(((i64)176 + regcode));
                aa_genss$genbyte(value);
            }
            else if (($temp==(i64)2)) {
                if (!(((i64)-32768<=value && value<=(i64)65535))) {
                    aa_lib$gerror((byte*)"exceeding word16 value");
                }
;
                aa_genss$genbyte((i64)102);
                aa_genss$genrex();
                aa_genss$genbyte(((i64)184 + regcode));
                aa_genss$genword(value);
            }
            else if (($temp==(i64)4)) {
                if (!!((*b).labeldef)) {
                    aa_genss$genrex();
                    aa_genss$genbyte(((i64)184 + regcode));
                    aa_genss$genopnd((struct aa_decls$opndrec *)b,(i64)4);
                }
                else {
                    if (!(((i64)-2147483648<=value && value<=(i64)(u32)(i64)4294967295))) {
                        msysc$m_print_startcon();
                        msysc$m_print_i64(value,NULL);
                        msysc$m_print_ptr((void *)value,NULL);
                        msysc$m_print_newline();
                        msysc$m_print_end();
                        ;
                        aa_lib$gerror((byte*)"1:exceeding word32 value");
                    }
;
                    //doreg32:
L870 :;
;
                    aa_genss$genrex();
                    aa_genss$genbyte(((i64)184 + regcode));
                    aa_genss$gendword(value);
                }
;
            }
            else {
                if (!!((*b).labeldef)) {
                    aa_genss$rex |= (u8)8u;
                    aa_genss$genrex();
                    aa_genss$genbyte(((i64)184 + regcode));
                    aa_genss$genopnd((struct aa_decls$opndrec *)b,(i64)8);
                }
                else {
                    if (((value >= (i64)0) && (value <= (i64)4294967295))) {
                        aa_genss$rex = msysc$m_setdotindex(aa_genss$rex,(i64)3,(u64)0u);
                        goto L870 ;
;
                    }
;
                    aa_genss$rex |= (u8)8u;
                    aa_genss$genrex();
                    aa_genss$genbyte(((i64)184 + regcode));
                    aa_genss$genqword(value);
                }
;
            }
            };
        }
        else {
            aa_lib$gerror((byte*)"MOV REG/??");
        }
        };
    }
    else if (($temp==(i64)3)) {
                {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1)) {
            if (((i64)(*a).size == (i64)0)) {
                (*a).size = (i64)(*b).size;
            }
;
            if ((((i64)(*a).size != (i64)(*b).size) && !!((i64)(*a).size))) {
                aa_lib$gerror((byte*)"Opnd size mismatch");
            }
;
            aa_genss$genrrm((((i64)(*b).size == (i64)1) ? (i64)136 : (i64)137),(struct aa_decls$opndrec *)b,(struct aa_decls$opndrec *)a);
        }
        else if (($temp==(i64)2)) {
            value = (*b).value;
            if (((i64)(*a).size == (i64)0)) {
                (*a).size = (i64)1;
            }
;
            if ((!!((*b).labeldef) && ((i64)(*a).size <= (i64)2))) {
                aa_lib$gerror((byte*)"mov imm?");
            }
;
            aa_genss$setopsize((struct aa_decls$opndrec *)a);
            opc = (((i64)(*a).size == (i64)1) ? (i64)198 : (i64)199);
            if (!(!!((*b).labeldef))) {
                aa_genss$checkimmrange(value,(i64)(*a).size);
            }
;
            aa_genss$genxrm(opc,(i64)0,(struct aa_decls$opndrec *)a);
            value = (*b).value;
                        {i64 $temp = (i64)(*a).size;
if (($temp==(i64)1)) {
                aa_genss$genbyte(value);
            }
            else if (($temp==(i64)2)) {
                aa_genss$genword(value);
            }
            else if (($temp==(i64)4) || ($temp==(i64)8)) {
                aa_genss$genopnd((struct aa_decls$opndrec *)b,(i64)4);
            }
            };
        }
        else {
            aa_lib$gerror((byte*)"MOV MEM/?");
        }
        };
    }
    else {
        aa_lib$gerror((byte*)"MOV ?/..");
    }
    };
}

static void aa_genss$do_arith(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 code) {
        i64 opc;
        i64 dispsize;
        i64 x;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
                {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1) || ($temp==(i64)3)) {
            opc = ((code << (i64)3) | (((i64)(*a).size == (i64)1) ? (i64)2 : (i64)3));
            aa_genss$genrrm(opc,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        else if (($temp==(i64)2)) {
            //doregimm:
L871 :;
;
            if (!!((*b).labeldef)) {
                if (((i64)(*a).size < (i64)4)) {
                    aa_lib$gerror((byte*)"add imm/size");
                }
;
                aa_genss$genxrm((i64)129,code,(struct aa_decls$opndrec *)a);
                aa_genss$genopnd((struct aa_decls$opndrec *)b,(i64)4);
                return;
            }
;
            x = (*b).value;
            dispsize = (i64)1;
            if (((i64)(*a).size == (i64)1)) {
                opc = (i64)128;
                aa_genss$checkimmrange(x,(i64)1);
                if (!((x >= (i64)-128 && x <= (i64)255))) {
                    aa_lib$gerror((byte*)"Exceeding i8/u8 range");
                }
;
            }
            else if (((i64)-128<=x && x<=(i64)127)) {
                opc = (i64)131;
            }
            else {
                aa_genss$checkimmrange(x,(i64)4);
                opc = (i64)129;
                dispsize = (((i64)(*a).size == (i64)2) ? (i64)2 : (i64)4);
            }
;
            aa_genss$genxrm(opc,code,(struct aa_decls$opndrec *)a);
            if ((dispsize==(i64)1)) {
                aa_genss$genbyte(x);
            }
            else if ((dispsize==(i64)2)) {
                aa_genss$genword(x);
            }
            else if ((dispsize==(i64)4)) {
                aa_genss$gendword(x);
            }
;
        }
        else {
            aa_lib$gerror((byte*)"ADD reg,???");
        }
        };
    }
    else if (($temp==(i64)3)) {
                {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1)) {
            opc = ((code << (i64)3) | (((i64)(*b).size == (i64)1) ? (i64)0 : (i64)1));
            aa_genss$genrrm(opc,(struct aa_decls$opndrec *)b,(struct aa_decls$opndrec *)a);
        }
        else if (($temp==(i64)2)) {
            goto L871 ;
;
        }
        else {
            aa_lib$gerror((byte*)"ADD mem,???");
        }
        };
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(aa_genss$opnames[(code)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        aa_lib$gerror((byte*)"Can't add to this opnd");
    }
    };
}

static void aa_genss$do_movxmm(struct aa_decls$opndrec *a,struct aa_decls$opndrec *b,i64 size) {
    if (((i64)(*b).size == (i64)0)) {
        (*b).size = size;
    }
;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
                {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)5)) {
            if (((i64)(*a).size != size)) {
                aa_lib$gerror((byte*)"1:movdq size");
            }
;
            (*b).size = (i64)(*a).size;
            aa_genss$sizeoverride = (i64)1;
            aa_genss$genrrm((i64)3966,(struct aa_decls$opndrec *)b,(struct aa_decls$opndrec *)a);
        }
        else {
            aa_lib$gerror((byte*)"movdq reg,?");
        }
        };
    }
    else if (($temp==(i64)5)) {
                {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)1)) {
            (*a).size = (i64)(*b).size;
            if (((i64)(*b).size != size)) {
                aa_lib$gerror((byte*)"3:movdq size");
            }
;
            aa_genss$sizeoverride = (i64)1;
            aa_genss$genrrm((i64)3950,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        else if (($temp==(i64)5)) {
            (*a).size = (i64)(*b).size;
            aa_genss$f3override = (i64)1;
            aa_genss$genrrm((i64)3966,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
        }
        else if (($temp==(i64)3)) {
            (*a).size = (i64)(*b).size;
            if (((i64)(*b).size != size)) {
                aa_lib$gerror((byte*)"3:movdq size");
            }
;
            if ((size == (i64)4)) {
                aa_genss$sizeoverride = (i64)1;
                aa_genss$nowmask = (i64)1;
                aa_genss$genrrm((i64)3950,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
            }
            else {
                aa_genss$f3override = (i64)1;
                aa_genss$nowmask = (i64)1;
                aa_genss$genrrm((i64)3966,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
            }
;
        }
        else {
            aa_lib$gerror((byte*)"movdq xreg,?");
        }
        };
    }
    else if (($temp==(i64)3)) {
                {i64 $temp = (i64)(*b).mode;
if (($temp==(i64)5)) {
            if ((!!((i64)(*a).size) && ((i64)(*a).size != size))) {
                aa_lib$gerror((byte*)"5:movdq size");
            }
;
            aa_genss$sizeoverride = (i64)1;
            aa_genss$genrrm(((size == (i64)4) ? (i64)3966 : (i64)4054),(struct aa_decls$opndrec *)b,(struct aa_decls$opndrec *)a);
        }
        else {
            aa_lib$gerror((byte*)"movdq mem,?");
        }
        };
    }
    else {
        aa_lib$gerror((byte*)"movdq opnds");
    }
    };
}

static void aa_genss$checksize(struct aa_decls$opndrec *a,i64 size1,i64 size2) {
    if (((i64)(*a).size == (i64)0)) {
        aa_lib$gerror((byte*)"Need size");
    }
;
    if ((!!(size1) && !(((i64)(*a).size == size1 || (i64)(*a).size == size2)))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"A.SIZE=",NULL);
        msysc$m_print_i64((i64)(*a).size,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        aa_lib$gerror((byte*)"Wrong size");
    }
;
}

// START
void aa_genss$start(void) {

}

void aa_lex$lex(void) {
        i64 i;
        i64 c;
        i64 hsum;
        i64 length;
        byte *  pstart;
    aa_lex$lxsubcode = (i64)0;
    L872 :;
    switch ((c = (i64)(*(aa_lex$lxsptr)++))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
    case 46:;
        {
            pstart = (aa_lex$lxsptr - (i64)1);
            hsum = c;
            //doname:
L874 :;
;
            L875 :;
            switch ((c = (i64)(*(aa_lex$lxsptr)++))) {
            case 97:;
            case 98:;
            case 99:;
            case 100:;
            case 101:;
            case 102:;
            case 103:;
            case 104:;
            case 105:;
            case 106:;
            case 107:;
            case 108:;
            case 109:;
            case 110:;
            case 111:;
            case 112:;
            case 113:;
            case 114:;
            case 115:;
            case 116:;
            case 117:;
            case 118:;
            case 119:;
            case 120:;
            case 121:;
            case 122:;
            case 48:;
            case 49:;
            case 50:;
            case 51:;
            case 52:;
            case 53:;
            case 54:;
            case 55:;
            case 56:;
            case 57:;
            case 95:;
            case 36:;
            case 46:;
                {
                    hsum = (((hsum << (i64)4) - hsum) + c);
                }
                break;
            case 65:;
            case 66:;
            case 67:;
            case 68:;
            case 69:;
            case 70:;
            case 71:;
            case 72:;
            case 73:;
            case 74:;
            case 75:;
            case 76:;
            case 77:;
            case 78:;
            case 79:;
            case 80:;
            case 81:;
            case 82:;
            case 83:;
            case 84:;
            case 85:;
            case 86:;
            case 87:;
            case 88:;
            case 89:;
            case 90:;
                {
                    (*(aa_lex$lxsptr - (i64)1)) = (c + (i64)32);
                    hsum = ((((hsum << (i64)4) - hsum) + c) + (i64)32);
                }
                break;
            default: {
                --(aa_lex$lxsptr);
                goto L876 ;
            }
            } //SW
goto L875 ;
L876 :;
            ;
            aa_lex$lxlength = (aa_lex$lxsptr - pstart);
            aa_lex$lxhashvalue = ((hsum << (i64)5) - hsum);
            if (!!(aa_lex$lookuplex((u8 *)pstart,aa_lex$lxlength))) {
                if (!!((i64)(*aa_lex$lxsymptr).ksymbol)) {
                    aa_lex$lxsymbol = (i64)(*aa_lex$lxsymptr).ksymbol;
                    aa_lex$lxsubcode = (i64)(*aa_lex$lxsymptr).subcode;
                }
                else {
                    aa_lex$lxsymbol = (i64)(*aa_lex$lxsymptr).symbol;
                }
;
            }
            else {
                aa_lex$lxsymbol = (i64)17;
            }
;
            return;
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
        {
            pstart = (aa_lex$lxsptr - (i64)1);
            hsum = ((*pstart) = (c + (i64)32));
            goto L874 ;
;
        }
        break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            aa_lex$readnumber(c);
            return;
        }
        break;
    case 96:;
        {
            pstart = aa_lex$lxsptr;
            hsum = (i64)0;
            L877 :;
            switch ((c = (i64)(*aa_lex$lxsptr))) {
            case 65:;
            case 66:;
            case 67:;
            case 68:;
            case 69:;
            case 70:;
            case 71:;
            case 72:;
            case 73:;
            case 74:;
            case 75:;
            case 76:;
            case 77:;
            case 78:;
            case 79:;
            case 80:;
            case 81:;
            case 82:;
            case 83:;
            case 84:;
            case 85:;
            case 86:;
            case 87:;
            case 88:;
            case 89:;
            case 90:;
            case 97:;
            case 98:;
            case 99:;
            case 100:;
            case 101:;
            case 102:;
            case 103:;
            case 104:;
            case 105:;
            case 106:;
            case 107:;
            case 108:;
            case 109:;
            case 110:;
            case 111:;
            case 112:;
            case 113:;
            case 114:;
            case 115:;
            case 116:;
            case 117:;
            case 118:;
            case 119:;
            case 120:;
            case 121:;
            case 122:;
            case 48:;
            case 49:;
            case 50:;
            case 51:;
            case 52:;
            case 53:;
            case 54:;
            case 55:;
            case 56:;
            case 57:;
            case 95:;
            case 36:;
            case 46:;
                {
                    ++(aa_lex$lxsptr);
                    hsum = (((hsum << (i64)4) - hsum) + c);
                }
                break;
            default: {
                goto L878 ;
            }
            } //SW
goto L877 ;
L878 :;
            ;
            aa_lex$lxsymbol = (i64)17;
            if ((pstart == aa_lex$lxsptr)) {
                aa_lex$lxerror((byte*)"NULL ` name");
            }
;
            aa_lex$lxlength = (aa_lex$lxsptr - pstart);
            aa_lex$lxhashvalue = ((hsum << (i64)5) - hsum);
            if (!!(aa_lex$lookuplex((u8 *)pstart,aa_lex$lxlength))) {
                aa_lex$lxsymbol = (i64)(*aa_lex$lxsymptr).symbol;
                if ((aa_lex$lxsymbol == (i64)0)) {
                    aa_lex$lxsymbol = ((*aa_lex$lxsymptr).symbol = (i64)17);
                }
;
            }
;
            return;
        }
        break;
    case 33:;
    case 59:;
    case 35:;
        {
            L879 :;
            while (!!((u64)aa_lex$commentmap[((i64)(*(aa_lex$lxsptr)++))])) {
L880 :;
            }
L881 :;
            ;
            if (((i64)(*(aa_lex$lxsptr - (i64)1)) == (i64)0)) {
                --(aa_lex$lxsptr);
            }
;
            ++(aa_decls$lxlineno);
            aa_lex$lxsymbol = (i64)11;
            return;
        }
        break;
    case 44:;
        {
            aa_lex$lxsymbol = (i64)2;
            return;
        }
        break;
    case 58:;
        {
            if (((i64)(*aa_lex$lxsptr) == (i64)58)) {
                aa_lex$lxsymbol = (i64)4;
                ++(aa_lex$lxsptr);
            }
            else {
                aa_lex$lxsymbol = (i64)3;
            }
;
            return;
        }
        break;
    case 91:;
        {
            aa_lex$lxsymbol = (i64)5;
            return;
        }
        break;
    case 93:;
        {
            aa_lex$lxsymbol = (i64)6;
            return;
        }
        break;
    case 43:;
        {
            aa_lex$lxsymbol = (i64)7;
            return;
        }
        break;
    case 45:;
        {
            aa_lex$lxsymbol = (i64)8;
            return;
        }
        break;
    case 42:;
        {
            aa_lex$lxsymbol = (i64)9;
            return;
        }
        break;
    case 61:;
        {
            aa_lex$lxsymbol = (i64)10;
            return;
        }
        break;
    case 39:;
        {
            pstart = aa_lex$lxsptr;
            L882 :;
            while (1) {
                switch ((i64)(*(aa_lex$lxsptr)++)) {
                case 39:;
                    {
                        goto L883 ;
                    }
                    break;
                case 13:;
                case 10:;
                    {
                        aa_lex$lxerror((byte*)"String not terminated");
                    }
                    break;
                } //SW
;
            }
L883 :;
            ;
            length = ((aa_lex$lxsptr - pstart) - (i64)1);
            aa_lex$lxvalue = (i64)0;
            for (i=length;i>=(i64)1;--i) {
L884 :;
                aa_lex$lxvalue = ((aa_lex$lxvalue << (i64)8) + (i64)(*((pstart + i) - (i64)1)));
L885 :;
            }
L886 :;
            ;
            aa_lex$lxsymbol = (i64)14;
            return;
        }
        break;
    case 34:;
        {
            pstart = aa_lex$lxsptr;
            L887 :;
            while (1) {
                switch ((i64)(*(aa_lex$lxsptr)++)) {
                case 34:;
                    {
                        aa_lex$lxsvalue = (u8 *)pstart;
                        aa_lex$lxlength = ((aa_lex$lxsptr - pstart) - (i64)1);
                        (*(aa_lex$lxsvalue + aa_lex$lxlength)) = (u64)0u;
                        aa_lex$lxsymbol = (i64)16;
                        return;
                    }
                    break;
                case 13:;
                case 10:;
                case 26:;
                case 0:;
                    {
                        aa_lex$lxerror((byte*)"String not terminated");
                    }
                    break;
                } //SW
;
            }
L888 :;
            ;
        }
        break;
    case 32:;
    case 9:;
        {
        }
        break;
    case 13:;
        {
        }
        break;
    case 10:;
        {
            ++(aa_decls$lxlineno);
            aa_lex$lxsymbol = (i64)11;
            return;
        }
        break;
    case 0:;
    case 26:;
        {
            aa_lex$lxsymbol = (i64)12;
            --(aa_lex$lxsptr);
            return;
        }
        break;
    default: {
        aa_lex$lxsymbol = (i64)1;
        aa_lex$lxvalue = c;
        return;
    }
    } //SW
goto L872 ;
L873 :;
    ;
}

void aa_lex$initlex(void) {
        i64 i;
    aa_lex$lxsubcode = (i64)0;
    aa_lex$lxsymbol = (i64)1;
    aa_decls$lxlineno = (i64)0;
    for (i=(i64)0;i<=(i64)255;++i) {
L889 :;
        switch (i) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 36:;
        case 95:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                aa_lex$alphamap[(i)] = (u64)1u;
            }
            break;
        } //SW
;
        switch (i) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                aa_lex$digitmap[(i)] = (u64)1u;
            }
            break;
        } //SW
;
        aa_lex$commentmap[(i)] = (u64)1u;
L890 :;
    }
L891 :;
    ;
    aa_lex$commentmap[((i64)0)] = (u64)0u;
    aa_lex$commentmap[((i64)10)] = (u64)0u;
    aa_lex$inithashtable();
}

static void aa_lex$readreal(u8 (*s)[],i64 slen,i64 intlen,i64 exponseen) {
        i64 i;
        i64 fractlen;
        i64 expon;
        i64 exponsign;
        i64 c;
        i64 digs;
        i64 $av_1;
        i64 $av_2;
    if (((intlen == (i64)0) || (intlen == slen))) {
        fractlen = (i64)0;
    }
    else {
        fractlen = (slen - intlen);
    }
;
    expon = (i64)0;
    exponsign = (i64)0;
    if (!!(exponseen)) {
                {i64 $temp = (c = (i64)(*(aa_lex$lxsptr)++));
if (($temp==(i64)43)) {
        }
        else if (($temp==(i64)45)) {
            exponsign = (i64)1;
        }
        else {
            --(aa_lex$lxsptr);
        }
        };
        digs = (i64)0;
        L892 :;
        switch ((c = (i64)(*(aa_lex$lxsptr)++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                expon = (((expon * (i64)10) + c) - (i64)48);
                ++(digs);
            }
            break;
        default: {
            --(aa_lex$lxsptr);
            goto L893 ;
        }
        } //SW
goto L892 ;
L893 :;
        ;
        if ((digs == (i64)0)) {
            aa_lex$lxerror((byte*)"Exponent error");
        }
;
        if (!!(exponsign)) {
            expon = -(expon);
        }
;
    }
;
    expon = (expon - fractlen);
    aa_lex$lxxvalue = (double)0.;
    for (i=(i64)1;i<=slen;++i) {
L894 :;
        c = (i64)(u64)(*s)[(i)-1];
        aa_lex$lxxvalue = ((aa_lex$lxxvalue * (double)10.) + (r64)(c - (i64)48));
L895 :;
    }
L896 :;
    ;
    if ((expon > (i64)0)) {
        $av_1 = expon;
        while ($av_1-- > 0) {
L897 :;
            aa_lex$lxxvalue = (aa_lex$lxxvalue * (double)10.);
L898 :;
        }
L899 :;
        ;
    }
    else if ((expon < (i64)0)) {
        $av_2 = -(expon);
        while ($av_2-- > 0) {
L900 :;
            aa_lex$lxxvalue = (aa_lex$lxxvalue / (double)10.);
L901 :;
        }
L902 :;
        ;
    }
;
    aa_lex$lxsymbol = (i64)15;
}

static void aa_lex$readnumber(i64 c) {
        u8 str[256];
        i64 i;
        i64 d;
        i64 intlen;
        i64 slen;
    d = (i64)(*aa_lex$lxsptr);
    if ((d==(i64)120) || (d==(i64)88)) {
        if ((c==(i64)48)) {
            ++(aa_lex$lxsptr);
            aa_lex$readhex();
            return;
        }
        else if ((c==(i64)50)) {
            ++(aa_lex$lxsptr);
            aa_lex$readbinary();
            return;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_i64(c,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            aa_lex$lxerror((byte*)"Base not supported");
        }
;
    }
;
    str[((i64)1)-1] = (u64)c;
    slen = (i64)1;
    intlen = (i64)0;
    L903 :;
    switch ((c = (i64)(*(aa_lex$lxsptr)++))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            str[(++(slen))-1] = (u64)c;
        }
        break;
    case 95:;
    case 39:;
    case 96:;
        {
        }
        break;
    case 46:;
        {
            intlen = slen;
        }
        break;
    case 101:;
    case 69:;
        {
            aa_lex$readreal((u8 (*)[])&str,slen,intlen,(i64)1);
            return;
        }
        break;
    default: {
        --(aa_lex$lxsptr);
        goto L904 ;
    }
    } //SW
goto L903 ;
L904 :;
    ;
    if (!!(intlen)) {
        aa_lex$readreal((u8 (*)[])&str,slen,intlen,(i64)0);
        return;
    }
;
    if (((slen > (i64)20) || ((slen == (i64)20) && (mlib$cmpstring((u8 *)str,(byte*)"18446744073709551615") > (i64)0)))) {
        aa_lex$lxerror((byte*)"Overflow in 64-bit value");
    }
;
    aa_lex$lxsymbol = (i64)14;
    aa_lex$lxvalue = (i64)0;
    for (i=(i64)1;i<=slen;++i) {
L905 :;
        aa_lex$lxvalue = (((aa_lex$lxvalue * (i64)10) + (i64)(u64)str[(i)-1]) - (i64)48);
L906 :;
    }
L907 :;
    ;
}

static void aa_lex$readbinary(void) {
        i64 ndigs;
    ndigs = (i64)0;
    aa_lex$lxvalue = (i64)0;
    L908 :;
    switch ((i64)(*(aa_lex$lxsptr)++)) {
    case 48:;
        {
            aa_lex$lxvalue = (aa_lex$lxvalue * (i64)2);
            ++(ndigs);
        }
        break;
    case 49:;
        {
            aa_lex$lxvalue = ((aa_lex$lxvalue * (i64)2) + (i64)1);
            ++(ndigs);
        }
        break;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            aa_lex$lxerror((byte*)"Bad binary digit");
        }
        break;
    case 95:;
    case 39:;
    case 96:;
        {
        }
        break;
    default: {
        --(aa_lex$lxsptr);
        goto L909 ;
    }
    } //SW
goto L908 ;
L909 :;
    ;
    if ((ndigs == (i64)0)) {
        aa_lex$lxerror((byte*)"No bin digits");
    }
    else if ((ndigs > (i64)64)) {
        aa_lex$lxerror((byte*)"Overflow in binary number");
    }
;
    aa_lex$lxsymbol = (i64)14;
}

static void aa_lex$readhex(void) {
        i64 ndigs;
        i64 c;
    ndigs = (i64)0;
    aa_lex$lxvalue = (i64)0;
    L910 :;
    switch ((c = (i64)(*(aa_lex$lxsptr)++))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            aa_lex$lxvalue = (((aa_lex$lxvalue * (i64)16) + c) - (i64)48);
            ++(ndigs);
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
        {
            aa_lex$lxvalue = ((aa_lex$lxvalue * (i64)16) + ((c - (i64)65) + (i64)10));
            ++(ndigs);
        }
        break;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
        {
            aa_lex$lxvalue = ((aa_lex$lxvalue * (i64)16) + ((c - (i64)97) + (i64)10));
            ++(ndigs);
        }
        break;
    case 95:;
    case 39:;
    case 96:;
        {
        }
        break;
    default: {
        --(aa_lex$lxsptr);
        goto L911 ;
    }
    } //SW
goto L910 ;
L911 :;
    ;
    if ((ndigs == (i64)0)) {
        aa_lex$lxerror((byte*)"No hex digits");
    }
    else if ((ndigs > (i64)16)) {
        aa_lex$lxerror((byte*)"Overflow in hex number");
    }
;
    aa_lex$lxsymbol = (i64)14;
}

void aa_lex$ps(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_str((byte*)":",NULL);
    msysc$m_print_end();
    ;
    aa_lex$printsymbol(0);
}

void aa_lex$printsymbol(void *dev) {
        u8 str[256];
        i64 $av_1;
    strcpy((u8 *)str,aa_tables$symbolnames[(aa_lex$lxsymbol)-1]);
    str[((strlen((u8 *)str) - (i64)2))-1] = (u64)0u;
    msysc$m_print_startfile(dev);
    msysc$m_print_str(str,NULL);
    msysc$m_print_end();
    ;
    $av_1 = ((i64)14 - strlen((u8 *)str));
    while ($av_1-- > 0) {
L912 :;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
L913 :;
    }
L914 :;
    ;
    if ((aa_lex$lxsymbol==(i64)17)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*aa_lex$lxsymptr).name,NULL);
        msysc$m_print_end();
        ;
    }
    else if ((aa_lex$lxsymbol==(i64)14)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_i64(aa_lex$lxvalue,NULL);
        msysc$m_print_end();
        ;
    }
    else if ((aa_lex$lxsymbol==(i64)15)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_r64(aa_lex$lxxvalue,NULL);
        msysc$m_print_end();
        ;
    }
    else if ((aa_lex$lxsymbol==(i64)16)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"\"",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(aa_lex$lxsvalue,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)"\"",NULL);
        msysc$m_print_end();
        ;
    }
    else if ((aa_lex$lxsymbol==(i64)1)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_i64(aa_lex$lxvalue,NULL);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startfile(dev);
        msysc$m_print_str(aa_tables$symbolnames[(aa_lex$lxsymbol)-1],NULL);
        msysc$m_print_end();
        ;
        if (!!(aa_lex$lxsubcode)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)" ",NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64(aa_lex$lxsubcode,NULL);
            msysc$m_print_end();
            ;
        }
;
    }
;
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void aa_lex$clearhashtable(void) {
}

static void aa_lex$inithashtable(void) {
        i64 i;
    if (((i64)65536 > (i64)65536)) {
    }
;
    aa_lex$clearhashtable();
    for (i=(i64)1;i<=(i64)147;++i) {
L915 :;
        aa_lex$addreservedword((aa_tables$mclnames[(i)-1] + (i64)2),(i64)23,i);
L916 :;
    }
L917 :;
    ;
    for (i=(i64)1;i<=(i64)136;++i) {
L918 :;
        aa_lex$addreservedword(aa_tables$dregnames[(i)-1],(i64)24,(i64)aa_tables$regindices[(i)-1]);
        (*aa_lex$lxsymptr).regsize = (i64)aa_tables$regsizes[(i)-1];
L919 :;
    }
L920 :;
    ;
    for (i=(i64)1;i<=(i64)16;++i) {
L921 :;
        aa_lex$addreservedword(aa_tables$xregnames[(i)-1],(i64)25,i);
L922 :;
    }
L923 :;
    ;
    for (i=(i64)1;i<=(i64)8;++i) {
L924 :;
        aa_lex$addreservedword(aa_tables$fregnames[(i)-1],(i64)26,i);
L925 :;
    }
L926 :;
    ;
    for (i=(i64)1;i<=(i64)8;++i) {
L927 :;
        aa_lex$addreservedword(aa_tables$mregnames[(i)-1],(i64)27,i);
L928 :;
    }
L929 :;
    ;
    for (i=(i64)1;i<=(i64)18;++i) {
L930 :;
        aa_lex$addreservedword(aa_tables$jmpccnames[(i)-1],(i64)28,(i64)aa_tables$jmpcccodes[(i)-1]);
L931 :;
    }
L932 :;
    ;
    for (i=(i64)1;i<=(i64)18;++i) {
L933 :;
        aa_lex$addreservedword(aa_tables$setccnames[(i)-1],(i64)29,(i64)aa_tables$setcccodes[(i)-1]);
L934 :;
    }
L935 :;
    ;
    for (i=(i64)1;i<=(i64)18;++i) {
L936 :;
        aa_lex$addreservedword(aa_tables$cmovccnames[(i)-1],(i64)30,(i64)aa_tables$cmovcccodes[(i)-1]);
L937 :;
    }
L938 :;
    ;
    for (i=(i64)1;i<=(i64)16;++i) {
L939 :;
        aa_lex$addreservedword(aa_tables$prefixnames[(i)-1],(i64)31,(i64)aa_tables$prefixsizes[(i)-1]);
L940 :;
    }
L941 :;
    ;
    for (i=(i64)1;i<=(i64)5;++i) {
L942 :;
        aa_lex$addreservedword(aa_mcxdecls$segmentnames[(i)-1],(i64)32,i);
L943 :;
    }
L944 :;
    ;
    aa_lex$addreservedword((byte*)"aframe",(i64)24,(i64)15);
    (*aa_lex$lxsymptr).regsize = (i64)4;
    aa_lex$addreservedword((byte*)"dframe",(i64)24,(i64)15);
    (*aa_lex$lxsymptr).regsize = (i64)8;
    aa_lex$addreservedword((byte*)"astack",(i64)24,(i64)16);
    (*aa_lex$lxsymptr).regsize = (i64)4;
    aa_lex$addreservedword((byte*)"dstack",(i64)24,(i64)16);
    (*aa_lex$lxsymptr).regsize = (i64)8;
    aa_lex$addreservedword((byte*)"dprog",(i64)24,(i64)9);
    (*aa_lex$lxsymptr).regsize = (i64)8;
    aa_lex$addreservedword((byte*)"dsptr",(i64)24,(i64)10);
    (*aa_lex$lxsymptr).regsize = (i64)8;
    aa_lex$addreservedword((byte*)"importlib",(i64)33,(i64)0);
    aa_lex$addreservedword((byte*)"importdll",(i64)34,(i64)0);
}

static void aa_lex$addreservedword(u8 *name,i64 symbol,i64 subcode) {
    aa_lex$lxhashvalue = aa_lex$gethashvalue(name);
    if (!!(aa_lex$lookuplex(name,(i64)0))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"NAME=",NULL);
        msysc$m_print_str(name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        aa_lex$lxerror((byte*)"DUPL NAME");
    }
;
    (*aa_lex$lxsymptr).symbol = (i64)0;
    (*aa_lex$lxsymptr).ksymbol = symbol;
    (*aa_lex$lxsymptr).subcode = subcode;
}

void aa_lex$printhashtable(void *devx,u8 *caption) {
        struct aa_decls$strec *  r;
        i64 count;
        i64 i;
    msysc$m_print_startfile(devx);
    msysc$m_print_str(caption,NULL);
    msysc$m_print_str((byte*)":",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    count = (i64)0;
    for (i=(i64)0;i<=(i64)65535;++i) {
L945 :;
        r = (struct aa_decls$strec *)aa_decls$lexhashtable[(i)];
        if ((!!(r) && !!((*r).name))) {
            count += (i64)1;
        }
;
L946 :;
    }
L947 :;
    ;
    msysc$m_print_startfile(devx);
    msysc$m_print_i64(count,NULL);
    msysc$m_print_str((byte*)" items in table",NULL);
    msysc$m_print_i64((i64)65536,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static i64 aa_lex$lookuplex(u8 *name,i64 length) {
        i64 j;
        i64 wrapped;
        i64 insource;
        i64 firstj;
    insource = length;
    if ((length == (i64)0)) {
        length = strlen(name);
    }
;
    firstj = (j = (aa_lex$lxhashvalue & (i64)65535));
    wrapped = (i64)0;
    L948 :;
    while (1) {
        aa_lex$lxsymptr = (struct aa_decls$strec *)aa_decls$lexhashtable[(j)];
        if ((aa_lex$lxsymptr == 0)) {
            goto L949 ;
        }
;
        if ((((i64)(*aa_lex$lxsymptr).namelen == length) && (memcmp((void *)(*aa_lex$lxsymptr).name,(void *)name,(u64)length) == (i64)0))) {
            return (i64)1;
        }
;
        if ((++(j) > (i64)65536)) {
            if (!!(wrapped)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"???????HASHTABLE FULL",NULL);
                msysc$m_print_i64((i64)65536,NULL);
                msysc$m_print_i64(aa_decls$lxlineno,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)1);
            }
;
            wrapped = (i64)1;
            j = (i64)1;
        }
;
    }
L949 :;
    ;
    if (!!(insource)) {
        name = aa_lex$makestring(name,length);
    }
;
    if ((aa_lex$lxsymptr == 0)) {
        aa_lex$lxsymptr = (struct aa_decls$strec *)mlib$pcm_allocz((i64)128);
        aa_decls$lexhashtable[(j)] = (struct aa_decls$strec *)aa_lex$lxsymptr;
    }
;
    (*aa_lex$lxsymptr).name = name;
    (*aa_lex$lxsymptr).namelen = length;
    (*aa_lex$lxsymptr).symbol = (i64)17;
    (*aa_lex$lxsymptr).ksymbol = (i64)0;
    (*aa_lex$lxsymptr).htindex = j;
    (*aa_lex$lxsymptr).htfirstindex = firstj;
    (*aa_lex$lxsymptr).moduleno = aa_decls$currmoduleno;
    return (i64)0;
}

void aa_lex$initsourcefile(u8 *source) {
    aa_lex$lxstart = (aa_lex$lxsptr = (byte *)source);
    aa_decls$lxlineno = (i64)1;
}

struct aa_decls$strec *aa_lex$addnamestr(u8 *name) {
    aa_lex$lxhashvalue = aa_lex$gethashvalue(name);
    aa_lex$lookuplex(mlib$pcm_copyheapstring(name),(i64)0);
    return (struct aa_decls$strec *)aa_lex$lxsymptr;
}

void aa_lex$lxerror(u8 *m) {
    msysc$m_print_startcon();
    msysc$m_print_setfmt((byte*)"\r\n\r\n Lexical Error\n*** # *** on line #");
    msysc$m_print_str(m,NULL);
    msysc$m_print_i64(aa_decls$lxlineno,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

i64 aa_lex$gethashvalue(u8 *s) {
        i64 c;
        i64 hsum;
    if (((i64)(u64)(*s) == (i64)0)) {
        return (i64)0;
    }
;
    hsum = (i64)(u64)(*(s)++);
    L950 :;
    while (1) {
        c = (i64)(u64)(*(s)++);
        if ((c == (i64)0)) {
            goto L951 ;
        }
;
        hsum = (((hsum << (i64)4) - hsum) + c);
    }
L951 :;
    ;
    return ((hsum << (i64)5) - hsum);
}

void aa_lex$skiptoeol(void) {
    L952 :;
    do {
        aa_lex$lex();
L953 :;
    }
    while (!((aa_lex$lxsymbol == (i64)11) || (aa_lex$lxsymbol == (i64)12)));
L954 :;
    ;
}

static u8 *aa_lex$makestring(u8 *p,i64 length) {
        u8 *  s;
    s = (u8 *)mlib$pcm_alloc((length + (i64)1));
    memcpy((void *)s,(void *)p,(u64)length);
    (*(s + length)) = (u64)0u;
    return s;
}

// START
void aa_lex$start(void) {

}

void aa_lib$initlib(void) {
        i64 reg;
        i64 size;
    aa_lib$zero_opnd = (struct aa_decls$opndrec *)aa_lib$genint((i64)0,(i64)4);
    for (reg=(i64)1;reg<=(i64)16;++reg) {
L955 :;
        for (size=(i64)1;size<=(i64)8;++size) {
L958 :;
            if ((size==(i64)1) || (size==(i64)2) || (size==(i64)4) || (size==(i64)8)) {
                aa_lib$regtable[(reg)-1][(size)-1] = (struct aa_decls$opndrec *)aa_lib$genreg0(reg,size);
            }
;
L959 :;
        }
L960 :;
        ;
L956 :;
    }
L957 :;
    ;
    for (reg=(i64)17;reg<=(i64)20;++reg) {
L961 :;
        aa_lib$regtable[(reg)-1][((i64)1)-1] = (struct aa_decls$opndrec *)aa_lib$genreg0(reg,(i64)1);
L962 :;
    }
L963 :;
    ;
    aa_decls$ss_symboltable = (struct aa_decls$strec *(*)[])mlib$pcm_alloc((i64)131072);
    aa_decls$ss_symboltablesize = (i64)16384;
    aa_decls$ss_nsymbols = (i64)0;
}

void aa_lib$genmc(i64 opcode,struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
        struct aa_lib$mclrec *  m;
        i64 nopnds;
    m = (struct aa_lib$mclrec *)mlib$pcm_alloc((i64)32);
    (*m).nextmcl = 0;
    if ((aa_lex$lxsymbol == (i64)11)) {
        (*m).lineno = (aa_decls$lxlineno - (i64)1);
    }
    else {
        (*m).lineno = aa_decls$lxlineno;
    }
;
    (*m).opcode = opcode;
    nopnds = ((a == 0) ? (i64)0 : ((b == 0) ? (i64)1 : (i64)2));
    if (((nopnds == (i64)2) && (opcode == (i64)90 || opcode == (i64)91))) {
        nopnds = (i64)3;
    }
;
    if ((nopnds < (i64)aa_tables$mclnopnds[(opcode)-1])) {
        aa_lib$serror((byte*)"Too few operands");
    }
    else if ((nopnds > (i64)aa_tables$mclnopnds[(opcode)-1])) {
        aa_lib$serror((byte*)"Too many operands");
    }
;
    (*m).a = (struct aa_decls$opndrec *)a;
    (*m).b = (struct aa_decls$opndrec *)b;
    if (!!(aa_lib$mccode)) {
        (*aa_lib$mccodex).nextmcl = (struct aa_lib$mclrec *)m;
        aa_lib$mccodex = (struct aa_lib$mclrec *)m;
    }
    else {
        aa_lib$mccode = (aa_lib$mccodex = (struct aa_lib$mclrec *)m);
    }
;
}

void aa_lib$genmcstr(i64 opcode,u8 *s) {
    aa_lib$genmc(opcode,(struct aa_decls$opndrec *)aa_lib$genstrimm(s),0);
}

static struct aa_decls$opndrec *aa_lib$newopnd(i64 mode) {
        struct aa_decls$opndrec *  a;
    a = (struct aa_decls$opndrec *)mlib$pcm_allocz((i64)24);
    (*a).mode = mode;
    return (struct aa_decls$opndrec *)a;
}

struct aa_decls$opndrec *aa_lib$genxreg(i64 xreg) {
        struct aa_decls$opndrec *  a;
    a = (struct aa_decls$opndrec *)aa_lib$newopnd((i64)5);
    (*a).reg = xreg;
    (*a).size = (i64)16;
    return (struct aa_decls$opndrec *)a;
}

struct aa_decls$opndrec *aa_lib$genindex(i64 areg,i64 ireg,i64 scale,struct aa_decls$opndrec *x,i64 size,i64 addrsize) {
        struct aa_decls$opndrec *  a;
    if (!!(x)) {
        a = (struct aa_decls$opndrec *)x;
        (*x).mode = (i64)3;
    }
    else {
        a = (struct aa_decls$opndrec *)aa_lib$newopnd((i64)3);
    }
;
    (*a).reg = areg;
    (*a).regix = ireg;
    (*a).scale = scale;
    (*a).size = size;
    (*a).addrsize = addrsize;
    return (struct aa_decls$opndrec *)a;
}

struct mlib$strbuffer *aa_lib$writemclblock(void) {
        i64 i;
        struct aa_lib$mclrec *  m;
    mlib$gs_init((struct mlib$strbuffer *)aa_lib$dest);
    mlib$gs_strln((struct mlib$strbuffer *)aa_lib$dest,(byte*)"MC CODE");
    m = (struct aa_lib$mclrec *)aa_lib$mccode;
    i = (i64)1;
    L964 :;
    while (!!(m)) {
        aa_lib$writemcl(i,(struct aa_lib$mclrec *)m);
        m = (struct aa_lib$mclrec *)(*m).nextmcl;
        ++(i);
L965 :;
    }
L966 :;
    ;
    return (struct mlib$strbuffer *)aa_lib$dest;
}

void aa_lib$gencomment(u8 *s) {
    if ((s == 0)) {
        aa_lib$genmc((i64)2,0,0);
    }
    else {
        aa_lib$genmcstr((i64)1,s);
    }
;
}

struct aa_decls$opndrec *aa_lib$genstrimm(u8 *s) {
        struct aa_decls$opndrec *  a;
    a = (struct aa_decls$opndrec *)aa_lib$newopnd((i64)6);
    (*a).svalue = s;
    return (struct aa_decls$opndrec *)a;
}

static u8 *aa_lib$getsizetag(i64 size) {
    if ((size==(i64)1)) {
        return (byte*)"b";
    }
    else if ((size==(i64)2)) {
        return (byte*)"h";
    }
    else if ((size==(i64)4)) {
        return (byte*)"w";
    }
    else if ((size==(i64)8)) {
        return (byte*)"d";
    }
;
    aa_lib$gerror((byte*)"GETSIZETAG?");
    return (u8 *)0;
}

static void aa_lib$writemcl(i64 index,struct aa_lib$mclrec *mcl) {
        u8 mclstr[512];
        u8 str[512];
        u8 *  semi;
    strcpy((u8 *)mclstr,aa_lib$strmcl((struct aa_lib$mclrec *)mcl));
    if (((i64)(u64)mclstr[((i64)1)-1] == (i64)0)) {
        return;
    }
;
        {i64 $temp = (i64)(*mcl).opcode;
if (($temp==(i64)1)) {
        semi = (byte*)";";
    }
    else {
        semi = (byte*)" ";
    }
    };
    msysc$m_print_startstr(str);
    msysc$m_print_str(semi,(byte*)"z3");
    msysc$m_print_i64(index,(byte*)"z4");
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)" ",NULL);
    msysc$m_print_end();
    ;
    mlib$gs_str((struct mlib$strbuffer *)aa_lib$dest,(u8 *)str);
    mlib$gs_strln((struct mlib$strbuffer *)aa_lib$dest,(u8 *)mclstr);
}

u8 *aa_lib$strmcl(struct aa_lib$mclrec *mcl) {
        static u8 str[512];
        u8 str2[128];
        i64 opcode;
        i64 sizepref;
    opcode = (i64)(*mcl).opcode;
    if ((opcode==(i64)7)) {
        return (*(*mcl).a).svalue;
    }
    else if ((opcode==(i64)2)) {
        return (byte*)"";
    }
    else if ((opcode==(i64)1)) {
        strcpy((u8 *)str,(byte*)";");
        strcat((u8 *)str,(*(*mcl).a).svalue);
        return (u8 *)str;
    }
    else if ((opcode==(i64)4)) {
        strcpy((u8 *)str,(*(*(*mcl).a).labeldef).name);
        strcat((u8 *)str,(byte*)":");
        return (u8 *)str;
    }
;
    strcpy((u8 *)str,(byte*)"\t\t");
    if ((opcode==(i64)25)) {
        strcat((u8 *)str,(byte*)"j");
        strcat((u8 *)str,aa_tables$condnames[((*(*mcl).a).value)]);
    }
    else if ((opcode==(i64)59)) {
        strcat((u8 *)str,(byte*)"set");
        strcat((u8 *)str,aa_tables$condnames[((*(*mcl).a).value)]);
    }
    else if ((opcode==(i64)14)) {
        strcat((u8 *)str,(byte*)"cmov");
        strcat((u8 *)str,aa_tables$condnames[((*(*mcl).a).value)]);
    }
    else {
        strcat((u8 *)str,(aa_tables$mclnames[(opcode)-1] + (i64)2));
    }
;
    mlib$ipadstr((u8 *)str,(i64)12,(byte*)" ");
    if ((!!((*mcl).a) && !!((*mcl).b))) {
        sizepref = aa_lib$needsizeprefix((i64)(*mcl).opcode,(struct aa_decls$opndrec *)(*mcl).a,(struct aa_decls$opndrec *)(*mcl).b);
        strcat((u8 *)str,aa_lib$stropnd((struct aa_decls$opndrec *)(*mcl).a,sizepref));
        strcat((u8 *)str,(byte*)",\t");
        strcat((u8 *)str,aa_lib$stropnd((struct aa_decls$opndrec *)(*mcl).b,sizepref));
    }
    else if (!!((*mcl).a)) {
        if (((i64)(*mcl).opcode == (i64)20)) {
            strcat((u8 *)str,aa_lib$stropnd((struct aa_decls$opndrec *)(*mcl).a,(i64)0));
        }
        else {
            strcat((u8 *)str,aa_lib$stropnd((struct aa_decls$opndrec *)(*mcl).a,(i64)1));
        }
;
    }
;
    if ((opcode==(i64)90) || (opcode==(i64)91)) {
        msysc$m_print_startstr(str2);
        msysc$m_print_setfmt((byte*)", #");
        msysc$m_print_i64((i64)(*mcl).c,NULL);
        msysc$m_print_end();
        ;
        strcat((u8 *)str,(u8 *)str2);
    }
;
    return (u8 *)str;
}

u8 *aa_lib$stropnd(struct aa_decls$opndrec *a,i64 sizeprefix) {
        static u8 str[256];
        u8 *  plus;
        u8 *  s;
        i64 value;
        struct aa_decls$strec *  d;
        {i64 $temp = (i64)(*a).mode;
if (($temp==(i64)1)) {
        return aa_lib$getregname((i64)(*a).reg,(i64)(*a).size);
    }
    else if (($temp==(i64)2)) {
        d = (struct aa_decls$strec *)(*a).labeldef;
        value = (*a).value;
        if (!!(d)) {
            if (((i64)(*d).symbol == (i64)18)) {
                return aa_lib$inttostr((*(*d).expr).value);
            }
;
            s = aa_lib$getfullname((struct aa_decls$strec *)d);
            if (!!(value)) {
                if ((value > (i64)0)) {
                    strcpy((u8 *)str,s);
                    strcat((u8 *)str,(byte*)"+");
                    strcat((u8 *)str,aa_lib$inttostr(value));
                }
                else {
                    strcpy((u8 *)str,s);
                    strcat((u8 *)str,aa_lib$inttostr(value));
                }
;
                return (u8 *)str;
            }
            else {
                strcpy((u8 *)str,s);
                return (u8 *)str;
            }
;
        }
;
        if (((i64)(*a).valtype == (i64)0)) {
            return aa_lib$inttostr(value);
        }
        else {
            return aa_lib$realtostr(*(r64*)&value);
        }
;
    }
    else if (($temp==(i64)3)) {
        str[((i64)1)-1] = (u64)0u;
        strcat((u8 *)str,aa_lib$getsizeprefix((i64)(*a).size,sizeprefix));
        strcat((u8 *)str,(byte*)"[");
        plus = (byte*)"";
        if (!!((i64)(*a).reg)) {
            strcat((u8 *)str,aa_lib$getregname((i64)(*a).reg,(i64)(*a).addrsize));
            plus = (byte*)"+";
        }
;
        if (!!((i64)(*a).regix)) {
            strcat((u8 *)str,plus);
            strcat((u8 *)str,aa_lib$getregname((i64)(*a).regix,(i64)(*a).addrsize));
            plus = (byte*)"+";
            if (((i64)(*a).scale > (i64)1)) {
                strcat((u8 *)str,(byte*)"*");
                strcat((u8 *)str,aa_lib$inttostr((i64)(*a).scale));
            }
;
        }
;
        if (!!((*a).labeldef)) {
            strcat((u8 *)str,plus);
            strcat((u8 *)str,aa_lib$strdef((struct aa_decls$strec *)(*a).labeldef));
            plus = (byte*)"+";
        }
;
        if (((*a).value > (i64)0)) {
            strcat((u8 *)str,plus);
            strcat((u8 *)str,aa_lib$inttostr((*a).value));
        }
        else if (((*a).value < (i64)0)) {
            strcat((u8 *)str,aa_lib$inttostr((*a).value));
        }
;
        strcat((u8 *)str,(byte*)"]");
    }
    else if (($temp==(i64)6)) {
        if ((strlen((*a).svalue) >= (i64)256)) {
            msysc$m_print_startstr(str);
            msysc$m_print_str((byte*)"\"<Long string>\"",NULL);
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startstr(str);
            msysc$m_print_str((byte*)"\"",NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((*a).svalue,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)"\"",NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if (($temp==(i64)4)) {
        return aa_lib$opndnames[((*a).value)];
    }
    else if (($temp==(i64)5)) {
        return aa_lib$xgetregname((i64)(*a).reg);
    }
    else {
        return (byte*)"<BAD OPND>";
    }
    };
    return (u8 *)str;
}

static u8 *aa_lib$strdef(struct aa_decls$strec *def) {
    if (((i64)(*def).symbol == (i64)18)) {
        return aa_lib$inttostr((*(*def).expr).value);
    }
;
    return aa_lib$getfullname((struct aa_decls$strec *)def);
}

void aa_lib$setsegment(i64 seg) {
    if ((seg == aa_lib$currsegment)) {
        return;
    }
;
    if ((seg==(i64)68)) {
        aa_lib$genmcstr((i64)118,(byte*)".data");
    }
    else if ((seg==(i64)90)) {
        aa_lib$genmcstr((i64)118,(byte*)".bss");
    }
    else if ((seg==(i64)67)) {
        aa_lib$genmcstr((i64)118,(byte*)".text");
    }
    else if ((seg==(i64)82)) {
        aa_lib$genmcstr((i64)118,(byte*)".rodata");
    }
;
    aa_lib$currsegment = seg;
}

static u8 *aa_lib$getsizeprefix(i64 size,i64 enable) {
    if (!(!!(enable))) {
        return (byte*)"";
    }
;
    if ((size==(i64)1)) {
        return (byte*)"byte ";
    }
    else if ((size==(i64)2)) {
        return (byte*)"word ";
    }
    else if ((size==(i64)4)) {
        return (byte*)"dword ";
    }
    else if ((size==(i64)8)) {
        return (byte*)"qword ";
    }
    else if ((size==(i64)0)) {
        return (byte*)"";
    }
;
    return (byte*)"N:";
}

static i64 aa_lib$needsizeprefix(i64 opcode,struct aa_decls$opndrec *a,struct aa_decls$opndrec *b) {
    if ((opcode==(i64)17) || (opcode==(i64)18)) {
        return (i64)1;
    }
    else if ((opcode==(i64)84) || (opcode==(i64)85)) {
        return (i64)1;
    }
;
    if ((((((i64)(*a).mode == (i64)1) || ((i64)(*a).mode == (i64)5)) || ((i64)(*b).mode == (i64)1)) || ((i64)(*b).mode == (i64)5))) {
        return (i64)0;
    }
;
    return (i64)1;
}

struct aa_decls$opndrec *aa_lib$genimm_expr(struct aa_decls$strec *d,i64 value,i64 t,i64 size) {
        struct aa_decls$opndrec *  a;
    a = (struct aa_decls$opndrec *)aa_lib$newopnd((i64)2);
    (*a).size = size;
    (*a).labeldef = (struct aa_decls$strec *)d;
    (*a).value = value;
    (*a).valtype = t;
    return (struct aa_decls$opndrec *)a;
}

struct aa_decls$opndrec *aa_lib$genint(i64 x,i64 size) {
        struct aa_decls$opndrec *  a;
    a = (struct aa_decls$opndrec *)aa_lib$newopnd((i64)2);
    (*a).size = size;
    (*a).value = x;
    return (struct aa_decls$opndrec *)a;
}

struct aa_decls$opndrec *aa_lib$genlab(struct aa_decls$strec *d,i64 size) {
        struct aa_decls$opndrec *  a;
    a = (struct aa_decls$opndrec *)aa_lib$newopnd((i64)2);
    (*a).size = size;
    (*a).labeldef = (struct aa_decls$strec *)d;
    return (struct aa_decls$opndrec *)a;
}

struct aa_decls$opndrec *aa_lib$genmem(struct aa_decls$strec *d,i64 size) {
        struct aa_decls$opndrec *  a;
    a = (struct aa_decls$opndrec *)aa_lib$genlab((struct aa_decls$strec *)d,size);
    (*a).mode = (i64)3;
    return (struct aa_decls$opndrec *)a;
}

struct aa_decls$opndrec *aa_lib$genreg0(i64 reg,i64 size) {
        struct aa_decls$opndrec *  a;
    a = (struct aa_decls$opndrec *)aa_lib$newopnd((i64)1);
    (*a).reg = reg;
    (*a).size = size;
    return (struct aa_decls$opndrec *)a;
}

u8 *aa_lib$getfullname(struct aa_decls$strec *d) {
        static u8 str[256];
        u8 *  ms;
    ms = (byte*)"";
    if (!!((*d).basedef)) {
        ms = (*(*d).basedef).name;
    }
;
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"<# : ## &:# SYM:## M:#>");
    msysc$m_print_str((*d).name,NULL);
    msysc$m_print_str((byte*)"#",NULL);
    msysc$m_print_i64((i64)(*d).moduleno,NULL);
    msysc$m_print_ptr(d,(byte*)"8");
    msysc$m_print_i64((strlen(aa_tables$symbolnames[((i64)(*d).symbol)-1]) - (i64)3),(byte*)"v");
    msysc$m_print_str(aa_tables$symbolnames[((i64)(*d).symbol)-1],(byte*)".*");
    msysc$m_print_str(ms,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
    return (*d).name;
}

u8 *aa_lib$getregname(i64 reg,i64 size) {
        u8 *  prefix;
        u8 *  rs;
        static u8 str[32];
    if ((reg==(i64)0)) {
        return (byte*)"-";
    }
    else if ((reg==(i64)15)) {
        rs = (byte*)"frame";
    }
    else if ((reg==(i64)16)) {
        rs = (byte*)"stack";
    }
    else {
        rs = aa_lib$inttostr((reg - (i64)1));
    }
;
    if ((size==(i64)1)) {
        prefix = (byte*)"B";
    }
    else if ((size==(i64)2)) {
        prefix = (byte*)"W";
    }
    else if ((size==(i64)4)) {
        prefix = (byte*)"A";
    }
    else {
        prefix = (byte*)"D";
    }
;
    strcpy((u8 *)str,prefix);
    strcat((u8 *)str,rs);
    return (u8 *)str;
}

u8 *aa_lib$xgetregname(i64 reg) {
        static u8 str[16];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"xmm",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64((reg - (i64)1),NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

void aa_lib$printst(void *f) {
        struct aa_decls$strec *  r;
    r = (struct aa_decls$strec *)aa_decls$modulenamelist;
    L967 :;
    while (!!(r)) {
        aa_lib$printstrec(f,(struct aa_decls$strec *)r);
        r = (struct aa_decls$strec *)(*r).nextdef;
L968 :;
    }
L969 :;
    ;
}

void aa_lib$printstrec(void *f,struct aa_decls$strec *d) {
        {i64 $temp = (i64)(*d).symbol;
if (($temp==(i64)19) || ($temp==(i64)20) || ($temp==(i64)22)) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"Label:       ",NULL);
        msysc$m_print_str(mlib$padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysc$m_print_str((((i64)(*d).scope == (i64)1) ? (byte*)"U" : (byte*)"-"),NULL);
        msysc$m_print_str(aa_tables$symbolnames[((i64)(*d).symbol)-1],NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(mlib$padstr((!!((i64)(*d).segment) ? aa_mcxdecls$segmentnames[((i64)(*d).segment)-1] : (byte*)"no seg"),(i64)12,(byte*)" "),NULL);
        msysc$m_print_i64((i64)(*d).offset,NULL);
        msysc$m_print_ptr((*d).fwdrefs,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)21)) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"Label:       ",NULL);
        msysc$m_print_str(mlib$padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysc$m_print_str((byte*)"EXTERN",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)18)) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"Named const: ",NULL);
        msysc$m_print_str(mlib$padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysc$m_print_str((byte*)"=",NULL);
        msysc$m_print_str(aa_lib$stropnd((struct aa_decls$opndrec *)(*d).expr,(i64)0),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"??",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    };
}

void aa_lib$adddef(struct aa_decls$strec *d) {
    (*d).nextdef = (struct aa_decls$strec *)aa_decls$modulenamelist;
    aa_decls$modulenamelist = (struct aa_decls$strec *)d;
}

void aa_lib$addimport(struct aa_decls$strec *d) {
        struct aa_decls$stlistrec *  p;
    p = (struct aa_decls$stlistrec *)mlib$pcm_alloc((i64)16);
    (*p).def = (struct aa_decls$strec *)d;
    (*p).nextitem = (struct aa_decls$stlistrec *)aa_decls$globalimportlist;
    aa_decls$globalimportlist = (struct aa_decls$stlistrec *)p;
}

void aa_lib$createlabel(struct aa_decls$strec *symptr,i64 symbol) {
    (*symptr).symbol = symbol;
    (*symptr).stindex = (i64)0;
    (*symptr).moduleno = aa_decls$currmoduleno;
    aa_lib$adddef((struct aa_decls$strec *)symptr);
}

void aa_lib$createnamedconst(struct aa_decls$strec *symptr,struct aa_decls$opndrec *expr) {
    (*symptr).symbol = (i64)18;
    (*symptr).expr = (struct aa_decls$opndrec *)expr;
    aa_lib$adddef((struct aa_decls$strec *)symptr);
}

void aa_lib$createregalias(struct aa_decls$strec *symptr,i64 regindex,i64 regsize) {
    (*symptr).symbol = (i64)24;
    (*symptr).ksymbol = (i64)24;
    (*symptr).subcode = regindex;
    (*symptr).regsize = regsize;
    aa_lib$adddef((struct aa_decls$strec *)symptr);
}

void aa_lib$createxregalias(struct aa_decls$strec *symptr,i64 regindex) {
    (*symptr).symbol = (i64)25;
    (*symptr).ksymbol = (i64)25;
    (*symptr).subcode = regindex;
    aa_lib$adddef((struct aa_decls$strec *)symptr);
}

void aa_lib$gerror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"\nSS code gen error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"On line:",NULL);
    msysc$m_print_i64(aa_decls$alineno,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

void aa_lib$serror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"\nSyntax error: '",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(mess,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)"' on line",NULL);
    msysc$m_print_i64(aa_decls$lxlineno,NULL);
    msysc$m_print_str(aa_decls$moduletable[(aa_decls$currmoduleno)-1].name,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

void aa_lib$serror_s(u8 *mess,u8 *param) {
        u8 str[256];
    sprintf((u8 *)str,mess,param);
    aa_lib$serror((u8 *)str);
}

static u8 *aa_lib$inttostr(i64 a) {
        static u8 str[64];
    msysc$getstrint(a,(u8 *)str);
    return (u8 *)str;
}

static u8 *aa_lib$realtostr(r64 a) {
        static u8 str[64];
    strcpy((u8 *)str,msysc$strreal(a,0));
    return (u8 *)str;
}

struct aa_decls$dbuffer *aa_lib$buffercreate(i64 size) {
        struct aa_decls$dbuffer *  a;
    a = (struct aa_decls$dbuffer *)mlib$pcm_alloc((i64)32);
    (*a).alloc = size;
    (*a).pstart = ((*a).pcurr = (byte *)mlib$pcm_alloc((*a).alloc));
    (*a).pend = ((*a).pstart + (*a).alloc);
    return (struct aa_decls$dbuffer *)a;
}

static void aa_lib$bufferexpand(struct aa_decls$dbuffer *a) {
        i64 newalloc;
        i64 usedbytes;
        byte *  p;
    newalloc = ((*a).alloc * (i64)2);
    usedbytes = ((*a).pcurr - (*a).pstart);
    if ((usedbytes > (*a).alloc)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"dbuffer error",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit(0);
    }
;
    p = (byte *)mlib$pcm_alloc(newalloc);
    memcpy(p,(*a).pstart,(u64)usedbytes);
    (*a).pstart = p;
    (*a).pcurr = (p + usedbytes);
    (*a).alloc = newalloc;
    (*a).pend = (p + newalloc);
}

void aa_lib$buffercheck(struct aa_decls$dbuffer *a,i64 n) {
    L970 :;
    while ((((*a).pend - (*a).pcurr) < n)) {
        aa_lib$bufferexpand((struct aa_decls$dbuffer *)a);
L971 :;
    }
L972 :;
    ;
}

i64 aa_lib$bufferlength(struct aa_decls$dbuffer *a) {
    return ((*a).pcurr - (*a).pstart);
}

void *aa_lib$bufferelemptr(struct aa_decls$dbuffer *a,i64 offset) {
    return ((*a).pstart + offset);
}

void aa_lib$addbyte(struct aa_decls$dbuffer *a,i64 x) {
    (*(*a).pcurr) = x;
    ++((*a).pcurr);
}

void aa_lib$addword(struct aa_decls$dbuffer *a,i64 x) {
    (*(*a).pcurr16) = x;
    ++((*a).pcurr16);
}

void aa_lib$adddword(struct aa_decls$dbuffer *a,i64 x) {
    (*(*a).pcurr32) = x;
    ++((*a).pcurr32);
}

void aa_lib$addqword(struct aa_decls$dbuffer *a,i64 x) {
    (*(*a).pcurr64) = (u64)x;
    ++((*a).pcurr64);
}

void aa_lib$printmodulesymbols(void *f) {
        struct aa_decls$strec *  d;
        struct aa_decls$strec *  e;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"MODULE SYMBOLS IN",NULL);
    msysc$m_print_str(aa_decls$moduletable[(aa_decls$currmoduleno)-1].name,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    d = (struct aa_decls$strec *)aa_decls$modulenamelist;
    L973 :;
    while (!!(d)) {
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"   ",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(mlib$padstr((*d).name,(i64)14,(byte*)" "),NULL);
        msysc$m_print_str(mlib$padstr(aa_tables$symbolnames[((i64)(*d).symbol)-1],(i64)12,(byte*)" "),NULL);
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"|| # # #");
        msysc$m_print_i64((i64)(*d).htfirstindex,(byte*)"6");
        msysc$m_print_i64((i64)(*d).htindex,(byte*)"6");
        msysc$m_print_ptr(d,(byte*)"8H");
        msysc$m_print_end();
        ;
        e = (struct aa_decls$strec *)aa_decls$dupltable[((i64)(*d).htfirstindex)];
        if (!!(e)) {
            msysc$m_print_startfile(f);
            msysc$m_print_str((byte*)"||",NULL);
            msysc$m_print_end();
            ;
            L976 :;
            while (!!(e)) {
                msysc$m_print_startfile(f);
                msysc$m_print_str((byte*)"(",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)")",NULL);
                msysc$m_print_end();
                ;
                e = (struct aa_decls$strec *)(*e).nextdupl;
L977 :;
            }
L978 :;
            ;
        }
;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)" BASE:",NULL);
        msysc$m_print_str((!!((*d).basedef) ? (*(*d).basedef).name : (byte*)""),NULL);
        msysc$m_print_ptr((*d).basedef,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        d = (struct aa_decls$strec *)(*d).nextdef;
L974 :;
    }
L975 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void aa_lib$printimportsymbols(void *f) {
        struct aa_decls$strec *  d;
        struct aa_decls$stlistrec *  p;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"GLOBAL IMPORT TABLE",NULL);
    msysc$m_print_ptr(aa_decls$globalimportlist,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    p = (struct aa_decls$stlistrec *)aa_decls$globalimportlist;
    L979 :;
    while (!!(p)) {
        d = (struct aa_decls$strec *)(*p).def;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"   ",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(mlib$padstr((*d).name,(i64)14,(byte*)" "),NULL);
        msysc$m_print_str(mlib$padstr(aa_tables$symbolnames[((i64)(*d).symbol)-1],(i64)12,(byte*)" "),NULL);
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str((byte*)"D.OFFSET=",NULL);
        msysc$m_print_i64((i64)(*d).offset,NULL);
        msysc$m_print_str(aa_tables$reftypenames[((i64)(*d).reftype)],NULL);
        msysc$m_print_ptr(d,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        p = (struct aa_decls$stlistrec *)(*p).nextitem;
L980 :;
    }
L981 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void aa_lib$printdupltable(void *f) {
        u8 str[256];
        struct aa_decls$strec *  d;
        i64 i;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"DUPL TABLE",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)0;i<=(i64)65535;++i) {
L982 :;
        if (!!(aa_decls$dupltable[(i)])) {
            d = (struct aa_decls$strec *)aa_decls$dupltable[(i)];
            msysc$m_print_startfile(f);
            msysc$m_print_str((byte*)"\t",NULL);
            msysc$m_print_i64((i64)(*d).htfirstindex,NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_end();
            ;
            L985 :;
            while (!!(d)) {
                msysc$m_print_startstr(str);
                msysc$m_print_setfmt((byte*)"(# # (#) #) ");
                msysc$m_print_i64((i64)(*d).htindex,(byte*)"6");
                msysc$m_print_str((*d).name,NULL);
                msysc$m_print_str(aa_decls$moduletable[((i64)(*d).moduleno)-1].name,NULL);
                msysc$m_print_ptr(d,(byte*)"8H");
                msysc$m_print_end();
                ;
                d = (struct aa_decls$strec *)(*d).nextdupl;
L986 :;
            }
L987 :;
            ;
            msysc$m_print_startfile(f);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
L983 :;
    }
L984 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

// START
void aa_lib$start(void) {

}

// START
void aa_mcxdecls$start(void) {

}

// START
void aa_objdecls$start(void) {

}

void aa_parse$readmodule(i64 moduleno) {
        struct aa_decls$strec *  symptr;
        i64 sym;
        i64 i;
    aa_lex$initsourcefile(aa_decls$moduletable[(moduleno)-1].source);
    aa_lex$lxsymbol = (i64)11;
    aa_lib$genmc((i64)118,(struct aa_decls$opndrec *)aa_lib$genint((i64)1,(i64)4),0);
    L988 :;
    while ((aa_lex$lxsymbol == (i64)11)) {
        aa_lex$lex();
        switch (aa_lex$lxsymbol) {
        case 23:;
            {
                aa_parse$readinstr();
            }
            break;
        case 17:;
            {
                symptr = (struct aa_decls$strec *)aa_lex$lxsymptr;
                aa_lex$lex();
                sym = aa_lex$lxsymbol;
                if ((sym==(i64)10)) {
                    aa_lex$lex();
                    if ((aa_lex$lxsymbol==(i64)24)) {
                        aa_lib$createregalias((struct aa_decls$strec *)symptr,(i64)(*aa_lex$lxsymptr).subcode,(i64)(*aa_lex$lxsymptr).regsize);
                        aa_lex$lex();
                    }
                    else if ((aa_lex$lxsymbol==(i64)25)) {
                        aa_lib$createxregalias((struct aa_decls$strec *)symptr,(i64)(*aa_lex$lxsymptr).subcode);
                        aa_lex$lex();
                    }
                    else {
                        aa_lib$createnamedconst((struct aa_decls$strec *)symptr,(struct aa_decls$opndrec *)aa_parse$readexpression());
                    }
;
                }
                else if ((sym==(i64)3) || (sym==(i64)4)) {
                    aa_lib$createlabel((struct aa_decls$strec *)symptr,((sym == (i64)3) ? (i64)20 : (i64)22));
                    aa_lib$genmc((i64)4,(struct aa_decls$opndrec *)aa_lib$genlab((struct aa_decls$strec *)symptr,(i64)4),0);
                    (*symptr).reftype = (i64)1;
                    aa_lex$lxsymbol = (i64)11;
                    goto L988 ;
                }
                else {
                    msysc$m_print_startcon();
                    msysc$m_print_str((*symptr).name,NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    aa_lib$serror((byte*)"colon expected after label");
                }
;
            }
            break;
        case 19:;
            {
                symptr = (struct aa_decls$strec *)aa_lex$lxsymptr;
                aa_lex$lex();
                if ((aa_lex$lxsymbol==(i64)10)) {
                    aa_lib$serror_s((byte*)"Redefining label as const: %s",(*symptr).name);
                }
                else if ((aa_lex$lxsymbol==(i64)3) || (aa_lex$lxsymbol==(i64)4)) {
                    (*symptr).fwdrefs = 0;
                    aa_lib$genmc((i64)4,(struct aa_decls$opndrec *)aa_lib$genlab((struct aa_decls$strec *)symptr,(i64)4),0);
                    (*symptr).symbol = ((aa_lex$lxsymbol == (i64)3) ? (i64)20 : (i64)22);
                    (*symptr).reftype = (i64)1;
                    aa_lex$lxsymbol = (i64)11;
                    goto L988 ;
                }
                else {
                    aa_lib$serror((byte*)"Instruction expected");
                }
;
            }
            break;
        case 21:;
            {
                aa_lib$serror_s((byte*)"Defining imported name: %s",(*symptr).name);
            }
            break;
        case 20:;
        case 22:;
            {
                aa_lib$serror((byte*)"Redefining symbol");
            }
            break;
        case 18:;
            {
                aa_lib$serror_s((byte*)"2:Const redefined: %s",(*symptr).name);
            }
            break;
        case 28:;
            {
                aa_parse$readcondinstr((i64)25);
            }
            break;
        case 29:;
            {
                aa_parse$readcondinstr((i64)59);
            }
            break;
        case 30:;
            {
                aa_parse$readcondinstr((i64)14);
            }
            break;
        case 11:;
            {
            }
            break;
        case 12:;
            {
                return;
            }
            break;
        case 33:;
            {
                aa_lex$lex();
                aa_parse$checksymbol((i64)17);
                if ((aa_decls$nimportlibs >= (i64)30)) {
                    aa_lib$serror((byte*)"Too many import libs");
                }
;
                for (i=(i64)1;i<=aa_decls$nimportlibs;++i) {
L991 :;
                    if (!!(mlib$eqstring(aa_decls$importlibs[(i)-1],(*aa_lex$lxsymptr).name))) {
                        goto L993 ;
                    }
;
L992 :;
                }
                {
                    aa_decls$importlibs[(++(aa_decls$nimportlibs))-1] = (*aa_lex$lxsymptr).name;
                }
L993 :;
                ;
                aa_lex$lex();
            }
            break;
        case 34:;
            {
                aa_lex$lex();
                aa_parse$checksymbol((i64)17);
                if ((aa_decls$nsearchlibs >= (i64)30)) {
                    aa_lib$serror((byte*)"Too many DLLs");
                }
;
                for (i=(i64)1;i<=aa_decls$nsearchlibs;++i) {
L994 :;
                    if (!!(mlib$eqstring(aa_decls$searchlibs[(i)-1],(*aa_lex$lxsymptr).name))) {
                        goto L996 ;
                    }
;
L995 :;
                }
                {
                    aa_decls$searchlibs[(++(aa_decls$nsearchlibs))-1] = (*aa_lex$lxsymptr).name;
                }
L996 :;
                ;
                aa_lex$lex();
            }
            break;
        default: {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Unknown symbol (possibly redefining regvar):",NULL);
            msysc$m_print_str(aa_tables$symbolnames[(aa_lex$lxsymbol)-1],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        } //SW
;
L989 :;
    }
L990 :;
    ;
    aa_lib$serror((byte*)"EOL expected");
}

void aa_parse$checkundefined(void) {
        struct aa_decls$strec *  d;
    d = (struct aa_decls$strec *)aa_decls$modulenamelist;
    L997 :;
    while (!!(d)) {
        if (((i64)(*d).symbol == (i64)19)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Undefined:",NULL);
            msysc$m_print_str(mlib$padstr((*d).name,(i64)20,(byte*)" "),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            ++(aa_decls$nundefined);
        }
;
        d = (struct aa_decls$strec *)(*d).nextdef;
L998 :;
    }
L999 :;
    ;
}

static void aa_parse$checksymbol(i64 symbol) {
        u8 str[265];
    if ((aa_lex$lxsymbol != symbol)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"# expected not #");
        msysc$m_print_str(aa_tables$symbolnames[(symbol)-1],NULL);
        msysc$m_print_str(aa_tables$symbolnames[(aa_lex$lxsymbol)-1],NULL);
        msysc$m_print_end();
        ;
        aa_lib$serror((u8 *)str);
    }
;
}

static void aa_parse$readinstr(void) {
        i64 opcode;
        struct aa_decls$opndrec *  a;
        struct aa_decls$opndrec *  b;
        struct aa_decls$opndrec *  c;
    opcode = aa_lex$lxsubcode;
    aa_lex$lex();
    switch (opcode) {
    case 114:;
    case 115:;
    case 116:;
    case 117:;
        {
            L1000 :;
            while (1) {
                if ((aa_lex$lxsymbol == (i64)16)) {
                    a = (struct aa_decls$opndrec *)aa_lib$genstrimm(aa_lex$lxsvalue);
                    aa_lex$lex();
                    aa_lib$genmc(opcode,(struct aa_decls$opndrec *)a,0);
                }
                else {
                    a = (struct aa_decls$opndrec *)aa_parse$readoperand();
                    aa_lib$genmc(opcode,(struct aa_decls$opndrec *)a,0);
                }
;
                if ((aa_lex$lxsymbol == (i64)2)) {
                    aa_lex$lex();
                }
                else {
                    goto L1001 ;
                }
;
            }
L1001 :;
            ;
        }
        break;
    case 118:;
        {
            aa_parse$checksymbol((i64)32);
            aa_lib$genmc((i64)118,(struct aa_decls$opndrec *)aa_lib$genint(aa_lex$lxsubcode,(i64)4),0);
            aa_lex$lex();
        }
        break;
    case 119:;
        {
            aa_lib$genmc((i64)118,(struct aa_decls$opndrec *)aa_lib$genint((i64)2,(i64)4),0);
        }
        break;
    case 120:;
        {
            aa_lib$genmc((i64)118,(struct aa_decls$opndrec *)aa_lib$genint((i64)3,(i64)4),0);
        }
        break;
    case 121:;
        {
            aa_lib$genmc((i64)118,(struct aa_decls$opndrec *)aa_lib$genint((i64)1,(i64)4),0);
        }
        break;
    case 40:;
        {
            a = (struct aa_decls$opndrec *)aa_parse$readoperand();
            aa_parse$checksymbol((i64)2);
            aa_lex$lex();
            b = (struct aa_decls$opndrec *)aa_parse$readoperand();
            aa_parse$checksymbol((i64)2);
            aa_lex$lex();
            c = (struct aa_decls$opndrec *)aa_parse$readoperand();
            aa_lib$serror((byte*)"IMUL3 CAN'T DO 3 OPNDS");
        }
        break;
    case 90:;
    case 91:;
        {
            a = (struct aa_decls$opndrec *)aa_parse$readoperand();
            aa_parse$checksymbol((i64)2);
            aa_lex$lex();
            b = (struct aa_decls$opndrec *)aa_parse$readoperand();
            aa_parse$checksymbol((i64)2);
            aa_lex$lex();
            c = (struct aa_decls$opndrec *)aa_parse$readoperand();
            if (((i64)(*c).mode != (i64)2)) {
                aa_lib$serror((byte*)"pcmpistr/not int");
            }
;
            aa_lib$genmc(opcode,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
            (*aa_lib$mccodex).c = (*c).value;
        }
        break;
    case 8:;
        {
            L1002 :;
            while ((aa_lex$lxsymbol != (i64)11)) {
                aa_lex$lex();
L1003 :;
            }
L1004 :;
            ;
        }
        break;
    default: {
        a = (b = 0);
        if ((aa_lex$lxsymbol != (i64)11)) {
            a = (struct aa_decls$opndrec *)aa_parse$readoperand();
            if ((aa_lex$lxsymbol == (i64)2)) {
                aa_lex$lex();
                b = (struct aa_decls$opndrec *)aa_parse$readoperand();
            }
;
        }
;
        aa_lib$genmc(opcode,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
    }
    } //SW
;
}

static void aa_parse$readcondinstr(i64 opc) {
        struct aa_decls$opndrec *  a;
        struct aa_decls$opndrec *  b;
    a = (struct aa_decls$opndrec *)aa_lib$genint(aa_lex$lxsubcode,(i64)4);
    aa_lex$lex();
    b = (struct aa_decls$opndrec *)aa_parse$readoperand();
    if (((aa_lex$lxsymbol == (i64)2) && (opc == (i64)14))) {
        aa_lib$genmc((i64)6,(struct aa_decls$opndrec *)b,0);
        aa_lex$lex();
        b = (struct aa_decls$opndrec *)aa_parse$readoperand();
    }
;
    aa_lib$genmc(opc,(struct aa_decls$opndrec *)a,(struct aa_decls$opndrec *)b);
}

static struct aa_decls$opndrec *aa_parse$readoperand(void) {
        struct aa_decls$opndrec *  p;
        i64 size;
    switch (aa_lex$lxsymbol) {
    case 24:;
        {
            p = (struct aa_decls$opndrec *)aa_lib$regtable[(aa_lex$lxsubcode)-1][((i64)(*aa_lex$lxsymptr).regsize)-1];
            aa_lex$lex();
            return (struct aa_decls$opndrec *)p;
        }
        break;
    case 5:;
        {
            aa_lex$lex();
            return (struct aa_decls$opndrec *)aa_parse$readaddrmode((i64)0);
        }
        break;
    case 25:;
        {
            p = (struct aa_decls$opndrec *)aa_lib$genxreg(aa_lex$lxsubcode);
            aa_lex$lex();
            return (struct aa_decls$opndrec *)p;
        }
        break;
    case 31:;
        {
            size = aa_lex$lxsubcode;
            aa_lex$lex();
            aa_parse$checksymbol((i64)5);
            aa_lex$lex();
            return (struct aa_decls$opndrec *)aa_parse$readaddrmode(size);
        }
        break;
    default: {
        return (struct aa_decls$opndrec *)aa_parse$readexpression();
    }
    } //SW
;
    return (struct aa_decls$opndrec *)0;
}

static struct aa_decls$opndrec *aa_parse$readexpression(void) {
        struct aa_decls$strec *  labelx;
        i64 valuex;
        i64 typex;
    aa_parse$readterm();
    L1005 :;
    if ((aa_lex$lxsymbol==(i64)7)) {
        labelx = (struct aa_decls$strec *)aa_parse$exprlabeldef;
        valuex = aa_parse$exprvalue;
        typex = aa_parse$exprtype;
        aa_lex$lex();
        aa_parse$readterm();
        if (!!(aa_parse$exprlabeldef)) {
            aa_lib$serror((byte*)"+label?");
        }
;
        aa_parse$exprlabeldef = (struct aa_decls$strec *)labelx;
        if ((!!(typex) || !!(aa_parse$exprtype))) {
            aa_lib$serror((byte*)"add real");
        }
;
        aa_parse$exprvalue += valuex;
    }
    else if ((aa_lex$lxsymbol==(i64)8)) {
        labelx = (struct aa_decls$strec *)aa_parse$exprlabeldef;
        valuex = aa_parse$exprvalue;
        typex = aa_parse$exprtype;
        aa_lex$lex();
        aa_parse$readterm();
        if (!!(aa_parse$exprlabeldef)) {
            aa_lib$serror((byte*)"+label?");
        }
;
        aa_parse$exprlabeldef = (struct aa_decls$strec *)labelx;
        if ((!!(typex) || !!(aa_parse$exprtype))) {
            aa_lib$serror((byte*)"sub real");
        }
;
        aa_parse$exprvalue = (valuex - aa_parse$exprvalue);
    }
    else if ((aa_lex$lxsymbol==(i64)9)) {
        labelx = (struct aa_decls$strec *)aa_parse$exprlabeldef;
        valuex = aa_parse$exprvalue;
        typex = aa_parse$exprtype;
        aa_lex$lex();
        aa_parse$readterm();
        if (!!(aa_parse$exprlabeldef)) {
            aa_lib$serror((byte*)"+label?");
        }
;
        aa_parse$exprlabeldef = (struct aa_decls$strec *)labelx;
        if ((!!(typex) || !!(aa_parse$exprtype))) {
            aa_lib$serror((byte*)"add real");
        }
;
        aa_parse$exprvalue *= valuex;
    }
    else {
        goto L1006 ;
    }
goto L1005 ;
L1006 :;
    ;
    return (struct aa_decls$opndrec *)aa_lib$genimm_expr((struct aa_decls$strec *)aa_parse$exprlabeldef,aa_parse$exprvalue,aa_parse$exprtype,(i64)4);
}

static void aa_parse$readterm(void) {
        struct aa_decls$strec *  symptr;
        r64 x;
    aa_parse$exprlabeldef = 0;
    aa_parse$exprvalue = (i64)0;
    aa_parse$exprtype = (i64)0;
    switch (aa_lex$lxsymbol) {
    case 19:;
    case 20:;
    case 22:;
        {
            aa_parse$exprlabeldef = (struct aa_decls$strec *)aa_lex$lxsymptr;
            aa_lex$lex();
            if ((aa_lex$lxsymbol == (i64)9)) {
                aa_lib$serror((byte*)"* applied to non-extern label or applied inconsistently");
            }
;
        }
        break;
    case 21:;
        {
            aa_parse$exprlabeldef = (struct aa_decls$strec *)aa_lex$lxsymptr;
            aa_lex$lex();
            if ((aa_lex$lxsymbol != (i64)9)) {
                msysc$m_print_startcon();
                msysc$m_print_str((*aa_lex$lxsymptr).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                aa_lib$serror((byte*)"* missing or applied inconsistently");
            }
;
            aa_lex$lex();
        }
        break;
    case 18:;
        {
            aa_parse$exprlabeldef = (struct aa_decls$strec *)(*(*aa_lex$lxsymptr).expr).labeldef;
            aa_parse$exprvalue = (*(*aa_lex$lxsymptr).expr).value;
            aa_parse$exprtype = (i64)(*(*aa_lex$lxsymptr).expr).valtype;
            aa_lex$lex();
        }
        break;
    case 17:;
        {
            symptr = (struct aa_decls$strec *)aa_lex$lxsymptr;
            aa_parse$exprlabeldef = (struct aa_decls$strec *)symptr;
            aa_lex$lex();
            if ((aa_lex$lxsymbol == (i64)9)) {
                aa_lib$createlabel((struct aa_decls$strec *)symptr,(i64)21);
                aa_lex$lex();
            }
            else {
                aa_lib$createlabel((struct aa_decls$strec *)symptr,(i64)19);
            }
;
        }
        break;
    case 14:;
        {
            aa_parse$exprvalue = aa_lex$lxvalue;
            aa_lex$lex();
        }
        break;
    case 15:;
        {
            aa_parse$exprvalue = *(i64*)&aa_lex$lxxvalue;
            aa_parse$exprtype = (i64)82;
            aa_lex$lex();
        }
        break;
    case 8:;
        {
            aa_lex$lex();
            aa_parse$readterm();
            if (!(!!(aa_parse$exprlabeldef))) {
                if (!(!!(aa_parse$exprtype))) {
                    aa_parse$exprvalue = -(aa_parse$exprvalue);
                }
                else {
                    x = -(*(r64*)&aa_parse$exprvalue);
                    aa_parse$exprvalue = *(i64*)&x;
                }
;
            }
            else {
                aa_lib$serror((byte*)"neg/label");
            }
;
        }
        break;
    case 7:;
        {
            aa_lex$lex();
            aa_parse$readterm();
        }
        break;
    default: {
        aa_lib$serror((byte*)"READTERM");
    }
    } //SW
;
}

static void aa_parse$readreg(i64 *reg,i64 *regsize,i64 *scale) {
    (*reg) = aa_lex$lxsubcode;
    (*regsize) = (i64)(*aa_lex$lxsymptr).regsize;
    aa_lex$lex();
    if ((aa_lex$lxsymbol == (i64)9)) {
        aa_lex$lex();
        aa_parse$checksymbol((i64)14);
        if ((aa_lex$lxvalue==(i64)1) || (aa_lex$lxvalue==(i64)2) || (aa_lex$lxvalue==(i64)4) || (aa_lex$lxvalue==(i64)8)) {
        }
        else {
            aa_lib$serror((byte*)"*n must be 1,2,4,8");
        }
;
        (*scale) = aa_lex$lxvalue;
        aa_lex$lex();
    }
    else {
        (*scale) = (i64)0;
    }
;
}

static struct aa_decls$opndrec *aa_parse$readaddrmode(i64 size) {
        i64 reg;
        i64 regsize;
        i64 scale;
        i64 regix;
        i64 regixsize;
        i64 scaleix;
        struct aa_decls$opndrec *  x;
        struct aa_decls$opndrec *  p;
    reg = (regix = (i64)0);
    regsize = (regixsize = (i64)0);
    scale = (scaleix = (i64)0);
    x = 0;
    if ((aa_lex$lxsymbol == (i64)24)) {
        aa_parse$readreg(&reg,&regsize,&scale);
        if ((aa_lex$lxsymbol==(i64)7)) {
            aa_lex$lex();
            if ((aa_lex$lxsymbol == (i64)24)) {
                aa_parse$readreg(&regix,&regixsize,&scaleix);
                if ((aa_lex$lxsymbol==(i64)7) || (aa_lex$lxsymbol==(i64)8)) {
                    x = (struct aa_decls$opndrec *)aa_parse$readexpression();
                }
;
            }
            else {
                x = (struct aa_decls$opndrec *)aa_parse$readexpression();
            }
;
        }
        else if ((aa_lex$lxsymbol==(i64)8)) {
            x = (struct aa_decls$opndrec *)aa_parse$readexpression();
        }
;
    }
    else {
        x = (struct aa_decls$opndrec *)aa_parse$readexpression();
    }
;
    if ((!!(scale) && !!(scaleix))) {
        aa_lib$serror((byte*)"Two *N scales");
    }
;
    aa_parse$checksymbol((i64)6);
    aa_lex$lex();
    if ((!!(scale) && !(!!(scaleix)))) {
        {i64 temp = reg; reg = regix; regix = temp; };
        {i64 temp = regsize; regsize = regixsize; regixsize = temp; };
        {i64 temp = scale; scale = scaleix; scaleix = temp; };
    }
;
    if ((scaleix == (i64)0)) {
        scaleix = (i64)1;
    }
;
    if (((!!(regsize) && !!(regixsize)) && (regsize != regixsize))) {
        aa_lib$serror((byte*)"Addr reg size mismatch");
    }
;
    p = (struct aa_decls$opndrec *)aa_lib$genindex(reg,regix,scaleix,(struct aa_decls$opndrec *)x,size,(((regsize == (i64)4) || (regixsize == (i64)4)) ? (i64)4 : (i64)8));
    return (struct aa_decls$opndrec *)p;
}

// START
void aa_parse$start(void) {

}

// START
void aa_tables$start(void) {

}

void aa_writeexe$writeexe(u8 *outfile,i64 dodll) {
        i64 i;
    aa_writeexe$dllfilename = outfile;
    aa_writeexe$isdll = dodll;
    aa_writeexe$datastart = (aa_writeexe$dataptr = (byte *)mlib$pcm_allocz(aa_writeexe$filesize));
    aa_writeexe$writedosstub();
    aa_writeexe$writepesig();
    aa_writeexe$writefileheader();
    aa_writeexe$writeoptheader();
    for (i=(i64)1;i<=aa_writeexe$nsections;++i) {
L1007 :;
        aa_writeexe$writesectionheader((struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[(i)-1]);
L1008 :;
    }
L1009 :;
    ;
    aa_writeexe$writepadding(aa_writeexe$sectiontable[((i64)1)-1].rawoffset);
    for (i=(i64)1;i<=aa_writeexe$nsections;++i) {
L1010 :;
        aa_writeexe$writesectiondata((struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[(i)-1]);
L1011 :;
    }
L1012 :;
    ;
    if (!!(aa_decls$fverbose)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Writing file:",NULL);
        msysc$m_print_str(outfile,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((mlib$writefile(outfile,aa_writeexe$datastart,(aa_writeexe$dataptr - aa_writeexe$datastart)) == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Error writing exe file (possibly still running)",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
;
}

void aa_writeexe$genexe(u8 *entrypoint,u8 *outfile,i64 dodll) {
    aa_writeexe$dllfilename = outfile;
    aa_writeexe$isdll = dodll;
    aa_writeexe$imagebase = (u64)(!!(aa_writeexe$isdll) ? (i64)1713635328 : (i64)4194304);
    aa_writeexe$userentrypoint = entrypoint;
    aa_writeexe$loadlibs();
    aa_writeexe$scanst();
    aa_writeexe$getoffsets();
    aa_writeexe$relocdata(&aa_writeexe$sectiontable[((i64)1)-1]);
    aa_writeexe$relocdata(&aa_writeexe$sectiontable[((i64)2)-1]);
}

static void aa_writeexe$loadlibs(void) {
        i64 i;
        i64 hinst;
        u8 filename[300];
    for (i=(i64)1;i<=aa_decls$nsearchlibs;++i) {
L1013 :;
        strcpy((u8 *)filename,aa_decls$searchlibs[(i)-1]);
        strcat((u8 *)filename,(byte*)".dll");
        hinst = (i64)mwindows$os_getdllinst((u8 *)filename);
        if ((hinst == (i64)0)) {
            msysc$m_print_startcon();
            msysc$m_print_str(aa_decls$searchlibs[(i)-1],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_str(filename,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            aa_lib$gerror((byte*)"Can't load search lib");
        }
;
        aa_writeexe$libinsttable[(i)-1] = hinst;
        aa_writeexe$libinstnames[(i)-1] = mlib$pcm_copyheapstring((u8 *)filename);
L1014 :;
    }
L1015 :;
    ;
}

void aa_writeexe$initsectiontable(void) {
    aa_writeexe$sectiontable[((i64)1)-1].name = (byte*)".text";
    aa_writeexe$sectiontable[((i64)1)-1].segtype = (i64)1;
    aa_writeexe$sectiontable[((i64)1)-1].data = (struct aa_decls$dbuffer *)aa_decls$ss_code;
    aa_writeexe$sectiontable[((i64)1)-1].virtsize = aa_lib$bufferlength((struct aa_decls$dbuffer *)aa_decls$ss_code);
    if ((aa_lib$bufferlength((struct aa_decls$dbuffer *)aa_decls$ss_idata) == (i64)0)) {
        aa_lib$addqword((struct aa_decls$dbuffer *)aa_decls$ss_idata,(i64)0);
    }
;
    aa_writeexe$sectiontable[((i64)2)-1].name = (byte*)".data";
    aa_writeexe$sectiontable[((i64)2)-1].segtype = (i64)2;
    aa_writeexe$sectiontable[((i64)2)-1].data = (struct aa_decls$dbuffer *)aa_decls$ss_idata;
    aa_writeexe$sectiontable[((i64)2)-1].virtsize = aa_lib$bufferlength((struct aa_decls$dbuffer *)aa_decls$ss_idata);
    aa_writeexe$sectiontable[((i64)2)-1].rawsize = mlib$roundtoblock(aa_writeexe$sectiontable[((i64)2)-1].virtsize,(i64)512);
    aa_writeexe$sectiontable[((i64)2)-1].nrelocs = aa_decls$ss_nidatarelocs;
    aa_writeexe$sectiontable[((i64)2)-1].relocs = (struct aa_decls$relocrec *)aa_decls$ss_idatarelocs;
    if ((aa_decls$ss_zdatalen == (i64)0)) {
        aa_decls$ss_zdatalen = (i64)16;
    }
;
    aa_writeexe$sectiontable[((i64)3)-1].name = (byte*)".bss";
    aa_writeexe$sectiontable[((i64)3)-1].segtype = (i64)3;
    aa_writeexe$sectiontable[((i64)3)-1].virtsize = aa_decls$ss_zdatalen;
    aa_writeexe$sectiontable[((i64)1)-1].rawsize = mlib$roundtoblock(aa_writeexe$sectiontable[((i64)1)-1].virtsize,(i64)512);
    aa_writeexe$sectiontable[((i64)1)-1].nrelocs = aa_decls$ss_ncoderelocs;
    aa_writeexe$sectiontable[((i64)1)-1].relocs = (struct aa_decls$relocrec *)aa_decls$ss_coderelocs;
    aa_writeexe$sectiontable[((i64)4)-1].name = (byte*)".idata";
    aa_writeexe$sectiontable[((i64)4)-1].segtype = (i64)5;
    aa_writeexe$sectiontable[((i64)4)-1].virtsize = (i64)0;
    aa_writeexe$sectiontable[((i64)4)-1].rawsize = (i64)0;
    aa_writeexe$nsections = (i64)4;
}

static u8 *aa_writeexe$extractlibname(u8 *name,i64 *libno,i64 moduleno) {
        u8 *  s;
        u8 *  name2;
        u8 str[256];
        i64 i;
        i64 n;
    name2 = 0;
    //reenter:
L1016 :;
;
    s = name;
    (*libno) = (i64)0;
    L1017 :;
    while (!!((u64)(*s))) {
        if (((u64)(*s) == '.')) {
            memcpy(str,(void *)name,(u64)(s - name));
            str[(((s - name) + (i64)1))-1] = (u64)0u;
            strcat((u8 *)str,(byte*)".dll");
            for (i=(i64)1;i<=aa_writeexe$ndlls;++i) {
L1020 :;
                if (!!(mlib$eqstring((u8 *)str,aa_writeexe$dlltable[(i)-1].name))) {
                    (*libno) = i;
                    ++(aa_writeexe$dlltable[((*libno))-1].nprocs);
                    return (!!(name2) ? name2 : (s + (i64)1));
                }
;
L1021 :;
            }
L1022 :;
            ;
            if ((aa_writeexe$ndlls >= (i64)50)) {
                aa_lib$gerror((byte*)"Too many libs");
            }
;
            (*libno) = ++(aa_writeexe$ndlls);
            aa_writeexe$dlltable[((*libno))-1].name = mlib$pcm_copyheapstring((u8 *)str);
            aa_writeexe$dlltable[((*libno))-1].nprocs = (i64)1;
            return (!!(name2) ? name2 : (s + (i64)1));
        }
;
        ++(s);
L1018 :;
    }
L1019 :;
    ;
    for (i=(i64)1;i<=aa_decls$nsearchlibs;++i) {
L1023 :;
        if (!!(mwindows$os_getdllprocaddr(aa_writeexe$libinsttable[(i)-1],name))) {
            n = i;
            goto L1025 ;
        }
;
L1024 :;
    }
    {
        msysc$m_print_startcon();
        msysc$m_print_str(name,NULL);
        msysc$m_print_str(aa_decls$moduletable[(moduleno)-1].name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        aa_lib$gerror((byte*)"Can't find external function");
    }
L1025 :;
    ;
    if (!!(((*libno) = aa_writeexe$libnotable[(n)-1]))) {
        ++(aa_writeexe$dlltable[((*libno))-1].nprocs);
        return name;
    }
;
    strcpy((u8 *)str,aa_decls$searchlibs[(n)-1]);
    strcat((u8 *)str,(byte*)".dll");
    if ((aa_writeexe$ndlls >= (i64)50)) {
        aa_lib$gerror((byte*)"2:Too many libs");
    }
;
    (*libno) = ++(aa_writeexe$ndlls);
    aa_writeexe$dlltable[((*libno))-1].name = mlib$pcm_copyheapstring((u8 *)str);
    aa_writeexe$dlltable[((*libno))-1].nprocs = (i64)1;
    aa_writeexe$libnotable[(n)-1] = (*libno);
    return name;
}

static void aa_writeexe$scanst(void) {
        i64 i;
        i64 libno;
        struct aa_decls$strec *  d;
        u8 *  name;
    for (i=(i64)1;i<=aa_decls$ss_nsymbols;++i) {
L1026 :;
        d = (struct aa_decls$strec *)(*aa_decls$ss_symboltable)[(i)-1];
                {i64 $temp = (i64)(*d).symbol;
if (($temp==(i64)21)) {
            if ((aa_writeexe$nimports >= (i64)1000)) {
                aa_lib$gerror((byte*)"genexe: Too many imports");
            }
;
            ++(aa_writeexe$nimports);
            name = aa_writeexe$extractlibname((*d).name,&libno,(i64)(*d).moduleno);
            aa_writeexe$importtable[(aa_writeexe$nimports)-1].libno = libno;
            aa_writeexe$importtable[(aa_writeexe$nimports)-1].name = name;
            aa_writeexe$importtable[(aa_writeexe$nimports)-1].def = (struct aa_decls$strec *)d;
            (*d).importindex = aa_writeexe$nimports;
        }
        else if (($temp==(i64)22)) {
            if (!!(aa_writeexe$userentrypoint)) {
                if (!!(mlib$eqstring((*d).name,aa_writeexe$userentrypoint))) {
                    aa_writeexe$stentrypoint = (struct aa_decls$strec *)d;
                }
;
            }
            else {
                if ((!!(mlib$eqstring((*d).name,(byte*)"main")) && !(!!(aa_writeexe$isdll)))) {
                    aa_writeexe$stentrypoint = (struct aa_decls$strec *)d;
                }
                else if ((!!(mlib$eqstring((*d).name,(byte*)"start")) && !(!!(aa_writeexe$isdll)))) {
                    aa_writeexe$stentrypoint2 = (struct aa_decls$strec *)d;
                }
                else if ((!!(mlib$eqstring((*d).name,(byte*)"dllmain")) && !!(aa_writeexe$isdll))) {
                    aa_writeexe$stentrypoint = (struct aa_decls$strec *)d;
                }
;
            }
;
            if ((!!(aa_writeexe$stentrypoint) && ((i64)(*aa_writeexe$stentrypoint).segment != (i64)1))) {
                aa_lib$gerror((byte*)"Entry point not in code seg");
            }
;
            if ((aa_writeexe$nexports >= (i64)3000)) {
                aa_lib$gerror((byte*)"gendll: Too many exports");
            }
;
            ++(aa_writeexe$nexports);
            aa_writeexe$exporttable[(aa_writeexe$nexports)-1].def = (struct aa_decls$strec *)d;
            aa_writeexe$exporttable[(aa_writeexe$nexports)-1].name = (*d).name;
        }
        };
L1027 :;
    }
L1028 :;
    ;
}

static void aa_writeexe$relocdata(struct aa_objdecls$sectionrec *s) {
        struct aa_objdecls$sectionrec *  u;
        struct aa_decls$relocrec *  r;
        byte *  p;
        u32 *  p32;
        u64 *  p64;
        struct aa_decls$strec *  d;
        u64 thunkoffset;
        i64 index;
    p = (byte *)aa_lib$bufferelemptr((struct aa_decls$dbuffer *)(*s).data,(i64)0);
    r = (struct aa_decls$relocrec *)(*s).relocs;
    L1029 :;
    while (!!(r)) {
        d = (struct aa_decls$strec *)(*aa_decls$ss_symboltable)[((*r).stindex)-1];
        index = (i64)(*d).importindex;
        thunkoffset = (u64)aa_writeexe$importtable[(index)-1].thunkoffset;
                {i64 $temp = (*r).reloctype;
if (($temp==(i64)4)) {
            if (((i64)(*d).symbol != (i64)21)) {
                aa_lib$gerror((byte*)"rel32/not imported");
            }
;
            (*(u32 *)(p + (*r).offset)) = (((i64)thunkoffset - (*r).offset) - (i64)4);
        }
        else if (($temp==(i64)2) || ($temp==(i64)1)) {
            if (((i64)(*d).symbol == (i64)21)) {
                (*(u32 *)(p + (*r).offset)) = ((i64)(aa_writeexe$imagebase + thunkoffset) + aa_writeexe$sectiontable[((i64)1)-1].virtoffset);
            }
            else {
                                {i64 $temp = (i64)(*d).segment;
if (($temp==(i64)3)) {
                    u = (struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[((i64)3)-1];
                }
                else if (($temp==(i64)2)) {
                    u = (struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[((i64)2)-1];
                }
                else if (($temp==(i64)1)) {
                    u = (struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[((i64)1)-1];
                }
                };
                p32 = (u32 *)(p + (*r).offset);
                if (((*r).reloctype == (i64)2)) {
                    (*p32) = (((i64)(*p32) + (*u).virtoffset) + (i64)aa_writeexe$imagebase);
                }
                else {
                    p64 = (u64 *)p32;
                    (*p64) = (u64)(((i64)(*p64) + (*u).virtoffset) + (i64)aa_writeexe$imagebase);
                }
;
            }
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(aa_objdecls$relocnames[((*r).reloctype)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            aa_lib$gerror((byte*)"Can't do this rel type");
        }
        };
        r = (struct aa_decls$relocrec *)(*r).nextreloc;
L1030 :;
    }
L1031 :;
    ;
}

static void aa_writeexe$getbaserelocs(struct aa_objdecls$sectionrec *s) {
        struct aa_objdecls$sectionrec *  u;
        struct aa_decls$relocrec *  r;
        byte *  p;
        struct aa_decls$strec *  d;
    p = (byte *)aa_lib$bufferelemptr((struct aa_decls$dbuffer *)(*s).data,(i64)0);
    r = (struct aa_decls$relocrec *)(*s).relocs;
    L1032 :;
    while (!!(r)) {
        d = (struct aa_decls$strec *)(*aa_decls$ss_symboltable)[((*r).stindex)-1];
                {i64 $temp = (*r).reloctype;
if (($temp==(i64)2) || ($temp==(i64)1)) {
            if (((i64)(*d).symbol == (i64)21)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"BASERELOC/SKIP IMPORT",NULL);
                msysc$m_print_str((*d).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
            else {
                                {i64 $temp = (i64)(*d).segment;
if (($temp==(i64)3)) {
                    u = (struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[((i64)3)-1];
                }
                else if (($temp==(i64)2)) {
                    u = (struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[((i64)2)-1];
                }
                else if (($temp==(i64)1)) {
                    u = (struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[((i64)1)-1];
                }
                };
                aa_writeexe$newbasereloc(((*u).virtoffset + (*r).offset),(*r).reloctype);
            }
;
        }
        };
        r = (struct aa_decls$relocrec *)(*r).nextreloc;
L1033 :;
    }
L1034 :;
    ;
}

static void aa_writeexe$writerecordx(void *r,i64 length) {
    memcpy(aa_writeexe$dataptr,r,(u64)length);
    aa_writeexe$dataptr += length;
}

static void aa_writeexe$writedosstub(void) {
        static byte stubdata[128] = {
    (u8)77u,
    (u8)90u,
    (u8)144u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)255u,
    (u8)255u,
    (u8)0u,
    (u8)0u,
    (u8)184u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)128u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)14u,
    (u8)31u,
    (u8)186u,
    (u8)14u,
    (u8)0u,
    (u8)180u,
    (u8)9u,
    (u8)205u,
    (u8)33u,
    (u8)184u,
    (u8)1u,
    (u8)76u,
    (u8)205u,
    (u8)33u,
    (u8)84u,
    (u8)104u,
    (u8)105u,
    (u8)115u,
    (u8)32u,
    (u8)112u,
    (u8)114u,
    (u8)111u,
    (u8)103u,
    (u8)114u,
    (u8)97u,
    (u8)109u,
    (u8)32u,
    (u8)99u,
    (u8)97u,
    (u8)110u,
    (u8)110u,
    (u8)111u,
    (u8)116u,
    (u8)32u,
    (u8)98u,
    (u8)101u,
    (u8)32u,
    (u8)114u,
    (u8)117u,
    (u8)110u,
    (u8)32u,
    (u8)105u,
    (u8)110u,
    (u8)32u,
    (u8)68u,
    (u8)79u,
    (u8)83u,
    (u8)32u,
    (u8)109u,
    (u8)111u,
    (u8)100u,
    (u8)101u,
    (u8)46u,
    (u8)13u,
    (u8)13u,
    (u8)10u,
    (u8)36u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
    aa_writeexe$writerecordx(&stubdata,(i64)128);
}

static void aa_writeexe$writepesig(void) {
    (*(aa_writeexe$dataptr)++) = (i64)80;
    (*(aa_writeexe$dataptr)++) = (i64)69;
    (*(aa_writeexe$dataptr)++) = (i64)0;
    (*(aa_writeexe$dataptr)++) = (i64)0;
}

static void aa_writeexe$writepadding(i64 offset) {
    aa_writeexe$dataptr = (aa_writeexe$datastart + offset);
}

static void aa_writeexe$writefileheader(void) {
        struct aa_objdecls$imagefileheader header;
    memset(&header,(i32)(i64)0,(u64)20u);
    header.machine = (i64)34404;
    header.nsections = aa_writeexe$nsections;
    header.optheadersize = (i64)240;
    header.characteristics = (i64)559;
    if (!!(aa_writeexe$isdll)) {
        header.characteristics = (i64)8750;
    }
;
    aa_writeexe$writerecordx(&header,(i64)20);
}

static void aa_writeexe$writeoptheader(void) {
        struct aa_objdecls$optionalheader header;
    memset(&header,(i32)(i64)0,(u64)240u);
    header.magic = (i64)523;
    header.majorlv = (i64)1;
    header.minorlv = (i64)0;
    header.codesize = aa_writeexe$sectiontable[((i64)1)-1].rawsize;
    header.idatasize = (aa_writeexe$sectiontable[((i64)2)-1].rawsize + aa_writeexe$sectiontable[((i64)4)-1].rawsize);
    header.zdatasize = mlib$roundtoblock(aa_writeexe$sectiontable[((i64)3)-1].virtsize,(i64)512);
    if ((aa_writeexe$stentrypoint == 0)) {
        aa_writeexe$stentrypoint = (struct aa_decls$strec *)aa_writeexe$stentrypoint2;
        if ((aa_writeexe$stentrypoint == 0)) {
            aa_writeexe$stentrypoint = (struct aa_decls$strec *)aa_writeexe$stentrypoint3;
            if (!!(aa_writeexe$stentrypoint)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Using tertiary 'WinMain' entry point",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
;
        }
;
    }
;
    if ((aa_writeexe$stentrypoint == 0)) {
        if (!!(aa_writeexe$userentrypoint)) {
            msysc$m_print_startcon();
            msysc$m_print_str(aa_writeexe$userentrypoint,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            aa_lib$gerror((byte*)"User entry point not found");
        }
        else {
            if (!(!!(aa_writeexe$isdll))) {
                aa_lib$gerror((byte*)"Entry point not found: main or start");
            }
;
        }
;
    }
    else {
        header.entrypoint = (aa_writeexe$sectiontable[((i64)1)-1].virtoffset + (i64)(*aa_writeexe$stentrypoint).offset);
    }
;
    header.codebase = (i64)4096;
    header.imagebase = aa_writeexe$imagebase;
    header.sectionalignment = (i64)4096;
    header.filealignment = (i64)512;
    header.majorosv = (i64)4;
    header.minorosv = (i64)0;
    header.majorssv = (i64)5;
    header.minorssv = (i64)2;
    header.imagesize = aa_writeexe$imagesize;
    header.headerssize = aa_writeexe$sectiontable[((i64)1)-1].rawoffset;
    header.subsystem = (i64)3;
    header.stackreserve = (u64)4194304u;
    header.stackcommit = (u64)2097152u;
    header.heapreserve = (u64)1048576u;
    header.heapcommit = (u64)4096u;
    header.rvadims = (i64)16;
    header.importtable.virtualaddr = aa_writeexe$sectiontable[((i64)4)-1].virtoffset;
    header.importtable.size = ((aa_writeexe$sectiontable[((i64)4)-1].virtsize - aa_writeexe$exportdirvirtsize) - aa_writeexe$blockdirvirtsize);
    if (!!(aa_writeexe$isdll)) {
        header.dllcharacteristics = (i64)64;
        header.exporttable.virtualaddr = aa_writeexe$exportdirvirtaddr;
        header.exporttable.size = aa_writeexe$exportdirvirtsize;
        header.basereloctable.virtualaddr = aa_writeexe$blockdirvirtaddr;
        header.basereloctable.size = aa_writeexe$blockdirvirtsize;
    }
;
    header.iat.virtualaddr = aa_writeexe$fileiatoffset;
    header.iat.size = aa_writeexe$fileiatsize;
    aa_writeexe$writerecordx(&header,(i64)240);
}

static void aa_writeexe$writesectionheader(struct aa_objdecls$sectionrec *s) {
        struct aa_objdecls$imagesectionheader sheader;
    memset(&sheader,(i32)(i64)0,(u64)40u);
    strcpy((u8 *)&sheader.name[((i64)1)-1],(*s).name);
    sheader.virtual_size = (*s).virtsize;
    sheader.virtual_address = (*s).virtoffset;
    sheader.rawdata_offset = (*s).rawoffset;
    sheader.rawdata_size = (*s).rawsize;
        {i64 $temp = (*s).segtype;
if (($temp==(i64)3)) {
        sheader.characteristics = (i64)3226468480;
    }
    else if (($temp==(i64)2)) {
        sheader.characteristics = (i64)3226468416;
    }
    else if (($temp==(i64)1)) {
        sheader.characteristics = (i64)1615855648;
    }
    else if (($temp==(i64)5)) {
        sheader.characteristics = (i64)1076887616;
    }
    };
    aa_writeexe$writerecordx(&sheader,(i64)40);
}

static void aa_writeexe$writesectiondata(struct aa_objdecls$sectionrec *s) {
        {i64 $temp = (*s).segtype;
if (($temp==(i64)5)) {
        aa_writeexe$writerecordx((*s).bytedata,(*s).virtsize);
        if (((*s).rawsize > (*s).virtsize)) {
            aa_writeexe$dataptr += ((*s).rawsize - (*s).virtsize);
        }
;
    }
    else if (($temp==(i64)3)) {
    }
    else {
        aa_writeexe$writerecordx(aa_lib$bufferelemptr((struct aa_decls$dbuffer *)(*s).data,(i64)0),(*s).rawsize);
    }
    };
}

static void aa_writeexe$getoffsets(void) {
        i64 fileoffset;
        i64 imageoffset;
        i64 i;
        i64 diroffset;
        i64 impdirno;
        i64 hinttableoffset;
        i64 j;
        i64 codesize;
        i64 length;
        i64 thunkoffset;
        i64 offset;
        i64 dirstartoffset;
        byte *  pcode;
        byte *  pimpdir;
        struct aa_objdecls$importdirrec *  pdir;
        i64 *  paddr;
        i64 *  pname;
        i64 iatoffset;
        byte *  phint;
        u32 *  pextra;
        i64 xxx;
        i64 $av_1;
        byte *  thunkptr;
        byte *  codebase;
        i64 thunkaddr;
    fileoffset = (i64)392;
    fileoffset += ((i64)40 * aa_writeexe$nsections);
    fileoffset = mlib$roundtoblock(fileoffset,(i64)512);
    imageoffset = (i64)4096;
    codesize = aa_writeexe$sectiontable[((i64)1)-1].virtsize;
    pcode = (byte *)aa_lib$bufferelemptr((struct aa_decls$dbuffer *)aa_decls$ss_code,codesize);
    L1035 :;
    while (!!((codesize & (i64)7))) {
        (*(pcode)++) = (i64)144;
        ++(codesize);
L1036 :;
    }
L1037 :;
    ;
    thunkoffset = codesize;
    codesize += (aa_writeexe$nimports * (i64)8);
    aa_writeexe$sectiontable[((i64)1)-1].virtsize = codesize;
    aa_writeexe$sectiontable[((i64)1)-1].rawsize = mlib$roundtoblock(codesize,(i64)512);
    aa_lib$buffercheck((struct aa_decls$dbuffer *)aa_decls$ss_code,((codesize - thunkoffset) + (i64)16));
    for (i=(i64)1;i<=aa_writeexe$nsections;++i) {
L1038 :;
        if ((aa_writeexe$sectiontable[(i)-1].segtype != (i64)3)) {
            aa_writeexe$sectiontable[(i)-1].rawoffset = fileoffset;
        }
;
        if ((aa_writeexe$sectiontable[(i)-1].segtype != (i64)3)) {
            fileoffset = mlib$roundtoblock((fileoffset + aa_writeexe$sectiontable[(i)-1].virtsize),(i64)512);
        }
;
        aa_writeexe$sectiontable[(i)-1].virtoffset = imageoffset;
        if ((aa_writeexe$sectiontable[(i)-1].segtype == (i64)5)) {
            diroffset = imageoffset;
            impdirno = i;
        }
;
        imageoffset = mlib$roundtoblock((imageoffset + aa_writeexe$sectiontable[(i)-1].virtsize),(i64)4096);
L1039 :;
    }
L1040 :;
    ;
    if (!!(aa_writeexe$isdll)) {
        aa_writeexe$getbaserelocs((struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[((i64)1)-1]);
        aa_writeexe$getbaserelocs((struct aa_objdecls$sectionrec *)&aa_writeexe$sectiontable[((i64)2)-1]);
    }
;
    diroffset += ((aa_writeexe$ndlls + (i64)1) * (i64)20);
    for (i=(i64)1;i<=aa_writeexe$ndlls;++i) {
L1041 :;
        aa_writeexe$dlltable[(i)-1].nametableoffset = diroffset;
        diroffset += ((aa_writeexe$dlltable[(i)-1].nprocs + (i64)1) * (i64)8);
L1042 :;
    }
L1043 :;
    ;
    aa_writeexe$fileiatoffset = diroffset;
    for (i=(i64)1;i<=aa_writeexe$ndlls;++i) {
L1044 :;
        aa_writeexe$dlltable[(i)-1].addrtableoffset = diroffset;
        diroffset += ((aa_writeexe$dlltable[(i)-1].nprocs + (i64)1) * (i64)8);
L1045 :;
    }
L1046 :;
    ;
    aa_writeexe$fileiatsize = (diroffset - aa_writeexe$fileiatoffset);
    hinttableoffset = diroffset;
    for (i=(i64)1;i<=aa_writeexe$nimports;++i) {
L1047 :;
        length = (strlen(aa_writeexe$importtable[(i)-1].name) + (i64)3);
        if (!!((length & (i64)1))) {
            ++(length);
        }
;
        aa_writeexe$importtable[(i)-1].hintnameoffset = diroffset;
        diroffset += length;
L1048 :;
    }
L1049 :;
    ;
    diroffset = mlib$roundtoblock(diroffset,(i64)4);
    for (i=(i64)1;i<=aa_writeexe$ndlls;++i) {
L1050 :;
        length = (strlen(aa_writeexe$dlltable[(i)-1].name) + (i64)1);
        if (!!(msysc$m_getdotindex(length,(i64)0))) {
            ++(length);
        }
;
        aa_writeexe$dlltable[(i)-1].dllextraoffset = diroffset;
        diroffset += (aa_writeexe$dlltable[(i)-1].nprocs * (i64)4);
        aa_writeexe$dlltable[(i)-1].dllnameoffset = diroffset;
        diroffset += length;
L1051 :;
    }
L1052 :;
    ;
    dirstartoffset = aa_writeexe$sectiontable[(impdirno)-1].virtoffset;
    if (!!(aa_writeexe$isdll)) {
        aa_writeexe$exportdirvirtaddr = diroffset;
        aa_writeexe$exportdiroffset = (diroffset - dirstartoffset);
        aa_writeexe$exportdirvirtsize = aa_writeexe$getexporttablesize();
        diroffset += aa_writeexe$exportdirvirtsize;
        aa_writeexe$scanbaserelocs();
        aa_writeexe$blockdirvirtaddr = diroffset;
        aa_writeexe$blockdiroffset = (diroffset - dirstartoffset);
        aa_writeexe$blockdirvirtsize = aa_writeexe$basetablesize;
        diroffset += aa_writeexe$blockdirvirtsize;
    }
;
    offset = (diroffset - dirstartoffset);
    aa_writeexe$sectiontable[(impdirno)-1].virtsize = offset;
    aa_writeexe$sectiontable[(impdirno)-1].rawsize = mlib$roundtoblock(offset,(i64)512);
    aa_writeexe$filesize = mlib$roundtoblock((fileoffset + offset),(i64)512);
    aa_writeexe$imagesize = mlib$roundtoblock((imageoffset + (diroffset - dirstartoffset)),(i64)4096);
    pimpdir = (aa_writeexe$sectiontable[(impdirno)-1].bytedata = (byte *)mlib$pcm_allocz(offset));
    pdir = (struct aa_objdecls$importdirrec *)pimpdir;
    for (i=(i64)1;i<=aa_writeexe$ndlls;++i) {
L1053 :;
        (*pdir).implookuprva = aa_writeexe$dlltable[(i)-1].nametableoffset;
        (*pdir).impaddressrva = aa_writeexe$dlltable[(i)-1].addrtableoffset;
        (*pdir).namerva = aa_writeexe$dlltable[(i)-1].dllnameoffset;
        ++(pdir);
        iatoffset = aa_writeexe$dlltable[(i)-1].addrtableoffset;
        paddr = (i64 *)((pimpdir + iatoffset) - dirstartoffset);
        pname = (i64 *)((pimpdir + aa_writeexe$dlltable[(i)-1].nametableoffset) - dirstartoffset);
        for (j=(i64)1;j<=aa_writeexe$nimports;++j) {
L1056 :;
            if ((aa_writeexe$importtable[(j)-1].libno == i)) {
                (*pname) = ((*paddr) = aa_writeexe$importtable[(j)-1].hintnameoffset);
                aa_writeexe$importtable[(j)-1].iatoffset = iatoffset;
                iatoffset += (i64)8;
                ++(pname);
                ++(paddr);
            }
;
L1057 :;
        }
L1058 :;
        ;
L1054 :;
    }
L1055 :;
    ;
    for (i=(i64)1;i<=aa_writeexe$nimports;++i) {
L1059 :;
        phint = ((pimpdir + aa_writeexe$importtable[(i)-1].hintnameoffset) - dirstartoffset);
        phint += (i64)2;
        strcpy((u8 *)phint,aa_writeexe$importtable[(i)-1].name);
L1060 :;
    }
L1061 :;
    ;
    xxx = dirstartoffset;
    for (i=(i64)1;i<=aa_writeexe$ndlls;++i) {
L1062 :;
        pextra = (u32 *)((pimpdir + aa_writeexe$dlltable[(i)-1].dllextraoffset) - dirstartoffset);
                ($av_1 = aa_writeexe$dlltable[(i)-1].nprocs);
        for (j=(i64)1;j<=$av_1;++j) {
L1065 :;
            (*pextra) = xxx;
            ++(pextra);
L1066 :;
        }
L1067 :;
        ;
        xxx += (i64)20;
        phint = ((pimpdir + aa_writeexe$dlltable[(i)-1].dllnameoffset) - dirstartoffset);
        strcpy((u8 *)phint,aa_writeexe$dlltable[(i)-1].name);
L1063 :;
    }
L1064 :;
    ;
    if (!!(aa_writeexe$isdll)) {
        aa_writeexe$writeexporttable((pimpdir + aa_writeexe$exportdiroffset));
        aa_writeexe$writebasereloctable((pimpdir + aa_writeexe$blockdiroffset));
    }
;
    thunkptr = (byte *)aa_lib$bufferelemptr((struct aa_decls$dbuffer *)aa_decls$ss_code,thunkoffset);
    codebase = (byte *)aa_lib$bufferelemptr((struct aa_decls$dbuffer *)aa_decls$ss_code,(i64)0);
    for (i=(i64)1;i<=aa_writeexe$nimports;++i) {
L1068 :;
        aa_writeexe$importtable[(i)-1].thunkoffset = (thunkptr - codebase);
        (*(thunkptr)++) = (i64)72;
        (*(thunkptr)++) = (i64)255;
        (*(thunkptr)++) = (i64)36;
        (*(thunkptr)++) = (i64)37;
        thunkaddr = ((i64)aa_writeexe$imagebase + aa_writeexe$importtable[(i)-1].iatoffset);
        (*(i32 *)thunkptr) = thunkaddr;
        thunkptr += (i64)4;
L1069 :;
    }
L1070 :;
    ;
}

static i64 aa_writeexe$getsectionno(i64 segment) {
    if ((segment==(i64)3)) {
        return (i64)3;
    }
    else if ((segment==(i64)2)) {
        return (i64)2;
    }
    else if ((segment==(i64)1)) {
        return (i64)1;
    }
    else {
        aa_lib$gerror((byte*)"GSN");
        return (i64)0;
    }
;
}

static void aa_writeexe$writeexporttable(byte *pstart) {
        i64 sortindex[3000];
        struct aa_objdecls$exportdirrec *  phdr;
        u32 *  paddrtable;
        u32 *  pnametable;
        u16 *  pordtable;
        u8 *  pdllname;
        u8 *  pnames;
        i64 addrtableoffset;
        i64 nametableoffset;
        i64 ordtableoffset;
        i64 dllnameoffset;
        i64 namesoffset;
        i64 virtoffset;
        i64 sectionno;
        struct aa_decls$strec *  d;
        i64 i;
    phdr = (struct aa_objdecls$exportdirrec *)pstart;
    (*phdr).timedatestamp = (i64)1602876664;
    (*phdr).ordinalbase = (i64)1;
    (*phdr).naddrtable = aa_writeexe$nexports;
    (*phdr).nnamepointers = aa_writeexe$nexports;
    addrtableoffset = (i64)40;
    nametableoffset = (addrtableoffset + (aa_writeexe$nexports * (i64)4));
    ordtableoffset = (nametableoffset + (aa_writeexe$nexports * (i64)4));
    dllnameoffset = (ordtableoffset + (aa_writeexe$nexports * (i64)2));
    namesoffset = ((dllnameoffset + strlen(aa_writeexe$dllfilename)) + (i64)1);
    virtoffset = (aa_writeexe$sectiontable[((i64)4)-1].virtoffset + aa_writeexe$exportdiroffset);
    paddrtable = (u32 *)(pstart + addrtableoffset);
    pnametable = (u32 *)(pstart + nametableoffset);
    pordtable = (u16 *)(pstart + ordtableoffset);
    pdllname = (u8 *)(pstart + dllnameoffset);
    pnames = (u8 *)(pstart + namesoffset);
    (*phdr).namerva = (dllnameoffset + virtoffset);
    (*phdr).expaddressrva = (addrtableoffset + virtoffset);
    (*phdr).namepointerrva = (nametableoffset + virtoffset);
    (*phdr).ordtablerva = (ordtableoffset + virtoffset);
    strcpy(pdllname,aa_writeexe$dllfilename);
    if ((aa_writeexe$nexports > (i64)3000)) {
        aa_lib$gerror((byte*)"Too many exports - can't sort");
    }
;
    aa_writeexe$sortexports(&sortindex);
    for (i=(i64)1;i<=aa_writeexe$nexports;++i) {
L1071 :;
        d = (struct aa_decls$strec *)aa_writeexe$exporttable[(sortindex[(i)-1])-1].def;
        sectionno = aa_writeexe$getsectionno((i64)(*d).segment);
        strcpy(pnames,(*d).name);
        (*pnametable) = (namesoffset + virtoffset);
        ++(pnametable);
        namesoffset += (strlen((*d).name) + (i64)1);
        pnames += (strlen((*d).name) + (i64)1);
        (*paddrtable) = ((i64)(*d).offset + aa_writeexe$sectiontable[(sectionno)-1].virtoffset);
        ++(paddrtable);
        (*pordtable) = (i - (i64)1);
        ++(pordtable);
L1072 :;
    }
L1073 :;
    ;
}

static i64 aa_writeexe$getexporttablesize(void) {
        i64 size;
        i64 i;
    size = (i64)40;
    size += (aa_writeexe$nexports * (i64)4);
    size += (aa_writeexe$nexports * (i64)4);
    size += (aa_writeexe$nexports * (i64)2);
    size += (strlen(aa_writeexe$dllfilename) + (i64)1);
    for (i=(i64)1;i<=aa_writeexe$nexports;++i) {
L1074 :;
        size += (strlen((*aa_writeexe$exporttable[(i)-1].def).name) + (i64)1);
L1075 :;
    }
L1076 :;
    ;
    return size;
}

static void aa_writeexe$newbasereloc(i64 addr,i64 reltype) {
        struct aa_writeexe$basereloc *  p;
    p = (struct aa_writeexe$basereloc *)mlib$pcm_allocz((i64)16);
    (*p).address = addr;
    (*p).reloctype = reltype;
    (*p).nextitem = (struct aa_writeexe$basereloc *)aa_writeexe$basereloclist;
    aa_writeexe$basereloclist = (struct aa_writeexe$basereloc *)p;
    ++(aa_writeexe$nbaserelocs);
    aa_writeexe$maxrelocaddr=(aa_writeexe$maxrelocaddr>addr?aa_writeexe$maxrelocaddr:addr);
;
}

static void aa_writeexe$scanbaserelocs(void) {
        i64 baseaddr;
        i64 addr;
        i64 nextblock;
        struct aa_writeexe$basereloc *  p;
        i64 i;
    baseaddr = (i64)4096;
    aa_writeexe$nbaseblocks = (i64)0;
    L1077 :;
    do {
        nextblock = (baseaddr + (i64)4096);
        if ((aa_writeexe$nbaseblocks >= (i64)500)) {
            aa_lib$gerror((byte*)"Too many blocks");
        }
;
        ++(aa_writeexe$nbaseblocks);
        aa_writeexe$blockbases[(aa_writeexe$nbaseblocks)-1] = baseaddr;
        aa_writeexe$blockcounts[(aa_writeexe$nbaseblocks)-1] = (i64)0;
        p = (struct aa_writeexe$basereloc *)aa_writeexe$basereloclist;
        L1080 :;
        while (!!(p)) {
            addr = (i64)(*p).address;
            if (((addr >= baseaddr) && (addr < nextblock))) {
                ++(aa_writeexe$blockcounts[(aa_writeexe$nbaseblocks)-1]);
            }
;
            p = (struct aa_writeexe$basereloc *)(*p).nextitem;
L1081 :;
        }
L1082 :;
        ;
        baseaddr = nextblock;
L1078 :;
    }
    while (!(baseaddr > aa_writeexe$maxrelocaddr));
L1079 :;
    ;
    for (i=(i64)1;i<=aa_writeexe$nbaseblocks;++i) {
L1083 :;
        if (!!((i64)aa_writeexe$blockcounts[(i)-1])) {
            if (!!(((i64)aa_writeexe$blockcounts[(i)-1] & (i64)1))) {
                ++(aa_writeexe$blockcounts[(i)-1]);
                ++(aa_writeexe$blockpadding[(i)-1]);
            }
;
            aa_writeexe$blockbytes[(i)-1] = (((i64)aa_writeexe$blockcounts[(i)-1] * (i64)2) + (i64)8);
            aa_writeexe$basetablesize += (i64)aa_writeexe$blockbytes[(i)-1];
        }
;
L1084 :;
    }
L1085 :;
    ;
}

static void aa_writeexe$writebasereloctable(byte *pstart) {
        u32 *  p32;
        u16 *  p16;
        i64 baseaddr;
        i64 addr;
        i64 nextblock;
        struct aa_writeexe$basereloc *  q;
        i64 i;
    p32 = (u32 *)pstart;
    for (i=(i64)1;i<=aa_writeexe$nbaseblocks;++i) {
L1086 :;
        if (!!((i64)aa_writeexe$blockcounts[(i)-1])) {
            (*p32) = aa_writeexe$blockbases[(i)-1];
            ++(p32);
            (*p32) = (i64)aa_writeexe$blockbytes[(i)-1];
            ++(p32);
            p16 = (u16 *)p32;
            q = (struct aa_writeexe$basereloc *)aa_writeexe$basereloclist;
            baseaddr = aa_writeexe$blockbases[(i)-1];
            nextblock = (baseaddr + (i64)4096);
            L1089 :;
            while (!!(q)) {
                addr = (i64)(*q).address;
                if (((addr >= baseaddr) && (addr < nextblock))) {
                    (*p16) = ((addr - baseaddr) + ((((i64)(*q).reloctype == (i64)2) ? (i64)3 : (i64)10) << (i64)12));
                    ++(p16);
                }
;
                q = (struct aa_writeexe$basereloc *)(*q).nextitem;
L1090 :;
            }
L1091 :;
            ;
            if (!!((i64)aa_writeexe$blockpadding[(i)-1])) {
                (*(p16)++) = (i64)0;
            }
;
            p32 = (u32 *)p16;
        }
;
L1087 :;
    }
L1088 :;
    ;
}

static void aa_writeexe$sortexports(i64 (*sortindex)[]) {
        struct aa_decls$strec *  d;
        struct aa_decls$strec *  e;
        i64 swapped;
        i64 $av_1;
        i64 i;
    for (i=(i64)1;i<=aa_writeexe$nexports;++i) {
L1092 :;
        (*sortindex)[(i)-1] = i;
L1093 :;
    }
L1094 :;
    ;
    L1095 :;
    do {
        swapped = (i64)0;
                ($av_1 = (aa_writeexe$nexports - (i64)1));
        for (i=(i64)1;i<=$av_1;++i) {
L1098 :;
            d = (struct aa_decls$strec *)aa_writeexe$exporttable[((*sortindex)[(i)-1])-1].def;
            e = (struct aa_decls$strec *)aa_writeexe$exporttable[((*sortindex)[((i + (i64)1))-1])-1].def;
            if ((strcmp((*d).name,(*e).name) > (i64)0)) {
                swapped = (i64)1;
                {i64 temp = (*sortindex)[(i)-1]; (*sortindex)[(i)-1] = (*sortindex)[((i + (i64)1))-1]; (*sortindex)[((i + (i64)1))-1] = temp; };
            }
;
L1099 :;
        }
L1100 :;
        ;
L1096 :;
    }
    while (!!(!!(swapped)));
L1097 :;
    ;
}

// START
void aa_writeexe$start(void) {

}

void aa_writeobj$writess(u8 *outfile) {
    aa_writeobj$writecoff(outfile);
}

static void aa_writeobj$writerecord(void *r,i64 length) {
    memcpy(aa_writeobj$dataptr,r,(u64)length);
    aa_writeobj$dataptr += length;
}

static void aa_writeobj$writerelocs(struct aa_decls$relocrec *r,i64 nrelocs) {
        static struct aa_objdecls$coffrelocrec s;
        struct aa_decls$strec *  d;
    if ((nrelocs == (i64)0)) {
        return;
    }
;
    L1101 :;
    while (!!(r)) {
                {i64 $temp = (*r).reloctype;
if (($temp==(i64)2) || ($temp==(i64)1)) {
            d = (struct aa_decls$strec *)(*aa_decls$ss_symboltable)[((*r).stindex)-1];
                        {i64 $temp = (i64)(*d).segment;
if (($temp==(i64)3)) {
                s.stindex = (i64)2;
            }
            else if (($temp==(i64)2)) {
                s.stindex = (i64)4;
            }
            else if (($temp==(i64)1)) {
                s.stindex = (i64)6;
            }
            else if (($temp==(i64)0)) {
                s.stindex = ((*r).stindex + aa_writeobj$stoffset);
            }
            else {
                aa_lib$gerror((byte*)"wrelocs/bad seg");
            }
            };
        }
        else {
            s.stindex = ((*r).stindex + aa_writeobj$stoffset);
        }
        };
        s.reloctype = (*r).reloctype;
        s.virtualaddr = (*r).offset;
        memcpy(aa_writeobj$dataptr,&s,(u64)10u);
        aa_writeobj$dataptr += (i64)10;
        r = (struct aa_decls$relocrec *)(*r).nextreloc;
L1102 :;
    }
L1103 :;
    ;
}

static void aa_writeobj$writedata(struct aa_decls$dbuffer *data) {
    memcpy(aa_writeobj$dataptr,aa_lib$bufferelemptr((struct aa_decls$dbuffer *)data,(i64)0),(u64)aa_lib$bufferlength((struct aa_decls$dbuffer *)data));
    aa_writeobj$dataptr += aa_lib$bufferlength((struct aa_decls$dbuffer *)data);
}

static void aa_writeobj$writesymboltable(void) {
        i64 i;
    for (i=(i64)1;i<=aa_writeobj$nsymbols;++i) {
L1104 :;
        aa_writeobj$writerecord(&aa_writeobj$symboltable[(i)],(i64)18);
L1105 :;
    }
L1106 :;
    ;
}

static void aa_writeobj$writestringtable(void) {
        i32 *  p;
        i64 i;
        i64 n;
    p = (i32 *)aa_writeobj$dataptr;
    (*p) = aa_writeobj$nextstringoffset;
    aa_writeobj$dataptr += (i64)4;
    for (i=(i64)1;i<=aa_writeobj$nstrings;++i) {
L1107 :;
        n = (aa_writeobj$stringlengths[(i)-1] + (i64)1);
        memcpy(aa_writeobj$dataptr,(void *)aa_writeobj$stringtable[(i)-1],(u64)n);
        aa_writeobj$dataptr += n;
L1108 :;
    }
L1109 :;
    ;
}

static struct aa_objdecls$imagesymbol *aa_writeobj$makesymbol(u8 *name,i64 namelen,i64 value,i64 sectionno,i64 symtype,i64 storage,i64 naux) {
        static struct aa_objdecls$imagesymbol r;
    if ((namelen == (i64)0)) {
        namelen = strlen(name);
    }
;
    if ((namelen < (i64)8)) {
        strcpy((u8 *)&r.shortname[((i64)1)-1],name);
    }
    else if ((namelen == (i64)8)) {
        memcpy(&r.shortname[((i64)1)-1],(void *)name,(u64)namelen);
    }
    else {
        r.shortx = (i64)0;
        r.longx = aa_writeobj$addstringentry(name,namelen);
    }
;
    r.value = value;
    r.sectionno = sectionno;
    r.symtype = symtype;
    r.storageclass = storage;
    r.nauxsymbols = naux;
    return &r;
}

static void aa_writeobj$addsymbol(struct aa_objdecls$imagesymbol *r) {
    if ((aa_writeobj$nsymbols >= (i64)13000)) {
        aa_lib$gerror((byte*)"as:Too many symbols");
    }
;
    memcpy(&aa_writeobj$symboltable[(++(aa_writeobj$nsymbols))],r,(u64)8u);
}

static void aa_writeobj$initsymboltable(u8 *filename) {
    aa_writeobj$nsymbols = (i64)0;
    aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$makesymbol((byte*)".file",(i64)0,(i64)0,(i64)-2,(i64)0,(i64)103,(i64)1));
    aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$strtoaux(filename));
    aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$makesymbol((byte*)".bss",(i64)0,(i64)0,(i64)1,(i64)0,(i64)3,(i64)1));
    aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$sectiontoaux(0,(i64)0));
    aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$makesymbol((byte*)".data",(i64)0,(i64)0,(i64)2,(i64)0,(i64)3,(i64)1));
    aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$sectiontoaux((struct aa_decls$dbuffer *)aa_decls$ss_idata,aa_decls$ss_nidatarelocs));
    aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$makesymbol((byte*)".text",(i64)0,(i64)0,(i64)3,(i64)0,(i64)3,(i64)1));
    aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$sectiontoaux((struct aa_decls$dbuffer *)aa_decls$ss_code,aa_decls$ss_ncoderelocs));
}

static struct aa_objdecls$imagesymbol *aa_writeobj$strtoaux(u8 *s) {
        static struct aa_objdecls$imagesymbol r;
        byte *  p;
        i64 n;
    p = (byte *)&r;
    memset(p,(i32)(i64)0,(u64)18u);
    n = (i64)0;
    L1110 :;
    while ((((i64)(u64)(*s) != (i64)0) && (n < (i64)18))) {
        (*(p)++) = (i64)(u64)(*(s)++);
        ++(n);
L1111 :;
    }
L1112 :;
    ;
    return (struct aa_objdecls$imagesymbol *)&r;
}

static struct aa_objdecls$auxsectionrec *aa_writeobj$sectiontoaux(struct aa_decls$dbuffer *data,i64 nrelocs) {
        static struct aa_objdecls$auxsectionrec r;
    memset(&(r),0,18);
    if ((data == 0)) {
        r.length = aa_decls$ss_zdatalen;
    }
    else {
        r.length = aa_lib$bufferlength((struct aa_decls$dbuffer *)data);
    }
;
    r.nrelocs = nrelocs;
    return &r;
}

static i64 aa_writeobj$addstringentry(u8 *s,i64 length) {
        i64 offset;
    offset = aa_writeobj$nextstringoffset;
    if ((aa_writeobj$nstrings > (i64)5000)) {
        aa_lib$gerror((byte*)"W:too many strings");
    }
;
    aa_writeobj$stringtable[(++(aa_writeobj$nstrings))-1] = s;
    aa_writeobj$stringlengths[(aa_writeobj$nstrings)-1] = length;
    aa_writeobj$nextstringoffset += (length + (i64)1);
    return offset;
}

static void aa_writeobj$convertsymboltable(void) {
        struct aa_decls$strec *  s;
        u8 *  name;
        i64 i;
        i64 sect;
        i64 scope;
    aa_writeobj$stoffset = (aa_writeobj$nsymbols - (i64)1);
    aa_writeobj$nstrings = (i64)0;
    aa_writeobj$nextstringoffset = (i64)4;
    for (i=(i64)1;i<=aa_decls$ss_nsymbols;++i) {
L1113 :;
        s = (struct aa_decls$strec *)(*aa_decls$ss_symboltable)[(i)-1];
        name = (*s).name;
                {i64 $temp = (i64)(*s).segment;
if (($temp==(i64)3)) {
            sect = (i64)1;
        }
        else if (($temp==(i64)2)) {
            sect = (i64)2;
        }
        else if (($temp==(i64)1)) {
            sect = (i64)3;
        }
        else {
            sect = (i64)0;
        }
        };
                {i64 $temp = (i64)(*s).symbol;
if (($temp==(i64)19) || ($temp==(i64)20)) {
            scope = (i64)3;
        }
        else if (($temp==(i64)21) || ($temp==(i64)22)) {
            scope = (i64)2;
        }
        else {
            scope = (i64)0;
        }
        };
        aa_writeobj$addsymbol((struct aa_objdecls$imagesymbol *)aa_writeobj$makesymbol((*s).name,(i64)(*s).namelen,(i64)(*s).offset,sect,(i64)0,scope,(i64)0));
L1114 :;
    }
L1115 :;
    ;
}

static void aa_writeobj$writecoff(u8 *outfile) {
        struct aa_objdecls$imagefileheader header;
        struct aa_objdecls$imagesectionheader zsection;
        struct aa_objdecls$imagesectionheader isection;
        struct aa_objdecls$imagesectionheader csection;
        i64 offset;
    memset(&(header),0,20);
    memset(&(zsection),0,40);
    memset(&(isection),0,40);
    memset(&(csection),0,40);
    header.machine = (i64)34404;
    header.nsections = (i64)3;
    strcpy((u8 *)&zsection.name[((i64)1)-1],(byte*)".bss");
    zsection.rawdata_size = aa_decls$ss_zdatalen;
    zsection.characteristics = (i64)3225419904;
    if (((aa_decls$ss_nidatarelocs >= (i64)65536) || (aa_decls$ss_ncoderelocs >= (i64)65536))) {
        aa_lib$gerror((byte*)"Too many relocs (exceeds 16-bit field)");
    }
;
    strcpy((u8 *)&isection.name[((i64)1)-1],(byte*)".data");
    isection.rawdata_size = aa_lib$bufferlength((struct aa_decls$dbuffer *)aa_decls$ss_idata);
    isection.nrelocs = aa_decls$ss_nidatarelocs;
    isection.characteristics = (i64)3226468416;
    strcpy((u8 *)&csection.name[((i64)1)-1],(byte*)".text");
    csection.rawdata_size = aa_lib$bufferlength((struct aa_decls$dbuffer *)aa_decls$ss_code);
    csection.nrelocs = aa_decls$ss_ncoderelocs;
    csection.characteristics = (i64)1615855648;
    aa_writeobj$initsymboltable(outfile);
    aa_writeobj$convertsymboltable();
    offset = (i64)20;
    offset += (i64)120;
    if (!!((i64)isection.nrelocs)) {
        isection.relocations_ptr = offset;
        offset += ((i64)isection.nrelocs * (i64)10);
    }
;
    if (!!((i64)csection.nrelocs)) {
        csection.relocations_ptr = offset;
        offset += ((i64)csection.nrelocs * (i64)10);
    }
;
    isection.rawdata_offset = offset;
    offset += (i64)isection.rawdata_size;
    csection.rawdata_offset = offset;
    offset += (i64)csection.rawdata_size;
    header.symtaboffset = offset;
    offset += (aa_writeobj$nsymbols * (i64)18);
    header.nsymbols = aa_writeobj$nsymbols;
    offset += aa_writeobj$nextstringoffset;
    aa_writeobj$datastart = (aa_writeobj$dataptr = (byte *)malloc((u64)offset));
    aa_writeobj$writerecord(&header,(i64)20);
    aa_writeobj$writerecord(&zsection,(i64)40);
    aa_writeobj$writerecord(&isection,(i64)40);
    aa_writeobj$writerecord(&csection,(i64)40);
    aa_writeobj$writerelocs((struct aa_decls$relocrec *)aa_decls$ss_idatarelocs,aa_decls$ss_nidatarelocs);
    aa_writeobj$writerelocs((struct aa_decls$relocrec *)aa_decls$ss_coderelocs,aa_decls$ss_ncoderelocs);
    aa_writeobj$writedata((struct aa_decls$dbuffer *)aa_decls$ss_idata);
    aa_writeobj$writedata((struct aa_decls$dbuffer *)aa_decls$ss_code);
    aa_writeobj$writesymboltable();
    aa_writeobj$writestringtable();
    if (!!(aa_decls$fverbose)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Writing file:",NULL);
        msysc$m_print_str(outfile,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    mlib$writefile(outfile,aa_writeobj$datastart,(aa_writeobj$dataptr - aa_writeobj$datastart));
}

// START
void aa_writeobj$start(void) {

}

void msysc$m_init(i64 nargs,u8 *(*args)[],u8 *(*envstrings)[]) {
        i64 j;
        i64 i;
    msysc$nsysparams = nargs;
    if ((msysc$nsysparams > (i64)128)) {
        printf((byte*)"Too many params\n");
        exit((i64)1);
    }
;
    for (i=(i64)1;i<=nargs;++i) {
L1116 :;
        msysc$sysparams[(i)-1] = (*args)[(i)-1];
L1117 :;
    }
L1118 :;
    ;
    msysc$ncmdparams = (msysc$nsysparams - (msysc$$cmdskip + (i64)1));
    msysc$cmdparams = (u8 *(*)[])&msysc$sysparams[((msysc$$cmdskip + (i64)1))-1];
    j = (i64)1;
    msysc$nenvstrings = (i64)0;
}

i64 msysc$m_getdotindex(u64 a,i64 i) {
    return (((i64)a & ((i64)1 << i)) >> i);
}

u64 msysc$m_setdotindex(u64 a,i64 i,i64 x) {
    return (u64)(((i64)a & ~(((i64)1 << i))) | (i64)((u64)x << i));
}

i64 msysc$m_getdotslice(u64 a,i64 i,i64 j) {
    if ((i >= j)) {
        return (i64)((a >> j) & ~(((u64)18446744073709551615u << ((i - j) + (i64)1))));
    }
    else {
        return (i64)((a >> i) & ~(((u64)18446744073709551615u << ((j - i) + (i64)1))));
    }
;
}

u64 msysc$m_setdotslice(u64 a,i64 i,i64 j,u64 x) {
        u64 mask64;
    if ((i > j)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"SETDOTSLICE?",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)52);
    }
;
    mask64 = (~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i);
    return ((a & ~(mask64)) | (x << i));
}

i64 msysc$m_get_nprocs(void) {
    return msysc$_fnnprocs;
}

i64 msysc$m_get_nexports(void) {
    return msysc$_fnnexports;
}

u8 *msysc$m_get_procname(i64 n) {
    return msysc$_fnnames[(n)-1];
}

void *msysc$m_get_procaddr(i64 n) {
    return msysc$_fnaddresses[(n)-1];
}

void *msysc$m_get_procexport(i64 n) {
    return 0;
}

static void msysc$pushio(void) {
    if ((msysc$niostack >= (i64)10)) {
        printf((byte*)"Too many io levels\n");
        exit((i64)53);
    }
;
    ++(msysc$niostack);
    msysc$outchan_stack[(msysc$niostack)-1] = msysc$outchan;
    msysc$outdev_stack[(msysc$niostack)-1] = msysc$outdev;
    msysc$fmtstr_stack[(msysc$niostack)-1] = msysc$fmtstr;
    msysc$needgap_stack[(msysc$niostack)-1] = msysc$needgap;
    msysc$needgap = (i64)0;
    msysc$fmtstr = 0;
    msysc$outchan = 0;
}

void msysc$m_print_startfile(void *dev) {
    msysc$pushio();
    msysc$outchan = dev;
    if (!!(dev)) {
        msysc$outdev = (i64)2;
    }
    else {
        msysc$outdev = (i64)1;
    }
;
}

void msysc$m_print_startstr(u8 *s) {
        u8 **  p;
    msysc$pushio();
    msysc$ptr_stack[(msysc$niostack)-1] = s;
    p = &msysc$ptr_stack[(msysc$niostack)-1];
    msysc$outchan = p;
    msysc$outdev = (i64)3;
}

void msysc$m_print_startptr(u8 **p) {
    msysc$pushio();
    msysc$outchan = p;
    msysc$outdev = (i64)3;
}

void msysc$m_print_startcon(void) {
    msysc$pushio();
    msysc$outdev = (i64)1;
}

void msysc$m_print_setfmt(u8 *format) {
    msysc$fmtstr = format;
}

void msysc$m_print_end(void) {
    msysc$needgap = (i64)0;
    msysc$nextfmtchars((i64)1);
    if ((msysc$niostack == (i64)0)) {
        return;
    }
;
    msysc$outchan = msysc$outchan_stack[(msysc$niostack)-1];
    msysc$outdev = msysc$outdev_stack[(msysc$niostack)-1];
    msysc$fmtstr = msysc$fmtstr_stack[(msysc$niostack)-1];
    msysc$needgap = (i64)msysc$needgap_stack[(msysc$niostack)-1];
    --(msysc$niostack);
}

void msysc$m_print_ptr(void *a,u8 *fmtstyle) {
    msysc$nextfmtchars((i64)0);
    msysc$printstr(msysc$strword((u64)a,(byte*)"z8h"));
    msysc$needgap = (i64)1;
}

void msysc$m_print_i64(i64 a,u8 *fmtstyle) {
        u8 s[40];
        struct msysc$fmtrec fmt;
        i64 n;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        if ((a >= (i64)0)) {
            n = msysc$u64tostr((u64)a,(u8 *)s,(u64)10u,(i64)0);
        }
        else {
            s[((i64)1)-1] = '-';
            n = (msysc$u64tostr((u64)-(a),(u8 *)&s[((i64)2)-1],(u64)10u,(i64)0) + (i64)1);
        }
;
        msysc$printstr_n((u8 *)s,n);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        if (((u64)fmt.param == 'V')) {
            msysc$fmtparam = a;
            msysc$needgap = (i64)0;
        }
        else {
            msysc$tostr_i64(a,(struct msysc$fmtrec *)&fmt);
        }
;
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_u64(u64 a,u8 *fmtstyle) {
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysc$printstr(msysc$strword(a,0));
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_u64(a,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_r64(r64 x,u8 *fmtstyle) {
        u8 s[360];
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        sprintf((u8 *)s,(byte*)"%f",x);
        msysc$printstr((u8 *)s);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_r64(x,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_r32(r32 x,u8 *fmtstyle) {
    msysc$m_print_r64((r64)x,fmtstyle);
}

void msysc$m_print_c8(i64 a,u8 *fmtstyle) {
        u8 s[40];
    msysc$nextfmtchars((i64)0);
    s[((i64)1)-1] = (u64)a;
    s[((i64)2)-1] = (u64)0u;
    msysc$printstr((u8 *)s);
    msysc$needgap = (i64)1;
}

void msysc$m_print_str(u8 *s,u8 *fmtstyle) {
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysc$printstr(s);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_str(s,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_newline(void) {
    msysc$needgap = (i64)0;
    msysc$nextfmtchars((i64)1);
    msysc$printstr((byte*)"\r\n");
}

void msysc$m_print_nogap(void) {
    msysc$needgap = (i64)0;
}

void msysc$m_print_space(void) {
    msysc$needgap = (i64)0;
    msysc$printstr((byte*)" ");
}

void msysc$printstr(u8 *s) {
        u8 **  p;
    if ((msysc$outdev==(i64)1)) {
        printf((byte*)"%s",s);
    }
    else if ((msysc$outdev==(i64)2)) {
        fprintf(msysc$outchan,(byte*)"%s",s);
    }
    else if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        strcpy((*p),s);
        (*p) += strlen(s);
    }
;
}

void msysc$printstr_n(u8 *s,i64 n) {
        u8 str[256];
        u8 **  p;
    if ((n==(i64)-1)) {
        n = strlen(s);
    }
    else if ((n==(i64)0)) {
        return;
    }
;
    if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        memcpy((void *)(*p),(void *)s,(u64)n);
        (*p) += n;
        (*(*p)) = (u64)0u;
    }
    else if ((msysc$outdev==(i64)2)) {
        s = msysc$makezstring(s,n,(u8 *)str);
        fprintf(msysc$outchan,(byte*)"%s",s);
        msysc$freezstring(s,n);
    }
    else if ((msysc$outdev==(i64)1)) {
        s = msysc$makezstring(s,n,(u8 *)str);
        printf((byte*)"%s",s);
        msysc$freezstring(s,n);
    }
;
}

void msysc$printstrn_app(u8 *s,i64 length,void *f) {
    if (!!(length)) {
        if ((f == 0)) {
            printf((u8*)"%.*s",(i32)length,s);;
        }
        else {
            fprintf(f,(u8*)"%.*s",(i32)length,s);;
        }
;
    }
;
}

static u8 *msysc$makezstring(u8 *s,i64 n,u8 *local) {
        u8 *  t;
    if ((n < (i64)256)) {
        memcpy((void *)local,(void *)s,(u64)n);
        (*(local + n)) = (u64)0u;
        return local;
    }
    else {
        t = (u8 *)mlib$pcm_alloc((n + (i64)1));
        memcpy((void *)t,(void *)s,(u64)n);
        (*(t + n)) = (u64)0u;
        return t;
    }
;
}

static void msysc$freezstring(u8 *t,i64 n) {
    if ((n >= (i64)256)) {
        mlib$pcm_free((void *)t,(n + (i64)1));
    }
;
}

static void msysc$printchar(i64 ch) {
        u8 **  p;
    if ((msysc$outdev==(i64)1)) {
        printf((u8*)"%c",(int)ch);
    }
    else if ((msysc$outdev==(i64)2)) {
        fprintf(msysc$outchan,(u8*)"%c",(int)ch);
    }
    else if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        (*(*p)) = (u64)ch;
        (*p) += (i64)1;
        (*(*p)) = (u64)0u;
    }
;
}

void msysc$nextfmtchars(i64 lastx) {
        u8 c;
        u8 *  pstart;
        i64 n;
    if (!(!!(msysc$fmtstr))) {
        if (!!(msysc$needgap)) {
            msysc$printchar((i64)32);
        }
;
        msysc$needgap = (i64)0;
        return;
    }
;
    pstart = msysc$fmtstr;
    n = (i64)0;
    L1119 :;
    while (1) {
        c = (u64)(*msysc$fmtstr);
        switch ((i64)(u64)c) {
        case 35:;
            {
                if (!!(lastx)) {
                    goto L1121 ;
;
                }
;
                ++(msysc$fmtstr);
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                }
;
                return;
            }
            break;
        case 0:;
            {
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                }
                else if (!(!!(lastx))) {
                    msysc$printstr_n((byte*)"|",(i64)1);
                }
;
                return;
            }
            break;
        case 126:;
            {
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                    n = (i64)0;
                }
;
                ++(msysc$fmtstr);
                c = (u64)(*msysc$fmtstr);
                if (!!((u64)c)) {
                    ++(msysc$fmtstr);
                    msysc$printchar((i64)(u64)c);
                }
;
                pstart = msysc$fmtstr;
            }
            break;
        default: {
            //skip:
L1121 :;
;
            ++(n);
            ++(msysc$fmtstr);
        }
        } //SW
;
    }
L1120 :;
    ;
}

void msysc$strtofmt(u8 *s,i64 slen,struct msysc$fmtrec *fmt) {
        u8 c;
        byte wset;
        i64 n;
        u8 str[100];
    (*fmt) = msysc$defaultfmt;
    if ((s == 0)) {
        return;
    }
;
    if ((slen == (i64)-1)) {
        slen = strlen(s);
    }
;
    memcpy(str,(void *)s,(u64)slen);
    str[(slen)] = (u64)0u;
    s = (u8 *)str;
    wset = (i64)0;
    L1122 :;
    while (!!((u64)(*s))) {
        c = (u64)(*s);
        ++(s);
        switch ((i64)(u64)c) {
        case 66:;
        case 98:;
            {
                (*fmt).base = (i64)2;
            }
            break;
        case 72:;
        case 104:;
            {
                (*fmt).base = (i64)16;
            }
            break;
        case 79:;
        case 111:;
            {
                (*fmt).base = (i64)8;
            }
            break;
        case 88:;
        case 120:;
            {
                c = (u64)(*s);
                if (!!((u64)c)) {
                    switch ((i64)(u64)c) {
                    case 48:;
                    case 49:;
                    case 50:;
                    case 51:;
                    case 52:;
                    case 53:;
                    case 54:;
                    case 55:;
                    case 56:;
                    case 57:;
                        {
                            c = ((u64)c - '0');
                        }
                        break;
                    case 65:;
                    case 66:;
                    case 67:;
                    case 68:;
                    case 69:;
                    case 70:;
                        {
                            c = (u64)((i64)((u64)c - 'A') + (i64)10);
                        }
                        break;
                    case 97:;
                    case 98:;
                    case 99:;
                    case 100:;
                    case 101:;
                    case 102:;
                        {
                            c = (u64)((i64)((u64)c - 'a') + (i64)10);
                        }
                        break;
                    default: {
                        c = (u64)10u;
                    }
                    } //SW
;
                    (*fmt).base = (i64)(u64)c;
                    ++(s);
                }
;
            }
            break;
        case 81:;
        case 113:;
            {
                (*fmt).quotechar = '"';
            }
            break;
        case 126:;
            {
                (*fmt).quotechar = '~';
            }
            break;
        case 74:;
        case 106:;
            {
                (*fmt).justify = (u64)toupper((i32)(u64)(*s));
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 65:;
            {
                (*fmt).lettercase = 'A';
            }
            break;
        case 97:;
            {
                (*fmt).lettercase = 'a';
            }
            break;
        case 90:;
        case 122:;
            {
                (*fmt).padchar = '0';
            }
            break;
        case 83:;
        case 115:;
            {
                (*fmt).sepchar = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 80:;
        case 112:;
            {
                (*fmt).padchar = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 84:;
        case 116:;
            {
                (*fmt).suffix = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 87:;
        case 119:;
            {
                (*fmt).usigned = 'W';
            }
            break;
        case 69:;
        case 101:;
            {
                (*fmt).realfmt = 'e';
            }
            break;
        case 70:;
        case 102:;
            {
                (*fmt).realfmt = 'f';
            }
            break;
        case 71:;
        case 103:;
            {
                (*fmt).realfmt = 'g';
            }
            break;
        case 46:;
            {
                wset = (i64)1;
            }
            break;
        case 44:;
        case 95:;
            {
                (*fmt).sepchar = (u64)c;
            }
            break;
        case 43:;
            {
                (*fmt).plus = '+';
            }
            break;
        case 68:;
        case 100:;
            {
                (*fmt).charmode = 'D';
            }
            break;
        case 67:;
        case 99:;
            {
                (*fmt).charmode = 'C';
            }
            break;
        case 77:;
        case 109:;
            {
                (*fmt).heapmode = 'M';
            }
            break;
        case 86:;
        case 118:;
            {
                (*fmt).param = 'V';
            }
            break;
        case 42:;
            {
                n = msysc$fmtparam;
                goto L1125 ;
;
            }
            break;
        default: {
            if ((((u64)c >= '0') && ((u64)c <= '9'))) {
                n = (i64)((u64)c - '0');
                L1126 :;
                while (1) {
                    c = (u64)(*s);
                    if (((i64)(u64)(*s) == (i64)0)) {
                        goto L1127 ;
                    }
;
                    if ((((u64)c >= '0') && ((u64)c <= '9'))) {
                        ++(s);
                        n = (((n * (i64)10) + (i64)(u64)c) - (i64)48);
                    }
                    else {
                        goto L1127 ;
                    }
;
                }
L1127 :;
                ;
                //gotwidth:
L1125 :;
;
                if (!(!!((i64)wset))) {
                    (*fmt).minwidth = n;
                    wset = (i64)1;
                }
                else {
                    (*fmt).precision = n;
                }
;
            }
;
        }
        } //SW
;
L1123 :;
    }
L1124 :;
    ;
}

static i64 msysc$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt) {
        u8 str[20];
        u8 *  q;
        i64 nchars;
        i64 $av_1;
    q = (u8 *)str;
    nchars = n;
    $av_1 = n;
    while ($av_1-- > 0) {
L1128 :;
        if (((i64)(u64)(*p) == (i64)0)) {
            goto L1130 ;
        }
;
        (*q) = (u64)(*p);
        ++(q);
        ++(p);
L1129 :;
    }
L1130 :;
    ;
    (*q) = (u64)0u;
    return msysc$expandstr((u8 *)str,dest,strlen((u8 *)str),(struct msysc$fmtrec *)fmt);
}

static i64 msysc$expandstr(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt) {
        i64 i;
        i64 w;
        i64 m;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
        i64 $av_5;
    w = (i64)(*fmt).minwidth;
    if (((w == (i64)0) || (w <= n))) {
        strncpy(t,s,(u64)n);
        (*(t + n)) = (u64)0u;
        return n;
    }
;
    if (((u64)(*fmt).justify == 'L')) {
        strncpy(t,s,(u64)n);
        t += n;
                ($av_1 = (w - n));
        for (i=(i64)1;i<=$av_1;++i) {
L1131 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1132 :;
        }
L1133 :;
        ;
        (*t) = (u64)0u;
    }
    else if (((u64)(*fmt).justify == 'R')) {
        if (((((u64)(*fmt).padchar == '0') && !!((i64)(*fmt).base)) && (((u64)(*s) == '-') || ((u64)(*s) == '+')))) {
            (*t) = (u64)(*s);
            ++(t);
            $av_2 = (w - n);
            while ($av_2-- > 0) {
L1134 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L1135 :;
            }
L1136 :;
            ;
            strncpy(t,(s + (i64)1),(u64)(n - (i64)1));
            (*((t + n) - (i64)1)) = (u64)0u;
        }
        else {
            $av_3 = (w - n);
            while ($av_3-- > 0) {
L1137 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L1138 :;
            }
L1139 :;
            ;
            strncpy(t,s,(u64)n);
            (*(t + n)) = (u64)0u;
        }
;
    }
    else {
        m = (((w - n) + (i64)1) / (i64)2);
        $av_4 = m;
        while ($av_4-- > 0) {
L1140 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1141 :;
        }
L1142 :;
        ;
        strncpy(t,s,(u64)n);
        t += n;
        $av_5 = ((w - n) - m);
        while ($av_5-- > 0) {
L1143 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1144 :;
        }
L1145 :;
        ;
        (*t) = (u64)0u;
    }
;
    return w;
}

static i64 msysc$u64tostr(u64 aa,u8 *s,u64 base,i64 sep) {
        u8 t[360];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
        u8 *  s0;
    i = (i64)0;
    k = (i64)0;
    g = (((i64)base == (i64)10) ? (i64)3 : (i64)4);
    L1146 :;
    do {
        t[(++(i))] = (u64)msysc$digits[((i64)(aa % base))];
        aa = (aa / base);
        ++(k);
        if (((!!(sep) && ((i64)aa != (i64)0)) && (k == g))) {
            t[(++(i))] = (u64)sep;
            k = (i64)0;
        }
;
L1147 :;
    }
    while (!((i64)aa == (i64)0));
L1148 :;
    ;
    j = i;
    s0 = s;
    L1149 :;
    while (!!(i)) {
        (*s) = (u64)t[((i)--)];
        ++(s);
L1150 :;
    }
L1151 :;
    ;
    (*s) = (u64)0u;
    return j;
}

static i64 msysc$i64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        i64 usigned;
        static u64 mindint = (u64)9223372036854775808u;
    usigned = (i64)0;
    if (!!((u64)(*fmt).usigned)) {
        usigned = (i64)1;
    }
;
    if (((aa == (i64)mindint) && !(!!(usigned)))) {
        str[((i64)0)] = '-';
        n = (msysc$i64mintostr((u8 *)&str[((i64)1)],(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
    }
    else {
        if (((!(!!(usigned)) && (aa < (i64)0)) || !!((u64)(*fmt).plus))) {
            if ((aa < (i64)0)) {
                aa = -(aa);
                str[((i64)0)] = '-';
            }
            else {
                str[((i64)0)] = '+';
            }
;
            n = (msysc$u64tostr((u64)aa,(u8 *)&str[((i64)1)],(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
        }
        else {
            n = msysc$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
        }
;
    }
;
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if (((((i64)(*fmt).base > (i64)10) || !!((u64)(*fmt).suffix)) && ((u64)(*fmt).lettercase == 'a'))) {
        msysc$convlcstring((u8 *)str);
    }
;
    return msysc$expandstr((u8 *)str,s,n,(struct msysc$fmtrec *)fmt);
}

static i64 msysc$u64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
    n = msysc$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if ((((i64)(*fmt).base > (i64)10) || (!!((u64)(*fmt).suffix) && ((u64)(*fmt).lettercase == 'a')))) {
        msysc$convlcstring((u8 *)str);
    }
;
    return msysc$expandstr((u8 *)str,s,n,(struct msysc$fmtrec *)fmt);
}

static i64 msysc$i64mintostr(u8 *s,i64 base,i64 sep) {
        u8 t[360];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
    switch (base) {
    case 10:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"9223372036854775808");
            j = (i64)3;
        }
        break;
    case 16:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"8000000000000000");
            j = (i64)1;
        }
        break;
    case 2:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"1000000000000000000000000000000000000000000000000000000000000000");
            j = (i64)7;
        }
        break;
    default: {
        strcpy((u8 *)&t[((i64)0)],(byte*)"<mindint>");
    }
    } //SW
;
    i = strlen((u8 *)&t[((i64)0)]);
    s += i;
    if (!!(sep)) {
        s += j;
    }
;
    (*s) = (u64)0u;
    k = (i64)0;
    g = ((base == (i64)10) ? (i64)3 : (i64)4);
    L1152 :;
    while (!!(i)) {
        --(s);
        (*s) = (u64)t[(((i)-- - (i64)1))];
        if (((!!(sep) && !!(i)) && (++(k) == g))) {
            --(s);
            (*s) = (u64)sep;
            k = (i64)0;
        }
;
L1153 :;
    }
L1154 :;
    ;
    return strlen(s);
}

static i64 msysc$strtostrfmt(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt) {
        u8 *  u;
        u8 *  v;
        u8 str[256];
        i64 w;
        i64 nheap;
    nheap = (i64)0;
    if ((!!((u64)(*fmt).quotechar) || !!((u64)(*fmt).lettercase))) {
        if ((n < (i64)256)) {
            u = (u8 *)str;
        }
        else {
            nheap = (n + (i64)3);
            u = (u8 *)mlib$pcm_alloc(nheap);
        }
;
        if (!!((u64)(*fmt).quotechar)) {
            v = u;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            if (!!(n)) {
                strcpy(v,s);
                v += n;
            }
;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            (*v) = (u64)0u;
            n += (i64)2;
        }
        else {
            memcpy((void *)u,(void *)s,(u64)n);
        }
;
        switch ((i64)(u64)(*fmt).lettercase) {
        case 97:;
            {
                msysc$convlcstring(u);
            }
            break;
        case 65:;
            {
                msysc$convucstring(u);
            }
            break;
        } //SW
;
        s = u;
    }
;
    w = (i64)(*fmt).minwidth;
    if ((w > n)) {
        n = msysc$expandstr(s,t,n,(struct msysc$fmtrec *)fmt);
    }
    else {
        memcpy((void *)t,(void *)s,(u64)n);
    }
;
    if (!!(nheap)) {
        mlib$pcm_free((void *)u,nheap);
    }
;
    return n;
}

static void msysc$tostr_i64(i64 a,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp==(u64)0u)) {
        n = msysc$i64tostrfmt(a,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='D') || ($temp=='d')) {
        n = msysc$domultichar((u8 *)&a,(i64)8,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else {
        msysc$printchar(a);
        return;
    }
    };
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_u64(u64 a,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp=='D') || ($temp=='d')) {
        n = msysc$domultichar((u8 *)&a,(i64)8,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='C') || ($temp=='c')) {
        msysc$printchar((i64)a);
        return;
    }
    else {
        n = msysc$u64tostrfmt((i64)a,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    };
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_r64(r64 x,struct msysc$fmtrec *fmt) {
        u8 str[360];
        u8 str2[360];
        u8 cfmt[10];
        i64 n;
    cfmt[((i64)0)] = '%';
    if (!!((i64)(*fmt).precision)) {
        cfmt[((i64)1)] = '.';
        cfmt[((i64)2)] = '*';
        cfmt[((i64)3)] = (u64)(*fmt).realfmt;
        cfmt[((i64)4)] = (u64)0u;
        sprintf((u8 *)str,(u8 *)cfmt,(i64)(*fmt).precision,x);
    }
    else {
        cfmt[((i64)1)] = (u64)(*fmt).realfmt;
        cfmt[((i64)2)] = (u64)0u;
        sprintf((u8 *)str,(u8 *)cfmt,x);
    }
;
    n = strlen((u8 *)str);
    if ((n < (i64)(*fmt).minwidth)) {
        n = msysc$expandstr((u8 *)str,(u8 *)str2,n,(struct msysc$fmtrec *)fmt);
        strcpy((u8 *)str,(u8 *)str2);
    }
;
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_str(u8 *s,struct msysc$fmtrec *fmt) {
        i64 oldlen;
        i64 newlen;
        i64 n;
        u8 *  t;
    oldlen = strlen(s);
    newlen = oldlen;
    if (((!!((u64)(*fmt).quotechar) || ((i64)(*fmt).minwidth > newlen)) || !!((u64)(*fmt).lettercase))) {
        if (!!((u64)(*fmt).quotechar)) {
            newlen += (i64)2;
        }
;
        if (((i64)(*fmt).minwidth > newlen)) {
            newlen = (i64)(*fmt).minwidth;
        }
;
        t = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        n = msysc$strtostrfmt(s,t,oldlen,(struct msysc$fmtrec *)fmt);
        msysc$printstr_n(t,n);
        mlib$pcm_free((void *)t,(newlen + (i64)1));
    }
    else {
        msysc$printstr_n(s,oldlen);
    }
;
}

static struct msysc$fmtrec *msysc$getfmt(u8 *fmtstyle) {
        static struct msysc$fmtrec fmt;
    if (!!(fmtstyle)) {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        return (struct msysc$fmtrec *)&fmt;
    }
    else {
        return (struct msysc$fmtrec *)&msysc$defaultfmt;
    }
;
}

u8 *msysc$strint(i64 a,u8 *fmtstyle) {
        static u8 str[100];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_i64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

void msysc$getstrint(i64 a,u8 *dest) {
    msysc$m_print_startstr(dest);
    msysc$tostr_i64(a,(struct msysc$fmtrec *)msysc$getfmt(0));
    msysc$m_print_end();
}

u8 *msysc$strword(u64 a,u8 *fmtstyle) {
        static u8 str[100];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_u64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

u8 *msysc$strreal(r64 a,u8 *fmtstyle) {
        static u8 str[320];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_r64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

static u8 *msysc$getstr(u8 *s,struct msysc$fmtrec *fmt) {
    if (!!((u64)(*fmt).heapmode)) {
        return mlib$pcm_copyheapstring(s);
    }
    else {
        return s;
    }
;
}

static void msysc$initreadbuffer(void) {
    if (!!(msysc$rd_buffer)) {
        return;
    }
;
    msysc$rd_buffer = (u8 *)mlib$pcm_alloc((i64)16384);
    (*msysc$rd_buffer) = (u64)0u;
    msysc$rd_pos = (msysc$rd_lastpos = msysc$rd_buffer);
}

void msysc$m_read_conline(void) {
    msysc$initreadbuffer();
    mlib$readlinen(0,msysc$rd_buffer,(i64)16384);
    msysc$rd_length = strlen(msysc$rd_buffer);
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

void msysc$m_read_fileline(void *f) {
    msysc$initreadbuffer();
    mlib$readlinen(f,msysc$rd_buffer,(i64)16384);
    msysc$rd_length = strlen(msysc$rd_buffer);
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

void msysc$m_read_strline(u8 *s) {
        i64 n;
    msysc$initreadbuffer();
    n = strlen(s);
    if ((n < (i64)16384)) {
        strcpy(msysc$rd_buffer,s);
    }
    else {
        memcpy((void *)msysc$rd_buffer,(void *)s,(u64)16383u);
        (*((msysc$rd_buffer + (i64)16384) - (i64)1)) = (u64)0u;
    }
;
    msysc$rd_length = n;
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

static u8 *msysc$readitem(i64 *itemlength) {
        u8 *  p;
        u8 *  s;
        u8 *  itemstr;
        u8 quotechar;
        u8 c;
    if (!(!!(msysc$rd_buffer))) {
        msysc$initreadbuffer();
    }
;
    s = msysc$rd_pos;
    L1155 :;
    while ((((u64)(*s) == ' ') || ((i64)(u64)(*s) == (i64)9))) {
        ++(s);
L1156 :;
    }
L1157 :;
    ;
    itemstr = s;
    msysc$rd_lastpos = (msysc$rd_pos = s);
    if (((i64)(u64)(*s) == (i64)0)) {
        msysc$termchar = (i64)0;
        (*itemlength) = (i64)0;
        return s;
    }
;
    quotechar = (u64)0u;
    if (((u64)(*s) == '"')) {
        quotechar = '"';
        ++(s);
    }
    else if (((u64)(*s) == (u64)39u)) {
        quotechar = (u64)39u;
        ++(s);
    }
;
    p = (itemstr = s);
    L1158 :;
    while (!!((u64)(*s))) {
        c = (u64)(*(s)++);
        switch ((i64)(u64)c) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
            {
                if ((!!((u64)quotechar) || (p == s))) {
                    goto L1161 ;
;
                }
;
                msysc$termchar = (i64)(u64)c;
                goto L1160 ;
            }
            break;
        default: {
            //normalchar:
L1161 :;
;
            if (((u64)c == (u64)quotechar)) {
                if (((u64)(*s) == (u64)quotechar)) {
                    (*p) = (u64)c;
                    ++(s);
                    ++(p);
                }
                else {
                    msysc$termchar = (i64)(u64)(*s);
                    if (((msysc$termchar == (i64)44) || (msysc$termchar == (i64)61))) {
                        ++(s);
                        msysc$termchar = (i64)(u64)(*s);
                    }
;
                    goto L1160 ;
                }
;
            }
            else {
                (*p) = (u64)c;
                ++(p);
            }
;
        }
        } //SW
;
L1159 :;
    }
L1160 :;
    ;
    if (((i64)(u64)(*s) == (i64)0)) {
        msysc$termchar = (i64)0;
    }
;
    (*itemlength) = (p - itemstr);
    msysc$rd_pos = s;
    return itemstr;
}

i64 msysc$strtoint(u8 *s,i64 length,i64 base) {
        byte signd;
        u64 aa;
        u8 c;
        u8 d;
    msysc$itemerror = (i64)0;
    if ((length == (i64)-1)) {
        length = strlen(s);
    }
;
    signd = (i64)0;
    if ((!!(length) && ((u64)(*s) == '-'))) {
        signd = (i64)1;
        ++(s);
        --(length);
    }
    else if ((!!(length) && ((u64)(*s) == '+'))) {
        ++(s);
        --(length);
    }
;
    aa = (u64)0u;
    L1162 :;
    while (!!(length)) {
        c = (u64)(*(s)++);
        --(length);
        switch ((i64)(u64)c) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
            {
                d = (u64)((i64)((u64)c - 'A') + (i64)10);
            }
            break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
            {
                d = (u64)((i64)((u64)c - 'a') + (i64)10);
            }
            break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                d = ((u64)c - '0');
            }
            break;
        case 95:;
        case 39:;
            {
                goto L1163 ;
            }
            break;
        default: {
            msysc$itemerror = (i64)1;
            goto L1164 ;
        }
        } //SW
;
        if (((i64)(u64)d >= base)) {
            msysc$itemerror = (i64)1;
            goto L1164 ;
        }
;
        aa = (u64)(((i64)aa * base) + (i64)(u64)d);
L1163 :;
    }
L1164 :;
    ;
    if (!!((i64)signd)) {
        return (i64)-(aa);
    }
    else {
        return (i64)aa;
    }
;
}

i64 msysc$m_read_i64(i64 fmt) {
        u8 *  s;
        i64 length;
    if ((fmt==(i64)67) || (fmt==(i64)99)) {
        msysc$rd_lastpos = msysc$rd_pos;
        if (!!((u64)(*msysc$rd_pos))) {
            return (i64)(u64)(*(msysc$rd_pos)++);
        }
        else {
            return (i64)0;
        }
;
    }
    else if ((fmt==(i64)84) || (fmt==(i64)116)) {
        return msysc$termchar;
    }
    else if ((fmt==(i64)69) || (fmt==(i64)101)) {
        return msysc$itemerror;
    }
;
    s = msysc$readitem(&length);
    if ((fmt==(i64)0) || (fmt==(i64)73) || (fmt==(i64)105)) {
        return msysc$strtoint(s,length,(i64)10);
    }
    else if ((fmt==(i64)66) || (fmt==(i64)98)) {
        return msysc$strtoint(s,length,(i64)2);
    }
    else if ((fmt==(i64)72) || (fmt==(i64)104)) {
        return msysc$strtoint(s,length,(i64)16);
    }
;
    return (i64)0;
}

r64 msysc$m_read_r64(i64 fmt) {
        u8 str[512];
        u8 *  s;
        i64 length;
        i32 numlength;
        r64 x;
    s = msysc$readitem(&length);
    if (((length == (i64)0) || (length >= (i64)512))) {
        return (double)0.;
    }
;
    memcpy(str,(void *)s,(u64)length);
    str[((length + (i64)1))-1] = (u64)0u;
    msysc$itemerror = (i64)0;
    if (((sscanf((u8 *)str,(byte*)"%lf%n",&x,&numlength) == (i64)0) || ((i64)numlength != length))) {
        x = (double)0.;
        msysc$itemerror = (i64)1;
    }
;
    return x;
}

void msysc$m_read_str(u8 *dest,i64 destlen,i64 fmt) {
        u8 *  s;
        i64 length;
    msysc$itemerror = (i64)0;
    if (((fmt == (i64)76) || (fmt == (i64)108))) {
        s = msysc$rd_pos;
        length = ((msysc$rd_buffer + msysc$rd_length) - msysc$rd_pos);
    }
    else {
        s = msysc$readitem(&length);
        if (((fmt == (i64)78) || (fmt == (i64)110))) {
            msysc$iconvlcn(s,length);
        }
;
    }
;
    if ((destlen > (i64)0)) {
        if ((length >= destlen)) {
            length = (destlen - (i64)1);
            msysc$itemerror = (i64)1;
        }
;
    }
;
    memcpy((void *)dest,(void *)s,(u64)length);
    (*(dest + length)) = (u64)0u;
}

void msysc$readstr(u8 *dest,i64 fmt,i64 destlen) {
    msysc$m_read_str(dest,destlen,fmt);
}

void msysc$rereadln(void) {
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = msysc$rd_pos;
}

void msysc$reread(void) {
    msysc$rd_pos = msysc$rd_lastpos;
}

i64 msysc$valint(u8 *s,i64 fmt) {
        u8 *  old_pos;
        u8 *  old_lastpos;
        i64 aa;
    msysc$initreadbuffer();
    old_pos = msysc$rd_pos;
    old_lastpos = msysc$rd_lastpos;
    msysc$rd_pos = s;
    aa = msysc$m_read_i64(fmt);
    msysc$rd_pos = old_pos;
    msysc$rd_lastpos = old_lastpos;
    return aa;
}

r64 msysc$valreal(u8 *s) {
        u8 *  old_pos;
        u8 *  old_lastpos;
        r64 x;
    msysc$initreadbuffer();
    old_pos = msysc$rd_pos;
    old_lastpos = msysc$rd_lastpos;
    msysc$rd_pos = s;
    x = msysc$m_read_r64((i64)0);
    msysc$rd_pos = old_pos;
    msysc$rd_lastpos = old_lastpos;
    return x;
}

static void msysc$iconvlcn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1165 :;
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1166 :;
    }
L1167 :;
    ;
}

static void msysc$iconvucn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1168 :;
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1169 :;
    }
L1170 :;
    ;
}

static void msysc$convlcstring(u8 *s) {
    L1171 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1172 :;
    }
L1173 :;
    ;
}

static void msysc$convucstring(u8 *s) {
    L1174 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1175 :;
    }
L1176 :;
    ;
}

i64 msysc$m_power_i64(i64 n,i64 a) {
    if ((n < (i64)0)) {
        return (i64)0;
    }
    else if ((n == (i64)0)) {
        return (i64)1;
    }
    else if ((n == (i64)1)) {
        return a;
    }
    else if (((n & (i64)1) == (i64)0)) {
        return msysc$m_power_i64((n / (i64)2),(a*a));
    }
    else {
        return (msysc$m_power_i64(((n - (i64)1) / (i64)2),(a*a)) * a);
    }
;
}

void msysc$m_intoverflow(void) {
    mlib$abortprogram((byte*)"Integer overflow detected");
}

void msysc$m_dotindex(u64 i,u64 a) {
    mlib$abortprogram((byte*)"DOT INDEX");
}

void msysc$m_dotslice(u64 j,u64 i,u64 a) {
    mlib$abortprogram((byte*)"DOT SLICE");
}

void msysc$m_popdotindex(u64 i,u64 *p,u64 x) {
    mlib$abortprogram((byte*)"POP DOT INDEX");
}

void msysc$m_popdotslice(u64 j,u64 i,u64 *p,u64 x) {
    mlib$abortprogram((byte*)"POP DOT SLICE");
}

i64 msysc$m_imin(i64 a,i64 b) {
    return (a<b?a:b);
}

i64 msysc$m_imax(i64 a,i64 b) {
    return (a>b?a:b);
}

r64 msysc$m_sign(r64 x) {
    if ((x > (double)0.)) {
        return (double)1.;
    }
    else if ((x < (double)0.)) {
        return (double)-1.;
    }
    else {
        return (double)0.;
    }
;
}

r64 msysc$m_tp_i64tor64(i64 a) {
        r64 x;
    memcpy(&x,&a,(u64)8u);
    return x;
}

i64 msysc$m_tp_r64toi64(r64 x) {
        i64 a;
    memcpy(&a,&x,(u64)8u);
    return a;
}

i64 msysc$m_tp_reftoi64(void *p) {
        i64 a;
    memcpy(&a,&p,(u64)8u);
    return a;
}

void *msysc$m_tp_i64toref(i64 a) {
        void *  p;
    memcpy(&p,&a,(u64)8u);
    return p;
}

// START
void msysc$start(void) {
    mlib$start();
    mclib$start();
    mwindows$start();
    mwindllc$start();

}

void *mlib$pcm_alloc(i64 n) {
        byte *  p;
    if (!(!!((i64)mlib$pcm_setup))) {
        mlib$pcm_init();
    }
;
    if ((n > (i64)2048)) {
        mlib$alloccode = mlib$pcm_getac(n);
        mlib$allocbytes = (i64)mlib$allocupper[(mlib$alloccode)];
        p = (byte *)mlib$allocmem(mlib$allocbytes);
        if (!(!!(p))) {
            mlib$abortprogram((byte*)"pcm_alloc failure");
        }
;
        return p;
    }
;
    mlib$alloccode = (i64)mlib$sizeindextable[(n)];
    mlib$allocbytes = (i64)mlib$allocupper[(mlib$alloccode)];
    mlib$smallmemtotal += mlib$allocbytes;
    if (!!((p = (byte *)mlib$freelist[(mlib$alloccode)]))) {
        mlib$freelist[(mlib$alloccode)] = (u64 *)(i64)(*mlib$freelist[(mlib$alloccode)]);
        return p;
    }
;
    p = mlib$pcheapptr;
    mlib$pcheapptr += mlib$allocbytes;
    if ((mlib$pcheapptr >= mlib$pcheapend)) {
        p = (byte *)mlib$pcm_newblock(mlib$allocbytes);
        return p;
    }
;
    return p;
}

void mlib$pcm_free(void *p,i64 n) {
        i64 acode;
    if ((n == (i64)0)) {
        return;
    }
;
    if ((n > (i64)2048)) {
        mlib$memtotal -= n;
        free(p);
        return;
    }
;
    if (!!(p)) {
        acode = (i64)mlib$sizeindextable[(n)];
        mlib$smallmemtotal -= (i64)mlib$allocupper[(acode)];
        (*(u64 *)p) = (u64)(i64)mlib$freelist[(acode)];
        mlib$freelist[(acode)] = (u64 *)p;
    }
;
}

void mlib$pcm_freeac(void *p,i64 alloc) {
    mlib$pcm_free(p,(i64)mlib$allocupper[(alloc)]);
}

void mlib$pcm_clearmem(void *p,i64 n) {
    memset(p,(i32)(i64)0,(u64)n);
}

void mlib$pcm_init(void) {
        i64 j;
        i64 k;
        i64 size;
        i64 i;
    mlib$alloccode = (i64)0;
    if (!!((i64)mlib$pcm_setup)) {
        return;
    }
;
    mlib$pcm_newblock((i64)0);
    for (i=(i64)1;i<=(i64)2048;++i) {
L1177 :;
        j = (i64)1;
        k = (i64)16;
        L1180 :;
        while ((i > k)) {
            k = (k << (i64)1);
            ++(j);
L1181 :;
        }
L1182 :;
        ;
        mlib$sizeindextable[(i)] = j;
L1178 :;
    }
L1179 :;
    ;
    mlib$allocupper[((i64)1)] = (u64)16u;
    size = (i64)16;
    for (i=(i64)2;i<=(i64)27;++i) {
L1183 :;
        size *= (i64)2;
        mlib$allocupper[(i)] = (u64)size;
        if ((size >= (i64)33554432)) {
            k = i;
            goto L1185 ;
        }
;
L1184 :;
    }
L1185 :;
    ;
    for (i=(k + (i64)1);i<=(i64)300;++i) {
L1186 :;
        size += (i64)33554432;
        if ((size < (i64)8589934592)) {
            mlib$allocupper[(i)] = (u64)size;
            mlib$maxmemory = (u64)size;
        }
        else {
            mlib$maxalloccode = (i - (i64)1);
            goto L1188 ;
        }
;
L1187 :;
    }
L1188 :;
    ;
    mlib$pcm_setup = (i64)1;
}

i64 mlib$pcm_getac(i64 size) {
    if ((size <= (i64)2048)) {
        return (i64)mlib$sizeindextable[(size)];
    }
;
    size = ((size + (i64)255) >> (i64)8);
    if ((size <= (i64)2048)) {
        return ((i64)mlib$sizeindextable[(size)] + (i64)8);
    }
;
    size = ((size + (i64)63) >> (i64)6);
    if ((size <= (i64)2048)) {
        return ((i64)mlib$sizeindextable[(size)] + (i64)14);
    }
;
    size = ((((size - (i64)2048) + (i64)2047) / (i64)2048) + (i64)22);
    return size;
}

void *mlib$pcm_newblock(i64 itemsize) {
        static i64 totalheapsize;
        byte *  p;
    totalheapsize += (i64)2097152;
    mlib$alloccode = (i64)0;
    p = (byte *)mlib$allocmem((i64)2097152);
    if ((p == 0)) {
        mlib$abortprogram((byte*)"Can't alloc pc heap");
    }
;
    memset(p,(i32)(i64)0,(u64)2097152u);
    mlib$pcheapptr = p;
    mlib$pcheapend = (p + (i64)2097152);
    if ((mlib$pcheapstart == 0)) {
        mlib$pcheapstart = p;
    }
;
    mlib$pcheapptr += itemsize;
    return (u32 *)p;
}

i64 mlib$pcm_round(i64 n) {
        static i32 allocbytes[9] = {(i32)(i64)0,(i32)(i64)16,(i32)(i64)32,(i32)(i64)64,(i32)(i64)128,(i32)(i64)256,(i32)(i64)512,(i32)(i64)1024,(i32)(i64)2048};
    if ((n > (i64)2048)) {
        return n;
    }
    else {
        return (i64)allocbytes[((i64)mlib$sizeindextable[(n)])];
    }
;
}

void *mlib$pcm_allocz(i64 n) {
        void *  p;
    p = mlib$pcm_alloc(n);
    memset(p,(i32)(i64)0,(u64)n);
    return p;
}

u8 *mlib$pcm_copyheapstring(u8 *s) {
        u8 *  q;
        i64 n;
    if ((s == 0)) {
        return 0;
    }
;
    n = (strlen(s) + (i64)1);
    q = (u8 *)mlib$pcm_alloc(n);
    memcpy((void *)q,(void *)s,(u64)n);
    return q;
}

u8 *mlib$pcm_copyheapstringn(u8 *s,i64 n) {
        u8 *  q;
    if ((s == 0)) {
        return 0;
    }
;
    q = (u8 *)mlib$pcm_alloc((n + (i64)1));
    memcpy((void *)q,(void *)s,(u64)n);
    (*(q + n)) = (u64)0u;
    return q;
}

u8 *mlib$pcm_copyheapblock(u8 *s,i64 length) {
        u8 *  q;
    if ((length == (i64)0)) {
        return 0;
    }
;
    q = (u8 *)mlib$pcm_alloc(length);
    memcpy((void *)q,(void *)s,(u64)length);
    return q;
}

void *mlib$allocmem(i64 n) {
        void *  p;
    p = malloc((u64)n);
    if (!!(p)) {
        mlib$memtotal += n;
        return p;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_i64(mlib$memtotal,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$abortprogram((byte*)"Alloc mem failure");
    return 0;
}

void *mlib$reallocmem(void *p,i64 n) {
    p = realloc(p,(u64)n);
    if (!!(p)) {
        return p;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$abortprogram((byte*)"Realloc mem failure");
    return 0;
}

void mlib$abortprogram(u8 *s) {
    msysc$m_print_startcon();
    msysc$m_print_str(s,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"ABORTING: Press key...",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)5);
}

i64 mlib$getfilesize(void *handlex) {
        u32 p;
        u32 size;
    p = ftell(handlex);
    fseek(handlex,(i32)(i64)0,(i32)(i64)2);
    size = ftell(handlex);
    fseek(handlex,(i32)(i64)p,(i32)(i64)0);
    return (i64)size;
}

void mlib$readrandom(void *handlex,byte *mem,i64 offset,i64 size) {
        i64 a;
    fseek(handlex,(i32)offset,(i32)(i64)0);
    a = (i64)fread(mem,(u64)1u,(u64)size,handlex);
}

i64 mlib$writerandom(void *handlex,byte *mem,i64 offset,i64 size) {
    fseek(handlex,(i32)offset,(i32)(i64)0);
    return (i64)fwrite(mem,(u64)1u,(u64)size,handlex);
}

i64 mlib$setfilepos(void *file,i64 offset) {
    return fseek(file,(i32)offset,(i32)(i64)0);
}

i64 mlib$getfilepos(void *file) {
    return ftell(file);
}

byte *mlib$readfile(u8 *filename) {
        void *  f;
        i64 size;
        byte *  m;
        byte *  p;
    f = fopen(filename,(byte*)"rb");
    if ((f == 0)) {
        return 0;
    }
;
    mlib$rfsize = (size = mlib$getfilesize(f));
    m = (byte *)mlib$pcm_alloc((size + (i64)2));
    if ((m == 0)) {
        return 0;
    }
;
    mlib$readrandom(f,m,(i64)0,size);
    p = (m + size);
    (*(u16 *)p) = (i64)0;
    fclose(f);
    return m;
}

i64 mlib$writefile(u8 *filename,byte *data,i64 size) {
        void *  f;
        i64 n;
    f = fopen(filename,(byte*)"wb");
    if ((f == 0)) {
        return (i64)0;
    }
;
    n = mlib$writerandom(f,data,(i64)0,size);
    fclose(f);
    return n;
}

i64 mlib$checkfile(u8 *file) {
        void *  f;
    if (!!((f = fopen(file,(byte*)"rb")))) {
        fclose(f);
        return (i64)1;
    }
;
    return (i64)0;
}

void mlib$readlinen(void *handlex,u8 *buffer,i64 size) {
        i64 ch;
        u8 *  p;
        i64 n;
        byte crseen;
    if ((handlex == 0)) {
        handlex = mwindows$os_getstdin();
    }
;
    if ((handlex == 0)) {
        n = (i64)0;
        p = buffer;
        L1189 :;
        while (1) {
            ch = getchar();
            if ((((ch == (i64)13) || (ch == (i64)10)) || (ch == (i64)-1))) {
                (*p) = (u64)0u;
                return;
            }
;
            (*(p)++) = (u64)ch;
            ++(n);
            if ((n >= (size - (i64)2))) {
                (*p) = (u64)0u;
                return;
            }
;
        }
L1190 :;
        ;
    }
;
    (*buffer) = (u64)0u;
    if ((fgets(buffer,(size - (i64)2),handlex) == 0)) {
        return;
    }
;
    n = strlen(buffer);
    if ((n == (i64)0)) {
        return;
    }
;
    p = ((buffer + n) - (i64)1);
    crseen = (i64)0;
    L1191 :;
    while (((p >= buffer) && (((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10)))) {
        if ((((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10))) {
            crseen = (i64)1;
        }
;
        (*(p)--) = (u64)0u;
L1192 :;
    }
L1193 :;
    ;
    if ((!(!!((i64)crseen)) && ((n + (i64)4) > size))) {
        msysc$m_print_startcon();
        msysc$m_print_i64(size,NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mlib$abortprogram((byte*)"line too long");
    }
;
}

void mlib$iconvlcn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1194 :;
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1195 :;
    }
L1196 :;
    ;
}

void mlib$iconvucn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1197 :;
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1198 :;
    }
L1199 :;
    ;
}

u8 *mlib$convlcstring(u8 *s) {
        u8 *  s0;
    s0 = s;
    L1200 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1201 :;
    }
L1202 :;
    ;
    return s0;
}

u8 *mlib$convucstring(u8 *s) {
        u8 *  s0;
    s0 = s;
    L1203 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1204 :;
    }
L1205 :;
    ;
    return s0;
}

u8 *mlib$changeext(u8 *s,u8 *newext) {
        static u8 newfile[260];
        u8 newext2[32];
        u8 *  sext;
        i64 n;
    strcpy((u8 *)&newfile[((i64)1)-1],s);
        {u64 $temp = (u64)(*newext);
if (($temp==(u64)0u)) {
        newext2[((i64)1)-1] = (u64)0u;
        newext2[((i64)2)-1] = (u64)0u;
    }
    else if (($temp=='.')) {
        strcpy((u8 *)&newext2[((i64)1)-1],newext);
    }
    else {
        strcpy((u8 *)&newext2[((i64)1)-1],(byte*)".");
        strcat((u8 *)&newext2[((i64)1)-1],newext);
    }
    };
    sext = mlib$extractext(s,(i64)1);
        {u64 $temp = (u64)(*sext);
if (($temp==(u64)0u)) {
        strcat((u8 *)&newfile[((i64)1)-1],(u8 *)&newext2[((i64)1)-1]);
    }
    else if (($temp=='.')) {
        strcat((u8 *)&newfile[((i64)1)-1],(u8 *)&newext2[((i64)2)-1]);
    }
    else {
        n = ((sext - s) - (i64)2);
        strcpy((u8 *)((&newfile[((i64)1)-1] + n) + (i64)1),(u8 *)&newext2[((i64)1)-1]);
    }
    };
    return (u8 *)&newfile[((i64)1)-1];
}

u8 *mlib$extractext(u8 *s,i64 period) {
        u8 *  t;
        u8 *  u;
    t = mlib$extractfile(s);
    if (((i64)(u64)(*t) == (i64)0)) {
        return (byte*)"";
    }
;
    u = ((t + strlen(t)) - (i64)1);
    L1206 :;
    while ((u >= t)) {
        if (((u64)(*u) == '.')) {
            if (((i64)(u64)(*(u + (i64)1)) == (i64)0)) {
                return (!!(period) ? (byte*)"." : (byte*)"");
            }
;
            return (u + (i64)1);
        }
;
        --(u);
L1207 :;
    }
L1208 :;
    ;
    return (byte*)"";
}

u8 *mlib$extractpath(u8 *s) {
        static u8 str[260];
        u8 *  t;
        i64 n;
    t = ((s + strlen(s)) - (i64)1);
    L1209 :;
    while ((t >= s)) {
        switch ((i64)(u64)(*t)) {
        case 92:;
        case 47:;
        case 58:;
            {
                n = ((t - s) + (i64)1);
                memcpy(str,(void *)s,(u64)n);
                str[(n)] = (u64)0u;
                return (u8 *)str;
            }
            break;
        } //SW
;
        --(t);
L1210 :;
    }
L1211 :;
    ;
    return (byte*)"";
}

u8 *mlib$extractfile(u8 *s) {
        u8 *  t;
    t = mlib$extractpath(s);
    if (((i64)(u64)(*t) == (i64)0)) {
        return s;
    }
;
    return (s + strlen(t));
}

u8 *mlib$extractbasefile(u8 *s) {
        static u8 str[100];
        u8 *  f;
        u8 *  e;
        i64 n;
        i64 flen;
    f = mlib$extractfile(s);
    flen = strlen(f);
    if ((flen == (i64)0)) {
        return (byte*)"";
    }
;
    e = mlib$extractext(f,(i64)0);
    if (!!((u64)(*e))) {
        n = ((flen - strlen(e)) - (i64)1);
        memcpy(&str,(void *)f,(u64)n);
        str[(n)] = (u64)0u;
        return (u8 *)str;
    }
;
    if (((u64)(*((f + flen) - (i64)1)) == '.')) {
        memcpy(&str,(void *)f,(u64)(flen - (i64)1));
        str[((flen - (i64)1))] = (u64)0u;
        return (u8 *)str;
    }
;
    return f;
}

u8 *mlib$addext(u8 *s,u8 *newext) {
        u8 *  sext;
    sext = mlib$extractext(s,(i64)1);
    if (((i64)(u64)(*sext) == (i64)0)) {
        return mlib$changeext(s,newext);
    }
;
    return s;
}

void *mlib$pcm_alloc32(void) {
        byte *  p;
    mlib$allocbytes = (i64)32;
    mlib$smallmemtotal += (i64)32;
    if (!!((p = (byte *)mlib$freelist[((i64)2)]))) {
        mlib$freelist[((i64)2)] = (u64 *)(i64)(*mlib$freelist[((i64)2)]);
        return p;
    }
;
    return mlib$pcm_alloc((i64)32);
}

void mlib$pcm_free32(void *p) {
    mlib$smallmemtotal -= (i64)32;
    (*(u64 *)p) = (u64)(i64)mlib$freelist[((i64)2)];
    mlib$freelist[((i64)2)] = (u64 *)p;
}

void mlib$outbyte(void *f,i64 x) {
    fwrite(&x,(u64)1u,(u64)1u,f);
}

void mlib$outword16(void *f,u64 x) {
    fwrite(&x,(u64)2u,(u64)1u,f);
}

void mlib$outword32(void *f,u64 x) {
    fwrite(&x,(u64)4u,(u64)1u,f);
}

void mlib$outword64(void *f,u64 x) {
    fwrite(&x,(u64)8u,(u64)1u,f);
}

void mlib$outstring(void *f,u8 *s) {
    fwrite((void *)s,(u64)(strlen(s) + (i64)1),(u64)1u,f);
}

void mlib$outblock(void *f,void *p,i64 n) {
    fwrite(p,(u64)n,(u64)1u,f);
}

i64 mlib$myeof(void *f) {
        i64 c;
    c = fgetc(f);
    if ((c == (i64)-1)) {
        return (i64)1;
    }
;
    ungetc((i32)c,f);
    return (i64)0;
}

void mlib$strbuffer_add(struct mlib$strbuffer *dest,u8 *s,i64 n) {
        i64 newlen;
        i64 oldlen;
        u8 *  newptr;
    if ((n == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=0",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((n == (i64)-1)) {
        n = strlen(s);
    }
;
    oldlen = (i64)(*dest).length;
    if ((oldlen == (i64)0)) {
        (*dest).strptr = (u8 *)mlib$pcm_alloc((n + (i64)1));
        (*dest).allocated = mlib$allocbytes;
        (*dest).length = n;
        memcpy((void *)(*dest).strptr,(void *)s,(u64)n);
        (*((*dest).strptr + n)) = (u64)0u;
        return;
    }
;
    newlen = (oldlen + n);
    if (((newlen + (i64)1) > (i64)(*dest).allocated)) {
        newptr = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        memcpy((void *)newptr,(void *)(*dest).strptr,(u64)oldlen);
        (*dest).strptr = newptr;
        (*dest).allocated = mlib$allocbytes;
    }
;
    memcpy((void *)((*dest).strptr + oldlen),(void *)s,(u64)n);
    (*((*dest).strptr + newlen)) = (u64)0u;
    (*dest).length = newlen;
}

void mlib$gs_init(struct mlib$strbuffer *dest) {
    mlib$pcm_clearmem(dest,(i64)16);
}

void mlib$gs_free(struct mlib$strbuffer *dest) {
    if (!!((i64)(*dest).allocated)) {
        mlib$pcm_free((void *)(*dest).strptr,(i64)(*dest).allocated);
    }
;
}

void mlib$gs_str(struct mlib$strbuffer *dest,u8 *s) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,(i64)-1);
}

void mlib$gs_char(struct mlib$strbuffer *dest,i64 c) {
        u8 s[16];
    s[((i64)1)-1] = (u64)c;
    s[((i64)2)-1] = (u64)0u;
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(u8 *)s,(i64)1);
}

void mlib$gs_strn(struct mlib$strbuffer *dest,u8 *s,i64 length) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,length);
}

void mlib$gs_strvar(struct mlib$strbuffer *dest,struct mlib$strbuffer *s) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(*s).strptr,(i64)-1);
}

void mlib$gs_strint(struct mlib$strbuffer *dest,i64 a) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,msysc$strint(a,0),(i64)-1);
}

void mlib$gs_strln(struct mlib$strbuffer *dest,u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)dest,s);
    mlib$gs_line((struct mlib$strbuffer *)dest);
}

void mlib$gs_strsp(struct mlib$strbuffer *dest,u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)dest,s);
    mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)" ");
}

void mlib$gs_line(struct mlib$strbuffer *dest) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(byte*)"\r\n",(i64)-1);
}

i64 mlib$gs_getcol(struct mlib$strbuffer *dest) {
    return (i64)(*dest).length;
}

void mlib$gs_leftstr(struct mlib$strbuffer *dest,u8 *s,i64 w,i64 padch) {
        i64 col;
        i64 i;
        i64 n;
        i64 slen;
        u8 str[2560];
    col = (i64)(*dest).length;
    strcpy((u8 *)str,s);
    slen = strlen(s);
    n = (w - slen);
    if ((n > (i64)0)) {
        for (i=(i64)1;i<=n;++i) {
L1212 :;
            str[((slen + i))-1] = (u64)padch;
L1213 :;
        }
L1214 :;
        ;
        str[(((slen + n) + (i64)1))-1] = (u64)0u;
    }
;
    mlib$gs_str((struct mlib$strbuffer *)dest,(u8 *)str);
}

void mlib$gs_leftint(struct mlib$strbuffer *dest,i64 a,i64 w,i64 padch) {
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,msysc$strint(a,0),w,padch);
}

void mlib$gs_padto(struct mlib$strbuffer *dest,i64 col,i64 ch) {
        i64 n;
        u8 str[2560];
        i64 i;
    n = (col - (i64)(*dest).length);
    if ((n <= (i64)0)) {
        return;
    }
;
    for (i=(i64)1;i<=n;++i) {
L1215 :;
        str[(i)-1] = (u64)ch;
L1216 :;
    }
L1217 :;
    ;
    str[((n + (i64)1))-1] = (u64)0u;
    mlib$gs_str((struct mlib$strbuffer *)dest,(u8 *)str);
}

void mlib$gs_println(struct mlib$strbuffer *dest,void *f) {
    if (((i64)(*dest).length == (i64)0)) {
        return;
    }
;
    (*((*dest).strptr + (i64)(*dest).length)) = (u64)0u;
    if ((f == 0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((*dest).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startfile(f);
        msysc$m_print_str((*dest).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

i64 mlib$nextcmdparamnew(i64 *paramno,u8 **name,u8 **value,u8 *defext) {
        static i64 infile = (i64)0;
        static u8 *  filestart = 0;
        static u8 *  fileptr = 0;
        static byte colonseen = (byte)(i64)0;
        u8 *  q;
        u8 *  item;
        u8 *  fileext;
        static i64 atsize;
        static u8 str[300];
    //reenter:
L1218 :;
;
    (*value) = 0;
    (*name) = 0;
    if (!!(infile)) {
        if ((mlib$readnextfileitem(&fileptr,&item) == (i64)0)) {
            mlib$pcm_free((void *)filestart,atsize);
            infile = (i64)0;
            goto L1218 ;
;
        }
;
    }
    else {
        if (((*paramno) > msysc$ncmdparams)) {
            return (i64)0;
        }
;
        item = (*msysc$cmdparams)[((*paramno))];
        ++((*paramno));
        if (((u64)(*item) == '@')) {
            if (!!(infile)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Nested @",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)1);
            }
;
            filestart = (fileptr = (u8 *)mlib$readfile((item + (i64)1)));
            if ((filestart == 0)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Can't open",NULL);
                msysc$m_print_str(item,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)7);
            }
;
            infile = (i64)1;
            atsize = mlib$allocbytes;
            goto L1218 ;
;
        }
;
        if (((u64)(*item) == ':')) {
            colonseen = (i64)1;
            return (i64)4;
        }
;
    }
;
    (*value) = 0;
    if (((u64)(*item) == '-')) {
        (*name) = (item + (!!((i64)colonseen) ? (i64)0 : (i64)1));
        q = strchr(item,(i32)':');
        if (!(!!(q))) {
            q = strchr(item,(i32)'=');
        }
;
        if (!!(q)) {
            (*value) = (q + (i64)1);
            (*q) = (u64)0u;
        }
;
        return (!!((i64)colonseen) ? (i64)5 : (i64)1);
    }
;
    fileext = mlib$extractext(item,(i64)0);
    (*name) = item;
    if (((i64)(u64)(*fileext) == (i64)0)) {
        strcpy((u8 *)str,(*name));
        if ((!!(defext) && !(!!((i64)colonseen)))) {
            (*name) = mlib$addext((u8 *)str,defext);
        }
;
    }
    else if ((!!(mlib$eqstring(fileext,(byte*)"dll")) || !!(mlib$eqstring(fileext,(byte*)"mcx")))) {
        return (!!((i64)colonseen) ? (i64)5 : (i64)3);
    }
;
    if (!!((i64)colonseen)) {
        return (i64)5;
    }
    else {
        return (i64)2;
    }
;
}

static i64 mlib$readnextfileitem(u8 **fileptr,u8 **item) {
        u8 *  p;
        u8 *  pstart;
        u8 *  pend;
        i64 n;
        static u8 str[256];
    p = (*fileptr);
    //reenter:
L1219 :;
;
    L1220 :;
    while (1) {
                {u64 $temp = (u64)(*p);
if (($temp==' ') || ($temp==(u64)9u) || ($temp==(u64)13u) || ($temp==(u64)10u)) {
            ++(p);
        }
        else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
            return (i64)0;
        }
        else {
            goto L1221 ;
        }
        };
    }
L1221 :;
    ;
        {u64 $temp = (u64)(*p);
if (($temp=='!') || ($temp=='#')) {
        ++(p);
        L1222 :;
                {u64 $temp = (u64)(*(p)++);
if (($temp==(u64)10u)) {
            goto L1219 ;
;
        }
        else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
            (*fileptr) = (p - (i64)1);
            return (i64)0;
        }
        else {
        }
        }goto L1222 ;
L1223 :;
        ;
    }
    };
        {u64 $temp = (u64)(*p);
if (($temp=='"')) {
        pstart = ++(p);
        L1224 :;
        while (1) {
                        {u64 $temp = (u64)(*p);
if (($temp==(u64)0u) || ($temp==(u64)26u)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Unexpected EOF in @file",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)8);
            }
            else if (($temp=='"')) {
                pend = (p)++;
                if (((u64)(*p) == ',')) {
                    ++(p);
                }
;
                goto L1225 ;
            }
            };
            ++(p);
        }
L1225 :;
        ;
    }
    else {
        pstart = p;
        L1226 :;
        while (1) {
                        {u64 $temp = (u64)(*p);
if (($temp==(u64)0u) || ($temp==(u64)26u)) {
                pend = p;
                goto L1227 ;
            }
            else if (($temp==' ') || ($temp==(u64)9u) || ($temp==',') || ($temp==(u64)13u) || ($temp==(u64)10u)) {
                pend = (p)++;
                goto L1227 ;
            }
            };
            ++(p);
        }
L1227 :;
        ;
    }
    };
    n = (pend - pstart);
    if ((n >= (i64)256)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"@file item too long",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)9);
    }
;
    memcpy(str,(void *)pstart,(u64)n);
    str[((n + (i64)1))-1] = (u64)0u;
    (*item) = (u8 *)str;
    (*fileptr) = p;
    return (i64)1;
}

void mlib$ipadstr(u8 *s,i64 width,u8 *padchar) {
        i64 n;
        i64 $av_1;
    n = strlen(s);
    $av_1 = (width - n);
    while ($av_1-- > 0) {
L1228 :;
        strcat(s,padchar);
L1229 :;
    }
L1230 :;
    ;
}

u8 *mlib$padstr(u8 *s,i64 width,u8 *padchar) {
        static u8 str[256];
    strcpy((u8 *)str,s);
    mlib$ipadstr((u8 *)str,width,padchar);
    return (u8 *)str;
}

u8 *mlib$chr(i64 c) {
        static u8 str[8];
    str[((i64)1)-1] = (u64)c;
    str[((i64)2)-1] = (u64)0u;
    return (u8 *)str;
}

i64 mlib$cmpstring(u8 *s,u8 *t) {
        i64 res;
    if (((res = strcmp(s,t)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$cmpstringn(u8 *s,u8 *t,i64 n) {
        i64 res;
    if (((res = strncmp(s,t,(u64)n)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$eqstring(u8 *s,u8 *t) {
    return (i64)(strcmp(s,t) == (i64)0);
}

i64 mlib$cmpbytes(void *p,void *q,i64 n) {
        i64 res;
    if (((res = memcmp(p,q,(u64)n)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$eqbytes(void *p,void *q,i64 n) {
    return (i64)(memcmp(p,q,(u64)n) == (i64)0);
}

void mlib$mseed(u64 a,u64 b) {
    mlib$seed[((i64)1)-1] = a;
    if (!!(b)) {
        mlib$seed[((i64)2)-1] = b;
    }
    else {
        mlib$seed[((i64)2)-1] ^= a;
    }
;
}

u64 mlib$mrandom(void) {
        i64 x;
        i64 y;
    x = (i64)mlib$seed[((i64)1)-1];
    y = (i64)mlib$seed[((i64)2)-1];
    mlib$seed[((i64)1)-1] = (u64)y;
    x ^= (x << (i64)23);
    mlib$seed[((i64)2)-1] = (u64)(((x ^ y) ^ (x >> (i64)17)) ^ (y >> (i64)26));
    return (u64)((i64)mlib$seed[((i64)2)-1] + y);
}

i64 mlib$mrandomp(void) {
    return ((i64)mlib$mrandom() & (i64)9223372036854775807);
}

i64 mlib$mrandomint(i64 n) {
    return (mlib$mrandomp() % n);
}

i64 mlib$mrandomrange(i64 a,i64 b) {
        i64 span;
    span = ((b - a) + (i64)1);
    if ((span <= (i64)0)) {
        return (i64)0;
    }
;
    return ((mlib$mrandomp() % span) + a);
}

r64 mlib$mrandomreal(void) {
        r64 x;
    L1231 :;
    do {
        x = ((r64)mlib$mrandomp() / (double)9223372036854775800.);
L1232 :;
    }
    while (!(x != (double)1.));
L1233 :;
    ;
    return x;
}

r64 mlib$mrandomreal1(void) {
    return (r64)(mlib$mrandomp() / (i64)9223372036854775807);
}

u8 *mlib$readline(void) {
    msysc$m_read_conline();
    ;
    return msysc$rd_buffer;
}

void *mlib$findfunction(u8 *name) {
        i64 $av_1;
        i64 i;
        ($av_1 = msysc$m_get_nprocs());
    for (i=(i64)1;i<=$av_1;++i) {
L1234 :;
        if (!!(mlib$eqstring(msysc$m_get_procname(i),name))) {
            return msysc$m_get_procaddr(i);
        }
;
L1235 :;
    }
L1236 :;
    ;
    return 0;
}

i64 mlib$roundtoblock(i64 n,i64 align) {
    if (((n & (align - (i64)1)) == (i64)0)) {
        return n;
    }
;
    return (n + (align - (n & (align - (i64)1))));
}

void *mlib$pcm_allocnfz(i64 n) {
        byte *  p;
    if (!!((n & (i64)7))) {
        n = (n + ((i64)8 - (n & (i64)7)));
    }
;
    p = mlib$pcheapptr;
    mlib$pcheapptr += n;
    if ((mlib$pcheapptr >= mlib$pcheapend)) {
        p = (byte *)mlib$pcm_newblock(n);
    }
;
    return p;
}

// START
void mlib$start(void) {

}

// START
void mclib$start(void) {

}

void mwindows$os_init(void) {
    mwindows$hconsole = GetStdHandle((u32)(i64)(u32)(i64)-11);
    mwindows$hconsolein = GetStdHandle((u32)(i64)(u32)(i64)-10);
    mwindows$lastkey.repeatcount = (i64)0;
    mwindows$keypending = (i64)0;
    SetConsoleCtrlHandler(0,(i64)1);
    SetConsoleMode(mwindows$hconsole,(u32)(i64)3);
    mwindows$init_flag = (i64)1;
}

i64 mwindows$os_execwait(u8 *cmdline,i64 newconsole,u8 *workdir) {
        u32 exitcode;
        i64 status;
        i64 cflags;
        struct mwindows$rstartupinfo si;
        struct mwindows$rprocess_information xpi;
    cflags = (i64)0;
    memset(&(si),0,104);
    memset(&(xpi),0,24);
    switch (newconsole) {
    case 0:;
        {
            cflags = (i64)32;
        }
        break;
    case 1:;
        {
            cflags = (i64)48;
        }
        break;
    case 2:;
        {
            cflags = (i64)48;
        }
        break;
    } //SW
;
    si.size = (i64)104;
    status = CreateProcessA(0,cmdline,0,0,(i64)1,(u32)cflags,0,0,&si,&xpi);
    if ((status == (i64)0)) {
        status = GetLastError();
        printf((byte*)"Winexec error: %lld\n",status);
        return (i64)-1;
    }
;
    WaitForSingleObject(xpi.process,(u32)(i64)4294967295);
    GetExitCodeProcess(xpi.process,&exitcode);
    CloseHandle(xpi.process);
    CloseHandle(xpi.thread);
    return (i64)exitcode;
}

i64 mwindows$os_execcmd(u8 *cmdline,i64 newconsole) {
        struct mwindows$rstartupinfo si;
        struct mwindows$rprocess_information xpi;
    memset(&(si),0,104);
    memset(&(xpi),0,24);
    si.size = (i64)104;
    CreateProcessA(0,cmdline,0,0,(i64)1,(u32)((i64)32 | (!!(newconsole) ? (i64)16 : (i64)0)),0,0,&si,&xpi);
    CloseHandle(xpi.process);
    CloseHandle(xpi.thread);
    return (i64)1;
}

i64 mwindows$os_getch(void) {
        i64 k;
    k = (mwindows$os_getchx() & (i64)255);
    return k;
}

i64 mwindows$os_kbhit(void) {
        u32 count;
    if (!(!!(mwindows$init_flag))) {
        mwindows$os_init();
    }
;
    GetNumberOfConsoleInputEvents(mwindows$hconsolein,&count);
    return (i64)((i64)count > (i64)1);
}

u64 mwindows$os_getdllinst(u8 *name) {
        void *  hinst;
    hinst = LoadLibraryA(name);
    return (u64)hinst;
}

void *mwindows$os_getdllprocaddr(i64 hinst,u8 *name) {
    return GetProcAddress((void *)hinst,name);
}

void mwindows$os_initwindows(void) {
    mwindows$os_init();
    mwindows$os_gxregisterclass((byte*)"pcc001");
}

void mwindows$os_gxregisterclass(u8 *classname) {
        struct mwindows$rwndclassex r;
        static byte registered;
    if (!!((i64)registered)) {
        return;
    }
;
    memset(&(r),0,80);
    r.size = (i64)80;
    r.style = (i64)40;
    r.wndproc = (void (*)(void))&mwindows$mainwndproc;
    r.instance = 0;
    r.icon = 0;
    r.cursor = LoadCursorA(0,(u8 *)(void *)(i64)32512);
    r.background = (void *)(i64)16;
    r.menuname = 0;
    r.classname = classname;
    r.iconsm = 0;
    if ((RegisterClassExA(&r) == (i64)0)) {
        printf((byte*)"Regclass error: %lld %lld\n",classname,GetLastError());
        exit((i64)1);
    }
;
    registered = (i64)1;
}

i64 mwindows$mainwndproc(void *hwnd,u32 message,u64 wparam,u64 lparam) {
        struct mwindows$rmsg m;
        i64 result;
        static i64 count = (i64)0;
    m.hwnd = hwnd;
    m.message = (i64)message;
    m.wparam = wparam;
    m.lparam = lparam;
    m.pt.x = (i64)0;
    m.pt.y = (i64)0;
    if (!!(mwindows$wndproc_callbackfn)) {
        result = ((*mwindows$wndproc_callbackfn))(&m);
    }
    else {
        result = (i64)0;
    }
;
    if (((i64)m.message == (i64)2)) {
        return (i64)0;
    }
;
    if (!(!!(result))) {
        return DefWindowProcA(hwnd,(u32)(i64)message,wparam,lparam);
    }
    else {
        return (i64)0;
    }
;
}

void mwindows$os_setmesshandler(void *addr) {
    mwindows$wndproc_callbackfn = (i64 (*)(void *))addr;
}

i64 mwindows$os_getchx(void) {
        i64 count;
        i64 charcode;
        i64 keyshift;
        i64 keycode;
        i64 altdown;
        i64 ctrldown;
        i64 shiftdown;
        i64 capslock;
    if (!(!!(mwindows$init_flag))) {
        mwindows$os_init();
    }
;
    if (!!(mwindows$keypending)) {
        mwindows$lastkey = mwindows$pendkey;
        mwindows$keypending = (i64)0;
    }
    else {
        if (((i64)mwindows$lastkey.repeatcount == (i64)0)) {
            L1237 :;
            do {
                count = (i64)0;
                ReadConsoleInputA(mwindows$hconsolein,&mwindows$lastkey,(u32)(i64)1,&count);
L1238 :;
            }
            while (!(((i64)mwindows$lastkey.eventtype == (i64)1) && ((i64)mwindows$lastkey.keydown == (i64)1)));
L1239 :;
            ;
        }
;
    }
;
    altdown = (!!(((i64)mwindows$lastkey.controlkeystate & (i64)3)) ? (i64)1 : (i64)0);
    ctrldown = (!!(((i64)mwindows$lastkey.controlkeystate & (i64)12)) ? (i64)1 : (i64)0);
    shiftdown = (!!(((i64)mwindows$lastkey.controlkeystate & (i64)16)) ? (i64)1 : (i64)0);
    capslock = (!!(((i64)mwindows$lastkey.controlkeystate & (i64)128)) ? (i64)1 : (i64)0);
    --(mwindows$lastkey.repeatcount);
    charcode = (i64)mwindows$lastkey.asciichar;
    keycode = ((i64)mwindows$lastkey.virtualkeycode & (i64)255);
    if ((charcode < (i64)0)) {
        if ((charcode < (i64)-128)) {
            charcode = (i64)0;
        }
        else {
            charcode += (i64)256;
        }
;
    }
;
    if (((!!(altdown) && !!(ctrldown)) && (charcode == (i64)166))) {
        altdown = (ctrldown = (i64)0);
    }
    else {
        if ((!!(altdown) || !!(ctrldown))) {
            charcode = (i64)0;
            if (((keycode >= (i64)65) && (keycode <= (i64)90))) {
                charcode = (keycode - (i64)64);
            }
;
        }
;
    }
;
    keyshift = ((((capslock << (i64)3) | (altdown << (i64)2)) | (ctrldown << (i64)1)) | shiftdown);
    return (((keyshift << (i64)24) | (keycode << (i64)16)) | charcode);
}

u8 *mwindows$os_getos(void) {
    if (((i64)64 == (i64)32)) {
        return (byte*)"W32";
    }
    else {
        return (byte*)"W64";
    }
;
}

i64 mwindows$os_gethostsize(void) {
    return (i64)64;
}

i64 mwindows$os_shellexec(u8 *opc,u8 *file) {
    return system(file);
}

void mwindows$os_sleep(i64 a) {
    Sleep((u32)a);
}

void *mwindows$os_getstdin(void) {
    return fopen((byte*)"con",(byte*)"rb");
}

void *mwindows$os_getstdout(void) {
    return fopen((byte*)"con",(byte*)"wb");
}

u8 *mwindows$os_gethostname(void) {
        static u8 name[300];
    GetModuleFileNameA(0,(u8 *)name,(u32)(i64)300);
    return (u8 *)name;
}

u8 *mwindows$os_getmpath(void) {
    return (byte*)"C:\\m\\";
}

i64 mwindows$os_clock(void) {
    return clock();
}

i64 mwindows$os_ticks(void) {
    return (i64)GetTickCount64();
}

i64 mwindows$os_hptimer(void) {
        i64 t;
    QueryPerformanceCounter(&t);
    return t;
}

i64 mwindows$os_iswindows(void) {
    return (i64)1;
}

void mwindows$os_getsystime(struct mwindows$rsystemtime *tm) {
    GetLocalTime((struct mwindows$rsystemtime *)tm);
}

void mwindows$os_peek(void) {
        i64 ticks;
        static i64 lastticks;
        byte m[100];
    ticks = (i64)GetTickCount64();
    if (((ticks - lastticks) >= (i64)1000)) {
        lastticks = ticks;
        PeekMessageA(&m,0,(u32)(i64)0,(u32)(i64)0,(u32)(i64)0);
    }
;
}

byte *mwindows$os_allocexecmem(i64 n) {
        byte *  p;
        u32 oldprot;
        i64 status;
    p = (byte *)VirtualAlloc(0,(u32)n,(u32)(i64)12288,(u32)(i64)1);
    if ((p == 0)) {
        return 0;
    }
;
    status = VirtualProtect(p,(u32)n,(u32)(i64)64,(u32 *)&oldprot);
    if ((status == (i64)0)) {
        return 0;
    }
;
    return p;
}

// START
void mwindows$start(void) {

}

u64 mwindllc$os_calldllfunction(void (*fnaddr)(void),i64 retcode,i64 nargs,i64 (*args)[],byte (*argcodes)[]) {
    if ((retcode == (i64)73)) {
        return (u64)mwindllc$calldll_cint((void (*)(void))fnaddr,args,nargs);
    }
    else {
        return (u64)mwindllc$calldll_creal((void (*)(void))fnaddr,args,nargs);
    }
;
}

u64 mwindllc$os_pushargs(u64 (*args)[],i64 nargs,i64 nextra,void (*fnaddr)(void),i64 isfloat) {
    return mwindllc$os_calldllfunction((void (*)(void))fnaddr,(!!(isfloat) ? (i64)0 : (i64)73),nargs,(i64 (*)[])args,0);
}

static i64 mwindllc$calldll_cint(void (*fnaddr)(void),i64 (*params)[],i64 nparams) {
    switch (nparams) {
    case 0:;
        {
            return ((*(i64 (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            return ((*(i64 (*)(i64))fnaddr))((*params)[((i64)1)-1]);
        }
        break;
    case 2:;
        {
            return ((*(i64 (*)(i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1]);
        }
        break;
    case 3:;
        {
            return ((*(i64 (*)(i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1]);
        }
        break;
    case 4:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1]);
        }
        break;
    case 5:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1]);
        }
        break;
    case 6:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1]);
        }
        break;
    case 9:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1]);
        }
        break;
    case 10:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1]);
        }
        break;
    case 11:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1]);
        }
        break;
    case 12:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1],(*params)[((i64)12)-1]);
        }
        break;
    case 14:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1],(*params)[((i64)12)-1],(*params)[((i64)13)-1],(*params)[((i64)14)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"calldll/c/int unsupported # of params",NULL);
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
    } //SW
;
    return (i64)0;
}

static i64 mwindllc$calldll_creal(void (*fnaddr)(void),i64 (*params)[],i64 nparams) {
        r64 x;
    switch (nparams) {
    case 0:;
        {
            return (i64)((*(r64 (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            mwindllc$os_dummycall((r64)(*params)[((i64)1)-1],(r64)(*params)[((i64)2)-1],(r64)(*params)[((i64)3)-1],(r64)(*params)[((i64)4)-1]);
            x = ((*(r64 (*)(i64))fnaddr))((*params)[((i64)1)-1]);
        }
        break;
    case 2:;
        {
            x = ((*(r64 (*)(i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"calldll/c/real too many params",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
    } //SW
;
    return *(i64*)&x;
}

void mwindllc$os_dummycall(r64 a,r64 b,r64 c,r64 d) {
}

// START
void mwindllc$start(void) {

}


/* ********** End of C Code ********** */

