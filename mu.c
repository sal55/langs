// Build on Linux using:

// gcc mu.c -omu -lm -ldl -O3 -fno-strict-aliasing

// Run using:
// ./mu file                # or file.m (optional extension)

// Generated C
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void mm_main();
void (*entrypoint)(void) = mm_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u64 a[4];};   // mem:32;
struct $B18 {u64 a[50];};   // mem:400;
struct $B19 {u64 a[143];};   // mem:1144;
struct $B20 {u64 a[64];};   // mem:512;
struct $B21 {u64 a[16];};   // mem:128;
struct $B22 {u64 a[14];};   // mem:112;
struct $B23 {u16 a[7];};   // mem:14;
struct $B24 {u8 a[143];};   // mem:143;
struct $B25 {u64 a[7];};   // mem:56;
struct $B26 {u16 a[3];};   // mem:6;
struct $B27 {u16 a[1];};   // mem:2;
struct $B28 {u64 a[12];};   // mem:96;
struct $B29 {u64 a[20];};   // mem:160;
struct $B30 {u64 a[8];};   // mem:64;
struct $B31 {u64 a[151];};   // mem:1208;
struct $B32 {u8 a[151];};   // mem:151;
struct $B33 {u64 a[21];};   // mem:168;
struct $B34 {u8 a[21];};   // mem:21;
struct $B35 {u64 a[137];};   // mem:1096;
struct $B36 {u8 a[137];};   // mem:137;
struct $B37 {u64 a[18];};   // mem:144;
struct $B38 {u16 a[9];};   // mem:18;
struct $B39 {u32 a[5];};   // mem:20;
struct $B40 {u64 a[17];};   // mem:136;
struct $B41 {u64 a[128];};   // mem:1024;
struct $B42 {u64 a[193];};   // mem:1544;
struct $B43 {u64 a[1];};   // mem:8;
struct $B44 {u64 a[500];};   // mem:4000;
struct $B45 {u64 a[250];};   // mem:2000;
struct $B46 {u32 a[125];};   // mem:500;
struct $B47 {u64 a[90];};   // mem:720;
struct $B48 {u64 a[18006];};   // mem:144048;
struct $B49 {u64 a[2000];};   // mem:16000;
struct $B50 {u64 a[300];};   // mem:2400;
struct $B51 {u16 a[117009];};   // mem:234018;
struct $B52 {u64 a[5000];};   // mem:40000;
struct $B53 {u64 a[3000];};   // mem:24000;
struct $B54 {u64 a[375];};   // mem:3000;
struct $B55 {u64 a[750];};   // mem:6000;
struct $B56 {u64 a[11];};   // mem:88;
struct $B57 {u64 a[55];};   // mem:440;
struct $B58 {u8 a[55];};   // mem:55;
struct $B59 {u64 a[200];};   // mem:1600;
struct $B60 {u8 a[65];};   // mem:65;
struct $B61 {u8 a[301];};   // mem:301;
struct $B62 {u64 a[31];};   // mem:248;
struct $B63 {u8 a[31];};   // mem:31;
struct $B64 {u64 a[51];};   // mem:408;
struct $B65 {u64 a[16001];};   // mem:128008;
struct $B66 {u32 a[16001];};   // mem:64004;
struct $B67 {u8 a[16001];};   // mem:16001;
struct $B68 {u64 a[152004];};   // mem:1216032;
struct $B69 {u32 a[38001];};   // mem:152004;
struct $B70 {u64 a[1000];};   // mem:8000;
struct $B71 {u64 a[5];};   // mem:40;
struct $B72 {u64 a[65536];};   // mem:524288;
struct $B73 {u64 a[13];};   // mem:104;
struct $B74 {u64 a[33];};   // mem:264;
struct $B75 {u8 a[33];};   // mem:33;
struct $B76 {u64 a[123];};   // mem:984;
struct $B77 {u8 a[123];};   // mem:123;
struct $B78 {u64 a[136];};   // mem:1088;
struct $B79 {u64 a[174];};   // mem:1392;
struct $B80 {u16 a[87];};   // mem:174;
struct $B81 {u32 a[87];};   // mem:348;
struct $B82 {u16 a[25];};   // mem:50;
struct $B83 {u32 a[15];};   // mem:60;
struct $B84 {u64 a[30];};   // mem:240;
struct $B85 {u64 a[27];};   // mem:216;
struct $B86 {u64 a[22];};   // mem:176;
struct $B87 {u64 a[130];};   // mem:1040;
struct $B88 {u64 a[2048];};   // mem:16384;
struct $B89 {u64 a[208];};   // mem:1664;
struct $B90 {u64 a[45];};   // mem:360;
struct $B91 {u64 a[320];};   // mem:2560;
struct $B92 {u64 a[10000];};   // mem:80000;
struct $B93 {u64 a[100];};   // mem:800;
struct $B94 {u64 a[157];};   // mem:1256;
struct $B95 {u64 a[1001];};   // mem:8008;
struct $B96 {u64 a[256];};   // mem:2048;

// Function Ptr Types:
typedef i64 (*F1)();
typedef i64 (*F2)(i64);
typedef i64 (*F3)(i64, i64);
typedef i64 (*F4)(i64, i64, i64);
typedef i64 (*F5)(i64, i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F13)();
typedef r64 (*F14)(i64);
typedef r64 (*F15)(i64, i64);
typedef i64 (*F16)(i64, u64, u64);
typedef i64 (*F17)(u64);
typedef void (*F18)(u64);
typedef u64 (*F19)(i64);
typedef void (*F20)();

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static i64 mlinux_init_flag;
static u8 pcl_pc_userunpcl;
static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc;
static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B17 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest;
static struct $B18 pc_decls_plibfiles;
static struct $B18 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype;
static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole;
static u8 pc_decls_fregoptim;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B19 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest;
static i64 pc_diags_destlinestart;
static struct $B20 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static i64 pc_run_dotrace;
static i64 pc_run_dostep;
static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B21 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B22 pc_tables_pstdnames;
static struct $B23 pc_tables_psize;
static struct $B23 pc_tables_psigned;
static struct $B23 pc_tables_pint;
static struct $B23 pc_tables_pfloat;
static struct $B23 pc_tables_pmin;
static struct $B23 pc_tables_piwrb;
static struct $B22 pc_tables_opndnames;
static struct $B19 pc_tables_pclnames;
static struct $B24 pc_tables_pclhastype;
static struct $B24 pc_tables_pclextra;
static struct $B24 pc_tables_pclhasopnd;
static struct $B24 pc_tables_pclargs;
static struct $B25 pc_tables_ccnames;
static struct $B1 pc_tables_idnames;
static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B19 mc_genmcl_px_handlertable;
static struct $B26 mc_genmcl_scondcodes;
static struct $B26 mc_genmcl_ucondcodes;
static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B28 mc_libmcl_smallinttable;
static struct $B29 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B29 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B20 mc_stackmcl_stropndstack_str;
static u8 mc_genss_rex;
static u8 mc_genss_sizeoverride;
static u8 mc_genss_addroverride;
static u8 mc_genss_f2override;
static u8 mc_genss_f3override;
static u8 mc_genss_nowmask;
static u8 mc_genss_usesizeb;
static u64 mc_genss_extraparam;
static i64 mc_genss_currseg;
static u64 mc_genss_currdata;
static u64 mc_genss_currrelocs;
static i64 mc_genss_nrelocs;
static struct $B3 mc_genss_ishighreg;
static u64 mc_genss_currmcl;
static u64 mc_genss_ripentry;
static struct $B11 mc_decls_valtypenames;
static struct $B31 mc_decls_mclnames;
static struct $B32 mc_decls_mclnopnds;
static struct $B32 mc_decls_mclcodes;
static struct $B33 mc_decls_regnames;
static struct $B34 mc_decls_regcodes;
static struct $B29 mc_decls_condnames;
static struct $B29 mc_decls_asmcondnames;
static struct $B29 mc_decls_asmrevcond;
static struct $B35 mc_decls_dregnames;
static struct $B36 mc_decls_regsizes;
static struct $B36 mc_decls_regindices;
static struct $B21 mc_decls_xmmregnames;
static struct $B30 mc_decls_fregnames;
static struct $B30 mc_decls_mregnames;
static struct $B37 mc_decls_jmpccnames;
static struct $B38 mc_decls_jmpcccodes;
static struct $B21 mc_decls_setccnames;
static struct $B3 mc_decls_setcccodes;
static struct $B21 mc_decls_cmovccnames;
static struct $B3 mc_decls_cmovcccodes;
static struct $B12 mc_decls_segmentnames;
static struct $B8 mc_decls_reftypenames;
static struct $B12 mc_decls_opndnames_ma;
static struct $B29 mc_decls_pclopnd;
static struct $B39 mc_decls_pclreg;
static struct $B39 mc_decls_pclmode;
static struct $B39 mc_decls_pclcount;
static struct $B39 mc_decls_pclloc;
static struct $B39 mc_decls_pcltempflags;
static struct $B29 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B17 mc_decls_locnames;
static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames;
static struct $B3 mc_decls_callalign;
static struct $B3 mc_decls_callblockret;
static struct $B30 mc_decls_callblocksize;
static struct $B16 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used;
static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment;
static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B41 mc_decls_regtable;
static struct $B42 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static u64 mc_decls_regmodes;
static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B18 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs;
static struct $B12 mc_decls_multxregs;
static struct $B23 mc_decls_ploadopx;
static struct $B23 mc_decls_ploadop;
static struct $B25 mc_objdecls_relocnames;
static struct $B41 mc_writeasm_nregnames;
static struct $B21 mc_writeasm_regvars;
static struct $B21 mc_writeasm_xregvars;
static struct $B20 mc_writeasm_strmcl_str;
static struct $B20 mc_writeasm_mstropnd_str;
static struct $B20 mc_writeasm_strvalue_str;
static struct $B17 mc_writeasm_getregname_str;
static struct $B17 mc_writeasm_getxregname_str;
static struct $B16 mc_writeasm_getdispname_str;
static struct $B21 mc_writeasm_gettempname_str;
static struct $B18 mc_writeexe_libinsttable;
static struct $B18 mc_writeexe_libinstnames;
static struct $B18 mc_writeexe_libnotable;
static u64 mc_writeexe_basereloclist;
static i64 mc_writeexe_nbaserelocs;
static i64 mc_writeexe_maxrelocaddr;
static struct $B44 mc_writeexe_blockbases;
static struct $B45 mc_writeexe_blockcounts;
static struct $B45 mc_writeexe_blockbytes;
static struct $B46 mc_writeexe_blockpadding;
static i64 mc_writeexe_nbaseblocks;
static i64 mc_writeexe_basetablesize;
static i64 mc_writeexe_imagebase;
static i64 mc_writeexe_imagesize;
static i64 mc_writeexe_filesize;
static u64 mc_writeexe_thunktable;
static i64 mc_writeexe_fileiatoffset;
static i64 mc_writeexe_fileiatsize;
static u64 mc_writeexe_stentrypoint;
static u64 mc_writeexe_stentrypoint2;
static u64 mc_writeexe_stentrypoint3;
static struct $B47 mc_writeexe_sectiontable;
static i64 mc_writeexe_nsections;
static u64 mc_writeexe_importdir;
static struct $B48 mc_writeexe_importtable;
static i64 mc_writeexe_nimports;
static struct $B49 mc_writeexe_exporttable;
static i64 mc_writeexe_nexports;
static u64 mc_writeexe_dllfilename;
static i64 mc_writeexe_isdll;
static struct $B50 mc_writeexe_dlltable;
static i64 mc_writeexe_ndlls;
static u64 mc_writeexe_datastart;
static u64 mc_writeexe_dataptr;
static u64 mc_writeexe_userentrypoint;
static i64 mc_writeexe_exportdirvirtaddr;
static i64 mc_writeexe_exportdirvirtsize;
static i64 mc_writeexe_exportdiroffset;
static i64 mc_writeexe_blockdirvirtaddr;
static i64 mc_writeexe_blockdirvirtsize;
static i64 mc_writeexe_blockdiroffset;
static i64 mc_writeobj_symtaboffset;
static u64 mc_writeobj_datastart;
static u64 mc_writeobj_dataptr;
static struct $B51 mc_writeobj_symboltable;
static i64 mc_writeobj_nsymbols;
static i64 mc_writeobj_stoffset;
static struct $B52 mc_writeobj_stringtable;
static struct $B52 mc_writeobj_stringlengths;
static i64 mc_writeobj_nextstringoffset;
static i64 mc_writeobj_nstrings;
static struct $B2 mc_writeobj_writerelocs_s;
static struct $B38 mc_writeobj_makesymbol_r;
static struct $B38 mc_writeobj_strtoaux_r;
static struct $B38 mc_writeobj_sectiontoaux_r;
static struct $B22 mx_decls_mcxdirnames;
static struct $B12 mx_decls_mcxrelocnames;
static struct $B29 mx_decls_dllnametable;
static struct $B29 mx_decls_dllinsttable;
static i64 mx_decls_ndlllibs;
static struct $B29 mx_decls_libnametable;
static struct $B29 mx_decls_libtable;
static struct $B39 mx_decls_librelocated;
static struct $B39 mx_decls_libinitdone;
static i64 mx_decls_nlibs;
static struct $B53 mx_decls_symbolnametable;
static struct $B54 mx_decls_symboldefined;
static struct $B53 mx_decls_symboladdress;
static struct $B55 mx_decls_symbollibindex;
static struct $B54 mx_decls_symboldllindex;
static i64 mx_decls_nsymbols;
static i64 mx_decls_nsymimports;
static i64 mx_decls_nsymexports;
static struct $B12 mx_lib_rsegmentnames;
static u64 mx_write_dest;
static u64 mx_write_entrypoint;
static u64 mm_cli_syslibname;
static struct $B56 mm_cli_passnames;
static struct $B30 mm_cli_dpassnames;
static struct $B57 mm_cli_optionnames;
static struct $B58 mm_cli_optionvalues;
static u8 mm_cli_msfile;
static u64 mm_cli_outext;
static i64 mm_cli_startclock;
static i64 mm_cli_endclock;
static i64 mm_cli_cmdskip;
static u64 mm_cli_inputfile;
static i64 mm_cli_loadtime;
static i64 mm_cli_parsetime;
static i64 mm_cli_resolvetime;
static i64 mm_cli_typetime;
static i64 mm_cli_ctime;
static i64 mm_cli_pcltime;
static i64 mm_cli_compiletime;
static u8 mm_cli_do_option_outused;
static u8 mm_cli_do_option_outpathused;
static i64 mm_genpcl_retindex;
static i64 mm_genpcl_initstaticsindex;
static u64 mm_genpcl_pcldoswx;
static struct $B59 mm_genpcl_loopstack;
static i64 mm_genpcl_loopindex;
static struct $B60 mm_genpcl_zero_unit;
static u64 mm_genpcl_pzero;
static i64 mm_genpcl_nvarlocals;
static i64 mm_genpcl_nvarparams;
static i64 mm_blockpcl_nnn;
static struct $B29 mm_blockpcl_casestmt;
static struct $B29 mm_blockpcl_caseelse;
static i64 mm_blockpcl_casedepth;
static u64 mm_blockpcl_sw_labeltable;
static u64 mm_blockpcl_sw_valuetable;
static i64 mm_blockpcl_sw_lower;
static i64 mm_blockpcl_sw_ncases;
static u8 mm_blockpcl_sw_defaultseen;
static i64 mm_blockpcl_sw_defaultlabel;
static i64 mm_blockpcl_sw_breaklabel;
static i64 mm_blockpcl_maxreg;
static u64 mm_blockpcl_pnprocs;
static u64 mm_blockpcl_pprocname;
static u64 mm_blockpcl_pprocaddr;
static struct $B7 mm_decls_modules;
static struct $B61 mm_decls_moduletosub;
static struct $B62 mm_decls_subprogs;
static struct $B7 mm_decls_sources;
static struct $B63 mm_decls_subproghasstart;
static i64 mm_decls_nmodules;
static i64 mm_decls_nsubprogs;
static i64 mm_decls_nsourcefiles;
static i64 mm_decls_nlibfiles;
static u64 mm_decls_stprogram;
static u64 mm_decls_stmodule;
static i64 mm_decls_currmoduleno;
static u8 mm_decls_loadedfromma;
static struct $B3 mm_decls_lx;
static struct $B3 mm_decls_nextlx;
static struct $B64 mm_decls_libfiles;
static i64 mm_decls_mainsubprogno;
static i64 mm_decls_ntypes;
static struct $B65 mm_decls_ttnamedef;
static struct $B65 mm_decls_ttowner;
static struct $B66 mm_decls_ttbasetype;
static struct $B65 mm_decls_ttname;
static struct $B66 mm_decls_ttsize;
static struct $B67 mm_decls_ttsizeset;
static struct $B66 mm_decls_ttlower;
static struct $B66 mm_decls_ttlength;
static struct $B65 mm_decls_ttmult;
static struct $B65 mm_decls_ttdimexpr;
static struct $B66 mm_decls_tttarget;
static struct $B67 mm_decls_ttusercat;
static struct $B66 mm_decls_ttlineno;
static struct $B67 mm_decls_ttsigned;
static struct $B67 mm_decls_ttisreal;
static struct $B67 mm_decls_ttisinteger;
static struct $B67 mm_decls_ttisshort;
static struct $B67 mm_decls_ttisref;
static struct $B67 mm_decls_ttisblock;
static struct $B68 mm_decls_typenames;
static struct $B69 mm_decls_typenamepos;
static i64 mm_decls_ntypenames;
static struct $B36 mm_decls_typestarterset;
static u64 mm_decls_currproc;
static i64 mm_decls_assemmode;
static i64 mm_decls_headermode;
static u64 mm_decls_proclist;
static u64 mm_decls_proclistx;
static u64 mm_decls_staticlist;
static u64 mm_decls_staticlistx;
static u64 mm_decls_constlist;
static u64 mm_decls_constlistx;
static u64 mm_decls_nullunit;
static i64 mm_decls_ndllproctable;
static struct $B70 mm_decls_dllproctable;
static i64 mm_decls_fverbose;
static u8 mm_decls_msyslevel;
static u8 mm_decls_mvarlib;
static u8 mm_decls_fvarnames;
static u8 mm_decls_fshowtiming;
static u8 mm_decls_fshowss;
static u8 mm_decls_fshowc;
static u8 mm_decls_fshowpcl;
static u8 mm_decls_fshowasm;
static u8 mm_decls_fshowast1;
static u8 mm_decls_fshowast2;
static u8 mm_decls_fshowast3;
static u8 mm_decls_fshowst;
static u8 mm_decls_fshowpst;
static u8 mm_decls_fshowstflat;
static u8 mm_decls_fshowtypes;
static u8 mm_decls_fshowmodules;
static u8 mm_decls_fcheckunusedlocals;
static u8 mm_decls_highmem;
static u8 mm_decls_clinux;
static u8 mm_decls_dointlibs;
static i64 mm_decls_passlevel;
static i64 mm_decls_dpasslevel;
static i64 mm_decls_prodmode;
static i64 mm_decls_debugmode;
static i64 mm_decls_libmode;
static i64 mm_decls_fshortnames;
static u64 mm_decls_outfile;
static u64 mm_decls_destfilename;
static u64 mm_decls_destfilepath;
static i64 mm_decls_nunits;
static i64 mm_decls_nunitsmem;
static i64 mm_diags_currlineno;
static i64 mm_diags_currfileno;
static struct $B3 mm_diags_sbuffer;
static u64 mm_diags_dest;
static struct $B41 mm_diags_getprefix_str;
static struct $B71 mm_diags_getlineinfok_str;
static struct $B29 mm_lex_lxstart_stack;
static struct $B29 mm_lex_lxsource_stack;
static struct $B29 mm_lex_lxsptr_stack;
static struct $B29 mm_lex_lxfileno_stack;
static struct $B6 mm_lex_lxnextlx_stack;
static struct $B39 mm_lex_lximport_stack;
static i64 mm_lex_sourcelevel;
static i64 mm_lex_lximport;
static u64 mm_lex_lxsource;
static u64 mm_lex_lxstart;
static u64 mm_lex_lxsptr;
static i64 mm_lex_lxifcond;
static i64 mm_lex_lxfileno;
static struct $B72 mm_lex_hashtable;
static struct $B16 mm_lex_namemap;
static u64 mm_lex_u64maxstr;
static i64 mm_lib_autotypeno;
static i64 mm_lib_nextavindex;
static i64 mm_lib_nextsvindex;
static struct $B3 mm_lib_exprstrvar;
static u64 mm_lib_exprstr;
static u64 mm_lib_unitheapptr;
static i64 mm_lib_remainingunits;
static struct $B3 mm_lib_sbuffer;
static u64 mm_lib_dest;
static u64 mm_lib_jdest;
static u64 mm_lib_framevarname;
static struct $B17 mm_lib_nextautotype_str;
static struct $B16 mm_lib_getdottedname_str;
static struct $B4 mm_lib_strmode_str;
static struct $B4 mm_lib_strmode2_str;
static struct $B73 mm_libsources_syslibnames;
static struct $B73 mm_libsources_syslibtext;
static u64 mm_modules_fileext;
static struct $B15 mm_modules_getmodulefilename_str;
static u64 mm_name_currstproc;
static i64 mm_name_allowmodname;
static i64 mm_name_noexpand;
static i64 mm_name_noassem;
static i64 mm_name_macrolevels;
static struct $B18 mm_name_macroparams;
static struct $B18 mm_name_macroparamsgen;
static struct $B18 mm_name_macroargs;
static i64 mm_name_nmacroparams;
static i64 mm_name_nmacroargs;
static i64 mm_parse_intabledata;
static i64 mm_parse_inreadprint;
static i64 mm_parse_inparamlist;
static i64 mm_parse_inrecordbody;
static i64 mm_parse_inimportmodule;
static i64 mm_parse_labelseen;
static u64 mm_parse_tabledataname;
static struct $B1 mm_parse_procstack;
static i64 mm_parse_nprocstack;
static u64 mm_parse_unionstring;
static u64 mm_parse_unionpend;
static u64 mm_parse_unionlastvar;
static u64 mm_parse_dretvar;
static i64 mm_parse_varattribs;
static struct $B1 mm_parse_dollarstack;
static i64 mm_parse_ndollar;
static i64 mm_parse_insiderecord;
static i64 mm_parse_insidedllimport;
static struct $B1 mm_parse_forindexvars;
static i64 mm_parse_nforloops;
static u64 mm_support_bytemasks;
static struct $B16 mm_tables_stdnames;
static struct $B17 mm_tables_stdsize;
static struct $B17 mm_tables_stdpcl;
static i64 mm_tables_trefproc;
static i64 mm_tables_treflabel;
static struct $B74 mm_tables_sysfnnames;
static struct $B75 mm_tables_sysfnparams;
static struct $B75 mm_tables_sysfnres;
static struct $B74 mm_tables_sysfnhandlers;
static struct $B76 mm_tables_jtagnames;
static struct $B77 mm_tables_jsubs;
static struct $B77 mm_tables_jisexpr;
static struct $B77 mm_tables_jsolo;
static struct $B30 mm_tables_bitfieldnames;
static struct $B17 mm_tables_optypenames;
static struct $B78 mm_tables_symbolnames;
static struct $B40 mm_tables_symboloptypes;
static struct $B40 mm_tables_symbolgenops;
static struct $B40 mm_tables_symbolgentoops;
static struct $B40 mm_tables_symbolopprios;
static struct $B40 mm_tables_exprstarter;
static struct $B17 mm_tables_headerdirnames;
static struct $B17 mm_tables_scopenames;
static struct $B3 mm_tables_parammodenames;
static struct $B37 mm_tables_namenames;
static struct $B38 mm_tables_name2pid;
static struct $B1 mm_tables_propnames;
static struct $B79 mm_tables_stnames;
static struct $B80 mm_tables_stsymbols;
static struct $B81 mm_tables_stsubcodes;
static struct $B22 mm_tables_convnames;
static struct $B23 mm_tables_convtopcl;
static struct $B12 mm_tables_d_typestarterset;
static struct $B82 mm_tables_softconvtable;
static struct $B40 mm_tables_endsexpr;
static struct $B9 mm_tables_exprendsymbols;
static struct $B77 mm_tables_isbooltag;
static i64 mm_type_countedfields;
static i64 mm_type_inassem;
static i64 mm_type_inidata;
static i64 mm_type_tpass_depth;
static i64 mm_type_setrecordsize_depth;
static i64 mm_type_tx_assign_nn;
static i64 $nprocs;
static struct $B87 $procname;
static struct $B87 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);
extern u64 dlopen(u64 $1, i32 $2);
extern u64 dlsym(u64 $1, u64 $2);
extern i32 tcgetattr(i32 $1, u64 $2);
extern i32 tcsetattr(i32 $1, i32 $2, u64 $3);
extern i32 gettimeofday(u64 $1, u64 $2);
extern u64 gmtime_r(u64 $1, u64 $2);
extern void stdin();
extern void stdout();

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static u64 pc_api_strpmode(i64 mode, i64 size);
static u64 pc_api_getfullname(u64 d, i64 backtick);
static u64 pc_api_addstr(u64 s, u64 t);
static u64 pc_diags_stropnd(u64 p);
static void mc_genmcl_inithandlers();
static u64 mc_libmcl_mgenextname(u64 s);
static u64 mc_stackmcl_stropndstack(i64 indent);
static u64 mc_genss_genrm(i64 reg, i64 opc, u64 b, i64 isxreg);
static void mc_writeasm_strmcl(u64 mcl);
static u64 mc_writeasm_mstropnd(u64 a, i64 sizeprefix, i64 opcode);
static u64 mc_writeasm_strvalue(u64 a);
static u64 mc_writeasm_getregname(i64 reg, i64 size);
static u64 mc_writeasm_getxregname(i64 reg, i64 size);
static u64 mc_writeasm_getdispname(u64 d);
static u64 mc_writeasm_gettempname(u64 d, i64 n);
static void mc_writeexe_writedosstub();
static void mc_writeobj_writerelocs(u64 r, i64 nrelocs);
static u64 mc_writeobj_makesymbol(u64 name, i64 value, i64 sectionno, i64 symtype, i64 storage, i64 naux);
static u64 mc_writeobj_strtoaux(u64 s);
static u64 mc_writeobj_sectiontoaux(u64 data, i64 nrelocs);
static void mm_cli_do_option(i64 sw, u64 value, i64 paramno);
static void mm_assem_initassemsymbols();
static void mm_diags_printunit(u64 p, i64 level, u64 prefix, u64 dev);
static u64 mm_diags_getprefix(i64 level, u64 prefix, u64 p);
static u64 mm_diags_getlineinfok();
static void mm_diags_printmodelist(u64 f);
static void mm_diags_showprojectinfo(u64 dev);
static u64 mm_lib_nextautotype();
static u64 mm_lib_getdottedname(u64 p);
static u64 mm_lib_strmode(i64 m, i64 expand);
static u64 mm_lib_strmode2(i64 m, i64 expand);
static u64 mm_modules_getmodulefilename(u64 path, u64 name, i64 issyslib);
static u64 mm_parse_readcompilervar();
static void mm_type_tpass(u64 p, i64 t, i64 lv);
static void mm_type_setrecordsize(i64 m);
static void mm_type_tx_assign(u64 p, u64 a, u64 b, i64 t);
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_startcon();
static void msysc_m$print_setfmt(u64 format);
static void msysc_m$print_end();
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_newline();
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mlinux_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mlinux_os_init();
static i64 mlinux_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mlinux_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mlinux_os_getch();
static i64 mlinux_os_kbhit();
static void mlinux_os_flushkeys();
static u64 mlinux_os_getconsolein();
static u64 mlinux_os_getconsoleout();
static u64 mlinux_os_proginstance();
static u64 mlinux_os_getdllinst(u64 name);
static u64 mlinux_os_getdllprocaddr(i64 hlib, u64 name);
static void mlinux_os_initwindows();
static i64 mlinux_os_getchx();
static u64 mlinux_os_getos();
static i64 mlinux_os_gethostsize();
static i64 mlinux_os_iswindows();
static i64 mlinux_os_shellexec(u64 opc, u64 file);
static void mlinux_os_sleep(i64 a);
static u64 mlinux_os_getstdout();
static u64 mlinux_os_gethostname();
static u64 mlinux_os_getmpath();
static void mlinux_os_exitprocess(i64 x);
static i64 mlinux_os_clock();
static i64 mlinux_os_ticks();
static i64 mlinux_os_getclockspersec();
static void mlinux_os_setmesshandler(u64 addr);
static i64 mlinux_os_hpcounter();
static i64 mlinux_os_hpfrequency();
static i64 mlinux_os_filelastwritetime(u64 filename);
static void mlinux_os_getsystime(u64 tm);
static void mlinux_os_peek();
static u64 mlinux_os_allocexecmem(i64 n);
static i64 mlinux_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
static u64 pc_api_pcl_start(u64 name, i64 nunits);
static void pc_api_pclerror(u64 mess);
static u64 pc_api_pc_makesymbol(u64 s, i64 id);
static void pc_api_pcl_end();
static void pc_api_pc_gen(i64 opcode, u64 p);
static u64 pc_api_pcl_writepcl(u64 filename);
static u64 pc_diags_writeallpcl();
static u64 pc_api_pcl_writepst(u64 filename);
static u64 pc_diags_writepst();
static void pc_api_pcl_genmcl();
static void mc_genmcl_genmcl(u64 dummy);
static void pc_api_pcl_genss(i64 obj);
static void mc_genss_genss(i64 obj);
static u64 pc_api_pcl_writess(u64 filename, i64 obj);
static u64 mc_writess_dummy_writessdata(i64 fexe);
static u64 pc_api_pcl_writeasm(u64 filename, i64 atype);
static u64 mc_writeasm_getassemstr();
static void pc_api_pcl_writeobj(u64 filename);
static void mc_writeobj_writecoff(u64 outfile);
static void pc_api_pcl_writedll(u64 filename);
static void mc_writeexe_writeexe(u64 outfile, i64 dodll, u64 entrypoint);
static void pc_api_pcl_writeexe(u64 filename);
static void pc_api_pcl_writemx(u64 filename);
static void mx_write_writemcx(u64 filename);
static void pc_api_pcl_exec();
static void mx_run_runlibfile(u64 filename, i64 cmdskip);
static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames);
static void pc_api_extendpclblock();
static u64 pc_api_newpcl();
static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset);
static void pc_api_pc_genx(i64 opcode, i64 x, u64 p);
static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p);
static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p);
static u64 pc_api_genint(i64 a);
static u64 pc_api_genreal(r64 x, i64 mode);
static u64 pc_api_genrealimm(r64 x, i64 mode);
static u64 pc_api_genstring(u64 s);
static u64 pc_api_genpcstrimm(u64 s);
static u64 pc_api_genlabel(i64 a);
static u64 pc_api_genmem(u64 d);
static u64 pc_api_genmemaddr(u64 d);
static u64 pc_api_gendata(u64 s, i64 length);
static void pc_api_gencomment(u64 s);
static u64 pc_api_genname(u64 s);
static u64 pc_api_gennameaddr(u64 s);
static u64 pc_api_genassem(u64 code);
static void pc_api_pc_setmode(i64 m, i64 size);
static void pc_api_pc_setmode2(i64 m);
static void pc_api_pc_setxy(i64 x, i64 y);
static void pc_api_pc_setscaleoff(i64 scale, i64 offset);
static void pc_api_pc_setoffset(i64 offset);
static void pc_api_pc_addoffset(i64 offset);
static void pc_api_pc_setincr(i64 n);
static void pc_api_pc_setnargs(i64 n);
static void pc_api_pc_setnvariadics(i64 n);
static void pc_api_pc_setalign(i64 n);
static void pc_api_perror(u64 mess);
static void pc_api_perror_s(u64 mess, u64 param);
static u64 pc_api_getbasename(u64 s);
static void pc_api_pc_addsymbol(u64 d);
static void pc_api_pcerrorstop(u64 filename, i64 lineno);
static void pc_api_pc_addplib(u64 name);
static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded);
static void pc_api_pc_setimport(u64 d);
static void pc_api_pc_addparam(u64 d);
static void pc_api_pc_addlocal(u64 d);
static void pc_api_pc_endproc();
static void pc_api_merror(u64 mess, u64 param);
static u64 pc_api_pc_duplpst(u64 d);
static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip);
static i64 pc_api_convertstring(u64 s, u64 t);
static void pc_diags_strpcl(u64 p);
static void pc_diags_strlabel(i64 labelno, i64 colon);
static void pc_diags_psstr(u64 s);
static void pc_diags_psname(u64 d);
static void pc_diags_psline();
static void pc_diags_psstrline(u64 s);
static void pc_diags_psdata(u64 p);
static void pc_diags_pstabto(i64 n);
static u64 pc_diags_strpclstr(u64 p, i64 buffsize);
static void pc_diags_writepcl(u64 p);
static void pc_diags_psint(i64 a);
static void pc_diags_psopnd(u64 p);
static void pc_diags_writepsymbol(u64 d, u64 fmt);
static void pc_diags_showprocinfo(u64 d);
static void pc_reduce_pcl_reducetest();
static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain);
static i64 pc_runaux_pci_getopnd(u64 p, u64 locals);
static i64 pc_runaux_pci_loadptr(u64 p, i64 mode);
static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size);
static void pc_runaux_pcusopnd(u64 p);
static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j);
static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x);
static i64 pc_run_getlineno(u64 pc);
static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param);
static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode);
static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y);
static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y);
static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y);
static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals);
static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode);
static void pc_run_fixuppcl();
static u64 pc_runaux_getdllfnptr(u64 d);
static void pc_run_pcl_runpcl();
static void pc_runaux_loadlibs();
static void pc_runaux_docmdskip();
static void mc_libmcl_mclinit(i64 bypass);
static void mc_genmcl_convertpcl(u64 p);
static void mc_stackmcl_showopndstack();
static void mc_auxmcl_genrealtable();
static void mc_auxmcl_genabsneg();
static void mc_auxmcl_genstringtable();
static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b);
static void mc_optim_peephole();
static void mc_genmcl_unimpl(u64 p);
static void mc_genmcl_doshowpcl(u64 p);
static void mc_libmcl_mgencomment(u64 s);
static void mc_genmcl_px_nop(u64 p);
static void mc_genmcl_px_dupl(u64 p);
static void mc_stackmcl_duplpcl();
static void mc_genmcl_px_double(u64 p);
static void mc_genmcl_px_opnd(u64 p);
static void mc_genmcl_px_type(u64 p);
static void mc_genmcl_px_comment(u64 p);
static void mc_genmcl_px_proc(u64 p);
static void mc_libmcl_setsegment(i64 seg, i64 align);
static u64 mc_libmcl_mgenmemaddr(u64 d);
static void mc_auxmcl_initproc(u64 d);
static void mc_auxmcl_fixmain();
static void mc_genmcl_px_endproc(u64 p);
static void mc_genmcl_px_endprog(u64 p);
static void mc_genmcl_px_istatic(u64 p);
static void mc_genmcl_px_zstatic(u64 p);
static u64 mc_libmcl_mgenint(i64 x, i64 mode);
static void mc_genmcl_px_data(u64 p);
static void mc_auxmcl_do_blockdata(u64 p);
static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode);
static i64 mc_libmcl_getstringindex(u64 s);
static u64 mc_libmcl_mgenlabel(i64 x);
static void mc_genmcl_px_label(u64 p);
static void mc_genmcl_px_load(u64 p);
static void mc_stackmcl_pushpcl(u64 p);
static void mc_genmcl_px_store(u64 p);
static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg);
static u64 mc_libmcl_mgenmem(u64 d, i64 mode);
static u64 mc_stackmcl_getworkregm(i64 mode);
static u64 mc_stackmcl_makeopndind(u64 a, i64 mode);
static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest);
static void mc_stackmcl_poppcl();
static void mc_genmcl_px_add(u64 p);
static u64 mc_stackmcl_isimmload(i64 n);
static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_sub(u64 p);
static void mc_genmcl_px_mul(u64 p);
static void mc_auxmcl_mulimm(u64 ax, i64 n);
static void mc_genmcl_px_div(u64 p);
static void mc_genmcl_px_eval(u64 p);
static void mc_genmcl_px_widen(u64 p);
static void mc_stackmcl_setnewzz(i64 reg, i64 mode);
static void mc_genmcl_px_jump(u64 p);
static void mc_genmcl_px_ijump(u64 p);
static void mc_genmcl_px_neg(u64 p);
static void mc_auxmcl_do_negreal(u64 ax, i64 mode);
static void mc_genmcl_px_abs(u64 p);
static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b);
static void mc_auxmcl_do_absreal(u64 ax, i64 mode);
static void mc_genmcl_px_bitnot(u64 p);
static void mc_genmcl_px_not(u64 p);
static u64 mc_libmcl_changeopndsize(u64 a, i64 size);
static void mc_genmcl_px_toboolt(u64 p);
static void mc_genmcl_px_sqr(u64 p);
static void mc_genmcl_px_sqrt(u64 p);
static void mc_genmcl_px_jumpcc(u64 p);
static void mc_genmcl_px_jumpt(u64 p);
static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond);
static void mc_genmcl_px_jumpf(u64 p);
static void mc_genmcl_px_bitand(u64 p);
static void mc_auxmcl_do_bitwise(u64 p, i64 opc);
static void mc_genmcl_px_bitor(u64 p);
static void mc_genmcl_px_bitxor(u64 p);
static void mc_genmcl_px_shl(u64 p);
static void mc_auxmcl_do_shift(u64 p, i64 opc);
static void mc_genmcl_px_shr(u64 p);
static void mc_genmcl_px_retproc(u64 p);
static void mc_auxmcl_do_procentry(u64 p);
static void mc_auxmcl_do_procexit();
static void mc_genmcl_px_retfn(u64 p);
static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset);
static u64 mc_libmcl_mgenreg(i64 reg, i64 mode);
static void mc_genmcl_px_setcall(u64 p);
static void mc_stackmcl_saveopnds(i64 n);
static void mc_libmcl_pushslots(i64 nslots);
static void mc_genmcl_px_setarg(u64 p);
static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno);
static void mc_stackmcl_pushopnd(i64 n, i64 mode);
static void mc_genmcl_px_callp(u64 p);
static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr);
static void mc_libmcl_popslots(i64 nslots);
static void mc_auxmcl_do_getretvalue(u64 p);
static void mc_genmcl_px_jumpret(u64 p);
static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_jumpretm(u64 p);
static void mc_stackmcl_movetoreg(i64 newreg);
static void mc_genmcl_px_startmx(u64 p);
static void mc_genmcl_px_resetmx(u64 p);
static void mc_genmcl_px_stop(u64 p);
static void mc_genmcl_px_incrto(u64 p);
static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrto(u64 p);
static void mc_genmcl_px_incrload(u64 p);
static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrload(u64 p);
static void mc_genmcl_px_loadincr(u64 p);
static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_loaddecr(u64 p);
static void mc_genmcl_px_forup(u64 p);
static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond);
static void mc_genmcl_px_fordown(u64 p);
static void mc_genmcl_px_iload(u64 p);
static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode);
static i64 mc_genmcl_getsharereg(u64 ax, i64 mode);
static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode);
static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode);
static void mc_auxmcl_dolea(u64 ax, u64 px);
static void mc_genmcl_px_iloadx(u64 p);
static u64 mc_auxmcl_do_addrmode(u64 p);
static void mc_genmcl_px_istore(u64 p);
static u64 mc_stackmcl_makesimpleaddr(u64 ax);
static void mc_genmcl_px_istorex(u64 p);
static void mc_genmcl_px_storem(u64 p);
static u64 mc_libmcl_newblocktemp(i64 size);
static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size);
static void mc_genmcl_px_addpx(u64 p);
static void mc_genmcl_px_subpx(u64 p);
static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale);
static void mc_genmcl_px_to(u64 p);
static void mc_genmcl_px_iswap(u64 p);
static void mc_genmcl_px_swapstk(u64 p);
static void mc_stackmcl_swapopnds(i64 m, i64 n);
static void mc_genmcl_px_labeldef(u64 p);
static void mc_genmcl_px_addto(u64 p);
static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc);
static void mc_genmcl_px_subto(u64 p);
static void mc_genmcl_px_multo(u64 p);
static void mc_auxmcl_do_binto_float(u64 p, i64 opc);
static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg);
static void mc_genmcl_px_bitandto(u64 p);
static void mc_genmcl_px_bitorto(u64 p);
static void mc_genmcl_px_bitxorto(u64 p);
static void mc_genmcl_px_shlto(u64 p);
static void mc_auxmcl_do_shiftnto(u64 p, i64 opc);
static void mc_genmcl_px_shrto(u64 p);
static void mc_genmcl_px_fix(u64 p);
static void mc_genmcl_px_float(u64 p);
static i64 mc_libmcl_mcreatefwdlabel();
static void mc_libmcl_mdefinefwdlabel(i64 lab);
static u64 mc_libmcl_mgenlabelmem(i64 x);
static void mc_genmcl_px_idiv(u64 p);
static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv);
static void mc_genmcl_px_irem(u64 p);
static void mc_genmcl_px_idivrem(u64 p);
static void mc_genmcl_px_clear(u64 p);
static void mc_auxmcl_clearblock(u64 ax, i64 n);
static void mc_genmcl_px_subp(u64 p);
static i64 mc_libmcl_ispoweroftwo(i64 x);
static void mc_genmcl_px_switch(u64 p);
static i64 mc_stackmcl_getworkireg();
static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def);
static void mc_genmcl_px_switchu(u64 p);
static void mc_genmcl_px_swlabel(u64 p);
static void mc_genmcl_px_endsw(u64 p);
static void mc_genmcl_px_fwiden(u64 p);
static void mc_genmcl_px_fnarrow(u64 p);
static void mc_genmcl_px_truncate(u64 p);
static void mc_genmcl_px_typepun(u64 p);
static void mc_genmcl_px_unload(u64 p);
static void mc_genmcl_px_loadbit(u64 p);
static void mc_genmcl_px_assem(u64 p);
static void mc_genmcl_px_sin(u64 p);
static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs);
static void mc_genmcl_px_cos(u64 p);
static void mc_genmcl_px_tan(u64 p);
static void mc_genmcl_px_asin(u64 p);
static void mc_genmcl_px_acos(u64 p);
static void mc_genmcl_px_atan(u64 p);
static void mc_genmcl_px_log(u64 p);
static void mc_genmcl_px_log10(u64 p);
static void mc_genmcl_px_exp(u64 p);
static void mc_genmcl_px_round(u64 p);
static void mc_genmcl_px_floor(u64 p);
static void mc_genmcl_px_ceil(u64 p);
static void mc_genmcl_px_atan2(u64 p);
static void mc_genmcl_px_fmod(u64 p);
static void mc_genmcl_px_setcc(u64 p);
static void mc_genmcl_px_min(u64 p);
static void mc_auxmcl_do_max_int(i64 cond);
static void mc_auxmcl_do_max_float(i64 opc);
static void mc_genmcl_px_max(u64 p);
static void mc_genmcl_px_power(u64 p);
static u64 mc_auxmcl_gethostfn(i64 opc);
static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs);
static void mc_genmcl_px_minto(u64 p);
static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode);
static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode);
static void mc_genmcl_px_maxto(u64 p);
static void mc_genmcl_px_negto(u64 p);
static void mc_genmcl_px_absto(u64 p);
static void mc_genmcl_px_addpxto(u64 p);
static void mc_genmcl_px_subpxto(u64 p);
static void mc_genmcl_px_divto(u64 p);
static void mc_genmcl_px_bitnotto(u64 p);
static void mc_genmcl_px_notto(u64 p);
static void mc_genmcl_px_toboolto(u64 p);
static void mc_genmcl_px_sign(u64 p);
static void mc_libmcl_clearreg(u64 ax);
static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode);
static void mc_genmcl_px_loadbf(u64 p);
static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j);
static void mc_auxmcl_do_loadbf_var(u64 p);
static void mc_genmcl_px_storebit(u64 p);
static void mc_auxmcl_do_storebit(u64 p);
static void mc_genmcl_px_storebf(u64 p);
static void mc_auxmcl_do_storebf(u64 p);
static void mc_genmcl_px_loadall(u64 p);
static void mc_stackmcl_checkallloaded();
static void mc_genmcl_px_setjmp(u64 p);
static void mc_stackmcl_freeworkregs(u64 p);
static void mc_genmcl_px_longjmp(u64 p);
static void mc_stackmcl_swapopndregs(i64 reg2);
static void mc_genmcl_px_initdswx(u64 p);
static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf);
static void mc_auxmcl_setmclentry(u64 p);
static u64 mc_libmcl_mgenname(u64 s);
static i64 mc_libmcl_roundsizetg(i64 size);
static u64 mc_auxmcl_resetmclentry();
static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size);
static void mc_auxmcl_spillparams();
static void mc_auxmcl_setmclentryf(u64 p);
static void mc_libmcl_pushstack(i64 n);
static u64 mc_auxmcl_resetmclentryf();
static void mc_libmcl_popstack(i64 n);
static i64 mc_auxmcl_ismemaddr(i64 n);
static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n);
static void mc_auxmcl_saverdx();
static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz);
static void mc_auxmcl_restorerdx();
static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype);
static void mc_auxmcl_gendb(i64 a);
static void mc_auxmcl_gendbstring(u64 s, i64 length);
static u64 mc_libmcl_mgenstring(u64 s, i64 length);
static void mc_auxmcl_gendq(i64 a);
static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs);
static u64 mc_libmcl_mgenreg0(i64 reg, i64 size);
static u64 mc_libmcl_newmclopnd();
static void mc_libmcl_initmcdest();
static u64 mc_libmcl_mgenint0(i64 x, i64 size);
static void mc_libmcl_genmc_str(i64 opcode, u64 s);
static u64 mc_libmcl_duplopnd(u64 a);
static i64 mc_libmcl_getrealindex(r64 x);
static i64 mc_libmcl_getr32index(r64 x);
static u64 mc_libmcl_mgenxregvar(u64 d);
static u64 mc_libmcl_mgenregvar(u64 d, i64 mode);
static u64 mc_libmcl_mgenregi(i64 reg, i64 mode);
static u64 mc_libmcl_mgentemp(i64 n, i64 mode);
static void mc_libmcl_merroropnd(u64 mess, i64 opndtype);
static u64 mc_libmcl_findnamesym(u64 s);
static void mc_libmcl_addnamesym(u64 d);
static i64 mc_libmcl_getprimreg(u64 ax);
static i64 mc_libmcl_addconst(u64 clist, i64 value);
static void mc_libmcl_axerror(u64 mess);
static void mc_libmcl_callproc(u64 cpname, u64 name, i64 lineno);
static u64 mc_libmcl_mgenstringx(u64 s);
static i64 mc_stackmcl_getworkreg(i64 mode);
static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg);
static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg);
static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax);
static void mc_stackmcl_savenextopnd();
static i64 mc_stackmcl_getworkxreg();
static void mc_stackmcl_saveopnd(i64 n, i64 allregs);
static void mc_stackmcl_savenextxopnd();
static i64 mc_optim_isreg0(u64 a);
static i64 mc_optim_endr0(u64 m);
static i64 mc_optim_isreg10(u64 a);
static i64 mc_optim_isreg(u64 a);
static u64 mc_optim_deletemcl(u64 p);
static i64 mc_optim_isconst(u64 a);
static i64 mc_optim_isreg00(u64 m);
static i64 mc_optim_sameoperand(u64 a, u64 b);
static i64 mc_optim_sameregopnd(u64 a, u64 b);
static void mc_genss_initlib(i64 nlabels);
static u64 mc_genss_buffercreate(i64 size);
static void mc_genss_switchseg(i64 newseg);
static void mc_genss_doinstr(u64 m, i64 index);
static i64 mc_genss_bufferlength(u64 a);
static u64 mc_genss_bufferelemptr(u64 a, i64 offset);
static void mc_genss_bufferexpand(u64 a);
static i64 mc_genss_getcurrdatalen(i64 id);
static i64 mc_genss_getstindex(u64 d);
static void mc_genss_dofwdrefs(u64 d);
static void mc_genss_do_call(u64 a);
static void mc_genss_do_jmp(u64 a, u64 m);
static u64 mc_genss_getdef(u64 a, i64 dneeded);
static i64 mc_genss_getrel32(u64 d, i64 offset);
static void mc_genss_gendword(i64 x);
static i64 mc_genss_checkshortjump(u64 m, u64 d);
static void mc_genss_genrel32(u64 a);
static void mc_genss_genrel8(u64 a);
static void mc_genss_genopnd(u64 a, i64 size);
static void mc_genss_genword(i64 x);
static void mc_genss_do_push(u64 a);
static void mc_genss_do_pop(u64 a);
static void mc_genss_do_inc(u64 a, i64 code);
static void mc_genss_do_neg(u64 a, i64 code);
static void mc_genss_do_arith(u64 a, u64 b, i64 code);
static void mc_genss_do_mov(u64 a, u64 b);
static void mc_genss_do_lea(u64 a, u64 b);
static void mc_genss_do_movsx(u64 a, u64 b, i64 opc);
static void mc_genss_do_movsxd(u64 a, u64 b);
static void mc_genss_do_exch(u64 a, u64 b);
static void mc_genss_do_imul2(u64 a, u64 b);
static void mc_genss_buffercheck(u64 a, i64 n);
static void mc_genss_do_shift(u64 a, u64 b, i64 code);
static void mc_genss_do_test(u64 a, u64 b);
static void mc_genss_do_loop(u64 a, i64 opc);
static void mc_genss_do_jcxz(u64 a, i64 opsize);
static void mc_genss_do_setcc(i64 cond, u64 b);
static void mc_genss_do_movxmm(u64 a, u64 b, i64 size);
static void mc_genss_do_arithxmm(u64 a, u64 b, i64 prefix, i64 opc);
static void mc_genss_do_logicxmm(u64 a, u64 b, i64 opc, i64 size);
static void mc_genss_do_convertfloat(u64 a, u64 b, i64 prefix);
static void mc_genss_do_fix(u64 a, u64 b, i64 prefix, i64 opc);
static void mc_genss_do_float(u64 a, u64 b, i64 prefix);
static void mc_genss_do_cmovcc(i64 cond, u64 a, u64 b);
static void mc_genss_do_fmem(u64 a, i64 freal, i64 code);
static void mc_genss_do_movdqx(u64 a, u64 b, i64 prefix);
static void mc_genss_do_popcnt(u64 a, u64 b);
static void mc_genss_do_bsf(u64 a, u64 b, i64 opc);
static void mc_genss_do_bswap(u64 a);
static void mc_genss_do_dshift(u64 a, u64 b, i64 c, i64 opc);
static void mc_genss_start();
static void mc_genss_addword(u64 a, i64 x);
static void mc_genss_adddword(u64 a, i64 x);
static void mc_genss_genqword(i64 x);
static void mc_genss_addqword(u64 a, i64 x);
static void mc_genss_genabs32(u64 a);
static void mc_genss_genabs64(u64 a);
static void mc_genss_addrelocitem(i64 reloctype, u64 d);
static void mc_genss_extendsymboltable();
static u64 mc_genss_addfwdref(u64 p, i64 offset, i64 reltype, i64 seg);
static void mc_genss_genrex();
static i64 mc_genss_isbytesized(i64 x);
static i64 mc_genss_isdwordsized(i64 x);
static void mc_genss_genamode(u64 a, u64 am);
static void mc_genss_setopsize(u64 a);
static i64 mc_genss_getdispsize(u64 a, u64 offset);
static void mc_genss_checkhighreg(u64 a);
static void mc_genss_genxrm(i64 opcode, i64 code, u64 b);
static void mc_genss_genrrm(i64 opcode, u64 a, u64 b);
static i64 mc_genss_getregcode(i64 reg, i64 mask, i64 isxreg);
static void mc_genss_checkimmrange(i64 value, i64 size);
static u64 mc_writeasm_strmclstr(u64 m);
static void mc_genss_fixrip(i64 dispsize);
static void mc_genss_checksize(u64 a, i64 size1, i64 size2);
static void mc_decls_start();
static void mc_writeasm_writemcl(i64 index, u64 mcl);
static void mc_writeasm_asmstr(u64 s);
static void mc_writeasm_asmchar(i64 c);
static void mc_writeasm_asmopnd(u64 a, i64 sizeprefix, i64 opcode);
static i64 mc_writeasm_needsizeprefix(i64 opcode, u64 a, u64 b);
static u64 mc_writeasm_strreg(i64 reg, i64 size);
static u64 mc_writeasm_getsizeprefix(i64 size, i64 enable);
static u64 mc_writeasm_strxreg(i64 reg, i64 size);
static void mc_writeasm_start();
static void mc_writeexe_genexe1(u64 entrypoint, u64 outfile, i64 dodll);
static void mc_writeexe_genexe2(u64 outfile, i64 dodll);
static void mc_writeexe_initsectiontable();
static void mc_writeexe_loadlibs();
static void mc_writeexe_scanst();
static void mc_writeexe_getoffsets();
static void mc_writeexe_relocdata(u64 s);
static i64 mc_writeexe_getripoffset(i64 addr, i64 dest, i64 extra);
static void mc_writeexe_writepesig();
static void mc_writeexe_writefileheader();
static void mc_writeexe_writeoptheader();
static void mc_writeexe_writesectionheader(u64 s);
static void mc_writeexe_writepadding(i64 offset);
static void mc_writeexe_writesectiondata(u64 s);
static u64 mc_writeexe_extractlibname(u64 name, u64 libno, i64 moduleno);
static void mc_writeexe_getbaserelocs(u64 s);
static void mc_writeexe_newbasereloc(i64 addr, i64 reltype);
static void mc_writeexe_writerecordx(u64 r, i64 length);
static void mc_writeexe_writeexporttable(u64 pstart);
static void mc_writeexe_sortexports(u64 sortindex);
static i64 mc_writeexe_getsectionno(i64 segment);
static i64 mc_writeexe_getexporttablesize();
static void mc_writeexe_scanbaserelocs();
static void mc_writeexe_writebasereloctable(u64 pstart);
static void mc_writeobj_initsymboltable(u64 filename);
static void mc_writeobj_convertsymboltable();
static void mc_writeobj_writerecord(u64 r, i64 length);
static void mc_writeobj_writedata(u64 data);
static void mc_writeobj_writesymboltable();
static void mc_writeobj_writestringtable();
static i64 mc_writeobj_addstringentry(u64 s, i64 length);
static void mc_writeobj_addsymbol(u64 r);
static u64 mx_run_writememlib(u64 filename);
static void mx_run_roundsegment(u64 p, i64 align, i64 value);
static void mx_run_countsymbols();
static void mx_run_writerelocs(u64 lib);
static void mx_run_addsymbols(u64 lib);
static void mx_lib_loadmemmcu(u64 lib);
static void mx_lib_fixuplib(u64 lib);
static void mx_lib_runprogram(u64 lib, i64 cmdskip);
static u64 mx_lib_readlibfile(u64 filespec, u64 p);
static u64 mx_lib_readu32(u64 p);
static i64 mx_lib_readbyte(u64 p);
static u64 mx_lib_readstring(u64 p);
static void mx_lib_alloclibdata(u64 lib);
static void mx_lib_error(u64 mess, u64 param);
static void mx_lib_checknew(u64 name, u64 filename);
static i64 mx_lib_mxaddlib(u64 name);
static void mx_lib_loadimports(u64 plib);
static i64 mx_lib_findlib(u64 name);
static void mx_lib_loaddlls();
static void mx_lib_checksymbols();
static void mx_lib_dorelocations();
static u64 mx_lib_finddllsymbol(u64 name, u64 dllindex);
static void mx_lib_reloclib(u64 lib);
static void mx_lib_dosublib(u64 name);
static void mx_lib_dosymbols(u64 lib);
static u64 mx_lib_loadlibfile(u64 filename, i64 libno);
static u64 mx_lib_readmxfile(u64 filename);
static void mx_lib_adddll(u64 name);
static i64 mx_lib_addsymbol(u64 name);
static void mx_lib_setspecialglobals(i64 cmdskip);
static void mx_lib_calllibinit(u64 lib);
static u64 mx_lib_findsymbol(u64 name);
static u64 mx_lib_loadmx(u64 filename);
static u64 mx_lib_loadmemmcb(u64 filename, u64 p);
static void mx_write_roundsegment(u64 p, i64 align, i64 value);
static void mx_write_genu32(i64 x);
static void mx_write_genbyte(i64 x);
static void mx_write_genstring(u64 s);
static void mx_write_writerelocs();
static void mx_write_genblock(u64 p, i64 length);
static void mx_write_writesymbols();
void mm_main();
static void pcl_start();
static void mm_start();
static void mm_cli_main2();
static void mm_cli_initdata();
static void mm_cli_getinputoptions();
static void mm_cli_production_compiler();
static void mm_cli_debug_compiler();
static void mm_modules_loadproject(u64 file);
static void mm_cli_do_parse(i64 flog);
static void mm_cli_do_name(i64 flog);
static void mm_cli_do_type(i64 flog);
static void mm_cli_do_genpcl(i64 flog);
static void mm_cli_do_genmcl(i64 flog);
static void mm_diags_showtimings();
static void mm_diags_showlogfile();
static void mm_cli_showcompilemess();
static void mm_support_do_writema(u64 inpfile);
static void mm_support_do_getinfo(u64 filename);
static void mm_cli_do_writeexports();
static i64 mm_parse_parsemodule(u64 pm);
static void mm_name_fixusertypes();
static void mm_cli_fixstartprocs();
static void mm_diags_showast(u64 filename);
static void mm_name_rx_typetable();
static i64 mm_name_rx_module(i64 n);
static void mm_type_tx_typetable();
static i64 mm_type_tx_module(i64 n);
static void mm_type_tx_allprocs();
static void mm_cli_do_genc();
static void mm_genpcl_codegen_il(u64 dummy);
static void mm_lib_writegsfile(u64 filename, u64 d);
static void mm_lex_lexsetup();
static void mm_support_init_tt_tables();
static void mm_support_initbblib();
static u64 mm_lex_addnamestr(u64 name);
static u64 mm_lib_createdupldef(u64 owner, u64 symptr, i64 id);
static i64 mm_support_mgetsourceinfo(i64 pos, u64 filename, u64 sourceline);
static void mm_assemaux_domcl_assem(u64 pcode);
static u64 mm_genpcl_findhostfn(i64 opc);
static i64 mm_assemaux_checkasmlabel(u64 p);
static void mm_support_loaderror(u64 mess, u64 mess2, u64 mess3);
static void mm_cli_showcaption();
static void mm_cli_showhelp();
static void mm_export_dummy_writeexports(u64 basefile, u64 modulename);
static u64 mm_cli_getoutfilename(u64 file, u64 ext);
static u64 mm_cli_addstartproc(u64 owner, u64 name, i64 scope, i64 moduleno);
static u64 mm_lib_getduplnameptr(u64 owner, u64 symptr, i64 id);
static u64 mm_parse_makeblock(u64 p);
static void mm_lib_adddef(u64 owner, u64 p);
static void mm_lib_addtoproclist(u64 d);
static void mm_genpcl_dolibs();
static void mm_genpcl_dostaticvar(u64 d);
static void mm_genpcl_gendllproc(u64 p);
static void mm_genpcl_genprocdef(u64 p);
static void mm_genpcl_scanprocs();
static void mm_genpcl_genmaindef(u64 p);
static void mm_genpcl_genstartdef(u64 p);
static void mm_genpcl_doprocdef(u64 d, i64 ismain);
static i64 mm_genpcl_createfwdlabel();
static void mm_blockpcl_evalunit(u64 p);
static void mm_genpcl_definefwdlabel(i64 lab);
static void mm_genpcl_genreturn();
static u64 mm_libpcl_getpsymbol(u64 d);
static u64 mm_genpcl_genmem_d(u64 d);
static void mm_libpcl_setmode(i64 mode);
static i64 mm_lib_getalignment(i64 m);
static void mm_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset);
static void mm_support_gerror(u64 mess, u64 p);
static i64 mm_lib_getpclmode(i64 t);
static void mm_libpcl_setmode_u(u64 p);
static u64 mm_genpcl_genmemaddr_d(u64 d);
static void mm_support_gerror_s(u64 mess, u64 s, u64 p);
static u64 mm_genpcl_genmem_u(u64 p);
static void mm_genpcl_genpushmem_d(u64 d);
static void mm_genpcl_genpushmemaddr_d(u64 d);
static i64 mm_genpcl_definelabel();
static i64 mm_genpcl_reversecond(i64 cc);
static i64 mm_genpcl_reversecond_order(i64 cc);
static void mm_genpcl_stacklooplabels(i64 a, i64 b, i64 c);
static i64 mm_genpcl_findlooplabel(i64 k, i64 n);
static void mm_genpcl_genpc_sysfn(i64 fnindex, u64 a, u64 b, u64 c);
static void mm_genpcl_genpc_sysproc(i64 fnindex, u64 a, u64 b, u64 c, i64 asfunc);
static void mm_genpcl_pushsysarg(u64 p, i64 n, u64 nargs);
static u64 mm_genpcl_getsysfnhandler(i64 fn);
static void mm_genpcl_start();
static void mm_genpcl_genpushint(i64 a);
static void mm_genpcl_genpushreal(r64 x, i64 mode);
static void mm_genpcl_genpushstring(u64 s);
static void mm_genpcl_docallproc(u64 d);
static void mm_genpcl_initstaticvar(u64 d);
static void mm_genpcl_setfunctab();
static u64 mm_libpcl_getequivdef(u64 d);
static void mm_libpcl_setmode2(i64 mode);
static void mm_blockpcl_do_const(u64 p);
static void mm_blockpcl_do_name(u64 p);
static void mm_blockpcl_do_block(u64 p);
static void mm_blockpcl_do_callproc(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_return(u64 p, u64 a);
static void mm_blockpcl_do_returnmult(u64 p, u64 a);
static void mm_blockpcl_do_assign(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_assignms(u64 a, u64 b);
static void mm_blockpcl_do_assignmm(u64 a, u64 b);
static void mm_blockpcl_do_assignmdrem(u64 a, u64 b);
static void mm_blockpcl_do_to(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 isref);
static void mm_blockpcl_do_for(u64 p, u64 pindex, u64 pfrom, u64 pbody, i64 down);
static void mm_blockpcl_do_forall(u64 p, u64 pindex, u64 plist, u64 pbody, i64 down);
static void mm_blockpcl_do_while(u64 p, u64 pcond, u64 pbody, u64 pincr);
static void mm_blockpcl_do_repeat(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_goto(u64 a);
static void mm_blockpcl_do_labeldef(u64 p);
static void mm_blockpcl_do_exit(u64 p, i64 k);
static void mm_blockpcl_do_do(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_case(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 loopsw, i64 isref);
static void mm_blockpcl_do_switch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 isref);
static void mm_blockpcl_do_recase(u64 p, u64 a);
static void mm_blockpcl_do_swap(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_select(u64 p, u64 a, u64 b, u64 c, i64 isref);
static void mm_blockpcl_do_print(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_read(u64 p, u64 a);
static void mm_blockpcl_do_readln(u64 a);
static void mm_blockpcl_do_stop(u64 p, u64 a);
static void mm_blockpcl_do_andl(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_orl(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_setcc(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_setccchain(u64 p, u64 q);
static void mm_blockpcl_do_bin(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_index(u64 p, u64 parray, u64 pindex);
static void mm_blockpcl_do_dotindex(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_dotslice(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_dot(u64 pdot);
static void mm_blockpcl_do_ptr(u64 p, u64 a);
static void mm_blockpcl_evalref(u64 p, u64 q);
static void mm_blockpcl_do_convert(u64 p, u64 a);
static void mm_blockpcl_do_typepun(u64 p, u64 a);
static void mm_blockpcl_do_shorten(u64 p, u64 a);
static void mm_blockpcl_do_typeconst(u64 p);
static void mm_blockpcl_do_unary(u64 p, u64 a);
static void mm_blockpcl_do_notl(u64 p, u64 a);
static void mm_blockpcl_do_istruel(u64 p, u64 a);
static void mm_blockpcl_do_isfalsel(u64 p, u64 a);
static void mm_blockpcl_do_incr(u64 p, u64 a);
static void mm_blockpcl_do_incrload(u64 p, u64 a);
static void mm_blockpcl_do_binto(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_unaryto(u64 p, u64 a);
static void mm_blockpcl_do_syscall(u64 p, u64 a);
static void mm_blockpcl_do_empty(u64 p, u64 a);
static void mm_blockpcl_do_slice(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_indexref(u64 parray, u64 pindex);
static void mm_blockpcl_do_dotref(u64 pdot);
static void mm_blockpcl_evalarray(u64 p);
static void mm_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab);
static void mm_blockpcl_gcomparejump(i64 jumpopc, i64 cond, u64 lhs, u64 rhs, i64 lab);
static void mm_blockpcl_genjumpl(i64 lab);
static void mm_blockpcl_unimpl(u64 mess);
static void mm_blockpcl_do_assignblock(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_storeindex(u64 p, u64 parray, u64 pindex, u64 rhs);
static void mm_blockpcl_do_storedot(u64 pdot, u64 pfield, u64 rhs);
static void mm_blockpcl_do_setinplace();
static void mm_blockpcl_docond(i64 opc, u64 p, i64 lab);
static void mm_blockpcl_setincrstep(i64 m);
static u64 mm_lib_getavname(u64 owner, i64 id);
static u64 mm_lib_createname(u64 p);
static i64 mm_blockpcl_checkdotchain(u64 p, u64 pname);
static i64 mm_lib_createrefmode(u64 owner, i64 target, i64 typedefx);
static i64 mm_blockpcl_getindexoffset(u64 parray, u64 pindex);
static u64 mm_lib_strexpr(u64 p);
static void mm_blockpcl_do_assignarray(u64 a, u64 b);
static void mm_blockpcl_do_assignrecord(u64 a, u64 b);
static u64 mm_lib_createconstunit(u64 a, i64 t);
static u64 mm_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 mm_lib_createunit0(i64 tag);
static void mm_blockpcl_pushrhs(u64 a);
static void mm_blockpcl_poptomult(u64 a);
static u64 mm_lib_getprocretmodes(u64 p);
static u64 mm_assem_readassemline();
static void mm_lex_lex();
static u64 mm_assem_assembleline(i64 oneline);
static u64 mm_assem_readassemblock();
static void mm_support_serror(u64 mess);
static void mm_parse_checkend(i64 endsym, i64 endkwd1, i64 endkwd2, i64 startline);
static void mm_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static void mm_parse_lexchecksymbol(i64 symbol);
static u64 mm_parse_readunit();
static void mm_lex_ps(u64 caption);
static u64 mm_assem_readassemopnd();
static void mm_parse_checksymbol(i64 symbol);
static u64 mm_lib_createunit1(i64 tag, u64 p);
static void mm_lex_addreservedword(u64 name, i64 symbol, i64 subcode, i64 regsize);
static u64 mm_assemaux_genasmopnd(u64 p);
static i64 mm_assemaux_fixasmlabel(u64 d);
static void mm_diags_printst(u64 f, u64 p, i64 level);
static void mm_diags_printstrec(u64 f, u64 p, i64 level);
static void mm_diags_printstflat(u64 f);
static void mm_diags_printcode(u64 f, u64 caption);
static i64 mm_support_getlineno(u64 pos);
static u64 mm_lib_typename(i64 m);
static void mm_diags_printunitlist(u64 dev, u64 p, i64 level, u64 prefix);
static void mm_lib_addtolog(u64 filename, u64 logdest);
static void mm_diags_showsttree(u64 caption, u64 f);
static void mm_diags_showstflat(u64 caption, u64 f);
static void mm_diags_printsymbol(u64 lp);
static void mm_lex_printstrn(u64 s, i64 length);
static void mm_diags_showtime(u64 caption, i64 t);
static void mm_lex_lexreadtoken();
static void mm_lex_doinclude();
static void mm_support_lxerror(u64 mess);
static i64 mm_lex_setinttype(u64 a);
static void mm_lex_readrawstring();
static void mm_lex_readarraystring(i64 prefix);
static void mm_lex_lookup(u64 name, i64 length, i64 hashindex);
static void mm_lex_readhex();
static void mm_lex_readbin();
static void mm_lex_readdec();
static void mm_lex_lxreadstring(i64 termchar);
static void mm_lex_readrawxname();
static void mm_lex_unstacksource();
static void mm_lex_inithashtable();
static i64 mm_lex_lookupsys(u64 name);
static i64 mm_lex_gethashvaluez(u64 s);
static void mm_lex_printhashtable();
static u64 mm_support_getsupportfile(u64 filename, u64 ext, u64 path);
static void mm_lex_stacksource(i64 fileno, i64 isimport);
static void mm_lex_startlex(u64 file);
static void mm_lex_psnext(u64 caption);
static void mm_lex_psx(u64 caption);
static void mm_lex_lxerror_s(u64 mess, u64 s);
static i64 mm_lex_readhexcode(u64 s, i64 n, i64 sp);
static i64 mm_lex_getutf8(i64 c, u64 s);
static void mm_lex_readreal();
static void mm_lex_nodecimal();
static void mm_lex_start();
static u64 mm_lib_newstrec();
static u64 mm_lib_allocunitrec();
static u64 mm_lib_createunit3(i64 tag, u64 p, u64 q, u64 r);
static void mm_lib_insertunit(u64 p, i64 tag);
static void mm_lib_deleteunit(u64 p, u64 q);
static u64 mm_lib_createstringconstunit(u64 s, i64 length);
static i64 mm_lib_newtypename(u64 a, u64 b);
static i64 mm_lib_createusertype(u64 stname);
static i64 mm_lib_createusertypefromstr(u64 name);
static u64 mm_lib_getrangelwbunit(u64 p);
static u64 mm_lib_getrangeupbunit(u64 p);
static i64 mm_lib_createarraymode(u64 owner, i64 target, u64 dimexpr, i64 typedefx);
static i64 mm_lib_storemode(u64 owner, i64 m, u64 pmode);
static i64 mm_lib_sameunit(u64 p, u64 q, u64 powner, u64 qowner);
static i64 mm_lib_createarraymodek(u64 owner, i64 target, i64 lower, i64 length, i64 typedefx);
static i64 mm_lib_createslicemode(u64 owner, i64 slicetype, i64 target, u64 dimexpr, i64 typedefx);
static i64 mm_lib_createslicemodek(u64 owner, i64 target, i64 lower, i64 typedefx);
static i64 mm_lib_createrefprocmode(u64 owner, u64 stproc, u64 paramlist, i64 kwd, i64 prettype, i64 typedefx);
static void mm_lib_copyttvalues(i64 dest, i64 source);
static void mm_lib_unionstr_clear(u64 u);
static void mm_lib_unionstr_append(u64 u, i64 c);
static void mm_lib_unionstr_concat(u64 u, u64 v);
static i64 mm_lib_unionstr_last(u64 u);
static void mm_lib_unionstr_copy(u64 u, u64 v);
static i64 mm_lib_createrecordmode(u64 owner, i64 typedefx);
static i64 mm_lib_createtuplemode(u64 owner, u64 elements, i64 elementslen, i64 typedefx);
static void mm_lib_jevalx2(u64 dest, u64 p);
static void mm_lib_jevalx(u64 p);
static void mm_lib_jadditem(u64 s);
static void mm_lib_jaddstr(u64 s);
static void mm_support_gs_additem(u64 dest, u64 s);
static void mm_lib_istrmode(i64 m, i64 expand, u64 dest);
static void mm_support_gs_copytostr(u64 source, u64 s);
static void mm_support_mcerror(u64 mess);
static void mm_lib_addstatic(u64 d);
static void mm_lib_addexpconst(u64 d);
static u64 mm_lib_createnewmoduledef(u64 owner, u64 symptr, i64 id);
static u64 mm_lib_duplunit(u64 p, i64 lineno);
static i64 mm_lib_isconstunit(u64 a);
static void mm_lib_getownername(u64 d, u64 dest);
static i64 mm_lib_gettypebase(i64 m);
static void mm_support_txerror(u64 mess, u64 p);
static void mm_libsources_loadbuiltins();
static u64 mm_support_newsourcefile();
static u64 mm_modules_loadsp(u64 filename, i64 mainsub);
static u64 mm_modules_loadmodule(u64 filespec, i64 issyslib);
static void mm_parse_skipsemi();
static void mm_modules_addlib(u64 libname);
static void mm_support_serror_s(u64 mess, u64 a);
static u64 mm_modules_loadsourcefile(u64 filespec, i64 issyslib);
static void mm_modules_loadsyslib();
static void mm_modules_loadmafile(u64 filespec, u64 builtinstr);
static u64 mm_modules_readfileline(u64 s);
static u64 mm_modules_findnextlineheader(u64 s);
static void mm_name_do_baseclass(u64 p);
static void mm_name_rx_unit(u64 owner, u64 p);
static void mm_name_resolvename(u64 owner, u64 p);
static void mm_name_expandmacro(u64 p, u64 a, u64 b);
static void mm_name_resolvedot(u64 owner, u64 p);
static void mm_name_rx_unitlist(u64 owner, u64 p);
static void mm_name_rx_passdef(u64 owner, u64 p);
static void mm_name_rx_deflist(u64 owner, u64 p);
static u64 mm_name_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod);
static void mm_support_rxerror_s(u64 mess, u64 a, u64 p);
static u64 mm_name_addframevar(u64 owner, u64 d, i64 moduleno, i64 mode);
static u64 mm_name_finddupl(u64 d, u64 pdupl);
static u64 mm_name_finddupl_sub(u64 d, u64 pdupl);
static void mm_support_rxerror(u64 mess, u64 p);
static void mm_name_fixmode(u64 p);
static u64 mm_name_copylistunit(u64 p);
static u64 mm_name_copyunit(u64 p);
static void mm_name_replaceunit(u64 p, u64 q);
static void mm_name_duplfield(u64 owner, u64 p, u64 q);
static void mm_parse_initparser();
static void mm_parse_readmoduledefs(u64 owner);
static void mm_parse_readprocdef(u64 procowner, i64 scope);
static u64 mm_parse_readvardef(u64 owner, i64 scope, i64 isstatic, i64 varid, i64 k);
static void mm_parse_readimportmodule(u64 owner);
static void mm_parse_readtypedef(u64 owner, i64 scope);
static void mm_parse_readconstdef(u64 owner, i64 scope);
static void mm_parse_readclassdef(u64 owner, i64 scope);
static void mm_parse_readtabledef(u64 owner, i64 scope);
static void mm_parse_readmacrodef(u64 owner, i64 scope);
static i64 mm_parse_istypestarter();
static void mm_parse_checkequals();
static i64 mm_parse_getcurrline();
static i64 mm_parse_checkbegin(i64 fbrack);
static void mm_parse_checkbeginend(i64 closesym, i64 kwd, i64 startline);
static void mm_parse_checksymbollex(i64 symbol);
static i64 mm_parse_readtypespec(u64 owner, i64 typedefx);
static u64 mm_parse_readconstexpr(i64 needconst);
static u64 mm_parse_readlbrack();
static u64 mm_parse_readsunit(i64 inwhile);
static u64 mm_parse_fixcond(u64 p);
static void mm_parse_addlistparam(u64 ulist, u64 ulistx, u64 p);
static u64 mm_parse_readcast();
static u64 mm_parse_readopc();
static u64 mm_parse_readterm2();
static u64 mm_parse_readcastx();
static i64 mm_parse_readrefproc(u64 owner, i64 typedefx);
static i64 mm_parse_readslicetype(u64 owner, i64 slicetype, i64 typedefx);
static u64 mm_parse_readslist(i64 iscall, i64 donulls);
static u64 mm_parse_readindex(u64 p, i64 dot);
static u64 mm_parse_readdotsuffix(u64 p);
static i64 mm_parse_readconstint();
static u64 mm_parse_readprocdecl(u64 procowner, i64 scope);
static void mm_parse_pushproc(u64 p);
static void mm_parse_popproc();
static u64 mm_parse_readparams(u64 procowner, u64 owner, u64 varparams, u64 nparams);
static i64 mm_parse_readreturntype(u64 owner, u64 retmodes);
static u64 mm_parse_readcondsuffix(u64 p);
static u64 mm_parse_readif();
static u64 mm_parse_readswitchcase();
static u64 mm_parse_readgoto(i64 gototag);
static u64 mm_parse_readunless();
static u64 mm_parse_readstop();
static u64 mm_parse_readreturn();
static u64 mm_parse_readdo();
static u64 mm_parse_readto();
static u64 mm_parse_readwhile();
static u64 mm_parse_readrepeat();
static u64 mm_parse_readloopcontrol();
static u64 mm_parse_readprint();
static u64 mm_parse_readread();
static u64 mm_parse_readfor();
static u64 mm_parse_readname();
static void mm_parse_readrecordfields(u64 owner, i64 m);
static u64 mm_parse_readequivfield(u64 owner);
static void mm_parse_readclassbody(u64 owner, i64 classkwd);
static void mm_parse_readimportbody(u64 owner);
static u64 mm_parse_readset();
static u64 mm_parse_readassignment(u64 pt);
static u64 mm_parse_readorterms(u64 pt);
static u64 mm_parse_readandterms(u64 pt);
static u64 mm_parse_readcmpterms(u64 pt);
static u64 mm_parse_readinterms(u64 pt);
static u64 mm_parse_readrangeterm(u64 pt);
static u64 mm_parse_readaddterms(u64 pt);
static u64 mm_parse_readmulterms(u64 pt);
static u64 mm_parse_readpowerterms(u64 p);
static u64 mm_parse_readterm();
static u64 mm_parse_readrecase();
static void mm_parse_checknotempty(u64 p);
static u64 mm_parse_readbxdata();
static void mm_support_serror_gen(u64 mess);
static void mm_support_showdivider(u64 ch);
static void mm_support_showerrorsource(i64 pos, u64 stproc);
static void mm_support_stopcompiler(u64 filename, i64 lineno);
static i64 mm_support_getfileno(u64 pos);
static u64 mm_support_getsourceline(u64 pos);
static u64 mm_support_getsourcepos(u64 pos);
static void mm_support_error_gen(i64 pass, u64 mess, u64 p);
static void mm_support_txerror_s(u64 mess, u64 a, u64 p);
static void mm_support_txerror_ss(u64 mess, u64 a, u64 b);
static void mm_support_lxerror_gen(u64 mess);
static i64 mm_support_isalphanum(i64 c);
static i64 mm_support_isabspath(u64 filespec);
static u64 mm_support_getsourcestart(u64 pos);
static void mm_support_getst(u64 f, u64 d);
static void mm_support_getstrec(u64 f, u64 d);
static void mm_tables_start();
static void mm_type_tx_name(u64 p, i64 t, i64 lv);
static void mm_type_tx_bin(u64 p, u64 a, u64 b);
static i64 mm_type_tx_in(u64 p, u64 a, u64 b);
static void mm_type_tx_unary(u64 p, u64 a);
static void mm_type_tx_prop(u64 p, u64 a);
static void mm_type_tx_binto(u64 p, u64 a, u64 b);
static void mm_type_tx_unaryto(u64 p, u64 a);
static void mm_type_tpasslv(u64 p, i64 t);
static void mm_type_tx_addroffirst(u64 p, u64 a, i64 t);
static void mm_type_tx_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 t, i64 lv);
static void mm_type_tx_index(u64 p, u64 a, u64 b, i64 t, i64 lv);
static void mm_type_tx_ptr(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_callproc(u64 p, u64 a, u64 pargs, i64 t);
static void mm_type_tx_dot(u64 p, u64 a, u64 b, i64 lv);
static void mm_type_tx_andl(u64 p, u64 a, u64 b);
static void mm_type_tx_notl(u64 p, u64 a);
static void mm_type_tx_convert(u64 p, u64 a, i64 hard);
static void mm_type_tx_typepun(u64 p, u64 a);
static void mm_type_tx_incrto(u64 p, u64 a, i64 t);
static void mm_type_tx_makerange(u64 p, u64 a, u64 b);
static void mm_type_tx_swap(u64 p, u64 a, u64 b);
static void mm_type_tx_select(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_switch(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_case(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_dotindex(u64 p, u64 a, u64 b, i64 lv);
static void mm_type_tx_slice(u64 p, u64 a, u64 b);
static void mm_type_tx_block(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_return(u64 p, u64 a, i64 t);
static void mm_type_tx_unitlist(u64 p, i64 t, i64 lv);
static void mm_type_fixchararray(u64 a);
static void mm_type_tx_for(u64 pindex, u64 pfrom, u64 pbody);
static void mm_type_tx_forall(u64 pindex, u64 plist, u64 pbody);
static void mm_type_coerceunit(u64 p, i64 t, i64 hard);
static void mm_type_tx_makelist(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_exit(u64 p, u64 a);
static void mm_type_tx_goto(u64 p, u64 a);
static i64 mm_type_iscondtrue(u64 p);
static i64 mm_type_iscondfalse(u64 p);
static void mm_type_tx_bitfield(u64 p, u64 a, i64 lv);
static void mm_type_tx_cmpchain(u64 p, u64 a);
static void mm_type_tx_strinclude(u64 p, u64 a);
static void mm_type_tx_makeslice(u64 p, u64 a, u64 b, i64 t);
static void mm_type_tx_makeset(u64 p, u64 a, i64 t);
static void mm_type_tevaluate(u64 p);
static void mm_type_tx_passdef(u64 p);
static void mm_type_setmodesize(i64 m);
static void mm_type_setarraysize(i64 m);
static void mm_type_setslicesize(i64 m);
static i64 mm_type_getconstint(u64 q);
static void mm_type_checkblocktype(i64 m);
static void mm_type_tx_namedconst(u64 d);
static void mm_type_tx_namedef(u64 d);
static void mm_type_checkconstexpr(u64 p);
static void mm_type_makenewconst(u64 p, i64 x, i64 t);
static void mm_type_twiden(u64 p, i64 lv);
static i64 mm_type_dobinnumx(u64 p, u64 a, u64 b);
static void mm_type_combinestrings(u64 p);
static i64 mm_type_comparemodes(i64 s, i64 t);
static void mm_type_mulstrings(u64 p);
static i64 mm_type_dobinnumf(u64 p, u64 a, u64 b);
static i64 mm_type_dobinnumi(u64 p, u64 a, u64 b);
static i64 mm_type_getdominantmode(i64 amode, i64 bmode);
static void mm_type_tmethodcall(u64 p, u64 pdot, u64 pargs);
static void mm_type_do_bounds(u64 p, u64 a);
static void mm_type_deref(u64 a, i64 needres);
static void mm_type_scanrecord(i64 state, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign);
static i64 mm_type_roundoffset(i64 offset, i64 alignment);
static void mm_type_tx_makeslicefromlist(u64 p, u64 a, i64 t);
static u64 mm_type_resolvefield(u64 d, i64 m);
static void mm_type_convintconst(u64 p, i64 x);
static void mm_type_tx_sliceptr(u64 p, u64 a);
static void mm_type_tstringslice(u64 p, i64 slicemode);
static void mm_type_addnotl(u64 p);
static void mm_type_tevalbinop(u64 p);
static void mm_type_tevalmonop(u64 p);
static u64 mm_type_addrdotindex(u64 p, u64 offset);
static void mm_type_applyconversion(u64 p, i64 s, i64 t, i64 opc);
static i64 mm_type_tevalconvert(u64 p, i64 s, i64 t, i64 opc);
static void mm_type_checkmodes(i64 s, i64 t);
static void mm_type_tx_assignmultmult(u64 pp, u64 a, u64 b);
static void mm_type_tx_assignmultscalar(u64 pp, u64 a, u64 b, i64 t);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    mm_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static i64 mlinux_init_flag = 0;

static u8 pcl_pc_userunpcl = 0;

static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc = 65536;

static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B17 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest = (u64)&pc_decls_sbuffer;

static struct $B18 pc_decls_plibfiles;
static struct $B18 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype = 16705;

static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole = 1;

static u8 pc_decls_fregoptim = 1;

static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B19 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static struct $B3 pc_diags_sbuffer;
static u64 pc_diags_dest = (u64)&pc_diags_sbuffer;

static i64 pc_diags_destlinestart;
static struct $B20 pc_diags_stropnd_str;
static u64 pc_diags_stropnd_longstring;
static i64 pc_run_dotrace = 0;

static i64 pc_run_dostep = 1;

static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B21 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B22 pc_tables_pstdnames = {{
(u64)"void",
(u64)"r32",
(u64)"r64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"mem",
(u64)"vec",
(u64)"$last"}};

static struct $B23 pc_tables_psize = {{
1024,
264,
1026,
264,
1026,
8,
0}};

static struct $B23 pc_tables_psigned = {{
0,
0,
0,
256,
257,
1,
0}};

static struct $B23 pc_tables_pint = {{
0,
256,
257,
257,
257,
1,
0}};

static struct $B23 pc_tables_pfloat = {{
256,
1,
0,
0,
0,
0,
0}};

static struct $B23 pc_tables_pmin = {{
256,
1282,
1285,
2310,
2313,
2826,
12}};

static struct $B23 pc_tables_piwrb = {{
256,
1538,
1542,
2566,
2570,
10,
0}};

static struct $B22 pc_tables_opndnames = {{
(u64)"no_opnd",
(u64)"mem_opnd",
(u64)"memaddr_opnd",
(u64)"label_opnd",
(u64)"int_opnd",
(u64)"real_opnd",
(u64)"r32_opnd",
(u64)"string_opnd",
(u64)"strimm_opnd",
(u64)"assem_opnd",
(u64)"realimm_opnd",
(u64)"realimm32_opnd",
(u64)"data_opnd",
(u64)"any_opnd"}};

static struct $B19 pc_tables_pclnames = {{
(u64)"nop",
(u64)"load",
(u64)"iload",
(u64)"iloadx",
(u64)"store",
(u64)"istore",
(u64)"istorex",
(u64)"storem",
(u64)"dupl",
(u64)"double",
(u64)"swapstk",
(u64)"unload",
(u64)"opnd",
(u64)"type",
(u64)"loadbit",
(u64)"loadbf",
(u64)"storebit",
(u64)"storebf",
(u64)"callp",
(u64)"icallp",
(u64)"retproc",
(u64)"callf",
(u64)"icallf",
(u64)"retfn",
(u64)"jump",
(u64)"ijump",
(u64)"jumpcc",
(u64)"jumpt",
(u64)"jumpf",
(u64)"jumpret",
(u64)"jumpretm",
(u64)"setcc",
(u64)"stop",
(u64)"to",
(u64)"forup",
(u64)"fordown",
(u64)"iswap",
(u64)"switch",
(u64)"switchu",
(u64)"swlabel",
(u64)"endsw",
(u64)"clear",
(u64)"assem",
(u64)"add",
(u64)"sub",
(u64)"mul",
(u64)"div",
(u64)"idiv",
(u64)"irem",
(u64)"idivrem",
(u64)"bitand",
(u64)"bitor",
(u64)"bitxor",
(u64)"shl",
(u64)"shr",
(u64)"min",
(u64)"max",
(u64)"addpx",
(u64)"subpx",
(u64)"subp",
(u64)"neg",
(u64)"abs",
(u64)"bitnot",
(u64)"not",
(u64)"toboolt",
(u64)"toboolf",
(u64)"sqr",
(u64)"sqrt",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"sign",
(u64)"atan2",
(u64)"power",
(u64)"fmod",
(u64)"incrto",
(u64)"decrto",
(u64)"incrload",
(u64)"decrload",
(u64)"loadincr",
(u64)"loaddecr",
(u64)"addto",
(u64)"subto",
(u64)"multo",
(u64)"divto",
(u64)"idivto",
(u64)"iremto",
(u64)"bitandto",
(u64)"bitorto",
(u64)"bitxorto",
(u64)"shlto",
(u64)"shrto",
(u64)"minto",
(u64)"maxto",
(u64)"addpxto",
(u64)"subpxto",
(u64)"negto",
(u64)"absto",
(u64)"bitnotto",
(u64)"notto",
(u64)"toboolto",
(u64)"typepun",
(u64)"float",
(u64)"fix",
(u64)"truncate",
(u64)"widen",
(u64)"fwiden",
(u64)"fnarrow",
(u64)"startmx",
(u64)"resetmx",
(u64)"endmx",
(u64)"proc",
(u64)"tcproc",
(u64)"endproc",
(u64)"istatic",
(u64)"zstatic",
(u64)"data",
(u64)"initdswx",
(u64)"label",
(u64)"labeldef",
(u64)"setjmp",
(u64)"longjmp",
(u64)"setcall",
(u64)"setarg",
(u64)"loadall",
(u64)"eval",
(u64)"comment",
(u64)"endprog",
(u64)"param",
(u64)"local",
(u64)"rettype",
(u64)"variadic",
(u64)"addlib",
(u64)"extproc"}};

static struct $B24 pc_tables_pclhastype = {{
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
2,
2,
2,
2,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0}};

static struct $B24 pc_tables_pclextra = {{
0,
1,
0,
2,
0,
0,
2,
0,
0,
0,
2,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
2,
2,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B24 pc_tables_pclhasopnd = {{
0,
13,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
13,
0,
0,
0,
0,
0,
2,
0,
0,
2,
0,
0,
3,
0,
3,
3,
3,
3,
3,
0,
0,
3,
3,
3,
0,
3,
3,
3,
0,
0,
13,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
1,
1,
13,
0,
3,
2,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
7,
1}};

static struct $B24 pc_tables_pclargs = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
9,
9,
0,
9,
9,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B25 pc_tables_ccnames = {{
(u64)"xx",
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B1 pc_tables_idnames = {{
(u64)"--",
(u64)"Import",
(u64)"Proc",
(u64)"Static",
(u64)"Local",
(u64)"Param",
(u64)"Label",
(u64)"Export",
(u64)"Misc",
(u64)"Program"}};

static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B19 mc_genmcl_px_handlertable;
static struct $B26 mc_genmcl_scondcodes = {{
1284,
3596,
3853}};

static struct $B26 mc_genmcl_ucondcodes = {{
1284,
1538,
1795}};

// Istatic skipped:mc_genmcl.inithandlers.initdone

// Istatic skipped:mc_genmcl.inithandlers.dupltable

static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B28 mc_libmcl_smallinttable;
static struct $B29 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B29 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B20 mc_stackmcl_stropndstack_str;
static u8 mc_genss_rex;
static u8 mc_genss_sizeoverride;
static u8 mc_genss_addroverride;
static u8 mc_genss_f2override;
static u8 mc_genss_f3override;
static u8 mc_genss_nowmask;
static u8 mc_genss_usesizeb;
static u64 mc_genss_extraparam;
static i64 mc_genss_currseg = 0;

static u64 mc_genss_currdata;
static u64 mc_genss_currrelocs;
static i64 mc_genss_nrelocs;
static struct $B3 mc_genss_ishighreg;
static u64 mc_genss_currmcl;
static u64 mc_genss_ripentry;
// Istatic skipped:mc_genss.genrm.scaletable

static struct $B11 mc_decls_valtypenames = {{
(u64)"no_val",
(u64)"intimm_val",
(u64)"realimm_val",
(u64)"realmem_val",
(u64)"stringimm_val",
(u64)"def_val",
(u64)"label_val",
(u64)"name_val",
(u64)"temp_val"}};

static struct $B31 mc_decls_mclnames = {{
(u64)"m_procstart",
(u64)"m_procend",
(u64)"m_comment",
(u64)"m_labelname",
(u64)"m_define",
(u64)"m_definereg",
(u64)"m_trace",
(u64)"m_endx",
(u64)"m_labelx",
(u64)"m_nop",
(u64)"m_mov",
(u64)"m_push",
(u64)"m_pop",
(u64)"m_lea",
(u64)"m_cmovcc",
(u64)"m_movd",
(u64)"m_movq",
(u64)"m_movsx",
(u64)"m_movzx",
(u64)"m_movsxd",
(u64)"m_call",
(u64)"m_ret",
(u64)"m_leave",
(u64)"m_retn",
(u64)"m_jmp",
(u64)"m_jmpcc",
(u64)"m_xchg",
(u64)"m_add",
(u64)"m_sub",
(u64)"m_adc",
(u64)"m_sbb",
(u64)"m_imul",
(u64)"m_mul",
(u64)"m_imul2",
(u64)"m_imul3",
(u64)"m_idiv",
(u64)"m_div",
(u64)"m_andx",
(u64)"m_orx",
(u64)"m_xorx",
(u64)"m_test",
(u64)"m_cmp",
(u64)"m_shl",
(u64)"m_sar",
(u64)"m_shr",
(u64)"m_rol",
(u64)"m_ror",
(u64)"m_rcl",
(u64)"m_rcr",
(u64)"m_neg",
(u64)"m_notx",
(u64)"m_inc",
(u64)"m_dec",
(u64)"m_cbw",
(u64)"m_cwd",
(u64)"m_cdq",
(u64)"m_cqo",
(u64)"m_setcc",
(u64)"m_bsf",
(u64)"m_bsr",
(u64)"m_shld",
(u64)"m_shrd",
(u64)"m_sqrtss",
(u64)"m_sqrtsd",
(u64)"m_addss",
(u64)"m_addsd",
(u64)"m_subss",
(u64)"m_subsd",
(u64)"m_mulss",
(u64)"m_mulsd",
(u64)"m_divss",
(u64)"m_divsd",
(u64)"m_comiss",
(u64)"m_comisd",
(u64)"m_ucomisd",
(u64)"m_xorps",
(u64)"m_xorpd",
(u64)"m_andps",
(u64)"m_andpd",
(u64)"m_pxor",
(u64)"m_pand",
(u64)"m_cvtss2si",
(u64)"m_cvtsd2si",
(u64)"m_cvttss2si",
(u64)"m_cvttsd2si",
(u64)"m_cvtsi2ss",
(u64)"m_cvtsi2sd",
(u64)"m_cvtsd2ss",
(u64)"m_cvtss2sd",
(u64)"m_movdqa",
(u64)"m_movdqu",
(u64)"m_pcmpistri",
(u64)"m_pcmpistrm",
(u64)"m_fld",
(u64)"m_fst",
(u64)"m_fstp",
(u64)"m_fild",
(u64)"m_fist",
(u64)"m_fistp",
(u64)"m_fadd",
(u64)"m_fsub",
(u64)"m_fmul",
(u64)"m_fdiv",
(u64)"m_fsqrt",
(u64)"m_fsin",
(u64)"m_fcos",
(u64)"m_fsincos",
(u64)"m_fptan",
(u64)"m_fpatan",
(u64)"m_fabs",
(u64)"m_fchs",
(u64)"m_minss",
(u64)"m_maxss",
(u64)"m_minsd",
(u64)"m_maxsd",
(u64)"m_db",
(u64)"m_dw",
(u64)"m_dd",
(u64)"m_dq",
(u64)"m_isegment",
(u64)"m_zsegment",
(u64)"m_csegment",
(u64)"m_align",
(u64)"m_resb",
(u64)"m_resw",
(u64)"m_resd",
(u64)"m_resq",
(u64)"m_xlat",
(u64)"m_loopnz",
(u64)"m_loopz",
(u64)"m_loopcx",
(u64)"m_jecxz",
(u64)"m_jrcxz",
(u64)"m_cmpsb",
(u64)"m_cmpsw",
(u64)"m_cmpsd",
(u64)"m_cmpsq",
(u64)"m_rdtsc",
(u64)"m_popcnt",
(u64)"m_bswap",
(u64)"m_finit",
(u64)"m_fldz",
(u64)"m_fld1",
(u64)"m_fldpi",
(u64)"m_fld2t",
(u64)"m_fld2e",
(u64)"m_fldlg2",
(u64)"m_fldln2",
(u64)"m_cpuid",
(u64)"m_xxxx",
(u64)"m_halt"}};

static struct $B32 mc_decls_mclnopnds = {{
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
2,
1,
1,
2,
2,
2,
2,
2,
2,
2,
1,
0,
0,
1,
1,
1,
2,
2,
2,
2,
2,
1,
1,
2,
3,
1,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
0,
0,
0,
0,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
3,
3,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B32 mc_decls_mclcodes = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
144,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
232,
195,
201,
0,
233,
0,
0,
0,
5,
2,
3,
5,
4,
0,
0,
7,
6,
4,
1,
6,
0,
7,
4,
7,
5,
0,
1,
2,
3,
3,
2,
0,
1,
0,
0,
0,
0,
0,
188,
189,
164,
172,
81,
81,
88,
88,
92,
92,
89,
89,
94,
94,
0,
47,
46,
87,
87,
84,
84,
239,
219,
0,
0,
0,
0,
0,
0,
0,
0,
102,
243,
99,
98,
0,
2,
3,
0,
2,
3,
193,
233,
201,
249,
250,
254,
255,
251,
242,
243,
225,
224,
93,
95,
93,
95,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
4,
8,
215,
224,
225,
226,
227,
227,
0,
0,
0,
0,
49,
0,
0,
0,
238,
232,
235,
233,
234,
236,
237,
0,
244,
244}};

static struct $B33 mc_decls_regnames = {{
(u64)"rnone",
(u64)"r0",
(u64)"r1",
(u64)"r2",
(u64)"r3",
(u64)"r4",
(u64)"r5",
(u64)"r6",
(u64)"r7",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"r16",
(u64)"r17",
(u64)"r18",
(u64)"r19"}};

static struct $B34 mc_decls_regcodes = {{
0,
0,
10,
11,
7,
3,
6,
12,
13,
14,
15,
1,
2,
8,
9,
5,
4,
4,
7,
5,
6}};

static struct $B29 mc_decls_condnames = {{
(u64)"ov",
(u64)"nov",
(u64)"ltu",
(u64)"geu",
(u64)"eq",
(u64)"ne",
(u64)"leu",
(u64)"gtu",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"lt",
(u64)"ge",
(u64)"le",
(u64)"gt",
(u64)"flt",
(u64)"fge",
(u64)"fle",
(u64)"fgt"}};

static struct $B29 mc_decls_asmcondnames = {{
(u64)"o",
(u64)"no",
(u64)"b",
(u64)"ae",
(u64)"z",
(u64)"nz",
(u64)"be",
(u64)"a",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"l",
(u64)"ge",
(u64)"le",
(u64)"g",
(u64)"b",
(u64)"ae",
(u64)"be",
(u64)"a"}};

static struct $B29 mc_decls_asmrevcond = {{
1,
0,
3,
2,
5,
4,
7,
6,
9,
8,
11,
10,
13,
12,
15,
14,
17,
16,
19,
18}};

static struct $B35 mc_decls_dregnames = {{
(u64)"d0",
(u64)"d1",
(u64)"d2",
(u64)"d3",
(u64)"d4",
(u64)"d5",
(u64)"d6",
(u64)"d7",
(u64)"d8",
(u64)"d9",
(u64)"d10",
(u64)"d11",
(u64)"d12",
(u64)"d13",
(u64)"d14",
(u64)"d15",
(u64)"a0",
(u64)"a1",
(u64)"a2",
(u64)"a3",
(u64)"a4",
(u64)"a5",
(u64)"a6",
(u64)"a7",
(u64)"a8",
(u64)"a9",
(u64)"a10",
(u64)"a11",
(u64)"a12",
(u64)"a13",
(u64)"a14",
(u64)"a15",
(u64)"w0",
(u64)"w1",
(u64)"w2",
(u64)"w3",
(u64)"w4",
(u64)"w5",
(u64)"w6",
(u64)"w7",
(u64)"w8",
(u64)"w9",
(u64)"w10",
(u64)"w11",
(u64)"w12",
(u64)"w13",
(u64)"w14",
(u64)"w15",
(u64)"b0",
(u64)"b1",
(u64)"b2",
(u64)"b3",
(u64)"b4",
(u64)"b5",
(u64)"b6",
(u64)"b7",
(u64)"b8",
(u64)"b9",
(u64)"b10",
(u64)"b11",
(u64)"b12",
(u64)"b13",
(u64)"b14",
(u64)"b15",
(u64)"b16",
(u64)"b17",
(u64)"b18",
(u64)"b19",
(u64)"_b20",
(u64)"rax",
(u64)"rbx",
(u64)"rcx",
(u64)"rdx",
(u64)"rsi",
(u64)"rdi",
(u64)"rbp",
(u64)"rsp",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"eax",
(u64)"ebx",
(u64)"ecx",
(u64)"edx",
(u64)"esi",
(u64)"edi",
(u64)"ebp",
(u64)"esp",
(u64)"r8d",
(u64)"r9d",
(u64)"r10d",
(u64)"r11d",
(u64)"r12d",
(u64)"r13d",
(u64)"r14d",
(u64)"r15d",
(u64)"ax",
(u64)"bx",
(u64)"cx",
(u64)"dx",
(u64)"si",
(u64)"di",
(u64)"bp",
(u64)"sp",
(u64)"r8w",
(u64)"r9w",
(u64)"r10w",
(u64)"r11w",
(u64)"r12w",
(u64)"r13w",
(u64)"r14w",
(u64)"r15w",
(u64)"al",
(u64)"bl",
(u64)"cl",
(u64)"dl",
(u64)"ah",
(u64)"bh",
(u64)"ch",
(u64)"dh",
(u64)"sil",
(u64)"dil",
(u64)"bpl",
(u64)"spl",
(u64)"r8b",
(u64)"r9b",
(u64)"r10b",
(u64)"r11b",
(u64)"r12b",
(u64)"r13b",
(u64)"r14b",
(u64)"r15b"}};

static struct $B36 mc_decls_regsizes = {{
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1}};

static struct $B36 mc_decls_regindices = {{
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
0,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
17,
18,
19,
20,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10}};

static struct $B21 mc_decls_xmmregnames = {{
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm14",
(u64)"xmm15"}};

static struct $B30 mc_decls_fregnames = {{
(u64)"st0",
(u64)"st1",
(u64)"st2",
(u64)"st3",
(u64)"st4",
(u64)"st5",
(u64)"st6",
(u64)"st7"}};

static struct $B30 mc_decls_mregnames = {{
(u64)"mmx0",
(u64)"mmx1",
(u64)"mmx2",
(u64)"mmx3",
(u64)"mmx4",
(u64)"mmx5",
(u64)"mmx6",
(u64)"mmx7"}};

static struct $B37 mc_decls_jmpccnames = {{
(u64)"jo",
(u64)"jno",
(u64)"jb",
(u64)"jae",
(u64)"jz",
(u64)"jnz",
(u64)"jbe",
(u64)"ja",
(u64)"js",
(u64)"jns",
(u64)"jp",
(u64)"jnp",
(u64)"jl",
(u64)"jge",
(u64)"jle",
(u64)"jg",
(u64)"jc",
(u64)"jnc"}};

static struct $B38 mc_decls_jmpcccodes = {{
256,
770,
1284,
1798,
2312,
2826,
3340,
3854,
770}};

static struct $B21 mc_decls_setccnames = {{
(u64)"seto",
(u64)"setno",
(u64)"setb",
(u64)"setae",
(u64)"setz",
(u64)"setnz",
(u64)"setbe",
(u64)"seta",
(u64)"sets",
(u64)"setns",
(u64)"setp",
(u64)"setnp",
(u64)"setl",
(u64)"setge",
(u64)"setle",
(u64)"setg"}};

static struct $B3 mc_decls_setcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B21 mc_decls_cmovccnames = {{
(u64)"cmovo",
(u64)"cmovno",
(u64)"cmovb",
(u64)"cmovae",
(u64)"cmovz",
(u64)"cmovnz",
(u64)"cmovbe",
(u64)"cmova",
(u64)"cmovs",
(u64)"cmovns",
(u64)"cmovp",
(u64)"cmovnp",
(u64)"cmovl",
(u64)"cmovge",
(u64)"cmovle",
(u64)"cmovg"}};

static struct $B3 mc_decls_cmovcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B12 mc_decls_segmentnames = {{
(u64)"no_seg",
(u64)"code_seg",
(u64)"idata_seg",
(u64)"zdata_seg",
(u64)"rodata_seg",
(u64)"impdata_seg"}};

static struct $B8 mc_decls_reftypenames = {{
(u64)"extern_ref",
(u64)"fwd_ref",
(u64)"back_ref"}};

static struct $B12 mc_decls_opndnames_ma = {{
(u64)"a_none",
(u64)"a_reg",
(u64)"a_imm",
(u64)"a_mem",
(u64)"a_cond",
(u64)"a_xreg"}};

static struct $B29 mc_decls_pclopnd;
static struct $B39 mc_decls_pclreg;
static struct $B39 mc_decls_pclmode;
static struct $B39 mc_decls_pclcount;
static struct $B39 mc_decls_pclloc;
static struct $B39 mc_decls_pcltempflags;
static struct $B29 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B17 mc_decls_locnames = {{
(u64)"pend",
(u64)"reg",
(u64)"regvar",
(u64)"temp"}};

static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B40 mc_decls_xregnames = {{
(u64)"-",
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm15",
(u64)"xmm15"}};

static struct $B3 mc_decls_callalign;
static struct $B3 mc_decls_callblockret;
static struct $B30 mc_decls_callblocksize;
static struct $B16 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used = 0;

static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment = 0;

static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B41 mc_decls_regtable;
static struct $B42 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static u64 mc_decls_regmodes = 432345564311454723;

static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B18 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs = {{
1,
2,
3,
11,
12,
13}};

static struct $B12 mc_decls_multxregs = {{
1,
2,
3,
4,
5,
6}};

static struct $B23 mc_decls_ploadopx;
static struct $B23 mc_decls_ploadop;
static struct $B25 mc_objdecls_relocnames = {{
(u64)"abs_rel",
(u64)"addr64_rel",
(u64)"addr32_rel",
(u64)"addr32nb_rel",
(u64)"rel32_rel",
(u64)"rel321_rel",
(u64)"rel8_rel"}};

static struct $B41 mc_writeasm_nregnames;
static struct $B21 mc_writeasm_regvars;
static struct $B21 mc_writeasm_xregvars;
static struct $B20 mc_writeasm_strmcl_str;
static struct $B20 mc_writeasm_mstropnd_str;
static struct $B20 mc_writeasm_strvalue_str;
// Istatic skipped:mc_writeasm.getregname.prefix

static struct $B17 mc_writeasm_getregname_str;
static struct $B17 mc_writeasm_getxregname_str;
static struct $B16 mc_writeasm_getdispname_str;
static struct $B21 mc_writeasm_gettempname_str;
static struct $B18 mc_writeexe_libinsttable;
static struct $B18 mc_writeexe_libinstnames;
static struct $B18 mc_writeexe_libnotable;
static u64 mc_writeexe_basereloclist;
static i64 mc_writeexe_nbaserelocs;
static i64 mc_writeexe_maxrelocaddr;
static struct $B44 mc_writeexe_blockbases;
static struct $B45 mc_writeexe_blockcounts;
static struct $B45 mc_writeexe_blockbytes;
static struct $B46 mc_writeexe_blockpadding;
static i64 mc_writeexe_nbaseblocks;
static i64 mc_writeexe_basetablesize;
static i64 mc_writeexe_imagebase;
static i64 mc_writeexe_imagesize;
static i64 mc_writeexe_filesize;
static u64 mc_writeexe_thunktable;
static i64 mc_writeexe_fileiatoffset;
static i64 mc_writeexe_fileiatsize;
static u64 mc_writeexe_stentrypoint;
static u64 mc_writeexe_stentrypoint2;
static u64 mc_writeexe_stentrypoint3;
static struct $B47 mc_writeexe_sectiontable;
static i64 mc_writeexe_nsections;
static u64 mc_writeexe_importdir;
static struct $B48 mc_writeexe_importtable;
static i64 mc_writeexe_nimports;
static struct $B49 mc_writeexe_exporttable;
static i64 mc_writeexe_nexports;
static u64 mc_writeexe_dllfilename;
static i64 mc_writeexe_isdll;
static struct $B50 mc_writeexe_dlltable;
static i64 mc_writeexe_ndlls;
static u64 mc_writeexe_datastart;
static u64 mc_writeexe_dataptr;
static u64 mc_writeexe_userentrypoint;
static i64 mc_writeexe_exportdirvirtaddr;
static i64 mc_writeexe_exportdirvirtsize;
static i64 mc_writeexe_exportdiroffset;
static i64 mc_writeexe_blockdirvirtaddr;
static i64 mc_writeexe_blockdirvirtsize;
static i64 mc_writeexe_blockdiroffset;
// Istatic skipped:mc_writeexe.writedosstub.stubdata

static i64 mc_writeobj_symtaboffset;
static u64 mc_writeobj_datastart;
static u64 mc_writeobj_dataptr;
static struct $B51 mc_writeobj_symboltable;
static i64 mc_writeobj_nsymbols;
static i64 mc_writeobj_stoffset = 0;

static struct $B52 mc_writeobj_stringtable;
static struct $B52 mc_writeobj_stringlengths;
static i64 mc_writeobj_nextstringoffset = 0;

static i64 mc_writeobj_nstrings = 0;

static struct $B2 mc_writeobj_writerelocs_s;
static struct $B38 mc_writeobj_makesymbol_r;
static struct $B38 mc_writeobj_strtoaux_r;
static struct $B38 mc_writeobj_sectiontoaux_r;
static struct $B22 mx_decls_mcxdirnames = {{
(u64)"pad_dir",
(u64)"version_dir",
(u64)"code_dir",
(u64)"idata_dir",
(u64)"zdata_dir",
(u64)"reloc_dir",
(u64)"dlls_dir",
(u64)"libs_dir",
(u64)"importsymbols_dir",
(u64)"exportsymbols_dir",
(u64)"exportsegs_dir",
(u64)"exportoffsets_dir",
(u64)"entry_dir",
(u64)"end_dir"}};

static struct $B12 mx_decls_mcxrelocnames = {{
(u64)"no_rel",
(u64)"locabs32",
(u64)"locabs64",
(u64)"impabs32",
(u64)"impabs64",
(u64)"imprel32"}};

static struct $B29 mx_decls_dllnametable;
static struct $B29 mx_decls_dllinsttable;
static i64 mx_decls_ndlllibs;
static struct $B29 mx_decls_libnametable;
static struct $B29 mx_decls_libtable;
static struct $B39 mx_decls_librelocated;
static struct $B39 mx_decls_libinitdone;
static i64 mx_decls_nlibs;
static struct $B53 mx_decls_symbolnametable;
static struct $B54 mx_decls_symboldefined;
static struct $B53 mx_decls_symboladdress;
static struct $B55 mx_decls_symbollibindex;
static struct $B54 mx_decls_symboldllindex;
static i64 mx_decls_nsymbols;
static i64 mx_decls_nsymimports = 0;

static i64 mx_decls_nsymexports = 0;

static struct $B12 mx_lib_rsegmentnames = {{
(u64)"no_seg",
(u64)"code_rseg",
(u64)"idata_rseg",
(u64)"zdata_rseg",
(u64)"rodata_rseg",
(u64)"impdata_rseg"}};

static u64 mx_write_dest;
static u64 mx_write_entrypoint;
static u64 mm_cli_syslibname = (u64)"";

static struct $B56 mm_cli_passnames = {{
(u64)"ma",
(u64)"list",
(u64)"proj",
(u64)"pcl",
(u64)"(int)",
(u64)"asm",
(u64)"obj",
(u64)"dll",
(u64)"exe",
(u64)"mx",
(u64)"(run)"}};

static struct $B30 mm_cli_dpassnames = {{
(u64)"dload_pass",
(u64)"dparse_pass",
(u64)"dfixup_pass",
(u64)"dname_pass",
(u64)"dtype_pass",
(u64)"dpcl_pass",
(u64)"dmcl_pass",
(u64)"dss_pass"}};

static struct $B57 mm_cli_optionnames = {{
(u64)"ma",
(u64)"getst",
(u64)"getproj",
(u64)"p",
(u64)"i",
(u64)"a",
(u64)"nasm",
(u64)"obj",
(u64)"dll",
(u64)"d",
(u64)"exe",
(u64)"mx",
(u64)"r",
(u64)"dload",
(u64)"dparse",
(u64)"dfixup",
(u64)"dname",
(u64)"dtype",
(u64)"dpcl",
(u64)"dmcl",
(u64)"dss",
(u64)"sys",
(u64)"min",
(u64)"nosys",
(u64)"linux",
(u64)"no",
(u64)"nopeep",
(u64)"noregs",
(u64)"ast1",
(u64)"ast2",
(u64)"ast3",
(u64)"showc",
(u64)"showpcl",
(u64)"showasm",
(u64)"st",
(u64)"stflat",
(u64)"types",
(u64)"showss",
(u64)"modules",
(u64)"shortnames",
(u64)"pst",
(u64)"time",
(u64)"v",
(u64)"vv",
(u64)"q",
(u64)"cs",
(u64)"ss",
(u64)"h",
(u64)"help",
(u64)"ext",
(u64)"o",
(u64)"outpath",
(u64)"unused",
(u64)"norip",
(u64)"himem"}};

static struct $B58 mm_cli_optionvalues = {{
1,
2,
3,
4,
5,
6,
6,
7,
8,
8,
9,
10,
11,
1,
2,
3,
4,
5,
6,
7,
8,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
3,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
2}};

static u8 mm_cli_msfile;
static u64 mm_cli_outext = (u64)"";

static i64 mm_cli_startclock;
static i64 mm_cli_endclock;
static i64 mm_cli_cmdskip;
static u64 mm_cli_inputfile;
static i64 mm_cli_loadtime;
static i64 mm_cli_parsetime;
static i64 mm_cli_resolvetime;
static i64 mm_cli_typetime;
static i64 mm_cli_ctime;
static i64 mm_cli_pcltime;
static i64 mm_cli_compiletime;
static u8 mm_cli_do_option_outused;
static u8 mm_cli_do_option_outpathused;
static i64 mm_genpcl_retindex;
static i64 mm_genpcl_initstaticsindex;
static u64 mm_genpcl_pcldoswx;
static struct $B59 mm_genpcl_loopstack;
static i64 mm_genpcl_loopindex;
static struct $B60 mm_genpcl_zero_unit;
static u64 mm_genpcl_pzero = (u64)&mm_genpcl_zero_unit;

static i64 mm_genpcl_nvarlocals;
static i64 mm_genpcl_nvarparams;
static i64 mm_blockpcl_nnn;
static struct $B29 mm_blockpcl_casestmt;
static struct $B29 mm_blockpcl_caseelse;
static i64 mm_blockpcl_casedepth;
static u64 mm_blockpcl_sw_labeltable;
static u64 mm_blockpcl_sw_valuetable;
static i64 mm_blockpcl_sw_lower;
static i64 mm_blockpcl_sw_ncases;
static u8 mm_blockpcl_sw_defaultseen;
static i64 mm_blockpcl_sw_defaultlabel;
static i64 mm_blockpcl_sw_breaklabel;
static i64 mm_blockpcl_maxreg = 0;

static u64 mm_blockpcl_pnprocs;
static u64 mm_blockpcl_pprocname;
static u64 mm_blockpcl_pprocaddr;
// Istatic skipped:mm_assem.initassemsymbols.regnames

// Istatic skipped:mm_assem.initassemsymbols.regnos

// Istatic skipped:mm_assem.initassemsymbols.sizes

static struct $B7 mm_decls_modules;
static struct $B61 mm_decls_moduletosub;
static struct $B62 mm_decls_subprogs;
static struct $B7 mm_decls_sources;
static struct $B63 mm_decls_subproghasstart;
static i64 mm_decls_nmodules;
static i64 mm_decls_nsubprogs;
static i64 mm_decls_nsourcefiles;
static i64 mm_decls_nlibfiles;
static u64 mm_decls_stprogram;
static u64 mm_decls_stmodule;
static i64 mm_decls_currmoduleno;
static u8 mm_decls_loadedfromma;
static struct $B3 mm_decls_lx;
static struct $B3 mm_decls_nextlx;
static struct $B64 mm_decls_libfiles;
static i64 mm_decls_mainsubprogno;
static i64 mm_decls_ntypes;
static struct $B65 mm_decls_ttnamedef;
static struct $B65 mm_decls_ttowner;
static struct $B66 mm_decls_ttbasetype;
static struct $B65 mm_decls_ttname;
static struct $B66 mm_decls_ttsize;
static struct $B67 mm_decls_ttsizeset;
static struct $B66 mm_decls_ttlower;
static struct $B66 mm_decls_ttlength;
static struct $B65 mm_decls_ttmult;
static struct $B65 mm_decls_ttdimexpr;
static struct $B66 mm_decls_tttarget;
static struct $B67 mm_decls_ttusercat;
static struct $B66 mm_decls_ttlineno;
static struct $B67 mm_decls_ttsigned;
static struct $B67 mm_decls_ttisreal;
static struct $B67 mm_decls_ttisinteger;
static struct $B67 mm_decls_ttisshort;
static struct $B67 mm_decls_ttisref;
static struct $B67 mm_decls_ttisblock;
static struct $B68 mm_decls_typenames;
static struct $B69 mm_decls_typenamepos;
static i64 mm_decls_ntypenames;
static struct $B36 mm_decls_typestarterset;
static u64 mm_decls_currproc;
static i64 mm_decls_assemmode = 0;

static i64 mm_decls_headermode = 0;

static u64 mm_decls_proclist;
static u64 mm_decls_proclistx;
static u64 mm_decls_staticlist;
static u64 mm_decls_staticlistx;
static u64 mm_decls_constlist;
static u64 mm_decls_constlistx;
static u64 mm_decls_nullunit;
static i64 mm_decls_ndllproctable;
static struct $B70 mm_decls_dllproctable;
static i64 mm_decls_fverbose = 1;

static u8 mm_decls_msyslevel = 2;

static u8 mm_decls_mvarlib = 0;

static u8 mm_decls_fvarnames = 0;

static u8 mm_decls_fshowtiming;
static u8 mm_decls_fshowss;
static u8 mm_decls_fshowc;
static u8 mm_decls_fshowpcl;
static u8 mm_decls_fshowasm;
static u8 mm_decls_fshowast1;
static u8 mm_decls_fshowast2;
static u8 mm_decls_fshowast3;
static u8 mm_decls_fshowst;
static u8 mm_decls_fshowpst;
static u8 mm_decls_fshowstflat;
static u8 mm_decls_fshowtypes;
static u8 mm_decls_fshowmodules;
static u8 mm_decls_fcheckunusedlocals = 0;

static u8 mm_decls_highmem = 1;

static u8 mm_decls_clinux;
static u8 mm_decls_dointlibs = 1;

static i64 mm_decls_passlevel = 0;

static i64 mm_decls_dpasslevel = 0;

static i64 mm_decls_prodmode = 0;

static i64 mm_decls_debugmode = 0;

static i64 mm_decls_libmode = 0;

static i64 mm_decls_fshortnames;
static u64 mm_decls_outfile;
static u64 mm_decls_destfilename;
static u64 mm_decls_destfilepath;
static i64 mm_decls_nunits;
static i64 mm_decls_nunitsmem;
static i64 mm_diags_currlineno;
static i64 mm_diags_currfileno;
static struct $B3 mm_diags_sbuffer;
static u64 mm_diags_dest = (u64)&mm_diags_sbuffer;

// Istatic skipped:mm_diags.printunit.cmpchain

static struct $B41 mm_diags_getprefix_str;
static struct $B71 mm_diags_getlineinfok_str;
// Istatic skipped:mm_diags.printmodelist.tab

// Istatic skipped:mm_diags.showprojectinfo.tab

static struct $B29 mm_lex_lxstart_stack;
static struct $B29 mm_lex_lxsource_stack;
static struct $B29 mm_lex_lxsptr_stack;
static struct $B29 mm_lex_lxfileno_stack;
static struct $B6 mm_lex_lxnextlx_stack;
static struct $B39 mm_lex_lximport_stack;
static i64 mm_lex_sourcelevel = 0;

static i64 mm_lex_lximport;
static u64 mm_lex_lxsource;
static u64 mm_lex_lxstart;
static u64 mm_lex_lxsptr;
static i64 mm_lex_lxifcond;
static i64 mm_lex_lxfileno;
static struct $B72 mm_lex_hashtable;
static struct $B16 mm_lex_namemap;
static u64 mm_lex_u64maxstr = (u64)"18446744073709551615";

static i64 mm_lib_autotypeno = 0;

static i64 mm_lib_nextavindex = 0;

static i64 mm_lib_nextsvindex = 0;

static struct $B3 mm_lib_exprstrvar;
static u64 mm_lib_exprstr = (u64)&mm_lib_exprstrvar;

static u64 mm_lib_unitheapptr = 0;

static i64 mm_lib_remainingunits = 0;

static struct $B3 mm_lib_sbuffer;
static u64 mm_lib_dest = (u64)&mm_lib_sbuffer;

static u64 mm_lib_jdest;
static u64 mm_lib_framevarname;
static struct $B17 mm_lib_nextautotype_str;
static struct $B16 mm_lib_getdottedname_str;
static struct $B4 mm_lib_strmode_str;
static struct $B4 mm_lib_strmode2_str;
static struct $B73 mm_libsources_syslibnames = {{
(u64)"msyswin.m",
(u64)"msyswinc.m",
(u64)"msyswini.m",
(u64)"msyslinc.m",
(u64)"msys.m",
(u64)"msysc.m",
(u64)"msysmin.m",
(u64)"mlib.m",
(u64)"mclib.m",
(u64)"mwindows.m",
(u64)"mlinux.m",
(u64)"mwindll.m",
(u64)"mwindllc.m"}};

static struct $B73 mm_libsources_syslibtext = {{
(u64)"module msys\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindll\n\n!proc start=\n!\tCPL \"MSYSWIN/START\"\n!END\n",
(u64)"module msysc\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindllc\n",
(u64)"module msys\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindllc\n",
(u64)"module msysc\nmodule mlib\nmodule mclib\nmodule mlinux\nmodule mwindllc\n",
(u64)"global record procinforec=\n\tu16\t\t\tfnindex\n\tbyte\t\trettype\n\tbyte\t\tnparams\n\t[12]byte\tparamlist\nend\n\n!for print/read routines\n!------------------------------------------\nexport record fmtrec=\t! (default)\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\n\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\n\tchar\tpadchar\t\t! Pc, Z (' ')\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\n\n\tchar\tplus\t\t! (0)   0 or '+'\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\n\tchar\tcharmode\t! C,M (0)  0 or 'C' or 'M'\to/p int as int or single char or multi-char\n\tchar\theapmode\t! D (0)  'D' for str-functions, return ptr to heap string\n\tchar\tparam\t\t! Use int value for <fmtparam>\n\tbyte\tspare : (showtype:1, newline:1)\nend\n\nint fmtparam\t\t\t!as set with :'V'\n\nenumdata =\n\tstd_io,file_io,str_io\nend\n\nconst comma = ','\n\nexport int $cmdskip\t\t\t!0 unless set by READMCX/etc\n\nexport int needgap\t\t\t= 0\nint outdev\t\t\t= std_io\nfilehandle outchan\t= nil\nref char fmtstr \t= nil\n\nconst maxiostack=10\n[maxiostack]filehandle\toutchan_stack\n[maxiostack]int\t\t\toutdev_stack\n[maxiostack]ref char\tfmtstr_stack\n[maxiostack]byte\t\tneedgap_stack\n\n[maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\nint niostack=0\n\n[0:]char digits=s\"0123456789ABCDEF\"\nconst onesixty=360\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\n\n!Read buffer vars\nexport const rd_buffersize = 16384\t!total capacity of line buffer\n\nexport ref char rd_buffer\t\t! point to start of read buffer\nexport int rd_length\t\t\t! length of this line (as read by readln)\nexport ref char rd_pos\t\t\t! current position it's up to (next read starts here)\nexport ref char rd_lastpos\t\t! set by sread() just before reading used for reread()\n\nint termchar\t\t\t! terminator char set by readxxx()\nint itemerror\t\t\t!\tset by some read functions, eg for reals\n\n[4096]char printbuffer\nichar printptr\nint printlen\n\n!------------------------------------------\n\nconst maxparam=128\nexport int nsysparams\nexport int ncmdparams\nexport int nenvstrings\nexport [maxparam]ichar sysparams\n!export ref[]ichar cmdparams\nexport ref[0:]ichar cmdparams\nexport ref[]ichar envstrings\n!export [maxparam]ichar envstrings\n\nproc start=\n\ti32 nargs\n\tint nargs64\n\tref[]ichar args\n\tstatic [128]byte startupinfo\t\t\t! 68 or 104 bytes\n\tint res\n\n!res:=1234567\n!res:=0x1234567\n!\n!CPL \"MSYS/START\"\n\n\tres:=__getmainargs(&nargs,cast(&args),cast(&envstrings),0,cast(&startupinfo))\n!\tres:=__getmainargs(&nargs,cast(&args),nil,0,cast(&startupinfo))\n\t\n\tnsysparams:=nargs\n\n\tif nsysparams>maxparam then\n\t\tprintf(\"Too many params\\n\")\n\t\tstop 50\n\tfi\n\n\tnargs64:=nargs\t\t\t!bug when using 32-bit limit when compiled with mm\n\tfor i:=1 to nargs64 do\n\t\tsysparams[i]:=args[i]\n\tod\n\t\n!assume nsysparams is >=1, since first is always the program name\n\tncmdparams:=nsysparams-($cmdskip+1)\n\tcmdparams:=cast(&sysparams[$cmdskip+1])\n\n\tint j:=1\n\tnenvstrings:=0\n\twhile envstrings[j] do\n\t\t++nenvstrings\n\t\t++j\n\tod\nend\n\nproc pushio=\n\tif niostack>=maxiostack then\n\t\tprintf(\"Too many io levels\\n\")\n\t\tstop 53\n\tfi\n\t++niostack\n\toutchan_stack[niostack]\t:= outchan\n\toutdev_stack[niostack]\t:= outdev\n\tfmtstr_stack[niostack]\t:= fmtstr\n\tneedgap_stack[niostack]\t:= needgap\n\tneedgap:=0\n\tfmtstr:=nil\n\toutchan:=nil\nend\n\nexport proc m$print_startfile(ref void dev)=\n\tpushio()\n\toutchan:=cast(dev)\n\tif dev then\n\t\toutdev:=file_io\n\telse\n\t\toutdev:=std_io\n\tfi\n\tresetprintbuffer()\nend\n\nexport proc m$print_startstr(ref char s)=\n\tref ref char p\n\tpushio()\n\n\tptr_stack[niostack]:=s\n\tp:=&ptr_stack[niostack]\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startptr(ref ref char p)=\n\tpushio()\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startcon=\n\tpushio()\n\toutdev:=std_io\n\tresetprintbuffer()\nend\n\nexport proc m$print_setfmt(ref char format)=\n\tfmtstr:=format\nend\n\nexport proc m$print_end=\n\tneedgap:=0\n\tnextfmtchars(1)\n\tif niostack=1 and outdev in [std_io,file_io] then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif niostack=0 then return fi\n\toutchan\t:= outchan_stack[niostack]\n\toutdev\t:= outdev_stack[niostack]\n\tfmtstr\t:= fmtstr_stack[niostack]\n\tneedgap\t:= needgap_stack[niostack]\n\n\t--niostack\nend\n\nexport proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n\tif fmtstyle=nil then\n\t\tfmtstyle:=\"z8H\"\n\tfi\n\tm$print_u64(a,fmtstyle)\nend\n\nexport proc m$print_ptr_nf(u64 a)=\n\tm$print_ptr(a)\nend\n\nexport proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\tint n\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tif a>=0 then\n\t\t\tn:=u64tostr(a,&.s,10,0)\n\t\telsif a=i64.min then\n\t\t\tfmt:=defaultfmt\n\t\t\tdofmt\n\n\t\telse\n\t\t\ts[1]:='-'\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\n\t\tfi\n\n\t\tprintstr_n(&.s,n)\n\n\telse\n\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\tif fmt.param='V' then\n\t\t\tfmtparam:=a\n\t\t\tneedgap:=0\n\t\telse\ndofmt:\n\t\t\ttostr_i64(a,&fmt)\n\t\tfi\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_i64_nf(i64 a)=\n\tm$print_i64(a)\nend\n\nexport proc m$print_bool(i64 a, ichar fmtstyle=nil)=\n\tif a then\n\t\tm$print_str(\"True\",fmtstyle)\n\telse\n\t\tm$print_str(\"False\",fmtstyle)\n\tfi\nend\n\nexport proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%llu\",a)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_u64(a,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_r64(real x,ichar fmtstyle=nil)=\n\t[360]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%f\",x)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_r64(x,&fmt)\n\tfi\n\n\tneedgap:=1\nend\n\nexport proc m$print_r32(r32 x,ichar fmtstyle=nil)=\n\tm$print_r64(x,fmtstyle)\nend\n\nglobal proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n\t[32]char s\n!\tint cc@s\n\tfmtrec fmt\n\tint n\n\tbyte charmode:=0\n\n\tnextfmtchars()\n\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1, &fmt)\n\t\tcharmode:=fmt.charmode\n\tfi\n\n\tif charmode='M' then\n\t\tn:=domultichar(ref char(&a), 8, &.s, &fmt)\n!\t\tn:=domultichar(ref char(&a), 8, &.str, fmt)\n\telse\t\t\t\t\t\t!assume 'C'\n\t\t(ref int(&s)^):=a\t\n\t\ts[9]:=0\n\n\t\tn:=getutfsize(s)\t\t\t!isolate size of next char\n\tfi\n\n\tprintstr_n(s,n)\n\n\tneedgap:=1\nend\n\nexport proc m$print_str(ichar s, fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr(s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,-1,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr_n(s,length)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,length,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_str_nf(ichar s)=\n\tm$print_str(s)\nend\n\nexport proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\nABORTPROGRAM(\"PRTSL\")\n!\tnextfmtchars()\n!\n!!\tfmtrec fmt\n!\n!\tif fmtstyle=nil then\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\n!!\t\tprintstr_n(cast(ss.str),ss.length)\n!\telse\n!\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\n!!\t\tstrtofmt(fmtstyle,-1,&fmt)\n!!\t\ttostr_str(s,s.len,&fmt)\n!\tfi\n!\tneedgap:=1\nend\n\nexport proc m$print_newline=\n!PUTS(\"<NEWLINE>\")\n\tneedgap:=0\n\tnextfmtchars(1)\n\tprintstr(\"\\w\")\nend\n\nexport proc m$print_nogap=\n\tneedgap:=0\nend\n\nexport proc m$print_space=\n\tneedgap:=0\n\tprintstr(\" \")\nend\n\nexport proc printstr(ichar s)=\n\tprintstr_n(s,strlen(s))\nend\n\nexport proc printstr_n(ichar s,int n)=\n\n!\treturn when n=0\n\n!\tif niostack=1 and outdev in [std_io,file_io] then\n!!puts(\"ADDTO BUFF\")\n!\t\taddtobuffer(s,n)\n!\telse\n!printf(\"DUMPSTR %lld\\n\", n)\n\t\tdumpstr(s,n)\n!\tfi\nend\n\nexport proc printstrn_app(ichar s, int length, filehandle f=nil)=\nif length then\n\tif f=nil then\n\t\tprintf(\"%.*s\",length,s)\n\telse\n\t\tfprintf(f,\"%.*s\",length,s)\n\tfi\nfi\nend\n\nproc printchar(int ch)=\n\t[4]char str\n\n\tstr[1]:=ch\n\tstr[2]:=0\n\tprintstr_n(str,1)\nend\n\nglobal proc nextfmtchars(int lastx=0)=\n\tchar c\n\tref char pstart\n\tint n\n\tif not fmtstr then\t\t\t!format not in use\n\t\tif needgap then\n\t\t\tprintchar(' ')\n\t\tfi\n\t\tneedgap:=0\n\t\treturn\n\tfi\n\n\tpstart:=fmtstr\n\tn:=0\n\n\tdo\n\t\tc:=fmtstr^\n\t\tcase c\n\t\twhen '#' then\n\t\t\tif lastx then\n\t\t\t\tgoto skip\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\tfi\n\t\t\treturn\n\t\twhen 0 then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\telsif not lastx then\n\t\t\t\tprintstr_n(\"|\",1)\n\t\t\tfi\n\t\t\treturn\n\t\twhen '~' then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\t\tn:=0\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tc:=fmtstr^\n\t\t\tif c then\n\t\t\t\t++fmtstr\n\t\t\t\tprintchar(c)\n\t\t\tfi\n\t\t\tpstart:=fmtstr\n\t\telse\n\tskip:\n\t\t\t++n\n\t\t\t++fmtstr\n\t\tesac\n\tod\nend\n\nexport proc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\n!convert format code string in s, to fmtrec at fmt^\n!Format code is a string containing the following char codes (upper or lower when mostly)\n!n\tWidth\n!.n\tMax width/precision\n!A\tConvert to upper case\n!a\tConvert to lower case\n!B\tBinary\n!C\tShow int as single n-bit (unicode) character\n!D\tDuplicate string returned via STRINT etc on heap\n!E,F,G\tSpecify format for double (corresponds to C format codes)\n!F\n!G\n!H\tHex\n!JC\tJustify centre\n!JL\tJustify left\n!JR\tJustify right\n!M\tShow int as multi-bit (unicode) character\n!M\tHEAPMODE???\n!O\tOctal\n!Pc\tUse padding char c\n!Q\tAdd double quotes around string (and deal with embedded quotes)\n!'\tAdd single quotes around string (and deal with embedded quotes)\n!Sc\tUse separator char c between every 3 or 4 digits\n!Tc\tUse terminator char c (typically B or H)\n!U\tShow ints as unsigned\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\n!W\tUnsigned\n!Xn\tUse base n (n is hex 0 to F)\n!Z\tUse \"0\" padding\n!+\tAlways have + or - in front of integers\n!~\tQuote char is ~\n!*\tSame as n but uses parameter set with :'V' on previous int\n\n\tint c, base\n\tbyte wset\n\tint n\n\t[0:100]char str\n\n\tfmt^:=defaultfmt\n\n\tif s=nil then return fi\n\n\tif slen=-1 then slen:=strlen(s) fi\n\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\n\tstr[slen]:=0\n\ts:=&.str\n\n\twset:=0\n\twhile s^ do\n\t\tc:=s^\n\t\t++s\n\t\tif c='A' then fmt.lettercase:='A'\n\t\telsif c='a' then fmt.lettercase:='a'\n\t\telseswitch toupper(c)\n\t\twhen 'B' then fmt.base:=2\n\t\twhen 'H' then fmt.base:=16\n\t\twhen 'O' then fmt.base:=8\n\t\twhen 'X' then\n\t\t\tbase:=0\n\t\t\tdo\n\t\t\t\tc:=s^\n\t\t\t\tif c in '0'..'9' then\n\t\t\t\t\tbase:=base*10+c-'0'\n\t\t\t\t\t++s\n\t\t\t\telse\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\tod\n\t\t\tif base in 2..16 then\n\t\t\t\tfmt.base:=base\n\t\t\tfi\n\n\t\twhen 'Q' then fmt.quotechar:='\"'\n\t\twhen 'J' then\n\t\t\tfmt.justify:=toupper(s^)\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'Z' then fmt.padchar:='0'\n\t\twhen 'S' then\n\t\t\tfmt.sepchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'P' then\n\t\t\tfmt.padchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'T' then\n\t\t\tfmt.suffix:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'U' then fmt.usigned:='W'\n\t\twhen 'E' then fmt.realfmt:='e'\n\t\twhen 'F' then fmt.realfmt:='f'\n\t\twhen 'G' then fmt.realfmt:='g'\n\t\twhen 'D' then fmt.heapmode:='D'\n\t\twhen 'C' then fmt.charmode:='C'\n\t\twhen 'M' then fmt.charmode:='M'\n\t\twhen 'V' then fmt.param:='V'\n\t\twhen 'Y' then fmt.showtype:=1\n\t\twhen 'N' then fmt.newline:=1\n\t\telsecase c\n\t\twhen '.' then\n\t\t\twset:=1\n\t\twhen comma,'_' then fmt.sepchar:=c\n\t\twhen '+' then fmt.plus:='+'\n\t\twhen '~' then fmt.quotechar:='~'\n\t\twhen '*' then\n\t\t\tn:=fmtparam\n\t\t\tgoto gotwidth\n\t\telse\n\t\t\tif c>='0' and c<='9' then\n\t\t\t\tn:=c-'0'\n\t\t\t\tdo\n\t\t\t\t\tc:=s^\n\t\t\t\t\tif s^=0 then\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tif c>='0' and c<='9' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\tn:=n*10+c-'0'\n\t\t\t\t\telse\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\tod\ngotwidth:\n\t\t\t\tif not wset then\n\t\t\t\t\tfmt.minwidth:=n\n\t\t\t\t\twset:=1\n\t\t\t\telse\n\t\t\t\t\tfmt.precision:=n\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tod\nend\n\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\n!there are n (4 or 8) chars at p.!\n!There could be 0 to 4 or 8 printable chars converted to string at dest\n\t[0:20]char str\n\tref char q\n\tint nchars\n\n\tq:=&.str\n\n\tnchars:=n\n\n\tto n do\n\t\tif p^=0 then exit fi\n\t\tq^:=p^\n\t\t++q\n\t\t++p\n\tod\n\tq^:=0\n\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\nend\n\nexport function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\n!s contains a partly stringified value.\n!widen s if necessary, according to fmt, and copy result to t\n!n is current length of s\n!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving\n!a leading +/- when right-justifying with '0' padding.\n!t MUST be big enough for the expanded string; caller must take care of this\n!result will be zero-terminated, for use in this module\n\n\tint i,w,m\n\n!check to see if result is acceptable as it is\n\tw:=fmt.minwidth\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\n\t\tstrncpy(t,s,n)\n\t\t(t+n)^:=0\n\t\treturn n\n\tfi\n\n\tif fmt.justify='L' then\t! left-justify\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tfor i:=1 to w-n do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\telsif fmt.justify='R' then\n\t\tif fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside \n\t\t\tt^:=s^\n\t\t\t++t\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s+1,n-1)\n\t\t\t(t+n-1)^:=0\n\t\telse\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s,n)\n\t\t\t(t+n)^:=0\n\t\tfi\n\n\telse\t\t\t\t! centre-justify?\n\n\t\tm:=(w-n+1)/2\n\t\tto m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tto w-n-m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\n\tfi\n\treturn w\nend\n\nexport function u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\n!convert 64-bit int a to string in s^\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\n!result when a=minint (will give \"<minint>\")\n\t[0:onesixty]char t\n\tu64 dd\n\tint i,j,k,g\n\tref char s0\n\n\ti:=0\n\tk:=0\n\tg:=(base=10|3|4)\n\n\trepeat\n!\t\tif base=10 then\t\t\t!BUGGY FOR AA OVER I64.MAX\n!\t\t\tassem\n!\t\t\t\tmov\t\trcx, [aa]\n!\t\t\t\tmov\t\trax, rcx\n!\t\t\t\tmov\t\trdx, 7378697629483820647\n!\t\t\t\timul\trdx\n!\t\t\t\tmov\t\trax, rdx\n!\t\t\t\tmov\t\trdx, rcx\n!\t\t\t\tsar\t\trdx, 63\n!\t\t\t\tsar\t\trax, 2\n!\t\t\t\tsub\t\trax, rdx\n!\t\t\t\tlea\t\trdx, [rax+rax*4]\n!\t\t\t\tadd\t\trdx, rdx\n!\t\t\t\tsub\t\trcx, rdx\n!\t\t\t\tmov\t\t[dd], rcx\n!\t\t\t\tmov\t\t[aa], rax\n!\t\t\tend\n!\t\telse\n\t\t\tdd:=aa rem base\n\t\t\taa:=aa/base\n!\t\tfi\n\n\t\tt[++i]:=digits[dd]\n\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\n!out a full length binary\n!so perhaps move this out to expandstr\n\t\t++k\n\t\tif sep and aa<>0 and k=g then\n\t\t\tt[++i]:=sep\n\t\t\tk:=0\n\t\tfi\n\tuntil aa=0\n\n\tj:=i\n\ts0:=s\n\twhile i do\n\t\ts^:=t[i--]\n\t\t++s\n\tod\n\ts^:=0\n\n\treturn j\nend\n\nexport function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\n!convert a to a string in s, according to fmt\n!a basic conversion is done first,: the field manipulation is done\n!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)\n!returns length of s\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n, usigned\n\tconst i64 mindint=0x8000'0000'0000'0000\n\n\tusigned:=0\n\tif fmt.usigned then\n\t\tusigned:=1\n\tfi\n\tif aa=mindint and not usigned then\t\t! minint\n\n\t\tstr[0]:='-'\n\t\tn:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1\n\n\telse\n\t\tif (not usigned and aa<0) or fmt.plus then\n\t\t\tif aa<0 then\n\t\t\t\taa:=-aa\n\t\t\t\tstr[0]:='-'\n\t\t\telse\n\t\t\t\tstr[0]:='+'\n\t\t\tfi\n\t\t\tn:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1\n\t\telse\n\t\t\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\t\tfi\n\tfi\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'\tthen\t! need lower when\n\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\n!see i64tostrfmt\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n\n\n\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif fmt.base>10 or fmt.suffix and fmt.lettercase='a'\tthen\t! need lower when\n!\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\n!convert minint to string in s do not include minus sign\n!return number of chars in string\n\t[0:onesixty]char t\n\tint i,j,k,g\n\n\tcase base\n\twhen 10 then\n\t\tstrcpy(&t[0],\"9223372036854775808\")\n\t\tj:=3\n\twhen 16 then\n\t\tstrcpy(&t[0],\"8000000000000000\")\n\t\tj:=1\n\twhen 2 then\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\n\t\tj:=7\n\telse\n\t\tstrcpy(&t[0],\"<mindint>\")\n\tesac\n\n\ti:=strlen(&t[0])\n\ts+:=i\n\tif sep then\n\t\ts+:=j\n\tfi\n\ts^:=0\n\n\tk:=0\n\tg:=(base=10|3|4)\n\n\twhile i do\n\t\t--s\n\t\ts^:=t[i-- -1]\n\t\tif sep and i and ++k=g then\n\t\t\t--s\n\t\t\ts^:=sep\n\t\t\tk:=0\n\t\tfi\n\tod\n\treturn strlen(s)\nend\n\nexport function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\n!s is a string process according to fmtrec fmt^, and return result in t\n!caller should check whether any changes are required to s (now it can just use s), but this\n!check is done here anyway (with a simple copy to t)\n!n is current length of s\n!return length of t\n!Three processing stages:\n!1 Basic input string s\n!2 Additions or mods: quotes, suffix, when conversion\n!3 Width adjustment\n!1 is detected here, 2 is done here, 3 is done by expandstr\n\tref char u,v\n\t[256]char str\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\n\n\tnheap:=0\n\n\tif fmt.quotechar or fmt.lettercase then\t\t! need local copy\n\t\tif n<256 then\n\t\t\tu:=&.str\n\t\telse\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\n\t\t\tu:=pcm_alloc(nheap)\n\t\tfi\n\t\tif fmt.quotechar then\n\t\t\tv:=u\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tif n then\n\t\t\t\tstrcpy(v,s)\n\t\t\t\tv+:=n\n\t\t\tfi\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tv^:=0\n\t\t\tn+:=2\n\t\telse\n\t\t\tmemcpy(u,s,n)\n\t\tfi\n\t\tcase fmt.lettercase\n\t\twhen 'a' then\t! need lower when\n\t\t\tconvlcstring(u)\n\t\twhen 'A' then\n\t\t\tconvucstring(u)\n\t\tesac\n\t\ts:=u\n\tfi\n\n\tw:=fmt.minwidth\n\tif w>n then\n\t\tn:=expandstr(s,t,n,fmt)\n\telse\n\t\tmemcpy(t,s,n)\n\tfi\n\tif nheap then\n\t\tpcm_free(u,nheap)\n\tfi\n\treturn n\nend\n\nproc tostr_i64(i64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 0 then\n\t\tn:=i64tostrfmt(a,&.str,fmt)\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\telse\t\t\t\t\t\t!assume 'C'\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_u64(u64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\twhen 'C' then\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\n\telse\n\t\tn:=u64tostrfmt(a,&.str,fmt)\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_r64(real x,ref fmtrec fmt) =\n\t[360]char str,str2\n\t[0:10]char cfmt\n\tint n\n\n\tcfmt[0]:='%'\n\n\tif fmt.precision then\n\t\tcfmt[1]:='.'\n\t\tcfmt[2]:='*'\n\t\tcfmt[3]:=fmt.realfmt\n\t\tcfmt[4]:=0\n\t\tsprintf(&.str,&.cfmt,fmt.precision,x)\n\telse\n\t\tcfmt[1]:=fmt.realfmt\n\t\tcfmt[2]:=0\n\t\tsprintf(&.str,&.cfmt,x)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\n\tn:=strlen(&.str)\t\t! current length\n\n\tif n<fmt.minwidth then\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\n\t\tstrcpy(&.str,&.str2)\n\tfi\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_str(ref char s, int oldlen, ref fmtrec fmt) =\n\tint newlen,n\n\tref char t\n\n!try and work out size of formatted string\n\tif oldlen=-1 then\n\t\toldlen:=strlen(s)\n\tfi\n\tnewlen:=oldlen\n\n\tif fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then\n\t\tif fmt.quotechar then\n\t\t\tnewlen+:=2\n\t\tfi\n\t\tif fmt.minwidth>newlen then\n\t\t\tnewlen:=fmt.minwidth\n\t\tfi\n\t\tt:=pcm_alloc(newlen+1)\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\n\t\tif fmt.precision then\n\t\t\tn min:=fmt.precision\n\t\tfi\n\n\t\tprintstr_n(t,n)\n\t\tpcm_free(t,newlen+1)\n\telse\n\t\tprintstr_n(s,oldlen)\n\tfi\nend\n\nfunction getfmt(ichar fmtstyle)ref fmtrec=\n\tstatic fmtrec fmt\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\treturn &fmt\n\telse\n\t\treturn &defaultfmt\n\tfi\nend\n\nexport function strint(i64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport proc getstrint(i64 a, ichar dest)=\n\tm$print_startstr(dest)\n\ttostr_i64(a,getfmt(nil))\n\tm$print_end()\nend\n\nexport function strword(u64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function strreal(real a, ichar fmtstyle=nil)ichar=\n\tstatic [320]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function getstr(ichar s, ref fmtrec fmt)ichar=\n\tif fmt.heapmode then\n\t\treturn pcm_copyheapstring(s)\n\telse\n\t\treturn s\n\tfi\nend\n\nproc initreadbuffer=\n\tif rd_buffer then return fi\n\trd_buffer:=pcm_alloc(rd_buffersize)\n\trd_buffer^:=0\n\trd_pos:=rd_lastpos:=rd_buffer\nend\n\nglobal proc m$read_conline=\n\tinitreadbuffer()\n\n\treadlinen(nil,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_fileline(filehandle f)=\n\tinitreadbuffer()\n\n\tif f=filehandle(1) then\nABORTPROGRAM(\"READ CMDLINE\")\n!\t\trd_buffer^:=0\n!\t\tp:=getcommandlinea()\n!\t\trepeat\n!\t\t\t++p\n!\t\tuntil p^ in [' ','\\t',0]\n!\t\tstrcpy(rd_buffer, p)\n!\t\trd_length:=strlen(rd_buffer)\n!\t\trd_pos:=rd_buffer\n!\t\trd_lastpos:=nil\n\t\treturn\n\tfi\n\n\treadlinen(f,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_strline(ichar s)=\n\tint n\n\n\tinitreadbuffer()\n\tn:=strlen(s)\n\n\tif n<rd_buffersize then\n\t\tstrcpy(rd_buffer,s)\n\telse\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\n\t\t(rd_buffer+rd_buffersize-1)^:=0\n\tfi\n\trd_length:=n\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nfunction readitem(int &itemlength)ref char =\n!read next item from rd_buffer\n!identify a substring that can contain a name, int, real, string or filename\n!return updated position of s that points past the item and past the immediate\n!terminator \n!information about the read item is returned in itemstr, which points to\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\n!Item can be quoted, then the item points inside the quotes\n!Any embedded quotes are removed, and the characters moved up. The item will\n!be that reduced subsequence\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\n!I can mitigate this by adding spaces between the end of the item, and the next item,\n!overwriting also the terminator. But this won't restore the line if one of the next\n!reads is literal, using 'L' or 'C' codes.\n\tref char p,s,itemstr\n\tchar quotechar, c\n\n\tunless rd_buffer then \n\t\tinitreadbuffer()\n\tend unless\n\n\ts:=rd_pos\n\n!scan string, eliminating leading white space\n\twhile s^=' ' or s^=9 do\n\t\t++s\n\tod\n\n\titemstr:=s\n\trd_lastpos:=rd_pos:=s\n\n\tif s^=0 then\n\t\ttermchar:=0\n\t\titemlength:=0\n\t\treturn s\n\tfi\n\n\tquotechar:=0\n\tif s^='\"' then\n\t\tquotechar:='\"'\n\t\t++s\n\telsif s^='\\'' then\n\t\tquotechar:='\\''\n\t\t++s\n\tfi\n\n!loop reading characters until separator or end reached\n\tp:=itemstr:=s\n\n\twhile s^ do\n\t\tc:=s++^\n\t\tcase c\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\n\t\t\t\tgoto normalchar\n\t\t\tfi\n\t\t\ttermchar:=c\n\t\t\texit\n\t\telse\n\tnormalchar:\n\t\t\tif c=quotechar then\n\t\t\t\tif s^=quotechar then\t! embedded quote\n\t\t\t\t\tp^:=c\n\t\t\t\t\t++s\n\t\t\t\t\t++p\n\t\t\t\telse\t\t\t\t\t! end of name\n\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tif termchar in [',', '='] then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tfi\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tp^:=c\n\t\t\t\t++p\n\t\t\tfi\n\t\tesac\n\tod\n\n\tif s^=0 then\n\t\ttermchar:=0\n\tfi\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\n\trd_pos:=s\n\n\treturn itemstr\nend\n\nexport function strtoint(ichar s,int length=-1, word base=10)i64=\n!return point to next char after terminator (which can be just off length of string)\n\tbyte signd\n\tu64 aa\n\tword c,d\n\n\titemerror:=0\n\n\tif length=-1 then\n\t\tlength:=strlen(s)\n\tfi\n!check for sign\n\tsignd:=0\n\tif length and s^='-' then\n\t\tsignd:=1; ++s; --length\n\telsif length and s^='+' then\n\t\t++s; --length\n\tfi\n\n\taa:=0\n\twhile length do\n\t\tc:=s++^\n\t\t--length\n\t\tif c in 'A'..'F' then d:=c-'A'+10\n\t\telsif c in 'a'..'f' then d:=c-'a'+10\n\t\telsif c in '0'..'9' then d:=c-'0'\n\t\telsif c in ['_', '\\''] then\n\t\t\tnextloop\n\t\telse\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\n\t\tif d>=base then\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\t\taa:=aa*base+d\n\tod\n\n\tif signd then\n\t\treturn -aa\n\telse\n\t\treturn aa\n\tfi\nend\n\nglobal function m$read_i64(int fmt=0)i64=\n\tref char s\n\tint length\n\n\tfmt:=toupper(fmt)\n\n\tcase fmt\n\twhen 'C' then\n\t\trd_lastpos:=rd_pos\n\t\tif rd_pos^ then\n\t\t\treturn rd_pos++^\n\t\telse\n\t\t\treturn 0\n\t\tfi\n\twhen 'T' then\n\t\treturn termchar\n\twhen 'E' then\n\t\treturn itemerror\n\tesac\n\n\ts:=readitem(length)\n\n\tcase fmt\n\twhen 0,'I' then\n\t\treturn strtoint(s,length)\n\twhen 'B' then\n\t\treturn strtoint(s,length,2)\n\twhen 'H' then\n\t\treturn strtoint(s,length,16)\n\tesac\n\treturn 0\nend\n\nglobal function m$read_r64(int fmt=0)real=\n\t[512]char str\n\tref char s\n\tint length\n\ti32 numlength\n\treal x\n\n\ts:=readitem(length)\n\n\tif length=0 or length>=str.len then\t\t!assume not a real\n\t\treturn 0.0\n\tfi\n\tmemcpy(&.str,s,length)\n\tstr[length+1]:=0\n\n\titemerror:=0\n\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\n\t\tx:=0.0\n\t\titemerror:=1\n\tfi\n\n\treturn x\nend\n\nglobal proc m$read_str(ref char dest, int destlen=0,fmt=0)=\n\tref char s\n\tint length\n\n\titemerror:=0\n\tif fmt in ['L','l'] then\n\t\ts:=rd_pos\n\t\tlength:=rd_buffer+rd_length-rd_pos\n\n\telse\n\t\ts:=readitem(length)\n\n\t\tif fmt in ['N','n'] then\n\t\t\ticonvlcn(s,length)\n\t\tfi\n\tfi\n\n\tif destlen>0 then\n\t\tif length>=destlen then\n\t\t\tlength:=destlen-1\n\t\t\titemerror:=1\n\t\tfi\n\tfi\n\tmemcpy(dest,s,length)\n\t(dest+length)^:=0\nend\n\nexport proc readstr(ref char dest, int fmt=0,destlen=0)=\n\tm$read_str(dest,destlen,fmt)\nend\n\nexport proc rereadln=\n\trd_pos:=rd_buffer\n\trd_lastpos:=rd_pos\nend\n\nexport proc reread=\n\trd_pos:=rd_lastpos\nend\n\nexport function valint(ichar s, int fmt=0)i64=\n\tref char old_pos, old_lastpos\n\ti64 aa\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\taa:=m$read_i64(fmt)\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn aa\nend\n\nexport function valreal(ichar s)real=\n\tref char old_pos, old_lastpos\n\treal x\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\tx:=m$read_r64()\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn x\nend\n\nproc mclunimpl(ichar mess)=\n\tprintf(\"MCL-UNIMPL: %s\\n\",mess)\n\tstop 1\nend\n\nproc dumpstr(ichar s, int n, fbuffer=0)=\n!fbuffer=1 when outputting contents of buffer\n\n\tref ref char p\n\n\tif outdev=str_io then\n\t\tp:=cast(outchan)\n\t\tif n then\n\t\t\tmemcpy(p^,s,n)\n\t\t\tp^+:=n\n\t\tfi\n\t\tp^^:=0\n\t\treturn\n\tfi\n\n\treturn when n=0\n\tif fbuffer and n>=2 and outdev=std_io then\n\t\t--printptr\t\t\t\t!point to last char\n\t\tif printptr^=10 then\n\t\t\tif (printptr-1)^=13 then\t\t!crlf\n\t\t\t\t(printptr-1)^:=0\n\t\t\telse\t\t\t\t\t\t\t!lf only\n\t\t\t\tprintptr^:=0\n\t\t\tfi\n\t\t\tputs(printbuffer)\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\tesac\nend\n\nproc dumpprintbuffer=\n\tif printlen then\n\t\tdumpstr(&.printbuffer,printlen,1)\n\tfi\n\n\tresetprintbuffer()\nend\n\nproc resetprintbuffer=\n\tprintptr:=&.printbuffer\n\tprintlen:=0\nend\n\nproc addtobuffer(ichar s, int n)=\n\tif printlen+n>=(printbuffer.len-8) then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif n<printbuffer.len then\n\t\tmemcpy(printptr,s,n)\n\t\tprintptr+:=n\n\t\tprintlen+:=n\n\t\treturn\n\tfi\n\n\tdumpstr(s, n)\t\t\t!don't bother with buffer\nend\n\nglobal function m$power_i64(i64 a,n)i64=\n\tif n<0 then\n\t\treturn 0\n\telsif n=0 then\n\t\treturn 1\n\telsif n=1 then\n\t\treturn a\n\telsif (n iand 1)=0 then\n\t\treturn m$power_i64(sqr a,n/2)\n\telse\t\t\t!assume odd\n\t\treturn m$power_i64(sqr a,(n-1)/2)*a\n\tfi\nend\n\nfunc getutfsize(ref char s)int =\n!work out the size in bytes of the ascii or utf8 character that s points to\n\tint a\n\n\ta:=s++^\n\n\tif a=0 then\t\t\t\t\t\t!end of string\n\t\t0\n\telsif a.[7]=0 then\t\t\t\t!ascii\n\t\t1\n\telsif a.[7..5]=2x110 then\n\t\t2\n\telsif a.[7..4]=2x1110 then\n\t\t3\n\telsif a.[7..3]=2x11110 then\n\t\t4\n\telse\t\t\t\t\t\t\t!error: just assume a byte of random binary\n\t\t1\n\tfi\nend\n\n!export fun `fract(real x)real = fmod(x,1.0)\n!export fun fraction(real x)real = fmod(x,1.0)\n\nexport fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))\nexport func m$sign_r64(real x)real =\n\tif x<0 then return -1 fi\n\tif x>0 then return 1 fi\n\t0\nend\n",
(u64)"global record procinforec=\n\tu16\t\tfnindex\n\tbyte\t\trettype\n\tbyte\t\tnparams\n\t[12]byte\tparamlist\nend\n\n!for print/read routines\n!------------------------------------------\nexport record fmtrec=\t! (default)\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\n\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\n\tchar\tpadchar\t\t! Pc, Z (' ')\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\n\n\tchar\tplus\t\t! (0)   0 or '+'\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\n\tchar\tcharmode\t! C,M (0)  0 or 'C' or 'M'\to/p int as int or single char or multi-char\n\tchar\theapmode\t! D (0)  'D' for str-functions, return ptr to heap string\n\tchar\tparam\t\t! Use int value for <fmtparam>\n\tbyte\tspare : (showtype:1, newline:1)\nend\n\nint fmtparam\t\t\t!as set with :'V'\n\nenumdata =\n\tstd_io,file_io,str_io\nend\n\nconst comma = ','\n\nexport int $cmdskip\t\t\t!0 unless set by READMCX/etc\n\nexport int needgap\t\t\t= 0\nint outdev\t\t\t= std_io\nfilehandle outchan\t= nil\nref char fmtstr \t= nil\n\nconst maxiostack=10\n[maxiostack]filehandle\toutchan_stack\n[maxiostack]int\t\t\toutdev_stack\n[maxiostack]ref char\tfmtstr_stack\n[maxiostack]byte\t\tneedgap_stack\n\n[maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\nint niostack=0\n\n[0:]char digits=A\"0123456789ABCDEF\"\nconst onesixty=360\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\n\n!Read buffer vars\nexport const rd_buffersize = 16384\t!total capacity of line buffer\n\nexport ref char rd_buffer\t\t! point to start of read buffer\nexport int rd_length\t\t\t! length of this line (as read by readln)\nexport ref char rd_pos\t\t\t! current position it's up to (next read starts here)\nexport ref char rd_lastpos\t\t! set by sread() just before reading used for reread()\n\nint termchar\t\t\t! terminator char set by readxxx()\nint itemerror\t\t\t!\tset by some read functions, eg for reals\n\n[4096]char printbuffer\nichar printptr\nint printlen\n\n!------------------------------------------\n\nexport int ncmdparams\n!export ref[]ichar cmdparams\nexport ref[0:]ichar cmdparams\n\nproc $getcommands(int ncmd, ref[0:]ichar cmds, int cmdskipL)=\n!CPL =$CMDSKIP\n!CPL =CMDSKIPL\n\tncmdparams:=ncmd-1\n\tcmdparams:=cmds\nend\n\n!export proc m$init(int nargs, ref[]ichar args)=\n!\tnsysparams:=nargs\n!\n!\tif nsysparams>maxparam then\n!\t\tprintf(\"Too many params\\n\")\n!\t\tstop 1\n!\tfi\n!\n!\tfor i:=1 to nargs do\n!\t\tsysparams[i]:=args[i]\n!\tod\n!\n!!assume nsysparams is >=1, since first is always the program name\n!\tncmdparams:=nsysparams-($cmdskip+1)\n!\tcmdparams:=cast(&sysparams[$cmdskip+1])\n!\n!\tint j:=1\n!\tnenvstrings:=0\n!!\twhile envstrings[j] do\n!!\t\t++nenvstrings\n!!\t\t++j\n!!\tod\n!\n!end\n\nproc pushio=\n\tif niostack>=maxiostack then\n\t\tprintf(\"Too many io levels\\n\")\n\t\tstop 53\n\tfi\n\t++niostack\n\toutchan_stack[niostack]\t:= outchan\n\toutdev_stack[niostack]\t:= outdev\n\tfmtstr_stack[niostack]\t:= fmtstr\n\tneedgap_stack[niostack]\t:= needgap\n\tneedgap:=0\n\tfmtstr:=nil\n\toutchan:=nil\nend\n\nexport proc m$print_startfile(ref void dev)=\n\tpushio()\n\toutchan:=cast(dev)\n\tif dev then\n\t\toutdev:=file_io\n\telse\n\t\toutdev:=std_io\n\tfi\n\tresetprintbuffer()\nend\n\nexport proc m$print_startstr(ref char s)=\n\tref ref char p\n\tpushio()\n\n\tptr_stack[niostack]:=s\n\tp:=&ptr_stack[niostack]\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startptr(ref ref char p)=\n\tpushio()\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startcon=\n\tpushio()\n\toutdev:=std_io\n\tresetprintbuffer()\nend\n\nexport proc m$print_setfmt(ref char format)=\n\tfmtstr:=format\nend\n\nexport proc m$print_end=\n\tneedgap:=0\n\tnextfmtchars(1)\n\tif niostack=1 and outdev in [std_io,file_io] then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif niostack=0 then return fi\n\toutchan\t:= outchan_stack[niostack]\n\toutdev\t:= outdev_stack[niostack]\n\tfmtstr\t:= fmtstr_stack[niostack]\n\tneedgap\t:= needgap_stack[niostack]\n\n\t--niostack\nend\n\nexport proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n\tif fmtstyle=nil then\n\t\tfmtstyle:=\"z8H\"\n\tfi\n\tm$print_u64(a,fmtstyle)\nend\n\nexport proc m$print_ptr_nf(u64 a)=\n\tm$print_ptr(a)\nend\n\nexport proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\tint n\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tif a>=0 then\n\t\t\tn:=u64tostr(a,&.s,10,0)\n\t\telsif a=i64.min then\n\t\t\tfmt:=defaultfmt\n\t\t\tdofmt\n\n\t\telse\n\t\t\ts[1]:='-'\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\n\t\tfi\n\n\t\tprintstr_n(&.s,n)\n\n\telse\n\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\tif fmt.param='V' then\n\t\t\tfmtparam:=a\n\t\t\tneedgap:=0\n\t\telse\ndofmt:\n\t\t\ttostr_i64(a,&fmt)\n\t\tfi\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_i64_nf(i64 a)=\n\tm$print_i64(a)\nend\n\nexport proc m$print_bool(i64 a, ichar fmtstyle=nil)=\n\tif a then\n\t\tm$print_str(\"True\",fmtstyle)\n\telse\n\t\tm$print_str(\"False\",fmtstyle)\n\tfi\nend\n\nexport proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%llu\",a)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_u64(a,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_r64(real x,ichar fmtstyle=nil)=\n\t[360]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%f\",x)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_r64(x,&fmt)\n\tfi\n\n\tneedgap:=1\nend\n\nexport proc m$print_r32(r32 x,ichar fmtstyle=nil)=\n\tm$print_r64(x,fmtstyle)\nend\n\nglobal proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n\t[32]char s\n!\tint cc@s\n\tfmtrec fmt\n\tint n\n\tbyte charmode:=0\n\n\tnextfmtchars()\n\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1, &fmt)\n\t\tcharmode:=fmt.charmode\n\tfi\n\n\tif charmode='M' then\n\t\tn:=domultichar(ref char(&a), 8, &.s, &fmt)\n!\t\tn:=domultichar(ref char(&a), 8, &.str, fmt)\n\telse\t\t\t\t\t\t!assume 'C'\n\t\t(ref int(&s)^):=a\t\n!\t\tcc:=a\t\n\t\ts[9]:=0\n\n\t\tn:=getutfsize(s)\t\t\t!isolate size of next char\n\tfi\n\n\tprintstr_n(s,n)\n\n\tneedgap:=1\nend\n\nexport proc m$print_str(ichar s, fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr(s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,-1,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr_n(s,length)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,length,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_str_nf(ichar s)=\n\tm$print_str(s)\nend\n\nexport proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\nABORTPROGRAM(\"PRTSL\")\n!\tnextfmtchars()\n!\n!!\tfmtrec fmt\n!\n!\tif fmtstyle=nil then\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\n!!\t\tprintstr_n(cast(ss.str),ss.length)\n!\telse\n!\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\n!!\t\tstrtofmt(fmtstyle,-1,&fmt)\n!!\t\ttostr_str(s,s.len,&fmt)\n!\tfi\n!\tneedgap:=1\nend\n\nexport proc m$print_newline=\n!PUTS(\"<NEWLINE>\")\n\tneedgap:=0\n\tnextfmtchars(1)\n\tprintstr(\"\\w\")\nend\n\nexport proc m$print_nogap=\n\tneedgap:=0\nend\n\nexport proc m$print_space=\n\tneedgap:=0\n\tprintstr(\" \")\nend\n\nexport proc printstr(ichar s)=\n\tprintstr_n(s,strlen(s))\nend\n\nexport proc printstr_n(ichar s,int n)=\n\n!\treturn when n=0\n\n!\tif niostack=1 and outdev in [std_io,file_io] then\n!!puts(\"ADDTO BUFF\")\n!\t\taddtobuffer(s,n)\n!\telse\n!printf(\"DUMPSTR %lld\\n\", n)\n\t\tdumpstr(s,n)\n!\tfi\nend\n\nexport proc printstrn_app(ichar s, int length, filehandle f=nil)=\nif length then\n\tif f=nil then\n\t\tprintf(\"%.*s\",length,s)\n\telse\n\t\tfprintf(f,\"%.*s\",length,s)\n\tfi\nfi\nend\n\nproc printchar(int ch)=\n\t[4]char str\n\n\tstr[1]:=ch\n\tstr[2]:=0\n\tprintstr_n(str,1)\nend\n\nglobal proc nextfmtchars(int lastx=0)=\n\tchar c\n\tref char pstart\n\tint n\n\tif not fmtstr then\t\t\t!format not in use\n\t\tif needgap then\n\t\t\tprintchar(' ')\n\t\tfi\n\t\tneedgap:=0\n\t\treturn\n\tfi\n\n\tpstart:=fmtstr\n\tn:=0\n\n\tdo\n\t\tc:=fmtstr^\n\t\tcase c\n\t\twhen '#' then\n\t\t\tif lastx then\n\t\t\t\tgoto skip\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\tfi\n\t\t\treturn\n\t\twhen 0 then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\telsif not lastx then\n\t\t\t\tprintstr_n(\"|\",1)\n\t\t\tfi\n\t\t\treturn\n\t\twhen '~' then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\t\tn:=0\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tc:=fmtstr^\n\t\t\tif c then\n\t\t\t\t++fmtstr\n\t\t\t\tprintchar(c)\n\t\t\tfi\n\t\t\tpstart:=fmtstr\n\t\telse\n\tskip:\n\t\t\t++n\n\t\t\t++fmtstr\n\t\tesac\n\tod\nend\n\nexport proc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\n!convert format code string in s, to fmtrec at fmt^\n!Format code is a string containing the following char codes (upper or lower when mostly)\n!n\tWidth\n!.n\tMax width/precision\n!A\tConvert to upper case\n!a\tConvert to lower case\n!B\tBinary\n!C\tShow int as single n-bit (unicode) character\n!D\tDuplicate string returned via STRINT etc on heap\n!E,F,G\tSpecify format for double (corresponds to C format codes)\n!F\n!G\n!H\tHex\n!JC\tJustify centre\n!JL\tJustify left\n!JR\tJustify right\n!M\tShow int as multi-bit (unicode) character\n!M\tHEAPMODE???\n!O\tOctal\n!Pc\tUse padding char c\n!Q\tAdd double quotes around string (and deal with embedded quotes)\n!'\tAdd single quotes around string (and deal with embedded quotes)\n!Sc\tUse separator char c between every 3 or 4 digits\n!Tc\tUse terminator char c (typically B or H)\n!U\tShow ints as unsigned\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\n!W\tUnsigned\n!Xn\tUse base n (n is hex 0 to F)\n!Z\tUse \"0\" padding\n!+\tAlways have + or - in front of integers\n!~\tQuote char is ~\n!*\tSame as n but uses parameter set with :'V' on previous int\n\n\tint c, base\n\tbyte wset\n\tint n\n\t[0:100]char str\n\n\tfmt^:=defaultfmt\n\n\tif s=nil then return fi\n\n\tif slen=-1 then slen:=strlen(s) fi\n\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\n\tstr[slen]:=0\n\ts:=&.str\n\n\twset:=0\n\twhile s^ do\n\t\tc:=s^\n\t\t++s\n\t\tif c='A' then fmt.lettercase:='A'\n\t\telsif c='a' then fmt.lettercase:='a'\n\t\telseswitch toupper(c)\n\t\twhen 'B' then fmt.base:=2\n\t\twhen 'H' then fmt.base:=16\n\t\twhen 'O' then fmt.base:=8\n\t\twhen 'X' then\n\t\t\tbase:=0\n\t\t\tdo\n\t\t\t\tc:=s^\n\t\t\t\tif c in '0'..'9' then\n\t\t\t\t\tbase:=base*10+c-'0'\n\t\t\t\t\t++s\n\t\t\t\telse\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\tod\n\t\t\tif base in 2..16 then\n\t\t\t\tfmt.base:=base\n\t\t\tfi\n\n\t\twhen 'Q' then fmt.quotechar:='\"'\n\t\twhen 'J' then\n\t\t\tfmt.justify:=toupper(s^)\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'Z' then fmt.padchar:='0'\n\t\twhen 'S' then\n\t\t\tfmt.sepchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'P' then\n\t\t\tfmt.padchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'T' then\n\t\t\tfmt.suffix:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'U' then fmt.usigned:='W'\n\t\twhen 'E' then fmt.realfmt:='e'\n\t\twhen 'F' then fmt.realfmt:='f'\n\t\twhen 'G' then fmt.realfmt:='g'\n\t\twhen 'D' then fmt.heapmode:='D'\n\t\twhen 'C' then fmt.charmode:='C'\n\t\twhen 'M' then fmt.charmode:='M'\n\t\twhen 'V' then fmt.param:='V'\n\t\twhen 'Y' then fmt.showtype:=1\n\t\twhen 'N' then fmt.newline:=1\n\t\telsecase c\n\t\twhen '.' then\n\t\t\twset:=1\n\t\twhen comma,'_' then fmt.sepchar:=c\n\t\twhen '+' then fmt.plus:='+'\n\t\twhen '~' then fmt.quotechar:='~'\n\t\twhen '*' then\n\t\t\tn:=fmtparam\n\t\t\tgoto gotwidth\n\t\telse\n\t\t\tif c>='0' and c<='9' then\n\t\t\t\tn:=c-'0'\n\t\t\t\tdo\n\t\t\t\t\tc:=s^\n\t\t\t\t\tif s^=0 then\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tif c>='0' and c<='9' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\tn:=n*10+c-'0'\n\t\t\t\t\telse\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\tod\ngotwidth:\n\t\t\t\tif not wset then\n\t\t\t\t\tfmt.minwidth:=n\n\t\t\t\t\twset:=1\n\t\t\t\telse\n\t\t\t\t\tfmt.precision:=n\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tod\nend\n\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\n!there are n (4 or 8) chars at p.!\n!There could be 0 to 4 or 8 printable chars converted to string at dest\n\t[0:20]char str\n\tref char q\n\tint nchars\n\n\tq:=&.str\n\n\tnchars:=n\n\n\tto n do\n\t\tif p^=0 then exit fi\n\t\tq^:=p^\n\t\t++q\n\t\t++p\n\tod\n\tq^:=0\n\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\nend\n\nexport function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\n!s contains a partly stringified value.\n!widen s if necessary, according to fmt, and copy result to t\n!n is current length of s\n!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving\n!a leading +/- when right-justifying with '0' padding.\n!t MUST be big enough for the expanded string; caller must take care of this\n!result will be zero-terminated, for use in this module\n\n\tint i,w,m\n\n!check to see if result is acceptable as it is\n\tw:=fmt.minwidth\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\n\t\tstrncpy(t,s,n)\n\t\t(t+n)^:=0\n\t\treturn n\n\tfi\n\n\tif fmt.justify='L' then\t! left-justify\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tfor i:=1 to w-n do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\telsif fmt.justify='R' then\n\t\tif fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside \n\t\t\tt^:=s^\n\t\t\t++t\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s+1,n-1)\n\t\t\t(t+n-1)^:=0\n\t\telse\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s,n)\n\t\t\t(t+n)^:=0\n\t\tfi\n\n\telse\t\t\t\t! centre-justify?\n\n\t\tm:=(w-n+1)/2\n\t\tto m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tto w-n-m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\n\tfi\n\treturn w\nend\n\nexport function u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\n!convert 64-bit int a to string in s^\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\n!result when a=minint (will give \"<minint>\")\n\t[0:onesixty]char t\n\tu64 dd\n\tint i,j,k,g\n\tref char s0\n\n\ti:=0\n\tk:=0\n\tg:=(base=10|3|4)\n\n\trepeat\n!\t\tif base=10 then\t\t\t!BUGGY FOR AA OVER I64.MAX\n!\t\t\tassem\n!\t\t\t\tmov\t\trcx, [aa]\n!\t\t\t\tmov\t\trax, rcx\n!\t\t\t\tmov\t\trdx, 7378697629483820647\n!\t\t\t\timul\trdx\n!\t\t\t\tmov\t\trax, rdx\n!\t\t\t\tmov\t\trdx, rcx\n!\t\t\t\tsar\t\trdx, 63\n!\t\t\t\tsar\t\trax, 2\n!\t\t\t\tsub\t\trax, rdx\n!\t\t\t\tlea\t\trdx, [rax+rax*4]\n!\t\t\t\tadd\t\trdx, rdx\n!\t\t\t\tsub\t\trcx, rdx\n!\t\t\t\tmov\t\t[dd], rcx\n!\t\t\t\tmov\t\t[aa], rax\n!\t\t\tend\n!\t\telse\n\t\t\tdd:=aa rem base\n\t\t\taa:=aa/base\n!\t\tfi\n\n\t\tt[++i]:=digits[dd]\n\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\n!out a full length binary\n!so perhaps move this out to expandstr\n\t\t++k\n\t\tif sep and aa<>0 and k=g then\n\t\t\tt[++i]:=sep\n\t\t\tk:=0\n\t\tfi\n\tuntil aa=0\n\n\tj:=i\n\ts0:=s\n\twhile i do\n\t\ts^:=t[i--]\n\t\t++s\n\tod\n\ts^:=0\n\n\treturn j\nend\n\nexport function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\n!convert a to a string in s, according to fmt\n!a basic conversion is done first,: the field manipulation is done\n!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)\n!returns length of s\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n, usigned\n\tconst i64 mindint=0x8000'0000'0000'0000\n\n\tusigned:=0\n\tif fmt.usigned then\n\t\tusigned:=1\n\tfi\n\tif aa=mindint and not usigned then\t\t! minint\n\n\t\tstr[0]:='-'\n\t\tn:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1\n\n\telse\n\t\tif (not usigned and aa<0) or fmt.plus then\n\t\t\tif aa<0 then\n\t\t\t\taa:=-aa\n\t\t\t\tstr[0]:='-'\n\t\t\telse\n\t\t\t\tstr[0]:='+'\n\t\t\tfi\n\t\t\tn:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1\n\t\telse\n\t\t\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\t\tfi\n\tfi\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'\tthen\t! need lower when\n\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\n!see i64tostrfmt\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n\n\n\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif fmt.base>10 or fmt.suffix and fmt.lettercase='a'\tthen\t! need lower when\n!\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\n!convert minint to string in s do not include minus sign\n!return number of chars in string\n\t[0:onesixty]char t\n\tint i,j,k,g\n\n\tcase base\n\twhen 10 then\n\t\tstrcpy(&t[0],\"9223372036854775808\")\n\t\tj:=3\n\twhen 16 then\n\t\tstrcpy(&t[0],\"8000000000000000\")\n\t\tj:=1\n\twhen 2 then\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\n\t\tj:=7\n\telse\n\t\tstrcpy(&t[0],\"<mindint>\")\n\tesac\n\n\ti:=strlen(&t[0])\n\ts+:=i\n\tif sep then\n\t\ts+:=j\n\tfi\n\ts^:=0\n\n\tk:=0\n\tg:=(base=10|3|4)\n\n\twhile i do\n\t\t--s\n\t\ts^:=t[i-- -1]\n\t\tif sep and i and ++k=g then\n\t\t\t--s\n\t\t\ts^:=sep\n\t\t\tk:=0\n\t\tfi\n\tod\n\treturn strlen(s)\nend\n\nexport function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\n!s is a string process according to fmtrec fmt^, and return result in t\n!caller should check whether any changes are required to s (now it can just use s), but this\n!check is done here anyway (with a simple copy to t)\n!n is current length of s\n!return length of t\n!Three processing stages:\n!1 Basic input string s\n!2 Additions or mods: quotes, suffix, when conversion\n!3 Width adjustment\n!1 is detected here, 2 is done here, 3 is done by expandstr\n\tref char u,v\n\t[256]char str\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\n\n\tnheap:=0\n\n\tif fmt.quotechar or fmt.lettercase then\t\t! need local copy\n\t\tif n<256 then\n\t\t\tu:=&.str\n\t\telse\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\n\t\t\tu:=pcm_alloc(nheap)\n\t\tfi\n\t\tif fmt.quotechar then\n\t\t\tv:=u\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tif n then\n\t\t\t\tstrcpy(v,s)\n\t\t\t\tv+:=n\n\t\t\tfi\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tv^:=0\n\t\t\tn+:=2\n\t\telse\n\t\t\tmemcpy(u,s,n)\n\t\tfi\n\t\tcase fmt.lettercase\n\t\twhen 'a' then\t! need lower when\n\t\t\tconvlcstring(u)\n\t\twhen 'A' then\n\t\t\tconvucstring(u)\n\t\tesac\n\t\ts:=u\n\tfi\n\n\tw:=fmt.minwidth\n\tif w>n then\n\t\tn:=expandstr(s,t,n,fmt)\n\telse\n\t\tmemcpy(t,s,n)\n\tfi\n\tif nheap then\n\t\tpcm_free(u,nheap)\n\tfi\n\treturn n\nend\n\nproc tostr_i64(i64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 0 then\n\t\tn:=i64tostrfmt(a,&.str,fmt)\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\telse\t\t\t\t\t\t!assume 'C'\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_u64(u64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\twhen 'C' then\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\n\telse\n\t\tn:=u64tostrfmt(a,&.str,fmt)\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_r64(real x,ref fmtrec fmt) =\n\t[360]char str,str2\n\t[0:10]char cfmt\n\tint n\n\n\tcfmt[0]:='%'\n\n\tif fmt.precision then\n\t\tcfmt[1]:='.'\n\t\tcfmt[2]:='*'\n\t\tcfmt[3]:=fmt.realfmt\n\t\tcfmt[4]:=0\n\t\tsprintf(&.str,&.cfmt,fmt.precision,x)\n\telse\n\t\tcfmt[1]:=fmt.realfmt\n\t\tcfmt[2]:=0\n\t\tsprintf(&.str,&.cfmt,x)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\n\tn:=strlen(&.str)\t\t! current length\n\n\tif n<fmt.minwidth then\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\n\t\tstrcpy(&.str,&.str2)\n\tfi\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_str(ref char s, int oldlen, ref fmtrec fmt) =\n\tint newlen,n\n\tref char t\n\n!try and work out size of formatted string\n\tif oldlen=-1 then\n\t\toldlen:=strlen(s)\n\tfi\n\tnewlen:=oldlen\n\n\tif fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then\n\t\tif fmt.quotechar then\n\t\t\tnewlen+:=2\n\t\tfi\n\t\tif fmt.minwidth>newlen then\n\t\t\tnewlen:=fmt.minwidth\n\t\tfi\n\t\tt:=pcm_alloc(newlen+1)\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\n\t\tif fmt.precision then\n\t\t\tn min:=fmt.precision\n\t\tfi\n\n\t\tprintstr_n(t,n)\n\t\tpcm_free(t,newlen+1)\n\telse\n\t\tprintstr_n(s,oldlen)\n\tfi\nend\n\nfunction getfmt(ichar fmtstyle)ref fmtrec=\n\tstatic fmtrec fmt\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\treturn &fmt\n\telse\n\t\treturn &defaultfmt\n\tfi\nend\n\nexport function strint(i64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport proc getstrint(i64 a, ichar dest)=\n\tm$print_startstr(dest)\n\ttostr_i64(a,getfmt(nil))\n\tm$print_end()\nend\n\nexport function strword(u64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function strreal(real a, ichar fmtstyle=nil)ichar=\n\tstatic [320]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function getstr(ichar s, ref fmtrec fmt)ichar=\n\tif fmt.heapmode then\n\t\treturn pcm_copyheapstring(s)\n\telse\n\t\treturn s\n\tfi\nend\n\nproc initreadbuffer=\n\tif rd_buffer then return fi\n\trd_buffer:=pcm_alloc(rd_buffersize)\n\trd_buffer^:=0\n\trd_pos:=rd_lastpos:=rd_buffer\nend\n\nglobal proc m$read_conline=\n\tinitreadbuffer()\n\n\treadlinen(nil,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_fileline(filehandle f)=\n\tinitreadbuffer()\n\n\tif f=filehandle(1) then\nABORTPROGRAM(\"READ CMDLINE\")\n!\t\trd_buffer^:=0\n!\t\tp:=getcommandlinea()\n!\t\trepeat\n!\t\t\t++p\n!\t\tuntil p^ in [' ','\\t',0]\n!\t\tstrcpy(rd_buffer, p)\n!\t\trd_length:=strlen(rd_buffer)\n!\t\trd_pos:=rd_buffer\n!\t\trd_lastpos:=nil\n\t\treturn\n\tfi\n\n\treadlinen(f,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_strline(ichar s)=\n\tint n\n\n\tinitreadbuffer()\n\tn:=strlen(s)\n\n\tif n<rd_buffersize then\n\t\tstrcpy(rd_buffer,s)\n\telse\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\n\t\t(rd_buffer+rd_buffersize-1)^:=0\n\tfi\n\trd_length:=n\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nfunction readitem(int &itemlength)ref char =\n!read next item from rd_buffer\n!identify a substring that can contain a name, int, real, string or filename\n!return updated position of s that points past the item and past the immediate\n!terminator \n!information about the read item is returned in itemstr, which points to\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\n!Item can be quoted, then the item points inside the quotes\n!Any embedded quotes are removed, and the characters moved up. The item will\n!be that reduced subsequence\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\n!I can mitigate this by adding spaces between the end of the item, and the next item,\n!overwriting also the terminator. But this won't restore the line if one of the next\n!reads is literal, using 'L' or 'C' codes.\n\tref char p,s,itemstr\n\tchar quotechar, c\n\n\tunless rd_buffer then \n\t\tinitreadbuffer()\n\tend unless\n\n\ts:=rd_pos\n\n!scan string, eliminating leading white space\n\twhile s^=' ' or s^=9 do\n\t\t++s\n\tod\n\n\titemstr:=s\n\trd_lastpos:=rd_pos:=s\n\n\tif s^=0 then\n\t\ttermchar:=0\n\t\titemlength:=0\n\t\treturn s\n\tfi\n\n\tquotechar:=0\n\tif s^='\"' then\n\t\tquotechar:='\"'\n\t\t++s\n\telsif s^='\\'' then\n\t\tquotechar:='\\''\n\t\t++s\n\tfi\n\n!loop reading characters until separator or end reached\n\tp:=itemstr:=s\n\n\twhile s^ do\n\t\tc:=s++^\n\t\tcase c\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\n\t\t\t\tgoto normalchar\n\t\t\tfi\n\t\t\ttermchar:=c\n\t\t\texit\n\t\telse\n\tnormalchar:\n\t\t\tif c=quotechar then\n\t\t\t\tif s^=quotechar then\t! embedded quote\n\t\t\t\t\tp^:=c\n\t\t\t\t\t++s\n\t\t\t\t\t++p\n\t\t\t\telse\t\t\t\t\t! end of name\n\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tif termchar in [',', '='] then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tfi\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tp^:=c\n\t\t\t\t++p\n\t\t\tfi\n\t\tesac\n\tod\n\n\tif s^=0 then\n\t\ttermchar:=0\n\tfi\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\n\trd_pos:=s\n\n\treturn itemstr\nend\n\nexport function strtoint(ichar s,int length=-1, word base=10)i64=\n!return point to next char after terminator (which can be just off length of string)\n\tbyte signd\n\tu64 aa\n\tword c,d\n\n\titemerror:=0\n\n\tif length=-1 then\n\t\tlength:=strlen(s)\n\tfi\n!check for sign\n\tsignd:=0\n\tif length and s^='-' then\n\t\tsignd:=1; ++s; --length\n\telsif length and s^='+' then\n\t\t++s; --length\n\tfi\n\n\taa:=0\n\twhile length do\n\t\tc:=s++^\n\t\t--length\n\t\tif c in 'A'..'F' then d:=c-'A'+10\n\t\telsif c in 'a'..'f' then d:=c-'a'+10\n\t\telsif c in '0'..'9' then d:=c-'0'\n\t\telsif c in ['_', '\\''] then\n\t\t\tnextloop\n\t\telse\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\n\t\tif d>=base then\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\t\taa:=aa*base+d\n\tod\n\n\tif signd then\n\t\treturn -aa\n\telse\n\t\treturn aa\n\tfi\nend\n\nglobal function m$read_i64(int fmt=0)i64=\n\tref char s\n\tint length\n\n\tfmt:=toupper(fmt)\n\n\tcase fmt\n\twhen 'C' then\n\t\trd_lastpos:=rd_pos\n\t\tif rd_pos^ then\n\t\t\treturn rd_pos++^\n\t\telse\n\t\t\treturn 0\n\t\tfi\n\twhen 'T' then\n\t\treturn termchar\n\twhen 'E' then\n\t\treturn itemerror\n\tesac\n\n\ts:=readitem(length)\n\n\tcase fmt\n\twhen 0,'I' then\n\t\treturn strtoint(s,length)\n\twhen 'B' then\n\t\treturn strtoint(s,length,2)\n\twhen 'H' then\n\t\treturn strtoint(s,length,16)\n\tesac\n\treturn 0\nend\n\nglobal function m$read_r64(int fmt=0)real=\n\t[512]char str\n\tref char s\n\tint length\n\ti32 numlength\n\treal x\n\n\ts:=readitem(length)\n\n\tif length=0 or length>=str.len then\t\t!assume not a real\n\t\treturn 0.0\n\tfi\n\tmemcpy(&.str,s,length)\n\tstr[length+1]:=0\n\n\titemerror:=0\n\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\n\t\tx:=0.0\n\t\titemerror:=1\n\tfi\n\n\treturn x\nend\n\nglobal proc m$read_str(ref char dest, int destlen=0,fmt=0)=\n\tref char s\n\tint length\n\n\titemerror:=0\n\tif fmt in ['L','l'] then\n\t\ts:=rd_pos\n\t\tlength:=rd_buffer+rd_length-rd_pos\n\n\telse\n\t\ts:=readitem(length)\n\n\t\tif fmt in ['N','n'] then\n\t\t\ticonvlcn(s,length)\n\t\tfi\n\tfi\n\n\tif destlen>0 then\n\t\tif length>=destlen then\n\t\t\tlength:=destlen-1\n\t\t\titemerror:=1\n\t\tfi\n\tfi\n\tmemcpy(dest,s,length)\n\t(dest+length)^:=0\nend\n\nexport proc readstr(ref char dest, int fmt=0,destlen=0)=\n\tm$read_str(dest,destlen,fmt)\nend\n\nexport proc rereadln=\n\trd_pos:=rd_buffer\n\trd_lastpos:=rd_pos\nend\n\nexport proc reread=\n\trd_pos:=rd_lastpos\nend\n\nexport function valint(ichar s, int fmt=0)i64=\n\tref char old_pos, old_lastpos\n\ti64 aa\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\taa:=m$read_i64(fmt)\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn aa\nend\n\nexport function valreal(ichar s)real=\n\tref char old_pos, old_lastpos\n\treal x\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\tx:=m$read_r64()\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn x\nend\n\nproc mclunimpl(ichar mess)=\n\tprintf(\"MCL-UNIMPL: %s\\n\",mess)\n\tstop 1\nend\n\nproc dumpstr(ichar s, int n, fbuffer=0)=\n!fbuffer=1 when outputting contents of buffer\n\n\tref ref char p\n\n\tif outdev=str_io then\n\t\tp:=cast(outchan)\n\t\tif n then\n\t\t\tmemcpy(p^,s,n)\n\t\t\tp^+:=n\n\t\tfi\n\t\tp^^:=0\n\t\treturn\n\tfi\n\n\treturn when n=0\n\tif fbuffer and n>=2 and outdev=std_io then\n\t\t--printptr\t\t\t\t!point to last char\n\t\tif printptr^=10 then\n\t\t\tif (printptr-1)^=13 then\t\t!crlf\n\t\t\t\t(printptr-1)^:=0\n\t\t\telse\t\t\t\t\t\t\t!lf only\n\t\t\t\tprintptr^:=0\n\t\t\tfi\n\t\t\tputs(printbuffer)\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\tesac\nend\n\nproc dumpprintbuffer=\n\tif printlen then\n\t\tdumpstr(&.printbuffer,printlen,1)\n\tfi\n\n\tresetprintbuffer()\nend\n\nproc resetprintbuffer=\n\tprintptr:=&.printbuffer\n\tprintlen:=0\nend\n\nproc addtobuffer(ichar s, int n)=\n\tif printlen+n>=(printbuffer.len-8) then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif n<printbuffer.len then\n\t\tmemcpy(printptr,s,n)\n\t\tprintptr+:=n\n\t\tprintlen+:=n\n\t\treturn\n\tfi\n\n\tdumpstr(s, n)\t\t\t!don't bother with buffer\nend\n\nfunc getutfsize(ref char s)int =\n!work out the size in bytes of the ascii or utf8 character that s points to\n\tint a\n\n\ta:=s++^\n\n\tif a=0 then\t\t\t\t\t\t!end of string\n\t\t0\n\telsif a.[7]=0 then\t\t\t\t!ascii\n\t\t1\n\telsif a.[7..5]=2x110 then\n\t\t2\n\telsif a.[7..4]=2x1110 then\n\t\t3\n\telsif a.[7..3]=2x11110 then\n\t\t4\n\telse\t\t\t\t\t\t\t!error: just assume a byte of random binary\n\t\t1\n\tfi\nend\n\n!export fun fraction(real x)real = fmod(x,1.0)\n\nexport fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))\n\nexport func m$sign_r64(real x)real =\n\tif x<0 then return -1 fi\n\tif x>0 then return 1 fi\n\t0\nend\n",
(u64)"!import clib\n!export type filehandle=ref void\n\n!importdll $cstd=\nimportdll msvcrt=\n\tfunc malloc\t(u64)ref void\n\tproc free\t\t(ref void)\n!\tfunc pow\t\t(real,real)real\n!\n\tfunc printf (ref char,...)i32\n!\tfunc fprintf (ref void,ref char,...)i32\n\tfunc puts (ref char)i32\n\tproc `exit(i32)\n\tfunc getchar\t:i32\n\tproc memcpy\t\t(ref void, ref void, word)\n\tproc memset\t\t(ref void, i32, u64)\n\tfunc strlen\t\t(ichar)u64\n\tfunc strcpy\t\t(ichar,ichar)ichar\n\tfunc strcat\t\t(ichar,ichar)ichar\n\tfunc strcmp\t\t(ichar,ichar)i32\n\n\tfunc _strdup\t(ichar)ichar\nend\n\nexport macro strdup=_strdup\n\n!export proc free(ref void) = end\n\n\nint needgap\n\n!proc start=\n!\tCPL \"MIN/START\"\n!end\n\n\nglobal proc m$print_startcon=\nend\n\nglobal proc m$print_end=\n\tneedgap:=0\nend\n\n!global proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n!!\tnextfmtchars()\n!\tprintf(\"%p\",a)\n!\tneedgap:=1\n!end\n\nglobal proc m$print_ptr_nf(u64 a)=\n\tnextfmtchars()\n\tprintf(\"%p\",a)\n\tneedgap:=1\nend\n!\n!global proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%lld\",a)\n!\tneedgap:=1\n!end\n\n!global proc m$print_i128(i64 a,ichar fmtstyle=nil)=\n!\tputs(\"<128>\")\n!!\tnextfmtchars()\n!!\tprintf(\"%lld\",a)\n!!\tneedgap:=1\n!end\n\nglobal proc m$print_i64_nf(i64 a)=\n!puts(\"PRINTI64_nf\")\n\tnextfmtchars()\n\tprintf(\"%lld\",a)\n\tneedgap:=1\nend\n\nglobal proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%llu\",a)\n\tneedgap:=1\nend\n\nglobal proc m$print_r64(real x,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%f\",x)\n\tneedgap:=1\nend\n\nglobal proc m$print_r32(real x,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%f\",x)\n\tneedgap:=1\nend\n\n!global proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%c\",a)\n!\tneedgap:=1\n!end\n!\n!global proc m$print_str(ichar s, fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%s\",s)\n!\tneedgap:=1\n!end\n\nglobal proc m$print_str_nf(ichar s)=\n\tnextfmtchars()\n\tprintf(\"%s\",s)\n\tneedgap:=1\nend\n\nglobal proc m$print_space=\n\tneedgap:=0\n\tprintf(\" \")\nend\n\nglobal proc m$print_newline=\n\tneedgap:=0\n\tprintf(\"\\n\")\nend\n\nglobal proc m$unimpl=\n\tputs(\"Sysfn unimpl\")\n\tstop 1\nend\n\nglobal proc m$print_nogap=\n\tneedgap:=0\nend\n\n!global proc nextfmtchars(int lastx=0)=\nglobal proc nextfmtchars=\n\tif needgap then\n\t\tprintf(\" \")\n\t\tneedgap:=0\n\tfi\nend\n\n!global proc m$stop(int stopcode)=\n!\t`exit(stopcode)\n!end\n!\n!global func strint(i64 a, ichar fmtstyle=nil)ichar=\n!\treturn \"?\"\n!end\n!\n\n!global function m$power_i64(i64 a,n)i64=\n!\tif n<0 then\n!\t\treturn 0\n!\telsif n=0 then\n!\t\treturn 1\n!\telsif n=1 then\n!\t\treturn a\n!\telsif (n iand 1)=0 then\n!\t\treturn m$power_i64(sqr a,n/2)\n!\telse\t\t\t!assume odd\n!\t\treturn m$power_i64(sqr a,(n-1)/2)*a\n!\tfi\n!end\n!\n!\n",
(u64)"!const mem_check=1\nconst mem_check=0\n\nglobal [0..300]u64 allocupper\nglobal int alloccode\t\t\t\t!set by heapalloc\nexport int allocbytes\t\t\t\t!set by heapalloc\nexport int fdebug=0\nexport int rfsize\n\nconst threshold=1<<25\nconst alloc_step=1<<25\nword maxmemory\nint  maxalloccode\n\n!GLOBAL REF VOID ALLOCBASE\n\nbyte pcm_setup=0\n\nint show=0\n\nglobal int memtotal=0\nexport i64 smallmemtotal=0\nglobal int smallmemobjs=0\nglobal int maxmemtotal=0\n\n!store all allocated pointers\nconst int maxmemalloc=(mem_check|500000|2)\n[maxmemalloc+1]ref i32 memalloctable\n[maxmemalloc+1]i32 memallocsize\n\nconst pcheapsize=1048576*2\nref byte pcheapstart\nref byte pcheapend\t\t\t!points to first address past heap\nref byte pcheapptr\n\nconst int maxblockindex = 8 \t\t!2048\nexport const int maxblocksize = 2048\nexport const int $maxblocksizexx = 2048\n\n[0:maxblocksize+1]byte sizeindextable\t!convert byte size to block index 1..maxblockindex\n\nconst int size16   = 1\t\t\t!the various index codes\nconst int size32   = 2\nconst int size64   = 3\nconst int size128  = 4\nconst int size256  = 5\nconst int size512  = 6\nconst int size1024 = 7\nconst int size2048 = 8\n\nexport [0:9]ref word freelist\n\nexport record strbuffer =\n\tichar strptr\n\ti32 length\n\ti32 allocated\nend\n\nexport enumdata [0:]ichar pmnames=\n\t(pm_end=0,\t\t$),\n\t(pm_option,\t\t$),\n\t(pm_sourcefile,\t$),\n\t(pm_libfile,\t$),\n\t(pm_colon,\t\t$),\n\t(pm_extra,\t\t$),\nend\n\n[2]int seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)\n\n!PROC START=\n!CPL \"MLIB START\"\n!END\n\n\nexport function pcm_alloc(int n)ref void =\n\tref byte p\n\n\n\tif not pcm_setup then\n\t\tpcm_init()\n\tfi\n\n!GOTO DOLARGE\n\n\tif n>maxblocksize then\t\t\t!large block allocation\n!DOLARGE:\n\t\talloccode:=pcm_getac(n)\n\t\tallocbytes:=allocupper[alloccode]\n\n\t\tp:=allocmem(allocbytes)\n\t\tif not p then\n\t\t\tabortprogram(\"pcm_alloc failure\")\n\t\tfi\n\n\t\treturn p\n\tfi\n\n!CPL \"DOSMALL\"\n\n\talloccode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\tallocbytes:=allocupper[alloccode]\n!\tsmallmemtotal+:=allocbytes\n\n\tif p:=ref byte(freelist[alloccode]) then\t\t!Items of this block size available\n\t\tfreelist[alloccode]:=ref word(int((freelist[alloccode])^))\n\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\tp:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\n\tpcheapptr+:=allocbytes\t\t\t!Shrink remaining pool\n\n\tif pcheapptr>=pcheapend then\t\t!Overflows?\n\t\tp:=pcm_newblock(allocbytes)\t\t!Create new heap block, and allocate from start of that\n\t\treturn p\n\tfi\n\n\treturn p\nend\n\nexport proc pcm_free(ref void p,int n) =\n!n can be the actual size requested it does not need to be the allocated size\n\tint acode\n\n\treturn when n=0 or p=nil\n\n\tif n>maxblocksize then\t\t!large block\n\t\tfree(p)\n\telse\n\t\tacode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\t\tcast(p,ref word)^:=word(int(freelist[acode]))\n\t\tfreelist[acode]:=p\n\tfi\nend\n\nexport proc pcm_freeac(ref void p,int alloc) =\n\tpcm_free(p,allocupper[alloc])\nend\n\nexport proc pcm_clearmem(ref void p,int n) =\n\tmemset(p,0,n)\nend\n\nexport proc pcm_init =\n!set up sizeindextable too\n\tint j, k\n\ti64 size\n\tconst limit=1<<33\n\n\talloccode:=0\n\tif pcm_setup then\n\t\treturn\n\tfi\n\n\tpcm_newblock(0)\n\n\tfor i to maxblocksize do\t!table converts eg. 78 to 4 (4th of 16,32,64,128)\n\t\tj:=1\n\t\tk:=16\n\t\twhile i>k do\n\t\t\tk:=k<<1\n\t\t\t++j\n\t\tod\n\t\tsizeindextable[i]:=j\n\tod\n\n\tallocupper[1]:=16\n\tsize:=16\n\n\tfor i:=2 to 27 do\n\t\tsize*:=2\n\t\tallocupper[i]:=size\n\t\tif size>=threshold then\n\t\t\t\tk:=i\n\t\t\texit\n\t\tfi\n\tod\n\n\tfor i:=k+1 to allocupper.upb do\n\t\tsize+:=alloc_step\n\t\tif size<limit then\n\t\t\tallocupper[i]:=size\n\t\t\tmaxmemory:=size\n\t\telse\n\t\t\tmaxalloccode:=i-1\n\t\t\texit\n\t\tfi\n\t\t\n\tod\n\tpcm_setup:=1\nend\n\nexport function pcm_getac(int size)int =\n! convert linear blocksize from 0..approx 2GB to 8-bit allocation code\n\n!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]\t\t!size 0 to 2KB\n\tfi\n\n\tsize:=(size+255)>>8\t\t\t\t\t!scale by 256\n\n!now same sizetable can be used for 2KB to 512KB (288 to 2KB)\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+8\n\tfi\n\n!sizetable now used for 512KB to 128MB (to 2KB)\n\tsize:=(size+63)>>6\t\t\t\t\t!scale by 256\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+14\n\tfi\n\n!size>2048, which means it had been over 128MB.\n\tsize:=(size-2048+2047)/2048+22\n\treturn size\nend\n\nexport function pcm_newblock(int itemsize)ref void=\n!create new heap block (can be first)\n!also optionally allocate small item at start\n!return pointer to this item (and to the heap block)\n\tstatic int totalheapsize\n\tref byte p\n\n\ttotalheapsize+:=pcheapsize\n\talloccode:=0\n\tp:=allocmem(pcheapsize)\t!can't free this block until appl terminates\n\tif p=nil then\n\t\tabortprogram(\"Can't alloc pc heap\")\n\tfi\n\tmemset(p,0,pcheapsize)\n\n\tpcheapptr:=p\n\tpcheapend:=p+pcheapsize\n\n\tif pcheapstart=nil then\t\t!this is first block\n\t\tpcheapstart:=p\n\tfi\n\tpcheapptr+:=itemsize\n\treturn ref u32(p)\nend\n\nexport function pcm_round(int n)int =\n!for any size n, return actual number of bytes that would be allocated\n\tstatic [0:maxblockindex+1]i32 allocbytes=(0,16,32,64,128,256,512,1024,2048)\n\n\tif n>maxblocksize then\n\t\treturn n\n\telse\n\t\treturn allocbytes[sizeindextable[n]]\n\tfi\nend\n\nexport function pcm_allocz(int n)ref void =\n\tref void p\n\tp:=pcm_alloc(n)\n\n\tmemset(p,0,n)\n\treturn p\nend\n\nexport function pcm_copyheapstring(ref char s)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tint n\n\tif s=nil then return nil fi\n\n\tn:=strlen(s)+1\n\tq:=pcm_alloc(n)\n\tmemcpy(q,s,n)\n\treturn q\nend\n\nexport function pcm_copyheapstringn(ref char s,int n)ref char =\n\tref char q\n\tif s=nil then return nil fi\n\n\tq:=pcm_alloc(n+1)\n\tmemcpy(q,s,n)\n\t(q+n)^:=0\n\treturn q\nend\n\nexport function pcm_copyheapblock(ref char s, int length)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tif length=0 then return nil fi\n\n\tq:=pcm_alloc(length)\n\tmemcpy(q,s,length)\n\treturn q\nend\n\nexport function allocmem(int n)ref void =\n\tref void p\n\n\tp:=malloc(n)\n\tif p then\n\t\treturn p\n\tfi\n\tprintln n,memtotal\n\tabortprogram(\"Alloc mem failure\")\n\treturn nil\nend\n\nglobal function reallocmem(ref void p,int n)ref void =\n\tp:=realloc(p,n)\n\treturn p when p\n\tprintln n\n\tabortprogram(\"Realloc mem failure\")\n\treturn nil\nend\n\nexport proc abortprogram(ref char s) =\n\tprintln s\n\tprint   \"ABORTING: Press key...\"\n!os_getch()\n\tstop 5\nend\n\nexport function getfilesize(filehandle handlex)int=\n\tu32 p,size\n\n\tp:=ftell(handlex)\t\t!current position\n\tfseek(handlex,0,2)\t\t!get to eof\n\tsize:=ftell(handlex)\t\t!size in bytes\n\tfseek(handlex,p,seek_set)\t!restore position\n\treturn size\nend\n\nexport proc readrandom(filehandle handlex, ref byte memx, int offset, size) =\n\tint a\n\tfseek(handlex,offset,seek_set)\n\ta:=fread(memx,1,size,handlex)\t\t\t!assign so as to remove gcc warning\nend\n\nexport function writerandom(filehandle handlex, ref byte memx, int offset,size)int =\n\tfseek(handlex,offset,seek_set)\n\treturn fwrite(memx,1,size,handlex)\nend\n\nexport function setfilepos(filehandle file,int offset)int=\n\treturn fseek(file,offset,0)\nend\n\nexport function getfilepos(filehandle file)int=\n\treturn ftell(file)\nend\n\nexport function readfile(ref char filename)ref byte =\n\tfilehandle f\n\tint size\n\tref byte m,p\n\n\tf:=fopen(filename,\"rb\")\n\tif f=nil then\n\t\treturn nil\n\tfi\n\trfsize:=size:=getfilesize(f)\n\n\tm:=malloc(size+2)\t\t!allow space for etx/zeof etc\n\n\tif m=nil then\n\t\treturn nil\n\tfi\n\n\treadrandom(f,m,0,size)\n\tp:=m+size\t\t\t!point to following byte\n\t(ref u16(p)^:=0)\t!add two zero bytes\n\n\tfclose(f)\n\treturn m\nend\n\nexport function writefile(ref char filename,ref byte data,int size)int =\n\tfilehandle f\n\tint n\n\n\tf:=fopen(filename,\"wb\")\n\tif f=nil then\n\t\treturn 0\n\tfi\n\n\tn:=writerandom(f,data,0,size)\n\tfclose(f)\n\treturn n\nend\n\nexport function checkfile(ref char file)int=\n\tfilehandle f\n\tif f:=fopen(file,\"rb\") then\n\t\tfclose(f)\n\t\treturn 1\n\tfi\n\treturn 0\nend\n\nexport proc readlinen(filehandle handlex,ref char buffer,int size) =\n!size>2\n\tint ch\n\tref char p\n\tint n\n\tbyte crseen\n\n\tif handlex=nil then\n\t\thandlex:=filehandle(os_getstdin())\n\tfi\n\tif handlex=nil then\n\t\tn:=0\n\t\tp:=buffer\n\t\tdo\n\t\t\tch:=getchar()\n\t\t\tif ch=13 or ch=10 or ch=-1 then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\t\tp++^:=ch\n\t\t\t++n\n\t\t\tif n>=(size-2) then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\tod\n\tfi\n\n\tbuffer^:=0\n\tif fgets(buffer,size-2,handlex)=nil then\n\t\treturn\n\tfi\n\n\tn:=strlen(buffer)\n\tif n=0 then\n\t\treturn\n\tfi\n\n\tp:=buffer+n-1\t\t!point to last char\n\tcrseen:=0\n\twhile (p>=buffer and (p^=13 or p^=10)) do\n\t\tif p^=13 or p^=10 then crseen:=1 fi\n\t\tp--^ :=0\n\tod\n\n!NOTE: this check doesn't work when a line simply doesn't end with cr-lf\n\n\tif not crseen and (n+4>size) then\n\t\tcpl size,n\n\t\tabortprogram(\"line too long\")\n\tfi\nend\n\nexport proc iconvlcn(ref char s,int n) =\n\tto n do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\nend\n\nexport proc iconvucn(ref char s,int n) =\n\tto n do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\nend\n\nexport function convlcstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function convucstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function changeext(ref char s,newext)ichar=\n!whether filespec has an extension or not, change it to newext\n!newext should start with \".\"\n!return new string (locally stored static string, so must be used before calling again)\n\tstatic [260]char newfile\n\t[32]char newext2\n\tref char sext\n\tint n\n\n\tstrcpy(&newfile[1],s)\n\n\tcase newext^\n\twhen 0 then\n\t\tnewext2[1]:=0\n\t\tnewext2[2]:=0\n\twhen '.' then\n\t\tstrcpy(&newext2[1],newext)\n\telse\n\t\tstrcpy(&newext2[1],\".\")\n\t\tstrcat(&newext2[1],newext)\n\tesac\n\n\n\tsext:=extractext(s,1)\t\t\t!include \".\" when it is only extension\n\n\tcase sext^\n\twhen 0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[1])\n\twhen '.' then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[2])\n\telse\t\t\t\t\t\t\t!has extension\n\t\tn:=sext-s-2\t\t\t!n is number of chars before the \".\"\n\t\tstrcpy(&newfile[1]+n+1,&newext2[1])\n\tesac\n\n\treturn &newfile[1]\nend\n\nexport function extractext(ref char s,int period=0)ichar=\n!if filespec s has an extension, then return pointer to it otherwise return \"\"\n!if s ends with \".\", then returns \".\"\n\tref char t,u\n\n\tt:=extractfile(s)\n\n\tif t^=0 then\t\t\t!s contains no filename\n\t\treturn \"\"\n\tfi\n\n!t contains filename+ext\n\tu:=t+strlen(t)-1\t\t!u points to last char of t\n\n\twhile u>=t do\n\t\tif u^='.' then\t\t!start extension found\n\t\t\tif (u+1)^=0 then\t\t!null extension\n\t\t\t\treturn (period|\".\"|\"\")\n\t\t\tfi\n\t\t\treturn u+1\t\t\t!return last part of filename as extension exclude the dot\n\t\tfi\n\t\t--u\n\tod\n\treturn \"\"\t\t\t!no extension seen\nend\n\nexport function extractpath(ref char s)ichar=\n\tstatic [0:260]char str\n\tref char t\n\tint n\n\n\tt:=s+strlen(s)-1\t\t!t points to last char\n\n\twhile (t>=s) do\n\t\tcase t^\n\t\twhen '\\\\','/',':' then\t\t!path separator or drive letter terminator assume no extension\n\t\t\tn:=t-s+1\t\t\t!n is number of chars in path, which includes rightmost / or \\ or :\n\t\t\tmemcpy(&.str,s,n)\n\t\t\tstr[n]:=0\n\t\t\treturn &.str\n\t\tesac\n\t\t--t\n\tod\n\treturn \"\"\t\t\t!no path found\nend\n\nexport function extractfile(ref char s)ichar=\n\tref char t\n\n\tt:=extractpath(s)\n\n\tif t^=0 then\t\t\t!s contains no path\n\t\treturn s\n\tfi\n\n\treturn s+strlen(t)\t\t!point to last part of s that contains the file\n\tend\n\nexport function extractbasefile(ref char s)ichar=\n\tstatic [0:100]char str\n\tref char f,e\n\tint n,flen\n\n\tf:=extractfile(s)\n\tflen:=strlen(f)\n\tif flen=0 then\t\t!s contains no path\n\t\treturn \"\"\n\tfi\n\te:=extractext(f,0)\n\n\tif e^ then\t\t\t!not null extension\n\t\tn:=flen-strlen(e)-1\n\t\tmemcpy(&str,f,n)\n\t\tstr[n]:=0\n\t\treturn &.str\n\tfi\n\tif (f+flen-1)^='.' then\n\t\tmemcpy(&str,f,flen-1)\n\t\tstr[flen-1]:=0\n\t\treturn &.str\n\tfi\n\treturn f\nend\n\nexport function addext(ref char s,ref char newext)ichar=\n!when filespec has no extension of its own, add newext\n\tref char sext\n\n\tsext:=extractext(s,1)\n\n\tif sext^=0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\treturn changeext(s,newext)\n\tfi\n\n\treturn s\t\t\t\t\t\t\t!has own extension; use that\nend\n\nexport function pcm_alloc32:ref void =\n\tref byte p\n\n\tallocbytes:=32\n!\tsmallmemtotal+:=32\n\n\tif p:=ref byte(freelist[2]) then\t\t!Items of this block size available\n\t\tfreelist[2]:=ref word(int((freelist[2])^))\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\treturn pcm_alloc(32)\nend\n\nexport proc pcm_free32(ref void p) =\n!n can be the actual size requested it does not need to be the allocated size\n\n!\tsmallmemtotal-:=32\n\n\tcast(p,ref word)^:=word(int(freelist[2]))\n\tfreelist[2]:=p\nend\n\nexport proc outbyte(filehandle f,int x)=\n\tfwrite(&x,1,1,f)\nend\n\nexport proc outu16(filehandle f,word x)=\n\tfwrite(&x,2,1,f)\nend\n\nexport proc outu32(filehandle f,word x)=\n\tfwrite(&x,4,1,f)\nend\n\nexport proc outu64(filehandle f,u64 x)=\n\tfwrite(&x,8,1,f)\nend\n\nexport proc outstring(filehandle f, ichar s)=\n\tfwrite(s,strlen(s)+1,1,f)\nend\n\nexport proc outblock(filehandle f, ref void p, int n)=\n\tfwrite(p,n,1,f)\nend\n\nexport function myeof(filehandle f)int=\n\tint c\n\n\tc:=fgetc(f)\n\tif c=c_eof then return 1 fi\n\tungetc(c,f)\n\treturn 0\nend\n\nexport proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)=\n\tint newlen,oldlen\n\tichar newptr\n\n!\tIF N=0 THEN CPL \"N=0\" FI\n\n\tif n=-1 then\n\t\tn:=strlen(s)\n\tfi\n\n\toldlen:=dest.length\n\n\tif oldlen=0 then\t\t\t\t!first string\n\t\tdest.strptr:=pcm_alloc(n+1)\n\t\tdest.allocated:=allocbytes\n\t\tdest.length:=n\t\t\t\t!length always excludes terminator\n\t\tmemcpy(dest.strptr,s,n)\n\t\t(dest.strptr+n)^:=0\n\t\treturn\n\tfi\n\n\tnewlen:=oldlen+n\n\tif newlen+1>dest.allocated then\n\t\tnewptr:=pcm_alloc(newlen+1)\n\t\tmemcpy(newptr,dest.strptr,oldlen)\n\t\tdest.strptr:=newptr\n\t\tdest.allocated:=allocbytes\n\tfi\n\n\tmemcpy(dest.strptr+oldlen,s,n)\n\t(dest.strptr+newlen)^:=0\n\n\tdest.length:=newlen\nend\n\nexport proc gs_init(ref strbuffer dest)=\n\tpcm_clearmem(dest,strbuffer.bytes)\nend\n\nexport proc gs_free(ref strbuffer dest)=\n\tif dest.allocated then\n\t\tpcm_free(dest.strptr,dest.allocated)\n\tfi\nend\n\nexport proc gs_str(ref strbuffer dest,ichar s)=\n\tstrbuffer_add(dest,s)\nend\n\nexport proc gs_char(ref strbuffer dest,int c)=\n\t[16]char s\n\n\ts[1]:=c\n\ts[2]:=0\n\n\tstrbuffer_add(dest,&.s,1)\nend\n\nexport proc gs_strn(ref strbuffer dest,ichar s,int length)=\n\tstrbuffer_add(dest,s,length)\nend\n\nexport proc gs_strvar(ref strbuffer dest,s)=\n\tstrbuffer_add(dest,s.strptr)\nend\n\nexport proc gs_strint(ref strbuffer dest,i64 a)=\n\tstrbuffer_add(dest,strint(a))\nend\n\nexport proc gs_strln(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_line(dest)\nend\n\nexport proc gs_strsp(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_str(dest,\" \")\nend\n\nexport proc gs_line(ref strbuffer dest)=\n!\tstrbuffer_add(dest,\"\\w\")\n\tstrbuffer_add(dest,\"\\n\")\nend\n\nexport function gs_getcol(ref strbuffer dest)int=\n\treturn dest.length\nend\n\nexport proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')=\n\tint col,i,n,slen\n\t[2560]char str\n\tcol:=dest.length\n\tstrcpy(&.str,s)\n\tslen:=strlen(s)\n\tn:=w-slen\n\tif n>0 then\n\t\tfor i:=1 to n do\n\t\t\tstr[slen+i]:=padch\n\t\tod\n\t\tstr[slen+n+1]:=0\n\tfi\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')=\n\tgs_leftstr(dest,strint(a),w,padch)\nend\n\nexport proc gs_padto(ref strbuffer dest,int col, ch=' ')=\n\tint n\n\t[2560]char str\n\n\tn:=col-dest.length\n\tif n<=0 then return fi\n\tfor i:=1 to n do\n\t\tstr[i]:=ch\n\tod\n\tstr[n+1]:=0\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_println(ref strbuffer dest,filehandle f=nil)=\n\tif dest.length=0 then return fi\n\t(dest.strptr+dest.length)^:=0\n\n\tif f=nil then\n\t\tprintln dest.strptr,,\"\\c\"\n\telse\n\t\tprintln @f,dest.strptr,,\"\\c\"\n\tfi\nend\n\nexport function nextcmdparamnew(int &paramno, ichar &name, &value, ichar defext=nil)int=\n\tstatic int infile=0\n\tstatic ichar filestart=nil\n\tstatic ichar fileptr=nil\n\tstatic byte colonseen=0\n\tref char q\n\tichar item,fileext\n\tint length\n\tstatic [300]char str\n\n\treenter:\n\tvalue:=nil\n\tname:=nil\n\n\tif infile then\n\t\tif readnextfileitem(fileptr,item)=0 then\t\t!eof\n\t\t\tfree(filestart)\t\t\t\t\t\t\t\t!file allocated via malloc\n\t\t\tinfile:=0\n\t\t\tgoto reenter\n\t\tfi\n\telse\n\t\tif paramno>ncmdparams then\n\t\t\treturn pm_end\n\t\tfi\n\t\titem:=cmdparams[paramno]\n\t\t++paramno\n\n\t\tlength:=strlen(item)\n\n\t\tif item^='@' then\t\t!@ file\n\t\t\tfilestart:=fileptr:=readfile(item+1)\n\t\t\tif filestart=nil then\n\t\t\t\tprintln \"Can't open\",item\n\t\t\t\tstop 7\n\t\t\tfi\n\t\t\tinfile:=1\n\t\t\tgoto reenter\n\t\tfi\n\n\t\tif item^=':' then\n\t\t\tcolonseen:=1\n\t\t\treturn pm_colon\n\t\tfi\n\tfi\n\n\tvalue:=nil\n\tif item^='-' then\n\t\tname:=item+(colonseen|0|1)\n\t\tq:=strchr(item,':')\n\t\tif not q then\n\t\t\tq:=strchr(item,'=')\n\t\tfi\n\t\tif q then\n\t\t\tvalue:=q+1\n\t\t\tq^:=0\n\t\tfi\n\t\treturn (colonseen|pm_extra|pm_option)\n\tfi\n\n\tfileext:=extractext(item,0)\n\tname:=item\n\n\tif fileext^=0 then\t\t\t\t\t\t\t!no extension\n\t\tstrcpy(&.str,name)\n\t\tif defext and not colonseen then\n\t\t\tname:=addext(&.str,defext)\t\t\t\t!try .c\n\t\tfi\n!\telsif eqstring(fileext,\"dll\") then\n\telsif eqstring(fileext,\"dll\") or eqstring(fileext,\"mcx\") then\n\t\treturn (colonseen|pm_extra|pm_libfile)\n\tfi\n\treturn (colonseen|pm_extra|pm_sourcefile)\nend\n\nfunction readnextfileitem(ichar &fileptr,&item)int=\n\tref char p,pstart,pend\n\tint n\n\tstatic [256]char str\n\n\tp:=fileptr\n\n\treenter:\n\tdo\n\t\tcase p^\n\t\twhen ' ','\\t',13,10 then\t!skip white space\n\t\t\t++p\n\t\twhen 26,0 then\t\t\t\t!eof\n\t\t\treturn 0\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\n\tcase p^\n\twhen '!', '#' then\t\t\t!comment\n\t\t++p\n\t\tdocase p++^\n\t\twhen 10 then\n\t\t\tgoto reenter\n\t\twhen 26,0 then\n\t\t\tfileptr:=p-1\n\t\t\treturn 0\n\t\telse\n\n\t\tend docase\n\tesac\n\n\n\tcase p^\n\twhen '\"' then\t\t\t\t!read until closing \"\n\t\tpstart:=++p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tprintln \"Unexpected EOF in @file\"\n\t\t\t\tstop 8\n\t\t\twhen '\"' then\n\t\t\t\tpend:=p++\n\t\t\t\tif p^=',' then ++p fi\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\telse\n\t\tpstart:=p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tpend:=p\n\t\t\t\texit\n\t\t\twhen ' ','\\t',',',13,10 then\n\t\t\t\tpend:=p++\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\tesac\n\n\tn:=pend-pstart\n\tif n>=str.len then\n\t\tprintln \"@file item too long\"\n\t\tstop 9\n\tfi\n\tmemcpy(&.str,pstart,n)\n\tstr[n+1]:=0\n\titem:=&.str\n\tfileptr:=p\n\n\treturn 1\nend\n\nexport proc ipadstr(ref char s,int width,ref char padchar=\" \")=\n\tint n\n\n\tn:=strlen(s)\n\tto width-n do\n\t\tstrcat(s,padchar)\n\tod\nend\n\nexport function padstr(ref char s,int width,ref char padchar=\" \")ichar=\n\tstatic [256]char str\n\n\tstrcpy(&.str,s)\n\tipadstr(&.str,width,padchar)\n\treturn &.str\nend\n\nexport function chr(int c)ichar=\n\tstatic [8]char str\n\n\tstr[1]:=c\n\tstr[2]:=0\n\treturn &.str\nend\n\nexport function cmpstring(ichar s,t)int=\n\tint res\n\tif (res:=strcmp(s,t))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function cmpstringn(ichar s,t,int n)int=\n\tint res\n\tif (res:=strncmp(s,t,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqstring(ichar s,t)int=\n\treturn strcmp(s,t)=0\nend\n\nexport function cmpbytes(ref void p,q,int n)int=\n\tint res\n\tif (res:=memcmp(p,q,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqbytes(ref void p,q,int n)int=\n\treturn memcmp(p,q,n)=0\nend\n\nexport proc mseed(u64 a,b=0)=\n\tseed[1]:=a\n\tif b then\n\t\tseed[2]:=b\n\telse\n\t\tseed[2] ixor:=a\n\tfi\nend\n\nexport function mrandom:word =\n!return pure 64-bit word value, 0 to 2**64-1\n!(cast result for signed value)\n!\tu64 x,y\n\tint x,y\n\tx:=seed[1]\n\ty:=seed[2]\n\tseed[1]:=y\n\tx ixor:=(x<<23)\n\tseed[2]:= x ixor y ixor (x>>17) ixor (y>>26)\n\treturn seed[2]+y\nend\n\nexport function mrandomp:int =\n!pure 64-bit int value, positive only, 0 to 2**63-1\n\treturn mrandom() iand 0x7FFF'FFFF'FFFF'FFFF\nend\n\nexport function mrandomint(int n)int=\n!positive random int value from 0 to n-1\n\treturn mrandomp() rem n\nend\n\nexport function mrandomrange(int a,b)int=\n!random int value from a to b inclusive\n!span extent must be 1 to 2**63-1\n\tint span\n\tspan:=b-a+1\n\tif span<=0 then\n\t\treturn 0\n\tfi\n\treturn (mrandomp() rem span)+a\nend\n\nexport function mrandomreal:real x=\n!positive random real value from 0 to just under (but not including) 1.0\n\trepeat x:=mrandomp()/9223372036854775808.0 until x<>1.0\n\treturn x\nend\n\nexport function mrandomreal1:real=\n!positive random real value from 0 to 1.0 inclusive\n\treturn mrandomp()/9223372036854775807.0\nend\n\nexport function readline:ichar=\n\treadln\n\treturn rd_buffer\nend\n\nexport function findfunction(ichar name)ref void=\n\tfor i to $getnprocs() do\n\t\tif eqstring($getprocname(i),name) then\n\t\t\treturn $getprocaddr(i)\n\t\tfi\n\tod\n\treturn nil\nend\n\nexport function roundtoblock(int n,align)int=\n!round up n until it is a multiple of filealign (which is a power of two)\n!return aligned value. Returns original if already aligned\n\tif n iand (align-1)=0 then return n fi\n\treturn n+(align-(n iand (align-1)))\nend\n\nexport function pcm_allocnfz(int n)ref void =\n!non-freeing allocator for small objects\n!n should be a multiple of 8 bytes, but is rounded up here if needed\n\tref byte p\n\n!make n a multiple of 8\n\tif n iand 7 then\n\t\tn:=n+(8-(n iand 7))\n\tfi\n\n\tp:=pcheapptr\t\t\t\t\t!Create item at start of remaining pool in heap block\n\tpcheapptr+:=n\t\t\t\t\t!Shrink remaining pool\n\n\tif pcheapptr>=pcheapend then\t!Overflows?\n\t\tp:=pcm_newblock(n)\t\t\t!Create new heap block, and allocate from start of that\n\tfi\n\n\treturn p\nend\n\n!export proc freddy=\n!\tPRINTLN \"FREDDY\"\n!end\n",
(u64)"export type filehandle=ref void\n\nimportdll $cstd=\n\tfunc malloc\t\t(u64)ref void\n\tfunc realloc\t(ref void, word)ref void\n\tproc free\t\t(ref void)\n\tproc memset\t\t(ref void, i32, word)\n\tproc memcpy\t\t(ref void, ref void, word)\n\tproc memmove\t\t(ref void, ref void, word)\n\tfunc clock\t\t:i32\n\tfunc ftell\t\t(filehandle)i32\n\tfunc fseek\t\t(filehandle, i32, i32)i32\n\tfunc fread\t\t(ref void, word, word, filehandle)word\n\tfunc fwrite\t\t(ref void, word, word, filehandle)word\n\tfunc getc\t\t(filehandle)i32\n\tfunc ungetc\t\t(i32, filehandle)i32\n\tfunc fopen\t\t(ichar a, b=\"rb\")filehandle\n\tfunc fclose\t\t(filehandle)i32\n\tfunc fgets\t\t(ichar, int, filehandle)ichar\n\tfunc remove\t\t(ichar)i32\n\tfunc rename\t\t(ichar, ichar)i32\n\tfunc getchar\t:i32\n\tproc putchar\t(i32)\n\tproc setbuf\t\t(filehandle, ref byte)\n\n\tfunc strlen\t\t(ichar)int\n\tfunc strcpy\t\t(ichar, ichar)ichar\n\tfunc strcmp\t\t(ichar, ichar)i32\n\tfunc strncmp\t(ichar, ichar, word)i32\n\tfunc strncpy\t(ichar, ichar, word)word\n\tfunc memcmp\t\t(ref void, ref void, word)i32\n\tfunc strcat\t\t(ichar, ichar)ichar\n\tfunc tolower\t(i32)i32\n\tfunc toupper\t(i32)i32\n\tfunc isalpha\t(i32)i32\n\tfunc isupper\t(i32)i32\n\tfunc islower\t(i32)i32\n\tfunc isalnum\t(i32)i32\n\tfunc isspace\t(i32)i32\n\tfunc strstr\t\t(ichar, ichar)ichar\n\tfunc atol\t\t(ichar)int\n\tfunc atoi\t\t(ichar)i32\n\tfunc strtod\t\t(ichar,ref ref char)r64\n\tfunc _strdup\t(ichar)ichar\n\n\tfunc puts\t\t(ichar)i32\n\tfunc printf\t\t(ichar, ...)i32\n\n\tfunc sprintf\t(ichar, ichar, ...)i32\n\n\tfunc sscanf\t\t(ichar, ichar, ...)i32\n\tfunc scanf\t\t(ichar, ...)i32\n\n\tfunc rand\t\t:i32\n\tproc srand\t\t(u32)\n\tfunc system\t\t(ichar)i32\n\n\tfunc fgetc\t\t(filehandle)i32\n\tfunc fputc\t\t(i32,  filehandle)i32\n\tfunc fprintf\t(filehandle, ichar, ...)i32\n\tfunc fputs\t\t(ichar,  filehandle)i32\n\tfunc feof\t\t(filehandle)i32\n\tfunc getch\t\t:i32\n\tfunc _getch\t\t:i32\n\tfunc kbhit\t\t:i32\n\tfunc _mkdir\t\t(ichar)i32\n\tfunc mkdir\t\t(ichar)i32\n\tfunc strchr\t\t(ichar,i32)ichar\n\n\tfunc _setmode\t(i32,i32)i32\n\n\tproc _exit\t\t(i32)\n\tproc \"exit\"\t\t(i32)\n!\tproc `exit\t\t(i32)\n\tfunc pow\t\t(real,real)real\n\n\tfunc `sin \t\t(real)real\n\tfunc `cos\t\t(real)real\n\tfunc `tan\t\t(real)real\n\tfunc `asin\t\t(real)real\n\tfunc `acos\t\t(real)real\n\tfunc `atan \t\t(real)real\n\tfunc `log\t\t(real)real\n\tfunc `log10\t\t(real)real\n\tfunc `exp\t\t(real)real\n\tfunc `floor\t\t(real)real\n\tfunc `ceil\t\t(real)real\n\n\tproc  qsort   \t(ref void, u64, u64, ref proc)\n\nend\n\nexport macro strdup=_strdup\n\nimportdll $cstdextra=\n\tfunc __getmainargs\t(ref i32, ref void, ref void, int, ref void)i32\nend\n\nexport const c_eof\t\t=-1\nexport const seek_set\t= 0\nexport const seek_curr\t= 1\nexport const seek_end\t= 2\n",
(u64)"const wm_destroy=2\n\nexport type wt_word\t= u16\nexport type wt_wordpm\t= u32\nexport type wt_bool\t= u32\nexport type wt_dword\t= u32\nexport type wt_wchar\t= u16\nexport type wt_wcharpm\t= u32\nexport type wt_char\t= byte\nexport type wt_ichar\t= ref char\nexport type wt_ptr\t\t= ref void\nexport type wt_wndproc\t= ref proc\nexport type wt_handle\t= ref void\nexport type wt_int\t\t= i32\nexport type wt_uint\t= u32\nexport type wt_long\t= i32\nexport type wt_wparam\t= word\nexport type wt_lparam\t= word\nexport type wt_point\t= rpoint\n\nexport record rsystemtime =\n\twt_word year\n\twt_word month\n\twt_word dayofweek\n\twt_word day\n\twt_word hour\n\twt_word minute\n\twt_word second\n\twt_word milliseconds\nend\n\nimportdll $windowsdlls=\n!\tfunc \"VirtualAlloc\"(wt_ptr, dint,wt_dword,wt_dword)wt_ptr\n\tfunc \"GetStdHandle\"(wt_dword)wt_handle\n\tfunc \"GetConsoleScreenBufferInfo\"(wt_handle,wt_ptr)int\n\tfunc \"SetConsoleCtrlHandler\"(wt_wndproc,int)int\n\tfunc \"SetConsoleMode\"(wt_handle,wt_dword)int\n\tfunc \"CreateProcessA\"(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,\n\t\t\t\t\t\twt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int\n\tfunc \"GetLastError\":wt_dword\n\tfunc \"WaitForSingleObject\"(wt_handle,wt_dword)wt_dword\n\tfunc \"GetExitCodeProcess\"(wt_handle,wt_ptr)int\n\tfunc \"CloseHandle\"(wt_handle)int\n\tfunc \"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)int\n\tfunc \"FlushConsoleInputBuffer\"(wt_handle)int\n\tfunc \"LoadLibraryA\"(wt_ichar)wt_handle\n!\tfunc \"GetProcAddress\"(wt_handle,wt_ichar)wt_wndproc\n\tfunc \"GetProcAddress\"(wt_handle,wt_ichar)ref void\n\tfunc \"LoadCursorA\"(wt_handle,wt_ichar)wt_handle\n\tfunc \"RegisterClassExA\"(wt_ptr)wt_wordpm\n\tfunc \"DefWindowProcA\"(wt_handle,wt_uint,wt_wparam,wt_lparam)int\n\tfunc \"ReadConsoleInputA\"(wt_handle,wt_ptr,wt_dword,wt_ptr)int\n\tproc \"Sleep\"(wt_dword)\n\tfunc \"GetModuleFileNameA\"(wt_handle,wt_ichar,wt_dword)wt_dword\n\n\tproc \"ExitProcess\"(wt_uint)\n\tproc \"PostQuitMessage\"(wt_int)\n\n\tproc \"MessageBoxA\"(wt_int x=0,wt_ichar message, caption=\"Caption\",wt_int y=0)\n\n\tfunc \"QueryPerformanceCounter\"(ref i64)wt_bool\n\tfunc \"QueryPerformanceFrequency\"(ref i64)wt_bool\n\n\tfunc \"CreateFileA\"(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle\n\tfunc \"GetFileTime\"(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool\n\n\tproc \"GetSystemTime\"(ref rsystemtime)\n\tproc \"GetLocalTime\"(ref rsystemtime)\n\n\tfunc \"GetTickCount64\":u64\n\tfunc \"PeekMessageA\"\t\t(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool\n\n\tfunc \"GetCommandLineA\":ichar\n\n\tfunc \"VirtualAlloc\" (ref void, wt_dword, wt_dword, wt_dword)ref void\n\tfunc \"VirtualProtect\" (ref void, wt_dword, wt_dword, ref wt_dword)wt_bool\n\n\tfunc \"WriteConsoleA\" (ref void, ref void, i32, ref i32, ref void)wt_bool\n\n\tfunc \"FindFirstFileA\" (wt_ichar,ref rfinddata)wt_handle\n\tfunc \"FindNextFileA\"  (wt_handle, ref rfinddata)wt_bool\n\tfunc \"FindClose\"      (wt_handle)wt_bool\n\n\tfunc \"MessageBeep\"    (i32)wt_bool\n\tfunc \"Beep\"    (i32 freq, dur)wt_bool\nend\n\nrecord input_record = $caligned\n\twt_word\teventtype\n!\tu16\tpadding\n\t\twt_bool\tkeydown\t\t\t!key event record (was inside 'Event' union in win32)\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nrecord rspoint=(i16 x,y)\n\nrecord rsrect=\n\ti16 leftx,top,rightx,bottom\nend\n\nglobal record rpoint =\n\twt_long x,y\nend\n\nrecord rconsole=\n\trspoint size,pos\n\tu16 attributes\n\trsrect window\n\trspoint maxwindowsize\nend\n\nrecord rstartupinfo =\n\twt_dword\tsize\n\tu32 dummy1\n\twt_ichar\treserved\n\twt_ichar\tdesktop\n\twt_ichar\ttitle\n\twt_dword\tx\n\twt_dword\ty\n\twt_dword\txsize\n\twt_dword\tysize\n\twt_dword\txcountchars\n\twt_dword\tycountchars\n\twt_dword\tfillattribute\n\twt_dword\tflags\n\twt_word\t\tshowwindow\n\twt_word\t\treserved2\n\tu32 dummy2\n\twt_ptr\t\treserved4\n\twt_handle\tstdinput\n\twt_handle\tstdoutput\n\twt_handle\tstderror\nend\n\nrecord rprocess_information =\n\twt_handle process\n\twt_handle thread\n\twt_dword processid\n\twt_dword threadid\nend\n\nrecord rwndclassex =\n\twt_uint\t\tsize\n\twt_uint\t\tstyle\n\twt_wndproc\twndproc\n\twt_int\t\tclsextra\n\twt_int\t\twndextra\n\twt_handle\tinstance\n\twt_handle\ticon\n\twt_handle\tcursor\n\twt_handle\tbackground\n\twt_ichar\tmenuname\n\twt_ichar\tclassname\n\twt_handle\ticonsm\nend\n\nglobal record rmsg =\n\twt_handle\thwnd\n\twt_uint\t\tmessage\n\tu32\t\tdummy1\n\twt_wparam\twParam\n\twt_lparam\tlParam\n\twt_dword\ttime\n\tu32\t\tdummy2\n\twt_point\tpt\nend\n\nrecord rfiletime =\n\twt_dword lowdatetime\n\twt_dword highdatetime\nend\n\nrecord rfinddata =\n\twt_dword\tfileattributes\n\trfiletime\tcreationtime\n\trfiletime\tlastaccesstime\n\trfiletime\tlastwritetime\n\twt_dword\tfilesizehigh\n\twt_dword\tfilesizelow\n\twt_dword\treserved0\n\twt_dword\treserved1\n\t[260]char\tfilename\n\t[14]char\t\taltfilename\n\twt_dword\tobs1, obs2\n\twt_word\t\tobs3\nend\n\nconst NORMAL_PRIORITY_CLASS=32\nconst CREATE_NEW_CONSOLE=16\nconst DETACHED_PROCESS=16\n\nconst MEM_COMMIT\t\t\t\t= 4096\nconst MEM_RESERVE\t\t\t\t= 8192\nconst PAGE_EXECUTE\t\t\t\t= 16\nconst PAGE_EXECUTE_READ\t\t\t= 32\nconst PAGE_EXECUTE_READWRITE\t= 64\nconst PAGE_NOACCESS\t\t\t\t= 1\n\n\nexport wt_handle hconsole, hconsolein\n\ninput_record lastkey, pendkey\nint keypending\t\t\t!whether pendkey contains a new key event detected by flushkbd\n\nint hpfreq\t\t\t\t!counts per msec\n\n\nref func (ref void)int wndproc_callbackfn=nil\t!windows call-back: address of handler\n\nint init_flag=0\n\nexport proc os_init=\n!general initialisation\n\thconsole:=GetStdHandle(u32(-11))\n\thconsolein:=GetStdHandle(u32(-10))\n\n\tlastkey.repeatcount:=0\n\tkeypending:=0\n\n\tSetConsoleCtrlHandler(nil,1)\n\n\tSetConsoleMode(hconsole,1 ior 2)\n\n\tinit_flag:=1\n\nend\n\nexport func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\n\twt_dword exitcode\n\tint status\n\tint cflags:=0\n\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tcase newconsole\n\twhen 0 then cflags := NORMAL_PRIORITY_CLASS\n\twhen 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE\n\twhen 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS\n\tesac\n\n\tsi.size := rstartupinfo.bytes\n\n\tstatus:=CreateProcessA(\n\t\tnil,\n\t\tcmdline,\n\t\tnil,\n\n\t\tnil,\n\t\t1,\n\t\tcflags,\n\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tif status=0 then\t\t!fails\n\t\tstatus:=GetLastError()\n\t\tprintf(\"Winexec error: %lld\\n\",status)\n\t\treturn -1\n\tfi\n\n\tWaitForSingleObject(xpi.process, 0xFFFF'FFFF)\n\tGetExitCodeProcess(xpi.process,&exitcode)\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn exitcode\nend\n\nexport func os_execcmd(ichar cmdline, int newconsole=0)int =\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tsi.size := rstartupinfo.bytes\n\n\tCreateProcessA( nil,\n\t\tcmdline,\n\t\tnil,\n\t\tnil,\n\t\t1,\n\t\tNORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn 1\nend\n\nexport func os_getch:int=\n\tint k\n\n\tk:=os_getchx() iand 255\n\n\treturn k\nend\n\nexport func os_kbhit:int=\n\twt_dword count\n\n\tunless init_flag then os_init() end\n\n\tGetNumberOfConsoleInputEvents(hconsolein,&count)\n\treturn count>1\nend\n\nexport func os_getdllinst(ichar name)u64=\n\twt_handle hinst\n\n\thinst:=LoadLibraryA(name)\n\treturn cast(hinst)\nend\n\nexport func os_getdllprocaddr(int hinst,ichar name)ref void=\n\treturn GetProcAddress(cast(hinst),name)\nend\n\nexport proc os_initwindows=\n\tos_init()\n\tos_gxregisterclass(\"pcc001\")\nend\n\nexport proc os_gxregisterclass(ichar classname)=\n\tconst idcarrow=32512\n\trwndclassex r\n\tstatic byte registered\n\n\tif registered then\n\t\treturn\n\tfi\n\n\tclear r\n\n\tr.size:=r.bytes\n\tr.style:=8 ior 32\n\tr.wndproc:=cast(&mainwndproc)\n\tr.instance:=nil\n\n\tr.icon:=nil\n\tr.cursor:=LoadCursorA(nil,ref void(idcarrow))\n\tr.background:=cast(15+1)\n\tr.menuname:=nil\n\tr.classname:=classname\n\tr.iconsm:=nil\n\n\tif RegisterClassExA(&r)=0 then\n\t\tprintf(\"Regclass error: %lld %lld\\n\",classname,GetLastError())\n\t\tstop 1\n\tend\n\tregistered:=1\nend\n\nglobal function mainwndproc (\n\t\twt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)int=\n\trmsg m\n\tint result\n\tstatic int count=0\n\n!CPL \"MAINWNDPROC\",HWND\n\n\tm.hwnd:=hwnd\n\tm.message:=message\n\tm.wParam:=wParam\n\tm.lParam:=lParam\n\tm.pt.x:=0\n\tm.pt.y:=0\n\t\n\tif (wndproc_callbackfn) then\n\t\tresult:=(wndproc_callbackfn^)(&m)\n\telse\n\t\tresult:=0\n\tfi\n\n\tif m.message=wm_destroy then\n\t\treturn 0\n\tfi\n\n\tif not result then\n\t\treturn DefWindowProcA(hwnd,message,wParam,lParam)\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport proc os_setmesshandler(ref void addr)=\n\twndproc_callbackfn:=addr\nend\n\nexport func os_getchx:int=\n!Q! function  os_getchx_c:int\n!return a 32-bit value containing:\n! 15..B0:\tchar code\n! 23..16\tvirtual keycode\n! 31..24\tshift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)\n\tconst rightaltmask\t= 1\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\tint count\n\tint charcode,keyshift,keycode\n\tint altdown,ctrldown,shiftdown,capslock\n\n!os_init() unless init_flag\n\tunless init_flag then os_init() end\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\tReadConsoleInputA(hconsolein,&lastkey,1,&count)\n\t\t\tuntil (lastkey.eventtype=1 and lastkey.keydown=1)\n\t\tfi\n\tfi\n\n!set shift flags\n\n\taltdown\t\t:= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)\n\tctrldown\t:= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)\n\tshiftdown\t:= ((lastkey.controlkeystate iand shiftmask)|1|0)\n\tcapslock\t:= ((lastkey.controlkeystate iand capsmask)|1|0)\n\n\t--lastkey.repeatcount\t\t!count this key out\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n\tif charcode<0 then\n\t\tif charcode<-128 then\n\t\t\tcharcode:=0\n\t\telse\n\t\t\tcharcode+:=256\n\t\tfi\n\tfi\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!....\n\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\treturn keyshift<<24 ior keycode<<16 ior charcode\nend\n\nexport func os_getos=>ichar=\n\treturn \"W64\"\nend\n\nexport func os_gethostsize=>int=\n\treturn 64\nend\n\nexport func os_shellexec(ichar opc, file)int=\n\treturn system(file)\nend\n\nexport proc os_sleep(int a)=\n\tSleep(a)\nend\n\nexport func os_getstdin:filehandle =\n\treturn fopen(\"con\",\"rb\")\nend\n\nexport func os_getstdout:filehandle =\n\treturn fopen(\"con\",\"wb\")\nend\n\nexport func os_gethostname:ichar=\n\tstatic [300]char name\n\tstatic int n\n\n\tGetModuleFileNameA(nil,&.name,name.bytes)\n\treturn &.name\nend\n\nexport func os_getmpath:ichar=\n!BART\n!\treturn \"C:\\\\m\\\\\"\n\treturn F\"C:@@@@\\m\\\" !ABC\n!\treturn \"C:@@@@\\\\m\\\\\" !ABC\nend\n\nexport func os_clock:i64=\n!\treturn clock()\n\treturn os_hpcounter()\nend\n\nexport func os_ticks:i64=\n\treturn GetTickCount64()\nend\n\nexport func os_iswindows:int=\n\treturn 1\nend\n\nexport proc os_getsystime(ref rsystemtime tm)=\n\tGetLocalTime(tm)\nend\n\nexport proc os_peek=\n\tint ticks\n\tstatic int lastticks\n\t[100]byte m\n\tticks:=GetTickCount64()\n\tif ticks-lastticks>=1000 then\n\t\tlastticks:=ticks\n\t\tPeekMessageA(&m,nil,0,0,0)\n\tfi\nend\n\nexport func os_allocexecmem(int n)ref byte=\n\tref byte p\n\tu32 oldprot\n\tint status\n\n\tp := VirtualAlloc(nil, n, MEM_RESERVE ior MEM_COMMIT, PAGE_NOACCESS)\n\tif p = nil then return nil fi\n\n\tstatus := VirtualProtect(p, n, PAGE_EXECUTE_READWRITE, &oldprot)\n\tif status = 0 then return nil fi\n\n\treturn p\nend\n\nexport func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int=\n!filespec is a filename (eg. \"*.dwg\") with possible drive/path; scan\n!directory for all matching files:\n! Store each file in dest array up to capacity\n! Return:\n!  -1:\tcapacity exceeded\n!   N:  number of files found including 0 for no matching files\n\n!t has this value\n! +1  Include normal files only, no sub-directory names\n! +2  Include directories\n! +3  (+1 +2) Include all files including directories\n! +4  Convert to lower case\n\tref void hfind\n\trfinddata file\n\tint nfiles:=0\n\t[300]char path\n\t[300]char fullfilename\n\n\tstrcpy(path, extractpath(filespec))\n\n\n\tif (hfind:=findfirstfilea(filespec,&file))<>ref void(-1) then\t!at least one file\n\t\trepeat\n\t\t\tif (file.fileattributes iand 16) then\t\t!this is a directory\n\t\t\t\tif (t iand 2)=0 then nextloop fi\t\t!no directories\n\t\t\telse\t\t\t\t\t\t!this is a file\n\t\t\t\tif (t iand 1)=0 then nextloop fi\n\t\t\tfi\n\t\t\tif nfiles>=capacity then\n\t\t\t\tnfiles:=-1\n\t\t\t\texit\n\t\t\tfi\n\n\t\t\tif (t iand 4) then\t\t\t\t!to lower case\n\t\t\t\tconvlcstring(file.filename)\n!\t\t\t\tconvlcstring(&.file.filename)\n\t\t\tfi\n\t\t\tstrcpy(fullfilename, path)\n\t\t\tstrcat(fullfilename, file.filename)\n\n\t\t\tdest[++nfiles]:=pcm_copyheapstring(fullfilename)\n\n\t\tuntil not findnextfilea(hfind,&file)\n\t\tfindclose(hfind)\n\tfi\n\treturn nfiles\nend\n\nexport func os_hpcounter:int a =\n!return counter such that successive calls indicate duration in msec\n\n\tif hpfreq=0 then\n\t\thpfreq:=os_hpfreq()/1000\t\t!counts per msec\n\tfi\n\n\tQueryPerformanceCounter(&a)\n\ta/hpfreq\nend\n\nexport func os_hpfreq:int a =\n\tQueryPerformanceFrequency(&a)\n\ta\nend\n\n",
(u64)"!import clib\n!import mlib\n!\n!importlib cstd=\n!\tclang proc     sleep\t(word32)\n!end\n\nrecord termios =\n\ti32 c_iflag\n\ti32 c_oflag\n\ti32 c_cflag\n\ti32 c_lflag\n\tchar c_line\n\t[32]char c_cc\t\t\t\t!at offset 17\n\t[3]byte filler\n\ti32 c_ispeed\t\t\t\t!at offset 52\n\ti32 c_ospeed\nend\n\n!importdll dlstuff=\nimportdll msvcrt=\n\tfunc dlopen\t\t\t(ichar, i32)ref void\n\tfunc dlsym\t\t\t(ref void, ichar)ref void\n\tfunc tcgetattr\t\t(i32, ref termios) i32\n\tfunc tcsetattr\t\t(i32, i32, ref termios) i32\n\tfunc gettimeofday\t(ref timeval, ref void) i32\n\tfunc gmtime_r  \t   (ref i64, ref tm_rec) ref void\n\tproc stdin\n\tproc stdout\nend\n \nrecord timeval =\n\ti64 tv_sec\n\ti64 tv_usec\nend\n\nrecord tm_rec =\n\ti32 tm_sec\n\ti32 tm_min\n\ti32 tm_hour\n\ti32 tm_mday\n\n\ti32 tm_mon\n\ti32 tm_year\n\ti32 tm_wday\n\ti32 tm_yday\n\ti32 tm_isdst\n\t[20]byte padding\nend\n\n!this record is used by some apps, so these fields must be present\nexport record rsystemtime =\n\ti32 year\n\ti32 month\n\ti32 dayofweek\n\ti32 day\n\ti32 hour\n\ti32 minute\n\ti32 second\n\tint milliseconds\nend\n\nint init_flag=0\n\n\nexport proc os_init=\n\tinit_flag:=1\nend\n\nexport func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\n\treturn system(cmdline)\nend\n\nexport func os_execcmd(ichar cmdline, int newconsole)int =\n\treturn system(cmdline)\nend\n\nexport func os_getch:int=\n\tconst ICANON  = 2\n\tconst ECHO    = 8\n\tconst TCSANOW = 0\n\tconst ISIG    = 1\n\n\ttermios old,new\n\tchar ch\n\n\ttcgetattr(0,&old)\n\tnew:=old\n\tnew.c_lflag iand:=inot ICANON\n\tnew.c_lflag iand:=inot ECHO\n\tnew.c_lflag iand:=inot ISIG\n\n\ttcsetattr(0,TCSANOW,&new)\n\n\tch:=getchar()\n\n\ttcsetattr(0,TCSANOW,&old)\n\n\treturn ch\nend\n\nexport func os_kbhit:int=\n\tabortprogram(\"kbhit\")\n\treturn 0\nend\n\nexport proc os_flushkeys=\n\tabortprogram(\"flushkeys\")\nend\n\nexport func os_getconsolein:ref void=\n\treturn nil\nend\n\nexport func os_getconsoleout:ref void=\n\treturn nil\nend\n\nexport func os_proginstance:ref void=\n\tabortprogram(\"PROGINST\")\n\treturn nil\nend\n\nexport func os_getdllinst(ichar name)u64=\n\tconst RTLD_LAZY=1\n\tref void h\n\n\th:=dlopen(name,RTLD_LAZY)\n\n\tif h=nil then\n\t\tif strcmp(name,\"msvcrt\")=0 then\t\t\t!might be linux\n\t\t\th:=dlopen(\"libc.so.6\",RTLD_LAZY);\n\t\tfi\n\tfi\n\n\treturn cast(h)\nend\n\nexport func os_getdllprocaddr(int hlib,ichar name)ref void=\n\tref void fnaddr\n\n\tif hlib=0 then\n\t\treturn nil\n\tfi\n\n\tfnaddr:=dlsym(cast(int(hlib)), name)\n\treturn fnaddr\nend\n\nexport proc os_initwindows=\nend\n\nexport func os_getchx:int=\n\tabortprogram(\"getchx\")\n\treturn 0\nend\n\nexport func os_getos=>ichar=\n!\tif $targetbits=32 then\n!\t\treturn \"L32\"\n!\telse\n\t\treturn \"L64\"\n!\tfi\nend\n\nexport func os_gethostsize=>int=\n\treturn 64\nend\n\nexport func os_iswindows:int=\n\treturn 0\nend\n\nexport func os_shellexec(ichar opc, file)int=\n\tabortprogram(\"SHELL EXEC\")\n\treturn 0\nend\n\nexport proc  os_sleep(int a)=\n!*!\tsleep(a)\nend\n\nexport func os_getstdin:filehandle =\n\tref filehandle pf:=cast(stdin)\n\treturn pf^\nend\n\nexport func os_getstdout:filehandle =\n\tref filehandle pf:=cast(stdout)\n\treturn pf^\nend\n\nexport func os_gethostname:ichar=\n!\tabortprogram(\"gethostname\")\n\treturn \"\"\nend\n\nexport func os_getmpath:ichar=\n!\tabortprogram(\"getmpath\")\n\treturn \"\"\nend\n\nexport proc os_exitprocess(int x)=\n\tstop\n!\t_exit(0)\n!\tExitProcess(x)\nend\n\nexport func os_clock:i64=\n\tif os_iswindows() then\n\t\treturn clock()\n\telse\n\t\treturn clock()/1000\n\tfi\nend\n\nexport func os_ticks:i64=\n\treturn clock()\nend\n\nexport func os_getclockspersec:i64=\n\treturn (os_iswindows()|1000|1000'000)\nend\n\nexport proc os_setmesshandler(ref void addr)=\n\tabortprogram(\"SETMESSHANDLER\")\n!\twndproc_callbackfn:=addr\nend\n\nexport func os_hpcounter:i64=\n\treturn 1\nend\n\nexport func os_hpfrequency:i64=\n\treturn 1\nend\n\nexport func os_filelastwritetime(ichar filename)i64=\n\treturn 0\nend\n\nexport proc os_getsystime(ref rsystemtime tm)=\n\ttimeval tv\n\ttm_rec tmr\n\n\n\tgettimeofday(&tv, nil)\n\tgmtime_r(&tv.tv_sec, &tmr)\n\n\ttm.year := tmr.tm_year + 1900\n\ttm.month := tmr.tm_mon + 1\n\ttm.dayofweek := tmr.tm_wday + 1\n\ttm.day := tmr.tm_mday\n\ttm.hour := tmr.tm_hour\n\ttm.minute := tmr.tm_min\n\ttm.second := tmr.tm_sec\n\ttm.milliseconds := tv.tv_usec/1000\ntm.month:=1\t\t\t!avoid crashing the M compiler\nend\n\nexport proc os_peek=\nend\n\nexport func  os_allocexecmem(int n)ref byte=\n\tabortprogram(\"No allocexec\")\n\tnil\nend\n\nexport func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int=\n\t0\nend\n",
(u64)"export function os_calldllfunction(\n\tref proc fnaddr,\n\tint retcode, nargs,\n\tref[]i64 args,\n\tref[]byte argcodes)u64 =\n\n\tu64 a\n\tr64 x\n\tint nextra := 0, pushedbytes\n\n!Stack is 16-byte aligned at this point\n\n\tif nargs<4 then\n\t\tnextra:=4-nargs\t\t\t!need at least 4 slots for shadow space\n\telsif nargs.odd then\t\t!need one more for a 16-byte-aligned stack\n\t\tnextra:=1\n\tfi\n\n\tpushedbytes:=(nextra+nargs)*8\n\n\tto nextra do\n\t\tasm push 0\n\tod\n\n\tfor i:=nargs downto 1 do\n\t\ta:=args[i]\t\t\t\t!get generic 64-bit value to push\n\t\tasm push u64 [a]\n\tod\n\n! blindly load first 4 args to both int/float regs, whether used or not,\n! and assuming calling a variadic function whether it is or not\n\n\tassem\n\t\tmov D10,   [Dstack]\n\t\tmovq XMM0, [Dstack]\n\t\tmov D11,   [Dstack+8]\n\t\tmovq XMM1, [Dstack+8]\n\t\tmov D12,   [Dstack+16]\n\t\tmovq XMM2, [Dstack+16]\n\t\tmov D13,   [Dstack+24]\n\t\tmovq XMM3, [Dstack+24]\n\tend\n\n\tif retcode='I' then\n\t\ta:=(ref func:i64(fnaddr))^()\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn a\n\n\telse\n\t\tx:=(ref func:r64(fnaddr))^()\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn u64@(x)\t\t\t!(type-punning cast)\n\n\tfi\nend\t\n",
(u64)"type dll0_int=ref function:int\ntype dll1_int=ref function(int)int\ntype dll2_int=ref function(int,int)int\ntype dll3_int=ref function(int,int,int)int\ntype dll4_int=ref function(int,int,int,int)int\ntype dll5_int=ref function(int,int,int,int,int)int\ntype dll6_int=ref function(int,int,int,int,int,int)int\ntype dll8_int=ref function(int,int,int,int, int,int,int,int)int\ntype dll9_int=ref function(int,int,int,int, int,int,int,int, int)int\ntype dll10_int=ref function(int,int,int,int, int,int,int,int, int,int)int\ntype dll11_int=ref function(int,int,int,int, int,int,int,int, int,int,int)int\ntype dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int\ntype dll14_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int, int,int)int\n\ntype dll0_r64=ref function:r64\ntype dll1_r64=ref function(int)r64\ntype dll2_r64=ref function(int,int)r64\n\ntype dll0_r64x=ref function:r64\ntype dll1_r64x=ref function(real)r64\ntype dll2_r64x=ref function(real,real)r64\n\ntype m_dll0_int=ref function:int\ntype m_dll1_int=ref function(int)int\ntype m_dll2_int=ref function(int,int)int\ntype m_dll3_int=ref function(int,int,int)int\ntype m_dll4_int=ref function(int,int,int,int)int\ntype m_dll5_int=ref function(int,int,int,int,int)int\ntype m_dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int\n\ntype m_dll0_r64=ref function:r64\ntype m_dll1_r64=ref function(int)r64\ntype m_dll2_r64=ref function(int,int)r64\n\n\nexport function os_calldllfunction(ref proc fnaddr,\n\t\tint retcode, nargs, ref[]i64 args, ref[]byte argcodes)u64 =\n!retcode is 'R' or 'I'\n!each argcodes element is 'R' or 'I' too\n!The x64 version can work with any combination.\n!Here, for C, only some combinations are dealt with:\n! I result, params all I (not all param counts)\n! R result, params all I (not all param counts)\n!Mixed params, for arbitrary return type, not handled (not really detected either)\n\n\tu64 a\n\tr64 x\n\tint oddstack, nextra, pushedbytes\n\n!CPL \"/////CCCCCCCCCCCCCCCCCC\"\n\n\tif retcode='I' then\n\t\treturn calldll_cint(fnaddr,args,nargs)\n\telse\n\t\treturn calldll_creal(fnaddr,args,nargs)\n\tfi\nend\t\n\nglobal function os_pushargs(ref[]u64 args, int nargs, nextra,\n\t\t\t\t\tref proc fnaddr, int isfloat)u64=\n\tu64 a\n\tr64 x\n!ABORTPROGRAM(\"PUSHARGS/C NOT READY\")\n\n\treturn os_calldllfunction(fnaddr, (isfloat|0|'I'), nargs, cast(args), nil)\n\n\n!\treturn a\nend\n\nfunction calldll_cint (ref proc fnaddr,ref[]i64 params,int nparams)i64=\nswitch nparams\nwhen 0 then\n\treturn dll0_int(fnaddr)^()\nwhen 1 then\n\treturn dll1_int(fnaddr)^(params^[1])\nwhen 2 then\n\treturn dll2_int(fnaddr)^(params^[1],params^[2])\nwhen 3 then\n\treturn dll3_int(fnaddr)^(params^[1],params^[2],params^[3])\nwhen 4 then\n\treturn dll4_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4])\nwhen 5 then\n\treturn dll5_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4], params^[5])\nwhen 6 then\n\treturn dll6_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4], params^[5],params^[6])\nwhen 8 then \n\treturn (dll8_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8])\nwhen 9 then \n\treturn (dll9_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9])\nwhen 10 then \n\treturn (dll10_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10])\nwhen 11 then \n\treturn (dll11_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11])\n\nwhen 12 then \n\treturn (dll12_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11],params^[12])\n\n!when 14 then \n!\treturn (dll14_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n!\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11],params^[12],\n!\t\t\t\tparams^[13],params^[14])\n!\nelse\n\tcpl nparams\n\tprintln \"calldll/c/int unsupported # of params\", nparams\n\tstop 1\nend switch\nreturn 0\nend\n\nfunction calldll_creal (ref proc fnaddr,ref[]i64 params,int nparams)i64=\nr64 x\n\nswitch nparams\nwhen 0 then\n\treturn dll0_r64(fnaddr)^()\nwhen 1 then\n\tos_dummycall(params^[1],params^[2],params^[3],params^[4])\n\tx:=dll1_r64(fnaddr)^(params^[1])\nwhen 2 then\n\tx:=dll2_r64(fnaddr)^(params^[1],params^[2])\nelse\n\tprintln \"calldll/c/real too many params\"\n\tstop 1\nend switch\nreturn i64@(x)\nend\n\n\nglobal proc os_dummycall(r64 a,b,c,d)=\nend\n"}};

static u64 mm_modules_fileext = (u64)"m";

static struct $B15 mm_modules_getmodulefilename_str;
static u64 mm_name_currstproc;
static i64 mm_name_allowmodname = 0;

static i64 mm_name_noexpand;
static i64 mm_name_noassem;
static i64 mm_name_macrolevels;
static struct $B18 mm_name_macroparams;
static struct $B18 mm_name_macroparamsgen;
static struct $B18 mm_name_macroargs;
static i64 mm_name_nmacroparams;
static i64 mm_name_nmacroargs;
static i64 mm_parse_intabledata = 0;

static i64 mm_parse_inreadprint = 0;

static i64 mm_parse_inparamlist = 0;

static i64 mm_parse_inrecordbody = 0;

static i64 mm_parse_inimportmodule = 0;

static i64 mm_parse_labelseen = 0;

static u64 mm_parse_tabledataname = 0;

static struct $B1 mm_parse_procstack;
static i64 mm_parse_nprocstack = 0;

static u64 mm_parse_unionstring;
static u64 mm_parse_unionpend;
static u64 mm_parse_unionlastvar = 0;

static u64 mm_parse_dretvar;
static i64 mm_parse_varattribs = 0;

static struct $B1 mm_parse_dollarstack;
static i64 mm_parse_ndollar = 0;

static i64 mm_parse_insiderecord = 0;

static i64 mm_parse_insidedllimport = 0;

static struct $B1 mm_parse_forindexvars;
static i64 mm_parse_nforloops;
// Istatic skipped:mm_parse.readcompilervar.monthnames

static u64 mm_support_bytemasks = -9205322385119247871;

static struct $B16 mm_tables_stdnames = {{
(u64)"void",
(u64)"r64",
(u64)"r32",
(u64)"i64",
(u64)"u64",
(u64)"c64",
(u64)"bool64",
(u64)"ref",
(u64)"rec",
(u64)"range",
(u64)"array",
(u64)"slice",
(u64)"c8",
(u64)"b8",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"ichar",
(u64)"refbit",
(u64)"auto",
(u64)"any",
(u64)"proc",
(u64)"label",
(u64)"type",
(u64)"bitfl",
(u64)"tuple",
(u64)"pend",
(u64)"block",
(u64)"last "}};

static struct $B17 mm_tables_stdsize = {{
578721382704351232,
144397767127601152,
17626613022980,
2251799948427264}};

static struct $B17 mm_tables_stdpcl = {{
433478087141818880,
578434388745456395,
434041037011550985,
3102847684445702}};

static i64 mm_tables_trefproc;
static i64 mm_tables_treflabel;
static struct $B74 mm_tables_sysfnnames = {{
(u64)"sf_init",
(u64)"sf_print_startfile",
(u64)"sf_print_startstr",
(u64)"sf_print_startptr",
(u64)"sf_print_startcon",
(u64)"sf_print_setfmt",
(u64)"sf_print_nogap",
(u64)"sf_print_space",
(u64)"sf_print_i64",
(u64)"sf_print_i64_nf",
(u64)"sf_print_u64",
(u64)"sf_print_r64",
(u64)"sf_print_r32",
(u64)"sf_print_str",
(u64)"sf_print_str_nf",
(u64)"sf_print_strsl",
(u64)"sf_print_ptr",
(u64)"sf_print_ptr_nf",
(u64)"sf_print_c8",
(u64)"sf_print_bool",
(u64)"sf_print_newline",
(u64)"sf_print_end",
(u64)"sf_read_i64",
(u64)"sf_read_r64",
(u64)"sf_read_str",
(u64)"sf_read_fileline",
(u64)"sf_read_strline",
(u64)"sf_read_conline",
(u64)"sf_getnprocs",
(u64)"sf_getprocname",
(u64)"sf_getprocaddr",
(u64)"sf_power_i64",
(u64)"sf_unimpl"}};

static struct $B75 mm_tables_sysfnparams = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B75 mm_tables_sysfnres = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1}};

static struct $B74 mm_tables_sysfnhandlers;
static struct $B76 mm_tables_jtagnames = {{
(u64)"jnone",
(u64)"jconst",
(u64)"jnull",
(u64)"jvoidvar",
(u64)"jname",
(u64)"jnamelv",
(u64)"jblock",
(u64)"jdecimal",
(u64)"jassem",
(u64)"jassemmacro",
(u64)"jassemreg",
(u64)"jassemxreg",
(u64)"jassemmem",
(u64)"jstrinclude",
(u64)"jsourceline",
(u64)"jandl",
(u64)"jorl",
(u64)"jnotl",
(u64)"jistruel",
(u64)"jisfalsel",
(u64)"jmakelist",
(u64)"jmakerange",
(u64)"jmakeset",
(u64)"jmakedict",
(u64)"jmakeslice",
(u64)"jreturnmult",
(u64)"jkeyword",
(u64)"jkeyvalue",
(u64)"jassign",
(u64)"jassignmm",
(u64)"jassignms",
(u64)"jassignmdrem",
(u64)"jcall",
(u64)"jcmp",
(u64)"jcmpchain",
(u64)"jbin",
(u64)"junary",
(u64)"jprop",
(u64)"jbinto",
(u64)"junaryto",
(u64)"jincr",
(u64)"jin",
(u64)"jinrev",
(u64)"jinrange",
(u64)"jinset",
(u64)"jstringz",
(u64)"jindex",
(u64)"jindexlv",
(u64)"jslice",
(u64)"jdot",
(u64)"jdotlv",
(u64)"jdotindex",
(u64)"jdotslice",
(u64)"jptr",
(u64)"jptrlv",
(u64)"jaddrof",
(u64)"jaddroffirst",
(u64)"jdaddrvv",
(u64)"jconvert",
(u64)"jshorten",
(u64)"jautocast",
(u64)"jtypepun",
(u64)"jtypeconst",
(u64)"joperator",
(u64)"jupper",
(u64)"jbitwidth",
(u64)"jbytesize",
(u64)"jtypestr",
(u64)"jbitfield",
(u64)"jminvalue",
(u64)"jmaxvalue",
(u64)"jcvlineno",
(u64)"jcvstrlineno",
(u64)"jcvmodulename",
(u64)"jcvfilename",
(u64)"jcvfunction",
(u64)"jcvdate",
(u64)"jcvtime",
(u64)"jcvversion",
(u64)"jcvtypename",
(u64)"jcvnil",
(u64)"jcvpi",
(u64)"jcvinfinity",
(u64)"jcvtrue",
(u64)"jcvfalse",
(u64)"jwhenthen",
(u64)"jfmtitem",
(u64)"jnogap",
(u64)"jspace",
(u64)"jreturn",
(u64)"jsyscall",
(u64)"jto",
(u64)"jif",
(u64)"jforup",
(u64)"jfordown",
(u64)"jforall",
(u64)"jforallrev",
(u64)"jwhile",
(u64)"jrepeat",
(u64)"jgoto",
(u64)"jlabeldef",
(u64)"jredo",
(u64)"jnext",
(u64)"jexit",
(u64)"jdo",
(u64)"jcase",
(u64)"jdocase",
(u64)"jswitch",
(u64)"jdoswitch",
(u64)"jdoswitchu",
(u64)"jdoswitchx",
(u64)"jswap",
(u64)"jselect",
(u64)"jrecase",
(u64)"jprint",
(u64)"jprintln",
(u64)"jfprint",
(u64)"jfprintln",
(u64)"jread",
(u64)"jreadln",
(u64)"jstop",
(u64)"jeval",
(u64)"jclear"}};

static struct $B77 mm_tables_jsubs = {{
0,
0,
0,
0,
0,
0,
1,
0,
3,
0,
0,
0,
1,
1,
1,
2,
2,
1,
1,
1,
2,
2,
1,
1,
2,
0,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
2,
2,
2,
2,
0,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
0,
1,
1,
3,
3,
3,
3,
3,
3,
3,
2,
1,
0,
0,
0,
0,
1,
3,
3,
3,
3,
3,
3,
2,
3,
1,
2,
2,
3,
3,
2,
2,
1,
1,
1}};

static struct $B77 mm_tables_jisexpr = {{
0,
3,
3,
3,
3,
3,
0,
3,
0,
0,
0,
0,
0,
3,
3,
2,
2,
1,
1,
1,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
2,
1,
2,
1,
1,
2,
1,
3,
2,
2,
2,
2,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
1,
1,
1,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
0,
3,
3,
3,
0,
3,
0,
3,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
3,
0,
3,
0,
0,
0,
0,
3,
0,
0,
0,
0,
0,
0,
0,
0,
3,
1}};

static struct $B77 mm_tables_jsolo = {{
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
0,
1,
1}};

static struct $B30 mm_tables_bitfieldnames = {{
(u64)"bf_msb",
(u64)"bf_lsb",
(u64)"bf_msbit",
(u64)"bf_lsbit",
(u64)"bf_msw",
(u64)"bf_lsw",
(u64)"bf_odd",
(u64)"bf_even"}};

static struct $B17 mm_tables_optypenames = {{
(u64)"no_op",
(u64)"bin_op",
(u64)"mon_op",
(u64)"prop_op"}};

static struct $B78 mm_tables_symbolnames = {{
(u64)".",
(u64)"&.",
(u64)",",
(u64)";",
(u64)":",
(u64)":=",
(u64)"=>",
(u64)"->",
(u64)"(",
(u64)")",
(u64)"[",
(u64)"]",
(u64)"{",
(u64)"}",
(u64)"^",
(u64)"|",
(u64)"@",
(u64)"?",
(u64)"&",
(u64)"&&",
(u64)"..",
(u64)"...",
(u64)"#",
(u64)"+",
(u64)"-",
(u64)"*",
(u64)"/",
(u64)"%",
(u64)"rem",
(u64)"divrem",
(u64)"iand",
(u64)"ior",
(u64)"ixor",
(u64)"<<",
(u64)">>",
(u64)"min",
(u64)"max",
(u64)"and",
(u64)"or",
(u64)"xor",
(u64)"=",
(u64)"cmp",
(u64)"**",
(u64)"in",
(u64)"notin",
(u64)"inrev",
(u64)"not",
(u64)"istrue",
(u64)"inot",
(u64)"abs",
(u64)"sign",
(u64)"sqrt",
(u64)"sqr",
(u64)"propsym",
(u64)"mathsopsym",
(u64)"maths2opsym",
(u64)"bitfieldsym",
(u64)"eolsym",
(u64)"eofsym",
(u64)"rawxnamesym",
(u64)"incrsym",
(u64)"intconstsym",
(u64)"realconstsym",
(u64)"charconstsym",
(u64)"stringconstsym",
(u64)"unitnamesym",
(u64)"namesym",
(u64)"kincludesym",
(u64)"kstrincludesym",
(u64)"regsym",
(u64)"xregsym",
(u64)"fregsym",
(u64)"mregsym",
(u64)"jmpccsym",
(u64)"setccsym",
(u64)"movccsym",
(u64)"segnamesym",
(u64)"asmopcodesym",
(u64)"stdtypesym",
(u64)"kicharsym",
(u64)"kifsym",
(u64)"kthensym",
(u64)"kelsifsym",
(u64)"kelsesym",
(u64)"kelsecasesym",
(u64)"kelseswitchsym",
(u64)"kendsym",
(u64)"kunlesssym",
(u64)"kcasesym",
(u64)"kdocasesym",
(u64)"krecasesym",
(u64)"kwhensym",
(u64)"kforsym",
(u64)"ktosym",
(u64)"kbysym",
(u64)"kdosym",
(u64)"kwhilesym",
(u64)"krepeatsym",
(u64)"kuntilsym",
(u64)"kreturnsym",
(u64)"kstopsym",
(u64)"kloopsym",
(u64)"kgotosym",
(u64)"kswitchsym",
(u64)"kdoswitchsym",
(u64)"kprintsym",
(u64)"kreadsym",
(u64)"kprocsym",
(u64)"kfunctionsym",
(u64)"klabelsym",
(u64)"krecordsym",
(u64)"kstructsym",
(u64)"kunionsym",
(u64)"kimportmodulesym",
(u64)"kprojectsym",
(u64)"ktypesym",
(u64)"krefsym",
(u64)"kvoidsym",
(u64)"kvarsym",
(u64)"kletsym",
(u64)"kslicesym",
(u64)"kmacrosym",
(u64)"kconstsym",
(u64)"kclearsym",
(u64)"kheadersym",
(u64)"kglobalsym",
(u64)"kstaticsym",
(u64)"kcastsym",
(u64)"compilervarsym",
(u64)"dollarsym",
(u64)"kevalsym",
(u64)"ktabledatasym",
(u64)"kclampsym",
(u64)"kswapsym",
(u64)"kassemsym",
(u64)"ksyscallsym"}};

static struct $B40 mm_tables_symboloptypes = {{
1099511627776,
0,
72057598332895232,
72340172838076673,
72340172838076673,
144678142341087489,
3307158503938,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B40 mm_tables_symbolgenops = {{
0,
0,
3098476543630901248,
3689065127789604140,
241444468020,
17732923538145280,
284597173566,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B40 mm_tables_symbolgentoops = {{
0,
0,
6485183463413514240,
7016608629048302683,
439787742050,
30399297484750848,
27243,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B40 mm_tables_symbolopprios = {{
1099511627776,
0,
288230397626548224,
289359587528868612,
578720265945678596,
25870599686,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B40 mm_tables_exprstarter = {{
256,
281474976776193,
72057594037993472,
1,
4311744512,
72339069014638849,
72339073326448897,
72340172821233664,
4295032833,
72339069014638592,
1,
1,
0,
0,
1103806595072,
72057594037927936,
72057598332895489}};

static struct $B17 mm_tables_headerdirnames = {{
(u64)"hdr_module",
(u64)"hdr_import",
(u64)"hdr_sourcepath",
(u64)"hdr_linkdll"}};

static struct $B17 mm_tables_scopenames = {{
(u64)"Local",
(u64)"Global",
(u64)"Program",
(u64)"Export"}};

static struct $B3 mm_tables_parammodenames = {{
(u64)"Byval ",
(u64)"Byref "}};

static struct $B37 mm_tables_namenames = {{
(u64)"nullid",
(u64)"programid",
(u64)"subprogid",
(u64)"moduleid",
(u64)"dllmoduleid",
(u64)"typeid",
(u64)"procid",
(u64)"dllprocid",
(u64)"dllvarid",
(u64)"constid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"fieldid",
(u64)"labelid",
(u64)"macroid",
(u64)"macroparamid",
(u64)"linkid"}};

static struct $B38 mm_tables_name2pid = {{
0,
2304,
0,
258,
0,
1027,
5,
6,
0}};

static struct $B1 mm_tables_propnames = {{
(u64)"kksliceptr",
(u64)"kklen",
(u64)"kklwb",
(u64)"kkupb",
(u64)"kkbounds",
(u64)"kkbitwidth",
(u64)"kkbytesize",
(u64)"kktypestr",
(u64)"kkminval",
(u64)"kkmaxval"}};

static struct $B79 mm_tables_stnames = {{
(u64)"if",
(u64)"then",
(u64)"elsif",
(u64)"else",
(u64)"dummyelse",
(u64)"elsecase",
(u64)"elseswitch",
(u64)"case",
(u64)"docase",
(u64)"recase",
(u64)"when",
(u64)"for",
(u64)"to",
(u64)"downto",
(u64)"by",
(u64)"do",
(u64)"end",
(u64)"while",
(u64)"repeat",
(u64)"until",
(u64)"return",
(u64)"stop",
(u64)"redoloop",
(u64)"nextloop",
(u64)"exit",
(u64)"goto",
(u64)"switch",
(u64)"doswitch",
(u64)"doswitchu",
(u64)"doswitchx",
(u64)"tabledata",
(u64)"enumdata",
(u64)"clamp",
(u64)"eval",
(u64)"print",
(u64)"println",
(u64)"fprint",
(u64)"fprintln",
(u64)"cp",
(u64)"cpl",
(u64)"read",
(u64)"readln",
(u64)"cast",
(u64)"function",
(u64)"func",
(u64)"proc",
(u64)"fun",
(u64)"threadedproc",
(u64)"type",
(u64)"record",
(u64)"struct",
(u64)"union",
(u64)"ref",
(u64)"var",
(u64)"let",
(u64)"include",
(u64)"binclude",
(u64)"sinclude",
(u64)"strinclude",
(u64)"macro",
(u64)"assem",
(u64)"asm",
(u64)"static",
(u64)"const",
(u64)"$getnprocs",
(u64)"$getprocname",
(u64)"$getprocaddr",
(u64)"importdll",
(u64)"project",
(u64)"unless",
(u64)"global",
(u64)"export",
(u64)"swap",
(u64)"void",
(u64)"int",
(u64)"word",
(u64)"real",
(u64)"ichar",
(u64)"ivoid",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"r32",
(u64)"r64",
(u64)"byte",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"char",
(u64)"c8",
(u64)"c64",
(u64)"bool64",
(u64)"bool",
(u64)"bool8",
(u64)"label",
(u64)"slice",
(u64)"million",
(u64)"billion",
(u64)"$lineno",
(u64)"$strlineno",
(u64)"$filename",
(u64)"$modulename",
(u64)"$function",
(u64)"$date",
(u64)"$time",
(u64)"$version",
(u64)"$typename",
(u64)"nil",
(u64)"pi",
(u64)"true",
(u64)"false",
(u64)"infinity",
(u64)"$",
(u64)"and",
(u64)"or",
(u64)"xor",
(u64)"iand",
(u64)"ior",
(u64)"ixor",
(u64)"in",
(u64)"notin",
(u64)"inrev",
(u64)"rem",
(u64)"divrem",
(u64)"min",
(u64)"max",
(u64)"not",
(u64)"inot",
(u64)"istrue",
(u64)"abs",
(u64)"sqr",
(u64)"sqrt",
(u64)"sign",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"atan2",
(u64)"fmod",
(u64)"sliceptr",
(u64)"len",
(u64)"lwb",
(u64)"upb",
(u64)"bounds",
(u64)"bitwidth",
(u64)"bytes",
(u64)"typestr",
(u64)"msb",
(u64)"lsb",
(u64)"msbit",
(u64)"lsbit",
(u64)"msw",
(u64)"lsw",
(u64)"odd",
(u64)"even",
(u64)"fi",
(u64)"esac",
(u64)"od",
(u64)"$caligned",
(u64)"clear",
(u64)"module",
(u64)"import",
(u64)"$sourcepath",
(u64)"linkdll"}};

static struct $B80 mm_tables_stsymbols = {{
21073,
21587,
21844,
22870,
23386,
23900,
24158,
24671,
24919,
25442,
25956,
26214,
26470,
26984,
26985,
33924,
33669,
27242,
27242,
27242,
27499,
28032,
27757,
27757,
28532,
29040,
30581,
17528,
17733,
31301,
34695,
31615,
34952,
29320,
22643,
32382,
30342,
20303,
20559,
20304,
20303,
20303,
20303,
20303,
20303,
20303,
20303,
20303,
31055,
16962,
33153,
33153,
33153,
33153,
33153,
33153,
33153,
9858,
10279,
8223,
11297,
11821,
7709,
9508,
12591,
12848,
13365,
14131,
14135,
14135,
14135,
14135,
14135,
14391,
13880,
13878,
13878,
13878,
14646,
14649,
14649,
14649,
22329,
22359,
31761,
32125,
32125}};

static struct $B81 mm_tables_stsubcodes = {{
92,
92,
6881281,
6881387,
7405674,
0,
65536,
0,
0,
0,
0,
6684773,
103,
7077995,
7209069,
65536,
0,
7536754,
7667828,
7536754,
7798902,
58,
0,
131073,
0,
0,
0,
0,
5439554,
83,
1,
0,
1966109,
31,
0,
196609,
0,
262147,
786433,
917504,
1048591,
131075,
1114113,
1179665,
262163,
786444,
393221,
851974,
720921,
131073,
4718663,
4784202,
4980811,
5111885,
5242959,
5439569,
5374036,
0,
0,
0,
0,
1,
0,
0,
0,
3997696,
0,
4456448,
4587589,
4718663,
4849737,
4980811,
5111885,
5308495,
65619,
196610,
327684,
458758,
65544,
196610,
327684,
458758,
5308424,
6291545,
1,
131073,
262147}};

static struct $B22 mm_tables_convnames = {{
(u64)"kkerror",
(u64)"kkfloat",
(u64)"kkfix",
(u64)"kktruncate",
(u64)"kkwiden",
(u64)"kkfwiden",
(u64)"kkfnarrow",
(u64)"kksoftconv",
(u64)"kktoboolt",
(u64)"kkharderr",
(u64)"kksofttrun",
(u64)"kkichar2sl",
(u64)"kkax2slice",
(u64)"kkcx2ichar"}};

static struct $B23 mm_tables_convtopcl = {{
28416,
29040,
29554,
116,
64,
0,
0}};

static struct $B12 mm_tables_d_typestarterset = {{
79,
11,
117,
111,
80,
121}};

static struct $B82 mm_tables_softconvtable = {{
7,
6,
2,
2,
2,
5,
7,
2,
2,
2,
1,
1,
7,
7,
7,
1,
1,
7,
7,
7,
1,
1,
7,
7,
7}};

static struct $B40 mm_tables_endsexpr;
static struct $B9 mm_tables_exprendsymbols = {{
1397885962,
1465934676,
1577324547}};

static struct $B77 mm_tables_isbooltag;
static i64 mm_type_countedfields;
static i64 mm_type_inassem;
static i64 mm_type_inidata;
static i64 mm_type_tpass_depth;
static i64 mm_type_setrecordsize_depth;
static i64 mm_type_tx_assign_nn;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B71 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B71 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B90 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B17 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B39 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B90 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B90 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B90 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B90 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B90 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B90 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B90 str;
	struct $B90 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B20 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L447;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L446;
L447:
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L449;
	asu64(R1) = p;
	free(asu64(R1));
	goto L448;
L449:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L448:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L454;
	goto L452;
L454:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L455:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L459;
L458:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L459:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L458;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L455;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L461:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L465;
	asi64(R1) = i;
	k = asi64(R1);
	goto L463;
L465:
	i += 1; if (i <= 27) goto L461;
L463:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L468;
L466:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L470;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L469;
L470:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L468;
L469:
	i += 1; if (i <= av_1) goto L466;
L468:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L452:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L473;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L471;
L473:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L475;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L471;
L475:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L477;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L471;
L477:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L471;
L471:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L480;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L480:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L482;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L482:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L478;
L478:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L485;
	asi64(R1) = n;
	goto L484;
L485:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L484:
	goto L483;
L483:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L486;
L486:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L489;
	R1 = 0;
	goto L487;
L489:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L492;
	R1 = 0;
	goto L490;
L492:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L490;
L490:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L495;
	R1 = 0;
	goto L493;
L495:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L493;
L493:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L498;
	asu64(R1) = p;
	goto L496;
L498:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L496;
L496:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L501;
	asu64(R1) = p;
	goto L499;
L501:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L499;
L499:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L503;
L503:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L505;
L505:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L510;
	R1 = 0;
	goto L508;
L510:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L512;
	R1 = 0;
	goto L508;
L512:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L508;
L508:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L515;
	R1 = 0;
	goto L513;
L515:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L513;
L513:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L518;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L516;
L518:
	R1 = 0;
	goto L516;
L516:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L521;
	asu64(R1) = mlinux_os_getstdin();
	handlex = asu64(R1);
L521:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L523;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L524:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L527;
L528:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L527:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L530;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L530:
	goto L524;
L523:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L532;
	goto L519;
L532:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L534;
	goto L519;
L534:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L536;
L535:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L540;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L539;
L540:
	R1 = 1;
	crseen = asu8(R1);
L539:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L536:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L535;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L535;
L541:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L543;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L543;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L543:
L519:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L547;
L545:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L545;
L547:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L551;
L549:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L549;
L551:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L554;
L553:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L553;
	asu64(R1) = s0;
	goto L552;
L552:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L558;
L557:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L557;
	asu64(R1) = s0;
	goto L556;
L556:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B17 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L562;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L563;
	goto L564;
L562:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L561;
L563:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L561;
L564:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L561:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L566;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L567;
	goto L568;
L566:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L567:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L568:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L565:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L560;
L560:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L571;
	R1 = tou64("");
	goto L569;
L571:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L573;
L572:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L576;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L578;
	asi64(R1) = period;
	if (!asi64(R1)) goto L580;
	R1 = tou64(".");
	goto L579;
L580:
	R1 = tou64("");
L579:
	goto L569;
L578:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L569;
L576:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L573:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L572;
	R1 = tou64("");
	goto L569;
L569:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L583;
L582:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L586;
	goto L587;
L586:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L581;
	goto L585;
L587:
L585:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L583:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L582;
	R1 = tou64("");
	goto L581;
L581:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L590;
	asu64(R1) = s;
	goto L588;
L590:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L588;
L588:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L593;
	R1 = tou64("");
	goto L591;
L593:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L595;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L595:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L597;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L597:
	asu64(R1) = f;
	goto L591;
L591:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L600;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L598;
L600:
	asu64(R1) = s;
	goto L598;
L598:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L603;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L601;
L603:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L601;
L601:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L613;
	R1 = 1;
	goto L611;
L613:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L611;
L611:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L616;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L616:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L618;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L614;
L618:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L620;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L620:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L614:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L624;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L624:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L633;
L633:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B91 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L636;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L639;
L637:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L637;
L639:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L636:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B91 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L643;
	goto L641;
L643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L646;
L644:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L644;
L646:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L641:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L649;
	goto L647;
L649:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L651;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L650;
L651:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L650:
L647:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L653:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L655;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L657;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L657:
	goto L654;
L655:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L659;
	R1 = 0;
	goto L652;
L659:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L661;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L663;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L663:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L661:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L665;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L652;
L665:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L667;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L669;
	R2 = 0;
	goto L668;
L669:
	R2 = 1;
L668:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L671;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L671:
	asu64(R1) = q;
	if (!asu64(R1)) goto L673;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L673:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L675;
	R1 = 5;
	goto L674;
L675:
	R1 = 1;
L674:
	goto L652;
L667:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L677;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L679;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L679;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L679:
	goto L676;
L677:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L681;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L680;
L681:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L683;
	R1 = 5;
	goto L682;
L683:
	R1 = 3;
L682:
	goto L652;
L680:
L676:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L685;
	R1 = 5;
	goto L684;
L685:
	R1 = 2;
L684:
	goto L652;
L652:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L687:
L688:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L692;
	goto L693;
L691:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L690;
L692:
	R1 = 0;
	goto L686;
	goto L690;
L693:
	goto L689;
L690:
	goto L688;
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L695;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L695;
	goto L696;
L695:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L697:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L699;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L700;
	goto L701;
L699:
	goto L687;
	goto L697;
L700:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L686;
	goto L697;
L701:
	goto L697;
	goto L694;
L696:
L694:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L703;
	goto L704;
L703:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L705:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L709;
	goto L710;
L708:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L707;
L709:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L712;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L712:
	goto L706;
	goto L707;
L710:
L707:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L705;
L706:
	goto L702;
L704:
	asu64(R1) = p;
	pstart = asu64(R1);
L713:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L717;
	goto L718;
L716:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L714;
	goto L715;
L717:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L714;
	goto L715;
L718:
L715:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L713;
L714:
L702:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L720;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L720:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L686;
L686:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L724;
L722:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L722;
L724:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L725;
L725:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L726;
L726:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L729;
	R1 = -1;
	goto L728;
L729:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L730;
	R1 = 1;
	goto L728;
L730:
	R1 = 0;
L728:
	goto L727;
L727:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L733;
	R1 = -1;
	goto L732;
L733:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L734;
	R1 = 1;
	goto L732;
L734:
	R1 = 0;
L732:
	goto L731;
L731:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L735;
L735:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L738;
	R1 = -1;
	goto L737;
L738:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L739;
	R1 = 1;
	goto L737;
L739:
	R1 = 0;
L737:
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L740;
L740:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L743;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L742;
L743:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L742:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L744;
L744:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L745;
L745:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L749;
	R1 = 0;
	goto L747;
L749:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L751:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L751;
	asr64(R1) = x;
	goto L750;
L750:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L754;
L754:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L755;
L755:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L759;
L757:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L761;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L756;
L761:
	i += 1; if (i <= av_1) goto L757;
L759:
	R1 = 0;
	goto L756;
L756:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L764;
	asi64(R1) = n;
	goto L762;
L764:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L762;
L762:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L767;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L767:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L769;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L769:
	asu64(R1) = p;
	goto L765;
L765:
	return asu64(R1);
}

static void mlinux_os_init() {
    u64 R1; 
	R1 = 1;
	mlinux_init_flag = asi64(R1);
	return;
}

static i64 mlinux_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1; 
	asu64(R1) = cmdline;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L771;
L771:
	return asi64(R1);
}

static i64 mlinux_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1; 
	asu64(R1) = cmdline;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L772;
L772:
	return asi64(R1);
}

static i64 mlinux_os_getch() {
    u64 R1, R2, R3; struct $B83 R1_B83; 
	struct $B83 old;
	struct $B83 new;
	u8 ch;
	R1 = (u64)&old;
	R2 = 0;
	asi32(R1) = tcgetattr(asi32(R2), asu64(R1));
	(R1_B83) = old;
	new = (R1_B83);
	R1 = -3;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = -9;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = -2;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = (u64)&new;
	R2 = 0;
	R3 = 0;
	asi32(R1) = tcsetattr(asi32(R3), asi32(R2), asu64(R1));
	asi32(R1) = getchar();
	ch = asu8(R1);
	R1 = (u64)&old;
	R2 = 0;
	R3 = 0;
	asi32(R1) = tcsetattr(asi32(R3), asi32(R2), asu64(R1));
	asu8(R1) = ch;
	R1 = toi64(tou8(R1));
	goto L773;
L773:
	return asi64(R1);
}

static i64 mlinux_os_kbhit() {
    u64 R1; 
	R1 = tou64("kbhit");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L774;
L774:
	return asi64(R1);
}

static void mlinux_os_flushkeys() {
    u64 R1; 
	R1 = tou64("flushkeys");
	mlib_abortprogram(asu64(R1));
	return;
}

static u64 mlinux_os_getconsolein() {
    u64 R1; 
	R1 = 0;
	goto L776;
L776:
	return asu64(R1);
}

static u64 mlinux_os_getconsoleout() {
    u64 R1; 
	R1 = 0;
	goto L777;
L777:
	return asu64(R1);
}

static u64 mlinux_os_proginstance() {
    u64 R1; 
	R1 = tou64("PROGINST");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L778;
L778:
	return asu64(R1);
}

static u64 mlinux_os_getdllinst(u64 name) {
    u64 R1, R2; 
	u64 h;
	R1 = 1;
	asu64(R2) = name;
	asu64(R1) = dlopen(asu64(R2), asi32(R1));
	h = asu64(R1);
	asu64(R1) = h;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L781;
	R1 = tou64("msvcrt");
	asu64(R2) = name;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L783;
	R1 = 1;
	R2 = tou64("libc.so.6");
	asu64(R1) = dlopen(asu64(R2), asi32(R1));
	h = asu64(R1);
L783:
L781:
	asu64(R1) = h;
	goto L779;
L779:
	return asu64(R1);
}

static u64 mlinux_os_getdllprocaddr(i64 hlib, u64 name) {
    u64 R1, R2; 
	u64 fnaddr;
	asi64(R1) = hlib;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L786;
	R1 = 0;
	goto L784;
L786:
	asu64(R1) = name;
	asi64(R2) = hlib;
	asu64(R1) = dlsym(asu64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	goto L784;
L784:
	return asu64(R1);
}

static void mlinux_os_initwindows() {
	return;
}

static i64 mlinux_os_getchx() {
    u64 R1; 
	R1 = tou64("getchx");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L788;
L788:
	return asi64(R1);
}

static u64 mlinux_os_getos() {
    u64 R1; 
	R1 = tou64("L64");
	goto L789;
L789:
	return asu64(R1);
}

static i64 mlinux_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L790;
L790:
	return asi64(R1);
}

static i64 mlinux_os_iswindows() {
    u64 R1; 
	R1 = 0;
	goto L791;
L791:
	return asi64(R1);
}

static i64 mlinux_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	R1 = tou64("SHELL EXEC");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L792;
L792:
	return asi64(R1);
}

static void mlinux_os_sleep(i64 a) {
	return;
}

static u64 mlinux_os_getstdin() {
    u64 R1; 
	u64 pf;
	R1 = (u64)&stdin;
	pf = asu64(R1);
	asu64(R1) = pf;
	asu64(R1) = *tou64p(R1);
	goto L794;
L794:
	return asu64(R1);
}

static u64 mlinux_os_getstdout() {
    u64 R1; 
	u64 pf;
	R1 = (u64)&stdout;
	pf = asu64(R1);
	asu64(R1) = pf;
	asu64(R1) = *tou64p(R1);
	goto L795;
L795:
	return asu64(R1);
}

static u64 mlinux_os_gethostname() {
    u64 R1; 
	R1 = tou64("");
	goto L796;
L796:
	return asu64(R1);
}

static u64 mlinux_os_getmpath() {
    u64 R1; 
	R1 = tou64("");
	goto L797;
L797:
	return asu64(R1);
}

static void mlinux_os_exitprocess(i64 x) {
    u64 R1; 
	R1 = 0;
	exit(R1);
	return;
}

static i64 mlinux_os_clock() {
    u64 R1, R2; 
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L801;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L800;
L801:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
L800:
	goto L799;
L799:
	return asi64(R1);
}

static i64 mlinux_os_ticks() {
    u64 R1; 
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L802;
L802:
	return asi64(R1);
}

static i64 mlinux_os_getclockspersec() {
    u64 R1; 
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L805;
	R1 = 1000;
	goto L804;
L805:
	R1 = 1000000;
L804:
	goto L803;
L803:
	return asi64(R1);
}

static void mlinux_os_setmesshandler(u64 addr) {
    u64 R1; 
	R1 = tou64("SETMESSHANDLER");
	mlib_abortprogram(asu64(R1));
	return;
}

static i64 mlinux_os_hpcounter() {
    u64 R1; 
	R1 = 1;
	goto L807;
L807:
	return asi64(R1);
}

static i64 mlinux_os_hpfrequency() {
    u64 R1; 
	R1 = 1;
	goto L808;
L808:
	return asi64(R1);
}

static i64 mlinux_os_filelastwritetime(u64 filename) {
    u64 R1; 
	R1 = 0;
	goto L809;
L809:
	return asi64(R1);
}

static void mlinux_os_getsystime(u64 tm) {
    u64 R1, R2, R3; 
	struct $B3 tv;
	struct $B25 tmr;
	R1 = 0;
	R2 = (u64)&tv;
	asi32(R1) = gettimeofday(asu64(R2), asu64(R1));
	R1 = (u64)&tmr;
	R2 = (u64)&tv;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = gmtime_r(asu64(R2), asu64(R1));
	R1 = (u64)&tmr;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1900;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tv;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = tm;
	R3 = 28;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = tm;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mlinux_os_peek() {
	return;
}

static u64 mlinux_os_allocexecmem(i64 n) {
    u64 R1; 
	R1 = tou64("No allocexec");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L812;
L812:
	return asu64(R1);
}

static i64 mlinux_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1; 
	R1 = 0;
	goto L813;
L813:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L816;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L815;
L816:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L815:
	goto L814;
L814:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L819;
	R4 = 0;
	goto L818;
L819:
	R4 = 73;
L818:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L817;
L817:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L824;
	case 1: goto L825;
	case 2: goto L826;
	case 3: goto L827;
	case 4: goto L828;
	case 5: goto L829;
	case 6: goto L830;
	case 7: goto L823;
	case 8: goto L831;
	case 9: goto L832;
	case 10: goto L833;
	case 11: goto L834;
	case 12: goto L835;
	default: goto L823;
    };
// SWITCH
L824:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F1)R1)();
	goto L820;
	goto L821;
L825:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F2)R2)(asi64(R1));
	goto L820;
	goto L821;
L826:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F3)R3)(asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L827:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F4)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L828:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F5)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L829:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F6)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L830:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F7)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L831:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F8)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L832:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F9)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L833:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F10)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L834:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F11)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L835:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F12)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L823:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L821:
	R1 = 0;
	goto L820;
L820:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L838;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L839;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L840;
	goto L841;
L838:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F13)R1)();
	R1 = toi64(asr64(R1));
	goto L836;
	goto L837;
L839:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F14)R2)(asi64(R1));
	x = asr64(R1);
	goto L837;
L840:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F15)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L837;
L841:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L837:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L836;
L836:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

static u64 pc_api_pcl_start(u64 name, i64 nunits) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_pcldone;
	if (!asu8(R1)) goto L845;
	R1 = tou64("PCL start?");
	pc_api_pclerror(asu64(R1));
L845:
	asu64(R1) = name;
	if (!asu64(R1)) goto L847;
	R1 = 9;
	asu64(R2) = name;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	pc_decls_currprog = asu64(R1);
L847:
	asi64(R1) = pc_api_initpcalloc;
	pc_api_pcalloc = asi64(R1);
	asi64(R1) = nunits;
	if (!asi64(R1)) goto L849;
	asi64(R1) = nunits;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nunits = asi64(R1);
	goto L851;
L850:
	R1 = 2;
	R2 = (u64)&pc_api_pcalloc;
	*toi64p(R2) *= asi64(R1);
L851:
	asi64(R1) = pc_api_pcalloc;
	asi64(R2) = nunits;
	if (asi64(R1) < asi64(R2)) goto L850;
L849:
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pc_api_pcstart = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	asi64(R2) = pc_api_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	R1 = 0;
	pc_api_pcfixed = asu8(R1);
	R1 = 0;
	pc_api_pcseqno = asi64(R1);
	R1 = 0;
	pc_api_pcneedfntable = asi64(R1);
	R1 = 0;
	pc_api_mlabelno = asi64(R1);
	asu64(R1) = pc_decls_currprog;
	goto L843;
L843:
	return asu64(R1);
}

static void pc_api_pcl_end() {
    u64 R1, R2; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) < asu64(R2)) goto L855;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L855;
	R1 = 0;
	R2 = 136;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L855:
	R1 = 1;
	pc_decls_pcldone = asu8(R1);
	return;
}

static u64 pc_api_pcl_writepcl(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writeallpcl();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L858;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L860;
	msysc_m$print_startcon();
	R1 = tou64("Writing PCL");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L860:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L857;
L858:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L857:
	goto L856;
L856:
	return asu64(R1);
}

static u64 pc_api_pcl_writepst(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_writepst();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L863;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L865;
	msysc_m$print_startcon();
	R1 = tou64("Writing PST");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L865:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L862;
L863:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L862:
	goto L861;
L861:
	return asu64(R1);
}

static void pc_api_pcl_genmcl() {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	return;
}

static void pc_api_pcl_genss(i64 obj) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_genss(asi64(R1));
	return;
}

static u64 pc_api_pcl_writess(u64 filename, i64 obj) {
    u64 R1, R2; 
	u64 ssstr;
	u64 f;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_genss(asi64(R1));
	asi64(R1) = obj;
	asi64(R1) = !asi64(R1);
	asu64(R1) = mc_writess_dummy_writessdata(asi64(R1));
	ssstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L870;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = ssstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = ssstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L869;
L870:
	asu64(R1) = ssstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L869:
	goto L868;
L868:
	return asu64(R1);
}

static u64 pc_api_pcl_writeasm(u64 filename, i64 atype) {
    u64 R1, R2; 
	u64 asmstr;
	u64 f;
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L873;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
L873:
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asu64(R1) = mc_writeasm_getassemstr();
	asmstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L875;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L877;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L877:
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = asmstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = asmstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L874;
L875:
	asu64(R1) = asmstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L874:
	goto L871;
L871:
	return asu64(R1);
}

static void pc_api_pcl_writeobj(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 1;
	mc_genss_genss(asi64(R1));
	R1 = 0;
	pc_api_phighmem = asu8(R1);
	msysc_m$print_startcon();
	R1 = tou64("PHIGHMEM=");
	msysc_m$print_str_nf(asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mlinux_os_clock();
	tt = asi64(R1);
	asu64(R1) = filename;
	mc_writeobj_writecoff(asu64(R1));
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_objtime = asi64(R1);
	return;
}

static void pc_api_pcl_writedll(u64 filename) {
    u64 R1, R2, R3; 
	i64 tt;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mlinux_os_clock();
	tt = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = filename;
	mc_writeexe_writeexe(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writeexe(u64 filename) {
    u64 R1, R2, R3; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mlinux_os_clock();
	tt = asi64(R1);
	R1 = 0;
	R2 = 0;
	asu64(R3) = filename;
	mc_writeexe_writeexe(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writemx(u64 filename) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asu64(R1) = filename;
	mx_write_writemcx(asu64(R1));
	return;
}

static void pc_api_pcl_exec() {
    u64 R1, R2; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	R2 = tou64("dummy");
	mx_run_runlibfile(asu64(R2), asi64(R1));
	return;
}

static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames) {
    u64 R1, R2; 
	asi64(R1) = highmem;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L885;
	asi64(R1) = highmem;
	pc_api_phighmem = asu8(R1);
L885:
	asi64(R1) = verbose;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L887;
	asi64(R1) = verbose;
	pc_decls_pverbose = asu8(R1);
L887:
	asi64(R1) = shortnames;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L889;
	asi64(R1) = shortnames;
	pc_api_fpshortnames = asu8(R1);
L889:
	return;
}

static void pc_api_extendpclblock() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	i64 lengthused;
	u64 newpcstart;
	asi64(R1) = pc_api_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	lengthused = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	asi64(R1) = lengthused;
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pc_api_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newpcalloc;
	asi64(R2) = lengthused;
	asi64(R1) -= asi64(R2);
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newpcstart;
	asi64(R3) = lengthused;
	R2 += (i64)R3*32;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = pc_api_pccurr;
	asu64(R3) = pc_api_pcstart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 32;
	R1 += (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	pc_api_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	pc_api_pcalloc = asi64(R1);
	return;
}

static u64 pc_api_newpcl() {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcend;
	if (asu64(R1) < asu64(R2)) goto L893;
	pc_api_extendpclblock();
L893:
	R1 = (u64)&pc_api_pccurr;
	(*tou64p(R1)) += 32;
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = pc_api_pccurr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc_api_pclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = pc_api_pccurr;
	goto L891;
L891:
	return asu64(R1);
}

static void pc_api_pc_gen(i64 opcode, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L896;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L896:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genx(i64 opcode, i64 x, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L900;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L900:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L903;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L903:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L906;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L906:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cond;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 pc_api_genint(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L907;
L907:
	return asu64(R1);
}

static u64 pc_api_genreal(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L910;
	R1 = 5;
	goto L909;
L910:
	R1 = 6;
L909:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L908;
L908:
	return asu64(R1);
}

static u64 pc_api_genrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L913;
	R1 = 10;
	goto L912;
L913:
	R1 = 11;
L912:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L911;
L911:
	return asu64(R1);
}

static u64 pc_api_genstring(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L914;
L914:
	return asu64(R1);
}

static u64 pc_api_genpcstrimm(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L915;
L915:
	return asu64(R1);
}

static u64 pc_api_genlabel(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L916;
L916:
	return asu64(R1);
}

static u64 pc_api_genmem(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L917;
L917:
	return asu64(R1);
}

static u64 pc_api_genmemaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L918;
L918:
	return asu64(R1);
}

static u64 pc_api_gendata(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 12;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L919;
L919:
	return asu64(R1);
}

static void pc_api_gencomment(u64 s) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L923;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L922;
L923:
	goto L920;
L922:
	asu64(R1) = s;
	asu64(R1) = pc_api_genpcstrimm(asu64(R1));
	R2 = 135;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L920:
	return;
}

static u64 pc_api_genname(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L924;
L924:
	return asu64(R1);
}

static u64 pc_api_gennameaddr(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L925;
L925:
	return asu64(R1);
}

static u64 pc_api_genassem(u64 code) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = code;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 9;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L926;
L926:
	return asu64(R1);
}

static u64 pc_api_strpmode(i64 mode, i64 size) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L929;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L930;
	goto L931;
L929:
	R1 = tou64("mem:");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = size;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_strpmode_str;
	goto L928;
L930:
	R1 = tou64("---");
	goto L928;
L931:
	R1 = (u64)&pc_tables_pstdnames;
	asi64(R2) = mode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L928:
	goto L927;
L927:
	return asu64(R1);
}

static void pc_api_pc_setmode(i64 m, i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L934;
	asi64(R1) = size;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L933;
L934:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L933:
	R1 = (u64)&pc_tables_pclhastype;
	asu64(R2) = pc_api_pccurr;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L936;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L936:
	return;
}

static void pc_api_pc_setmode2(i64 m) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void pc_api_pc_setxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setscaleoff(i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = scale;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_addoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	return;
}

static void pc_api_pc_setincr(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnargs(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnvariadics(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setalign(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_perror(u64 mess) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = mess;
	pc_api_perror_s(asu64(R2), asu64(R1));
	return;
}

static void pc_api_perror_s(u64 mess, u64 param) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = param;
	if (!asu64(R1)) goto L949;
	msysc_m$print_startcon();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L949:
	R1 = 1;
	exit(R1);
	return;
}

static u64 pc_api_getbasename(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L952;
L951:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L952:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) <= asu64(R2)) goto L954;
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L951;
L954:
	asu64(R1) = t;
	goto L950;
L950:
	return asu64(R1);
}

static void pc_api_pclerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addsymbol(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_psymboltable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L958;
	asu64(R1) = d;
	R2 = R1;
	pc_decls_psymboltablex = asu64(R2);
	pc_decls_psymboltable = asu64(R1);
	goto L957;
L958:
	asu64(R1) = d;
	asu64(R2) = pc_decls_psymboltablex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	pc_decls_psymboltablex = asu64(R1);
L957:
	return;
}

static u64 pc_api_pc_makesymbol(u64 s, i64 id) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = id;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L961;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L962;
	goto L963;
L961:
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L960;
L962:
	R1 = 1;
	asu64(R2) = d;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	id = asi64(R1);
	goto L960;
L963:
L960:
	asi64(R1) = id;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L966;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L965;
L966:
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L964;
L965:
	asi64(R1) = id;
	if (!asi64(R1)) goto L967;
	asu64(R1) = d;
	pc_api_pc_addsymbol(asu64(R1));
L967:
L964:
	asu64(R1) = d;
	goto L959;
L959:
	return asu64(R1);
}

static u64 pc_api_getfullname(u64 d, i64 backtick) {
    u64 R1, R2, R3; 
	i64 n;
	u64 e;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	R2 = (u64)&pc_api_getfullname_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L970;
	R1 = tou64("`");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L970:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L972;
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L974;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L973;
L974:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L973:
	R1 = (u64)&pc_api_getfullname_str;
	goto L968;
L972:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L977;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L976;
L977:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_getfullname_str;
	goto L968;
L976:
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L979;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L978;
L979:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L978:
	goto L968;
L968:
	return asu64(R1);
}

static void pc_api_pcerrorstop(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addplib(u64 name) {
    u64 R1, R2, R3; 
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L983;
	R1 = tou64("Too many libs");
	pc_api_perror(asu64(R1));
L983:
	R1 = tou64("");
	asu64(R2) = name;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&pc_decls_plibfiles;
	R3 = (u64)&pc_decls_nplibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L986;
	R1 = tou64("Nested proc");
	pc_api_pclerror(asu64(R1));
L986:
	asu64(R1) = d;
	asu64(R1) = pc_api_genmem(asu64(R1));
	asi64(R2) = threaded;
	if (!asi64(R2)) goto L988;
	R2 = 121;
	goto L987;
L988:
	R2 = 120;
L987:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L990;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L990:
	R1 = 0;
	asi64(R2) = mode;
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L992;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl proc:");
	asu64(R1) = pc_api_addstr(asu64(R2), asu64(R1));
	pc_api_pclerror(asu64(R1));
L992:
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L994;
	asi64(R1) = isentry;
	if (!asi64(R1)) goto L994;
	asu64(R1) = d;
	pc_decls_entryproc = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 83;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L994:
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_setimport(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_addparam(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L998;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L998:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1000;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L999;
L1000:
	goto L1002;
L1001:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1002:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1001;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L999:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1005;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1005:
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	return;
}

static void pc_api_pc_addlocal(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1008;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1008:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1010;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1009;
L1010:
	goto L1012;
L1011:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1012:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1011;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1009:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1015;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1015:
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	return;
}

static void pc_api_pc_endproc() {
    u64 R1, R2; 
	asu64(R1) = pc_decls_currfunc;
	if (asu64(R1)) goto L1018;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1018:
	R1 = 0;
	R2 = 122;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_decls_currfunc = asu64(R1);
	return;
}

static u64 pc_api_addstr(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = t;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_addstr_str;
	goto L1019;
L1019:
	return asu64(R1);
}

static void pc_api_merror(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1022;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F16)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L1021;
L1022:
	R1 = 0;
	lineno = asi64(R1);
	R1 = tou64("?");
	filename = asu64(R1);
L1021:
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1024;
	msysc_m$print_startcon();
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1024:
	msysc_m$print_startcon();
	R1 = tou64("MCL Error: # (#) on Line: # in #, PCL:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pc_decls_ppseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	asu64(R2) = filename;
	pc_api_pcerrorstop(asu64(R2), asi64(R1));
	return;
}

static u64 pc_api_pc_duplpst(u64 d) {
    u64 R1, R2, R3; struct $B21 R1_B21; 
	u64 e;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	(R1_B21) = *(struct $B21*)(R1);
	asu64(R2) = e;
	*(struct $B21*)(R2) = (R1_B21);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = e;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L1025;
L1025:
	return asu64(R1);
}

static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip) {
    u64 R1; 
	asi64(R1) = cmdskip;
	pc_decls_pcmdskip = asi64(R1);
	return;
}

static i64 pc_api_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	asu64(R1) = t;
	t0 = asu64(R1);
	goto L1029;
L1028:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1032;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1033;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1034;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1035;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1036;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1037;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1037;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1037;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1037;
	goto L1038;
L1032:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1031;
L1033:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1031;
L1034:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1031;
L1035:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1031;
L1036:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1031;
L1037:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1031;
L1038:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1040;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1040;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1039;
L1040:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 120;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2h");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1039:
L1031:
L1029:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L1028;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1027;
L1027:
	return asi64(R1);
}

static void pc_diags_strpcl(u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	i64 opcode;
	i64 n;
	i64 x;
	i64 y;
	u64 d;
	u64 e;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asi64(R1) = opcode;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1043;
	R2 = 128;
	if (asi64(R1) == asi64(R2)) goto L1044;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1045;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1046;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1046;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1047;
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L1048;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1049;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1050;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1050;
	goto L1051;
L1043:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	pc_diags_strlabel(asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1053;
	R1 = tou64(" NOT USED");
	pc_diags_psstr(asu64(R1));
L1053:
	goto L1041;
	goto L1042;
L1044:
	R1 = tou64("! ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
	goto L1041;
	goto L1042;
L1045:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L1055;
	R1 = tou64("!");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	goto L1054;
L1055:
	R1 = tou64("! - - -");
	pc_diags_psstr(asu64(R1));
L1054:
	goto L1041;
	goto L1042;
L1046:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = opcode;
	R2 = 121;
	if (asi64(R1) != asi64(R2)) goto L1057;
	R1 = tou64("tcproc");
	pc_diags_psstr(asu64(R1));
	goto L1056;
L1057:
	R1 = tou64("proc");
	pc_diags_psstr(asu64(R1));
L1056:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	pc_diags_psname(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1059;
	R1 = tou64("::");
	goto L1058;
L1059:
	R1 = tou64(":");
L1058:
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1061;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1061:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1065;
L1062:
	R1 = tou64("    param    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1065:
	asu64(R1) = e;
	if (asu64(R1)) goto L1062;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1069;
L1066:
	R1 = tou64("    local    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = e;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("       ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1069:
	asu64(R1) = e;
	if (asu64(R1)) goto L1066;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1071;
	R1 = tou64("    rettype  ");
	pc_diags_psstr(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
L1071:
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1073;
	R1 = tou64("    variadic");
	pc_diags_psstrline(asu64(R1));
L1073:
	goto L1041;
	goto L1042;
L1047:
	R1 = tou64("endproc");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	goto L1041;
	goto L1042;
L1048:
	R1 = tou64("endprog");
	pc_diags_psstr(asu64(R1));
	goto L1041;
	goto L1042;
L1049:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1075;
	asu64(R1) = p;
	pc_diags_psdata(asu64(R1));
	goto L1041;
L1075:
	goto L1042;
L1050:
	goto L1076;
	goto L1042;
L1051:
L1042:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
// pc_diags.strpcl.skiptab:
L1076:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1078;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L1079;
	goto L1080;
L1078:
	R1 = tou64("jump");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1077;
L1079:
	R1 = tou64("set");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1077;
L1080:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L1077:
	R1 = 32;
	R2 = 9;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1082;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pclhastype;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1084;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1084:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1082:
	R1 = 32;
	R2 = 4;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_pclextra;
	asi64(R2) = opcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L1086;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	x = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L1089;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1088;
L1089:
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1088:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1091;
	asi64(R1) = y;
	if (!asi64(R1)) goto L1091;
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = y;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1091:
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1086:
	R1 = 32;
	R2 = 5;
	R3 = (u64)&str;
	asu64(R4) = pc_diags_dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1093;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = p;
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	pc_diags_psstr(asu64(R1));
L1093:
	R1 = 40;
	pc_diags_pstabto(asi64(R1));
L1041:
	return;
}

static u64 pc_diags_stropnd(u64 p) {
    u64 R1, R2, R3; 
	i64 length;
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1096;
	R1 = tou64("");
	goto L1094;
L1096:
	R1 = 0;
	R2 = (u64)&pc_diags_stropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1098;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1099;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1099;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1099;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1099;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1100;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1101;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1102;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1103;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1104;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1105;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1106;
	goto L1107;
L1098:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1094;
	goto L1097;
L1099:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L1109;
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("infinity");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L1108;
L1109:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e16.16");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L1108:
	goto L1097;
L1100:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	length = asi64(R2);
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L1111;
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&pc_diags_stropnd_str;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1110;
L1111:
	asu64(R1) = pc_diags_stropnd_longstring;
	if (!asu64(R1)) goto L1113;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_diags_stropnd_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1113:
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	pc_api_longstringlen = asi64(R1);
	asi64(R1) = pc_api_longstringlen;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_diags_stropnd_longstring = asu64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
	length = asi64(R1);
	R1 = 34;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = pc_diags_stropnd_longstring;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3+2)) = asu8(R1);
	asu64(R1) = pc_diags_stropnd_longstring;
	goto L1094;
L1110:
	goto L1097;
L1101:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1116;
	R2 = 124;
	if (asi64(R1) != asi64(R2)) goto L1115;
L1116:
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1118;
	R1 = tou64(":");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1118:
L1115:
	goto L1097;
L1102:
	R1 = tou64("&");
	R2 = (u64)&pc_diags_stropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L1101;
	goto L1097;
L1103:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L1097;
L1104:
	R1 = tou64("");
	goto L1094;
	goto L1097;
L1105:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	goto L1094;
	goto L1097;
L1106:
	R1 = (u64)&pc_diags_stropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<Data * # (#)>");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L1097;
L1107:
	msysc_m$print_startcon();
	R1 = tou64("---------");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<PCLOPND?>");
	goto L1094;
L1097:
	R1 = (u64)&pc_diags_stropnd_str;
	goto L1094;
L1094:
	return asu64(R1);
}

static u64 pc_diags_strpclstr(u64 p, i64 buffsize) {
    u64 R1, R2; 
	asu64(R1) = pc_diags_dest;
	mlib_gs_free(asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	pc_diags_destlinestart = asi64(R1);
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	R1 = 0;
	asu64(R2) = pc_diags_dest;
	mlib_gs_char(asu64(R2), asi64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = buffsize;
	if (asi64(R1) < asi64(R2)) goto L1121;
	R1 = tou64("<BIGSTR>");
	goto L1119;
L1121:
	asu64(R1) = pc_diags_dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1119;
L1119:
	return asu64(R1);
}

static void pc_diags_writepcl(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	pc_diags_strpcl(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1124;
	goto L1125;
L1124:
	goto L1123;
L1125:
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
L1123:
	return;
}

static u64 pc_diags_writeallpcl() {
    u64 R1, R2; 
	u64 p;
	u64 d;
	i64 i;
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = tou64("!PROC PCL");
	asu64(R2) = pc_diags_dest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1129;
L1127:
	R1 = tou64("addlib    \"");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc_diags_psstr(asu64(R1));
	R1 = tou64("\"");
	pc_diags_psstr(asu64(R1));
	pc_diags_psline();
	i += 1; if (i <= pc_decls_nplibfiles) goto L1127;
L1129:
	asi64(R1) = pc_decls_nplibfiles;
	if (!asi64(R1)) goto L1131;
	pc_diags_psline();
L1131:
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1135;
L1132:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1137;
	R1 = tou64("extproc    ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1139;
	R1 = tou64(" 1");
	pc_diags_psstr(asu64(R1));
L1139:
	pc_diags_psline();
L1137:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1135:
	asu64(R1) = d;
	if (asu64(R1)) goto L1132;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1141;
L1140:
	asu64(R1) = p;
	pc_diags_writepcl(asu64(R1));
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pc_diags_destlinestart = asi64(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1141:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1140;
	pc_diags_psline();
	asu64(R1) = pc_api_longstring;
	if (!asu64(R1)) goto L1144;
	asi64(R1) = pc_api_longstringlen;
	asu64(R2) = pc_api_longstring;
	mlib_pcm_free(asu64(R2), asi64(R1));
L1144:
	asu64(R1) = pc_diags_dest;
	goto L1126;
L1126:
	return asu64(R1);
}

static void pc_diags_psstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psstrline(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = pc_diags_dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void pc_diags_psline() {
    u64 R1, R2; 
	R1 = tou64("\n");
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psint(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_psname(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_diags_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void pc_diags_pstabto(i64 n) {
    u64 R1, R2; 
	i64 col;
	asu64(R1) = pc_diags_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = pc_diags_destlinestart;
	asi64(R1) -= asi64(R2);
	col = asi64(R1);
	goto L1152;
L1151:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&col;
	(*toi64p(R1)) += 1;
L1152:
	asi64(R1) = n;
	asi64(R2) = col;
	if (asi64(R1) > asi64(R2)) goto L1151;
	return;
}

static void pc_diags_strlabel(i64 labelno, i64 colon) {
    u64 R1; 
	R1 = tou64("#");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = labelno;
	pc_diags_psint(asi64(R1));
	asi64(R1) = colon;
	if (!asi64(R1)) goto L1156;
	R1 = tou64(":");
	pc_diags_psstr(asu64(R1));
L1156:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	return;
}

static void pc_diags_psopnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	pc_diags_psstr(asu64(R1));
	return;
}

static void pc_diags_psdata(u64 p) {
    u64 R1, R2; 
	i64 n;
	i64 m;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1160;
	goto L1158;
L1160:
	goto L1162;
L1161:
	asi64(R1) = n;
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L1165;
	R1 = 20;
	m = asi64(R1);
L1165:
	asi64(R1) = m;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = tou64("    data mem:");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	pc_diags_psint(asi64(R1));
	R1 = tou64("  ");
	pc_diags_psstr(asu64(R1));
	asi64(R1) = m;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L1167;
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
L1167:
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1170;
L1168:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L1168;
L1170:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1172;
	pc_diags_psline();
L1172:
L1162:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1161;
L1158:
	return;
}

static u64 pc_diags_writepst() {
    u64 R1, R2; 
	u8 localfile;
	i64 i;
	i64 j;
	u64 d;
	u64 e;
	R1 = 0;
	localfile = asu8(R1);
	R1 = 0;
	i = asi64(R1);
	asu64(R1) = pc_diags_dest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("PROC PC Symbol table");
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1177;
L1174:
	R1 = tou64("H");
	asu64(R2) = d;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("25jl");
	asu64(R2) = d;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1180;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1179;
L1180:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1184;
L1181:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1184:
	asu64(R1) = e;
	if (asu64(R1)) goto L1181;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	j = asi64(R1);
	goto L1188;
L1185:
	R1 = tou64("    ");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("21jl");
	asu64(R2) = e;
	pc_diags_writepsymbol(asu64(R2), asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1188:
	asu64(R1) = e;
	if (asu64(R1)) goto L1185;
L1179:
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1177:
	asu64(R1) = d;
	if (asu64(R1)) goto L1174;
	pc_diags_psline();
	asu64(R1) = pc_diags_dest;
	goto L1173;
L1173:
	return asu64(R1);
}

static void pc_diags_writepsymbol(u64 d, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u8 localfile;
	struct $B16 str;
	i64 av_1;
	R1 = 0;
	localfile = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("4");
	asu64(R2) = d;
	R3 = 120;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = (u64)&pc_tables_idnames;
	asu64(R2) = d;
	R3 = 72;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	R1 = 8;
	R2 = (u64)&pc_tables_idnames;
	asu64(R3) = d;
	R4 = 72;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1192;
L1190:
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	if (--asi64(av_1)) goto L1190;
L1192:
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmt;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1194;
	R1 = tou64(" Pm:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" Loc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	pc_diags_psint(asi64(R1));
L1194:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1196;
	R1 = tou64(" Exp");
	pc_diags_psstr(asu64(R1));
L1196:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1198;
	R1 = tou64(" Imp");
	pc_diags_psstr(asu64(R1));
L1198:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1200;
	R1 = tou64(" Var:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	pc_diags_psint(asi64(R1));
L1200:
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1202;
	R1 = tou64(" TC");
	pc_diags_psstr(asu64(R1));
L1202:
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1204;
	R1 = tou64(" Dot");
	pc_diags_psstr(asu64(R1));
L1204:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1206;
	R1 = tou64(" ENTRY PT");
	pc_diags_psstr(asu64(R1));
L1206:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1208;
	R1 = tou64(" .PCADDR =");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
L1208:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1210;
	R1 = tou64(" (");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_diags_psint(asi64(R1));
	R1 = tou64(" ");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1210:
	R1 = 0;
	if (!asu16(R1)) goto L1212;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1212;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1212;
	R1 = tou64(" (Proc:");
	pc_diags_psstr(asu64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(") (D:");
	pc_diags_psstr(asu64(R1));
	R1 = tou64("H");
	asu64(R2) = d;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	pc_diags_psstr(asu64(R1));
	R1 = tou64(")");
	pc_diags_psstr(asu64(R1));
L1212:
	R1 = 0;
	if (!asu16(R1)) goto L1214;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1214;
	asu64(R1) = d;
	R2 = 104;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1214;
	R1 = tou64(" Has statics");
	pc_diags_psstr(asu64(R1));
L1214:
	pc_diags_psline();
	return;
}

static void pc_diags_showprocinfo(u64 d) {
    u64 R1, R2; 
	struct $B16 str;
	u64 p;
	u64 e;
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1217;
	goto L1215;
L1217:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("PROC INFO FOR: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Params:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Locals:   #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Leaf:     #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Nmaxargs: #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Assem:    #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  MCLdone:  #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Hasblocks:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	pc_diags_psline();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1221;
L1218:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Pm: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1221:
	asu64(R1) = e;
	if (asu64(R1)) goto L1218;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L1225;
L1222:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("  Loc: # used:#, addrof:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	pc_diags_psstrline(asu64(R1));
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1225:
	asu64(R1) = e;
	if (asu64(R1)) goto L1222;
	pc_diags_psline();
L1215:
	return;
}

static void pc_reduce_pcl_reducetest() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 nn;
	i64 seqno;
	i64 lab;
	i64 lab2;
	i64 nargs;
	u64 pc;
	u64 newpc;
	u64 pcnext;
	u64 pcnext2;
	u64 pcproc;
	u64 labelmap;
	u64 pdef;
	struct $B21 callstack;
	i64 ncall;
	i64 nprocs;
	i64 nleaf;
	i64 nallparams;
	i64 nalllocals;
	i64 offset;
	i64 av_1;
	R1 = 0;
	nprocs = asi64(R1);
	R1 = 0;
	nleaf = asi64(R1);
	R1 = 0;
	nallparams = asi64(R1);
	R1 = 0;
	nalllocals = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nn = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	goto L1230;
L1227:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1232;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1233;
	goto L1234;
L1232:
	goto L1231;
L1233:
	asu64(R1) = pc_api_icheckasmlabel;
	if (!asu64(R1)) goto L1236;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_icheckasmlabel;
	asi64(R1) = ((F17)R2)(asu64(R1));
	lab = asi64(R1);
	asi64(R1) = lab;
	if (!asi64(R1)) goto L1238;
	asu64(R1) = labelmap;
	asi64(R2) = lab;
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1238:
L1236:
	goto L1231;
L1234:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1240;
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1240:
L1231:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1230:
	asu64(R1) = pc;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1227;
// pc_reduce.pcl_reducetest.skip:
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	newpc = asu64(R1);
	R1 = 0;
	seqno = asi64(R1);
	asi64(R1) = nn;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1244;
L1242:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcnext = asu64(R1);
	R1 = (u64)&pc_tables_pclargs;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	nargs = asi64(R2);
	if (!asi64(R1)) goto L1246;
	asi64(R1) = nargs;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L1248;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	nargs = asi64(R1);
L1248:
	asu64(R1) = pc_decls_pinfo;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = nargs;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1246:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1250;
	asu64(R1) = pc_decls_pinfo;
	if (!asu64(R1)) goto L1250;
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1250;
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1250:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1252;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1253;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1254;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1254;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L1255;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L1255;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1255;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1255;
	R2 = 131;
	if (asi64(R1) == asi64(R2)) goto L1256;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1257;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1258;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1259;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1259;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L1260;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L1261;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1262;
	goto L1263;
L1252:
	goto L1251;
L1253:
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu16(R1) = *tou16p(((i64)R1+(i64)R2*2-2));
	if (!asu16(R1)) goto L1265;
	goto L1263;
	goto L1263;
L1265:
	goto L1251;
L1254:
	R1 = (u64)&nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdef = asu64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pdef;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	asu64(R2) = pdef;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&nallparams;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&nalllocals;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	ncall = asi64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcproc = asu64(R1);
	goto L1263;
	goto L1263;
	goto L1251;
L1255:
	R1 = 0;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&ncall;
	(*toi64p(R1)) -=1;
	goto L1263;
	goto L1263;
	goto L1251;
L1256:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = newpc;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = (u64)&callstack;
	R3 = (u64)&ncall;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1251;
L1257:
	asu64(R1) = pc_decls_pinfo;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1267;
	R1 = (u64)&nleaf;
	(*toi64p(R1)) += 1;
L1267:
	R1 = 0;
	pc_decls_pinfo = asu64(R1);
	goto L1263;
	goto L1263;
	goto L1251;
L1258:
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1263;
	goto L1263;
	goto L1251;
L1259:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1269;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1269;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = newpc;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1271;
	R1 = 3;
	goto L1270;
L1271:
	R1 = 6;
L1270:
	asu64(R2) = newpc;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1268;
L1269:
	goto L1263;
	goto L1263;
L1268:
	goto L1251;
L1260:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) != asi64(R2)) goto L1273;
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L1273;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1272;
L1273:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1275;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1274;
L1275:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1272;
L1274:
	goto L1263;
	goto L1263;
L1272:
	goto L1251;
L1261:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1278;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1278;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1277;
L1278:
	asu64(R1) = newpc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) != asi64(R2)) goto L1277;
	goto L1276;
L1277:
	goto L1263;
	goto L1263;
L1276:
	goto L1251;
L1262:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1280;
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = newpc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1281;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1281;
	R1 = 1;
	goto L1282;
L1281:
	R1 = 0;
L1282:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L1280;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pcnext;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = pcnext;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = newpc;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1279;
L1280:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1283;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1279;
L1283:
	goto L1263;
	goto L1263;
L1279:
	goto L1251;
L1263:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = newpc;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1285;
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1288;
	asu64(R1) = newpc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1287;
L1288:
	R1 = 1;
	asu64(R2) = newpc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1287:
L1285:
L1251:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	if (--asi64(av_1)) goto L1242;
L1244:
	asu64(R1) = newpc;
	pc_api_pccurr = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 stack;
	u64 pc;
	i64 sp;
	i64 fp;
	i64 a;
	u64 ptr;
	i64 b;
	u64 ptrb;
	i64 n;
	u64 d;
	struct $B52 callstack;
	struct $B92 callstackst;
	i64 callsp;
	struct $B16 str;
	i64 mag;
	i64 oldsp;
	i64 ncmd;
	u64 cmd;
	i64 lastpos;
	i64 count;
	i64 av_1;
	i64 av_2;
	asu64(R1) = pcentry;
	pc = asu64(R1);
	R1 = 0;
	sp = asi64(R1);
	R1 = 0;
	fp = asi64(R1);
	R1 = 0;
	callsp = asi64(R1);
	R1 = 560000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	stack = asu64(R1);
	asi64(R1) = cmain;
	if (!asi64(R1)) goto L1291;
	asi64(R1) = msysc_ncmdparams;
	ncmd = asi64(R1);
	asu64(R1) = msysc_cmdparams;
	cmd = asu64(R1);
	asi64(R1) = ncmd;
	asi64(R2) = pc_decls_pcmdskip;
	asi64(R1) -= asi64(R2);
	ncmd = asi64(R1);
	asu64(R1) = cmd;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	cmd = asu64(R1);
	asu64(R1) = cmd;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1291:
	R1 = 0;
	lastpos = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1293;
	R1 = tou64("<Fn ptr>");
	R2 = (u64)&pc_run_emptyst;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1293:
L1294:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L1298;
	case 1: goto L1299;
	case 2: goto L1302;
	case 3: goto L1303;
	case 4: goto L1304;
	case 5: goto L1311;
	case 6: goto L1312;
	case 7: goto L1297;
	case 8: case 9: goto L1313;
	case 10: goto L1314;
	case 11: goto L1315;
	case 12: goto L1316;
	case 13: goto L1318;
	case 14: goto L1319;
	case 15: goto L1320;
	case 16: goto L1321;
	case 17: goto L1324;
	case 18: case 21: goto L1325;
	case 19: goto L1350;
	case 20: goto L1340;
	case 22: goto L1358;
	case 23: goto L1345;
	case 24: goto L1363;
	case 25: goto L1364;
	case 26: goto L1365;
	case 27: goto L1373;
	case 28: goto L1376;
	case 29: goto L1379;
	case 30: goto L1380;
	case 31: goto L1381;
	case 32: goto L1388;
	case 33: goto L1389;
	case 34: goto L1392;
	case 35: goto L1395;
	case 36: goto L1398;
	case 37: case 38: goto L1401;
	case 39: goto L1404;
	case 40: goto L1405;
	case 41: goto L1406;
	case 42: goto L1407;
	case 43: goto L1408;
	case 44: goto L1411;
	case 45: goto L1414;
	case 46: goto L1417;
	case 47: goto L1418;
	case 48: goto L1421;
	case 49: goto L1424;
	case 50: goto L1425;
	case 51: goto L1426;
	case 52: goto L1427;
	case 53: goto L1428;
	case 54: goto L1429;
	case 55: goto L1432;
	case 56: goto L1436;
	case 57: goto L1440;
	case 58: goto L1441;
	case 59: goto L1442;
	case 60: goto L1443;
	case 61: goto L1446;
	case 62: goto L1449;
	case 63: goto L1450;
	case 64: goto L1451;
	case 65: goto L1452;
	case 66: goto L1453;
	case 67: goto L1456;
	case 68: goto L1457;
	case 69: goto L1458;
	case 70: goto L1459;
	case 71: goto L1460;
	case 72: goto L1461;
	case 73: goto L1462;
	case 74: goto L1463;
	case 75: goto L1464;
	case 76: goto L1465;
	case 77: goto L1466;
	case 78: goto L1467;
	case 79: goto L1468;
	case 80: goto L1469;
	case 81: goto L1470;
	case 82: goto L1471;
	case 83: goto L1474;
	case 84: goto L1475;
	case 85: goto L1476;
	case 86: goto L1477;
	case 87: goto L1478;
	case 88: goto L1479;
	case 89: goto L1480;
	case 90: goto L1481;
	case 91: goto L1484;
	case 92: goto L1487;
	case 93: case 94: goto L1490;
	case 95: goto L1493;
	case 96: goto L1494;
	case 97: goto L1495;
	case 98: goto L1496;
	case 99: goto L1497;
	case 100: goto L1498;
	case 101: goto L1501;
	case 102: goto L1505;
	case 103: goto L1509;
	case 104: goto L1510;
	case 105: goto L1511;
	case 106: goto L1512;
	case 107: goto L1513;
	case 108: goto L1514;
	case 109: goto L1515;
	case 110: goto L1516;
	case 111: goto L1517;
	case 112: goto L1520;
	case 113: goto L1521;
	case 114: goto L1522;
	case 115: goto L1523;
	case 116: goto L1524;
	case 117: goto L1525;
	case 118: goto L1526;
	case 119: goto L1527;
	case 120: goto L1528;
	case 121: goto L1534;
	case 122: goto L1535;
	case 123: goto L1536;
	case 124: goto L1537;
	case 125: goto L1538;
	case 126: goto L1549;
	case 127: goto L1539;
	case 128: goto L1540;
	case 129: goto L1541;
	case 130: goto L1542;
	case 131: goto L1543;
	case 132: goto L1544;
	case 133: goto L1545;
	case 134: goto L1546;
	case 135: goto L1547;
	case 136: goto L1548;
	default: goto L1297;
    };
// SWITCH
L1298:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1299:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1301;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1300;
L1301:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1300:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1302:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1303:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1304:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1306;
	goto L1307;
L1306:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1309;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1308;
L1309:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1310;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1310;
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	goto L1308;
L1310:
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	R1 += (i64)R2*8-8;
	ptr = asu64(R1);
L1308:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1305;
L1307:
	asu64(R1) = pc;
	pc_runaux_pcusopnd(asu64(R1));
L1305:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1311:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1312:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1313:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1314:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asi64(R2) -= asi64(R3);
	R1 += (i64)R2*8-8;
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R4) = pc;
	R5 = 20;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) -= asi64(R4);
	R2 += (i64)R3*8-8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1315:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1316:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1318:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1319:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1320:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-24));
	asi64(R1) = pc_runaux_pci_loadbf(asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1321:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-24));
	if (!asi64(R1)) goto L1323;
	R1 = 1;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L1322;
L1323:
	R1 = 0;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L1322:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1324:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-24));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-32));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-16));
	asi64(R4) = a;
	asi64(R1) = pc_runaux_pci_storebf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1325:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1327;
	asi64(R1) = callsp;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1330;
L1328:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L1328;
L1330:
	msysc_m$print_startcon();
	R1 = tou64("# Call:   # # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_run_seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	asi64(R1) = pc_run_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1327:
	asi64(R1) = sp;
	R2 = 69900;
	if (asi64(R1) <= asi64(R2)) goto L1332;
	R1 = tou64("");
	R2 = tou64("Stack overflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1332:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1334;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	R5 = 0;
	asu64(R6) = d;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L1336;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1335;
L1336:
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1335:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1333;
L1334:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1337;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Proc not defined:");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1333;
L1337:
	asi64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 21;
	if (asi64(R2) != asi64(R3)) goto L1339;
	R2 = 1;
	goto L1338;
L1339:
	R2 = 0;
L1338:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	asu64(R1) = d;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L1333:
	goto L1294;
L1340:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1342;
	R1 = tou64("");
	R2 = tou64("retp/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1342:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1344;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETP/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1344:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1294;
L1345:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1347;
	R1 = tou64("");
	R2 = tou64("ref/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1347:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1349;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETF/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1349:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1294;
L1350:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1352;
	R1 = tou64("");
	R2 = tou64("ICALLP NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1352:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1354;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1354;
// pc_run.dispatch_loop.icallp:
L1355:
	asi64(R1) = sp;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 22;
	if (asi64(R2) != asi64(R3)) goto L1357;
	R2 = 1;
	goto L1356;
L1357:
	R2 = 0;
L1356:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&pc_run_emptyst;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = ptr;
	pc = asu64(R1);
	goto L1353;
L1354:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1353:
	goto L1294;
L1358:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1360;
	R1 = tou64("");
	R2 = tou64("ICALLF NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1360:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1362;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1362;
	goto L1355;
	goto L1361;
L1362:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1361:
	goto L1294;
L1363:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1294;
L1364:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1294;
L1365:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1367;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpreal(asi64(R3), asr64(R2), asr64(R1));
	n = asi64(R1);
	goto L1366;
L1367:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1368;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1366;
L1368:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1366:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1370;
	asi64(R1) = n;
	if (asi64(R1)) goto L1370;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1369;
L1370:
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
L1369:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1372;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1371;
L1372:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1371:
	goto L1294;
L1373:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L1375;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1374;
L1375:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1374:
	goto L1294;
L1376:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1378;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1377;
L1378:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1377:
	goto L1294;
L1379:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1294;
L1380:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1381:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1383;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1384;
	goto L1385;
L1383:
	R1 = tou64("");
	R2 = tou64("setcc/r64");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1382;
L1384:
	R1 = tou64("");
	R2 = tou64("setcc/r32");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1382;
L1385:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1387;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1386;
L1387:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1386:
L1382:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1388:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L1289;
	goto L1294;
L1389:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	(*toi64p(R1)) -=1;
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L1391;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1390;
L1391:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1390:
	goto L1294;
L1392:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L1394;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1393;
L1394:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1393:
	goto L1294;
L1395:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L1397;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1396;
L1397:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1396:
	goto L1294;
L1398:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1400;
	R1 = tou64("");
	R2 = tou64("swap/block");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1400:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptrb = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptrb;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	b = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = b;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptrb;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1401:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) < asi64(R2)) goto L1403;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) > asi64(R2)) goto L1403;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2*32;
	asi64(R2) = a;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 -= (i64)R2*32;
	pc = asu64(R1);
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1402;
L1403:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
L1402:
	goto L1294;
L1404:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1405:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1406:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = 0;
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1407:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1408:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1410;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) += asr64(R1);
	goto L1409;
L1410:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) += asi64(R1);
L1409:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1411:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1413;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) -= asr64(R1);
	goto L1412;
L1413:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) -= asi64(R1);
L1412:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1414:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1416;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) *= asr64(R1);
	goto L1415;
L1416:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) *= asi64(R1);
L1415:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1417:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) /= asr64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1418:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1420;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1419;
L1420:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1419:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1421:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1423;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) %= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1422;
L1423:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) %= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1422:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1424:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1425:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1426:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) |= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1427:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) ^= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1428:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) <<= asu64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1429:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1431;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) >>= asi64(R1);
	goto L1430;
L1431:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) >>= asu64(R1);
L1430:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1432:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1434;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Min(*tor64p(R2), asr64(R1));
	goto L1433;
L1434:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1435;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1433;
L1435:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1433:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1436:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1438;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Max(*tor64p(R2), asr64(R1));
	goto L1437;
L1438:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1439;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1437;
L1439:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1437:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1440:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1441:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1442:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1443:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1445;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1444;
L1445:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1444:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1446:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1448;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1447;
L1448:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1447:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1449:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = ~asu64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1450:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) ^= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1451:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !!asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1452:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1453:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1455;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	*tor64p(R2) *= asr64(R1);
	goto L1454;
L1455:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) *= asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1454:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1456:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = sqrt(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1457:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1458:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1459:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1460:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1461:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1462:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1463:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1464:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1465:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1466:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1467:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1468:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1469:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1470:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1471:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1473;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) = pow(asr64(R1), asr64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	goto L1472;
L1473:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
L1472:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1474:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1475:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1476:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1477:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1478:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1479:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1480:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1481:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1483;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) += asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1482;
L1483:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) += asi64(R1);
L1482:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1484:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1486;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) -= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1485;
L1486:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) -= asi64(R1);
L1485:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1487:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1489;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) *= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1488;
L1489:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) *= asi64(R1);
L1488:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1490:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1492;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) /= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1491;
L1492:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	a = asi64(R1);
L1491:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1493:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) %= asi64(R2);
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1494:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1495:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) |= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1496:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) ^= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1497:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1498:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1500;
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) >>= asi64(R1);
	goto L1499;
L1500:
	asu64(R1) = b;
	R2 = (u64)&a;
	*tou64p(R2) >>= asu64(R1);
L1499:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1501:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1503;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Min(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1502;
L1503:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1504;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1502;
L1504:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1502:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1505:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1507;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Max(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1506;
L1507:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1508;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1506;
L1508:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1506:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1509:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1510:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) -= asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1511:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1512:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1513:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1514:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1515:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1516:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1517:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1519;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1518;
L1519:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asu64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
L1518:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1520:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	R1 = toi64(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1521:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1522:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1523:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1524:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1525:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1526:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1527:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1528:
	asi64(R1) = fp;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = sp;
	fp = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1530;
	asi64(R1) = callsp;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1533;
L1531:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_2)) goto L1531;
L1533:
	msysc_m$print_startcon();
	R1 = tou64("# Enter:  # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = pc_run_seqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = fp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1530:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1534:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1535:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1536:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1537:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1538:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1539:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1540:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1541:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = ptr;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = sp;
	asu64(R2) = ptr;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = fp;
	asu64(R2) = ptr;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1542:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	pc = asu64(R1);
	asu64(R1) = ptr;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	sp = asi64(R1);
	asu64(R1) = ptr;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	fp = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1294;
L1543:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1544:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1545:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1546:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1547:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1548:
	goto L1317;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1294;
L1549:
	goto L1294;
L1297:
// pc_run.dispatch_loop.unimpl:
L1317:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("GETOPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Unimpl: # at seq: #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	goto L1294;
	R1 = 0;
	goto L1289;
L1289:
	return asi64(R1);
}

static void pc_run_fixuppcl() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 d;
	u64 e;
	u64 dproc;
	u64 pdata;
	i64 parambytes;
	i64 framebytes;
	i64 paramslots;
	i64 localslots;
	u64 a;
	asi64(R1) = pc_api_mlabelno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_run_labeltable = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1554;
L1551:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1556;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1556;
	goto L1557;
L1556:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1555;
L1557:
L1555:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1554:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1551;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1561;
L1558:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1563;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1563;
	goto L1564;
L1563:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1562;
L1564:
L1562:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1561:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1558;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1568;
L1565:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1570;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1570;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1571;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1572;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1573;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1574;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1574;
	goto L1575;
L1570:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdata = asu64(R1);
	goto L1569;
L1571:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1577;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1579;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1580;
	goto L1581;
L1579:
	R1 = tou64("");
	R2 = tou64("FIX/DATA/MEM");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1578;
L1580:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1583;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1584;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1585;
	goto L1586;
L1583:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1582;
L1584:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1582;
L1585:
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asu64(R1);
	goto L1582;
L1586:
	R1 = tou64("");
	R2 = tou64("data &mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1582:
	asu64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1588;
	R1 = tou64("");
	R2 = tou64("data &mem = nil");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1588:
	goto L1578;
L1581:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L1578:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = (u64)&a;
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1576;
L1577:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1576:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pdata;
	*tou64p(R2) += asu64(R1);
	goto L1569;
L1572:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	dproc = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	parambytes = asi64(R1);
	goto L1592;
L1589:
	R1 = 8;
	R2 = (u64)&parambytes;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1592:
	asu64(R1) = e;
	if (asu64(R1)) goto L1589;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	framebytes = asi64(R1);
	goto L1596;
L1593:
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 8;
	asu64(R2) = e;
	R3 = 84;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&framebytes;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1596:
	asu64(R1) = e;
	if (asu64(R1)) goto L1593;
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	paramslots = asi64(R2);
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	localslots = asi64(R2);
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1569;
L1573:
	asu64(R1) = p;
	asu64(R2) = pc_run_labeltable;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1569;
L1574:
	asi64(R1) = paramslots;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = localslots;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1569;
L1575:
L1569:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1568:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1565;
	return;
}

static void pc_run_pcl_runpcl() {
    u64 R1, R2, R3; 
	i64 stopcode;
	pc_runaux_loadlibs();
	pc_run_fixuppcl();
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1599;
	R1 = tou64("");
	R2 = tou64("No 'main' entry point");
	asu64(R3) = pc_api_pcstart;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1599:
	pc_runaux_docmdskip();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1601;
	msysc_m$print_startcon();
	R1 = tou64("Run PCL:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1601:
	asu64(R1) = pc_decls_entryproc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = pc_decls_entryproc;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_run_dispatch_loop(asu64(R2), asi64(R1));
	stopcode = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1603;
	msysc_m$print_startcon();
	R1 = tou64("Stopped");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = stopcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L1603:
	asi64(R1) = stopcode;
	exit(R1);
	return;
}

static i64 pc_run_getlineno(u64 pc) {
    u64 R1, R2, R3, R4; 
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1606;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asu64(R3) = pc;
	R4 = 24;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F16)R4)(asi64(R3), asu64(R2), asu64(R1));
	goto L1605;
L1606:
	R1 = 0;
L1605:
	goto L1604;
L1604:
	return asi64(R1);
}

static i64 pc_runaux_pci_getopnd(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	i64 a;
	u64 d;
	u64 ptr;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1609;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1610;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1611;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1612;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1613;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1613;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1614;
	goto L1615;
L1609:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1608;
L1610:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1617;
	goto L1618;
L1617:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1616;
L1618:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	ptr = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1620;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1620;
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	ptr = asu64(R1);
L1620:
L1616:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	goto L1608;
L1611:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1622;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1623;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1624;
	goto L1625;
L1622:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	goto L1621;
L1623:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1627;
	asi64(R1) = a;
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	a = asi64(R1);
L1627:
	goto L1621;
L1624:
	asu64(R1) = d;
	asi64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asi64(R1);
	goto L1621;
L1625:
	asu64(R1) = d;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
L1621:
	goto L1608;
L1612:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1608;
L1613:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1608;
L1614:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	goto L1608;
L1615:
	asu64(R1) = p;
	pc_runaux_pcusopnd(asu64(R1));
L1608:
	asi64(R1) = a;
	goto L1607;
L1607:
	return asi64(R1);
}

static i64 pc_runaux_pci_loadptr(u64 p, i64 mode) {
    u64 R1, R2; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1630;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1630:
	asi64(R1) = mode;
	switch (asi64(R1)) {
	case 1: goto L1636;
	case 2: goto L1635;
	case 3: goto L1644;
	case 4: goto L1643;
	case 5: goto L1642;
	case 6: goto L1641;
	case 7: goto L1640;
	case 8: goto L1639;
	case 9: goto L1638;
	case 10: goto L1637;
	case 11: goto L1634;
	default: goto L1633;
    };
// SWITCH
L1634:
	asu64(R1) = p;
	goto L1631;
L1635:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1631;
L1636:
	asu64(R1) = p;
	asr32(R1) = *tor32p(R1);
    asr64(R1) = tor64(asr32(R1));
	x = asr64(R1);
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L1631;
L1637:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1631;
L1638:
	asu64(R1) = p;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	goto L1631;
L1639:
	asu64(R1) = p;
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	goto L1631;
L1640:
	asu64(R1) = p;
	asi8(R1) = *toi8p(R1);
	R1 = toi64(toi8(R1));
	goto L1631;
L1641:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1631;
L1642:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	goto L1631;
L1643:
	asu64(R1) = p;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	goto L1631;
L1644:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L1631;
L1633:
	R1 = 0;
L1631:
	goto L1628;
L1628:
	return asi64(R1);
}

static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size) {
    u64 R1, R2, R3; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1647;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1647:
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1649;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1650;
	goto L1651;
L1649:
	asi64(R1) = size;
	asi64(R2) = a;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1648;
L1650:
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	x = asr64(R1);
	asr64(R1) = x;
    asr32(R1) = tor32(asr64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L1648;
L1651:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1653;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1654;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1655;
	goto L1656;
L1653:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L1652;
L1654:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L1652;
L1655:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	goto L1652;
L1656:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi8p(R2) = asi8(R1);
L1652:
L1648:
	return;
}

static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1659;
	R1 = tou64("");
	R2 = tou64("Not mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1659:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1661;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1660;
L1661:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
L1660:
	goto L1657;
L1657:
	return asu64(R1);
}

static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("PC Exec error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("seq:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	if (!asu64(R2)) goto L1664;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	goto L1663;
L1664:
	R2 = 0;
L1663:
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_runaux_pcusopnd(u64 p) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("Unsupported operand:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode) {
    u64 R1, R2, R3, R4, R5; 
	struct $B93 args;
	i64 retval;
	i64 i;
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1668;
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	fnaddr = asu64(R1);
L1668:
	asi64(R1) = nargs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1671;
L1669:
	asu64(R1) = revargs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = i;
	asi64(R3) -= asi64(R4);
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	i += -1; if (i >= 1) goto L1669;
L1671:
	R1 = 0;
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = retmode;
	R5 = 1;
	if (asi64(R4) == asi64(R5)) goto L1674;
	R5 = 2;
	if (asi64(R4) != asi64(R5)) goto L1673;
L1674:
	R4 = 82;
	goto L1672;
L1673:
	R4 = 73;
L1672:
	asu64(R5) = fnaddr;
	asi64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	retval = asi64(R1);
	asi64(R1) = retval;
	goto L1666;
L1666:
	return asi64(R1);
}

static u64 pc_runaux_getdllfnptr(u64 d) {
    u64 R1, R2, R3; 
	u64 fnaddr;
	i64 libindex;
	u64 dllinst;
	u64 procname;
	u64 libname;
	i64 i;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1677;
	asu64(R1) = fnaddr;
	goto L1675;
L1677:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	procname = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1681;
L1678:
	asu64(R1) = procname;
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlinux_os_getdllprocaddr(asi64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1683;
	goto L1680;
L1683:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1678;
L1681:
	asu64(R1) = procname;
	R2 = tou64("Can't find DLL func:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1680:
	asu64(R1) = fnaddr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fnaddr;
	goto L1675;
L1675:
	return asu64(R1);
}

static void pc_runaux_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1687;
L1685:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mlinux_os_getdllinst(asu64(R1));
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc_decls_plibinst;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L1689;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't load lib:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1689:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1685;
L1687:
	return;
}

static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1692;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1693;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1694;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1695;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1696;
	goto L1697;
L1692:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  ==  asr64(R2);
	goto L1691;
L1693:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  !=  asr64(R2);
	goto L1691;
L1694:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <  asr64(R2);
	goto L1691;
L1695:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <=  asr64(R2);
	goto L1691;
L1696:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >=  asr64(R2);
	goto L1691;
L1697:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >  asr64(R2);
L1691:
	goto L1690;
L1690:
	return asi64(R1);
}

static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1700;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1701;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1702;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1703;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1704;
	goto L1705;
L1700:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1699;
L1701:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L1699;
L1702:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	goto L1699;
L1703:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L1699;
L1704:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	goto L1699;
L1705:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
L1699:
	goto L1698;
L1698:
	return asi64(R1);
}

static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1708;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1709;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1710;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1711;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1712;
	goto L1713;
L1708:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  ==  asu64(R2);
	goto L1707;
L1709:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	goto L1707;
L1710:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	goto L1707;
L1711:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	goto L1707;
L1712:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	goto L1707;
L1713:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >  asu64(R2);
L1707:
	goto L1706;
L1706:
	return asi64(R1);
}

static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1716;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1717;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1718;
	goto L1719;
L1716:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou64p(R2) += asu64(R1);
	goto L1715;
L1717:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou32p(R2) += asu32(R1);
	goto L1715;
L1718:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou16p(R2) += asu16(R1);
	goto L1715;
L1719:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou8p(R2) += asu8(R1);
L1715:
	return;
}

static void pc_runaux_docmdskip() {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1724;
L1721:
	R1 = tou64("$cmdskip");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1726;
	asi64(R1) = pc_decls_pcmdskip;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) = asu8(R1);
	goto L1723;
L1726:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1724:
	asu64(R1) = d;
	if (asu64(R1)) goto L1721;
L1723:
	return;
}

static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j) {
    u64 R1, R2; 
	u64 mask;
	i64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1729;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1729:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	R1 = -1;
	asi64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	asu64(R2) = i;
	asu64(R1) >>= asu64(R2);
	goto L1727;
L1727:
	return asu64(R1);
}

static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x) {
    u64 R1, R2; 
	u64 mask;
	u64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1732;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1732:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asu64(R1) += asu64(R2);
	n = asu64(R1);
	R1 = -1;
	asu64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = x;
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	x = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R2) = ~asu64(R2);
	asu64(R1) &= asu64(R2);
	asu64(R2) = x;
	asu64(R1) |= asu64(R2);
	goto L1730;
L1730:
	return asu64(R1);
}

static void mc_genmcl_genmcl(u64 dummy) {
    u64 R1, R2, R3; 
	i64 tt;
	i64 i;
	asu8(R1) = pc_decls_mcldone;
	if (!asu8(R1)) goto L1735;
	goto L1733;
L1735:
	R1 = 0;
	if (asu16(R1)) goto L1738;
	R1 = 0;
	if (!asu16(R1)) goto L1737;
L1738:
	msysc_m$print_startcon();
	R1 = tou64("********* ASM HAS PCL INFO *********");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1737:
	asi64(R1) = mlinux_os_clock();
	tt = asi64(R1);
	mc_genmcl_inithandlers();
	R1 = 0;
	mc_libmcl_mclinit(asi64(R1));
	asu64(R1) = pc_api_pcstart;
	mc_decls_currpcl = asu64(R1);
	R1 = 0;
	i = asi64(R1);
L1739:
	asu64(R1) = mc_decls_currpcl;
	mc_genmcl_convertpcl(asu64(R1));
	R1 = 0;
	if (!asu16(R1)) goto L1743;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1743;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1743;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1743;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1743;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1743;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1743;
	mc_stackmcl_showopndstack();
L1743:
	R1 = (u64)&mc_decls_currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = mc_decls_currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1744;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) != asi64(R2)) goto L1739;
L1744:
	mc_auxmcl_genrealtable();
	mc_auxmcl_genabsneg();
	mc_auxmcl_genstringtable();
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L1746;
	mc_optim_peephole();
L1746:
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
L1733:
	return;
}

static void mc_genmcl_convertpcl(u64 p) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 oldregset;
	i64 reg;
	i64 i;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	mc_decls_pmode = asu8(R1);
	asu64(R1) = p;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pc_decls_ppseqno = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	((F18)R2)(asu64(R1));
	(R1_B3) = mc_decls_regset;
	oldregset = (R1_B3);
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1750;
L1748:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L1752;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1754;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1753;
L1754:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1753:
L1752:
	i += 1; if (i <= mc_decls_noperands) goto L1748;
L1750:
	R1 = (u64)&oldregset;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 48;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	R1 = (u64)&oldregset;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 56;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	return;
}

static void mc_genmcl_inithandlers() {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	i64 n;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	i64 k;
// PROC LOCAL STATICS GO HERE
	static u8 mc_genmcl_inithandlers_initdone = 0;
	static struct $B3 mc_genmcl_inithandlers_dupltable = {{
1303249015287398465,
	3485556719402710647    }};
	asu8(R1) = mc_genmcl_inithandlers_initdone;
	if (!asu8(R1)) goto L1757;
	goto L1755;
L1757:
	asi64(R1) = $nprocs;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1760;
L1758:
	R1 = (u64)&$procname;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 3;
	R2 = tou64("px_");
	asu64(R3) = name;
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L1762;
	R1 = 0;
	k = asi64(R1);
	R1 = 142;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1766;
L1763:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	s = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) != asu64(R2)) goto L1768;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L1768:
	asu64(R1) = name;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1770;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L1765;
L1770:
	k += 1; if (k <= av_1) goto L1763;
L1766:
	asu64(R1) = name;
	R2 = tou64("Invalid handler name:");
	pc_api_merror(asu64(R2), asu64(R1));
L1765:
L1762:
	i += 1; if (i <= n) goto L1758;
L1760:
	R1 = 1;
	i = asi64(R1);
	R1 = 8;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1773;
L1771:
	R1 = (u64)&mc_genmcl_px_handlertable;
	R2 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R3) = i;
	R2 += (i64)R3*2-2;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	R3 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R4) = i;
	R3 += (i64)R4*2-2;
	R4 = 1;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L1771;
L1773:
	R1 = 0;
	i = asi64(R1);
	R1 = 142;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1776;
L1774:
	R1 = (u64)&mc_genmcl_px_handlertable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (asu64(R1)) goto L1778;
	R1 = (u64)&mc_genmcl_unimpl;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L1778:
	i += 1; if (i <= av_3) goto L1774;
L1776:
	R1 = 1;
	mc_genmcl_inithandlers_initdone = asu8(R1);
L1755:
	return;
}

static void mc_genmcl_doshowpcl(u64 p) {
    u64 R1, R2; 
	struct $B94 str;
	goto L1779;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1781;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1781;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1781;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1781;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1781;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1781;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1781;
	goto L1782;
L1781:
	goto L1780;
L1782:
	R1 = tou64("                       ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1256;
	asu64(R2) = p;
	asu64(R1) = pc_diags_strpclstr(asu64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
L1780:
L1779:
	return;
}

static void mc_genmcl_unimpl(u64 p) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Unimpl: # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_nop(u64 p) {
	return;
}

static void mc_genmcl_px_dupl(u64 p) {
	mc_stackmcl_duplpcl();
	return;
}

static void mc_genmcl_px_double(u64 p) {
    u64 R1, R2; 
	asi64(R1) = mc_decls_ncalldepth;
	if (!asi64(R1)) goto L1788;
	mc_stackmcl_duplpcl();
	goto L1787;
L1788:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L1787:
	return;
}

static void mc_genmcl_px_opnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_type(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_comment(u64 p) {
	return;
}

static void mc_genmcl_px_proc(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_currfunc = asu64(R1);
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 1;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	mc_auxmcl_initproc(asu64(R1));
	R1 = tou64("?>>");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mclprocentry = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1794;
	asu64(R1) = pc_decls_currfunc;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1794;
	mc_auxmcl_fixmain();
L1794:
	return;
}

static void mc_genmcl_px_endproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1797;
	msysc_m$print_startcon();
	R1 = tou64("PCL STACK NOT EMPTY");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PCL STACK NOT EMPTY");
	mc_libmcl_mgencomment(asu64(R1));
L1797:
	R1 = 0;
	R2 = 0;
	R3 = 2;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endprog(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_istatic(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_zstatic(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_data(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 opc;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1803;
	asu64(R1) = p;
	mc_auxmcl_do_blockdata(asu64(R1));
	goto L1801;
L1803:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1805;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1806;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1807;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1808;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1809;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1810;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1811;
	goto L1812;
L1805:
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1804;
L1806:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1804;
L1807:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1804;
L1808:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1804;
L1809:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1804;
L1810:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1804;
L1811:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1804;
L1812:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("db/dq optype? #");
	pc_api_merror(asu64(R2), asu64(R1));
L1804:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1814;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1815;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1816;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1817;
	goto L1818;
L1814:
	R1 = 116;
	opc = asi64(R1);
	goto L1813;
L1815:
	R1 = 117;
	opc = asi64(R1);
	goto L1813;
L1816:
	R1 = 118;
	opc = asi64(R1);
	goto L1813;
L1817:
	R1 = 119;
	opc = asi64(R1);
	goto L1813;
L1818:
	msysc_m$print_startcon();
	R1 = tou64("P.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STRPMODE(P.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("DATA/not 1248");
	pc_api_merror(asu64(R2), asu64(R1));
L1813:
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1801:
	return;
}

static void mc_genmcl_px_label(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_load(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_stackmcl_pushpcl(asu64(R1));
	return;
}

static void mc_genmcl_px_store(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1823;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1822;
L1823:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L1822:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_add(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1826;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1828;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1828;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 52;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1827;
L1828:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1827:
	goto L1825;
L1826:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 65;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1825:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_sub(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1831;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1833;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1833;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1832;
L1833:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1832:
	goto L1830;
L1831:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 67;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1830:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_mul(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	i64 x;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1836;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1838;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1837;
L1838:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1837:
	goto L1835;
L1836:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 69;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1835:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_div(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 71;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_eval(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_widen(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1843;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1843;
	R1 = 0;
	R2 = 5;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1845;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1845:
	goto L1842;
L1843:
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = (u64)&pc_tables_psigned;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	if (!asu8(R3)) goto L1847;
	R3 = 18;
	goto L1846;
L1847:
	R3 = 19;
L1846:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1842:
	return;
}

static void mc_genmcl_px_jump(u64 p) {
    u64 R1, R2, R3; 
	i64 labno;
	u64 q;
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	goto L1850;
L1849:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
L1850:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1849;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1853;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1854;
	goto L1855;
L1853:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1857;
	goto L1848;
L1857:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) != asi64(R2)) goto L1859;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1859;
	goto L1848;
L1859:
	goto L1852;
L1854:
	R1 = 0;
	asu64(R2) = q;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1852;
L1855:
L1852:
	R1 = 0;
	asi64(R2) = labno;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1848:
	return;
}

static void mc_genmcl_px_ijump(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_neg(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1863;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1862;
L1863:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
L1862:
	return;
}

static void mc_genmcl_px_abs(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 lx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1866;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1865;
L1866:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L1865:
	return;
}

static void mc_genmcl_px_bitnot(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_not(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 cx;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1871;
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = cx;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1873;
	R3 = 5;
	goto L1872;
L1873:
	R3 = 4;
L1872:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1870;
L1871:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1875;
	R3 = 5;
	goto L1874;
L1875:
	R3 = 4;
L1874:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-3)) = asu8(R1);
L1870:
	return;
}

static void mc_genmcl_px_sqr(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1878;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1877;
L1878:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 69;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1877:
	return;
}

static void mc_genmcl_px_sqrt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 63;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_jumpcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 mcond;
	u64 ax;
	u64 bx;
	u64 lx;
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	lx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1882;
	R1 = tou64("");
	R2 = tou64("JUMPCC/BLOCK");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1881;
L1882:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1884;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1886;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1886;
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1887;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1886;
L1887:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1885;
L1886:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1889;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
L1889:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1885:
	goto L1883;
L1884:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1883:
	R1 = 0;
	asu64(R2) = lx;
	asi64(R3) = mcond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1891;
	mc_stackmcl_poppcl();
L1891:
L1881:
	return;
}

static void mc_genmcl_px_jumpt(u64 p) {
    u64 R1, R2; 
	R1 = 5;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_jumpf(u64 p) {
    u64 R1, R2; 
	R1 = 4;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitand(u64 p) {
    u64 R1, R2; 
	R1 = 38;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitor(u64 p) {
    u64 R1, R2; 
	R1 = 39;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxor(u64 p) {
    u64 R1, R2; 
	R1 = 40;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shl(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shr(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1900;
	R1 = 44;
	goto L1899;
L1900:
	R1 = 45;
L1899:
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_retproc(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mclprocentry;
	asu64(R2) = mc_decls_mccodex;
	if (asu64(R1) != asu64(R2)) goto L1903;
	R1 = tou64("---");
	mc_libmcl_mgencomment(asu64(R1));
L1903:
	asu64(R1) = p;
	mc_auxmcl_do_procentry(asu64(R1));
	mc_auxmcl_do_procexit();
	return;
}

static void mc_genmcl_px_retfn(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1906;
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 6;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1906:
	asu64(R1) = p;
	mc_genmcl_px_retproc(asu64(R1));
	return;
}

static void mc_genmcl_px_setcall(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	asi64(R1) = mc_decls_ncalldepth;
	R2 = 16;
	if (asi64(R1) < asi64(R2)) goto L1909;
	R1 = tou64("");
	R2 = tou64("Too many nested calls");
	pc_api_merror(asu64(R2), asu64(R1));
L1909:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1911;
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1910;
L1911:
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asi64(R2) = mc_decls_mstackdepth;
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1910:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callblocksize;
	asi64(R3) = mc_decls_ncalldepth;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1913;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
L1913:
	return;
}

static void mc_genmcl_px_setarg(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L1916;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1918;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 0;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
L1918:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	mc_stackmcl_pushopnd(asi64(R2), asi64(R1));
	goto L1915;
L1916:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1919;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*16-16;
	asi64(R3) = n;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
L1919:
L1915:
	return;
}

static void mc_genmcl_px_callp(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 nargs;
	i64 nregargs;
	i64 slots;
	i64 isptr;
	i64 shadow;
	i64 blockret;
	i64 av_1;
	R1 = 0;
	isptr = asi64(R1);
	R1 = 0;
	shadow = asi64(R1);
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	nargs = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nregargs = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1923;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L1922;
L1923:
	R1 = 1;
	isptr = asi64(R1);
L1922:
	asi64(R1) = isptr;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = nregargs;
	mc_auxmcl_do_pushlowargs(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1925;
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L1927;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	goto L1926;
L1927:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L1926:
	goto L1924;
L1925:
	asi64(R1) = nargs;
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	slots = asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
L1924:
	asi64(R1) = isptr;
	if (!asi64(R1)) goto L1929;
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L1928;
L1929:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1928:
	asi64(R1) = nregargs;
	asi64(R2) = blockret;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1932;
L1930:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L1930;
L1932:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L1934;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L1934:
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1936;
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
L1936:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mc_genmcl_px_jumpret(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1939;
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1941;
	R1 = 1;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
L1941:
L1939:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_jumpretm(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	i64 reg;
	i64 av_1;
	i64 av_2;
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1945;
L1943:
	R1 = 0;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1943;
L1945:
	R1 = 1;
	reg = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1948;
L1946:
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1950;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1950;
	R1 = 11;
	reg = asi64(R1);
L1950:
	asi64(R1) = reg;
	mc_stackmcl_movetoreg(asi64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	if (--asi64(av_2)) goto L1946;
L1948:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_startmx(u64 p) {
    u64 R1; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	return;
}

static void mc_genmcl_px_resetmx(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L1954;
	mc_stackmcl_poppcl();
L1954:
	return;
}

static void mc_genmcl_px_stop(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 11;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = tou64("exit*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_incrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_incrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadincr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loaddecr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_forup(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 14;
	R2 = 28;
	R3 = 52;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fordown(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 13;
	R2 = 29;
	R3 = 53;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_iload(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 px;
	u64 nextpcl;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1966;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1968;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L1967;
L1968:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L1967:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L1970;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L1969;
L1970:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1969:
	goto L1965;
L1966:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
L1965:
	return;
}

static i64 mc_genmcl_getsharereg(u64 ax, i64 mode) {
    u64 R1, R2; 
	u8 reg;
	u8 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	reg = asu8(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	regix = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1973;
	R1 = 0;
	goto L1971;
L1973:
	asu8(R1) = reg;
	if (!asu8(R1)) goto L1975;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = reg;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1976;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L1975;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L1975;
L1976:
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	goto L1971;
	goto L1974;
L1975:
	asu8(R1) = regix;
	if (!asu8(R1)) goto L1977;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = regix;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1978;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L1977;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L1977;
L1978:
	asu8(R1) = regix;
	R1 = toi64(tou8(R1));
	goto L1971;
L1977:
L1974:
	R1 = 0;
	goto L1971;
L1971:
	return asi64(R1);
}

static void mc_genmcl_px_iloadx(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 z;
	u64 nextpcl;
	u64 ax;
	u64 bx;
	u64 px;
	u64 fx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1981;
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1980;
L1981:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L1983;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L1982;
L1983:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1982:
L1980:
	return;
}

static void mc_genmcl_px_istore(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 bx;
	u64 px;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1986;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L1985;
L1986:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L1985:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1988;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1987;
L1988:
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1987:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_istorex(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 px;
	u64 z;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1991;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	cx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = cx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1990;
L1991:
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1990:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_storem(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 z;
	u64 dblock;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1994;
	R1 = tou64("");
	R2 = tou64("Storem not 16");
	pc_api_merror(asu64(R2), asu64(R1));
L1994:
	R1 = 16;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	R2 = 0;
	R3 = 8;
	asu64(R4) = px;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = px;
	R2 = 6;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_addpx(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 cx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	cx = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subpx(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 scale;
	i64 extra;
	i64 offset;
	u64 ax;
	u64 bx;
	u64 z;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1998;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R3) = extra;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1997;
L1998:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = scale;
	asu64(R2) = bx;
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2000;
	asi64(R1) = scale;
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
L2000:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = extra;
	if (!asi64(R1)) goto L2002;
	msysc_m$print_startcon();
	R1 = tou64("EXTRA=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = extra;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUBREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L2002:
L1997:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_to(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 ax;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	q = asu64(R1);
	R1 = 6;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_iswap(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 qx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	qx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2006;
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qx;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = qx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2005;
L2006:
	R1 = tou64("");
	R2 = tou64("swap/block");
	pc_api_merror(asu64(R2), asu64(R1));
L2005:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swapstk(u64 p) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_noperands;
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_labeldef(u64 p) {
    u64 R1, R2; 
	struct $B5 str;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(":");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_addto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 65;
	R2 = 28;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 67;
	R2 = 29;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_multo(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 cx;
	u64 x;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2013;
	R1 = 69;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2011;
L2013:
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2015;
	R1 = tou64("");
	R2 = tou64("multo/byte");
	pc_api_merror(asu64(R2), asu64(R1));
L2015:
	R1 = 0;
	R2 = 10;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	x = asu64(R2);
	if (!asu64(R1)) goto L2017;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = cx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L2016;
L2017:
	asu64(R1) = bx;
	asu64(R2) = cx;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2016:
	asu64(R1) = cx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2011:
	return;
}

static void mc_genmcl_px_bitandto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 38;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 39;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 40;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shlto(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shrto(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2024;
	R1 = 44;
	goto L2023;
L2024:
	R1 = 45;
L2023:
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fix(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 fx;
	u64 ax;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&pc_tables_pmin;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = fx;
	asu64(R2) = ax;
	R3 = 84;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_float(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 fx;
	i64 lab;
	i64 lab2;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2028;
	R1 = tou64("");
	R2 = tou64("float/short");
	pc_api_merror(asu64(R2), asu64(R1));
L2028:
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2030;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 86;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2029;
L2030:
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L2031;
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab2 = asi64(R1);
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 12;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab2;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	asi64(R1) = mc_decls_labmask63;
	if (asi64(R1)) goto L2033;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_labmask63 = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_laboffset64 = asi64(R1);
L2033:
	asi64(R1) = mc_decls_labmask63;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_laboffset64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = fx;
	R3 = 66;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab2;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
// mc_genmcl.px_float.reduce:
L2034:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2036;
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2036:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2029;
L2031:
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2034;
L2029:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_idiv(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_irem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_idivrem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 2;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_clear(u64 p) {
    u64 R1, R2; 
	u64 ax;
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = ax;
	mc_auxmcl_clearblock(asu64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 n;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2043;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L2045;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2044;
L2045:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUB/REF NOT POWER OF xx");
	pc_api_merror(asu64(R2), asu64(R1));
L2044:
L2043:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_switch(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 elselab;
	i64 reg;
	u64 ax;
	u64 bx;
	u64 ax2;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = mc_decls_currpcl;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	elselab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L2048;
	asu64(R1) = ax;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	ax2 = asu64(R3);
	R3 = 18;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax2;
	ax = asu64(R1);
L2048:
	asi64(R1) = minlab;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2050;
	R1 = 10;
	asi64(R2) = minlab;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2050:
	R1 = 10;
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = elselab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 3;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2052;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	R1 = 6;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2051;
L2052:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2051:
	mc_stackmcl_poppcl();
	R1 = 1;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_switchu(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 reg;
	u64 ax;
	u64 bx;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2055;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2054;
L2055:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2054:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swlabel(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endsw(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fwiden(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 8;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 89;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_fnarrow(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_truncate(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = pmode2;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2062;
	asu64(R1) = ax;
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = (u64)&mc_decls_ploadop;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2062:
	return;
}

static void mc_genmcl_px_typepun(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_unload(u64 p) {
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_loadbit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 z;
	i64 i;
	i64 m;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2067;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2069;
	R2 = 31;
	if (asi64(R1) > asi64(R2)) goto L2069;
	R1 = 5;
	goto L2068;
L2069:
	R1 = 6;
L2068:
	m = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = i;
	if (!asi64(R1)) goto L2071;
	asi64(R1) = m;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2073;
	goto L2074;
L2073:
L2071:
	goto L2066;
L2067:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2076;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2076:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2078;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2078:
L2066:
	R1 = 5;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
// mc_genmcl.px_loadbit.skip:
L2074:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_assem(u64 p) {
    u64 R1, R2; 
	asu64(R1) = pc_api_idomcl_assem;
	if (!asu64(R1)) goto L2081;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_idomcl_assem;
	((F18)R2)(asu64(R1));
	goto L2080;
L2081:
	R1 = tou64("");
	R2 = tou64("No Assem handler");
	pc_api_merror(asu64(R2), asu64(R1));
L2080:
	return;
}

static void mc_genmcl_px_sin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("sin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_cos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("cos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_tan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("tan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_asin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("asin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_acos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("acos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("atan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log10(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log10*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_exp(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("exp*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_round(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("round*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_floor(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("floor*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_ceil(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("ceil*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan2(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("atan2*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fmod(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("fmod*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_setcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 cond;
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2098;
	R1 = tou64("");
	R2 = tou64("setcc/block");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2097;
L2098:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2099;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2101;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
L2101:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	cx = asu64(R1);
	goto L2097;
L2099:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	R1 = 10;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
L2097:
	R1 = 0;
	asu64(R2) = cx;
	asi64(R3) = cond;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_min(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2104;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2106;
	R1 = 15;
	goto L2105;
L2106:
	R1 = 7;
L2105:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L2103;
L2104:
	R1 = 112;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L2103:
	return;
}

static void mc_genmcl_px_max(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2109;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2111;
	R1 = 12;
	goto L2110;
L2111:
	R1 = 2;
L2110:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L2108;
L2109:
	R1 = 113;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L2108:
	return;
}

static void mc_genmcl_px_power(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 d;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2114;
	R1 = 82;
	asu64(R1) = mc_auxmcl_gethostfn(asi64(R1));
	d = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	asu64(R2) = d;
	asu64(R3) = p;
	mc_auxmcl_do_host(asu64(R3), asu64(R2), asi64(R1));
	goto L2113;
L2114:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("pow*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
L2113:
	return;
}

static void mc_genmcl_px_minto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2117;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2119;
	R2 = 14;
	goto L2118;
L2119:
	R2 = 6;
L2118:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L2116;
L2117:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L2116:
	return;
}

static void mc_genmcl_px_maxto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2122;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2124;
	R2 = 13;
	goto L2123;
L2124:
	R2 = 3;
L2123:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L2121;
L2122:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L2121:
	return;
}

static void mc_genmcl_px_negto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2127;
	R1 = 0;
	asu64(R2) = px;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2126;
L2127:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	fx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = fx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = fx;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
	asu64(R1) = fx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2126:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_absto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 lx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2130;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2129;
L2130:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L2129:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_addpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2133;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2132;
L2133:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2132:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2136;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2135;
L2136:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L2138;
	R1 = tou64("");
	R2 = tou64("SUBTOREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L2138:
L2135:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_divto(u64 p) {
    u64 R1, R2; 
	R1 = 71;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitnotto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu64(R2) = px;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_notto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = px;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	R3 = 5;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_sign(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 lx1;
	u64 lx2;
	u64 lx3;
	u8 gtop;
	u8 ltop;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2145;
	R1 = 7;
	gtop = asu8(R1);
	R1 = 2;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asr64(R2) = 0.000000000000000000e+000;
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2144;
L2145:
	R1 = 15;
	gtop = asu8(R1);
	R1 = 12;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2144:
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx1 = asu64(R3);
	asu8(R3) = gtop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx2 = asu64(R3);
	asu8(R3) = ltop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx3 = asu64(R3);
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx1;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = bx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx2;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = bx;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadbf(u64 p) {
    u64 R1, R2, R3; 
	u64 y;
	u64 z;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	y = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	z = asu64(R1);
	asu64(R1) = y;
	if (!asu64(R1)) goto L2148;
	asu64(R1) = z;
	if (!asu64(R1)) goto L2148;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	mc_auxmcl_do_loadbf_const(asu64(R3), asi64(R2), asi64(R1));
	goto L2147;
L2148:
	asu64(R1) = p;
	mc_auxmcl_do_loadbf_var(asu64(R1));
L2147:
	return;
}

static void mc_genmcl_px_storebit(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebit(asu64(R1));
	return;
}

static void mc_genmcl_px_storebf(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebf(asu64(R1));
	return;
}

static void mc_genmcl_px_loadall(u64 p) {
	mc_stackmcl_checkallloaded();
	return;
}

static void mc_genmcl_px_setjmp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 lab;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = lab;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	R2 = 0;
	R3 = 8;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dframeopnd;
	R2 = 0;
	R3 = 16;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	asu64(R1) = p;
	mc_stackmcl_freeworkregs(asu64(R1));
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	return;
}

static void mc_genmcl_px_longjmp(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 16;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	R1 = 1;
	mc_stackmcl_swapopndregs(asi64(R1));
	R1 = 0;
	asu64(R2) = cx;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_initdswx(u64 p) {
	return;
}

static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf) {
    u64 R1, R2, R3; 
	struct $B17 params;
	struct $B17 xparams;
	struct $B17 leafparams;
	struct $B17 xleafparams;
	u32 leafparamno;
	u32 xleafparamno;
	struct $B16 locals;
	struct $B16 xlocals;
	i64 nparams;
	i64 nxparams;
	i64 nleafparams;
	i64 nxleafparams;
	i64 nlocals;
	i64 nxlocals;
	i64 n;
	i64 reg;
	i64 xreg;
	i64 nl;
	i64 np;
	i64 nlx;
	i64 npx;
	u64 d;
	i64 i;
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nxparams = asi64(R1);
	R1 = 0;
	nleafparams = asi64(R1);
	R1 = 0;
	nxleafparams = asi64(R1);
	R1 = 0;
	nlocals = asi64(R1);
	R1 = 0;
	nxlocals = asi64(R1);
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = mc_decls_maxxregvars;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2157;
	goto L2155;
L2157:
	asi64(R1) = skipparams;
	if (asi64(R1)) goto L2159;
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L2163;
L2160:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2165;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2165;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2165;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2165;
	asi64(R1) = isleaf;
	if (asi64(R1)) goto L2167;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2169;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2171;
	asu64(R1) = d;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2171:
	goto L2168;
L2169:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2172;
	asi64(R1) = nxparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2174;
	asu64(R1) = d;
	R2 = (u64)&xparams;
	R3 = (u64)&nxparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2174:
L2172:
L2168:
	goto L2166;
L2167:
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2176;
	asi64(R1) = nleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2178;
	asu64(R1) = d;
	R2 = (u64)&leafparams;
	R3 = (u64)&nleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&leafparamno;
	asi64(R3) = nleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2178:
	goto L2175;
L2176:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2179;
	asi64(R1) = nxleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2181;
	asu64(R1) = d;
	R2 = (u64)&xleafparams;
	R3 = (u64)&nxleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&xleafparamno;
	asi64(R3) = nxleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2181:
L2179:
L2175:
L2166:
L2165:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2163:
	asu64(R1) = d;
	if (asu64(R1)) goto L2160;
L2159:
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2185;
L2182:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2187;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2187;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2187;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2189;
	asi64(R1) = nlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L2191;
	asu64(R1) = d;
	R2 = (u64)&locals;
	R3 = (u64)&nlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2191:
	goto L2188;
L2189:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2192;
	asi64(R1) = nxlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L2192;
	asu64(R1) = d;
	R2 = (u64)&xlocals;
	R3 = (u64)&nxlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2192:
L2188:
L2187:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2185:
	asu64(R1) = d;
	if (asu64(R1)) goto L2182;
	asi64(R1) = nlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2194;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	np = asi64(R1);
	R1 = 0;
	nl = asi64(R1);
	goto L2193;
L2194:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2195;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nl = asi64(R1);
	R1 = 0;
	np = asi64(R1);
	goto L2193;
L2195:
	asi64(R1) = nlocals;
	nl = asi64(R1);
	asi64(R1) = nparams;
	np = asi64(R1);
	asi64(R1) = np;
	asi64(R2) = nl;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2197;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2199;
	asi64(R1) = np;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2199;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2199:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2201;
	asi64(R1) = n;
	R2 = (u64)&nl;
	*toi64p(R2) -= asi64(R1);
L2201:
L2197:
L2193:
	R1 = 4;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nl;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2204;
L2202:
	R1 = (u64)&locals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= nl) goto L2202;
L2204:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = np;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2207;
L2205:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= np) goto L2205;
L2207:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2210;
L2208:
	R1 = (u64)&leafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&leafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2212;
	R1 = 1;
	pc_decls_r10used = asu8(R1);
L2212:
	asi64(R1) = reg;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2214;
	R1 = 1;
	pc_decls_r11used = asu8(R1);
L2214:
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nleafparams) goto L2208;
L2210:
	asi64(R1) = nxlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2216;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npx = asi64(R1);
	R1 = 0;
	nlx = asi64(R1);
	goto L2215;
L2216:
	asi64(R1) = nxparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2217;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nlx = asi64(R1);
	R1 = 0;
	npx = asi64(R1);
	goto L2215;
L2217:
	asi64(R1) = nxlocals;
	nlx = asi64(R1);
	asi64(R1) = nxparams;
	npx = asi64(R1);
	asi64(R1) = npx;
	asi64(R2) = nlx;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2219;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2221;
	asi64(R1) = npx;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2221;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2221:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2223;
	asi64(R1) = n;
	R2 = (u64)&nlx;
	*toi64p(R2) -= asi64(R1);
L2223:
L2219:
L2215:
	R1 = 16;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2226;
L2224:
	R1 = (u64)&xlocals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= nlx) goto L2224;
L2226:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = npx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2229;
L2227:
	R1 = (u64)&xparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= npx) goto L2227;
L2229:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nxleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2232;
L2230:
	R1 = (u64)&xleafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&xleafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nxleafparams) goto L2230;
L2232:
L2155:
	return;
}

static void mc_auxmcl_initproc(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 e;
	u64 pinfi;
	i64 reg;
	i64 xreg;
	i64 n;
	i64 r;
	i64 npregs;
	i64 av_1;
	i64 av_2;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isregvar;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isxregvar;
	memset(R1, 0, 16);
	R1 = 3;
	mc_decls_nworkregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	mc_decls_maxxregvars = asi64(R2);
	mc_decls_maxregvars = asi64(R1);
	R1 = 0;
	npregs = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2235;
	R1 = 10;
	mc_decls_nworkregs = asi64(R1);
	R1 = 12;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 4;
	r = asi64(R1);
L2236:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 10) goto L2236;
	R1 = 7;
	r = asi64(R1);
L2239:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 16) goto L2239;
	goto L2234;
L2235:
	R1 = 4;
	asu64(R2) = pc_decls_currfunc;
	R3 = 112;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = pc_decls_pinfo;
	R4 = 4;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) = Max(asi64(R2), asi64(R3));
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npregs = asi64(R1);
	R1 = 4;
	mc_decls_nworkregs = asi64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2243;
	R1 = (u64)&mc_decls_nworkregs;
	(*toi64p(R1)) += 1;
L2243:
	R1 = 5;
	mc_decls_nworkxregs = asi64(R1);
	asi64(R1) = mc_decls_nworkregs;
	R2 = 3;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = npregs;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L2245;
	asi64(R1) = n;
	if (!asi64(R1)) goto L2245;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = npregs;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2247;
	asi64(R1) = n;
	if (!asi64(R1)) goto L2247;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2247:
L2245:
	R1 = 10;
	r = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2250;
L2248:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_1)) goto L2248;
L2250:
	R1 = 7;
	r = asi64(R1);
	asi64(R1) = mc_decls_nworkxregs;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2253;
L2251:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_2)) goto L2251;
L2253:
L2234:
	R1 = 4;
	r = asi64(R1);
L2254:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2258;
	R1 = (u64)&mc_decls_maxregvars;
	(*toi64p(R1)) += 1;
L2258:
	r += 1; if (r <= 10) goto L2254;
	R1 = 7;
	r = asi64(R1);
L2259:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2263;
	R1 = (u64)&mc_decls_maxxregvars;
	(*toi64p(R1)) += 1;
L2263:
	r += 1; if (r <= 16) goto L2259;
	R1 = (u64)&mc_decls_usedregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_usedxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_pcltempflags;
	memset(R1, 0, 20);
	R1 = 0;
	R2 = R1;
	pc_decls_r11used = asu8(R2);
	pc_decls_r10used = asu8(R1);
	R1 = 0;
	mc_decls_mstackdepth = asi64(R1);
	R1 = 0;
	mc_decls_noperands = asi64(R1);
	R1 = 0;
	R2 = R1;
	mc_genmcl_framebytes = asi64(R2);
	R2 = R1;
	mc_genmcl_paramoffset = asi64(R2);
	mc_genmcl_frameoffset = asi64(R1);
	R1 = 0;
	pc_decls_localshadow = asu8(R1);
	R1 = 0;
	mc_decls_nblocktemps = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2265;
	R1 = 8;
	R2 = tou64("$1x");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	asu64(R2) = e;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = e;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = pc_decls_currfunc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	pc_decls_blockretname = asu64(R1);
L2265:
	asu8(R1) = pc_decls_fregoptim;
	if (!asu8(R1)) goto L2268;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2267;
L2268:
	goto L2233;
L2267:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2270;
	goto L2233;
L2270:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_decls_currfunc;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (asu8(R2)) goto L2271;
	asu64(R2) = pc_decls_currfunc;
	R3 = 113;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2272;
L2271:
	R2 = 1;
	goto L2273;
L2272:
	R2 = 0;
L2273:
	mc_auxmcl_allocregvars(asi64(R2), asi64(R1));
L2233:
	return;
}

static void mc_auxmcl_do_procentry(u64 p) {
    u64 R1, R2, R3; 
	i64 retmode;
	i64 ntemps;
	i64 hasequiv;
	i64 offset;
	i64 size;
	i64 reg;
	u64 ax;
	u64 d;
	struct $B5 str;
	struct $B5 newname;
	i64 rr;
	i64 ff;
	i64 r;
	i64 i;
	asu64(R1) = mc_decls_mclprocentry;
	mc_auxmcl_setmclentry(asu64(R1));
	R1 = 0;
	R2 = R1;
	pc_decls_bxspill = asi64(R2);
	pc_decls_bspill = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2277;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2276;
L2277:
	R1 = 4;
	r = asi64(R1);
L2278:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2283;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2282;
L2283:
	R1 = (u64)&pc_decls_bspill;
	(*toi64p(R1)) += 1;
L2282:
	r += 1; if (r <= 10) goto L2278;
	R1 = 7;
	r = asi64(R1);
L2284:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2289;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2288;
L2289:
	R1 = (u64)&pc_decls_bxspill;
	(*toi64p(R1)) += 1;
L2288:
	r += 1; if (r <= 16) goto L2284;
L2276:
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2293;
L2290:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2295;
	R1 = tou64("");
	R2 = tou64("@PARAM");
	pc_api_merror(asu64(R2), asu64(R1));
L2295:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2297;
	asi64(R1) = mc_genmcl_paramoffset;
	R2 = 16;
	asi64(R1) += asi64(R2);
	asi64(R2) = pc_decls_bspill;
	asi64(R3) = pc_decls_bxspill;
	asi64(R2) += asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writeasm_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2296;
L2297:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2296:
	R1 = 8;
	R2 = (u64)&mc_genmcl_paramoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2293:
	asu64(R1) = d;
	if (asu64(R1)) goto L2290;
	asu64(R1) = pc_decls_currfunc;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	retmode = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2301;
L2298:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2303;
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	size = asi64(R1);
L2303:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2305;
	goto L2299;
L2305:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2307;
	R1 = 1;
	hasequiv = asi64(R1);
	goto L2306;
L2307:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2308;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2306;
L2308:
	asi64(R1) = size;
	asi64(R1) = mc_libmcl_roundsizetg(asi64(R1));
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writeasm_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2306:
L2299:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2301:
	asu64(R1) = d;
	if (asu64(R1)) goto L2298;
	R1 = 0;
	ntemps = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L2309:
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2313;
	R1 = (u64)&ntemps;
	(*toi64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&mc_decls_pcltempopnds;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ax = asu64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = ax;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asi64(R2) = i;
	asu64(R3) = pc_decls_currfunc;
	asu64(R2) = mc_writeasm_gettempname(asu64(R3), asi64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2313:
	i += 1; if (i <= 20) goto L2309;
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2315;
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (asi16(R1)) goto L2318;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2317;
L2318:
	R1 = tou64("");
	R2 = tou64("Threaded proc has locals/params");
	pc_api_merror(asu64(R2), asu64(R1));
L2317:
	asi64(R1) = ntemps;
	if (!asi64(R1)) goto L2320;
	R1 = tou64("");
	R2 = tou64("Threaded proc has temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2320:
	asu64(R1) = mc_auxmcl_resetmclentry();
	goto L2274;
L2315:
	asi64(R1) = mc_genmcl_frameoffset;
	asi64(R1) = -asi64(R1);
	mc_genmcl_framebytes = asi64(R1);
	asi64(R1) = pc_decls_bspill;
	asi64(R2) = pc_decls_bxspill;
	asi64(R1) += asi64(R2);
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2322;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L2324;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2324:
	goto L2321;
L2322:
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2326;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2326:
L2321:
	asu8(R1) = pc_decls_localshadow;
	if (!asu8(R1)) goto L2328;
	R1 = 32;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2328:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L2330;
	R1 = 4;
	r = asi64(R1);
L2331:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2336;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2335;
L2336:
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2335:
	r += 1; if (r <= 10) goto L2331;
L2330:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L2338;
	R1 = 6;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 7;
	r = asi64(R1);
L2339:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2344;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2343;
L2344:
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2343:
	r += 1; if (r <= 16) goto L2339;
L2338:
	R1 = tou64("?]]");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_auxmcl_mclframesetup = asu64(R1);
	mc_auxmcl_spillparams();
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_auxmcl_resetmclentry();
L2274:
	return;
}

static void mc_auxmcl_do_procexit() {
    u64 R1, R2, R3; 
	u64 ax;
	i64 offset;
	i64 r;
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2347;
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2345;
L2347:
	asu64(R1) = mc_auxmcl_mclframesetup;
	mc_auxmcl_setmclentryf(asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L2350;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2349;
L2350:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2352;
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_pushstack(asi64(R1));
	goto L2351;
L2352:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L2354;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
L2354:
L2351:
L2349:
	asu64(R1) = mc_auxmcl_resetmclentryf();
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L2357;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2356;
L2357:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2359;
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_popstack(asi64(R1));
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2358;
L2359:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L2361;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_popstack(asi64(R1));
L2361:
L2358:
L2356:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L2363;
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 16;
	r = asi64(R1);
L2364:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2368;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	R2 = 8;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2368:
	r += -1; if (r >= 7) goto L2364;
L2363:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L2370;
	R1 = 10;
	r = asi64(R1);
L2371:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2375;
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2375:
	r += -1; if (r >= 4) goto L2371;
L2370:
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2345:
	return;
}

static void mc_auxmcl_spillparams() {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 d;
	u64 ax;
	i64 offset;
	i64 regoffset;
	i64 xregoffset;
	i64 firstoffset;
	i64 i;
	R1 = 16;
	offset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2378;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	firstoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L2381;
L2379:
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asi64(R4) = i;
	R5 = 8;
	asi64(R4) *= asi64(R5);
	asi64(R5) = firstoffset;
	asi64(R4) += asi64(R5);
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = i;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	i += 1; if (i <= 3) goto L2379;
L2381:
L2378:
	goto L2385;
L2382:
	asi64(R1) = regoffset;
	R2 = 3;
	if (asi64(R1) <= asi64(R2)) goto L2387;
	goto L2384;
L2387:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2389;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2391;
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asu64(R4) = d;
	R5 = 76;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2393;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2394;
	goto L2395;
L2393:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2392;
L2394:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 16;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2392;
L2395:
	R1 = 10;
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2392:
	goto L2390;
L2391:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2396;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2398;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L2400;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 8;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2400:
	goto L2397;
L2398:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2401;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2401:
L2397:
L2396:
L2390:
L2389:
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&regoffset;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2385:
	asu64(R1) = d;
	if (asu64(R1)) goto L2382;
L2384:
	return;
}

static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2404;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2403;
L2404:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2403:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_bitwise(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shift(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 y;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	y = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2408;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2408;
	R1 = 10;
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2407;
L2408:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2410;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2410:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2412;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2412:
L2407:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_setmclentry(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mce_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentry() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mce_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mce_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mce_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L2414;
L2414:
	return asu64(R1);
}

static void mc_auxmcl_setmclentryf(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mcf_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentryf() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mcf_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mcf_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mcf_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L2416;
L2416:
	return asu64(R1);
}

static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 j;
	i64 k;
	i64 nextireg;
	i64 nextxreg;
	i64 mode;
	i64 imode;
	i64 blockret;
	u64 dblock;
	i64 av_1;
	i64 i;
	asi64(R1) = nargs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2419;
	goto L2417;
L2419:
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	R1 = 11;
	nextireg = asi64(R1);
	R1 = 1;
	nextxreg = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = nargs;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) < asi64(R2)) goto L2422;
L2420:
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = k;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2424;
	asi64(R1) = blockret;
	if (!asi64(R1)) goto L2424;
	R1 = (u64)&mc_decls_callblocksize;
	asi64(R2) = mc_decls_ncalldepth;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2423;
L2424:
	asi64(R1) = i;
	asi64(R2) = isptr;
	asi64(R1) -= asi64(R2);
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = j;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2426;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2427;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2427;
	goto L2428;
L2426:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = k;
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*16-16;
	asi64(R3) = k;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(tou32(R2));
	asu64(R3) = ax;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
	goto L2425;
L2427:
	asi64(R1) = nextxreg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L2430;
	asi64(R1) = k;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L2430;
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2432;
	R1 = 5;
	goto L2431;
L2432:
	R1 = 6;
L2431:
	imode = asi64(R1);
	asi64(R1) = mode;
	asi64(R2) = nextxreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = imode;
	asi64(R3) = nextireg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2430:
	goto L2425;
L2428:
// mc_auxmcl.do_pushlowargs.doint:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
L2425:
L2423:
	R1 = (u64)&nextireg;
	(*toi64p(R1)) += 1;
	R1 = (u64)&nextxreg;
	(*toi64p(R1)) += 1;
	i += -1; if (i >= av_1) goto L2420;
L2422:
L2417:
	return;
}

static void mc_auxmcl_do_getretvalue(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 xreg;
	i64 i;
	i64 n;
	i64 m;
	struct $B1 modes;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L2436;
	R1 = 0;
	n = asi64(R1);
	goto L2438;
L2437:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&modes;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L2438:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2437;
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2442;
L2440:
	R1 = (u64)&modes;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2444;
	R1 = (u64)&mc_decls_multxregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L2443;
L2444:
	R1 = (u64)&mc_decls_multregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
L2443:
	asi64(R2) = m;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	i += -1; if (i >= 1) goto L2440;
L2442:
	goto L2435;
L2436:
	R1 = 1;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
L2435:
	return;
}

static i64 mc_auxmcl_ismemaddr(i64 n) {
    u64 R1, R2; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2447;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2447;
	R1 = 1;
	goto L2445;
L2447:
	R1 = 0;
	goto L2445;
L2445:
	return asi64(R1);
}

static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 mx;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2450;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2449;
L2450:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2449:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2453;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2452;
L2453:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2452:
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2456;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2455;
L2456:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2455:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 r;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 mx;
	i64 reg;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	r = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2459;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2461;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2460;
L2461:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2460:
	asu64(R1) = mx;
	ax = asu64(R1);
	goto L2458;
L2459:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2463;
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2462;
L2463:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2462:
	asu64(R1) = ax;
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2458:
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2465;
	R1 = 10;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	goto L2464;
L2465:
	R1 = 6;
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	bx = asu64(R1);
L2464:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale) {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2469;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2469;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2469;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2468;
L2469:
	asi64(R1) = scale;
	goto L2466;
L2468:
	asi64(R1) = scale;
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	goto L2466;
L2466:
	return asi64(R1);
}

static void mc_auxmcl_mulimm(u64 ax, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 shifts;
	i64 m;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2472;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2473;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L2474;
	goto L2475;
L2472:
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	goto L2470;
	goto L2471;
L2473:
	goto L2470;
	goto L2471;
L2474:
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2470;
	goto L2471;
L2475:
L2471:
	R1 = 0;
	shifts = asi64(R1);
	asi64(R1) = n;
	m = asi64(R1);
	goto L2477;
L2476:
	R1 = 1;
	R2 = (u64)&m;
	*toi64p(R2) >>= asi64(R1);
	R1 = (u64)&shifts;
	(*toi64p(R1)) += 1;
L2477:
	asi64(R1) = m;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2476;
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2480;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2480:
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2482;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2483;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2483;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2483;
	goto L2484;
L2482:
	goto L2470;
	goto L2481;
L2483:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = m;
	R6 = 1;
	asi64(R5) -= asi64(R6);
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2481;
L2484:
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2486;
	R1 = 34;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_mccodex;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2485;
L2486:
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2485:
L2481:
L2470:
	return;
}

static u64 mc_auxmcl_do_addrmode(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 px;
	u64 ax;
	u64 bx;
	i64 scale;
	i64 extra;
	i64 offset;
	i64 reg;
	i64 regix;
	u64 d;
	u64 q;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2489;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
L2489:
	R1 = 0;
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2491;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2493;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2492;
L2493:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2494;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2492;
L2494:
	asi64(R1) = scale;
	R2 = 0;
	R3 = (u64)&mc_decls_pclmode;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2492:
	goto L2490;
L2491:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R1) = mc_auxmcl_ismemaddr(asi64(R1));
	if (!asi64(R1)) goto L2495;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2499;
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2498;
L2499:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2497;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2497;
L2498:
	goto L2500;
L2497:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2502;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2501;
L2502:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2503;
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2501;
L2503:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 10;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2501:
	goto L2490;
L2495:
// mc_auxmcl.do_addrmode.skip:
L2500:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2505;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2504;
L2505:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2506;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2504;
L2506:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2504:
L2490:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = px;
	goto L2487;
L2487:
	return asu64(R1);
}

static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	i64 regix;
	u64 ax;
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2510;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2510;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2510;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2509;
L2510:
	asi64(R1) = reg;
	goto L2507;
L2509:
	asi64(R1) = mc_stackmcl_getworkireg();
	regix = asi64(R1);
	R1 = 10;
	asi64(R2) = regix;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2512;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 1;
	asi64(R6) = reg;
	asi64(R7) = reg;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
	goto L2511;
L2512:
	R1 = 10;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
L2511:
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = regix;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 10;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = regix;
	goto L2507;
L2507:
	return asi64(R1);
}

static void mc_auxmcl_dolea(u64 ax, u64 px) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = px;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2517;
	asu64(R2) = px;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2517;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2517;
	R1 = 1;
	goto L2518;
L2517:
	R1 = 0;
L2518:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2516;
	asu64(R1) = px;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2515;
L2516:
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2515:
	return;
}

static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 rx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2521;
	asi64(R1) = fopc;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2519;
L2521:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2519:
	return;
}

static void mc_auxmcl_do_binto_float(u64 p, i64 opc) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = cx;
	asi64(R3) = opc;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shiftnto(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 cx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2525;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2525;
	R1 = 10;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2524;
L2525:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2527;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2527:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2529;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2529:
L2524:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 q;
	i64 opc;
	i64 n;
	i64 shifts;
	u8 fdivto;
	i64 locyy;
	i64 loczz;
	R1 = 0;
	fdivto = asu8(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	locyy = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	loczz = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L2533;
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L2532;
L2533:
	R1 = (u64)&locyy;
	R2 = (u64)&loczz;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	fdivto = asu8(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2531;
L2532:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
L2531:
	asi64(R1) = loczz;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2535;
	asi64(R1) = isdiv;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2535;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2537;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2538;
	goto L2539;
L2537:
	R1 = tou64("");
	R2 = tou64("Divide by zero");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2536;
L2538:
	mc_stackmcl_poppcl();
	goto L2530;
	goto L2536;
L2539:
	asi64(R1) = n;
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	shifts = asi64(R1);
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2541;
	asu8(R1) = fdivto;
	if (asu8(R1)) goto L2541;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = issigned;
	if (!asi64(R3)) goto L2543;
	R3 = 44;
	goto L2542;
L2543:
	R3 = 45;
L2542:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L2530;
L2541:
L2536:
L2535:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	mc_auxmcl_saverdx();
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_auxmcl_fixdivopnds(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = issigned;
	if (!asi64(R1)) goto L2545;
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2547;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2548;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2549;
	goto L2550;
L2547:
	R1 = 57;
	goto L2546;
L2548:
	R1 = 56;
	goto L2546;
L2549:
	R1 = 55;
	goto L2546;
L2550:
	R1 = tou64("");
	R2 = tou64("div/u8");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
L2546:
	opc = asi64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 36;
	opc = asi64(R1);
	goto L2544;
L2545:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 37;
	opc = asi64(R1);
L2544:
	R1 = 0;
	asu64(R2) = bx;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = isdiv;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2552;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2553;
	goto L2554;
L2552:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2551;
L2553:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	mc_stackmcl_swapopndregs(asi64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2551;
L2554:
L2551:
	mc_auxmcl_restorerdx();
	asu8(R1) = fdivto;
	if (!asu8(R1)) goto L2556;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu64(R2) = bx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = bx;
	asu64(R2) = mc_stackmcl_makeopndind(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
L2556:
	asi64(R1) = isdiv;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2558;
	mc_stackmcl_poppcl();
L2558:
L2530:
	return;
}

static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz) {
    u64 R1, R2, R3; 
	i64 regx;
	i64 regy;
	i64 zop;
	u64 bx;
	u64 ax;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regx = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = loczz;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regy = asi64(R1);
	asi64(R1) = regx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2561;
	goto L2559;
L2561:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = regy;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2563;
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2559;
L2563:
	R1 = (u64)&mc_decls_regset;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2565;
	asu64(R1) = bx;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = regx;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = locyy;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2559;
L2565:
	asi64(R1) = mc_decls_noperands;
	zop = asi64(R1);
	asi64(R1) = zop;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2569;
L2566:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2571;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2571;
	goto L2568;
L2571:
	zop += -1; if (zop >= 1) goto L2566;
L2569:
	goto L2559;
L2568:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = zop;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
L2559:
	return;
}

static void mc_auxmcl_saverdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2574;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2574:
	return;
}

static void mc_auxmcl_restorerdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2577;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2577:
	return;
}

static void mc_auxmcl_clearblock(u64 ax, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 av_1;
	i64 i;
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2580;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L2580;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2583;
L2581:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2581;
L2583:
	goto L2579;
L2580:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2584;
	asi64(R1) = nwords;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2586;
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	goto L2585;
L2586:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	R3 = 4;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
L2587:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= 4) goto L2587;
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2585:
L2584:
L2579:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2591;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2593;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2593:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2595;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2595:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2597;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2597:
L2591:
	return;
}

static void mc_auxmcl_do_blockdata(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 d;
	i64 n;
	i64 nqwords;
	i64 nwords;
	i64 r;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2600;
	goto L2598;
L2600:
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2603;
L2601:
	R1 = 0;
	R2 = 10;
	R3 = (u64)&d;
	asu64(R4) = *tou64p(R3); *(tou64p(R3)) += 8; asu64(R3) = asu64(R4);
	asi64(R3) = *toi64p(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L2601;
L2603:
	asi64(R1) = n;
	asi64(R2) = nwords;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) -= asi64(R2);
	r = asi64(R1);
	asi64(R1) = r;
	if (!asi64(R1)) goto L2605;
	R1 = 66;
	asi64(R2) = r;
	asu64(R3) = d;
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
L2605:
	R1 = tou64("ENDDATA");
	mc_libmcl_mgencomment(asu64(R1));
L2598:
	return;
}

static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 axreg;
	u8 saved;
	i64 av_1;
	R1 = 0;
	saved = asu8(R1);
	asi64(R1) = n;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2608;
	R1 = 2;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2606;
L2608:
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2610;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2610;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 8;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2613;
L2611:
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2611;
L2613:
	goto L2609;
L2610:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2614;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asi64(R1) = savedest;
	if (!asi64(R1)) goto L2616;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	axreg = asi64(R1);
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	saved = asu8(R1);
L2616:
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	bx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2614:
L2609:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2618;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2620;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 4;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2620:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2622;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 2;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2622:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2624;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 1;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2624:
L2618:
	asu8(R1) = saved;
	if (!asu8(R1)) goto L2626;
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2626:
L2606:
	return;
}

static void mc_auxmcl_genstringtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_cstringlist;
	if (asu64(R1)) goto L2629;
	goto L2627;
L2629:
	R1 = tou64("String Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_kk0used;
	if (!asi64(R1)) goto L2631;
	R1 = 0;
	asi64(R2) = mc_decls_kk0used;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2631:
	asu64(R1) = mc_decls_cstringlist;
	p = asu64(R1);
	goto L2635;
L2632:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = -1;
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2635:
	asu64(R1) = p;
	if (asu64(R1)) goto L2632;
L2627:
	return;
}

static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype) {
    u64 R1, R2; 
	i64 i;
	i64 c;
	i64 seqlen;
	u64 seq;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L2638;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2638:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2640;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
	goto L2636;
L2640:
	R1 = 0;
	seqlen = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2643;
L2641:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L2646;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) >= asi64(R2)) goto L2646;
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2647;
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L2645;
L2647:
L2646:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2649;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
	R1 = 0;
	seqlen = asi64(R1);
L2649:
	asi64(R1) = c;
	mc_auxmcl_gendb(asi64(R1));
	goto L2644;
L2645:
	asi64(R1) = seqlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2651;
	R1 = 1;
	seqlen = asi64(R1);
	asu64(R1) = s;
	R2 = 1;
	R1 -= (i64)R2;
	seq = asu64(R1);
	goto L2650;
L2651:
	R1 = (u64)&seqlen;
	(*toi64p(R1)) += 1;
L2650:
L2644:
	if (--asi64(av_1)) goto L2641;
L2643:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2653;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
L2653:
	asi64(R1) = strtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2655;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2655:
L2636:
	return;
}

static void mc_auxmcl_gendb(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendbstring(u64 s, i64 length) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendq(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_genrealtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_creallist;
	if (asu64(R1)) goto L2661;
	asu64(R1) = mc_decls_cr32list;
	if (asu64(R1)) goto L2661;
	goto L2659;
L2661:
	R1 = tou64("Real Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = mc_decls_creallist;
	p = asu64(R1);
	goto L2665;
L2662:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2667;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2666;
L2667:
	R1 = 0;
	R2 = 2;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2666:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2665:
	asu64(R1) = p;
	if (asu64(R1)) goto L2662;
	R1 = tou64("Real32 Table");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_cr32list;
	p = asu64(R1);
	goto L2671;
L2668:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2673;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
    asr32(R3) = tor32(asr64(R3));
	asi64(R3) = asi64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2672;
L2673:
	R1 = 0;
	R2 = 1;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2672:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2671:
	asu64(R1) = p;
	if (asu64(R1)) goto L2668;
L2659:
	return;
}

static void mc_auxmcl_genabsneg() {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_lababs32;
	asi64(R2) = mc_decls_lababs64;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg32;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg64;
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L2676;
	R1 = 16;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
L2676:
	asi64(R1) = mc_decls_lababs32;
	if (!asi64(R1)) goto L2678;
	R1 = tou64("lababs32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
L2678:
	asi64(R1) = mc_decls_lababs64;
	if (!asi64(R1)) goto L2680;
	R1 = tou64("lababs64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
L2680:
	asi64(R1) = mc_decls_labneg32;
	if (!asi64(R1)) goto L2682;
	R1 = tou64("labneg32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
L2682:
	asi64(R1) = mc_decls_labneg64;
	if (!asi64(R1)) goto L2684;
	R1 = tou64("labneg64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
L2684:
	asi64(R1) = mc_decls_labzero;
	if (!asi64(R1)) goto L2686;
	R1 = tou64("labzero");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labzero;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendq(asi64(R1));
L2686:
	asi64(R1) = mc_decls_labmask63;
	if (!asi64(R1)) goto L2688;
	R1 = tou64("mask63/offset64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labmask63;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_laboffset64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4890909195324358656;
	mc_auxmcl_gendq(asi64(R1));
L2688:
	return;
}

static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	R2 = 0;
	asu64(R3) = opname;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	asu64(R2) = d;
	R3 = 0;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs) {
    u64 R1, R2, R3; 
	i64 slots;
	i64 av_1;
	asi64(R1) = nargs;
	mc_stackmcl_saveopnds(asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2693;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
	R1 = 1;
	slots = asi64(R1);
L2693:
	R1 = 0;
	R2 = 0;
	asi64(R3) = nargs;
	mc_auxmcl_do_pushlowargs(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L2695;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	goto L2694;
L2695:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L2694:
	asu64(R1) = opname;
	if (!asu64(R1)) goto L2697;
	R1 = 0;
	asu64(R2) = opname;
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2696;
L2697:
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2696:
	asi64(R1) = nargs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2700;
L2698:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L2698;
L2700:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L2702;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L2702:
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
	return;
}

static void mc_auxmcl_do_max_int(i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = cond;
	R4 = 15;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_max_float(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asi64(R1) = mode;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asi64(R4) = mode;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_negreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2709;
	asi64(R1) = mc_decls_labneg64;
	if (asi64(R1)) goto L2711;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg64 = asi64(R1);
L2711:
	asi64(R1) = mc_decls_labneg64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 77;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2708;
L2709:
	asi64(R1) = mc_decls_labneg32;
	if (asi64(R1)) goto L2713;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg32 = asi64(R1);
L2713:
	asi64(R1) = mc_decls_labneg32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 76;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2708:
	return;
}

static void mc_auxmcl_do_absreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2716;
	asi64(R1) = mc_decls_lababs64;
	if (asi64(R1)) goto L2718;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs64 = asi64(R1);
L2718:
	asi64(R1) = mc_decls_lababs64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 79;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2715;
L2716:
	asi64(R1) = mc_decls_lababs32;
	if (asi64(R1)) goto L2720;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs32 = asi64(R1);
L2720:
	asi64(R1) = mc_decls_lababs32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 78;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2715:
	return;
}

static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 mx;
	u64 mask;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2723;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 44;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2722;
L2723:
	asi64(R1) = i;
	if (!asi64(R1)) goto L2725;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2725:
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	asu64(R1) = mask;
	R2 = 2147483647;
	if (asu64(R1) > asu64(R2)) goto L2727;
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2726;
L2727:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2726:
L2722:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_loadbf_var(u64 p) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = tou64("LOADBF_VAR");
	pc_api_merror(asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_do_storebit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 cx;
	u64 ix;
	u64 q;
	u64 r;
	i64 i;
	i64 offset;
	u8 mask1s;
	u8 mask0s;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2731;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	offset = asi64(R1);
	R1 = 7;
	R2 = (u64)&i;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = px;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	mask0s = asu8(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	mask1s = asu8(R1);
	asu64(R1) = r;
	if (!asu64(R1)) goto L2733;
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2735;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2734;
L2735:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask0s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2734:
	goto L2732;
L2733:
	R1 = 0;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2737;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2737:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2732:
	goto L2730;
L2731:
	asu64(R1) = r;
	if (!asu64(R1)) goto L2738;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2740;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2742;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2742:
	R1 = 11;
	R2 = 10;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ix = asu64(R1);
	R1 = 1;
	asu64(R2) = cx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2744;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2744:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2746;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2745;
L2746:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2745:
	goto L2739;
L2740:
	R1 = tou64("");
	R2 = tou64("STOREBIT/VAR");
	pc_api_merror(asu64(R2), asu64(R1));
L2739:
	goto L2730;
L2738:
	R1 = tou64("");
	R2 = tou64("Storebit: both vars");
	pc_api_merror(asu64(R2), asu64(R1));
L2730:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_storebf(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 rx;
	u64 mx;
	u64 mx4;
	u64 dx;
	i64 i;
	i64 j;
	u64 q;
	u64 r;
	u64 mask;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = r;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2749;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2749;
	R1 = tou64("");
	R2 = tou64("storebf not imm");
	pc_api_merror(asu64(R2), asu64(R1));
L2749:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 3;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	dx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	j = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	asi64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2751;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = dx;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2751:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = mx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dx;
	asu64(R2) = rx;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static u64 mc_auxmcl_gethostfn(i64 opc) {
    u64 R1, R2; 
	u64 d;
	u64 name;
	u64 namec;
	u64 ps;
	asu64(R1) = pc_api_igethostfn;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2754;
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2756;
	goto L2757;
L2756:
	R1 = tou64("msys.m$power_i64");
	name = asu64(R1);
	R1 = tou64("msysc.m$power_i64");
	namec = asu64(R1);
	goto L2755;
L2757:
	R1 = 0;
	name = asu64(R1);
L2755:
	asu64(R1) = name;
	if (!asu64(R1)) goto L2759;
	asu64(R1) = pc_decls_psymboltable;
	ps = asu64(R1);
	goto L2763;
L2760:
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L2766;
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = namec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2765;
L2766:
	asu64(R1) = ps;
	goto L2752;
L2765:
	asu64(R1) = ps;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ps = asu64(R1);
L2763:
	asu64(R1) = ps;
	if (asu64(R1)) goto L2760;
L2759:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("gethostfn?");
	pc_api_merror(asu64(R2), asu64(R1));
L2754:
	asi64(R1) = opc;
	asu64(R2) = pc_api_igethostfn;
	asu64(R1) = ((F19)R2)(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2768;
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("No host fn:");
	pc_api_merror(asu64(R2), asu64(R1));
L2768:
	asu64(R1) = d;
	goto L2752;
L2752:
	return asu64(R1);
}

static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 dblock;
	u64 ax;
	u64 bx;
	u64 axi;
	u64 bxi;
	asu64(R1) = px;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2771;
	msysc_m$print_startcon();
	R1 = tou64("High block arg not copied in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("()");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L2769;
L2771:
	asi64(R1) = size;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = px;
	if (!asu64(R1)) goto L2773;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2772;
L2773:
	R1 = 0;
	R2 = 11;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
L2772:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = size;
	R3 = 0;
	R4 = 10;
	asu64(R5) = bx;
	R6 = 10;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asu64(R3) = mc_libmcl_mgenireg(asi64(R5), asi64(R4), asi64(R3));
	R4 = 0;
	R5 = 10;
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R4) = mc_libmcl_mgenireg(asi64(R6), asi64(R5), asi64(R4));
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = px;
	if (!asu64(R1)) goto L2775;
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2775:
	R1 = 0;
	mc_stackmcl_freeworkregs(asu64(R1));
L2769:
	return;
}

static void mc_auxmcl_fixmain() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 dn;
	u64 dargs;
	u64 denv;
	u64 dinfo;
	u64 ax;
	asu64(R1) = pc_decls_currfunc;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dn = asu64(R1);
	asu64(R1) = dn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dargs = asu64(R1);
	R1 = 3;
	R2 = tou64("$env");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	denv = asu64(R1);
	R1 = 6;
	asu64(R2) = denv;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = denv;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = tou64("$info");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	dinfo = asu64(R1);
	R1 = 11;
	asu64(R2) = dinfo;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 128;
	asu64(R2) = dinfo;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 8;
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = dinfo;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 128;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = denv;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 8;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = denv;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dinfo;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = R1;
	asu64(R3) = d;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = dargs;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = dn;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dn;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = dn;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = dargs;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dn;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = R2;
	ax = asu64(R3);
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dinfo;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dinfo;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dn;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dn;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dargs;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dargs;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = denv;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 13;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = denv;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	R2 = 14;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	R2 = tou64("__getmainargs*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 48;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	if (!asi64(R1)) goto L2778;
	R1 = 9;
	asi64(R2) = pc_decls_pcmdskip;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dn;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dargs;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2778:
	return;
}

static void mc_libmcl_mclinit(i64 bypass) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 r;
	i64 s;
	i64 av_1;
	i64 av_2;
	i64 i;
	R1 = 64;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2781;
	R1 = tou64("MCLREC>64B");
	mlib_abortprogram(asu64(R1));
L2781:
	R1 = 1;
	r = asi64(R1);
L2782:
	R1 = 1;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 2;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 4;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 4;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	r += 1; if (r <= 16) goto L2782;
	R1 = -128;
	i = asi64(R1);
	R1 = 64;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L2787;
L2785:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = i;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_frameregtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+1024)) = asu64(R1);
	i += 1; if (i <= av_1) goto L2785;
L2787:
	R1 = 6;
	R2 = 15;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dframeopnd = asu64(R1);
	R1 = 6;
	R2 = 16;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dstackopnd = asu64(R1);
	mc_libmcl_initmcdest();
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	mc_decls_lab_funcnametable = asi64(R1);
	R1 = 0;
	mc_decls_lab_funcaddrtable = asi64(R1);
	R1 = -1;
	i = asi64(R1);
	R1 = 10;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2790;
L2788:
	R1 = 8;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_libmcl_smallinttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L2788;
L2790:
	asi64(R1) = bypass;
	if (!asi64(R1)) goto L2792;
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
L2792:
	return;
}

static void mc_libmcl_initmcdest() {
    u64 R1, R2; 
	R1 = 0;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
	return;
}

static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 m;
	u64 oldm;
	i64 labno;
	R1 = 64;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	m = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_libmcl_mclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = m;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opcode;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2796;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2797;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2798;
	goto L2799;
L2796:
	asu64(R1) = b;
	if (!asu64(R1)) goto L2801;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2801;
	R1 = 1;
	asu64(R2) = b;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2801:
	goto L2795;
L2797:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	goto L2795;
L2798:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2804;
	asu64(R1) = b;
	if (!asu64(R1)) goto L2803;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2803;
L2804:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2806;
	R1 = 17;
	goto L2805;
L2806:
	R1 = 16;
L2805:
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2803:
	goto L2795;
L2799:
L2795:
	asu64(R1) = mc_decls_mccode;
	if (!asu64(R1)) goto L2808;
	asu64(R1) = mc_decls_mccodex;
	asu64(R2) = m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	mc_decls_mccodex = asu64(R1);
	goto L2807;
L2808:
	asu64(R1) = m;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
L2807:
	return;
}

static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = mc_decls_mccodex;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mc_libmcl_genmc_str(i64 opcode, u64 s) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = -1;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_newmclopnd() {
    u64 R1; 
	u64 a;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	a = asu64(R1);
	R1 = (u64)&mc_libmcl_nmclopnd;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	goto L2811;
L2811:
	return asu64(R1);
}

static u64 mc_libmcl_duplopnd(u64 a) {
    u64 R1, R2; struct $B3 R1_B3; 
	u64 b;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	b = asu64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = b;
	goto L2812;
L2812:
	return asu64(R1);
}

static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = areg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = areg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2816;
	asi64(R1) = ireg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2815;
L2816:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2815:
	asi64(R1) = ireg;
	asu64(R2) = a;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 5;
	R4 = 8;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = labno;
	if (!asi64(R1)) goto L2818;
	asi64(R1) = labno;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2817;
L2818:
	asu64(R1) = def;
	if (!asu64(R1)) goto L2819;
	asu64(R1) = def;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = def;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = def;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2822;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2821;
L2822:
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2821:
L2819:
L2817:
	asu64(R1) = a;
	goto L2813;
L2813:
	return asu64(R1);
}

static void mc_libmcl_mgencomment(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = 3;
	mc_libmcl_genmc_str(asi64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenstring(u64 s, i64 length) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2826;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2826:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = a;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2824;
L2824:
	return asu64(R1);
}

static u64 mc_libmcl_mgenname(u64 s) {
    u64 R1, R2, R3, R4; 
	struct $B30 str;
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2827;
L2827:
	return asu64(R1);
}

static void mc_libmcl_setsegment(i64 seg, i64 align) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 oldalign;
	asi64(R1) = seg;
	asi64(R2) = mc_decls_currsegment;
	if (asi64(R1) == asi64(R2)) goto L2830;
	asi64(R1) = seg;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L2832;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L2833;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L2834;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2835;
	goto L2836;
L2832:
	R1 = 120;
	opc = asi64(R1);
	goto L2831;
L2833:
	R1 = 121;
	opc = asi64(R1);
	goto L2831;
L2834:
	R1 = 122;
	opc = asi64(R1);
	goto L2831;
L2835:
	R1 = tou64("");
	R2 = tou64("CAN'T DO RODATA SEG");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2831;
L2836:
	R1 = tou64("");
	R2 = tou64("BAD SEG CODE");
	pc_api_merror(asu64(R2), asu64(R1));
L2831:
	asu64(R1) = mc_decls_mccodex;
	if (!asu64(R1)) goto L2838;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L2839;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2839;
	R2 = 122;
	if (asi64(R1) != asi64(R2)) goto L2838;
L2839:
	asi64(R1) = opc;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2837;
L2838:
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2837:
	asi64(R1) = seg;
	mc_decls_currsegment = asi64(R1);
L2830:
	asi64(R1) = align;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2841;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) != asi64(R2)) goto L2843;
	asu64(R1) = mc_decls_mccodex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldalign = asi64(R1);
	asi64(R1) = oldalign;
	asi64(R2) = align;
	if (asi64(R1) < asi64(R2)) goto L2845;
	goto L2828;
L2845:
L2843:
	R1 = 0;
	R2 = 10;
	asi64(R3) = align;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 123;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2841:
L2828:
	return;
}

static u64 mc_libmcl_changeopndsize(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L2848;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2850;
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	b = asu64(R1);
	goto L2849;
L2850:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2849:
	asu64(R1) = b;
	goto L2846;
L2848:
	asu64(R1) = a;
	goto L2846;
L2846:
	return asu64(R1);
}

static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2853;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2853;
	asu64(R1) = a;
	goto L2851;
L2853:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = b;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L2855;
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2855:
	asu64(R1) = b;
	goto L2851;
L2851:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint(i64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = x;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2858;
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2858;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2858;
	R1 = (u64)&mc_libmcl_smallinttable;
	asi64(R2) = x;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8+8));
	goto L2856;
L2858:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2856;
L2856:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint0(i64 x, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2859;
L2859:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2862;
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getrealindex(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2861;
L2862:
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getr32index(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2861:
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2860;
L2860:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asr64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2863;
L2863:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabel(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2866;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	x = asi64(R1);
L2866:
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2864;
L2864:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabelmem(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asi64(R1) = x;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2867;
L2867:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmem(u64 d, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2870;
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2872;
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenxregvar(asu64(R1));
	goto L2868;
	goto L2871;
L2872:
	asi64(R1) = mode;
	asu64(R2) = d;
	asu64(R1) = mc_libmcl_mgenregvar(asu64(R2), asi64(R1));
	goto L2868;
L2871:
L2870:
	R1 = 0;
	reg = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2875;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2874;
L2875:
	R1 = 15;
	reg = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2874:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	if (!asi64(R1)) goto L2877;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2876;
L2877:
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asu64(R1) = Min(asu64(R1), asu64(R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2876:
	asu64(R1) = a;
	goto L2868;
L2868:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmemaddr(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2878;
L2878:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg0(i64 reg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2881;
	R1 = tou64("");
	R2 = tou64("1:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2881:
	asu64(R1) = a;
	goto L2879;
L2879:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = xreg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2884;
	R1 = tou64("");
	R2 = tou64("2:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2884:
	asu64(R1) = a;
	goto L2882;
L2882:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg(i64 reg, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2887;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedxregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2886;
L2887:
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2889;
	R1 = 8;
	size = asi64(R1);
L2889:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2891;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2891;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2891:
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2885;
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
L2886:
	goto L2885;
L2885:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregi(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	R2 = (u64)&pc_tables_psize;
	asi64(R3) = mode;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2892;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	goto L2892;
L2892:
	return asu64(R1);
}

static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	goto L2893;
L2893:
	return asu64(R1);
}

static u64 mc_libmcl_mgentemp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	i64 size;
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2896;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	goto L2894;
L2896:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pcltempflags;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2894;
L2894:
	return asu64(R1);
}

static i64 mc_libmcl_roundsizetg(i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2899;
	asi64(R1) = size;
	goto L2897;
L2899:
	asi64(R1) = size;
	R2 = 8;
	asi64(R3) = size;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L2897;
L2897:
	return asi64(R1);
}

static void mc_libmcl_merroropnd(u64 mess, i64 opndtype) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MCL Opnd not supported: # (#) [#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asi64(R2) = opndtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 mc_libmcl_mcreatefwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L2901;
L2901:
	return asi64(R1);
}

static void mc_libmcl_mdefinefwdlabel(i64 lab) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenextname(u64 s) {
    u64 R1, R2, R3; 
	struct $B30 str;
	u64 d;
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mc_libmcl_findnamesym(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L2905;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	mc_libmcl_addnamesym(asu64(R1));
L2905:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	goto L2903;
L2903:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregvar(u64 d, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	goto L2906;
L2906:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxregvar(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 8;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2907;
L2907:
	return asu64(R1);
}

static i64 mc_libmcl_getprimreg(u64 ax) {
    u64 R1, R2; 
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2910;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L2909;
L2910:
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
L2909:
	goto L2908;
L2908:
	return asi64(R1);
}

static void mc_libmcl_pushslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) += asi64(R1);
	return;
}

static void mc_libmcl_popslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_popstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) -= asi64(R1);
	return;
}

static void mc_libmcl_pushstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2915;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2915:
	return;
}

static void mc_libmcl_popstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2918;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2918:
	return;
}

static i64 mc_libmcl_getstringindex(u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2921;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_kk0used = asi64(R1);
	asi64(R1) = mc_decls_kk0used;
	goto L2919;
L2921:
	asu64(R1) = mc_decls_cstringlist;
	if (!asu64(R1)) goto L2923;
	asu64(R1) = s;
	asu64(R2) = mc_decls_cstringlist;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2923;
	asu64(R1) = mc_decls_cstringlist;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2919;
L2923:
	asu64(R1) = s;
	R2 = (u64)&mc_decls_cstringlist;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2919;
L2919:
	return asi64(R1);
}

static i64 mc_libmcl_addconst(u64 clist, i64 value) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 24;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = clist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = clist;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	goto L2924;
L2924:
	return asi64(R1);
}

static i64 mc_libmcl_getrealindex(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	R2 = (u64)&mc_decls_creallist;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2925;
L2925:
	return asi64(R1);
}

static i64 mc_libmcl_getr32index(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	R2 = (u64)&mc_decls_cr32list;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2926;
L2926:
	return asi64(R1);
}

static i64 mc_libmcl_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L2928:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L2932;
	asi64(R1) = n;
	goto L2927;
L2932:
	if (--asi64(av_1)) goto L2928;
	R1 = 0;
	goto L2927;
L2927:
	return asi64(R1);
}

static void mc_libmcl_axerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("AX ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("AASEQ:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static u64 mc_libmcl_newblocktemp(i64 size) {
    u64 R1, R2, R3; 
	struct $B3 str;
	u64 d;
	asi64(R1) = mc_decls_nblocktemps;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L2936;
	R1 = tou64("");
	R2 = tou64("Too many block temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2936:
	R1 = (u64)&mc_decls_nblocktemps;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$B#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_nblocktemps;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 8;
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 11;
	asu64(R2) = d;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = d;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pc_decls_currfunc;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_decls_blockdefs;
	asi64(R3) = mc_decls_nblocktemps;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	goto L2934;
L2934:
	return asu64(R1);
}

static u64 mc_libmcl_findnamesym(u64 s) {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2940;
L2938:
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2942;
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2937;
L2942:
	i += 1; if (i <= mc_libmcl_nnametable) goto L2938;
L2940:
	R1 = 0;
	goto L2937;
L2937:
	return asu64(R1);
}

static void mc_libmcl_addnamesym(u64 d) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 20;
	if (asi64(R1) >= asi64(R2)) goto L2945;
	asu64(R1) = d;
	R2 = (u64)&mc_libmcl_nametable;
	R3 = (u64)&mc_libmcl_nnametable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L2944;
L2945:
	R1 = tou64("");
	R2 = tou64("Ext nametab overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2944:
	return;
}

static void mc_libmcl_callproc(u64 cpname, u64 name, i64 lineno) {
	goto L2946;
L2946:
	return;
}

static u64 mc_libmcl_mgenstringx(u64 s) {
    u64 R1; 
	asu64(R1) = s;
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	goto L2947;
L2947:
	return asu64(R1);
}

static void mc_libmcl_clearreg(u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2950;
	R1 = 4;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2950:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2953;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2953;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2954;
	goto L2955;
L2953:
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2951;
	goto L2952;
L2954:
	asi64(R1) = mode;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgentemp(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	goto L2951;
	goto L2952;
L2955:
L2952:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2957;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2958;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2959;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2960;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2960;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2961;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2962;
	goto L2963;
L2957:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2965;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2965;
	R1 = 6;
	mode = asi64(R1);
	goto L2958;
	goto L2964;
L2965:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2964:
	goto L2956;
L2958:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2967;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2967;
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2966;
L2967:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2966:
	goto L2956;
L2959:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2969;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2970;
	goto L2971;
L2969:
	R1 = 65535;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L2968;
L2970:
	R1 = 4294967295;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L2968;
L2971:
L2968:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2973;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L2973;
	asu64(R1) = bx;
	ax = asu64(R1);
	goto L2972;
L2973:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2972:
	goto L2956;
L2960:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2956;
L2961:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2956;
L2962:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2956;
L2963:
// mc_stackmcl.getopnd.error:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = a;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("getopnd");
	pc_api_merror(asu64(R2), asu64(R1));
L2956:
	asu64(R1) = ax;
	goto L2951;
L2951:
	return asu64(R1);
}

static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2977;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2979;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L2979:
L2977:
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	goto L2975;
L2975:
	return asu64(R1);
}

static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg_m(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	goto L2980;
L2980:
	return asu64(R1);
}

static void mc_stackmcl_pushopnd(i64 n, i64 mode) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2983;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L2983:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2985;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2987;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2988;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2989;
	goto L2990;
L2987:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2992;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2993;
L2992:
	goto L2986;
L2988:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2995;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L2995;
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2993;
L2995:
	goto L2986;
L2989:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2993;
	goto L2986;
L2990:
L2986:
L2985:
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2997;
	asu64(R1) = ax;
	bx = asu64(R1);
	asi64(R1) = mode;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2999;
	R1 = 5;
	goto L2998;
L2999:
	R1 = 6;
L2998:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2997:
// mc_stackmcl.pushopnd.pushit:
L2993:
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&mc_decls_mstackdepth;
	(*toi64p(R1)) += 1;
	return;
}

static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3003;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3002;
L3003:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3006;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L3005;
L3006:
	asu64(R1) = ax;
	goto L3000;
L3005:
L3002:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3000;
L3000:
	return asu64(R1);
}

static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3010;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3009;
L3010:
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L3012;
	asu64(R1) = ax;
	goto L3007;
L3012:
L3009:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3007;
L3007:
	return asu64(R1);
}

static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3015;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3015;
	asu64(R1) = ax;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3015;
	R1 = 4;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	goto L3014;
L3015:
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3014:
	return;
}

static void mc_stackmcl_pushpcl(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L3018;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3018:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3020;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3020;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3020:
	return;
}

static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L3023;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3023:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3025;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L3025:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3027;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3026;
L3027:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3026:
	return;
}

static void mc_stackmcl_poppcl() {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L3030;
	R1 = tou64("");
	R2 = tou64("poppcl/underflow");
	pc_api_merror(asu64(R2), asu64(R1));
L3030:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3032;
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	R1 += (i64)R2-1;
	(*tou8p(R1)) -=1;
	goto L3028;
L3032:
	R1 = (u64)&mc_decls_noperands;
	(*toi64p(R1)) -=1;
L3028:
	return;
}

static void mc_stackmcl_duplpcl() {
    u64 R1, R2, R3, R4; 
	i64 mode;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 0;
	asi64(R3) = mode;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_stackmcl_getworkireg() {
    u64 R1, R2, R3; 
	i64 r;
	i64 av_1;
	R1 = 10;
	av_1 = asi64(R1);
L3035:
	R1 = 1;
	r = asi64(R1);
L3038:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3042;
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3042;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L3034;
L3042:
	r += 1; if (r <= 14) goto L3038;
	mc_stackmcl_savenextopnd();
	if (--asi64(av_1)) goto L3035;
	R1 = tou64("");
	R2 = tou64("No more work regs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3034;
L3034:
	return asi64(R1);
}

static i64 mc_stackmcl_getworkxreg() {
    u64 R1, R2, R3; 
	i64 r;
	R1 = 5;
	r = asi64(R1);
L3044:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3048;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3048;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L3043;
L3048:
	r += 1; if (r <= 16) goto L3044;
	R1 = tou64("");
	R2 = tou64("No more work xregs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3043;
L3043:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkregm(i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R2) = mode;
	asi64(R2) = mc_stackmcl_getworkreg(asi64(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L3049;
L3049:
	return asu64(R1);
}

static i64 mc_stackmcl_getworkreg(i64 mode) {
    u64 R1, R2; 
	i64 reg;
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3052;
	asi64(R1) = mc_stackmcl_getworkxreg();
	goto L3051;
L3052:
	asi64(R1) = mc_stackmcl_getworkireg();
L3051:
	goto L3050;
L3050:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3056;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3055;
L3056:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L3053;
L3055:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3060;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L3059;
L3060:
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3058;
L3059:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L3053;
L3058:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L3053;
L3053:
	return asu64(R1);
}

static void mc_stackmcl_saveopnd(i64 n, i64 allregs) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 mode;
	u64 tx;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3063;
	goto L3061;
L3063:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3065;
	asi64(R1) = allregs;
	if (asi64(R1)) goto L3068;
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L3069;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L3067;
L3069:
L3068:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3067:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3064;
L3065:
	asi64(R1) = allregs;
	if (asi64(R1)) goto L3072;
	asi64(R1) = reg;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3071;
	R2 = 6;
	if (asi64(R1) > asi64(R2)) goto L3071;
L3072:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L3071:
	R1 = 0;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3064:
	R1 = 3;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3061:
	return;
}

static void mc_stackmcl_saveopnds(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3076;
L3074:
	R1 = 0;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L3074;
L3076:
	return;
}

static void mc_stackmcl_savenextopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3080;
L3078:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3082;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3082;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L3077;
L3082:
	i += 1; if (i <= mc_decls_noperands) goto L3078;
L3080:
L3077:
	return;
}

static void mc_stackmcl_savenextxopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3086;
L3084:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3088;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3088;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L3083;
L3088:
	i += 1; if (i <= mc_decls_noperands) goto L3084;
L3086:
L3083:
	return;
}

static void mc_stackmcl_movetoreg(i64 newreg) {
    u64 R1, R2, R3; 
	i64 oldreg;
	i64 mode;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
// mc_stackmcl.movetoreg.retry:
L3090:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	oldreg = asi64(R1);
	asi64(R1) = oldreg;
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L3092;
	goto L3089;
L3092:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3094;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3096;
	R1 = tou64("");
	R2 = tou64("MOVE TO REG: XREG IN USE");
	pc_api_merror(asu64(R2), asu64(R1));
L3096:
	goto L3093;
L3094:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3098;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3101;
L3099:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L3103;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L3103;
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 6;
	asi64(R2) = newreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asi64(R3) = oldreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L3090;
L3103:
	i += 1; if (i <= mc_decls_noperands) goto L3099;
L3101:
L3098:
L3093:
	asi64(R1) = mode;
	asi64(R2) = oldreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newreg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3105;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3104;
L3105:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3104:
L3089:
	return;
}

static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3108;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3110;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3113;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3112;
L3113:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	goto L3106;
L3112:
L3110:
L3108:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3115;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3115:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3106;
L3106:
	return asu64(R1);
}

static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3118;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3118:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3116;
L3116:
	return asu64(R1);
}

static void mc_stackmcl_swapopnds(i64 m, i64 n) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = m;
	R1 += (i64)R2*8-8;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	R2 += (i64)R3*8-8;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	return;
}

static u64 mc_stackmcl_isimmload(i64 n) {
    u64 R1, R2; 
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3122;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3122;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3122;
	asu64(R1) = p;
	goto L3121;
L3122:
	R1 = 0;
L3121:
	goto L3120;
L3120:
	return asu64(R1);
}

static void mc_stackmcl_setnewzz(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_stackmcl_freeworkregs(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 i;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3127;
L3125:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3129;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3131;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3130;
L3131:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3130:
L3129:
	i += 1; if (i <= mc_decls_noperands) goto L3125;
L3127:
	return;
}

static void mc_stackmcl_swapopndregs(i64 reg2) {
    u64 R1, R2, R3; 
	i64 reg1;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3134;
	R1 = tou64("");
	R2 = tou64("SOR1");
	pc_api_merror(asu64(R2), asu64(R1));
L3134:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg1 = asi64(R1);
	asi64(R1) = reg1;
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L3136;
	goto L3132;
L3136:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3140;
L3137:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3142;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L3142;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	goto L3132;
L3142:
	i += -1; if (i >= 1) goto L3137;
L3140:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg2;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3132:
	return;
}

static u64 mc_stackmcl_makeopndind(u64 a, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3145;
	R1 = tou64("");
	R2 = tou64("makeopndind");
	pc_api_merror(asu64(R2), asu64(R1));
L3145:
	R1 = 0;
	asi64(R2) = mode;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3143;
L3143:
	return asu64(R1);
}

static u64 mc_stackmcl_makesimpleaddr(u64 ax) {
    u64 R1, R2, R3; 
	u64 bx;
	i64 newreg;
	i64 reg;
	i64 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3148;
	R1 = 0;
	reg = asi64(R1);
L3148:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3150;
	R1 = tou64("");
	R2 = tou64("MSA");
	pc_api_merror(asu64(R2), asu64(R1));
L3150:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3152;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3152;
	asi64(R1) = mc_stackmcl_getworkireg();
	newreg = asi64(R1);
	goto L3151;
L3152:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3153;
	asu64(R1) = ax;
	goto L3146;
	goto L3151;
L3153:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3154;
	asi64(R1) = regix;
	newreg = asi64(R1);
	goto L3151;
L3154:
	asi64(R1) = regix;
	newreg = asi64(R1);
L3151:
	R1 = 0;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3146;
L3146:
	return asu64(R1);
}

static void mc_stackmcl_checkallloaded() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3158;
L3156:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3160;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3160;
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = i;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3160:
	i += 1; if (i <= mc_decls_noperands) goto L3156;
L3158:
	return;
}

static u64 mc_stackmcl_stropndstack(i64 indent) {
    u64 R1, R2, R3; 
	struct $B20 str2;
	u64 s;
	u64 t;
	i64 fs;
	i64 i;
	i64 r;
	R1 = (u64)&mc_stackmcl_stropndstack_str;
	s = asu64(R1);
	asi64(R1) = indent;
	if (!asi64(R1)) goto L3163;
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("========================================#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L3162;
L3163:
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3162:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3166;
L3164:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L3170;
	case 2: goto L3171;
	case 3: goto L3172;
	case 4: goto L3173;
	default: goto L3169;
    };
// SWITCH
L3170:
	R1 = tou64("Z:");
	goto L3167;
L3171:
	R1 = tou64("Y:");
	goto L3167;
L3172:
	R1 = tou64("X:");
	goto L3167;
L3173:
	R1 = tou64("W:");
	goto L3167;
L3169:
	R1 = tou64("");
L3167:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3175;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3175;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3176;
	goto L3177;
L3175:
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3179;
	R1 = (u64)&mc_decls_xregnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3178;
L3179:
	R1 = (u64)&mc_decls_regnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3178:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3181;
	R1 = tou64("*");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3181:
	goto L3174;
L3176:
	R1 = tou64("T");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = i;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3174;
L3177:
	R1 = tou64("(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu8(R1) = pc_api_fpshortnames;
	R1 = toi64(tou8(R1));
	fs = asi64(R1);
	R1 = 1;
	pc_api_fpshortnames = asu8(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = pc_diags_stropnd(asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = fs;
	pc_api_fpshortnames = asu8(R1);
	R1 = tou64(")");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3174:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3183;
	R1 = tou64("@");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3183:
	R1 = tou64("<");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pstdnames;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(">");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = mc_decls_noperands;
	if (asi64(R1) >= asi64(R2)) goto L3185;
	R1 = tou64(", ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3185:
	i += 1; if (i <= mc_decls_noperands) goto L3164;
L3166:
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 50;
	R3 = (u64)&mc_stackmcl_stropndstack_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("WR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
L3186:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3190;
	R1 = tou64("1 ");
	goto L3189;
L3190:
	R1 = tou64("0 ");
L3189:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= 10) goto L3186;
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("XWR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
	asi64(R1) = mc_decls_xregmax;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3193;
L3191:
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3195;
	R1 = tou64("1 ");
	goto L3194;
L3195:
	R1 = tou64("0 ");
L3194:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= mc_decls_xregmax) goto L3191;
L3193:
	R1 = tou64(") hwstack:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_mstackdepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" noperands:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ncalldepth:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_ncalldepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = s;
	goto L3161;
L3161:
	return asu64(R1);
}

static void mc_stackmcl_showopndstack() {
    u64 R1; 
	R1 = 1;
	asu64(R1) = mc_stackmcl_stropndstack(asi64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_optim_peephole() {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 m;
	u64 m2;
	u64 m3;
	i64 lab1;
	i64 lab2;
	asu8(R1) = pc_decls_fpeephole;
	if (asu8(R1)) goto L3199;
	goto L3197;
L3199:
	asu64(R1) = mc_decls_mccode;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L3203;
L3200:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m2 = asu64(R1);
	asu64(R1) = m2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m3 = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3205;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3206;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L3207;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3208;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L3209;
	goto L3210;
L3205:
	goto L3202;
	goto L3204;
L3206:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3212;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3213;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L3214;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L3215;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L3215;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L3216;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L3216;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L3217;
	goto L3218;
L3212:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3220;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3220;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3220;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L3222;
	goto L3221;
L3222:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (asi64(R1)) goto L3224;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3223;
L3224:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3223:
L3221:
	goto L3219;
L3220:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3225;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3225;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L3225;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L3225;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3225;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3225:
L3219:
	goto L3211;
L3213:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3227;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L3228;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3228;
	R1 = 1;
	goto L3229;
L3228:
	R1 = 0;
L3229:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3227;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3227;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3227;
	R1 = 41;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3227:
	goto L3211;
L3214:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3231;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3231;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3231;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3231;
	R1 = 42;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3231:
	goto L3211;
L3215:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3233;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3233;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3233;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isconst(asu64(R1));
	if (!asi64(R1)) goto L3233;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 28;
	if (asi64(R4) != asi64(R5)) goto L3235;
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	goto L3234;
L3235:
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	asi64(R4) = -asi64(R4);
L3234:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3233:
	goto L3211;
L3216:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3237;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3237;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3237;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 52;
	if (asi64(R4) != asi64(R5)) goto L3239;
	R4 = 1;
	goto L3238;
L3239:
	R4 = -1;
L3238:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3237:
	goto L3211;
L3217:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3241;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3241;
	R1 = 25;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3241:
	goto L3211;
L3218:
L3211:
	goto L3204;
L3207:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L3243;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3245;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L3246;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3246;
	R1 = 1;
	goto L3247;
L3246:
	R1 = 0;
L3247:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3245;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3245;
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3245:
L3243:
	goto L3204;
L3208:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3249;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3251;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3251;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3251;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3251;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3251;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = m;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3251:
L3249:
	goto L3204;
L3209:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L3253;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L3253;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = m3;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L3253;
	asu64(R1) = m;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3253;
	R1 = (u64)&mc_decls_asmrevcond;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = m;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3253:
	goto L3204;
L3210:
L3204:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3203:
	asu64(R1) = m;
	if (asu64(R1)) goto L3200;
L3202:
L3197:
	return;
}

static i64 mc_optim_isreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3254;
L3254:
	return asi64(R1);
}

static i64 mc_optim_isreg0(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3257;
	R1 = 0;
	goto L3255;
L3257:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3259;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3259;
	R1 = 1;
	goto L3255;
L3259:
	R1 = 0;
	goto L3255;
L3255:
	return asi64(R1);
}

static i64 mc_optim_isreg10(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3262;
	R1 = 0;
	goto L3260;
L3262:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3264;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3264;
	R1 = 1;
	goto L3260;
L3264:
	R1 = 0;
	goto L3260;
L3260:
	return asi64(R1);
}

static i64 mc_optim_isreg00(u64 m) {
    u64 R1, R2, R3; 
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3267;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3267;
	R1 = 1;
	goto L3265;
L3267:
	R1 = 0;
	goto L3265;
L3265:
	return asi64(R1);
}

static i64 mc_optim_isconst(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3270;
	R1 = 0;
	goto L3268;
L3270:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3272;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3272;
	R1 = 1;
	goto L3268;
L3272:
	R1 = 0;
	goto L3268;
L3268:
	return asi64(R1);
}

static i64 mc_optim_sameoperand(u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 16;
	asu64(R2) = b;
	asu64(R3) = a;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3273;
L3273:
	return asi64(R1);
}

static i64 mc_optim_sameregopnd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3277;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3276;
L3277:
	R1 = 0;
	goto L3274;
L3276:
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3274;
L3274:
	return asi64(R1);
}

static u64 mc_optim_deletemcl(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3281;
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3280;
L3281:
	R1 = tou64("");
	R2 = tou64("delmcl?");
	pc_api_merror(asu64(R2), asu64(R1));
L3280:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	goto L3278;
L3278:
	return asu64(R1);
}

static i64 mc_optim_endr0(u64 m) {
    u64 R1, R2; 
	asu64(R1) = m;
	R2 = 48;
	R1 += (i64)R2;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L3282;
L3282:
	return asi64(R1);
}

static void mc_genss_genss(i64 obj) {
    u64 R1, R2, R3; 
	i64 index;
	u64 m;
	u64 pr;
	u64 codeaddr;
	u64 offsetptr;
	asu8(R1) = pc_decls_ssdone;
	if (!asu8(R1)) goto L3285;
	goto L3283;
L3285:
	asi64(R1) = mlinux_os_clock();
	pc_decls_sstime = asi64(R1);
	asi64(R1) = pc_api_mlabelno;
	mc_genss_initlib(asi64(R1));
	R1 = 0;
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_zdata = asu64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_idata = asu64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_code = asu64(R1);
	R1 = 0;
	mc_decls_ss_idatarelocs = asu64(R1);
	R1 = 0;
	mc_decls_ss_coderelocs = asu64(R1);
	R1 = 0;
	mc_decls_ss_nsymbols = asi64(R1);
	R1 = 1;
	mc_genss_switchseg(asi64(R1));
	R1 = 9999;
	mc_decls_aaseqno = asi64(R1);
	R1 = 0;
	mc_genss_extraparam = asu64(R1);
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 0;
	index = asi64(R1);
	goto L3287;
L3286:
	R1 = (u64)&index;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	mc_genss_doinstr(asu64(R2), asi64(R1));
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3287:
	asu64(R1) = m;
	if (asu64(R1)) goto L3286;
	R1 = 0;
	mc_genss_switchseg(asi64(R1));
	asu64(R1) = mc_decls_ss_zdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	if (!asi64(R1)) goto L3290;
	R1 = tou64("Zdata contains code or data");
	mc_libmcl_axerror(asu64(R1));
L3290:
	asi64(R1) = obj;
	if (!asi64(R1)) goto L3292;
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codeaddr = asu64(R1);
	asu64(R1) = mc_decls_riplist;
	pr = asu64(R1);
	goto L3296;
L3293:
	asu64(R1) = codeaddr;
	asu64(R2) = pr;
	R3 = 8;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	offsetptr = asu64(R1);
	asu64(R1) = pr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offsetptr;
	*tou32p(R2) -= asu32(R1);
	asu64(R1) = pr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pr = asu64(R1);
L3296:
	asu64(R1) = pr;
	if (asu64(R1)) goto L3293;
L3292:
	R1 = 1;
	pc_decls_ssdone = asu8(R1);
	asi64(R1) = mlinux_os_clock();
	asi64(R2) = pc_decls_sstime;
	asi64(R1) -= asi64(R2);
	pc_decls_sstime = asi64(R1);
L3283:
	return;
}

static void mc_genss_doinstr(u64 m, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	u64 d;
	u64 e;
	i64 x;
	i64 offset;
	i64 shortjmp;
	i64 n;
	i64 av_1;
	i64 av_2;
	asu64(R1) = mc_genss_currdata;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1024;
	if (asi64(R1) >= asi64(R2)) goto L3299;
	asu64(R1) = mc_genss_currdata;
	mc_genss_bufferexpand(asu64(R1));
L3299:
	R1 = 0;
	R2 = R1;
	mc_genss_usesizeb = asu8(R2);
	R2 = R1;
	mc_genss_nowmask = asu8(R2);
	R2 = R1;
	mc_genss_f3override = asu8(R2);
	R2 = R1;
	mc_genss_f2override = asu8(R2);
	R2 = R1;
	mc_genss_addroverride = asu8(R2);
	R2 = R1;
	mc_genss_sizeoverride = asu8(R2);
	mc_genss_rex = asu8(R1);
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = m;
	R2 = 36;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	mc_decls_aaseqno = asi64(R1);
	R1 = 0;
	mc_genss_ripentry = asu64(R1);
	asu64(R1) = m;
	mc_genss_currmcl = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L3303;
	case 2: goto L3304;
	case 3: case 8: goto L3426;
	case 4: goto L3307;
	case 5: goto L3305;
	case 6: goto L3306;
	case 7: case 23: case 35: case 92: case 93: case 150: goto L3302;
	case 9: goto L3314;
	case 10: case 151: goto L3335;
	case 11: goto L3349;
	case 12: goto L3344;
	case 13: goto L3345;
	case 14: goto L3350;
	case 15: goto L3408;
	case 16: goto L3392;
	case 17: goto L3393;
	case 18: goto L3351;
	case 19: goto L3352;
	case 20: goto L3353;
	case 21: goto L3319;
	case 22: goto L3340;
	case 24: goto L3341;
	case 25: goto L3320;
	case 26: goto L3321;
	case 27: goto L3354;
	case 28: case 29: case 30: case 31: case 38: case 39: case 40: case 42: goto L3348;
	case 32: case 33: case 36: case 37: case 50: case 51: goto L3347;
	case 34: goto L3355;
	case 41: goto L3386;
	case 43: case 44: case 45: case 46: case 47: case 48: case 49: goto L3385;
	case 52: case 53: goto L3346;
	case 54: goto L3336;
	case 55: goto L3337;
	case 56: goto L3338;
	case 57: goto L3339;
	case 58: goto L3391;
	case 59: case 60: goto L3422;
	case 61: case 62: goto L3425;
	case 63: case 65: case 67: case 69: case 71: case 112: case 113: goto L3394;
	case 64: case 66: case 68: case 70: case 72: case 114: case 115: goto L3395;
	case 73: goto L3398;
	case 74: case 75: goto L3399;
	case 76: case 78: goto L3396;
	case 77: case 79: case 80: case 81: goto L3397;
	case 82: goto L3402;
	case 83: goto L3403;
	case 84: goto L3404;
	case 85: goto L3405;
	case 86: goto L3406;
	case 87: goto L3407;
	case 88: goto L3401;
	case 89: goto L3400;
	case 90: case 91: goto L3418;
	case 94: case 95: case 96: goto L3410;
	case 97: case 98: case 99: goto L3411;
	case 100: case 101: case 102: case 103: goto L3412;
	case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: goto L3409;
	case 116: goto L3328;
	case 117: goto L3329;
	case 118: goto L3330;
	case 119: goto L3331;
	case 120: goto L3333;
	case 121: goto L3334;
	case 122: goto L3332;
	case 123: goto L3369;
	case 124: case 125: case 126: case 127: goto L3356;
	case 128: goto L3390;
	case 129: case 130: case 131: goto L3387;
	case 132: goto L3388;
	case 133: goto L3389;
	case 134: goto L3413;
	case 135: goto L3414;
	case 136: goto L3415;
	case 137: goto L3416;
	case 138: goto L3417;
	case 139: goto L3421;
	case 140: goto L3424;
	case 141: goto L3419;
	case 142: case 143: case 144: case 145: case 146: case 147: case 148: goto L3420;
	case 149: goto L3423;
	default: goto L3302;
    };
// SWITCH
L3303:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	goto L3300;
L3304:
	goto L3300;
L3305:
	goto L3300;
L3306:
	goto L3300;
L3307:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3309;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3310;
	goto L3311;
L3309:
	goto L3308;
L3310:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 2;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mc_genss_currseg;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3313;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
L3313:
	asu64(R1) = d;
	mc_genss_dofwdrefs(asu64(R1));
	goto L3308;
L3311:
L3308:
	goto L3300;
L3314:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3316;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L3315;
L3316:
	asu64(R1) = mc_decls_labeldeftable;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
L3315:
	R1 = 2;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mc_genss_currseg;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3318;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
L3318:
	asu64(R1) = d;
	mc_genss_dofwdrefs(asu64(R1));
	goto L3300;
L3319:
	asu64(R1) = a;
	mc_genss_do_call(asu64(R1));
	goto L3300;
L3320:
	asu64(R1) = m;
	asu64(R2) = a;
	mc_genss_do_jmp(asu64(R2), asu64(R1));
	goto L3300;
L3321:
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 7;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3323;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3325;
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	R2 = 4;
	asi64(R1) -= asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3324;
L3325:
	R1 = 112;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3324:
	goto L3322;
L3323:
	asu64(R1) = d;
	asu64(R2) = m;
	asi64(R1) = mc_genss_checkshortjump(asu64(R2), asu64(R1));
	shortjmp = asi64(R1);
	asi64(R1) = shortjmp;
	if (asi64(R1)) goto L3327;
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3326;
L3327:
	R1 = 112;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel8(asu64(R1));
L3326:
L3322:
	goto L3300;
L3328:
	R1 = 1;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3300;
L3329:
	R1 = 2;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3300;
L3330:
	R1 = 4;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3300;
L3331:
	R1 = 8;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3300;
L3332:
	R1 = 1;
	mc_genss_switchseg(asi64(R1));
	goto L3300;
L3333:
	R1 = 2;
	mc_genss_switchseg(asi64(R1));
	goto L3300;
L3334:
	R1 = 3;
	mc_genss_switchseg(asi64(R1));
	goto L3300;
L3335:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3336:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 152;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3337:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3338:
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3339:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3340:
	R1 = 195;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3341:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3343;
	R1 = tou64("retn?");
	mc_libmcl_axerror(asu64(R1));
L3343:
	R1 = 194;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genword(asi64(R1));
	goto L3300;
L3344:
	asu64(R1) = a;
	mc_genss_do_push(asu64(R1));
	goto L3300;
L3345:
	asu64(R1) = a;
	mc_genss_do_pop(asu64(R1));
	goto L3300;
L3346:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_inc(asu64(R2), asi64(R1));
	goto L3300;
L3347:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_neg(asu64(R2), asi64(R1));
	goto L3300;
L3348:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_arith(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3349:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_mov(asu64(R2), asu64(R1));
	goto L3300;
L3350:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_lea(asu64(R2), asu64(R1));
	goto L3300;
L3351:
	R1 = 190;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movsx(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3352:
	R1 = 182;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movsx(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3353:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_movsxd(asu64(R2), asu64(R1));
	goto L3300;
L3354:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_exch(asu64(R2), asu64(R1));
	goto L3300;
L3355:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_imul2(asu64(R2), asu64(R1));
	goto L3300;
L3356:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3358;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	n = asi64(R1);
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3360;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3361;
	goto L3362;
L3360:
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3365;
L3363:
	R1 = 144;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L3363;
L3365:
	goto L3359;
L3361:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3368;
L3366:
	R1 = 0;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_2)) goto L3366;
L3368:
	goto L3359;
L3362:
	asi64(R1) = n;
	R2 = (u64)&mc_decls_ss_zdatalen;
	*toi64p(R2) += asi64(R1);
L3359:
	goto L3357;
L3358:
	R1 = tou64("resb?");
	mc_libmcl_axerror(asu64(R1));
L3357:
	goto L3300;
L3369:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3371;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	asi64(R1) = x;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3374;
	asi64(R1) = x;
	R2 = 16384;
	if (asi64(R1) <= asi64(R2)) goto L3373;
L3374:
	R1 = tou64("align2");
	mc_libmcl_axerror(asu64(R1));
L3373:
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = mc_genss_currseg;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3376;
	goto L3378;
L3377:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3381;
	R1 = 144;
	goto L3380;
L3381:
	R1 = 0;
L3380:
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3378:
	asu64(R1) = mc_genss_currdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	asi64(R2) = x;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L3377;
	goto L3375;
L3376:
	goto L3383;
L3382:
	R1 = (u64)&mc_decls_ss_zdatalen;
	(*toi64p(R1)) += 1;
L3383:
	asi64(R1) = mc_decls_ss_zdatalen;
	asi64(R2) = x;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L3382;
L3375:
	goto L3370;
L3371:
	R1 = tou64("align?");
	mc_libmcl_axerror(asu64(R1));
L3370:
	goto L3300;
L3385:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_shift(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3386:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_test(asu64(R2), asu64(R1));
	goto L3300;
L3387:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_loop(asu64(R2), asi64(R1));
	goto L3300;
L3388:
	R1 = 4;
	asu64(R2) = a;
	mc_genss_do_jcxz(asu64(R2), asi64(R1));
	goto L3300;
L3389:
	R1 = 8;
	asu64(R2) = a;
	mc_genss_do_jcxz(asu64(R2), asi64(R1));
	goto L3300;
L3390:
	R1 = 215;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3391:
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_genss_do_setcc(asi64(R2), asu64(R1));
	goto L3300;
L3392:
	R1 = 4;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movxmm(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3393:
	R1 = 8;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movxmm(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3394:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3395:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3396:
	R1 = 4;
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_logicxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3397:
	R1 = 8;
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_logicxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3398:
	R1 = 47;
	R2 = 0;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3399:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 102;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3400:
	R1 = 243;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_convertfloat(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3401:
	R1 = 242;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_convertfloat(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3402:
	R1 = 45;
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3403:
	R1 = 45;
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3404:
	R1 = 44;
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3405:
	R1 = 44;
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3406:
	R1 = 243;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_float(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3407:
	R1 = 242;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_float(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3408:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = m;
	R4 = 34;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_genss_do_cmovcc(asi64(R3), asu64(R2), asu64(R1));
	goto L3300;
L3409:
	R1 = 217;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3410:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asu64(R3) = a;
	mc_genss_do_fmem(asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3411:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R3) = a;
	mc_genss_do_fmem(asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3412:
	R1 = 222;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3413:
	R1 = 166;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3414:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3415:
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3416:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3417:
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3418:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movdqx(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3419:
	R1 = 219;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 227;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3420:
	R1 = 217;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3421:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_popcnt(asu64(R2), asu64(R1));
	goto L3300;
L3422:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_bsf(asu64(R3), asu64(R2), asi64(R1));
	goto L3300;
L3423:
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 162;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3300;
L3424:
	asu64(R1) = a;
	mc_genss_do_bswap(asu64(R1));
	goto L3300;
L3425:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = m;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_dshift(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3300;
L3426:
	goto L3300;
L3302:
	msysc_m$print_startcon();
	R1 = tou64("*** Can't do opcode");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mc_decls_mclnames;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M.OPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M_HALT=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 151;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("STOPPING");
	mc_libmcl_axerror(asu64(R1));
L3300:
	return;
}

static void mc_genss_start() {
    u64 R1, R2, R3; 
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genss_genword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_addword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_gendword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_adddword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_genqword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_addqword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_genopnd(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 s;
	i64 x;
	i64 length;
	r32 x32;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3433;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	size = asi64(R1);
L3433:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3435;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L3436;
	goto L3437;
L3435:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 100;
	if (asi64(R1) <= asi64(R2)) goto L3439;
	R1 = 1024;
	asi64(R2) = length;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = mc_genss_currdata;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
L3439:
	goto L3441;
L3440:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3441:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L3440;
	goto L3431;
	goto L3434;
L3436:
	msysc_m$print_startcon();
	R1 = tou64("GENSS/NAME OPND");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3434;
L3437:
L3434:
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3444;
	asi64(R1) = size;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3444;
	R1 = tou64("8/16-BIT RELOC");
	mc_libmcl_axerror(asu64(R1));
L3444:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3446;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3447;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3448;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3449;
	goto L3450;
L3446:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3445;
L3447:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genword(asi64(R1));
	goto L3445;
L3448:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3452;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3453;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3454;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3454;
	goto L3455;
L3452:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3451;
L3453:
	asu64(R1) = a;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	x32 = asr32(R1);
	asr32(R1) = x32;
	asi64(R1) = asi64(R1);
	mc_genss_gendword(asi64(R1));
	goto L3451;
L3454:
	asu64(R1) = a;
	mc_genss_genabs32(asu64(R1));
	goto L3451;
L3455:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("OPND/4/VALTYPE?");
	mc_libmcl_axerror(asu64(R1));
L3451:
	goto L3445;
L3449:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3457;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3458;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3459;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3459;
	goto L3460;
L3457:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genqword(asi64(R1));
	goto L3456;
L3458:
	asu64(R1) = a;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	mc_genss_genqword(asi64(R1));
	goto L3456;
L3459:
	asu64(R1) = a;
	mc_genss_genabs64(asu64(R1));
	goto L3456;
L3460:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("OPND/8/VALTYPE?");
	mc_libmcl_axerror(asu64(R1));
L3456:
	goto L3445;
L3450:
L3445:
L3431:
	return;
}

static void mc_genss_addrelocitem(i64 reloctype, u64 d) {
    u64 R1, R2, R3; 
	u64 r;
	i64 stindex;
	i64 adjust;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
	stindex = asi64(R1);
	R1 = 4;
	adjust = asi64(R1);
	asi64(R1) = reloctype;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3463;
	R1 = 8;
	adjust = asi64(R1);
L3463:
	R1 = 32;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	r = asu64(R1);
	asu64(R1) = mc_genss_currrelocs;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = reloctype;
	asu64(R2) = r;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asi64(R2) = adjust;
	asi64(R1) -= asi64(R2);
	asu64(R2) = r;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = stindex;
	asu64(R2) = r;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_genss_nrelocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	mc_genss_currrelocs = asu64(R1);
	return;
}

static i64 mc_genss_getstindex(u64 d) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = d;
	R2 = 96;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3466;
	asi64(R1) = mc_decls_ss_nsymbols;
	asi64(R2) = mc_decls_ss_symboltablesize;
	if (asi64(R1) < asi64(R2)) goto L3468;
	mc_genss_extendsymboltable();
L3468:
	R1 = (u64)&mc_decls_ss_nsymbols;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 96;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = d;
	asu64(R2) = mc_decls_ss_symboltable;
	asu64(R3) = d;
	R4 = 96;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3470;
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3472;
	R1 = 1;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3472:
L3470:
L3466:
	asu64(R1) = d;
	R2 = 96;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L3464;
L3464:
	return asi64(R1);
}

static void mc_genss_genrel32(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3475;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3473;
L3475:
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3477;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3478;
	goto L3479;
L3477:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) == asi64(R2)) goto L3481;
	R1 = tou64("Rel label across segments");
	mc_libmcl_axerror(asu64(R1));
L3481:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R2) = mc_genss_getcurrdatalen(asi64(R2));
	R3 = 4;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3476;
L3478:
	R1 = 0;
	R2 = 4;
	R3 = 3;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	goto L3476;
L3479:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 4;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3476:
L3473:
	return;
}

static u64 mc_genss_getdef(u64 a, i64 dneeded) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3485;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3484;
L3485:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3487;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3488;
	goto L3489;
L3487:
	asu64(R1) = mc_decls_labeldeftable;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L3482;
	goto L3486;
L3488:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3491;
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3493;
	R1 = 1;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3493:
L3491:
	asu64(R1) = d;
	goto L3482;
	goto L3486;
L3489:
L3486:
L3484:
	asi64(R1) = dneeded;
	if (!asi64(R1)) goto L3495;
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("getdef/no def");
	mc_libmcl_axerror(asu64(R1));
L3495:
	R1 = 0;
	goto L3482;
L3482:
	return asu64(R1);
}

static void mc_genss_genabs32(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3498;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3499;
	goto L3500;
L3498:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
	goto L3497;
L3499:
	asi64(R1) = mc_genss_currseg;
	R2 = 2;
	R3 = 4;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3503;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3502;
L3503:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3501;
L3502:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3501:
	goto L3497;
L3500:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3497:
	return;
}

static void mc_genss_genabs64(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3506;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3507;
	goto L3508;
L3506:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
	goto L3505;
L3507:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	R3 = 5;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3511;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3510;
L3511:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_genqword(asi64(R1));
	goto L3509;
L3510:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3509:
	goto L3505;
L3508:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3505:
	return;
}

static i64 mc_genss_getrel32(u64 d, i64 offset) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3514;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) == asi64(R2)) goto L3516;
	R1 = tou64("Rel label across segments2");
	mc_libmcl_axerror(asu64(R1));
L3516:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	goto L3513;
L3514:
	R1 = 2147483647;
L3513:
	goto L3512;
L3512:
	return asi64(R1);
}

static void mc_genss_dofwdrefs(u64 d) {
    u64 R1, R2, R3; 
	u64 f;
	i64 offset;
	i64 seg;
	u64 p8;
	u64 p32;
	u64 p64;
	u64 data;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3519;
	goto L3517;
L3519:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L3521;
L3520:
	asu64(R1) = f;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	asu64(R1) = f;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3524;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3525;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3525;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3526;
	goto L3527;
L3524:
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p32 = asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = 4;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p32;
	*toi32p(R2) = asi32(R1);
	goto L3523;
L3525:
	asu64(R1) = f;
	R2 = 14;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3529;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3531;
	goto L3532;
L3529:
	asu64(R1) = mc_decls_ss_code;
	data = asu64(R1);
	goto L3528;
L3530:
	R1 = tou64("Fwd ref in zdata");
	mc_libmcl_axerror(asu64(R1));
	goto L3528;
L3531:
	asu64(R1) = mc_decls_ss_idata;
	data = asu64(R1);
	goto L3528;
L3532:
L3528:
	asi64(R1) = offset;
	asu64(R2) = data;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p32 = asu64(R1);
	asu64(R1) = f;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3534;
	asu64(R1) = p32;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = p32;
	*toi32p(R2) = asi32(R1);
	goto L3533;
L3534:
	asu64(R1) = p32;
	p64 = asu64(R1);
	asu64(R1) = p64;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = p64;
	*toi64p(R2) = asi64(R1);
L3533:
	goto L3523;
L3526:
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p8 = asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p8;
	*tou8p(R2) = asu8(R1);
	goto L3523;
L3527:
	msysc_m$print_startcon();
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = f;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("DOFWDREFS/CAN'T DO RELTYPE");
	mc_libmcl_axerror(asu64(R1));
L3523:
	asu64(R1) = f;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
L3521:
	asu64(R1) = f;
	if (asu64(R1)) goto L3520;
L3517:
	return;
}

static void mc_genss_genrex() {
    u64 R1, R2, R3; 
	asu8(R1) = mc_genss_f2override;
	if (!asu8(R1)) goto L3537;
	R1 = 242;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3537:
	asu8(R1) = mc_genss_f3override;
	if (!asu8(R1)) goto L3539;
	R1 = 243;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3539:
	asu8(R1) = mc_genss_sizeoverride;
	if (!asu8(R1)) goto L3541;
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3541:
	asu8(R1) = mc_genss_addroverride;
	if (!asu8(R1)) goto L3543;
	R1 = 103;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3543:
	asu8(R1) = mc_genss_nowmask;
	if (!asu8(R1)) goto L3545;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L3545:
	asu8(R1) = mc_genss_rex;
	if (!asu8(R1)) goto L3547;
	asu8(R1) = mc_genss_rex;
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = 64;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3547:
	return;
}

static i64 mc_genss_isbytesized(i64 x) {
    u64 R1, R2; 
	R1 = -128;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3549;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3549;
	R1 = 1;
	goto L3550;
L3549:
	R1 = 0;
L3550:
	goto L3548;
L3548:
	return asi64(R1);
}

static i64 mc_genss_isdwordsized(i64 x) {
    u64 R1, R2; 
	R1 = -2147483648;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3552;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L3552;
	R1 = 1;
	goto L3553;
L3552:
	R1 = 0;
L3553:
	goto L3551;
L3551:
	return asi64(R1);
}

static void mc_genss_genamode(u64 a, u64 am) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 pr;
	R1 = (u64)&am;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&am;
	R2 = 2;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3556;
	R1 = (u64)&am;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3556:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3558;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3559;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3560;
	goto L3561;
L3558:
	goto L3557;
L3559:
	R1 = (u64)&am;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3557;
L3560:
	R1 = (u64)&am;
	R2 = 2;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L3563;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pr = asu64(R1);
	asu64(R1) = mc_decls_riplist;
	asu64(R2) = pr;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_genss_currdata;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pr;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pr;
	R2 = R1;
	mc_decls_riplist = asu64(R2);
	mc_genss_ripentry = asu64(R1);
L3563:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3565;
	goto L3566;
L3565:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3568;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3568;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3569;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3569;
	goto L3570;
L3568:
	asu64(R1) = a;
	mc_genss_genabs32(asu64(R1));
	goto L3567;
L3569:
	R1 = (u64)&am;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	goto L3567;
L3570:
	R1 = tou64("genam/3");
	mc_libmcl_axerror(asu64(R1));
L3567:
	goto L3564;
L3566:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("GENAMODE/MODE?");
	mc_libmcl_axerror(asu64(R1));
L3564:
	goto L3557;
L3561:
	R1 = tou64("genamode size 2/8");
	mc_libmcl_axerror(asu64(R1));
L3557:
	return;
}

static void mc_genss_setopsize(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3573;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3574;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3575;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3576;
	goto L3577;
L3573:
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	goto L3572;
L3574:
	goto L3572;
L3575:
	goto L3572;
L3576:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	goto L3572;
L3577:
	R1 = tou64("Operand size not set");
	mc_libmcl_axerror(asu64(R1));
L3572:
	return;
}

static i64 mc_genss_getdispsize(u64 a, u64 offset) {
    u64 R1, R2; 
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L3580;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3583;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3582;
L3583:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offset;
	*toi32p(R2) += asi32(R1);
	goto L3581;
L3582:
	R1 = 4;
	goto L3578;
L3581:
L3580:
	asu64(R1) = offset;
	asi32(R1) = *toi32p(R1);
	if (!asi32(R1)) goto L3585;
	asu64(R1) = offset;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_genss_isbytesized(asi64(R1));
	if (!asi64(R1)) goto L3587;
	R1 = 1;
	goto L3586;
L3587:
	R1 = 4;
L3586:
	goto L3584;
L3585:
	R1 = 0;
L3584:
	goto L3578;
L3578:
	return asi64(R1);
}

static void mc_genss_checkhighreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3590;
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3590:
	return;
}

static void mc_genss_do_loop(u64 a, i64 opc) {
    u64 R1, R2, R3; 
	i64 offset;
	R1 = 9;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asu64(R3) = a;
	asu64(R2) = mc_genss_getdef(asu64(R3), asi64(R2));
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3593;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3595;
	R1 = tou64("loop jmp out of range");
	mc_libmcl_axerror(asu64(R1));
L3595:
	asi64(R1) = opc;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3592;
L3593:
	R1 = tou64("Can't do loopxx fwd jump");
	mc_libmcl_axerror(asu64(R1));
L3592:
	return;
}

static void mc_genss_do_jcxz(u64 a, i64 opsize) {
    u64 R1, R2, R3; 
	i64 offset;
	R1 = 10;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asu64(R3) = a;
	asu64(R2) = mc_genss_getdef(asu64(R3), asi64(R2));
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3598;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3600;
	R1 = tou64("jcxz jmp out of range");
	mc_libmcl_axerror(asu64(R1));
L3600:
	asi64(R1) = opsize;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3602;
	R1 = 103;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3602:
	R1 = 227;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3597;
L3598:
	R1 = tou64("Can't do jcxz fwd jump");
	mc_libmcl_axerror(asu64(R1));
L3597:
	return;
}

static void mc_genss_do_call(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3605;
	goto L3606;
L3605:
	R1 = 232;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3604;
L3606:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3608;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3609;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3609;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3609;
	goto L3610;
L3608:
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L3607;
L3609:
	R1 = tou64("call[]size");
	mc_libmcl_axerror(asu64(R1));
	goto L3607;
L3610:
L3607:
	asu64(R1) = a;
	R2 = 2;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
L3604:
	return;
}

static void mc_genss_do_jmp(u64 a, u64 m) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	i64 offset;
	i64 shortjmp;
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3613;
	goto L3614;
L3613:
	R1 = 11;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3616;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) <= asi64(R2)) goto L3616;
	R1 = 235;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3615;
L3616:
	R1 = 0;
	shortjmp = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3618;
	asu64(R1) = d;
	asu64(R2) = m;
	asi64(R1) = mc_genss_checkshortjump(asu64(R2), asu64(R1));
	shortjmp = asi64(R1);
L3618:
	asi64(R1) = shortjmp;
	if (asi64(R1)) goto L3620;
	R1 = 233;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3619;
L3620:
	R1 = 235;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel8(asu64(R1));
L3619:
L3615:
	goto L3612;
L3614:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3622;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3623;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3623;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3623;
	goto L3624;
L3622:
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L3621;
L3623:
	R1 = tou64("jmp[]size");
	mc_libmcl_axerror(asu64(R1));
	goto L3621;
L3624:
L3621:
	asu64(R1) = a;
	R2 = 4;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
L3612:
	return;
}

static i64 mc_genss_getcurrdatalen(i64 id) {
    u64 R1, R2; 
	asi64(R1) = mc_genss_currseg;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3627;
	asi64(R1) = mc_decls_ss_zdatalen;
	goto L3625;
L3627:
	asu64(R1) = mc_genss_currdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	goto L3625;
L3625:
	return asi64(R1);
}

static void mc_genss_do_cmovcc(i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3630;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3630;
	R1 = tou64("1:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3630:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3632;
	R1 = tou64("cmov/byte");
	mc_libmcl_axerror(asu64(R1));
L3632:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3904;
	asi64(R4) = cond;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_fmem(u64 a, i64 freal, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	i64 am;
	i64 regcode;
	i64 mf;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3635;
	R1 = tou64("fmem/not mem");
	mc_libmcl_axerror(asu64(R1));
L3635:
	asi64(R1) = freal;
	if (!asi64(R1)) goto L3637;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3639;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3640;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3641;
	R2 = 16;
	if (asu64(R1) == asu64(R2)) goto L3641;
	goto L3642;
L3639:
	R1 = 0;
	mf = asi64(R1);
	goto L3638;
L3640:
	R1 = 2;
	mf = asi64(R1);
	goto L3638;
L3641:
	R1 = 1;
	mf = asi64(R1);
	asi64(R1) = code;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3644;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3645;
	goto L3646;
L3644:
	R1 = 5;
	code = asi64(R1);
	goto L3643;
L3645:
	R1 = 7;
	code = asi64(R1);
	goto L3643;
L3646:
	R1 = tou64("r80 not allowed");
	mc_libmcl_axerror(asu64(R1));
L3643:
	goto L3638;
L3642:
	msysc_m$print_startcon();
	R1 = tou64("SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("fmem size");
	mc_libmcl_axerror(asu64(R1));
L3638:
	goto L3636;
L3637:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3648;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3649;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3650;
	goto L3651;
L3648:
	R1 = 3;
	mf = asi64(R1);
	goto L3647;
L3649:
	R1 = 1;
	mf = asi64(R1);
	goto L3647;
L3650:
	R1 = 3;
	mf = asi64(R1);
	asi64(R1) = code;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3653;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3654;
	goto L3655;
L3653:
	R1 = 5;
	code = asi64(R1);
	goto L3652;
L3654:
	R1 = 7;
	code = asi64(R1);
	goto L3652;
L3655:
	R1 = tou64("fst i64?");
	mc_libmcl_axerror(asu64(R1));
L3652:
	goto L3647;
L3651:
	R1 = tou64("fmem int size");
	mc_libmcl_axerror(asu64(R1));
L3647:
L3636:
	asu64(R1) = a;
	asi64(R2) = code;
	R3 = 217;
	asi64(R4) = mf;
	R5 = 1;
	asi64(R4) <<= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void mc_genss_genrel8(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3658;
	R1 = 0;
	R2 = 6;
	R3 = 3;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3657;
L3658:
	R1 = tou64("genrel8");
	mc_libmcl_axerror(asu64(R1));
L3657:
	return;
}

static i64 mc_genss_checkshortjump(u64 m, u64 d) {
    u64 R1, R2, R3; 
	i64 n;
	u64 a;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L3661;
L3660:
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3664;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3665;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3665;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L3666;
	goto L3667;
L3664:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3669;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3670;
	goto L3671;
L3669:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 100;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L3673;
	R1 = 1;
	goto L3659;
L3673:
	goto L3668;
L3670:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L3675;
	R1 = 1;
	goto L3659;
L3675:
	goto L3668;
L3671:
L3668:
	goto L3663;
L3665:
	goto L3663;
L3666:
	R1 = 0;
	goto L3659;
	goto L3663;
L3667:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L3663:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3661:
	asu64(R1) = m;
	if (!asu64(R1)) goto L3676;
	asi64(R1) = n;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L3660;
L3676:
	R1 = 0;
	goto L3659;
L3659:
	return asi64(R1);
}

static u64 mc_genss_addfwdref(u64 p, i64 offset, i64 reltype, i64 seg) {
    u64 R1, R2, R3; 
	u64 q;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = q;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = reltype;
	asu64(R2) = q;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = seg;
	asu64(R2) = q;
	R3 = 14;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	goto L3677;
L3677:
	return asu64(R1);
}

static void mc_genss_switchseg(i64 newseg) {
    u64 R1, R2; 
	asi64(R1) = newseg;
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) != asi64(R2)) goto L3680;
	goto L3678;
L3680:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3682;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3683;
	goto L3684;
L3682:
	asu64(R1) = mc_genss_currrelocs;
	mc_decls_ss_coderelocs = asu64(R1);
	asi64(R1) = mc_genss_nrelocs;
	mc_decls_ss_ncoderelocs = asi64(R1);
	goto L3681;
L3683:
	asu64(R1) = mc_genss_currrelocs;
	mc_decls_ss_idatarelocs = asu64(R1);
	asi64(R1) = mc_genss_nrelocs;
	mc_decls_ss_nidatarelocs = asi64(R1);
	goto L3681;
L3684:
L3681:
	asi64(R1) = newseg;
	mc_genss_currseg = asi64(R1);
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3686;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3687;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3688;
	goto L3689;
L3686:
	asu64(R1) = mc_decls_ss_code;
	mc_genss_currdata = asu64(R1);
	asu64(R1) = mc_decls_ss_coderelocs;
	mc_genss_currrelocs = asu64(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	mc_genss_nrelocs = asi64(R1);
	goto L3685;
L3687:
	asu64(R1) = mc_decls_ss_idata;
	mc_genss_currdata = asu64(R1);
	asu64(R1) = mc_decls_ss_idatarelocs;
	mc_genss_currrelocs = asu64(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	mc_genss_nrelocs = asi64(R1);
	goto L3685;
L3688:
	asu64(R1) = mc_decls_ss_zdata;
	mc_genss_currdata = asu64(R1);
	goto L3685;
L3689:
L3685:
L3678:
	return;
}

static void mc_genss_do_popcnt(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3692;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3694;
	R1 = 8;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3694:
L3692:
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 4024;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_bsf(u64 a, u64 b, i64 opc) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3697;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3699;
	R1 = 8;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3699:
L3697:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3701;
	R1 = tou64("bsf size");
	mc_libmcl_axerror(asu64(R1));
L3701:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_extendsymboltable() {
    u64 R1, R2, R3; 
	u64 oldsymboltable;
	i64 oldsymboltablesize;
	i64 i;
	asi64(R1) = mc_decls_ss_symboltablesize;
	oldsymboltablesize = asi64(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	oldsymboltable = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_ss_symboltablesize;
	*toi64p(R2) *= asi64(R1);
	R1 = 8;
	asi64(R2) = mc_decls_ss_symboltablesize;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_ss_symboltable = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3705;
L3703:
	asu64(R1) = oldsymboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = mc_decls_ss_symboltable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L3703;
L3705:
	R1 = 8;
	asi64(R2) = oldsymboltablesize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = oldsymboltable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_initlib(i64 nlabels) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	u64 d;
	i64 i;
	R1 = 262144;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_ss_symboltable = asu64(R1);
	R1 = 32768;
	mc_decls_ss_symboltablesize = asi64(R1);
	R1 = 0;
	mc_decls_ss_nsymbols = asi64(R1);
	asi64(R1) = nlabels;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_labeldeftable = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlabels;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3709;
L3707:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	R2 = R1;
	asu64(R3) = mc_decls_labeldeftable;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	d = asu64(R1);
	asi64(R1) = i;
	asu64(R2) = d;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("l#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= nlabels) goto L3707;
L3709:
	return;
}

static u64 mc_genss_buffercreate(i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	a = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = a;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	goto L3710;
L3710:
	return asu64(R1);
}

static void mc_genss_bufferexpand(u64 a) {
    u64 R1, R2, R3; 
	i64 newalloc;
	i64 usedbytes;
	u64 p;
	asu64(R1) = a;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newalloc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	usedbytes = asi64(R1);
	asi64(R1) = usedbytes;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L3713;
	msysc_m$print_startcon();
	R1 = tou64("dbuffer error");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
L3713:
	asi64(R1) = newalloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = usedbytes;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asi64(R2) = usedbytes;
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newalloc;
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	asi64(R2) = newalloc;
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mc_genss_buffercheck(u64 a, i64 n) {
    u64 R1, R2, R3; 
	goto L3716;
L3715:
	asu64(R1) = a;
	mc_genss_bufferexpand(asu64(R1));
L3716:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L3715;
	return;
}

static i64 mc_genss_bufferlength(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	goto L3718;
L3718:
	return asi64(R1);
}

static u64 mc_genss_bufferelemptr(u64 a, i64 offset) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	R1 += (i64)R2;
	goto L3719;
L3719:
	return asu64(R1);
}

static void mc_genss_addword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou16p(R2) = asu16(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 2;
	return;
}

static void mc_genss_adddword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou32p(R2) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 4;
	return;
}

static void mc_genss_addqword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou64p(R2) = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 8;
	return;
}

static void mc_genss_genxrm(i64 opcode, i64 code, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 am;
	asu64(R1) = b;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	asi64(R3) = code;
	R4 = 0;
	asu64(R1) = mc_genss_genrm(asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	am = asu64(R1);
	asu64(R1) = mc_genss_currmcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3725;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3725;
	goto L3726;
L3725:
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L3724;
L3726:
L3724:
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3728;
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 24;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3728:
	mc_genss_genrex();
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3730;
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3730:
	asi64(R1) = opcode;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = am;
	asu64(R2) = b;
	mc_genss_genamode(asu64(R2), asu64(R1));
	return;
}

static void mc_genss_genrrm(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3733;
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3733:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu8(R1) = mc_genss_usesizeb;
	if (!asu8(R1)) goto L3735;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3737;
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3737:
L3735:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu64(R4) = a;
	R5 = 10;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R1) = mc_genss_genrm(asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	am = asu64(R1);
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3739;
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 24;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3739:
	mc_genss_genrex();
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3741;
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3741:
	asi64(R1) = opcode;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = am;
	asu64(R2) = b;
	mc_genss_genamode(asu64(R2), asu64(R1));
	return;
}

static i64 mc_genss_getregcode(i64 reg, i64 mask, i64 isxreg) {
    u64 R1, R2; 
	i64 regcode;
	asi64(R1) = isxreg;
	if (asi64(R1)) goto L3744;
	R1 = (u64)&mc_decls_regcodes;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regcode = asi64(R1);
	goto L3743;
L3744:
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	regcode = asi64(R1);
L3743:
	asi64(R1) = regcode;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L3746;
	R1 = 8;
	R2 = (u64)&regcode;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mask;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3746:
	asi64(R1) = regcode;
	goto L3742;
L3742:
	return asi64(R1);
}

static void mc_genss_checkimmrange(i64 value, i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3749;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3750;
	goto L3751;
L3749:
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3754;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3753;
L3754:
	R1 = tou64("exceeding byte value");
	mc_libmcl_axerror(asu64(R1));
L3753:
	goto L3748;
L3750:
	R1 = -32768;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3757;
	R2 = 65535;
	if (asi64(R1) <= asi64(R2)) goto L3756;
L3757:
	R1 = tou64("exceeding u16 value");
	mc_libmcl_axerror(asu64(R1));
L3756:
	goto L3748;
L3751:
	R1 = -2147483648;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3760;
	R2 = 4294967295;
	if (asi64(R1) <= asi64(R2)) goto L3759;
L3760:
	R1 = tou64("2:exceeding u32 value");
	mc_libmcl_axerror(asu64(R1));
L3759:
L3748:
	return;
}

static u64 mc_genss_genrm(i64 reg, i64 opc, u64 b, i64 isxreg) {
    u64 R1, R2, R3, R4; 
	i64 mode;
	i64 rm;
	i64 scale;
	i64 index;
	i64 base;
	i64 regix;
	i64 code;
	i64 ismem;
	u64 am;
// PROC LOCAL STATICS GO HERE
	static struct $B30 mc_genss_genrm_scaletable = {{
	0,
	1,
	0,
	2,
	0,
	0,
	0,
	3    }};
	R1 = (u64)&am;
	memset(R1, 0, 8);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3763;
	asi64(R1) = isxreg;
	R2 = 4;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	opc = asi64(R1);
L3763:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3765;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3765;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3766;
	goto L3767;
L3765:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = 1;
	asu64(R3) = b;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	rm = asi64(R1);
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	R1 = 192;
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = rm;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = am;
	goto L3761;
	goto L3764;
L3766:
	R1 = 1;
	ismem = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3769;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3770;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3771;
	goto L3772;
L3769:
	asu64(R1) = b;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3774;
	R1 = 2;
	ismem = asi64(R1);
L3774:
	goto L3768;
L3770:
	R1 = 2;
	ismem = asi64(R1);
	goto L3768;
L3771:
	R1 = 2;
	ismem = asi64(R1);
	goto L3768;
L3772:
L3768:
	goto L3764;
L3767:
	R1 = tou64("genrm not mem");
	mc_libmcl_axerror(asu64(R1));
L3764:
	R1 = 0;
	R2 = R1;
	rm = asi64(R2);
	mode = asi64(R1);
	R1 = 0;
	scale = asi64(R1);
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = b;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	asi64(R2) = regix;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3776;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3776;
	R1 = 0;
	mode = asi64(R1);
	R1 = 4;
	rm = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
	R1 = 4;
	index = asi64(R1);
	R1 = 5;
	base = asi64(R1);
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3775;
L3776:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L3777;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3777;
// mc_genss.genrm.simple:
L3778:
	R1 = (u64)&am;
	R2 = 4;
	R1 += (i64)R2;
	asu64(R2) = b;
	asi64(R1) = mc_genss_getdispsize(asu64(R2), asu64(R1));
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3780;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3782;
	R1 = 1;
	goto L3781;
L3782:
	R1 = 2;
L3781:
	mode = asi64(R1);
L3780:
	R1 = 0;
	R2 = 1;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	base = asi64(R2);
	rm = asi64(R1);
	asi64(R1) = rm;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3784;
	asi64(R1) = rm;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3786;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3786;
	R1 = 1;
	mode = asi64(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3786:
	R1 = 0;
	index = asi64(R1);
	goto L3783;
L3784:
	R1 = 4;
	index = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
L3783:
	goto L3775;
L3777:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3787;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3787;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L3789;
	R1 = (u64)&reg;
	R2 = (u64)&regix;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	goto L3778;
L3789:
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	mode = asi64(R1);
	R1 = 4;
	rm = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3791;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3790;
L3791:
	R1 = 1;
L3790:
	scale = asi64(R1);
	R1 = 5;
	base = asi64(R1);
	R1 = 0;
	R2 = 2;
	asi64(R3) = regix;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	index = asi64(R1);
	asi64(R1) = regix;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3793;
	R1 = tou64("Scaled rstack?");
	mc_libmcl_axerror(asu64(R1));
L3793:
	goto L3775;
L3787:
	R1 = (u64)&am;
	R2 = 4;
	R1 += (i64)R2;
	asu64(R2) = b;
	asi64(R1) = mc_genss_getdispsize(asu64(R2), asu64(R1));
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3795;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3797;
	R1 = 1;
	goto L3796;
L3797:
	R1 = 2;
L3796:
	mode = asi64(R1);
L3795:
	R1 = 4;
	rm = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3799;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3798;
L3799:
	R1 = 1;
L3798:
	scale = asi64(R1);
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3801;
	R1 = 5;
	base = asi64(R1);
	goto L3800;
L3801:
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3804;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3803;
L3804:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3803;
	R1 = 1;
	mode = asi64(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3803:
	R1 = 0;
	R2 = 1;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	base = asi64(R1);
L3800:
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3806;
	R1 = 4;
	index = asi64(R1);
	goto L3805;
L3806:
	R1 = 0;
	R2 = 2;
	asi64(R3) = regix;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	index = asi64(R1);
	asi64(R1) = reg;
	if (asi64(R1)) goto L3808;
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3808:
	asi64(R1) = regix;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3810;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3810;
	R1 = tou64("Can't scale rstack");
	mc_libmcl_axerror(asu64(R1));
L3810:
L3805:
L3775:
	asi64(R1) = scale;
	if (!asi64(R1)) goto L3812;
	R1 = (u64)&mc_genss_genrm_scaletable;
	asi64(R2) = scale;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 6;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = index;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = base;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 2;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L3812:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3814;
	asi64(R1) = ismem;
	if (!asi64(R1)) goto L3814;
	asi64(R1) = reg;
	if (asi64(R1)) goto L3817;
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3816;
L3817:
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3819;
	asi64(R1) = ismem;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3819;
	msysc_m$print_startcon();
	R1 = tou64("Addr32 can't use RIP, line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = mc_genss_currmcl;
	asu64(R1) = mc_writeasm_strmclstr(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3819:
	goto L3815;
L3816:
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L3820;
	R1 = -1;
	R2 = (u64)&am;
	R3 = 2;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
	R1 = 0;
	mode = asi64(R1);
	R1 = 5;
	rm = asi64(R1);
L3820:
L3815:
L3814:
	asi64(R1) = mode;
	R2 = 6;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = rm;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = am;
	goto L3761;
L3761:
	return asu64(R1);
}

static void mc_genss_do_arith(u64 a, u64 b, i64 code) {
    u64 R1, R2, R3, R4; 
	u64 d;
	i64 opc;
	i64 dispsize;
	i64 x;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3823;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3824;
	goto L3825;
L3823:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3827;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3827;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3828;
	goto L3829;
L3827:
	asi64(R1) = code;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R3 = 1;
	if (asi64(R2) != asi64(R3)) goto L3831;
	R2 = 2;
	goto L3830;
L3831:
	R2 = 3;
L3830:
	asi64(R1) |= asi64(R2);
	opc = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3826;
L3828:
// mc_genss.do_arith.doregimm:
L3832:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L3834;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L3836;
	R1 = tou64("add imm/size");
	mc_libmcl_axerror(asu64(R1));
L3836:
	asu64(R1) = a;
	asi64(R2) = code;
	R3 = 129;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3821;
L3834:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	R1 = 1;
	dispsize = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3838;
	R1 = 128;
	opc = asi64(R1);
	R1 = 1;
	asi64(R2) = x;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
	asi64(R1) = x;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L3841;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3840;
L3841:
	R1 = tou64("Exceeding i8/u8 range");
	mc_libmcl_axerror(asu64(R1));
L3840:
	goto L3837;
L3838:
	R1 = -128;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3842;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3842;
	R1 = 131;
	opc = asi64(R1);
	goto L3837;
L3842:
	R1 = 4;
	asi64(R2) = x;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
	R1 = 129;
	opc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3844;
	R1 = 2;
	goto L3843;
L3844:
	R1 = 4;
L3843:
	dispsize = asi64(R1);
L3837:
	asu64(R1) = a;
	asi64(R2) = code;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = dispsize;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3846;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3847;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3848;
	goto L3849;
L3846:
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3845;
L3847:
	asi64(R1) = x;
	mc_genss_genword(asi64(R1));
	goto L3845;
L3848:
	asi64(R1) = x;
	mc_genss_gendword(asi64(R1));
	goto L3845;
L3849:
L3845:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3826;
L3829:
	R1 = tou64("ADD reg,???");
	mc_libmcl_axerror(asu64(R1));
L3826:
	goto L3822;
L3824:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3851;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3852;
	goto L3853;
L3851:
	asi64(R1) = code;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R3 = 1;
	if (asi64(R2) != asi64(R3)) goto L3855;
	R2 = 0;
	goto L3854;
L3855:
	R2 = 1;
L3854:
	asi64(R1) |= asi64(R2);
	opc = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3850;
L3852:
	goto L3832;
	goto L3850;
L3853:
	R1 = tou64("ADD mem,???");
	mc_libmcl_axerror(asu64(R1));
L3850:
	goto L3822;
L3825:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asi64(R2) = code;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("CODE=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = code;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1:Can't add to this opnd");
	mc_libmcl_axerror(asu64(R1));
L3822:
L3821:
	return;
}

static void mc_genss_do_mov(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 regcode;
	i64 opc;
	i64 dispsize;
	i64 value;
	u64 d;
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3858;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3859;
	goto L3860;
L3858:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3862;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3862;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3863;
	goto L3864;
L3862:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3866;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3866;
	R1 = tou64("2:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3866:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3868;
	R3 = 138;
	goto L3867;
L3868:
	R3 = 139;
L3867:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3861;
L3863:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	regcode = asi64(R1);
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L3870;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3870;
	R1 = tou64("mov imm?");
	mc_libmcl_axerror(asu64(R1));
L3870:
	asu64(R1) = a;
	mc_genss_checkhighreg(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3872;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3873;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3874;
	goto L3875;
L3872:
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3878;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3877;
L3878:
	R1 = tou64("exceeding byte value");
	mc_libmcl_axerror(asu64(R1));
L3877:
	mc_genss_genrex();
	R1 = 176;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3871;
L3873:
	R1 = -32768;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3881;
	R2 = 65535;
	if (asi64(R1) <= asi64(R2)) goto L3880;
L3881:
	R1 = tou64("exceeding u16 value");
	mc_libmcl_axerror(asu64(R1));
L3880:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3871;
L3874:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3883;
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3882;
L3883:
	R1 = -2147483648;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3886;
	R2 = 4294967295;
	asi64(R2) = toi64(tou32(R2));
	if (asi64(R1) <= asi64(R2)) goto L3885;
L3886:
	msysc_m$print_startcon();
	asi64(R1) = value;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = value;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1:exceeding u32 value");
	mc_libmcl_axerror(asu64(R1));
L3885:
// mc_genss.do_mov.doreg32:
L3887:
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L3882:
	goto L3871;
L3875:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3889;
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 8;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3888;
L3889:
	asi64(R1) = value;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3891;
	asi64(R1) = value;
	R2 = 4294967295;
	if (asi64(R1) > asi64(R2)) goto L3891;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L3887;
L3891:
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genqword(asi64(R1));
L3888:
L3871:
	goto L3861;
L3864:
	R1 = tou64("MOV REG/??");
	mc_libmcl_axerror(asu64(R1));
L3861:
	goto L3857;
L3859:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3893;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3894;
	goto L3895;
L3893:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3897;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3897:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3899;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3899;
	R1 = tou64("3:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3899:
	asu64(R1) = a;
	asu64(R2) = b;
	asu64(R3) = b;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3901;
	R3 = 136;
	goto L3900;
L3901:
	R3 = 137;
L3900:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3892;
L3894:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3903;
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3903:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3905;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3905;
	R1 = tou64("mov imm?");
	mc_libmcl_axerror(asu64(R1));
L3905:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3907;
	R1 = 198;
	goto L3906;
L3907:
	R1 = 199;
L3906:
	opc = asi64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L3909;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = value;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
L3909:
	asu64(R1) = a;
	R2 = 0;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	dispsize = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3911;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3912;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3913;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3913;
	goto L3914;
L3911:
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3910;
L3912:
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3910;
L3913:
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	R1 = 4;
	dispsize = asi64(R1);
	goto L3910;
L3914:
L3910:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3892;
L3895:
	R1 = tou64("MOV MEM/?");
	mc_libmcl_axerror(asu64(R1));
L3892:
	goto L3857;
L3860:
	R1 = tou64("MOV ?/..");
	mc_libmcl_axerror(asu64(R1));
L3857:
	return;
}

static void mc_genss_do_push(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3917;
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3917:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3919;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3920;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3921;
	goto L3922;
L3919:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3924;
	R1 = tou64("pushreg not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3924:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	mc_genss_genrex();
	R1 = 80;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3918;
L3920:
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3926;
	R1 = 104;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3925;
L3926:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_genss_isbytesized(asi64(R1));
	if (!asi64(R1)) goto L3927;
	R1 = 106;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3925;
L3927:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_genss_isdwordsized(asi64(R1));
	if (!asi64(R1)) goto L3928;
	R1 = 104;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3925;
L3928:
	R1 = tou64("push imm value too large");
	mc_libmcl_axerror(asu64(R1));
L3925:
	goto L3918;
L3921:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3930;
	R1 = tou64("push not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3930:
	asu64(R1) = a;
	R2 = 6;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3918;
L3922:
	R1 = tou64("push opnd?");
	mc_libmcl_axerror(asu64(R1));
L3918:
	return;
}

static void mc_genss_do_pop(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3933;
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3933:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3935;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3936;
	goto L3937;
L3935:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3939;
	R1 = tou64("popreg not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3939:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	mc_genss_genrex();
	R1 = 88;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3934;
L3936:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3941;
	R1 = tou64("pop not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3941:
	asu64(R1) = a;
	R2 = 0;
	R3 = 143;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3934;
L3937:
	R1 = tou64("pop opnd?");
	mc_libmcl_axerror(asu64(R1));
L3934:
	return;
}

static void mc_genss_do_inc(u64 a, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3944;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3944;
	goto L3945;
L3944:
	asu64(R1) = a;
	asi64(R2) = code;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3947;
	R3 = 254;
	goto L3946;
L3947:
	R3 = 255;
L3946:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3943;
L3945:
	R1 = tou64("inc/opnd?");
	mc_libmcl_axerror(asu64(R1));
L3943:
	return;
}

static void mc_genss_do_neg(u64 a, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3950;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3950;
	goto L3951;
L3950:
	asu64(R1) = a;
	asi64(R2) = code;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3953;
	R3 = 246;
	goto L3952;
L3953:
	R3 = 247;
L3952:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3949;
L3951:
	R1 = tou64("neg/div/etc opnd?");
	mc_libmcl_axerror(asu64(R1));
L3949:
	return;
}

static void mc_genss_do_lea(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 regcode;
	i64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3957;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3956;
L3957:
	R1 = tou64("LEA not reg/mem");
	mc_libmcl_axerror(asu64(R1));
L3956:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L3959;
	R1 = tou64("LEA size error");
	mc_libmcl_axerror(asu64(R1));
L3959:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 141;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_movsx(u64 a, u64 b, i64 opc) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3962;
	R1 = tou64("movsx not reg");
	mc_libmcl_axerror(asu64(R1));
L3962:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3964;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3964;
	asi64(R1) = opc;
	R2 = 190;
	if (asi64(R1) != asi64(R2)) goto L3966;
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_movsxd(asu64(R2), asu64(R1));
	goto L3965;
L3966:
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	R2 = 4;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_mov(asu64(R2), asu64(R1));
L3965:
	goto L3960;
L3964:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3969;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) > asu64(R2)) goto L3968;
L3969:
	R1 = tou64("movsx size error");
	mc_libmcl_axerror(asu64(R1));
L3968:
	asi64(R1) = opc;
	R2 = 182;
	if (asi64(R1) != asi64(R2)) goto L3971;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3971;
	R1 = tou64("movsx 4=>8 bytes?");
	mc_libmcl_axerror(asu64(R1));
L3971:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3973;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3974;
	goto L3975;
L3973:
	goto L3972;
L3974:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3977;
	R1 = tou64("movsx need size prefix");
	mc_libmcl_axerror(asu64(R1));
L3977:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3979;
	R1 = tou64("movsx size 8");
	mc_libmcl_axerror(asu64(R1));
L3979:
	goto L3972;
L3975:
	R1 = tou64("movsx not reg/mem");
	mc_libmcl_axerror(asu64(R1));
L3972:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asu64(R4) = b;
	R5 = 8;
	asu16(R4) = *tou16p(((i64)R4+(i64)R5));
	R4 = toi64(tou16(R4));
	R5 = 0;
	R6 = 4;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	if (asi64(R4) != asi64(R5)) goto L3981;
	asi64(R4) = opc;
	goto L3980;
L3981:
	asi64(R4) = opc;
	R5 = 1;
	asi64(R4) += asi64(R5);
L3980:
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L3960:
	return;
}

static void mc_genss_do_exch(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 regcode;
	i64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3984;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3984;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3985;
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3984;
L3985:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3984;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3987;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L3987:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3989;
	R1 = tou64("exch size");
	mc_libmcl_axerror(asu64(R1));
L3989:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	regcode = asi64(R1);
	mc_genss_genrex();
	R1 = 144;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3982;
L3984:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3991;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L3991:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3994;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3993;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3993;
L3994:
	R1 = tou64("exch opnds");
	mc_libmcl_axerror(asu64(R1));
L3993:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3996;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3996;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3996:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3998;
	R1 = tou64("exch size");
	mc_libmcl_axerror(asu64(R1));
L3998:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4000;
	R3 = 134;
	goto L3999;
L4000:
	R3 = 135;
L3999:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L3982:
	return;
}

static void mc_genss_do_movsxd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4003;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4003;
	R1 = 4;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4003:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4006;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L4005;
L4006:
	R1 = tou64("movsxd size");
	mc_libmcl_axerror(asu64(R1));
L4005:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4009;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4008;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4008;
L4009:
	R1 = tou64("movsxd opnds");
	mc_libmcl_axerror(asu64(R1));
L4008:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 99;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_imul2(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	i64 opc;
	i64 dispsize;
	i64 value;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4012;
	R1 = tou64("imul2 opnds");
	mc_libmcl_axerror(asu64(R1));
L4012:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4014;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4014:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4016;
	R1 = tou64("imul2 byte");
	mc_libmcl_axerror(asu64(R1));
L4016:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4018;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4018;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4019;
	goto L4020;
L4018:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L4022;
	R1 = tou64("imul2 size");
	mc_libmcl_axerror(asu64(R1));
L4022:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 4015;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4017;
L4019:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L4024;
	R1 = tou64("mul/label");
	mc_libmcl_axerror(asu64(R1));
L4024:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L4026;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L4026;
	R1 = 107;
	opc = asi64(R1);
	goto L4025;
L4026:
	R1 = 105;
	opc = asi64(R1);
L4025:
	asu64(R1) = a;
	asu64(R2) = a;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L4028;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L4028;
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	dispsize = asi64(R1);
	goto L4027;
L4028:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4029;
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	R1 = 2;
	dispsize = asi64(R1);
	goto L4027;
L4029:
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
	R1 = 4;
	dispsize = asi64(R1);
L4027:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L4017;
L4020:
	R1 = tou64("imul2 opnds");
	mc_libmcl_axerror(asu64(R1));
L4017:
	return;
}

static void mc_genss_do_shift(u64 a, u64 b, i64 code) {
    u64 R1, R2, R3; 
	i64 w;
	i64 opc;
	i64 needdisp;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4032;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4032;
	R1 = tou64("shift opnds1?");
	mc_libmcl_axerror(asu64(R1));
L4032:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L4034;
	R1 = tou64("shift/label");
	mc_libmcl_axerror(asu64(R1));
L4034:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4036;
	R1 = 0;
	goto L4035;
L4036:
	R1 = 1;
L4035:
	w = asi64(R1);
	R1 = 0;
	needdisp = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4038;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4039;
	goto L4040;
L4038:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4042;
	R1 = 208;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4041;
L4042:
	R1 = 192;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	R1 = 1;
	needdisp = asi64(R1);
L4041:
	goto L4037;
L4039:
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4045;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4044;
L4045:
	R1 = tou64("cl or b10 needed");
	mc_libmcl_axerror(asu64(R1));
L4044:
	R1 = 210;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4037;
L4040:
	R1 = tou64("shift opnds2?");
	mc_libmcl_axerror(asu64(R1));
L4037:
	asu64(R1) = a;
	asi64(R2) = code;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = needdisp;
	if (!asi64(R1)) goto L4047;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_fixrip(asi64(R1));
L4047:
	return;
}

static void mc_genss_do_test(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 value;
	i64 opc;
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4050;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4050;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4050;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4052;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4053;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4054;
	goto L4055;
L4052:
	R1 = 168;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L4051;
L4053:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L4051;
L4054:
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
	goto L4051;
L4055:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L4051:
	goto L4049;
L4050:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4057;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4056;
L4057:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4056;
	asu64(R1) = a;
	R2 = 0;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4059;
	R3 = 246;
	goto L4058;
L4059:
	R3 = 247;
L4058:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4061;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4062;
	goto L4063;
L4061:
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L4060;
L4062:
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L4060;
L4063:
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L4060:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	mc_genss_fixrip(asi64(R1));
	goto L4049;
L4056:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4065;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4064;
L4065:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4064;
// mc_genss.do_test.domemreg:
L4066:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L4068;
	R3 = 132;
	goto L4067;
L4068:
	R3 = 133;
L4067:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4049;
L4064:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4069;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4069;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	goto L4066;
	goto L4049;
L4069:
	R1 = tou64("test opnds");
	mc_libmcl_axerror(asu64(R1));
L4049:
	return;
}

static void mc_genss_do_setcc(i64 cond, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4074;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4073;
L4074:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4072;
L4073:
	R1 = tou64("setcc opnd/size");
	mc_libmcl_axerror(asu64(R1));
L4072:
	asu64(R1) = b;
	R2 = 0;
	R3 = 3984;
	asi64(R4) = cond;
	asi64(R3) += asi64(R4);
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void mc_genss_checksize(u64 a, i64 size1, i64 size2) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4077;
	R1 = tou64("Need size");
	mc_libmcl_axerror(asu64(R1));
L4077:
	asi64(R1) = size1;
	if (!asi64(R1)) goto L4079;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size1;
	if (asi64(R1) == asi64(R2)) goto L4079;
	asi64(R2) = size2;
	if (asi64(R1) == asi64(R2)) goto L4079;
	msysc_m$print_startcon();
	R1 = tou64("A.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Wrong size");
	mc_libmcl_axerror(asu64(R1));
L4079:
	return;
}

static void mc_genss_do_arithxmm(u64 a, u64 b, i64 prefix, i64 opc) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4083;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4082;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4082;
L4083:
	R1 = tou64("arithxmm opnds");
	mc_libmcl_axerror(asu64(R1));
L4082:
	asi64(R1) = prefix;
	if (!asi64(R1)) goto L4085;
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4085:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_logicxmm(u64 a, u64 b, i64 opc, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4089;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4088;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4088;
L4089:
	R1 = tou64("logicxmm opnds");
	mc_libmcl_axerror(asu64(R1));
L4088:
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4091;
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4091:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_convertfloat(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4095;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4094;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4094;
L4095:
	R1 = tou64("convertfloat opnds");
	mc_libmcl_axerror(asu64(R1));
L4094:
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3930;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_fix(u64 a, u64 b, i64 prefix, i64 opc) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4099;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4098;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4098;
L4099:
	R1 = tou64("fix opnds");
	mc_libmcl_axerror(asu64(R1));
L4098:
	R1 = 8;
	R2 = 4;
	asu64(R3) = a;
	mc_genss_checksize(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = prefix;
	R2 = 243;
	if (asi64(R1) != asi64(R2)) goto L4101;
	R1 = 4;
	goto L4100;
L4101:
	R1 = 8;
L4100:
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_float(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4105;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4104;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4104;
L4105:
	R1 = tou64("float opnds");
	mc_libmcl_axerror(asu64(R1));
L4104:
	R1 = 8;
	R2 = 4;
	asu64(R3) = b;
	mc_genss_checksize(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = prefix;
	R2 = 243;
	if (asi64(R1) != asi64(R2)) goto L4107;
	R1 = 4;
	goto L4106;
L4107:
	R1 = 8;
L4106:
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_usesizeb = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3882;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_movxmm(u64 a, u64 b, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	i64 regcode1;
	i64 regcode2;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4110;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4111;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4112;
	goto L4113;
L4110:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4115;
	goto L4116;
L4115:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4118;
	R1 = tou64("1:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4118:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4114;
L4116:
	R1 = tou64("movdq reg,?");
	mc_libmcl_axerror(asu64(R1));
L4114:
	goto L4109;
L4111:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4120;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4121;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4122;
	goto L4123;
L4120:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4125;
	R1 = tou64("3:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4125:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3950;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4119;
L4121:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4119;
L4122:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4127;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4127:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4129;
	R1 = tou64("31:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4129:
	asi64(R1) = size;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4131;
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3950;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4130;
L4131:
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4130:
	goto L4119;
L4123:
	R1 = tou64("movdq xreg,?");
	mc_libmcl_axerror(asu64(R1));
L4119:
	goto L4109;
L4112:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4133;
	goto L4134;
L4133:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L4136;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4136;
	R1 = tou64("5:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4136:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = size;
	R4 = 4;
	if (asi64(R3) != asi64(R4)) goto L4138;
	R3 = 3966;
	goto L4137;
L4138:
	R3 = 4054;
L4137:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4132;
L4134:
	R1 = tou64("movdq mem,?");
	mc_libmcl_axerror(asu64(R1));
L4132:
	goto L4109;
L4113:
	R1 = tou64("movdq opnds");
	mc_libmcl_axerror(asu64(R1));
L4109:
	return;
}

static void mc_genss_fixrip(i64 dispsize) {
    u64 R1, R2, R3; 
	u64 codeaddr;
	u64 offsetptr;
	asu64(R1) = mc_genss_ripentry;
	if (asu64(R1)) goto L4141;
	goto L4139;
L4141:
	asi64(R1) = dispsize;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4143;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4144;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4144;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4144;
	goto L4145;
L4143:
	goto L4139;
	goto L4142;
L4144:
	goto L4142;
L4145:
	msysc_m$print_startcon();
	R1 = tou64("DISPSIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = dispsize;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("fixrip disp?");
	mc_libmcl_axerror(asu64(R1));
L4142:
	asi64(R1) = dispsize;
	asu64(R2) = mc_genss_ripentry;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4139:
	return;
}

static void mc_genss_do_bswap(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4149;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L4148;
L4149:
	R1 = tou64("bswap reg>");
	mc_libmcl_axerror(asu64(R1));
L4148:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	mc_genss_genrex();
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 200;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_genss_do_movdqx(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = prefix;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	R2 = 3840;
	asi64(R1) += asi64(R2);
	prefix = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4152;
	R1 = 16;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4152:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4154;
	R1 = 16;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4154:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4156;
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = prefix;
	R4 = 127;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4155;
L4156:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = prefix;
	R4 = 111;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4155:
	return;
}

static void mc_genss_do_dshift(u64 a, u64 b, i64 c, i64 opc) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4159;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4159:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L4162;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L4161;
L4162:
	R1 = tou64("dshift/size");
	mc_libmcl_axerror(asu64(R1));
L4161:
	R1 = 0;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = c;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_decls_start() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4166;
L4164:
	R1 = 10;
	R2 = (u64)&mc_decls_ploadop;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L4164;
L4166:
	R1 = 19;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 5;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 4;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 18;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 9;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 8;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 17;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 10;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mc_writeasm_writemcl(i64 index, u64 mcl) {
    u64 R1, R2; 
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4169;
	asu64(R1) = mcl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 63;
	if (asu64(R1) != asu64(R2)) goto L4169;
	goto L4168;
L4169:
	asu64(R1) = mcl;
	mc_writeasm_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
L4168:
	return;
}

static void mc_writeasm_strmcl(u64 mcl) {
    u64 R1, R2, R3, R4; 
	struct $B21 opcname;
	u64 a;
	u64 b;
	i64 opcode;
	i64 cond;
	i64 sizepref;
	u64 s;
	u64 comment;
	u64 d;
	u8 first;
	i64 r;
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeasm_strmcl_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = mcl;
	R2 = 34;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu64(R1) = mcl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = mcl;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	comment = asu64(R1);
	asi64(R1) = opcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4172;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4173;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4174;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4175;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4176;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4177;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4178;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4179;
	goto L4180;
L4172:
	R1 = tou64(";Proc ");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	R1 = (u64)&mc_writeasm_regvars;
	memset(R1, 0, 128);
	R1 = (u64)&mc_writeasm_xregvars;
	memset(R1, 0, 128);
	goto L4170;
	goto L4171;
L4173:
	R1 = tou64(";End\n");
	mc_writeasm_asmstr(asu64(R1));
	R1 = 0;
	mc_decls_currasmproc = asu64(R1);
	goto L4170;
	goto L4171;
L4174:
	R1 = 59;
	mc_writeasm_asmchar(asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writeasm_asmstr(asu64(R1));
	goto L4170;
	goto L4171;
L4175:
	goto L4170;
	goto L4171;
L4176:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4182;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4183;
	goto L4184;
L4182:
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	mc_writeasm_asmstr(asu64(R1));
	goto L4181;
L4183:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writeasm_asmstr(asu64(R1));
	goto L4170;
	goto L4181;
L4184:
	R1 = tou64("");
	R2 = tou64("strmcl/lab");
	pc_api_merror(asu64(R2), asu64(R1));
L4181:
	R1 = tou64(":");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4186;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4188;
	R1 = tou64(":");
	mc_writeasm_asmstr(asu64(R1));
	goto L4187;
L4188:
	R1 = tou64("\n`");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	mc_writeasm_asmstr(asu64(R1));
	R1 = tou64("::");
	mc_writeasm_asmstr(asu64(R1));
L4187:
L4186:
	goto L4170;
	goto L4171;
L4177:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4190;
	R1 = (u64)&mc_writeasm_strmcl_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("L#:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L4189;
L4190:
	goto L4176;
L4189:
	R1 = (u64)&mc_writeasm_strmcl_str;
	mc_writeasm_asmstr(asu64(R1));
	goto L4170;
	goto L4171;
L4178:
	R1 = tou64("    ");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writeasm_asmstr(asu64(R1));
	R1 = tou64(" = ");
	mc_writeasm_asmstr(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L4170;
	goto L4171;
L4179:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = tou64("    ");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L4192;
	asu64(R1) = d;
	R2 = (u64)&mc_writeasm_xregvars;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4191;
L4192:
	asu64(R1) = d;
	R2 = (u64)&mc_writeasm_regvars;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4191:
	R1 = tou64(" = ");
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4194;
	goto L4195;
L4194:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_getregname(asi64(R2), asi64(R1));
	mc_writeasm_asmstr(asu64(R1));
	goto L4193;
L4195:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_getxregname(asi64(R2), asi64(R1));
	mc_writeasm_asmstr(asu64(R1));
L4193:
	goto L4170;
	goto L4171;
L4180:
L4171:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4197;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4198;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4199;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L4200;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4201;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4202;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L4203;
	goto L4204;
L4197:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("j");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4196;
L4198:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("set");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4196;
L4199:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("cmov");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4196;
L4200:
	R1 = tou64("and");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4196;
L4201:
	R1 = tou64("or");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4196;
L4202:
	R1 = tou64("xor");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4196;
L4203:
	R1 = tou64("not");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4196;
L4204:
	asi64(R1) = opcode;
	R2 = 151;
	if (asi64(R1) <= asi64(R2)) goto L4206;
	R1 = 0;
	asi64(R2) = opcode;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4205;
L4206:
	R1 = (u64)&mc_decls_mclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 2;
	R1 += (i64)R2;
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L4205:
L4196:
	R1 = tou64(" ");
	asi64(R2) = opcode;
	R3 = 119;
	if (asi64(R2) != asi64(R3)) goto L4208;
	R2 = 4;
	goto L4207;
L4208:
	R2 = 10;
L4207:
	R3 = (u64)&opcname;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 4;
	R3 = (u64)&mc_writeasm_strmcl_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&opcname;
	R2 = (u64)&mc_writeasm_strmcl_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writeasm_strmcl_str;
	mc_writeasm_asmstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L4210;
	asu64(R1) = b;
	if (!asu64(R1)) goto L4210;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	asi64(R1) = mc_writeasm_needsizeprefix(asi64(R3), asu64(R2), asu64(R1));
	sizepref = asi64(R1);
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = a;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64(",\t");
	mc_writeasm_asmstr(asu64(R1));
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = b;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = mcl;
	R2 = 32;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4212;
	R1 = tou64(",");
	mc_writeasm_asmstr(asu64(R1));
	R1 = 0;
	asu64(R2) = mcl;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	mc_writeasm_asmstr(asu64(R1));
L4212:
	goto L4209;
L4210:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4213;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L4213;
	asi64(R1) = opcode;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4215;
	asi64(R1) = opcode;
	R2 = 0;
	asu64(R3) = a;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L4214;
L4215:
	asi64(R1) = opcode;
	R2 = 1;
	asu64(R3) = a;
	mc_writeasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
L4214:
L4213:
L4209:
L4170:
	return;
}

static u64 mc_writeasm_strmclstr(u64 m) {
    u64 R1, R2; 
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = m;
	mc_writeasm_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4216;
L4216:
	return asu64(R1);
}

static u64 mc_writeasm_mstropnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3, R4; 
	struct $B21 str2;
	u64 plus;
	u64 t;
	i64 offset;
	i64 tc;
	R1 = 0;
	R2 = (u64)&mc_writeasm_mstropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4219;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4220;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4221;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4222;
	goto L4223;
L4219:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_strreg(asi64(R2), asi64(R1));
	goto L4217;
	goto L4218;
L4220:
	asi64(R1) = opcode;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L4225;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4225;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4227;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L4227;
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4226;
L4227:
	R1 = tou64("0x");
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("H");
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4226:
	goto L4224;
L4225:
	asu64(R1) = a;
	asu64(R1) = mc_writeasm_strvalue(asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L4224:
	goto L4218;
L4221:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4229;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4230;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4231;
	goto L4232;
L4229:
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4228;
L4230:
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4228;
L4231:
	R1 = (u64)&mc_writeasm_mstropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("M#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L4228;
L4232:
L4228:
	asi64(R1) = sizeprefix;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = mc_writeasm_getsizeprefix(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("[");
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4234;
	R1 = 8;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
L4234:
	asu64(R1) = a;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4236;
	asu64(R1) = plus;
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = a;
	R3 = 11;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4238;
	R1 = tou64("*");
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 5;
	R4 = 8;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4238:
L4236:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4241;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4241;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4240;
L4241:
	asu64(R1) = plus;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L4243;
	asu64(R1) = plus;
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4243:
	asu64(R1) = a;
	asu64(R1) = mc_writeasm_strvalue(asu64(R1));
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4239;
L4240:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L4244;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" + ");
	asi64(R2) = offset;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4244:
L4239:
	R1 = tou64("]");
	R2 = (u64)&mc_writeasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4218;
L4222:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writeasm_strxreg(asi64(R2), asi64(R1));
	goto L4217;
	goto L4218;
L4223:
	msysc_m$print_startcon();
	R1 = tou64("BAD OPND");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<BAD OPND>");
	goto L4217;
L4218:
	R1 = (u64)&mc_writeasm_mstropnd_str;
	goto L4217;
L4217:
	return asu64(R1);
}

static u64 mc_writeasm_strvalue(u64 a) {
    u64 R1, R2, R3; 
	struct $B21 str2;
	u64 def;
	i64 value;
	i64 offset;
	i64 length;
	u64 ss;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	def = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4247;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4248;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4249;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4250;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4251;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L4252;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L4253;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L4254;
	goto L4255;
L4247:
	asu64(R1) = def;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
// mc_writeasm.strvalue.addoffset:
L4256:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L4258;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4260;
	R1 = tou64("+");
	goto L4259;
L4260:
	R1 = tou64("");
L4259:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = offset;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4258:
	goto L4246;
L4248:
	R1 = 0;
	asi64(R2) = value;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4246;
L4249:
	R1 = (u64)&mc_writeasm_strvalue_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("20.20");
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4246;
L4250:
	R1 = tou64("M");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4246;
L4251:
	R1 = tou64("\"");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4246;
L4252:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4246;
L4253:
	R1 = tou64("L");
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writeasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4256;
	goto L4246;
L4254:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_currasmproc;
	asu64(R1) = mc_writeasm_gettempname(asu64(R2), asi64(R1));
	goto L4245;
	goto L4246;
L4255:
	R1 = tou64("");
	R2 = tou64("Stropnd?");
	pc_api_merror(asu64(R2), asu64(R1));
L4246:
	R1 = (u64)&mc_writeasm_strvalue_str;
	goto L4245;
L4245:
	return asu64(R1);
}

static void mc_writeasm_asmopnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	asi64(R2) = sizeprefix;
	asu64(R3) = a;
	asu64(R1) = mc_writeasm_mstropnd(asu64(R3), asi64(R2), asi64(R1));
	mc_writeasm_asmstr(asu64(R1));
	return;
}

static u64 mc_writeasm_getregname(i64 reg, i64 size) {
    u64 R1, R2, R3; 
	struct $B3 str2;
	u64 rs;
	i64 size2;
// PROC LOCAL STATICS GO HERE
	static struct $B40 mc_writeasm_getregname_prefix = {{
	(u64)"B",
	(u64)"W",
	(u64)"",
	(u64)"A",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"D",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"",
	(u64)"Q",
	(u64)"N"    }};
	R1 = (u64)&mc_writeasm_nregnames;
	asi64(R2) = size;
	R1 += (i64)R2*128-128;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L4262;
	asi64(R1) = size;
	size2 = asi64(R1);
	asi64(R1) = size2;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L4264;
	R1 = 17;
	size2 = asi64(R1);
L4264:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4266;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4267;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4268;
	goto L4269;
L4266:
	R1 = tou64("-");
	goto L4262;
	goto L4265;
L4267:
	R1 = tou64("fp");
	rs = asu64(R1);
	goto L4265;
L4268:
	R1 = tou64("sp");
	rs = asu64(R1);
	goto L4265;
L4269:
	R1 = (u64)&str2;
	asi64(R2) = reg;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	msysc_getstrint(asi64(R2), asu64(R1));
	R1 = (u64)&str2;
	rs = asu64(R1);
L4265:
	R1 = (u64)&mc_writeasm_getregname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = (u64)&mc_writeasm_getregname_prefix;
	asi64(R2) = size2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = rs;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writeasm_getregname_str;
	goto L4262;
L4262:
	return asu64(R1);
}

static u64 mc_writeasm_getxregname(i64 reg, i64 size) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4272;
	R1 = tou64("-");
	goto L4270;
L4272:
	R1 = (u64)&mc_writeasm_getxregname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("XMM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writeasm_getxregname_str;
	goto L4270;
L4270:
	return asu64(R1);
}

static void mc_writeasm_asmstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mc_writeasm_asmchar(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_char(asu64(R2), asi64(R1));
	return;
}

static u64 mc_writeasm_getdispname(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4277;
	R1 = (u64)&mc_writeasm_getdispname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("##R.#");
	msysc_m$print_setfmt(asu64(R1));
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4279;
	R1 = tou64("");
	goto L4278;
L4279:
	R1 = tou64("`");
L4278:
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4281;
	R1 = tou64("X");
	goto L4280;
L4281:
	R1 = tou64("");
L4280:
	msysc_m$print_str_nf(asu64(R1));
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4283;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4282;
L4283:
	R1 = 0;
	asu64(R2) = d;
	asu64(R1) = pc_api_getfullname(asu64(R2), asi64(R1));
L4282:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writeasm_getdispname_str;
	goto L4275;
L4277:
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4285;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4284;
L4285:
	R1 = 1;
	asu64(R2) = d;
	asu64(R1) = pc_api_getfullname(asu64(R2), asi64(R1));
L4284:
	goto L4275;
L4275:
	return asu64(R1);
}

static u64 mc_writeasm_gettempname(u64 d, i64 n) {
    u64 R1, R2; 
	asu8(R1) = pc_api_fpshortnames;
	if (asu8(R1)) goto L4289;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4288;
L4289:
	R1 = (u64)&mc_writeasm_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L4287;
L4288:
	R1 = (u64)&mc_writeasm_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.$T#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L4287:
	R1 = (u64)&mc_writeasm_gettempname_str;
	goto L4286;
L4286:
	return asu64(R1);
}

static u64 mc_writeasm_strreg(i64 reg, i64 size) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = (u64)&mc_writeasm_regvars;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L4292;
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = size;
	if (asi64(R1) != asi64(R2)) goto L4292;
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	goto L4290;
L4292:
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_writeasm_getregname(asi64(R2), asi64(R1));
	goto L4290;
L4290:
	return asu64(R1);
}

static u64 mc_writeasm_strxreg(i64 reg, i64 size) {
    u64 R1, R2; 
	u64 d;
	R1 = (u64)&mc_writeasm_xregvars;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4295;
	asu64(R1) = d;
	if (!asu64(R1)) goto L4295;
	asu64(R1) = d;
	asu64(R1) = mc_writeasm_getdispname(asu64(R1));
	goto L4294;
L4295:
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_writeasm_getxregname(asi64(R2), asi64(R1));
L4294:
	goto L4293;
L4293:
	return asu64(R1);
}

static u64 mc_writeasm_getassemstr() {
    u64 R1, R2; 
	u64 d;
	u64 e;
	u64 m;
	struct $B17 str2;
	struct $B17 str3;
	i64 i;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4298;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4299;
	goto L4300;
L4298:
	R1 = tou64("    $userip\n");
	mc_writeasm_asmstr(asu64(R1));
	goto L4297;
L4299:
	R1 = tou64("    $highmem\n");
	mc_writeasm_asmstr(asu64(R1));
	goto L4297;
L4300:
L4297:
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L4302;
L4301:
	asu64(R1) = m;
	asi64(R2) = i;
	mc_writeasm_writemcl(asi64(R2), asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L4302:
	asu64(R1) = m;
	if (asu64(R1)) goto L4301;
	asu64(R1) = pc_decls_pdest;
	goto L4296;
L4296:
	return asu64(R1);
}

static i64 mc_writeasm_needsizeprefix(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L4306;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4306;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4306;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4306;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L4307;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4307;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4307;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4307;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4308;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4308;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4308;
	goto L4309;
L4306:
	R1 = 1;
	goto L4304;
	goto L4305;
L4307:
	R1 = 1;
	goto L4304;
	goto L4305;
L4308:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4311;
	R1 = 1;
	goto L4304;
L4311:
	R1 = 0;
	goto L4304;
	goto L4305;
L4309:
L4305:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4314;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4314;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4314;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4313;
L4314:
	R1 = 0;
	goto L4304;
L4313:
	R1 = 1;
	goto L4304;
L4304:
	return asi64(R1);
}

static u64 mc_writeasm_getsizeprefix(i64 size, i64 enable) {
    u64 R1, R2; 
	asi64(R1) = enable;
	if (asi64(R1)) goto L4317;
	R1 = tou64("");
	goto L4315;
L4317:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4319;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4320;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4321;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4322;
	goto L4323;
L4319:
	R1 = tou64("byte ");
	goto L4315;
	goto L4318;
L4320:
	R1 = tou64("u16 ");
	goto L4315;
	goto L4318;
L4321:
	R1 = tou64("u32 ");
	goto L4315;
	goto L4318;
L4322:
	R1 = tou64("u64 ");
	goto L4315;
	goto L4318;
L4323:
L4318:
	R1 = tou64("");
	goto L4315;
L4315:
	return asu64(R1);
}

static void mc_writeasm_start() {
    u64 R1, R2, R3; 
	u8 flag;
	i64 av_1;
	i64 i;
	i64 r;
	i64 k;
	R1 = 16705;
	pc_decls_assemtype = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4325:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4330;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4330;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4330;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4329;
L4330:
	R1 = 1;
	r = asi64(R1);
L4331:
	R1 = 0;
	flag = asu8(R1);
	R1 = 1;
	k = asi64(R1);
	R1 = 137;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4336;
L4334:
	asu8(R1) = flag;
	if (!asu8(R1)) goto L4338;
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L4340;
	R1 = (u64)&mc_decls_regindices;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = r;
	if (asi64(R1) != asi64(R2)) goto L4340;
	R1 = (u64)&mc_decls_dregnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_writeasm_nregnames;
	asi64(R3) = i;
	R2 += (i64)R3*128-128;
	asi64(R3) = r;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4340:
	goto L4337;
L4338:
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4341;
	R1 = 1;
	flag = asu8(R1);
L4341:
L4337:
	k += 1; if (k <= av_1) goto L4334;
L4336:
	r += 1; if (r <= 16) goto L4331;
L4329:
	i += 1; if (i <= 8) goto L4325;
	return;
}

static void mc_writeexe_writeexe(u64 outfile, i64 dodll, u64 entrypoint) {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_exedone;
	if (!asu8(R1)) goto L4344;
	goto L4342;
L4344:
	asi64(R1) = dodll;
	asu64(R2) = outfile;
	asu64(R3) = entrypoint;
	mc_writeexe_genexe1(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = dodll;
	asu64(R2) = outfile;
	mc_writeexe_genexe2(asu64(R2), asi64(R1));
	R1 = 1;
	pc_decls_exedone = asu8(R1);
L4342:
	return;
}

static void mc_writeexe_genexe1(u64 entrypoint, u64 outfile, i64 dodll) {
    u64 R1, R2, R3, R4; 
	i64 offset;
	u64 codeaddr;
	u64 offsetptr;
	u64 pr;
	mc_writeexe_initsectiontable();
	asu64(R1) = outfile;
	asu64(R1) = mlib_extractfile(asu64(R1));
	mc_writeexe_dllfilename = asu64(R1);
	asi64(R1) = dodll;
	mc_writeexe_isdll = asi64(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4347;
	R1 = 268435456;
	goto L4346;
L4347:
	R1 = 4194304;
L4346:
	mc_writeexe_imagebase = asi64(R1);
	asu64(R1) = entrypoint;
	mc_writeexe_userentrypoint = asu64(R1);
	mc_writeexe_loadlibs();
	mc_writeexe_scanst();
	mc_writeexe_getoffsets();
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writeexe_relocdata(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writeexe_relocdata(asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codeaddr = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L4349;
	asu64(R1) = mc_decls_riplist;
	pr = asu64(R1);
	goto L4353;
L4350:
	asu64(R1) = codeaddr;
	asu64(R2) = pr;
	R3 = 8;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	offsetptr = asu64(R1);
	asu64(R1) = pr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offsetptr;
	asu32(R2) = *tou32p(R2);
	R2 = toi64(tou32(R2));
	asi64(R3) = mc_writeexe_imagebase;
	asi64(R2) -= asi64(R3);
	asu64(R3) = pr;
	R4 = 8;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asi64(R1) = mc_writeexe_getripoffset(asi64(R3), asi64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	asu64(R2) = offsetptr;
	*tou32p(R2) = asu32(R1);
	asu64(R1) = pr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pr = asu64(R1);
L4353:
	asu64(R1) = pr;
	if (asu64(R1)) goto L4350;
L4349:
	return;
}

static void mc_writeexe_genexe2(u64 outfile, i64 dodll) {
    u64 R1, R2, R3; 
	struct $B39 header;
	struct $B84 optheader;
	i64 offset;
	i64 i;
	i64 aa;
	asu64(R1) = outfile;
	asu64(R1) = mlib_extractfile(asu64(R1));
	mc_writeexe_dllfilename = asu64(R1);
	asi64(R1) = dodll;
	mc_writeexe_isdll = asi64(R1);
	asi64(R1) = mc_writeexe_filesize;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	R2 = R1;
	mc_writeexe_dataptr = asu64(R2);
	mc_writeexe_datastart = asu64(R1);
	mc_writeexe_writedosstub();
	mc_writeexe_writepesig();
	mc_writeexe_writefileheader();
	mc_writeexe_writeoptheader();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4357;
L4355:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	mc_writeexe_writesectionheader(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4355;
L4357:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_writeexe_writepadding(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4360;
L4358:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	mc_writeexe_writesectiondata(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4358;
L4360:
	asu8(R1) = pc_decls_pverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4362;
	msysc_m$print_startcon();
	R1 = tou64("EXE size:  ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_writeexe_dataptr;
	asu64(R3) = mc_writeexe_datastart;
	asi64(R2) -= asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L4362:
	asu64(R1) = mc_writeexe_dataptr;
	asu64(R2) = mc_writeexe_datastart;
	asi64(R1) -= asi64(R2);
	asu64(R2) = mc_writeexe_datastart;
	asu64(R3) = outfile;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4364;
	msysc_m$print_startcon();
	R1 = tou64("Error writing exe file (possibly still running)");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L4364:
	return;
}

static void mc_writeexe_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	i64 hinst;
	u64 file;
	struct $B15 filename;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4368;
L4366:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4370;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filename;
	asi64(R1) = mlinux_os_getdllinst(asu64(R1));
	hinst = asi64(R1);
	asi64(R1) = hinst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4372;
	msysc_m$print_startcon();
	R1 = tou64("File:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't load search lib");
	mc_libmcl_axerror(asu64(R1));
L4372:
	asi64(R1) = hinst;
	R2 = (u64)&mc_writeexe_libinsttable;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&filename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_libinstnames;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4370:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4366;
L4368:
	return;
}

static void mc_writeexe_initsectiontable() {
    u64 R1, R2, R3; 
	R1 = tou64(".text");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_code;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L4375;
	msysc_m$print_startcon();
	R1 = tou64("Code size: ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_code;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("bytes");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = pc_decls_pverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4377;
	msysc_m$print_startcon();
	R1 = tou64("Idata size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_idata;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Code+Idata:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_code;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	asu64(R3) = mc_decls_ss_idata;
	asi64(R3) = mc_genss_bufferlength(asu64(R3));
	asi64(R2) += asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Zdata size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asi64(R2) = mc_decls_ss_zdatalen;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4377:
L4375:
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4379;
	R1 = 0;
	asu64(R2) = mc_decls_ss_idata;
	mc_genss_addqword(asu64(R2), asi64(R1));
L4379:
	R1 = tou64(".data");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idata;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idatarelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4381;
	R1 = 16;
	mc_decls_ss_zdatalen = asi64(R1);
L4381:
	R1 = tou64(".bss");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 3;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_coderelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64(".idata");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 5;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	mc_writeexe_nsections = asi64(R1);
	return;
}

static u64 mc_writeexe_extractlibname(u64 name, u64 libno, i64 moduleno) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 name2;
	struct $B16 str;
	struct $B16 str2;
	i64 i;
	i64 n;
	R1 = 0;
	name2 = asu64(R1);
// mc_writeexe.extractlibname.reenter:
	asu64(R1) = name;
	s = asu64(R1);
	R1 = 0;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	goto L4385;
L4384:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L4388;
	asu64(R1) = s;
	asu64(R2) = name;
	asu64(R1) -= asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asu64(R4) = name;
	asi64(R3) -= asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = tou64(".dll");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4391;
L4389:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4393;
	asi64(R1) = i;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asu64(R2) = libno;
	asi64(R2) = *toi64p(R2);
	R1 += (i64)R2*48-40;
	(*toi64p(R1)) += 1;
	asu64(R1) = name2;
	if (!asu64(R1)) goto L4395;
	asu64(R1) = name2;
	goto L4394;
L4395:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
L4394:
	goto L4382;
L4393:
	i += 1; if (i <= mc_writeexe_ndlls) goto L4389;
L4391:
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4397;
	R1 = tou64("Too many libs");
	mc_libmcl_axerror(asu64(R1));
L4397:
	R1 = (u64)&mc_writeexe_ndlls;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = name2;
	if (!asu64(R1)) goto L4399;
	asu64(R1) = name2;
	goto L4398;
L4399:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
L4398:
	goto L4382;
L4388:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L4385:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L4384;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4403;
L4400:
	R1 = (u64)&mc_writeexe_libinsttable;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L4405;
	asu64(R1) = name;
	R2 = (u64)&mc_writeexe_libinsttable;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlinux_os_getdllprocaddr(asi64(R2), asu64(R1));
	if (!asu64(R1)) goto L4407;
	asi64(R1) = i;
	n = asi64(R1);
	goto L4402;
L4407:
L4405:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4400;
L4403:
	msysc_m$print_startcon();
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find external function");
	mc_libmcl_axerror(asu64(R1));
L4402:
	R1 = (u64)&mc_writeexe_libnotable;
	asi64(R2) = n;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	asu64(R3) = libno;
	*toi64p(R3) = asi64(R2);
	if (!asi64(R1)) goto L4409;
	R1 = (u64)&mc_writeexe_dlltable;
	asu64(R2) = libno;
	asi64(R2) = *toi64p(R2);
	R1 += (i64)R2*48-40;
	(*toi64p(R1)) += 1;
	asu64(R1) = name;
	goto L4382;
L4409:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".dll");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4411;
	R1 = tou64("2:Too many libs");
	mc_libmcl_axerror(asu64(R1));
L4411:
	R1 = (u64)&mc_writeexe_ndlls;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = libno;
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&mc_writeexe_libnotable;
	asi64(R3) = n;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = name;
	goto L4382;
L4382:
	return asu64(R1);
}

static void mc_writeexe_scanst() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 libno;
	u64 d;
	u64 name;
	u64 libname;
	u64 basename;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4415;
L4413:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4417;
	asi64(R1) = mc_writeexe_nimports;
	R2 = 3000;
	if (asi64(R1) < asi64(R2)) goto L4419;
	R1 = tou64("genexe: Too many imports");
	mc_libmcl_axerror(asu64(R1));
L4419:
	R1 = (u64)&mc_writeexe_nimports;
	(*toi64p(R1)) += 1;
	R1 = 1;
	R2 = (u64)&libno;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mc_writeexe_extractlibname(asu64(R3), asu64(R2), asi64(R1));
	name = asu64(R1);
	asi64(R1) = libno;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = name;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mc_writeexe_nimports;
	asu64(R2) = d;
	R3 = 98;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L4416;
L4417:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4420;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	basename = asu64(R1);
	asu64(R1) = mc_writeexe_userentrypoint;
	if (!asu64(R1)) goto L4422;
	asu64(R1) = mc_writeexe_userentrypoint;
	asu64(R2) = basename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4424;
	asu64(R1) = d;
	mc_writeexe_stentrypoint = asu64(R1);
L4424:
	goto L4421;
L4422:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4426;
	asi64(R1) = mc_writeexe_isdll;
	if (asi64(R1)) goto L4426;
	asu64(R1) = d;
	mc_writeexe_stentrypoint = asu64(R1);
L4426:
L4421:
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L4428;
	R1 = tou64("gendll: Too many exports");
	mc_libmcl_axerror(asu64(R1));
L4428:
	R1 = (u64)&mc_writeexe_nexports;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = (u64)&mc_writeexe_exporttable;
	asi64(R3) = mc_writeexe_nexports;
	R2 += (i64)R3*16-16;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	R2 = (u64)&mc_writeexe_exporttable;
	asi64(R3) = mc_writeexe_nexports;
	R2 += (i64)R3*16-16;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4420:
L4416:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4413;
L4415:
	return;
}

static void mc_writeexe_relocdata(u64 s) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 r;
	u64 p;
	u64 p32;
	u64 p64;
	u64 d;
	i64 offset;
	i64 index;
	i64 thunkoffset;
	i64 iatoffset;
	R1 = 0;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = s;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L4431;
L4430:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 98;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = index;
	R1 += (i64)R2*48;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	thunkoffset = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4434;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4435;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4435;
	goto L4436;
L4434:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4438;
	R1 = tou64("rel32/not imported");
	mc_libmcl_axerror(asu64(R1));
L4438:
	asi64(R1) = thunkoffset;
	asu64(R2) = r;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 4;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4433;
L4435:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4440;
	asi64(R1) = mc_writeexe_imagebase;
	asi64(R2) = thunkoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4439;
L4440:
	R1 = 0;
	u = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4442;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4443;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4444;
	goto L4445;
L4442:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 144;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4441;
L4443:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4441;
L4444:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4441;
L4445:
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("RELOCDATA/SEG?");
	mc_libmcl_axerror(asu64(R1));
L4441:
	asu64(R1) = p;
	asu64(R2) = r;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	p32 = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4447;
	asu64(R1) = p32;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R2) = u;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_writeexe_imagebase;
	asi64(R1) += asi64(R2);
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	goto L4446;
L4447:
	asu64(R1) = p32;
	p64 = asu64(R1);
	asu64(R1) = p64;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = u;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_writeexe_imagebase;
	asu64(R1) += asu64(R2);
	asu64(R2) = p64;
	*tou64p(R2) = asu64(R1);
L4446:
L4439:
	goto L4433;
L4436:
	msysc_m$print_startcon();
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't do this rel type");
	mc_libmcl_axerror(asu64(R1));
L4433:
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4431:
	asu64(R1) = r;
	if (asu64(R1)) goto L4430;
	return;
}

static void mc_writeexe_getbaserelocs(u64 s) {
    u64 R1, R2, R3, R4; 
	u64 r;
	u64 p;
	u64 d;
	i64 index;
	R1 = 0;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = s;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L4450;
L4449:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4453;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4453;
	goto L4454;
L4453:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4456;
	goto L4455;
L4456:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4458;
	goto L4457;
L4458:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	mc_writeexe_newbasereloc(asi64(R2), asi64(R1));
L4457:
L4455:
	goto L4452;
L4454:
L4452:
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4450:
	asu64(R1) = r;
	if (asu64(R1)) goto L4449;
	return;
}

static void mc_writeexe_writerecordx(u64 r, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = r;
	asu64(R3) = mc_writeexe_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&mc_writeexe_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeexe_writedosstub() {
    u64 R1, R2; 
// PROC LOCAL STATICS GO HERE
	static struct $B21 mc_writeexe_writedosstub_stubdata = {{
12894362189,
	281470681743364,
	184,
	64,
	0,
	0,
	0,
	549755813888,
	-3672206108803850482,
	7517670843615393825,
	8243680180223112041,
	8029476550202125665,
	7959393399912669300,
	2329292586301155616,
	724249607997255533,
	36    }};
	R1 = 128;
	R2 = (u64)&mc_writeexe_writedosstub_stubdata;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writepesig() {
    u64 R1, R2, R3; 
	R1 = 80;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 69;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_writeexe_writepadding(i64 offset) {
    u64 R1, R2; 
	asu64(R1) = mc_writeexe_datastart;
	asi64(R2) = offset;
	R1 += (i64)R2;
	mc_writeexe_dataptr = asu64(R1);
	return;
}

static void mc_writeexe_writefileheader() {
    u64 R1, R2, R3; 
	struct $B39 header;
	R1 = (u64)&header;
	memset(R1, 0, 20);
	R1 = 34404;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = (u64)&header;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 240;
	R2 = (u64)&header;
	R3 = 16;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 559;
	R2 = (u64)&header;
	R3 = 18;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4465;
	R1 = 8750;
	R2 = (u64)&header;
	R3 = 18;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L4465:
	R1 = 20;
	R2 = (u64)&header;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writeoptheader() {
    u64 R1, R2, R3; 
	struct $B84 header;
	R1 = (u64)&header;
	memset(R1, 0, 240);
	R1 = 523;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&header;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&header;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 2;
	R1 += (i64)R2*72-72;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	R2 = (u64)&header;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&header;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = mc_writeexe_stentrypoint;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4468;
	asu64(R1) = mc_writeexe_stentrypoint2;
	mc_writeexe_stentrypoint = asu64(R1);
L4468:
	asu64(R1) = mc_writeexe_stentrypoint;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4470;
	asu64(R1) = mc_writeexe_userentrypoint;
	if (!asu64(R1)) goto L4472;
	msysc_m$print_startcon();
	asu64(R1) = mc_writeexe_userentrypoint;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("User entry point not found");
	mc_libmcl_axerror(asu64(R1));
	goto L4471;
L4472:
	asi64(R1) = mc_writeexe_isdll;
	if (asi64(R1)) goto L4474;
	R1 = tou64("Entry point not found: main");
	mc_libmcl_axerror(asu64(R1));
L4474:
L4471:
	goto L4469;
L4470:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_writeexe_stentrypoint;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = (u64)&header;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4469:
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&header;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 32;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 512;
	R2 = (u64)&header;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 4;
	R2 = (u64)&header;
	R3 = 40;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 0;
	R2 = (u64)&header;
	R3 = 42;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&header;
	R3 = 48;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 2;
	R2 = (u64)&header;
	R3 = 50;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_imagesize;
	R2 = (u64)&header;
	R3 = 56;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 60;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = (u64)&header;
	R3 = 68;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 4194304;
	R2 = (u64)&header;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2097152;
	R2 = (u64)&header;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1048576;
	R2 = (u64)&header;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 16;
	R2 = (u64)&header;
	R3 = 108;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeexe_exportdirvirtsize;
	asi64(R1) -= asi64(R2);
	asi64(R2) = mc_writeexe_blockdirvirtsize;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&header;
	R3 = 124;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4476;
	R1 = 64;
	R2 = (u64)&header;
	R3 = 70;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_exportdirvirtaddr;
	R2 = (u64)&header;
	R3 = 112;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_exportdirvirtsize;
	R2 = (u64)&header;
	R3 = 116;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_blockdirvirtaddr;
	R2 = (u64)&header;
	R3 = 152;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_blockdirvirtsize;
	R2 = (u64)&header;
	R3 = 156;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4476:
	asi64(R1) = mc_writeexe_fileiatoffset;
	R2 = (u64)&header;
	R3 = 208;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_fileiatsize;
	R2 = (u64)&header;
	R3 = 212;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 240;
	R2 = (u64)&header;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writesectionheader(u64 s) {
    u64 R1, R2, R3; 
	struct $B71 sheader;
	i64 aa;
	R1 = (u64)&sheader;
	memset(R1, 0, 40);
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4479;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4480;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4481;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4482;
	goto L4483;
L4479:
	R1 = 3226468480;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4478;
L4480:
	R1 = 3226468416;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4478;
L4481:
	R1 = 1615855648;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4478;
L4482:
	R1 = 3224371264;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4478;
L4483:
L4478:
	R1 = 40;
	R2 = (u64)&sheader;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writesectiondata(u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = s;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4486;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4487;
	goto L4488;
L4486:
	asu64(R1) = s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L4490;
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mc_writeexe_dataptr;
	*tou64p(R2) += asu64(R1);
L4490:
	goto L4485;
L4487:
	goto L4485;
L4488:
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R3) = s;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
L4485:
	return;
}

static void mc_writeexe_writeexporttable(u64 pstart) {
    u64 R1, R2, R3; 
	struct $B49 sortindex;
	u64 phdr;
	u64 paddrtable;
	u64 pnametable;
	u64 pordtable;
	u64 pdllname;
	u64 pnames;
	i64 addrtableoffset;
	i64 nametableoffset;
	i64 ordtableoffset;
	i64 dllnameoffset;
	i64 namesoffset;
	i64 virtoffset;
	i64 sectionno;
	u64 d;
	u64 basename;
	i64 i;
	asu64(R1) = pstart;
	phdr = asu64(R1);
	R1 = 1602876664;
	asu64(R2) = phdr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = phdr;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_nexports;
	asu64(R2) = phdr;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_nexports;
	asu64(R2) = phdr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 40;
	addrtableoffset = asi64(R1);
	asi64(R1) = addrtableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 4;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	nametableoffset = asi64(R1);
	asi64(R1) = nametableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 4;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	ordtableoffset = asi64(R1);
	asi64(R1) = ordtableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	dllnameoffset = asi64(R1);
	asi64(R1) = dllnameoffset;
	asu64(R2) = mc_writeexe_dllfilename;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	namesoffset = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeexe_exportdiroffset;
	asi64(R1) += asi64(R2);
	virtoffset = asi64(R1);
	asu64(R1) = pstart;
	asi64(R2) = addrtableoffset;
	R1 += (i64)R2;
	paddrtable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = nametableoffset;
	R1 += (i64)R2;
	pnametable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = ordtableoffset;
	R1 += (i64)R2;
	pordtable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = dllnameoffset;
	R1 += (i64)R2;
	pdllname = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = namesoffset;
	R1 += (i64)R2;
	pnames = asu64(R1);
	asi64(R1) = dllnameoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = addrtableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 28;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = nametableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 32;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = ordtableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = mc_writeexe_dllfilename;
	asu64(R2) = pdllname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mc_writeexe_nexports;
	R2 = 2000;
	if (asi64(R1) <= asi64(R2)) goto L4493;
	R1 = tou64("Too many exports - can't sort");
	mc_libmcl_axerror(asu64(R1));
L4493:
	R1 = (u64)&sortindex;
	mc_writeexe_sortexports(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4496;
L4494:
	R1 = (u64)&mc_writeexe_exporttable;
	R2 = (u64)&sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&mc_writeexe_exporttable;
	R2 = (u64)&sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	basename = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R1) = mc_writeexe_getsectionno(asi64(R1));
	sectionno = asi64(R1);
	asu64(R1) = basename;
	asu64(R2) = pnames;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = namesoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = pnametable;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&pnametable;
	(*tou64p(R1)) += 4;
	asu64(R1) = basename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&namesoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = basename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&pnames;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = sectionno;
	R2 += (i64)R3*72-72;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = paddrtable;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&paddrtable;
	(*tou64p(R1)) += 4;
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pordtable;
	*tou16p(R2) = asu16(R1);
	R1 = (u64)&pordtable;
	(*tou64p(R1)) += 2;
	i += 1; if (i <= mc_writeexe_nexports) goto L4494;
L4496:
	return;
}

static i64 mc_writeexe_getexporttablesize() {
    u64 R1, R2; 
	i64 size;
	i64 i;
	R1 = 40;
	size = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = mc_writeexe_dllfilename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4500;
L4498:
	R1 = (u64)&mc_writeexe_exporttable;
	asi64(R2) = i;
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_nexports) goto L4498;
L4500:
	asi64(R1) = size;
	goto L4497;
L4497:
	return asi64(R1);
}

static void mc_writeexe_newbasereloc(i64 addr, i64 reltype) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = addr;
	asu64(R2) = p;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = reltype;
	asu64(R2) = p;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	mc_writeexe_basereloclist = asu64(R1);
	R1 = (u64)&mc_writeexe_nbaserelocs;
	(*toi64p(R1)) += 1;
	asi64(R1) = addr;
	R2 = (u64)&mc_writeexe_maxrelocaddr;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	return;
}

static void mc_writeexe_scanbaserelocs() {
    u64 R1, R2, R3; 
	i64 baseaddr;
	i64 addr;
	i64 nextblock;
	u64 p;
	i64 i;
	R1 = 4096;
	baseaddr = asi64(R1);
	R1 = 0;
	mc_writeexe_nbaseblocks = asi64(R1);
L4503:
	asi64(R1) = baseaddr;
	R2 = 4096;
	asi64(R1) += asi64(R2);
	nextblock = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 500;
	if (asi64(R1) < asi64(R2)) goto L4507;
	R1 = tou64("Too many blocks");
	mc_libmcl_axerror(asu64(R1));
L4507:
	R1 = (u64)&mc_writeexe_nbaseblocks;
	(*toi64p(R1)) += 1;
	asi64(R1) = baseaddr;
	R2 = (u64)&mc_writeexe_blockbases;
	asi64(R3) = mc_writeexe_nbaseblocks;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_blockcounts;
	asi64(R3) = mc_writeexe_nbaseblocks;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	p = asu64(R1);
	goto L4509;
L4508:
	asu64(R1) = p;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	addr = asi64(R1);
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	if (asi64(R1) < asi64(R2)) goto L4512;
	asi64(R1) = addr;
	asi64(R2) = nextblock;
	if (asi64(R1) >= asi64(R2)) goto L4512;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = mc_writeexe_nbaseblocks;
	R1 += (i64)R2*4-4;
	(*toi32p(R1)) += 1;
L4512:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4509:
	asu64(R1) = p;
	if (asu64(R1)) goto L4508;
	asi64(R1) = nextblock;
	baseaddr = asi64(R1);
	asi64(R1) = baseaddr;
	asi64(R2) = mc_writeexe_maxrelocaddr;
	if (asi64(R1) <= asi64(R2)) goto L4503;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4515;
L4513:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	if (!asi32(R1)) goto L4517;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4519;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	R1 += (i64)R2*4-4;
	(*toi32p(R1)) += 1;
	R1 = (u64)&mc_writeexe_blockpadding;
	asi64(R2) = i;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L4519:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 8;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeexe_blockbytes;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&mc_writeexe_blockbytes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_writeexe_basetablesize;
	*toi64p(R2) += asi64(R1);
L4517:
	i += 1; if (i <= mc_writeexe_nbaseblocks) goto L4513;
L4515:
	return;
}

static void mc_writeexe_writebasereloctable(u64 pstart) {
    u64 R1, R2, R3; 
	u64 p32;
	u64 p16;
	i64 baseaddr;
	i64 addr;
	i64 nextblock;
	u64 q;
	i64 i;
	asu64(R1) = pstart;
	p32 = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4523;
L4521:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	if (!asi32(R1)) goto L4525;
	R1 = (u64)&mc_writeexe_blockbases;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&p32;
	(*tou64p(R1)) += 4;
	R1 = (u64)&mc_writeexe_blockbytes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&p32;
	(*tou64p(R1)) += 4;
	asu64(R1) = p32;
	p16 = asu64(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	q = asu64(R1);
	R1 = (u64)&mc_writeexe_blockbases;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	baseaddr = asi64(R1);
	asi64(R1) = baseaddr;
	R2 = 4096;
	asi64(R1) += asi64(R2);
	nextblock = asi64(R1);
	goto L4527;
L4526:
	asu64(R1) = q;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	addr = asi64(R1);
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	if (asi64(R1) < asi64(R2)) goto L4530;
	asi64(R1) = addr;
	asi64(R2) = nextblock;
	if (asi64(R1) >= asi64(R2)) goto L4530;
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = q;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 2;
	if (asi64(R2) != asi64(R3)) goto L4532;
	R2 = 3;
	goto L4531;
L4532:
	R2 = 10;
L4531:
	R3 = 12;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = p16;
	*tou16p(R2) = asu16(R1);
	R1 = (u64)&p16;
	(*tou64p(R1)) += 2;
L4530:
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L4527:
	asu64(R1) = q;
	if (asu64(R1)) goto L4526;
	R1 = (u64)&mc_writeexe_blockpadding;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4534;
	R1 = 0;
	R2 = (u64)&p16;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 2; asu64(R2) = asu64(R3);
	*tou16p(R2) = asu16(R1);
L4534:
	asu64(R1) = p16;
	p32 = asu64(R1);
L4525:
	i += 1; if (i <= mc_writeexe_nbaseblocks) goto L4521;
L4523:
	return;
}

static void mc_writeexe_sortexports(u64 sortindex) {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	i64 swapped;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4538;
L4536:
	asi64(R1) = i;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	i += 1; if (i <= mc_writeexe_nexports) goto L4536;
L4538:
L4539:
	R1 = 0;
	swapped = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4544;
L4542:
	R1 = (u64)&mc_writeexe_exporttable;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&mc_writeexe_exporttable;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4546;
	R1 = 1;
	swapped = asi64(R1);
	asu64(R1) = sortindex;
	asi64(R2) = i;
	R1 += (i64)R2*8-8;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	R2 += (i64)R3*8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L4546:
	i += 1; if (i <= av_1) goto L4542;
L4544:
	asi64(R1) = swapped;
	if (asi64(R1)) goto L4539;
	return;
}

static i64 mc_writeexe_getsectionno(i64 segment) {
    u64 R1, R2; 
	asi64(R1) = segment;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4549;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4550;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4551;
	goto L4552;
L4549:
	R1 = 3;
	goto L4548;
L4550:
	R1 = 2;
	goto L4548;
L4551:
	R1 = 1;
	goto L4548;
L4552:
	R1 = tou64("GSN");
	mc_libmcl_axerror(asu64(R1));
	R1 = 0;
L4548:
	goto L4547;
L4547:
	return asi64(R1);
}

static void mc_writeexe_getoffsets() {
    u64 R1, R2, R3, R4; 
	i64 fileoffset;
	i64 imageoffset;
	i64 i;
	i64 diroffset;
	i64 impdirno;
	i64 hinttableoffset;
	i64 j;
	i64 n;
	i64 codesize;
	i64 length;
	i64 thunkoffset;
	i64 offset;
	i64 dirstartoffset;
	u64 pcode;
	u64 pimpdir;
	u64 pdir;
	u64 paddr;
	u64 pname;
	i64 iatoffset;
	u64 phint;
	u64 pextra;
	i64 xxx;
	i64 av_1;
	u64 thunkptr;
	u64 codebase;
	i64 thunkaddr;
	R1 = 392;
	fileoffset = asi64(R1);
	R1 = 40;
	asi64(R2) = mc_writeexe_nsections;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&fileoffset;
	*toi64p(R2) += asi64(R1);
	R1 = 512;
	asi64(R2) = fileoffset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	fileoffset = asi64(R1);
	R1 = 4096;
	imageoffset = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	codesize = asi64(R1);
	asi64(R1) = codesize;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	pcode = asu64(R1);
	goto L4555;
L4554:
	R1 = 144;
	R2 = (u64)&pcode;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&codesize;
	(*toi64p(R1)) += 1;
L4555:
	asi64(R1) = codesize;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4554;
	asi64(R1) = codesize;
	thunkoffset = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&codesize;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = codesize;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = codesize;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = codesize;
	asi64(R2) = thunkoffset;
	asi64(R1) -= asi64(R2);
	R2 = 16;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_decls_ss_code;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4559;
L4557:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4561;
	asi64(R1) = fileoffset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = i;
	R2 += (i64)R3*72-72;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4561:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4563;
	R1 = 512;
	asi64(R2) = fileoffset;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = i;
	R3 += (i64)R4*72-72;
	R4 = 40;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	fileoffset = asi64(R1);
L4563:
	asi64(R1) = imageoffset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = i;
	R2 += (i64)R3*72-72;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4565;
	asi64(R1) = imageoffset;
	diroffset = asi64(R1);
	asi64(R1) = i;
	impdirno = asi64(R1);
L4565:
	R1 = 4096;
	asi64(R2) = imageoffset;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = i;
	R3 += (i64)R4*72-72;
	R4 = 40;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	imageoffset = asi64(R1);
	i += 1; if (i <= mc_writeexe_nsections) goto L4557;
L4559:
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4567;
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writeexe_getbaserelocs(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writeexe_getbaserelocs(asu64(R1));
L4567:
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 20;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4570;
L4568:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4568;
L4570:
	asi64(R1) = diroffset;
	mc_writeexe_fileiatoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4573;
L4571:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4571;
L4573:
	asi64(R1) = diroffset;
	asi64(R2) = mc_writeexe_fileiatoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_fileiatsize = asi64(R1);
	asi64(R1) = diroffset;
	hinttableoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4576;
L4574:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	R1 += (i64)R2*48;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 3;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4578;
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L4578:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_nimports) goto L4574;
L4576:
	R1 = 4;
	asi64(R2) = diroffset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	diroffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4581;
L4579:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4583;
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L4583:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4579;
L4581:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = impdirno;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	dirstartoffset = asi64(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4585;
	asi64(R1) = diroffset;
	mc_writeexe_exportdirvirtaddr = asi64(R1);
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_exportdiroffset = asi64(R1);
	asi64(R1) = mc_writeexe_getexporttablesize();
	mc_writeexe_exportdirvirtsize = asi64(R1);
	asi64(R1) = mc_writeexe_exportdirvirtsize;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	mc_writeexe_scanbaserelocs();
	asi64(R1) = diroffset;
	mc_writeexe_blockdirvirtaddr = asi64(R1);
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_blockdiroffset = asi64(R1);
	asi64(R1) = mc_writeexe_basetablesize;
	mc_writeexe_blockdirvirtsize = asi64(R1);
	asi64(R1) = mc_writeexe_blockdirvirtsize;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
L4585:
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = impdirno;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = offset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = impdirno;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = fileoffset;
	asi64(R3) = offset;
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_writeexe_filesize = asi64(R1);
	R1 = 4096;
	asi64(R2) = imageoffset;
	asi64(R3) = diroffset;
	asi64(R4) = dirstartoffset;
	asi64(R3) -= asi64(R4);
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_writeexe_imagesize = asi64(R1);
	asi64(R1) = offset;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	R2 = R1;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = impdirno;
	R3 += (i64)R4*72-72;
	R4 = 0;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	pimpdir = asu64(R1);
	asu64(R1) = pimpdir;
	pdir = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4588;
L4586:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pdir;
	(*tou64p(R1)) += 20;
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	iatoffset = asi64(R1);
	asu64(R1) = pimpdir;
	asi64(R2) = iatoffset;
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	paddr = asu64(R1);
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	pname = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4591;
L4589:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = j;
	R1 += (i64)R2*48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L4593;
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = j;
	R1 += (i64)R2*48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = paddr;
	*toi64p(R3) = asi64(R2);
	asu64(R2) = pname;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = iatoffset;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = j;
	R2 += (i64)R3*48;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	R2 = (u64)&iatoffset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&pname;
	(*tou64p(R1)) += 8;
	R1 = (u64)&paddr;
	(*tou64p(R1)) += 8;
L4593:
	j += 1; if (j <= mc_writeexe_nimports) goto L4589;
L4591:
	i += 1; if (i <= mc_writeexe_ndlls) goto L4586;
L4588:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4596;
L4594:
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	phint = asu64(R1);
	R1 = 2;
	R2 = (u64)&phint;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	R1 += (i64)R2*48;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = phint;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_writeexe_nimports) goto L4594;
L4596:
	asi64(R1) = dirstartoffset;
	xxx = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4599;
L4597:
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	pextra = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4602;
L4600:
	asi64(R1) = xxx;
	asu64(R2) = pextra;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&pextra;
	(*tou64p(R1)) += 4;
	j += 1; if (j <= av_1) goto L4600;
L4602:
	R1 = 20;
	R2 = (u64)&xxx;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	phint = asu64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = phint;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_writeexe_ndlls) goto L4597;
L4599:
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4604;
	asu64(R1) = pimpdir;
	asi64(R2) = mc_writeexe_exportdiroffset;
	R1 += (i64)R2;
	mc_writeexe_writeexporttable(asu64(R1));
	asu64(R1) = pimpdir;
	asi64(R2) = mc_writeexe_blockdiroffset;
	R1 += (i64)R2;
	mc_writeexe_writebasereloctable(asu64(R1));
L4604:
	asi64(R1) = thunkoffset;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	thunkptr = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codebase = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4607;
L4605:
	asu64(R1) = thunkptr;
	asu64(R2) = codebase;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4609;
	R1 = 72;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 36;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	thunkaddr = asi64(R1);
	asi64(R1) = thunkaddr;
	asu64(R2) = thunkptr;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&thunkptr;
	*tou64p(R2) += asu64(R1);
	goto L4608;
L4609:
	R1 = 72;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	thunkaddr = asi64(R1);
	R1 = 0;
	asi64(R2) = thunkaddr;
	asi64(R3) = mc_writeexe_imagebase;
	asi64(R2) -= asi64(R3);
	asu64(R3) = thunkptr;
	asu64(R4) = codebase;
	asi64(R3) -= asi64(R4);
	asi64(R1) = mc_writeexe_getripoffset(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = thunkptr;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&thunkptr;
	*tou64p(R2) += asu64(R1);
	R1 = 144;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4608:
	i += 1; if (i <= mc_writeexe_nimports) goto L4605;
L4607:
	return;
}

static i64 mc_writeexe_getripoffset(i64 addr, i64 dest, i64 extra) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&addr;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = dest;
	asi64(R2) = addr;
	R3 = 4;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) -= asi64(R2);
	goto L4610;
L4610:
	return asi64(R1);
}

static void mc_writeobj_writecoff(u64 outfile) {
    u64 R1, R2, R3; 
	struct $B39 header;
	struct $B71 zsection;
	struct $B71 isection;
	struct $B71 csection;
	i64 offset;
	i64 aa;
	asu8(R1) = pc_decls_objdone;
	if (!asu8(R1)) goto L4613;
	goto L4611;
L4613:
	R1 = (u64)&header;
	memset(R1, 0, 20);
	R1 = (u64)&zsection;
	memset(R1, 0, 40);
	R1 = (u64)&isection;
	memset(R1, 0, 40);
	R1 = (u64)&csection;
	memset(R1, 0, 40);
	R1 = 34404;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3;
	R2 = (u64)&header;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = tou64(".bss");
	R2 = (u64)&zsection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&zsection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3225419904;
	R2 = (u64)&zsection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = 65536;
	if (asi64(R1) >= asi64(R2)) goto L4616;
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L4615;
L4616:
	R1 = tou64("Too many relocs (exceeds 16-bit field)");
	mc_libmcl_axerror(asu64(R1));
L4615:
	R1 = tou64(".data");
	R2 = (u64)&isection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&isection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = (u64)&isection;
	R3 = 32;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3226468416;
	R2 = (u64)&isection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = tou64(".text");
	R2 = (u64)&csection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&csection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = (u64)&csection;
	R3 = 32;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1615855648;
	R2 = (u64)&csection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = outfile;
	mc_writeobj_initsymboltable(asu64(R1));
	mc_writeobj_convertsymboltable();
	R1 = 20;
	offset = asi64(R1);
	R1 = 120;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&isection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L4618;
	asi64(R1) = offset;
	R2 = (u64)&isection;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&isection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4618:
	R1 = (u64)&csection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L4620;
	asi64(R1) = offset;
	R2 = (u64)&csection;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&csection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4620:
	asi64(R1) = offset;
	R2 = (u64)&isection;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&isection;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&csection;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&csection;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&header;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 18;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = (u64)&header;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeobj_nextstringoffset;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	asu64(R1) = malloc(asu64(R1));
	R2 = R1;
	mc_writeobj_dataptr = asu64(R2);
	mc_writeobj_datastart = asu64(R1);
	R1 = 20;
	R2 = (u64)&header;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&zsection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&isection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&csection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asu64(R2) = mc_decls_ss_idatarelocs;
	mc_writeobj_writerelocs(asu64(R2), asi64(R1));
	asi64(R1) = mc_decls_ss_ncoderelocs;
	asu64(R2) = mc_decls_ss_coderelocs;
	mc_writeobj_writerelocs(asu64(R2), asi64(R1));
	asu64(R1) = mc_decls_ss_idata;
	mc_writeobj_writedata(asu64(R1));
	asu64(R1) = mc_decls_ss_code;
	mc_writeobj_writedata(asu64(R1));
	mc_writeobj_writesymboltable();
	mc_writeobj_writestringtable();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L4622;
	msysc_m$print_startcon();
	R1 = tou64("Writing file:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4622:
	asu64(R1) = mc_writeobj_dataptr;
	asu64(R2) = mc_writeobj_datastart;
	asi64(R1) -= asi64(R2);
	asu64(R2) = mc_writeobj_datastart;
	asu64(R3) = outfile;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	pc_decls_objdone = asu8(R1);
L4611:
	return;
}

static void mc_writeobj_writerecord(u64 r, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = r;
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeobj_writerelocs(u64 r, i64 nrelocs) {
    u64 R1, R2, R3; 
	u64 d;
	asi64(R1) = nrelocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4626;
	goto L4624;
L4626:
	goto L4628;
L4627:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4631;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4631;
	goto L4632;
L4631:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4634;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4635;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4636;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4637;
	goto L4638;
L4634:
	R1 = 2;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4633;
L4635:
	R1 = 4;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4633;
L4636:
	R1 = 6;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4633;
L4637:
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeobj_stoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4633;
L4638:
	R1 = tou64("wrelocs/bad seg");
	mc_libmcl_axerror(asu64(R1));
L4633:
	goto L4630;
L4632:
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeobj_stoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4630:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4640;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4641;
	goto L4642;
L4640:
	goto L4639;
L4641:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4644;
	R1 = 4;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 4;
	asu64(R2) = r;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4644:
	goto L4639;
L4642:
	R1 = tou64("OBJ/phighmem 1?");
	mc_libmcl_axerror(asu64(R1));
L4639:
	asu64(R1) = r;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4628:
	asu64(R1) = r;
	if (asu64(R1)) goto L4627;
L4624:
	return;
}

static void mc_writeobj_writedata(u64 data) {
    u64 R1, R2, R3; 
	asu64(R1) = data;
	asu64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = 0;
	asu64(R3) = data;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = data;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeobj_writesymboltable() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4649;
L4647:
	R1 = 18;
	R2 = (u64)&mc_writeobj_symboltable;
	asi64(R3) = i;
	R2 += (i64)R3*18;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	i += 1; if (i <= mc_writeobj_nsymbols) goto L4647;
L4649:
	return;
}

static void mc_writeobj_writestringtable() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	i64 n;
	asu64(R1) = mc_writeobj_dataptr;
	p = asu64(R1);
	asi64(R1) = mc_writeobj_nextstringoffset;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeobj_nstrings;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4653;
L4651:
	R1 = (u64)&mc_writeobj_stringlengths;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = (u64)&mc_writeobj_stringtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	i += 1; if (i <= mc_writeobj_nstrings) goto L4651;
L4653:
	return;
}

static u64 mc_writeobj_makesymbol(u64 name, i64 value, i64 sectionno, i64 symtype, i64 storage, i64 naux) {
    u64 R1, R2, R3, R4; 
	i64 length;
	i64 namelen;
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	namelen = asi64(R1);
	asi64(R1) = namelen;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L4656;
	asu64(R1) = name;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4655;
L4656:
	asi64(R1) = namelen;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4657;
	asi64(R1) = namelen;
	asu64(R2) = name;
	R3 = (u64)&mc_writeobj_makesymbol_r;
	R4 = 0;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L4655;
L4657:
	R1 = 0;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = namelen;
	asu64(R2) = name;
	asi64(R1) = mc_writeobj_addstringentry(asu64(R2), asi64(R1));
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4655:
	asi64(R1) = value;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = sectionno;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = symtype;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 14;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = storage;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = naux;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_writeobj_makesymbol_r;
	goto L4654;
L4654:
	return asu64(R1);
}

static void mc_writeobj_addsymbol(u64 r) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 13000;
	if (asi64(R1) < asi64(R2)) goto L4660;
	R1 = tou64("as:Too many symbols");
	mc_libmcl_axerror(asu64(R1));
L4660:
	R1 = 18;
	asu64(R2) = r;
	R3 = (u64)&mc_writeobj_symboltable;
	R4 = (u64)&mc_writeobj_nsymbols;
	asi64(R4) = *(toi64p(R4)) += 1;
	R3 += (i64)R4*18;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_writeobj_initsymboltable(u64 filename) {
    u64 R1, R2, R3, R4, R5, R6; 
	R1 = 0;
	mc_writeobj_nsymbols = asi64(R1);
	R1 = 1;
	R2 = 103;
	R3 = 0;
	R4 = -2;
	R5 = 0;
	R6 = tou64(".file");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asu64(R1) = filename;
	asu64(R1) = mc_writeobj_strtoaux(asu64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 1;
	R5 = 0;
	R6 = tou64(".bss");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 2;
	R5 = 0;
	R6 = tou64(".data");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asu64(R2) = mc_decls_ss_idata;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 3;
	R5 = 0;
	R6 = tou64(".text");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asi64(R1) = mc_decls_ss_ncoderelocs;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	return;
}

static u64 mc_writeobj_strtoaux(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	i64 n;
	R1 = (u64)&mc_writeobj_strtoaux_r;
	p = asu64(R1);
	R1 = 18;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 0;
	n = asi64(R1);
	goto L4664;
L4663:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L4664:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4666;
	asi64(R1) = n;
	R2 = 18;
	if (asi64(R1) < asi64(R2)) goto L4663;
L4666:
	R1 = (u64)&mc_writeobj_strtoaux_r;
	goto L4662;
L4662:
	return asu64(R1);
}

static u64 mc_writeobj_sectiontoaux(u64 data, i64 nrelocs) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_writeobj_sectiontoaux_r;
	memset(R1, 0, 18);
	asu64(R1) = data;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4669;
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4668;
L4669:
	asu64(R1) = data;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4668:
	asi64(R1) = nrelocs;
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 4;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mc_writeobj_sectiontoaux_r;
	goto L4667;
L4667:
	return asu64(R1);
}

static i64 mc_writeobj_addstringentry(u64 s, i64 length) {
    u64 R1, R2, R3; 
	i64 offset;
	asi64(R1) = mc_writeobj_nextstringoffset;
	offset = asi64(R1);
	asi64(R1) = mc_writeobj_nstrings;
	R2 = 5000;
	if (asi64(R1) <= asi64(R2)) goto L4672;
	R1 = tou64("W:too many strings");
	mc_libmcl_axerror(asu64(R1));
L4672:
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeobj_stringtable;
	R3 = (u64)&mc_writeobj_nstrings;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = length;
	R2 = (u64)&mc_writeobj_stringlengths;
	asi64(R3) = mc_writeobj_nstrings;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_nextstringoffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	goto L4670;
L4670:
	return asi64(R1);
}

static void mc_writeobj_convertsymboltable() {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 s;
	u64 name;
	i64 i;
	i64 sect;
	i64 scope;
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mc_writeobj_stoffset = asi64(R1);
	R1 = 0;
	mc_writeobj_nstrings = asi64(R1);
	R1 = 4;
	mc_writeobj_nextstringoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4676;
L4674:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = s;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4678;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4679;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4680;
	goto L4681;
L4678:
	R1 = 1;
	sect = asi64(R1);
	goto L4677;
L4679:
	R1 = 2;
	sect = asi64(R1);
	goto L4677;
L4680:
	R1 = 3;
	sect = asi64(R1);
	goto L4677;
L4681:
	R1 = 0;
	sect = asi64(R1);
L4677:
	asu64(R1) = s;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4683;
	R1 = 0;
	sect = asi64(R1);
L4683:
	R1 = 0;
	scope = asi64(R1);
	asu64(R1) = s;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4686;
	asu64(R1) = s;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4685;
L4686:
	R1 = 2;
	scope = asi64(R1);
	goto L4684;
L4685:
	R1 = 3;
	scope = asi64(R1);
L4684:
	asu64(R1) = s;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4688;
	asu64(R1) = name;
	asu64(R1) = pc_api_getbasename(asu64(R1));
	name = asu64(R1);
L4688:
	R1 = 0;
	asi64(R2) = scope;
	R3 = 0;
	asi64(R4) = sect;
	asu64(R5) = s;
	R6 = 76;
	asi32(R5) = *toi32p(((i64)R5+(i64)R6));
	R5 = toi64(toi32(R5));
	asu64(R6) = name;
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4674;
L4676:
	return;
}

static u64 mc_writess_dummy_writessdata(i64 fexe) {
    u64 R1; 
	R1 = 0;
	goto L4689;
L4689:
	return asu64(R1);
}

static u64 mx_run_writememlib(u64 filename) {
    u64 R1, R2, R3; 
	u64 plib;
	i64 n;
	i64 k;
	struct $B85 lib;
	i64 ndlls;
	i64 nlibs;
	i64 i;
	R1 = (u64)&lib;
	memset(R1, 0, 216);
	R1 = 8;
	asi64(R2) = mc_decls_ss_zdatalen;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 144;
	R2 = 8;
	asu64(R3) = mc_decls_ss_code;
	mx_run_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	asu64(R3) = mc_decls_ss_idata;
	mx_run_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("0.1234");
	R2 = (u64)&lib;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&lib;
	R3 = 184;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 192;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&lib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	mx_run_countsymbols();
	R1 = (u64)&lib;
	mx_run_writerelocs(asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&lib;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&lib;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&lib;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = (u64)&lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_idata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = (u64)&lib;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	ndlls = asi64(R1);
	R1 = 0;
	nlibs = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4693;
L4691:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4695;
	R1 = (u64)&ndlls;
	(*toi64p(R1)) += 1;
L4695:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4691;
L4693:
	asi64(R1) = ndlls;
	R2 = (u64)&lib;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = nlibs;
	R2 = (u64)&lib;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = ndlls;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asi64(R2) = nlibs;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4698;
L4696:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4700;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&lib;
	R3 = 96;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4700:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4696;
L4698:
	R1 = (u64)&lib;
	mx_run_addsymbols(asu64(R1));
	R1 = 216;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	plib = asu64(R1);
	R1 = 216;
	R2 = (u64)&lib;
	asu64(R3) = plib;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = plib;
	goto L4690;
L4690:
	return asu64(R1);
}

static void mx_run_roundsegment(u64 p, i64 align, i64 value) {
    u64 R1, R2, R3; 
	i64 length;
	i64 newlength;
	i64 av_1;
	asu64(R1) = p;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	length = asi64(R1);
	asi64(R1) = align;
	asi64(R2) = length;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newlength = asi64(R1);
	asi64(R1) = align;
	asu64(R2) = p;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = newlength;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4704;
L4702:
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L4702;
L4704:
	return;
}

static void mx_run_writerelocs(u64 lib) {
    u64 R1, R2, R3; 
	u64 oldr;
	u64 newr;
	i64 n;
	i64 k;
	u64 d;
	u64 baseptr64;
	i64 i;
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asi64(R2) = mc_decls_ss_ncoderelocs;
	asi64(R1) += asi64(R2);
	asu64(R2) = lib;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4706:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4710;
	asu64(R1) = mc_decls_ss_idatarelocs;
	goto L4709;
L4710:
	asu64(R1) = mc_decls_ss_coderelocs;
L4709:
	oldr = asu64(R1);
	goto L4714;
L4711:
	R1 = (u64)&newr;
	memset(R1, 0, 8);
	asu64(R1) = oldr;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4716;
	R1 = 2;
	goto L4715;
L4716:
	R1 = 1;
L4715:
	R2 = (u64)&newr;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = oldr;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4718;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4719;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4719;
	goto L4720;
L4718:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4722;
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4721;
L4722:
	R1 = tou64("rel32/rel not imported");
	mc_libmcl_axerror(asu64(R1));
L4721:
	goto L4717;
L4719:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4724;
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4726;
	R1 = 3;
	goto L4725;
L4726:
	R1 = 4;
L4725:
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L4723;
L4724:
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4728;
	R1 = 1;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4727;
L4728:
	R1 = 2;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4727:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4723:
	goto L4717;
L4720:
	R1 = tou64("reloc?");
	mc_libmcl_axerror(asu64(R1));
L4717:
	asu64(R1) = newr;
	asu64(R2) = lib;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = oldr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	oldr = asu64(R1);
L4714:
	asu64(R1) = oldr;
	if (asu64(R1)) goto L4711;
	i += 1; if (i <= 2) goto L4706;
	return;
}

static void mx_run_addsymbols(u64 lib) {
    u64 R1, R2, R3; 
	u64 d;
	u64 stentry;
	u64 epoffset;
	i64 n;
	i64 k;
	u64 name;
	i64 i;
	R1 = 0;
	stentry = asu64(R1);
	R1 = -1;
	epoffset = asu64(R1);
	asi64(R1) = mx_decls_nsymimports;
	asu64(R2) = lib;
	R3 = 56;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mx_decls_nsymexports;
	asu64(R2) = lib;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mx_decls_nsymimports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 120;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4732;
L4730:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4734;
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 112;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4734:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4730;
L4732:
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4737;
L4735:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4739;
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4741;
	asu64(R1) = d;
	stentry = asu64(R1);
L4741:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 120;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 128;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = k;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4739:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4735;
L4737:
	asu64(R1) = stentry;
	if (!asu64(R1)) goto L4743;
	asu64(R1) = stentry;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4742;
L4743:
	msysc_m$print_startcon();
	R1 = tou64("NO MAIN FOUND");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = -1;
	asu64(R2) = lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4742:
	return;
}

static void mx_run_countsymbols() {
    u64 R1, R2, R3; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4747;
L4745:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4749;
	R1 = (u64)&mx_decls_nsymexports;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 118;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4749:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4751;
	R1 = (u64)&mx_decls_nsymimports;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4751:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4745;
L4747:
	return;
}

static void mx_run_runlibfile(u64 filename, i64 cmdskip) {
    u64 R1, R2; 
	u64 plib;
	asu64(R1) = filename;
	asu64(R1) = mx_run_writememlib(asu64(R1));
	plib = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadmemmcu(asu64(R1));
	asu64(R1) = plib;
	mx_lib_fixuplib(asu64(R1));
	asi64(R1) = cmdskip;
	asu64(R2) = plib;
	mx_lib_runprogram(asu64(R2), asi64(R1));
	return;
}

static u64 mx_lib_readlibfile(u64 filespec, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 plib;
	struct $B85 lib;
	u64 sig;
	i64 dir;
	i64 n;
	i64 tablesize;
	u64 q;
	i64 i;
	R1 = (u64)&lib;
	memset(R1, 0, 216);
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	sig = asu64(R1);
	asu64(R1) = sig;
	R2 = 441992013;
	if (asu64(R1) == asu64(R2)) goto L4755;
	msysc_m$print_startcon();
	R1 = tou64("Bad sig - not MCX file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L4755:
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 184;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 192;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4756:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readbyte(asu64(R1));
	R2 = R1;
	dir = asi64(R2);
	switch (asi64(R1)) {
	case 0: goto L4791;
	case 1: goto L4760;
	case 2: goto L4763;
	case 3: goto L4762;
	case 4: goto L4761;
	case 5: goto L4788;
	case 6: goto L4764;
	case 7: goto L4768;
	case 8: goto L4772;
	case 9: goto L4776;
	case 10: goto L4780;
	case 11: goto L4784;
	case 12: goto L4789;
	case 13: goto L4790;
	default: goto L4759;
    };
// SWITCH
L4760:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4756;
L4761:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4756;
L4762:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = (u64)&lib;
	R4 = 80;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4756;
L4763:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4756;
L4764:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4767;
L4765:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4765;
L4767:
	goto L4756;
L4768:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4771;
L4769:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4769;
L4771:
	goto L4756;
L4772:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 56;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4775;
L4773:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 112;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4773;
L4775:
	goto L4756;
L4776:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 120;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4779;
L4777:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 120;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4777;
L4779:
	goto L4756;
L4780:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4783;
L4781:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readbyte(asu64(R1));
	R2 = (u64)&lib;
	R3 = 128;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L4781;
L4783:
	goto L4756;
L4784:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	n = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4787;
L4785:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4785;
L4787:
	goto L4756;
L4788:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = (u64)&lib;
	R4 = 88;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4756;
L4789:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4756;
L4790:
	goto L4757;
	goto L4756;
L4791:
	goto L4756;
L4759:
	msysc_m$print_startcon();
	R1 = tou64("Unknown directive:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mx_decls_mcxdirnames;
	asi64(R2) = dir;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
	goto L4756;
L4757:
	R1 = 216;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	plib = asu64(R1);
	R1 = 216;
	R2 = (u64)&lib;
	asu64(R3) = plib;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = plib;
	goto L4753;
L4753:
	return asu64(R1);
}

static i64 mx_lib_readbyte(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L4792;
L4792:
	return asi64(R1);
}

static u64 mx_lib_readu32(u64 p) {
    u64 R1, R2; 
	u64 x;
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu32(R1) = *tou32p(R1);
	R1 = tou64(tou32(R1));
	x = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = x;
	goto L4793;
L4793:
	return asu64(R1);
}

static u64 mx_lib_readstring(u64 p) {
    u64 R1; 
	u64 s;
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	s = asu64(R1);
	goto L4796;
L4795:
L4796:
	asu64(R1) = p;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L4795;
	asu64(R1) = p;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	goto L4794;
L4794:
	return asu64(R1);
}

static void mx_lib_alloclibdata(u64 lib) {
    u64 R1, R2, R3, R4; 
	i64 tablesize;
	i64 n;
	u64 p;
	asu64(R1) = lib;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = lib;
	R3 = 152;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	tablesize = asi64(R1);
	asu64(R1) = lib;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = tablesize;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlinux_os_allocexecmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4800;
	R1 = tou64("");
	R2 = tou64("Can't alloc code memory");
	mx_lib_error(asu64(R2), asu64(R1));
L4800:
	asi64(R1) = n;
	asu64(R2) = lib;
	R3 = 72;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = tablesize;
	R2 = 0;
	asu64(R3) = p;
	asi64(R4) = n;
	R3 += (i64)R4;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = tablesize;
	asu64(R2) = lib;
	R3 = 160;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asu64(R2) = lib;
	R3 = 64;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 168;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = lib;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 176;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 144;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4294967295;
	if (asi64(R1) == asi64(R2)) goto L4802;
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 144;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = lib;
	R3 = 200;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4802:
	return;
}

static void mx_lib_error(u64 mess, u64 param) {
    u64 R1; 
	asu64(R1) = param;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L4805;
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L4804;
L4805:
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4804:
	msysc_m$print_startcon();
	R1 = tou64("Aborting");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mx_lib_loadmemmcu(u64 lib) {
    u64 R1, R2, R3; 
	i64 newlib;
	u64 name;
	asu64(R1) = lib;
	R2 = 192;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = lib;
	R2 = 184;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asu64(R1) = lib;
	R2 = (u64)&mx_decls_libtable;
	asi64(R3) = newlib;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lib;
	mx_lib_loadimports(asu64(R1));
	return;
}

static void mx_lib_checknew(u64 name, u64 filename) {
    u64 R1, R2; 
	asu64(R1) = name;
	asi64(R1) = mx_lib_findlib(asu64(R1));
	if (!asi64(R1)) goto L4809;
	asu64(R1) = filename;
	R2 = tou64("Lib already exists:");
	mx_lib_error(asu64(R2), asu64(R1));
L4809:
	return;
}

static i64 mx_lib_findlib(u64 name) {
    u64 R1, R2; 
	i64 n;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4813;
L4811:
	R1 = (u64)&mx_decls_libnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4815;
	asi64(R1) = i;
	goto L4810;
L4815:
	i += 1; if (i <= mx_decls_nlibs) goto L4811;
L4813:
	R1 = 0;
	goto L4810;
L4810:
	return asi64(R1);
}

static i64 mx_lib_mxaddlib(u64 name) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mx_decls_nlibs;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4818;
	R1 = tou64("");
	R2 = tou64("Too many libs");
	mx_lib_error(asu64(R2), asu64(R1));
L4818:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_libnametable;
	R3 = (u64)&mx_decls_nlibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mx_decls_nlibs;
	goto L4816;
L4816:
	return asi64(R1);
}

static void mx_lib_fixuplib(u64 lib) {
	mx_lib_loaddlls();
	mx_lib_checksymbols();
	mx_lib_dorelocations();
	return;
}

static void mx_lib_loaddlls() {
    u64 R1, R2, R3; 
	u64 inst;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4823;
L4821:
	R1 = (u64)&mx_decls_dllinsttable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L4825;
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mlinux_os_getdllinst(asu64(R1));
	inst = asu64(R1);
	asu64(R1) = inst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4827;
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't find DLL: #");
	mx_lib_error(asu64(R2), asu64(R1));
L4827:
	asu64(R1) = inst;
	R2 = (u64)&mx_decls_dllinsttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4825:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4821;
L4823:
	return;
}

static u64 mx_lib_finddllsymbol(u64 name, u64 dllindex) {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	R1 = 0;
	asu64(R2) = dllindex;
	*toi64p(R2) = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4831;
L4829:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_dllinsttable;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlinux_os_getdllprocaddr(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L4833;
	asi64(R1) = i;
	asu64(R2) = dllindex;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	goto L4828;
L4833:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4829;
L4831:
	R1 = 0;
	goto L4828;
L4828:
	return asu64(R1);
}

static void mx_lib_checksymbols() {
    u64 R1, R2, R3; 
	i64 dllindex;
	i64 undef;
	u64 p;
	i64 i;
	R1 = 0;
	undef = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4837;
L4835:
	R1 = (u64)&mx_decls_symboldefined;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4839;
	R1 = (u64)&dllindex;
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mx_lib_finddllsymbol(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L4841;
	asu64(R1) = p;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = dllindex;
	R2 = (u64)&mx_decls_symboldllindex;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mx_decls_symboldefined;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L4840;
L4841:
	msysc_m$print_startcon();
	R1 = tou64("Undef");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mx_decls_symbolnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&undef;
	(*toi64p(R1)) += 1;
L4840:
L4839:
	i += 1; if (i <= mx_decls_nsymbols) goto L4835;
L4837:
	asi64(R1) = undef;
	if (!asi64(R1)) goto L4843;
L4843:
	return;
}

static void mx_lib_dorelocations() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4847;
L4845:
	R1 = (u64)&mx_decls_librelocated;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4849;
	R1 = (u64)&mx_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_reloclib(asu64(R1));
L4849:
	i += 1; if (i <= mx_decls_nlibs) goto L4845;
L4847:
	return;
}

static void mx_lib_reloclib(u64 lib) {
    u64 R1, R2, R3, R4; 
	i64 index;
	i64 targetoffset;
	u64 name;
	u64 p;
	u64 q;
	u64 qaddr;
	u64 r;
	i64 av_1;
	i64 av_2;
	i64 i;
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = lib;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	qaddr = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4853;
L4851:
	asu64(R1) = lib;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 72;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 36;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = qaddr;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	R1 = 4;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&qaddr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*tou64p(R2) = asu64(R1);
	i += 1; if (i <= av_1) goto L4851;
L4853:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4856;
L4854:
	asu64(R1) = lib;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	r = asu64(R1);
	R1 = (u64)&r;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4858;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4859;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4860;
	goto L4861;
L4858:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4857;
L4859:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4857;
L4860:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4857;
L4861:
L4857:
	R1 = (u64)&r;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4863;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4864;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4865;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4866;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4867;
	goto L4868;
L4863:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	targetoffset = asi64(R1);
	R1 = (u64)&r;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4870;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4871;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4872;
	goto L4873;
L4870:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4869;
L4871:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4869;
L4872:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4869;
L4873:
L4869:
	goto L4862;
L4864:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	targetoffset = asi64(R1);
	R1 = (u64)&r;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4875;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4876;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4877;
	goto L4878;
L4875:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4874;
L4876:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4874;
L4877:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4874;
L4878:
L4874:
	goto L4862;
L4865:
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 4;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
	goto L4862;
L4866:
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 4;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	*tou32p(R2) += asu32(R1);
	goto L4862;
L4867:
	R1 = (u64)&r;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4880;
	R1 = tou64("");
	R2 = tou64("imprel32?");
	mx_lib_error(asu64(R2), asu64(R1));
L4880:
	R1 = (u64)&r;
	R2 = 4;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	index = asi64(R1);
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = index;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4862;
L4868:
L4862:
	i += 1; if (i <= av_2) goto L4854;
L4856:
	R1 = 1;
	R2 = (u64)&mx_decls_librelocated;
	asu64(R3) = lib;
	R4 = 208;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mx_lib_loadimports(u64 plib) {
    u64 R1, R2; 
	u64 qlib;
	u64 name;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = plib;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4884;
L4882:
	asu64(R1) = plib;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_dosublib(asu64(R1));
	i += 1; if (i <= av_1) goto L4882;
L4884:
	asu64(R1) = plib;
	mx_lib_alloclibdata(asu64(R1));
	asu64(R1) = plib;
	mx_lib_dosymbols(asu64(R1));
	return;
}

static void mx_lib_dosublib(u64 name) {
    u64 R1, R2, R3; 
	u64 qlib;
	i64 n;
	asu64(R1) = name;
	asi64(R1) = mx_lib_findlib(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (asi64(R1)) goto L4887;
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	n = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Loading sublib");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = n;
	R2 = tou64("ml");
	asu64(R3) = name;
	asu64(R2) = mlib_addext(asu64(R3), asu64(R2));
	asu64(R1) = mx_lib_loadlibfile(asu64(R2), asi64(R1));
	qlib = asu64(R1);
	asu64(R1) = qlib;
	mx_lib_loadimports(asu64(R1));
L4887:
	return;
}

static u64 mx_lib_loadlibfile(u64 filename, i64 libno) {
    u64 R1, R2, R3, R4; 
	u64 plib;
	u64 p;
	asu64(R1) = filename;
	asu64(R1) = mx_lib_readmxfile(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4890;
	asu64(R1) = filename;
	R2 = tou64("Can't find #");
	mx_lib_error(asu64(R2), asu64(R1));
L4890:
	asu64(R1) = p;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_readlibfile(asu64(R2), asu64(R1));
	plib = asu64(R1);
	asi64(R1) = libno;
	asu64(R2) = plib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = plib;
	R2 = R1;
	R3 = (u64)&mx_decls_libtable;
	asi64(R4) = libno;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	goto L4888;
L4888:
	return asu64(R1);
}

static void mx_lib_dosymbols(u64 lib) {
    u64 R1, R2, R3; 
	i64 ix;
	i64 libx;
	i64 dllx;
	u64 baseaddr;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4894;
L4892:
	asu64(R1) = lib;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_adddll(asu64(R1));
	i += 1; if (i <= av_1) goto L4892;
L4894:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4897;
L4895:
	asu64(R1) = lib;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mx_lib_addsymbol(asu64(R1));
	ix = asi64(R1);
	asi64(R1) = ix;
	asu64(R2) = lib;
	R3 = 176;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
	i += 1; if (i <= av_2) goto L4895;
L4897:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 64;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4900;
L4898:
	asu64(R1) = lib;
	R2 = 120;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mx_lib_addsymbol(asu64(R1));
	ix = asi64(R1);
	R1 = (u64)&mx_decls_symboldefined;
	asi64(R2) = ix;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4902;
	msysc_m$print_startcon();
	R1 = tou64("Dupl symbol:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = lib;
	R2 = 120;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L4899;
L4902:
	R1 = 1;
	R2 = (u64)&mx_decls_symboldefined;
	asi64(R3) = ix;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = lib;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4904;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4905;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4906;
	goto L4907;
L4904:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4903;
L4905:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4903;
L4906:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4903;
L4907:
	R1 = 0;
	baseaddr = asu64(R1);
L4903:
	asu64(R1) = baseaddr;
	asu64(R2) = lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = ix;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mx_decls_symbollibindex;
	asi64(R3) = ix;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
L4899:
	i += 1; if (i <= av_3) goto L4898;
L4900:
	return;
}

static u64 mx_lib_readmxfile(u64 filename) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = filename;
	asu64(R1) = mlib_readfile(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4910;
	R1 = 0;
	goto L4908;
L4910:
	R1 = 13;
	asu64(R2) = p;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L4908;
L4908:
	return asu64(R1);
}

static void mx_lib_adddll(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4914;
L4912:
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4916;
	goto L4911;
L4916:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4912;
L4914:
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4918;
	R1 = tou64("");
	R2 = tou64("Too many DLLs");
	mx_lib_error(asu64(R2), asu64(R1));
L4918:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_dllnametable;
	R3 = (u64)&mx_decls_ndlllibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4911:
	return;
}

static i64 mx_lib_addsymbol(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4922;
L4920:
	R1 = (u64)&mx_decls_symbolnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4924;
	asi64(R1) = i;
	goto L4919;
L4924:
	i += 1; if (i <= mx_decls_nsymbols) goto L4920;
L4922:
	asi64(R1) = mx_decls_nsymbols;
	R2 = 3000;
	if (asi64(R1) < asi64(R2)) goto L4926;
	R1 = tou64("");
	R2 = tou64("Too many Imports");
	mx_lib_error(asu64(R2), asu64(R1));
L4926:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_symbolnametable;
	R3 = (u64)&mx_decls_nsymbols;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mx_decls_nsymbols;
	goto L4919;
L4919:
	return asi64(R1);
}

static void mx_lib_setspecialglobals(i64 cmdskip) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4930;
L4928:
	R1 = tou64("msys.$cmdskip");
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L4933;
	R1 = tou64("$cmdskip");
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4932;
L4933:
	asi64(R1) = cmdskip;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	*tou8p(R2) = asu8(R1);
L4932:
	i += 1; if (i <= mx_decls_nsymbols) goto L4928;
L4930:
	return;
}

static void mx_lib_runprogram(u64 lib, i64 cmdskip) {
    u64 R1, R2, R3; 
	u64 fnptr;
	i64 libno;
	i64 i;
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	libno = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4937;
L4935:
	asi64(R1) = i;
	asi64(R2) = libno;
	if (asi64(R1) == asi64(R2)) goto L4939;
	R1 = (u64)&mx_decls_libinitdone;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4939;
	R1 = (u64)&mx_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_calllibinit(asu64(R1));
L4939:
	i += 1; if (i <= mx_decls_nlibs) goto L4935;
L4937:
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4941;
	R1 = tou64("");
	R2 = tou64("No entry point found");
	mx_lib_error(asu64(R2), asu64(R1));
L4941:
	asi64(R1) = cmdskip;
	mx_lib_setspecialglobals(asi64(R1));
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = fnptr;
	((F20)R1)();
	R1 = 1;
	R2 = (u64)&mx_decls_libinitdone;
	asi64(R3) = libno;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mx_lib_calllibinit(u64 lib) {
    u64 R1, R2, R3, R4; 
	u64 fnptr;
	i64 libno;
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	libno = asi64(R1);
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4944;
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = fnptr;
	((F20)R1)();
L4944:
	R1 = 1;
	R2 = (u64)&mx_decls_libinitdone;
	asu64(R3) = lib;
	R4 = 208;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static u64 mx_lib_findsymbol(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4948;
L4946:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4950;
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L4945;
L4950:
	i += 1; if (i <= mx_decls_nsymbols) goto L4946;
L4948:
	R1 = 0;
	goto L4945;
L4945:
	return asu64(R1);
}

static u64 mx_lib_loadmx(u64 filename) {
    u64 R1, R2; 
	u64 plib;
	i64 newlib;
	u64 name;
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = filename;
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asi64(R1) = newlib;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_loadlibfile(asu64(R2), asi64(R1));
	plib = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadimports(asu64(R1));
	asu64(R1) = plib;
	goto L4951;
L4951:
	return asu64(R1);
}

static u64 mx_lib_loadmemmcb(u64 filename, u64 p) {
    u64 R1, R2, R3; 
	u64 plib;
	i64 newlib;
	u64 name;
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = filename;
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_readlibfile(asu64(R2), asu64(R1));
	plib = asu64(R1);
	asi64(R1) = newlib;
	asu64(R2) = plib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = plib;
	R2 = (u64)&mx_decls_libtable;
	asi64(R3) = newlib;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadimports(asu64(R1));
	asu64(R1) = plib;
	goto L4952;
L4952:
	return asu64(R1);
}

static void mx_write_writemcx(u64 filename) {
    u64 R1, R2, R3; 
	i64 n;
	i64 ndlls;
	i64 nlibs;
	i64 i;
	R1 = 8;
	asi64(R2) = mc_decls_ss_zdatalen;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 144;
	R2 = 8;
	asu64(R3) = mc_decls_ss_code;
	mx_write_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	asu64(R3) = mc_decls_ss_idata;
	mx_write_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mx_write_dest = asu64(R1);
	R1 = 441992013;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	mx_write_genbyte(asi64(R1));
	R1 = tou64("0.1234");
	mx_write_genstring(asu64(R1));
	mx_run_countsymbols();
	mx_write_writerelocs();
	R1 = 4;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	mx_write_genu32(asi64(R1));
	R1 = 2;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = mc_decls_ss_code;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mx_write_genblock(asu64(R2), asi64(R1));
	R1 = 3;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = mc_decls_ss_idata;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mx_write_genblock(asu64(R2), asi64(R1));
	R1 = 0;
	ndlls = asi64(R1);
	R1 = 0;
	nlibs = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4956;
L4954:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4958;
	R1 = (u64)&ndlls;
	(*toi64p(R1)) += 1;
L4958:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4954;
L4956:
	R1 = 6;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = ndlls;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4961;
L4959:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4963;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_write_genstring(asu64(R1));
L4963:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4959;
L4961:
	mx_write_writesymbols();
	R1 = 13;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mx_write_dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mx_write_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = mx_write_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mx_write_writerelocs() {
    u64 R1, R2, R3; 
	u64 oldr;
	u64 newr;
	i64 n;
	i64 count;
	u64 d;
	u64 baseptr64;
	i64 i;
	R1 = 5;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asi64(R2) = mc_decls_ss_ncoderelocs;
	asi64(R1) += asi64(R2);
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	R1 = 0;
	count = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4965:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4969;
	asu64(R1) = mc_decls_ss_idatarelocs;
	goto L4968;
L4969:
	asu64(R1) = mc_decls_ss_coderelocs;
L4968:
	oldr = asu64(R1);
	goto L4973;
L4970:
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
	R1 = (u64)&newr;
	memset(R1, 0, 8);
	asu64(R1) = oldr;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4975;
	R1 = 2;
	goto L4974;
L4975:
	R1 = 1;
L4974:
	R2 = (u64)&newr;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = oldr;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4977;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4978;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4978;
	goto L4979;
L4977:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4981;
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4980;
L4981:
	R1 = tou64("rel32/rel not imported");
	mc_libmcl_axerror(asu64(R1));
L4980:
	goto L4976;
L4978:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4983;
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4985;
	R1 = 3;
	goto L4984;
L4985:
	R1 = 4;
L4984:
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L4982;
L4983:
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4987;
	R1 = 1;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4986;
L4987:
	R1 = 2;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4986:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4982:
	goto L4976;
L4979:
	R1 = tou64("reloc?");
	mc_libmcl_axerror(asu64(R1));
L4976:
	R1 = 8;
	R2 = (u64)&newr;
	mx_write_genblock(asu64(R2), asi64(R1));
	asu64(R1) = oldr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	oldr = asu64(R1);
L4973:
	asu64(R1) = oldr;
	if (asu64(R1)) goto L4970;
	i += 1; if (i <= 2) goto L4965;
	return;
}

static void mx_write_writesymbols() {
    u64 R1, R2; 
	u64 d;
	i64 n;
	u64 name;
	i64 i;
	R1 = 8;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymimports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4991;
L4989:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4993;
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mx_write_genstring(asu64(R1));
L4993:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4989;
L4991:
	R1 = 9;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4996;
L4994:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4998;
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5000;
	asu64(R1) = d;
	mx_write_entrypoint = asu64(R1);
L5000:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mx_write_genstring(asu64(R1));
L4998:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4994;
L4996:
	R1 = 10;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5003;
L5001:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5005;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mx_write_genbyte(asi64(R1));
L5005:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5001;
L5003:
	R1 = 11;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5008;
L5006:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L5010;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mx_write_genu32(asi64(R1));
L5010:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L5006;
L5008:
	R1 = 12;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mx_write_entrypoint;
	if (!asu64(R1)) goto L5012;
	asu64(R1) = mx_write_entrypoint;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mx_write_genu32(asi64(R1));
	goto L5011;
L5012:
	R1 = 4294967295;
	mx_write_genu32(asi64(R1));
L5011:
	return;
}

static void mx_write_roundsegment(u64 p, i64 align, i64 value) {
    u64 R1, R2, R3; 
	i64 length;
	i64 newlength;
	i64 av_1;
	asu64(R1) = p;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	length = asi64(R1);
	asi64(R1) = align;
	asi64(R2) = length;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newlength = asi64(R1);
	asi64(R1) = align;
	asu64(R2) = p;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = newlength;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5016;
L5014:
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L5014;
L5016:
	return;
}

static void mx_write_genbyte(i64 x) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = x;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mx_write_genu32(i64 x) {
    u64 R1, R2, R3; 
	R1 = 4;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = x;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 4; asu64(R2) = asu64(R3);
	*tou32p(R2) = asu32(R1);
	return;
}

static void mx_write_genstring(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = s;
	mx_write_genblock(asu64(R2), asi64(R1));
	return;
}

static void mx_write_genblock(u64 p, i64 length) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = length;
	asu64(R2) = p;
	asu64(R3) = mx_write_dest;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	return;
}

void mm_main() {
    u64 R1; 
	pcl_start();
	mm_start();
	mm_cli_main2();
	R1 = 0;
	exit(R1);
	return;
}

static void mm_cli_main2() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	u64 r;
	i64 m;
	i64 fileno;
	i64 ntokens;
	i64 t;
	i64 tt;
	asi64(R1) = mlinux_os_clock();
	mm_cli_startclock = asi64(R1);
	asi64(R1) = mm_cli_startclock;
	pc_decls_pstartclock = asi64(R1);
	mm_cli_initdata();
	mm_cli_getinputoptions();
	asi64(R1) = mm_decls_prodmode;
	if (!asi64(R1)) goto L5024;
	mm_cli_production_compiler();
	goto L5023;
L5024:
	mm_cli_debug_compiler();
L5023:
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5026;
	msysc_m$print_startcon();
	R1 = tou64("Finished.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5026:
	return;
}

static void mm_cli_debug_compiler() {
    u64 R1, R2; 
	asu64(R1) = mm_cli_inputfile;
	mm_modules_loadproject(asu64(R1));
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5029;
	R1 = 4;
	mm_decls_passlevel = asi64(R1);
	goto L5028;
L5029:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5030;
	R1 = 6;
	mm_decls_passlevel = asi64(R1);
L5030:
L5028:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L5032;
	asu8(R1) = mm_decls_fshowast1;
	R1 = toi64(tou8(R1));
	mm_cli_do_parse(asi64(R1));
L5032:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L5034;
	asu8(R1) = mm_decls_fshowast2;
	R1 = toi64(tou8(R1));
	mm_cli_do_name(asi64(R1));
L5034:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L5036;
	asu8(R1) = mm_decls_fshowast3;
	R1 = toi64(tou8(R1));
	mm_cli_do_type(asi64(R1));
L5036:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L5038;
	asu8(R1) = mm_decls_fshowpcl;
	if (asu8(R1)) goto L5039;
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L5040;
L5039:
	R1 = 1;
	goto L5041;
L5040:
	R1 = 0;
L5041:
	mm_cli_do_genpcl(asi64(R1));
L5038:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L5043;
	asu8(R1) = mm_decls_fshowasm;
	if (asu8(R1)) goto L5044;
	R1 = 0;
	if (!asu16(R1)) goto L5045;
L5044:
	R1 = 1;
	goto L5046;
L5045:
	R1 = 0;
L5046:
	mm_cli_do_genmcl(asi64(R1));
L5043:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L5048;
	R1 = 0;
	pc_api_pcl_genss(asi64(R1));
L5048:
	asu8(R1) = mm_decls_fshowtiming;
	if (!asu8(R1)) goto L5050;
	mm_diags_showtimings();
L5050:
	mm_diags_showlogfile();
	return;
}

static void mm_cli_production_compiler() {
    u64 R1, R2; 
	mm_cli_showcompilemess();
	asu64(R1) = mm_cli_inputfile;
	mm_modules_loadproject(asu64(R1));
	R1 = 0;
	mm_cli_do_parse(asi64(R1));
	R1 = 0;
	mm_cli_do_name(asi64(R1));
	R1 = 0;
	mm_cli_do_type(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5053;
	asu64(R1) = mm_cli_inputfile;
	mm_support_do_writema(asu64(R1));
L5053:
	asi64(R1) = mm_decls_passlevel;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5056;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5055;
L5056:
	asu64(R1) = mm_cli_inputfile;
	mm_support_do_getinfo(asu64(R1));
L5055:
	asi64(R1) = mm_decls_passlevel;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5058;
	mm_cli_do_writeexports();
L5058:
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	mm_cli_do_genpcl(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5060;
	pc_run_pcl_runpcl();
L5060:
	asi64(R1) = mm_decls_passlevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L5062;
	asi64(R1) = mm_decls_passlevel;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5063;
	R1 = 0;
	if (!asu16(R1)) goto L5064;
L5063:
	R1 = 1;
	goto L5065;
L5064:
	R1 = 0;
L5065:
	mm_cli_do_genmcl(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5067;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5068;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5069;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5070;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5071;
	goto L5072;
L5067:
	R1 = tou64("obj");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writeobj(asu64(R1));
	goto L5066;
L5068:
	R1 = tou64("exe");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writeexe(asu64(R1));
	goto L5066;
L5069:
	R1 = tou64("dll");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writedll(asu64(R1));
	goto L5066;
L5070:
	R1 = tou64("mx");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writemx(asu64(R1));
	goto L5066;
L5071:
	pc_api_pcl_exec();
	goto L5066;
L5072:
L5066:
L5062:
	asu8(R1) = mm_decls_fshowtiming;
	if (!asu8(R1)) goto L5074;
	mm_diags_showtimings();
L5074:
	return;
}

static void mm_cli_showcompilemess() {
    u64 R1, R2; 
	asi64(R1) = mm_decls_fverbose;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5077;
	asu8(R1) = mm_cli_msfile;
	if (asu8(R1)) goto L5077;
	msysc_m$print_startcon();
	R1 = tou64("Compiling # to #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mm_cli_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_cli_passnames;
	asi64(R2) = mm_decls_passlevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5077:
	return;
}

static void mm_cli_do_parse(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5081;
L5079:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R1) = mm_parse_parsemodule(asu64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L5079;
L5081:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_parsetime = asi64(R1);
	asi64(R1) = mm_decls_prodmode;
	if (asi64(R1)) goto L5084;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 3;
	if (asi64(R1) < asi64(R2)) goto L5083;
L5084:
	mm_name_fixusertypes();
L5083:
	mm_cli_fixstartprocs();
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5086;
	R1 = tou64("AST1");
	mm_diags_showast(asu64(R1));
L5086:
	return;
}

static void mm_cli_do_name(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	mm_name_rx_typetable();
	R1 = 2;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L5090;
L5088:
	asi64(R1) = i;
	asi64(R1) = mm_name_rx_module(asi64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L5088;
L5090:
	R1 = 1;
	asi64(R1) = mm_name_rx_module(asi64(R1));
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_resolvetime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5092;
	R1 = tou64("AST2");
	mm_diags_showast(asu64(R1));
L5092:
	return;
}

static void mm_cli_do_type(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	mm_type_tx_typetable();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5096;
L5094:
	asi64(R1) = i;
	asi64(R1) = mm_type_tx_module(asi64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L5094;
L5096:
	mm_type_tx_allprocs();
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_typetime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5098;
	R1 = tou64("AST3");
	mm_diags_showast(asu64(R1));
L5098:
	return;
}

static void mm_cli_do_genc() {
    u64 R1, R2; 
	i64 tt;
	u64 file;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	R1 = tou64("c");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file = asu64(R1);
	asu64(R1) = file;
	mm_genpcl_codegen_il(asu64(R1));
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_ctime = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("WRITE C FILE:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_lib_dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_lib_dest;
	asu64(R2) = file;
	mm_lib_writegsfile(asu64(R2), asu64(R1));
	return;
}

static void mm_cli_do_genpcl(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	R1 = 0;
	mm_genpcl_codegen_il(asu64(R1));
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L5103;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L5102;
L5103:
	pc_reduce_pcl_reducetest();
L5102:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_pcltime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5105;
	asu8(R1) = mm_decls_fshowpcl;
	if (asu8(R1)) goto L5108;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5107;
L5108:
	R1 = tou64("pcl");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
L5107:
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L5110;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5110;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
L5110:
L5105:
	return;
}

static void mm_cli_do_genmcl(i64 flog) {
    u64 R1, R2, R3; 
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	pc_api_pcl_genmcl();
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L5113;
	R1 = 16705;
	R2 = tou64("asm");
	asu64(R3) = mm_decls_outfile;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L5113:
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L5115;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L5115;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
L5115:
	return;
}

static void mm_cli_initdata() {
    u64 R1, R2, R3; 
	u64 pm;
	u64 pf;
	mlib_pcm_init();
	mm_lex_lexsetup();
	mm_assem_initassemsymbols();
	mm_support_init_tt_tables();
	mm_support_initbblib();
	R1 = 64;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	R1 = tou64("PROGRAM");
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = tou64("$prog");
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	mm_decls_stprogram = asu64(R1);
	asu64(R1) = mm_decls_stprogram;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&mm_support_mgetsourceinfo;
	pc_decls_igetmsourceinfo = asu64(R1);
	R1 = (u64)&mm_assemaux_domcl_assem;
	pc_api_idomcl_assem = asu64(R1);
	R1 = (u64)&mm_genpcl_findhostfn;
	pc_api_igethostfn = asu64(R1);
	R1 = (u64)&mm_assemaux_checkasmlabel;
	pc_api_icheckasmlabel = asu64(R1);
	R1 = tou64("PSYMTAB");
	asi32(R1) = remove(asu64(R1));
	return;
}

static void mm_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 paramno;
	i64 pmtype;
	i64 sw;
	i64 extlen;
	u64 name;
	u64 value;
	u64 ext;
	struct $B15 filespec;
	i64 av_1;
	asu8(R1) = pcl_pc_userunpcl;
	if (!asu8(R1)) goto L5119;
	R1 = 5;
	mm_decls_passlevel = asi64(R1);
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
	R1 = 0;
	mm_decls_fverbose = asi64(R1);
L5119:
	R1 = 1;
	paramno = asi64(R1);
	R1 = tou64("ms.exe");
	asu64(R2) = mlinux_os_gethostname();
	asu64(R2) = mlib_extractfile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5121;
	R1 = 1;
	mm_cli_msfile = asu8(R1);
	R1 = 0;
	mm_decls_fverbose = asi64(R1);
	R1 = 0;
	R2 = tou64("");
	R3 = 13;
	mm_cli_do_option(asi64(R3), asu64(R2), asi64(R1));
L5121:
	goto L5123;
L5122:
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5126;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5127;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5128;
	goto L5129;
L5126:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 55;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5133;
L5130:
	R1 = (u64)&mm_cli_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5135;
	asi64(R1) = paramno;
	asu64(R2) = value;
	asi64(R3) = sw;
	mm_cli_do_option(asi64(R3), asu64(R2), asi64(R1));
	goto L5132;
L5135:
	sw += 1; if (sw <= av_1) goto L5130;
L5133:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 99;
	exit(R1);
L5132:
	goto L5125;
L5127:
	asu64(R1) = mm_cli_inputfile;
	if (!asu64(R1)) goto L5137;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Specify one lead module only");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5137:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_cli_inputfile = asu64(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5140;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5139;
L5140:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	mm_cli_cmdskip = asi64(R1);
	goto L5124;
L5139:
	goto L5125;
L5128:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Lib files go in module headers");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
	goto L5125;
L5129:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Invalid params");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5125:
L5123:
	R1 = tou64("m");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	pmtype = asi64(R2);
	if (asi64(R1)) goto L5122;
L5124:
	asi64(R1) = mm_decls_prodmode;
	asi64(R2) = mm_decls_debugmode;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L5142;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5142;
	R1 = 9;
	mm_decls_passlevel = asi64(R1);
	R1 = tou64("exe");
	mm_cli_outext = asu64(R1);
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
L5142:
	asi64(R1) = mm_decls_passlevel;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5144;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5144;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5145;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5146;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5146;
	goto L5147;
L5144:
	R1 = 2;
	mm_decls_highmem = asu8(R1);
	goto L5143;
L5145:
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L5149;
	R1 = 2;
	mm_decls_highmem = asu8(R1);
L5149:
	goto L5143;
L5146:
	R1 = 0;
	mm_decls_highmem = asu8(R1);
	goto L5143;
L5147:
L5143:
	asu64(R1) = mm_cli_inputfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5151;
	mm_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("   ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(" prog[.m]  Compile prog.m to prog.exe");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("   ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(" -h           Show all options");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
	goto L5150;
L5151:
	asu64(R1) = mm_cli_inputfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
	asu64(R1) = mm_decls_destfilename;
	if (!asu64(R1)) goto L5153;
	asu64(R1) = mm_decls_destfilename;
	mm_decls_outfile = asu64(R1);
L5153:
	asu64(R1) = mm_decls_destfilepath;
	if (!asu64(R1)) goto L5155;
	asu64(R1) = mm_decls_destfilepath;
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mm_decls_outfile;
	R2 = (u64)&filespec;
	asu64(R2) = mlib_extractfile(asu64(R2));
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
L5155:
L5150:
	R1 = 0;
	asu64(R2) = mm_cli_inputfile;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	ext = asu64(R1);
	asu64(R1) = ext;
	asi64(R1) = strlen(asu64(R1));
	extlen = asi64(R1);
	asu64(R1) = ext;
	asu64(R2) = msysc_cmdparams;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mm_cli_inputfile;
	R2 = (u64)&filespec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5157;
	asi64(R1) = mm_decls_passlevel;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L5157;
	R1 = tou64("2.m");
	R2 = (u64)&filespec;
	R3 = (u64)&filespec;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	asi64(R3) = extlen;
	R2 -= (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("New dest=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_decls_outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5157:
	asi64(R1) = mm_decls_fshortnames;
	R2 = -1;
	asu8(R3) = mm_decls_highmem;
	R3 = toi64(tou8(R3));
	pc_api_pcl_setflags(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mm_cli_cmdskip;
	pc_api_pcl_cmdskip(asi64(R2), asu64(R1));
	asu8(R1) = mm_decls_msyslevel;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5159;
	R1 = 1;
	pc_api_pfullsys = asu8(R1);
L5159:
	return;
}

static void mm_cli_do_option(i64 sw, u64 value, i64 paramno) {
    u64 R1, R2, R3; 
	asi64(R1) = sw;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5162;
	R2 = 13;
	if (asi64(R1) > asi64(R2)) goto L5162;
	asi64(R1) = mm_decls_prodmode;
	if (!asi64(R1)) goto L5164;
	R1 = tou64("");
	R2 = (u64)&mm_cli_optionnames;
	asi64(R3) = sw;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = tou64("dupl prod option:");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5164:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_decls_passlevel = asi64(R1);
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
	R1 = (u64)&mm_cli_passnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_cli_outext = asu64(R1);
	asi64(R1) = sw;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5166;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5167;
	goto L5168;
L5166:
	asi64(R1) = pc_decls_assemtype;
	R2 = 16705;
	if (asi64(R1) != asi64(R2)) goto L5171;
	asi64(R1) = sw;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5170;
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) == asi64(R2)) goto L5170;
L5171:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Wrong WRITEASM");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5170:
	goto L5165;
L5167:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	mm_cli_cmdskip = asi64(R1);
	goto L5165;
L5168:
L5165:
	goto L5160;
	goto L5161;
L5162:
	asi64(R1) = sw;
	R2 = 14;
	if (asi64(R1) < asi64(R2)) goto L5172;
	R2 = 21;
	if (asi64(R1) > asi64(R2)) goto L5172;
	asi64(R1) = mm_decls_debugmode;
	if (!asi64(R1)) goto L5174;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("dupl debug option");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5174:
	asi64(R1) = sw;
	R2 = 14;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	mm_decls_dpasslevel = asi64(R1);
	R1 = 1;
	mm_decls_debugmode = asi64(R1);
	goto L5160;
L5172:
L5161:
	asi64(R1) = sw;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L5176;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L5177;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L5178;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L5179;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L5180;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5181;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L5182;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L5183;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5184;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L5185;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L5186;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5187;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5188;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L5189;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L5189;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L5189;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L5190;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5191;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5192;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5193;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5194;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L5194;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L5194;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5195;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5195;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L5196;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5196;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L5197;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5198;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5199;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5200;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L5201;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L5202;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5202;
	goto L5203;
L5176:
	R1 = 1;
	mm_decls_fshowast1 = asu8(R1);
	goto L5175;
L5177:
	R1 = 1;
	mm_decls_fshowast2 = asu8(R1);
	goto L5175;
L5178:
	R1 = 1;
	mm_decls_fshowast3 = asu8(R1);
	goto L5175;
L5179:
	R1 = 1;
	mm_decls_fshowpcl = asu8(R1);
	goto L5175;
L5180:
	R1 = 1;
	mm_decls_fshowc = asu8(R1);
	goto L5175;
L5181:
	R1 = 1;
	mm_decls_fshowasm = asu8(R1);
	goto L5175;
L5182:
	R1 = 1;
	mm_decls_fshowst = asu8(R1);
	goto L5175;
L5183:
	R1 = 1;
	mm_decls_fshowstflat = asu8(R1);
	goto L5175;
L5184:
	R1 = 1;
	mm_decls_fshowpst = asu8(R1);
	goto L5175;
L5185:
	R1 = 1;
	mm_decls_fshowtypes = asu8(R1);
	goto L5175;
L5186:
	R1 = 1;
	mm_decls_fshowss = asu8(R1);
	goto L5175;
L5187:
	R1 = 1;
	mm_decls_fshowmodules = asu8(R1);
	goto L5175;
L5188:
	R1 = 1;
	mm_decls_clinux = asu8(R1);
	goto L5175;
L5189:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	mm_decls_msyslevel = asu8(R1);
	goto L5175;
L5190:
	R1 = 0;
	R2 = R1;
	pc_decls_fregoptim = asu8(R2);
	pc_decls_fpeephole = asu8(R1);
	goto L5175;
L5191:
	R1 = 0;
	pc_decls_fpeephole = asu8(R1);
	goto L5175;
L5192:
	R1 = 0;
	pc_decls_fregoptim = asu8(R1);
	goto L5175;
L5193:
	R1 = 1;
	mm_decls_fshowtiming = asu8(R1);
	goto L5175;
L5194:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_decls_fverbose = asi64(R1);
	goto L5175;
L5195:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	pc_decls_pverbose = asu8(R1);
	goto L5175;
L5196:
	mm_cli_showhelp();
	R1 = 0;
	exit(R1);
	goto L5175;
L5197:
	R1 = 0;
	mm_decls_dointlibs = asu8(R1);
	goto L5175;
L5198:
	asu8(R1) = mm_cli_do_option_outpathused;
	if (!asu8(R1)) goto L5205;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("mixed out/path");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5205:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_destfilename = asu64(R1);
	R1 = 1;
	mm_cli_do_option_outused = asu8(R1);
	goto L5175;
L5199:
	asu8(R1) = mm_cli_do_option_outused;
	if (!asu8(R1)) goto L5207;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("mixed out/path");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5207:
	asu64(R1) = value;
	asu64(R2) = value;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5209;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5209;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Path needs to end with \\ or /");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5209:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_destfilepath = asu64(R1);
	R1 = 1;
	mm_cli_do_option_outpathused = asu8(R1);
	goto L5175;
L5200:
	R1 = 1;
	mm_decls_fcheckunusedlocals = asu8(R1);
	goto L5175;
L5201:
	R1 = 1;
	mm_decls_fshortnames = asi64(R1);
	goto L5175;
L5202:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	mm_decls_highmem = asu8(R1);
	goto L5175;
L5203:
L5175:
L5160:
	return;
}

static void mm_cli_showcaption() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("M Compiler [M7.1]");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("16-Jul-2025");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10:52:29");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_cli_showhelp() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("M Compiler for 64-bit Windows\n\nNormal use:           Compiles lead module prog.m to:\n\n    mm      prog      prog.exe (default)\n    mm -r   prog      in-memory native code then execute\n    mm -i   prog      in-memory IL then interpret\n\n    mm -exe prog      prog.exe\n    mm -dll prog      prog.dll\n    mm -obj prog      prog.obj\n    mm -a   prog      prog.asm\n    mm -n   prog      prog.nasm\n    mm -mx  prog      prog.mx\n    mm -p   prog      prog.pcl (textual IL)\n    mm -ma   prog     prog.ma (single amalgamated source file)\n\nOther options:\n\n    -ext              Used std headers external to compiler\n    -opt              Optimise native code\n    -out:file         Name output file (extension can be added)\n    -rip              Use RIP address modes\n    -himem            Generate PIC code (automatic with -obj/-dll)\n    @file             Read files and options from a file\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_cli_do_writeexports() {
    u64 R1, R2; 
	struct $B15 str;
	asu64(R1) = mm_decls_outfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("dll");
	R2 = (u64)&str;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R2) = mm_decls_outfile;
	mm_export_dummy_writeexports(asu64(R2), asu64(R1));
	return;
}

static u64 mm_cli_getoutfilename(u64 file, u64 ext) {
    u64 R1, R2; 
	asu64(R1) = ext;
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L5213;
L5213:
	return asu64(R1);
}

static void mm_cli_fixstartprocs() {
    u64 R1, R2, R3, R4, R5; 
	u64 ms;
	u64 ps;
	u64 d;
	u64 p;
	u64 q;
	i64 s;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5217;
L5215:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = ps;
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5219;
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = ps;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L5219:
	i += 1; if (i <= mm_decls_nsubprogs) goto L5215;
L5217:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5222;
L5220:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	asu64(R1) = ms;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5224;
	R1 = 1;
	R2 = (u64)&mm_decls_subproghasstart;
	asu64(R3) = ms;
	R4 = 18;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5224:
	i += 1; if (i <= mm_decls_nmodules) goto L5220;
L5222:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5227;
L5225:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	asu64(R1) = ms;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5229;
	asu64(R1) = ms;
	R2 = 18;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&mm_decls_subproghasstart;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5231;
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = s;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L5231;
	asi64(R1) = i;
	R2 = 2;
	R3 = tou64("start");
	asu64(R4) = ms;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mm_cli_addstartproc(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ms;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5231:
L5229:
	i += 1; if (i <= mm_decls_nmodules) goto L5225;
L5227:
	return;
}

static u64 mm_cli_addstartproc(u64 owner, u64 name, i64 scope, i64 moduleno) {
    u64 R1, R2, R3; 
	u64 stproc;
	R1 = 6;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = moduleno;
	asu64(R2) = stproc;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = moduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stproc;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = stproc;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stproc;
	mm_lib_addtoproclist(asu64(R1));
	asu64(R1) = stproc;
	goto L5232;
L5232:
	return asu64(R1);
}

static void mm_genpcl_codegen_il(u64 dummy) {
    u64 R1, R2; 
	u64 d;
	u64 pp;
	i64 i;
	asi64(R1) = mm_decls_nunits;
	R2 = 0;
	asu64(R1) = pc_api_pcl_start(asu64(R2), asi64(R1));
	mm_genpcl_dolibs();
	asu64(R1) = mm_decls_staticlist;
	pp = asu64(R1);
	goto L5235;
L5234:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_dostaticvar(asu64(R1));
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L5235:
	asu64(R1) = pp;
	if (asu64(R1)) goto L5234;
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ndllproctable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5239;
L5237:
	R1 = (u64)&mm_decls_dllproctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_genpcl_gendllproc(asu64(R1));
	i += 1; if (i <= mm_decls_ndllproctable) goto L5237;
L5239:
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L5241;
L5240:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = R1;
	mm_decls_currproc = asu64(R2);
	mm_genpcl_genprocdef(asu64(R1));
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L5241:
	asu64(R1) = pp;
	if (asu64(R1)) goto L5240;
	mm_genpcl_scanprocs();
	pc_api_pcl_end();
	return;
}

static void mm_genpcl_genprocdef(u64 p) {
    u64 R1, R2, R3; 
	u64 ms;
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = p;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	R1 = 0;
	mm_genpcl_pcldoswx = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ms;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L5245;
	R1 = (u64)&mm_decls_moduletosub;
	asu64(R2) = p;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L5245;
	asu64(R1) = p;
	mm_genpcl_genmaindef(asu64(R1));
	goto L5243;
	goto L5244;
L5245:
	asu64(R1) = p;
	asu64(R2) = ms;
	R3 = 48;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L5246;
	asu64(R1) = p;
	mm_genpcl_genstartdef(asu64(R1));
	goto L5243;
L5246:
L5244:
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5248;
	R1 = 0;
	R2 = 126;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	mm_genpcl_pcldoswx = asu64(R1);
	R1 = 0;
	R2 = 0;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5248:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
L5243:
	return;
}

static void mm_genpcl_gendllproc(u64 p) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = p;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_setimport(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5253;
L5250:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5253:
	asu64(R1) = e;
	if (asu64(R1)) goto L5250;
	R1 = 0;
	pc_api_pc_setimport(asu64(R1));
	return;
}

static void mm_genpcl_dolibs() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5257;
L5255:
	R1 = (u64)&mm_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L5259;
	R1 = (u64)&mm_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pc_api_pc_addplib(asu64(R1));
L5259:
	i += 1; if (i <= mm_decls_nlibfiles) goto L5255;
L5257:
	return;
}

static void mm_genpcl_dostaticvar(u64 d) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5262;
	goto L5260;
L5262:
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5264;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) != asu64(R2)) goto L5264;
	R1 = tou64("$cmdskip");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5266;
	R1 = 3;
	asu64(R2) = d;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5266:
L5264:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5268;
	goto L5260;
	goto L5267;
L5268:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5269;
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	pc_api_pc_setalign(asi64(R1));
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5267;
L5269:
// mm_genpcl.dostaticvar.dozstatic:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 124;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	pc_api_pc_setalign(asi64(R1));
L5267:
L5260:
	return;
}

static void mm_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset) {
    u64 R1, R2, R3, R4, R5; 
	struct $B45 data;
	i64 t;
	i64 tbase;
	u8 allbytes;
	u8 nbytes;
	u64 q;
	u64 a;
	u64 d;
	u64 s;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5273;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5274;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5275;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L5276;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L5277;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5278;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5278;
	goto L5279;
L5273:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5281;
	asi64(R1) = t;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L5283;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5285;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L5287;
	R1 = 0;
	R2 = tou64("1:B-str?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5287:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5284;
L5285:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5284:
	goto L5282;
L5283:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5282:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5280;
L5281:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5288;
	asi64(R1) = t;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genrealimm(asr64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
	goto L5280;
L5288:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5289;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5291;
	R1 = 0;
	R2 = tou64("IDATA/ARRAY/NOT BLOCKDATA");
	mm_support_gerror(asu64(R2), asu64(R1));
L5291:
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_gendata(asu64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5280;
L5289:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5280:
	goto L5272;
L5274:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	allbytes = asu8(R1);
	R1 = 0;
	nbytes = asu8(R1);
	goto L5295;
L5292:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5297;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5297;
	asu8(R1) = nbytes;
	R1 = toi64(tou8(R1));
	R2 = 2000;
	if (asi64(R1) >= asi64(R2)) goto L5297;
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&data;
	R3 = (u64)&nbytes;
	asu8(R3) = *(tou8p(R3)) += 1;
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L5296;
L5297:
	R1 = 0;
	allbytes = asu8(R1);
	goto L5294;
L5296:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5295:
	asu64(R1) = q;
	if (asu64(R1)) goto L5292;
L5294:
	asu8(R1) = allbytes;
	if (!asu8(R1)) goto L5299;
	asu8(R1) = nbytes;
	if (!asu8(R1)) goto L5299;
	asu8(R1) = nbytes;
	R1 = toi64(tou8(R1));
	asu8(R2) = nbytes;
	R2 = toi64(tou8(R2));
	R3 = (u64)&data;
	asu64(R2) = mlib_pcm_copyheapstringn(asu64(R3), asi64(R2));
	asu64(R1) = pc_api_gendata(asu64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5298;
L5299:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5303;
L5300:
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = q;
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5303:
	asu64(R1) = q;
	if (asu64(R1)) goto L5300;
L5298:
	goto L5272;
L5275:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5305;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5305;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5305;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5306;
	goto L5307;
L5305:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = offset;
	if (!asi64(R1)) goto L5309;
	asi64(R1) = offset;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L5309:
	asi64(R1) = am;
	R2 = 80;
	if (asi64(R1) != asi64(R2)) goto L5311;
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5310;
L5311:
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
L5310:
	goto L5304;
L5306:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5313;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5313:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5304;
L5307:
	R1 = 0;
	R2 = tou64("Idata &frameXXX");
	mm_support_gerror(asu64(R2), asu64(R1));
L5304:
	goto L5271;
	goto L5272;
L5276:
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5272;
L5277:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
	goto L5272;
L5278:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5315;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L5314;
L5315:
	R1 = 0;
L5314:
	R2 = 80;
	R3 = 1;
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5272;
L5279:
	asu64(R1) = p;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("IDATA: ");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5272:
L5271:
	return;
}

static u64 mm_genpcl_genmem_u(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L5316;
L5316:
	return asu64(R1);
}

static u64 mm_genpcl_genmem_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L5317;
L5317:
	return asu64(R1);
}

static void mm_genpcl_genpushmem_d(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static u64 mm_genpcl_genmemaddr_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L5319;
L5319:
	return asu64(R1);
}

static void mm_genpcl_genpushmemaddr_d(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static i64 mm_genpcl_definelabel() {
    u64 R1, R2; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = pc_api_mlabelno;
	goto L5321;
L5321:
	return asi64(R1);
}

static i64 mm_genpcl_createfwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L5322;
L5322:
	return asi64(R1);
}

static void mm_genpcl_definefwdlabel(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_genpcl_genreturn() {
    u64 R1, R2, R3; 
	asu64(R1) = mm_decls_currproc;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5326;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5327;
	goto L5328;
L5326:
	R1 = 0;
	R2 = 20;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5325;
L5327:
	R1 = 0;
	R2 = 23;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	goto L5325;
L5328:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	R3 = 122;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 23;
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
L5325:
	return;
}

static i64 mm_genpcl_reversecond(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5331;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5332;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5333;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5334;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5335;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5336;
	goto L5337;
L5331:
	R1 = 2;
	cc = asi64(R1);
	goto L5330;
L5332:
	R1 = 1;
	cc = asi64(R1);
	goto L5330;
L5333:
	R1 = 5;
	cc = asi64(R1);
	goto L5330;
L5334:
	R1 = 6;
	cc = asi64(R1);
	goto L5330;
L5335:
	R1 = 3;
	cc = asi64(R1);
	goto L5330;
L5336:
	R1 = 4;
	cc = asi64(R1);
	goto L5330;
L5337:
L5330:
	asi64(R1) = cc;
	goto L5329;
L5329:
	return asi64(R1);
}

static i64 mm_genpcl_reversecond_order(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5340;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5341;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5342;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5343;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5344;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5345;
	goto L5346;
L5340:
	R1 = 1;
	cc = asi64(R1);
	goto L5339;
L5341:
	R1 = 2;
	cc = asi64(R1);
	goto L5339;
L5342:
	R1 = 6;
	cc = asi64(R1);
	goto L5339;
L5343:
	R1 = 5;
	cc = asi64(R1);
	goto L5339;
L5344:
	R1 = 4;
	cc = asi64(R1);
	goto L5339;
L5345:
	R1 = 3;
	cc = asi64(R1);
	goto L5339;
L5346:
L5339:
	asi64(R1) = cc;
	goto L5338;
L5338:
	return asi64(R1);
}

static void mm_genpcl_stacklooplabels(i64 a, i64 b, i64 c) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_genpcl_loopindex;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L5349;
	R1 = 0;
	R2 = tou64("Too many nested loops");
	mm_support_gerror(asu64(R2), asu64(R1));
L5349:
	asi64(R1) = a;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 3;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static i64 mm_genpcl_findlooplabel(i64 k, i64 n) {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = mm_genpcl_loopindex;
	asi64(R2) = n;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5353;
	asi64(R1) = i;
	asi64(R2) = mm_genpcl_loopindex;
	if (asi64(R1) <= asi64(R2)) goto L5352;
L5353:
	R1 = 0;
	R2 = tou64("Bad loop index");
	mm_support_gerror(asu64(R2), asu64(R1));
L5352:
	R1 = (u64)&mm_genpcl_loopstack;
	asi64(R2) = i;
	R1 += (i64)R2*32-32;
	asi64(R2) = k;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L5350;
L5350:
	return asi64(R1);
}

static void mm_genpcl_genpc_sysfn(i64 fnindex, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asi64(R5) = fnindex;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_genpcl_genpc_sysproc(i64 fnindex, u64 a, u64 b, u64 c, i64 asfunc) {
    u64 R1, R2, R3; 
	i64 nargs;
	i64 opc;
	u64 d;
	u64 p;
	R1 = 0;
	nargs = asi64(R1);
	R1 = 0;
	opc = asi64(R1);
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	p = asu64(R1);
	R1 = (u64)&nargs;
	R2 = 3;
	asu64(R3) = c;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nargs;
	R2 = 2;
	asu64(R3) = b;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nargs;
	R2 = 1;
	asu64(R3) = a;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = nargs;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = fnindex;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5357;
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	asi64(R2) = asfunc;
	if (!asi64(R2)) goto L5359;
	R2 = 21;
	goto L5358;
L5359:
	R2 = 18;
L5358:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = nargs;
	pc_api_pc_setnargs(asi64(R1));
	goto L5356;
L5357:
	R1 = (u64)&mm_tables_sysfnnames;
	asi64(R2) = fnindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	asu64(R1) = pc_api_gennameaddr(asu64(R1));
	asi64(R2) = asfunc;
	if (!asi64(R2)) goto L5361;
	R2 = 21;
	goto L5360;
L5361:
	R2 = 18;
L5360:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5356:
	asi64(R1) = nargs;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_genpcl_pushsysarg(u64 p, i64 n, u64 nargs) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L5364;
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = nargs;
	(*toi64p(R1)) += 1;
L5364:
	return;
}

static void mm_genpcl_start() {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_genpcl_getsysfnhandler(i64 fn) {
    u64 R1, R2, R3; 
	u64 p;
	struct $B15 str;
	i64 report;
	u64 pp;
	R1 = (u64)&mm_tables_sysfnhandlers;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5368;
	R1 = (u64)&mm_tables_sysfnhandlers;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5366;
L5368:
	R1 = tou64("m$");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_sysfnnames;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L5372;
L5369:
	R1 = (u64)&str;
	asu64(R2) = pp;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5374;
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_tables_sysfnhandlers;
	asi64(R3) = fn;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5366;
L5374:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L5372:
	asu64(R1) = pp;
	if (asu64(R1)) goto L5369;
	R1 = 1;
	report = asi64(R1);
	R1 = 0;
	report = asi64(R1);
	asi64(R1) = report;
	if (!asi64(R1)) goto L5376;
	msysc_m$print_startcon();
	R1 = tou64("Sysfn not found:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5376:
	asi64(R1) = fn;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L5378;
	R1 = 33;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5380;
	asi64(R1) = report;
	if (!asi64(R1)) goto L5380;
	R1 = 0;
	R2 = tou64("No m$unimpl");
	mm_support_gerror(asu64(R2), asu64(R1));
L5380:
	asu64(R1) = p;
	goto L5366;
L5378:
	R1 = 0;
	goto L5366;
L5366:
	return asu64(R1);
}

static u64 mm_genpcl_findhostfn(i64 opc) {
    u64 R1, R2; 
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5383;
	goto L5384;
L5383:
	R1 = 32;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	goto L5382;
L5384:
	R1 = 0;
L5382:
	goto L5381;
L5381:
	return asu64(R1);
}

static void mm_genpcl_genpushint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genpushreal(r64 x, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asr64(R2) = x;
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genpushstring(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genmaindef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 i;
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5391;
L5389:
	asi64(R1) = i;
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) == asi64(R2)) goto L5393;
	R1 = (u64)&mm_decls_modules;
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
L5393:
	i += 1; if (i <= mm_decls_nsubprogs) goto L5389;
L5391:
	R1 = (u64)&mm_decls_modules;
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = mm_decls_mainsubprogno;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
	return;
}

static void mm_genpcl_genstartdef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lead;
	i64 m;
	i64 s;
	i64 i;
	R1 = 0;
	lead = asi64(R1);
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L5396;
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = s;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L5396;
	R1 = 1;
	lead = asi64(R1);
	goto L5395;
L5396:
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = s;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L5397;
	R1 = 2;
	lead = asi64(R1);
L5397:
L5395:
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	asi64(R1) = lead;
	if (!asi64(R1)) goto L5399;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5402;
L5400:
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = s;
	if (asi64(R1) != asi64(R2)) goto L5404;
	asi64(R1) = i;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L5404;
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
L5404:
	i += 1; if (i <= mm_decls_nmodules) goto L5400;
L5402:
L5399:
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
	return;
}

static void mm_genpcl_initstaticvar(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5407;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
L5407:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_genpcl_docallproc(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	if (asu64(R1)) goto L5410;
	goto L5408;
L5410:
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_api_pc_setnargs(asi64(R1));
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 18;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5408:
	return;
}

static void mm_genpcl_doprocdef(u64 d, i64 ismain) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 e;
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = ismain;
	R3 = 0;
	asu64(R4) = d;
	asu64(R4) = mm_libpcl_getpsymbol(asu64(R4));
	R5 = R4;
	p = asu64(R5);
	pc_api_pc_defproc(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5415;
L5412:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5417;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5418;
	goto L5419;
L5417:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	goto L5416;
L5418:
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5422;
	asu64(R1) = e;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5421;
L5422:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addlocal(asu64(R1));
L5421:
	goto L5416;
L5419:
L5416:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5415:
	asu64(R1) = e;
	if (asu64(R1)) goto L5412;
	return;
}

static void mm_genpcl_scanprocs() {
    u64 R1, R2, R3; 
	struct $B70 proctable;
	u64 currpcl;
	i64 nprocs;
	i64 i;
	R1 = 0;
	nprocs = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	currpcl = asu64(R1);
L5424:
	asu64(R1) = currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L5429;
	R2 = 121;
	if (asi64(R1) != asi64(R2)) goto L5428;
L5429:
	asu64(R1) = currpcl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5428;
	asi64(R1) = nprocs;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L5431;
	R1 = 0;
	R2 = tou64("PCL proctab overflow");
	mm_support_gerror(asu64(R2), asu64(R1));
L5431:
	asu64(R1) = currpcl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&proctable;
	R3 = (u64)&nprocs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5428:
	R1 = (u64)&currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L5424;
	asi64(R1) = nprocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5433;
	asu64(R1) = mm_blockpcl_pnprocs;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5433;
	R1 = 3;
	R2 = tou64("$nprocs");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pnprocs = asu64(R1);
	R1 = 10;
	asu64(R2) = mm_blockpcl_pnprocs;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5434;
L5433:
	mm_genpcl_setfunctab();
	asu64(R1) = mm_blockpcl_pprocaddr;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nprocs;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 11;
	asu64(R2) = mm_blockpcl_pprocaddr;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_api_pccurr;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = mm_blockpcl_pprocaddr;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5437;
L5435:
	R1 = (u64)&proctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nprocs) goto L5435;
L5437:
	asu64(R1) = mm_blockpcl_pprocname;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nprocs;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 11;
	asu64(R2) = mm_blockpcl_pprocname;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_api_pccurr;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = mm_blockpcl_pprocname;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5440;
L5438:
	R1 = (u64)&proctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nprocs) goto L5438;
L5440:
// mm_genpcl.scanprocs.finish:
L5434:
	asu64(R1) = mm_blockpcl_pnprocs;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = nprocs;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_setfunctab() {
    u64 R1, R2, R3; 
	asu64(R1) = mm_blockpcl_pnprocs;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5443;
	R1 = 3;
	R2 = tou64("$nprocs");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pnprocs = asu64(R1);
	R1 = 10;
	asu64(R2) = mm_blockpcl_pnprocs;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = tou64("$procname");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pprocname = asu64(R1);
	R1 = 3;
	R2 = tou64("$procaddr");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pprocaddr = asu64(R1);
L5443:
	return;
}

static u64 mm_libpcl_getpsymbol(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 e;
	struct $B16 str;
	struct $B21 chain;
	i64 n;
	i64 i;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5446;
	R1 = 0;
	goto L5444;
L5446:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5448;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5444;
L5448:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5450;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5450;
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getequivdef(asu64(R1));
	R2 = R1;
	e = asu64(R2);
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5444;
L5450:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5453;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5453;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5452;
L5453:
	asu64(R1) = d;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5455;
	asu64(R1) = d;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5454;
L5455:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L5454:
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L5451;
L5452:
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L5456:
	asu64(R1) = e;
	R2 = (u64)&chain;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5459;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5456;
L5459:
	R1 = (u64)&chain;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5462;
L5460:
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5464;
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L5463;
L5464:
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L5463:
	i += -1; if (i >= 1) goto L5460;
L5462:
L5451:
	R1 = (u64)&mm_tables_name2pid;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	R2 = R1;
	p = asu64(R2);
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5466;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5466;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5466:
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5468;
	R1 = 1;
	asu64(R2) = p;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5468:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5471;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5470;
L5471:
	R1 = 1;
	asu64(R2) = p;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5470:
	asu64(R1) = d;
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 6;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = p;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 108;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	if (!asu16(R1)) goto L5473;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5473;
	asu64(R1) = e;
	if (!asu64(R1)) goto L5473;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5473;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5473;
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 104;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5473:
	asu64(R1) = p;
	goto L5444;
L5444:
	return asu64(R1);
}

static void mm_libpcl_setmode(i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = mode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asi64(R2) = mode;
	asi64(R2) = mm_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static void mm_libpcl_setmode2(i64 mode) {
    u64 R1; 
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	pc_api_pc_setmode2(asi64(R1));
	return;
}

static void mm_libpcl_setmode_u(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = mode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asi64(R2) = mode;
	asi64(R2) = mm_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static u64 mm_libpcl_getequivdef(u64 d) {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5479;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L5480;
	goto L5481;
L5479:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5478;
L5480:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5478;
L5481:
	R1 = 0;
	R2 = tou64("geteqv");
	mm_support_gerror(asu64(R2), asu64(R1));
	R1 = 0;
L5478:
	goto L5477;
L5477:
	return asu64(R1);
}

static void mm_blockpcl_evalunit(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 a;
	u64 b;
	u64 c;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5484;
	goto L5482;
L5484:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L5488;
	case 2: goto L5489;
	case 3: case 5: case 7: case 9: case 10: case 11: case 12: case 13: case 20: case 21: case 22: case 23: case 24: case 26: case 27: case 37: case 41: case 42: case 43: case 44: case 45: case 47: case 50: case 54: case 57: case 60: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: goto L5487;
	case 4: goto L5490;
	case 6: goto L5491;
	case 8: goto L5552;
	case 14: goto L5554;
	case 15: goto L5525;
	case 16: goto L5526;
	case 17: goto L5542;
	case 18: goto L5543;
	case 19: goto L5544;
	case 25: goto L5494;
	case 28: goto L5495;
	case 29: goto L5497;
	case 30: goto L5496;
	case 31: goto L5498;
	case 32: goto L5492;
	case 33: goto L5527;
	case 34: goto L5528;
	case 35: goto L5529;
	case 36: goto L5541;
	case 38: goto L5549;
	case 39: goto L5550;
	case 40: goto L5545;
	case 46: goto L5530;
	case 48: goto L5555;
	case 49: goto L5533;
	case 51: goto L5531;
	case 52: goto L5532;
	case 53: goto L5534;
	case 55: goto L5535;
	case 56: goto L5536;
	case 58: goto L5537;
	case 59: goto L5539;
	case 61: goto L5538;
	case 62: goto L5540;
	case 89: goto L5493;
	case 90: goto L5551;
	case 91: goto L5499;
	case 92: goto L5500;
	case 93: goto L5501;
	case 94: goto L5502;
	case 95: goto L5503;
	case 96: goto L5504;
	case 97: goto L5505;
	case 98: goto L5506;
	case 99: goto L5507;
	case 100: goto L5508;
	case 101: goto L5509;
	case 102: goto L5510;
	case 103: goto L5511;
	case 104: goto L5512;
	case 105: goto L5513;
	case 106: goto L5514;
	case 107: case 108: case 109: case 110: goto L5515;
	case 111: goto L5517;
	case 112: goto L5518;
	case 113: goto L5516;
	case 114: case 115: goto L5519;
	case 116: case 117: goto L5520;
	case 118: goto L5521;
	case 119: goto L5522;
	case 120: goto L5523;
	case 121: goto L5524;
	case 122: goto L5553;
	default: goto L5487;
    };
// SWITCH
L5488:
	asu64(R1) = p;
	mm_blockpcl_do_const(asu64(R1));
	goto L5485;
L5489:
	goto L5485;
L5490:
	asu64(R1) = p;
	mm_blockpcl_do_name(asu64(R1));
	goto L5485;
L5491:
	asu64(R1) = p;
	mm_blockpcl_do_block(asu64(R1));
	goto L5485;
L5492:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_callproc(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5493:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_return(asu64(R2), asu64(R1));
	goto L5485;
L5494:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_returnmult(asu64(R2), asu64(R1));
	goto L5485;
L5495:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_assign(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5496:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignms(asu64(R2), asu64(R1));
	goto L5485;
L5497:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignmm(asu64(R2), asu64(R1));
	goto L5485;
L5498:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignmdrem(asu64(R2), asu64(R1));
	goto L5485;
L5499:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_to(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5500:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5485;
L5501:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_for(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5485;
L5502:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_for(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5485;
L5503:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_forall(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5485;
L5504:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_forall(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5485;
L5505:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_blockpcl_do_while(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5506:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_repeat(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5507:
	asu64(R1) = a;
	mm_blockpcl_do_goto(asu64(R1));
	goto L5485;
L5508:
	asu64(R1) = p;
	mm_blockpcl_do_labeldef(asu64(R1));
	goto L5485;
L5509:
	R1 = 1;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L5485;
L5510:
	R1 = 2;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L5485;
L5511:
	R1 = 3;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L5485;
L5512:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_do(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5513:
	R1 = 0;
	R2 = 0;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_blockpcl_do_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5485;
L5514:
	R1 = 0;
	R2 = 1;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_blockpcl_do_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5485;
L5515:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_switch(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5485;
L5516:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_recase(asu64(R2), asu64(R1));
	goto L5485;
L5517:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_swap(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5518:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_select(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5485;
L5519:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_print(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5520:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_print(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5521:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_read(asu64(R2), asu64(R1));
	goto L5485;
L5522:
	asu64(R1) = a;
	mm_blockpcl_do_readln(asu64(R1));
	goto L5485;
L5523:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_stop(asu64(R2), asu64(R1));
	goto L5485;
L5524:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 134;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5485;
L5525:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_andl(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5526:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_orl(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5527:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_setcc(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5528:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_setccchain(asu64(R2), asu64(R1));
	goto L5485;
L5529:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_bin(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5530:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_index(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5531:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_dotindex(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5532:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_dotslice(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5533:
	asu64(R1) = p;
	mm_blockpcl_do_dot(asu64(R1));
	goto L5485;
L5534:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_ptr(asu64(R2), asu64(R1));
	goto L5485;
L5535:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L5485;
L5536:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L5485;
L5537:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_convert(asu64(R2), asu64(R1));
	goto L5485;
L5538:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_typepun(asu64(R2), asu64(R1));
	goto L5485;
L5539:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_shorten(asu64(R2), asu64(R1));
	goto L5485;
L5540:
	asu64(R1) = p;
	mm_blockpcl_do_typeconst(asu64(R1));
	goto L5485;
L5541:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_unary(asu64(R2), asu64(R1));
	goto L5485;
L5542:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_notl(asu64(R2), asu64(R1));
	goto L5485;
L5543:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_istruel(asu64(R2), asu64(R1));
	goto L5485;
L5544:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_isfalsel(asu64(R2), asu64(R1));
	goto L5485;
L5545:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L5548;
	R2 = 85;
	if (asi64(R1) != asi64(R2)) goto L5547;
L5548:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_incr(asu64(R2), asu64(R1));
	goto L5546;
L5547:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_incrload(asu64(R2), asu64(R1));
L5546:
	goto L5485;
L5549:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_binto(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5550:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_unaryto(asu64(R2), asu64(R1));
	goto L5485;
L5551:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_syscall(asu64(R2), asu64(R1));
	goto L5485;
L5552:
	asu64(R1) = p;
	asu64(R1) = pc_api_genassem(asu64(R1));
	R2 = 42;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5485;
L5553:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_empty(asu64(R2), asu64(R1));
	goto L5485;
L5554:
	R1 = tou64(" ");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_api_gencomment(asu64(R1));
	goto L5485;
L5555:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_slice(asu64(R3), asu64(R2), asu64(R1));
	goto L5485;
L5487:
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("UNSUPPORTED TAG ");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L5482;
L5485:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5557;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5557;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5559;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L5559;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L5559;
	goto L5560;
L5559:
	goto L5558;
L5560:
	R1 = (u64)&mm_tables_jsolo;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5562;
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("NOT ALLOWED BY ITSELF:");
	asu64(R2) = pc_api_addstr(asu64(R3), asu64(R2));
	mm_support_gerror(asu64(R2), asu64(R1));
L5562:
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5558:
L5557:
L5482:
	return;
}

static void mm_blockpcl_evalref(u64 p, u64 q) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	u64 b;
	u64 c;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5565;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5566;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5567;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5568;
	goto L5569;
L5565:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushmemaddr_d(asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = q;
	if (!asu64(R1)) goto L5571;
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 17;
	mm_libpcl_setmode(asi64(R1));
L5571:
	goto L5564;
L5566:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_indexref(asu64(R2), asu64(R1));
	goto L5564;
L5567:
	asu64(R1) = p;
	mm_blockpcl_do_dotref(asu64(R1));
	goto L5564;
L5568:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	goto L5564;
L5569:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5573;
	goto L5574;
L5573:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5572;
L5574:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("evalref");
	mm_support_gerror(asu64(R2), asu64(R1));
L5572:
L5564:
	return;
}

static void mm_blockpcl_evalarray(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5577;
	goto L5578;
L5577:
	R1 = 0;
	asu64(R2) = p;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5576;
L5578:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L5580;
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5579;
L5580:
	R1 = 0;
	asu64(R2) = p;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
L5579:
L5576:
	return;
}

static void mm_blockpcl_do_block(u64 p) {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L5583;
L5582:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L5583:
	asu64(R1) = a;
	if (asu64(R1)) goto L5582;
	return;
}

static void mm_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	u64 s;
	i64 lab2;
	i64 i;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5587;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5588;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5589;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5589;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5590;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5591;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L5592;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5593;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L5594;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5595;
	goto L5596;
L5587:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5598;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5599;
	goto L5600;
L5598:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5597;
L5599:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L5597;
L5600:
L5597:
	goto L5586;
L5588:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5602;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5603;
	goto L5604;
L5602:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L5601;
L5603:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5601;
L5604:
L5601:
	goto L5586;
L5589:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5606;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5607;
	goto L5608;
L5606:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5605;
L5607:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5605;
L5608:
L5605:
	goto L5586;
L5590:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5586;
L5591:
	goto L5610;
L5609:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5610:
	asu64(R1) = q;
	if (!asu64(R1)) goto L5612;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5609;
L5612:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L5586;
L5592:
	asi64(R1) = lab;
	asu64(R2) = r;
	asu64(R3) = q;
	asu64(R4) = p;
	R5 = 64;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asi64(R5) = opc;
	mm_blockpcl_gcomparejump(asi64(R5), asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5586;
L5593:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L5614;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 3;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 4;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L5613;
L5614:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 3;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 6;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L5613:
	goto L5586;
L5594:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5616;
	R1 = 0;
	R2 = tou64("empty set");
	mm_support_gerror(asu64(R2), asu64(R1));
L5616:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L5618;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5620;
L5619:
	asu64(R1) = s;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	if (!asu64(R1)) goto L5623;
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5622;
L5623:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 2;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5622:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L5620:
	asu64(R1) = s;
	if (asu64(R1)) goto L5619;
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L5617;
L5618:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5627;
L5624:
	asu64(R1) = s;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5629;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5629:
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
L5627:
	asu64(R1) = s;
	if (asu64(R1)) goto L5624;
L5617:
	goto L5586;
L5595:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L5631;
	goto L5633;
L5632:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5636;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	asi64(R2) = mm_genpcl_reversecond_order(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5635;
L5636:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5635:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L5633:
	asu64(R1) = r;
	if (asu64(R1)) goto L5632;
	goto L5630;
L5631:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	goto L5638;
L5637:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5641;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	asi64(R2) = mm_genpcl_reversecond_order(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5640;
L5641:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5640:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L5638:
	asu64(R1) = r;
	if (asu64(R1)) goto L5637;
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
L5630:
	goto L5586;
L5596:
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttisblock;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5643;
	R1 = 0;
	R2 = tou64("jumpt/f");
	mm_support_gerror(asu64(R2), asu64(R1));
L5643:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
L5586:
	return;
}

static void mm_blockpcl_gcomparejump(i64 jumpopc, i64 cond, u64 lhs, u64 rhs, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = jumpopc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L5646;
	asi64(R1) = cond;
	asi64(R1) = mm_genpcl_reversecond(asi64(R1));
	cond = asi64(R1);
L5646:
	asu64(R1) = lhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = cond;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = lhs;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_unimpl(u64 mess) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = mess;
	R3 = tou64("Unimplemented: #");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_const(u64 p) {
    u64 R1, R2, R3; 
	i64 mode;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5652;
	asi64(R1) = mode;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5651;
L5652:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	goto L5650;
L5651:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5653;
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	mm_genpcl_genpushreal(asr64(R2), asi64(R1));
	goto L5650;
L5653:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5654;
	asu64(R1) = p;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5656;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L5658;
	R1 = 0;
	R2 = tou64("1:B-str?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5658:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushstring(asu64(R1));
	goto L5655;
L5656:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
L5655:
	goto L5650;
L5654:
	R1 = 0;
	R2 = tou64("do_const");
	mm_support_gerror(asu64(R2), asu64(R1));
L5650:
	asi64(R1) = mode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_name(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5661;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5661;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5662;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5663;
	goto L5664;
L5661:
	asu64(R1) = d;
	mm_genpcl_genpushmemaddr_d(asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5660;
L5662:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5666;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5666:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5668;
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5667;
L5668:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5667:
	goto L5660;
L5663:
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_genpcl_genpushint(asi64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5660;
L5664:
	asu64(R1) = d;
	mm_genpcl_genpushmem_d(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
L5660:
	return;
}

static void mm_blockpcl_do_stop(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L5671;
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5670;
L5671:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L5670:
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_andl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 labfalse;
	i64 labend;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	labfalse = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = labfalse;
	asu64(R2) = a;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labfalse;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = labfalse;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_orl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 labtrue;
	i64 labfalse;
	i64 labend;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	labtrue = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labfalse = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = labtrue;
	asu64(R2) = a;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labfalse;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labtrue;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = labfalse;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_notl(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_istruel(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
	return;
}

static void mm_blockpcl_do_isfalsel(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 65;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
	return;
}

static void mm_blockpcl_do_typepun(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5679;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 92;
	R2 += (i64)R3;
	R3 = 5;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5679:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L5681;
	goto L5677;
L5681:
	R1 = 0;
	R2 = 110;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 53;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
L5677:
	return;
}

static void mm_blockpcl_do_shorten(u64 p, u64 a) {
    u64 R1; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	return;
}

static void mm_blockpcl_do_assign(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5685;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (asu16(R1)) goto L5685;
	goto L5683;
L5685:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5687;
	goto L5688;
L5687:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5690;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_assignblock(asu64(R3), asu64(R2), asu64(R1));
	goto L5683;
L5690:
	goto L5686;
L5688:
L5686:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5692;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L5693;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5694;
	goto L5695;
L5692:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	mm_blockpcl_do_storeindex(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L5683;
	goto L5691;
L5693:
	R1 = 0;
	R2 = tou64("ASS/SLICE");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L5691;
L5694:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	mm_blockpcl_do_storedot(asu64(R3), asu64(R2), asu64(R1));
	goto L5683;
	goto L5691;
L5695:
L5691:
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5697;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5697:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5699;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5700;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5701;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5702;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5703;
	goto L5704;
L5699:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5707;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5707;
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5706;
L5707:
	R1 = 0;
	R2 = tou64("Assign to proc?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5706:
	asu64(R1) = a;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5698;
L5700:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5698;
L5701:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 16;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	goto L5683;
	goto L5698;
L5702:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 17;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	goto L5683;
	goto L5698;
L5703:
	R1 = 1;
	asu64(R2) = a;
	R3 = 32;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = a;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5698;
L5704:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Can't assign");
	mm_support_gerror(asu64(R2), asu64(R1));
L5698:
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
L5683:
	return;
}

static void mm_blockpcl_do_bin(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L5711;
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L5710;
L5711:
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asu64(R3) = p;
	R4 = 62;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L5709;
L5710:
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L5713;
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L5713:
L5709:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_setcc(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 64;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 31;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_setccchain(u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	i64 lab1;
	i64 lab2;
	i64 i;
	i64 cond;
	u64 r;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5717;
L5716:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R1) = mm_genpcl_reversecond(asi64(R1));
	cond = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5720;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = cond;
	asi64(R1) = mm_genpcl_reversecond_order(asi64(R1));
	cond = asi64(R1);
L5720:
	asi64(R1) = lab1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = cond;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5722;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5722:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L5717:
	asu64(R1) = r;
	if (asu64(R1)) goto L5716;
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = lab1;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_binto(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5725;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5725;
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L5725:
	return;
}

static void mm_blockpcl_do_unary(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 adj;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5728;
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5730;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5730;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5731;
	goto L5732;
L5730:
	R1 = 8;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5734;
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	adj = asi64(R1);
	asi64(R1) = adj;
	if (!asi64(R1)) goto L5736;
	asi64(R1) = adj;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 43;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L5736:
L5734:
	goto L5729;
L5731:
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L5729;
L5732:
L5729:
	goto L5726;
L5728:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
L5726:
	return;
}

static void mm_blockpcl_do_unaryto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_ptr(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_labeldef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	struct $B16 str;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5741;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5741:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 128;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_goto(u64 a) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5744;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5744;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5746;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5746:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5743;
L5744:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5743:
	return;
}

static void mm_blockpcl_do_do(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 lab_abc;
	i64 lab_d;
	asi64(R1) = mm_genpcl_definelabel();
	lab_abc = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_abc;
	asi64(R3) = lab_abc;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_to(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 cvar;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 count;
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cvar = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = cvar;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5750;
	asu64(R1) = cvar;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = mm_genpcl_pzero;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_d;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 4;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5749;
L5750:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	count = asi64(R1);
	asi64(R1) = count;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L5752;
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
L5752:
L5749:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 33;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = cvar;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_while(u64 p, u64 pcond, u64 pbody, u64 pincr) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_incr;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L5755;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_incr = asi64(R1);
	goto L5754;
L5755:
	asi64(R1) = lab_c;
	lab_incr = asi64(R1);
L5754:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = lab_incr;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L5757;
	asu64(R1) = pincr;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_incr;
	mm_genpcl_definefwdlabel(asi64(R1));
L5757:
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_repeat(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 lab_ab;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = mm_genpcl_definelabel();
	lab_ab = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_ab;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5761;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5760;
L5761:
	asi64(R1) = lab_ab;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
L5760:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_exit(u64 p, i64 k) {
    u64 R1, R2; 
	i64 n;
	i64 index;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	index = asi64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5764;
	asi64(R1) = mm_genpcl_loopindex;
	index = asi64(R1);
L5764:
	asi64(R1) = index;
	asi64(R2) = k;
	asi64(R1) = mm_genpcl_findlooplabel(asi64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5766;
	asu64(R1) = p;
	R2 = tou64("Bad exit/loop index");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L5765;
L5766:
	asi64(R1) = n;
	mm_blockpcl_genjumpl(asi64(R1));
L5765:
	return;
}

static void mm_blockpcl_do_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 isref) {
    u64 R1, R2, R3; 
	i64 labend;
	i64 i;
	i64 lab2;
	i64 ismult;
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	ismult = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L5769;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5769:
	goto L5773;
L5770:
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = pcond;
	R3 = 28;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L5775;
	R1 = 0;
	asu64(R2) = plist;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L5774;
L5775:
	asu64(R1) = plist;
	mm_blockpcl_evalunit(asu64(R1));
L5774:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L5777;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5777:
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5780;
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5779;
L5780:
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
L5779:
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcond = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
L5773:
	asu64(R1) = pcond;
	if (asu64(R1)) goto L5770;
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5782;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L5784;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L5783;
L5784:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L5783:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L5786;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5786:
L5782:
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_return(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L5789;
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5788;
L5789:
	asi64(R1) = mm_genpcl_retindex;
	mm_blockpcl_genjumpl(asi64(R1));
L5788:
	return;
}

static void mm_blockpcl_do_returnmult(u64 p, u64 a) {
    u64 R1, R2, R3; 
	struct $B93 params;
	u64 q;
	i64 nparams;
	i64 i;
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 0;
	nparams = asi64(R1);
	goto L5792;
L5791:
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5795;
	R1 = 0;
	R2 = tou64("Mult?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5795:
	asu64(R1) = q;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5792:
	asu64(R1) = q;
	if (asu64(R1)) goto L5791;
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5798;
L5796:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_evalunit(asu64(R1));
	i += -1; if (i >= 1) goto L5796;
L5798:
	asi64(R1) = mm_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 30;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = nparams;
	pc_api_pc_setnargs(asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_blockpcl_do_callproc(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	struct $B93 paramlist;
	struct $B5 argattr;
	i64 nparams;
	i64 isptr;
	i64 nvariadics;
	i64 nret;
	i64 isfn;
	i64 iparams;
	i64 fparams;
	i64 nfixedparams;
	u64 d;
	u64 e;
	u64 pmult;
	u64 q;
	i64 i;
	R1 = 0;
	isptr = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5801;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5802;
	goto L5803;
L5801:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5800;
L5802:
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 1;
	isptr = asi64(R1);
	goto L5800;
L5803:
	R1 = 0;
	R2 = tou64("call/not ptr");
	mm_support_gerror(asu64(R2), asu64(R1));
L5800:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nvariadics = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	nfixedparams = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5807;
L5804:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5809;
	R1 = (u64)&nfixedparams;
	(*toi64p(R1)) += 1;
L5809:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5807:
	asu64(R1) = e;
	if (asu64(R1)) goto L5804;
	asu64(R1) = b;
	q = asu64(R1);
	goto L5813;
L5810:
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5815;
	R1 = 0;
	R2 = tou64("maxparams");
	mm_support_gerror(asu64(R2), asu64(R1));
L5815:
	asu64(R1) = q;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5817;
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) < asi64(R2)) goto L5817;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L5817;
	asi64(R1) = nvariadics;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5817;
	asi64(R1) = nparams;
	nvariadics = asi64(R1);
L5817:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5813:
	asu64(R1) = q;
	if (asu64(R1)) goto L5810;
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	fparams = asi64(R2);
	iparams = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5820;
L5818:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5823;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5822;
L5823:
	R1 = (u64)&fparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5825;
	R1 = 2;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L5825:
	goto L5821;
L5822:
	R1 = (u64)&iparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5827;
	R1 = 2;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L5827:
L5821:
	i += 1; if (i <= nparams) goto L5818;
L5820:
	asi64(R1) = fparams;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5829;
	asi64(R1) = iparams;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5829;
	R1 = 0;
	R2 = tou64("Mixed stack args");
	mm_support_gerror(asu64(R2), asu64(R1));
L5829:
	asi64(R1) = fparams;
	asi64(R2) = iparams;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	R2 = 8;
	asi64(R1) -= asi64(R2);
	iparams = asi64(R1);
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5832;
L5830:
	asi64(R1) = iparams;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5834;
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	if (!asi8(R1)) goto L5834;
	R1 = 1;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	R1 = 0;
	iparams = asi64(R1);
L5834:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L5836;
	asi64(R1) = i;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L5836;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5836;
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 2;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 1;
	mm_libpcl_setmode(asi64(R1));
	goto L5835;
L5836:
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L5835:
	asi64(R1) = i;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	R1 = toi64(toi8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += -1; if (i >= 1) goto L5830;
L5832:
	asi64(R1) = isptr;
	if (asi64(R1)) goto L5838;
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L5840;
	R2 = 21;
	goto L5839;
L5840:
	R2 = 18;
L5839:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5837;
L5838:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L5842;
	R2 = 22;
	goto L5841;
L5842:
	R2 = 19;
L5841:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5837:
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = nvariadics;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L5844;
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5844:
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L5846;
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L5846;
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nret = asi64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5849;
L5847:
	R1 = 0;
	R2 = 13;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pmult;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nret) goto L5847;
L5849:
L5846:
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L5851;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5851;
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L5851:
	return;
}

static void mm_blockpcl_do_print(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	u64 fmt;
	i64 m;
	i64 fn;
	i64 needprintend;
	asu64(R1) = a;
	if (!asu64(R1)) goto L5854;
	R1 = 1;
	needprintend = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5856;
	R1 = 0;
	R2 = tou64("@dev no ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L5856:
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5858;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5859;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5860;
	goto L5861;
L5858:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 2;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5857;
L5859:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 3;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5857;
L5860:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 4;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5857;
L5861:
	R1 = 0;
	R2 = tou64("@dev?");
	mm_support_gerror(asu64(R2), asu64(R1));
L5857:
	goto L5853;
L5854:
	R1 = 1;
	needprintend = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 5;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L5853:
	asu64(R1) = b;
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L5863;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L5863;
	goto L5864;
L5863:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5867;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = q;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5866;
L5867:
	R1 = 0;
	R2 = tou64("string expected");
	mm_support_gerror(asu64(R2), asu64(R1));
L5866:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = q;
	R5 = 6;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5862;
L5864:
L5862:
	goto L5869;
L5868:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L5872;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5873;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L5874;
	goto L5875;
L5872:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fmt = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	goto L5871;
L5873:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 7;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5869;
	goto L5871;
L5874:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 8;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5869;
	goto L5871;
L5875:
	R1 = 0;
	fmt = asu64(R1);
	asu64(R1) = q;
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
L5871:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5877;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5878;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5879;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5880;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5881;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5882;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5883;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5884;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5885;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5886;
	goto L5887;
L5877:
	R1 = 9;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L5889;
	R1 = 10;
	fn = asi64(R1);
L5889:
	goto L5876;
L5878:
	R1 = 11;
	fn = asi64(R1);
	goto L5876;
L5879:
	R1 = 13;
	fn = asi64(R1);
	goto L5876;
L5880:
	R1 = 12;
	fn = asi64(R1);
	goto L5876;
L5881:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5892;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5891;
	R1 = (u64)&mm_decls_tttarget;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5891;
L5892:
	R1 = 14;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L5894;
	R1 = 15;
	fn = asi64(R1);
L5894:
	goto L5890;
L5891:
	R1 = 17;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L5896;
	R1 = 18;
	fn = asi64(R1);
L5896:
L5890:
	goto L5876;
L5882:
	R1 = 20;
	fn = asi64(R1);
	goto L5876;
L5883:
	R1 = 0;
	R2 = tou64("PRINTARRAY");
	mm_support_gerror(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5876;
L5884:
	R1 = 0;
	R2 = tou64("PRINTRECORD");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L5876;
L5885:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5898;
	R1 = 16;
	fn = asi64(R1);
	goto L5897;
L5898:
	R1 = 0;
	R2 = tou64("PRINTSLICE");
	mm_support_gerror(asu64(R2), asu64(R1));
L5897:
	goto L5876;
L5886:
	R1 = 19;
	fn = asi64(R1);
	goto L5876;
L5887:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("PRINT/T=#");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5876:
	asi64(R1) = fn;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5900;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5900;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5900;
	goto L5901;
L5900:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = r;
	asi64(R5) = fn;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5899;
L5901:
	R1 = 0;
	R2 = 0;
	asu64(R3) = fmt;
	if (!asu64(R3)) goto L5903;
	asu64(R3) = fmt;
	goto L5902;
L5903:
	asu64(R3) = mm_genpcl_pzero;
L5902:
	asu64(R4) = r;
	asi64(R5) = fn;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L5899:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5869:
	asu64(R1) = q;
	if (asu64(R1)) goto L5868;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 115;
	if (asi64(R1) == asi64(R2)) goto L5905;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L5905;
	goto L5906;
L5905:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 21;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5904;
L5906:
L5904:
	asi64(R1) = needprintend;
	if (!asi64(R1)) goto L5908;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 22;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L5908:
	return;
}

static void mm_blockpcl_do_incr(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_blockpcl_setincrstep(asi64(R1));
	return;
}

static void mm_blockpcl_setincrstep(i64 m) {
    u64 R1, R2, R3; 
	R1 = 1;
	pc_api_pc_setincr(asi64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5912;
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	pc_api_pc_setincr(asi64(R1));
L5912:
	return;
}

static void mm_blockpcl_do_incrload(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_blockpcl_setincrstep(asi64(R1));
	return;
}

static void mm_blockpcl_do_for(u64 p, u64 pindex, u64 pfrom, u64 pbody, i64 down) {
    u64 R1, R2, R3; 
	u64 pto;
	u64 pstep;
	u64 pelse;
	u64 px;
	u64 ptoinit;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 a;
	i64 b;
	i64 stepx;
	u64 d;
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = pto;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pstep = asu64(R1);
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptoinit = asu64(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 53;
	if (asi64(R1) != asi64(R2)) goto L5916;
	asu64(R1) = pto;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = px;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5918;
	asu64(R1) = px;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5918;
	asu64(R1) = d;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5918;
	R1 = 0;
	R2 = tou64("Possibly using &param as for-loop limit");
	mm_support_gerror(asu64(R2), asu64(R1));
L5918:
L5916:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5920;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_e = asi64(R1);
	goto L5919;
L5920:
	asi64(R1) = lab_d;
	lab_e = asi64(R1);
L5919:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = ptoinit;
	if (!asu64(R1)) goto L5922;
	R1 = 0;
	asu64(R2) = ptoinit;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ptoinit;
	mm_blockpcl_evalunit(asu64(R1));
L5922:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5924;
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5924;
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = down;
	if (!asi64(R1)) goto L5928;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L5927;
L5928:
	asi64(R1) = down;
	if (asi64(R1)) goto L5926;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L5926;
L5927:
	goto L5925;
L5926:
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5925:
	goto L5923;
L5924:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5930;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L5932;
	R2 = 6;
	goto L5931;
L5932:
	R2 = 3;
L5931:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	goto L5929;
L5930:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L5934;
	R2 = 3;
	goto L5933;
L5934:
	R2 = 6;
L5933:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5929:
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L5923:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pstep;
	if (!asu64(R1)) goto L5936;
	asu64(R1) = pstep;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5938;
	R1 = 0;
	R2 = tou64("for/step non-const not ready");
	mm_support_gerror(asu64(R2), asu64(R1));
L5938:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	stepx = asi64(R1);
	asi64(R1) = stepx;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L5940;
	R1 = 0;
	R2 = tou64("Bad for-step");
	mm_support_gerror(asu64(R2), asu64(R1));
L5940:
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = stepx;
	asi64(R3) = down;
	if (!asi64(R3)) goto L5942;
	R3 = 35;
	goto L5941;
L5942:
	R3 = 34;
L5941:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	goto L5935;
L5936:
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	asi64(R3) = down;
	if (!asi64(R3)) goto L5944;
	R3 = 35;
	goto L5943;
L5944:
	R3 = 34;
L5943:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L5935:
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5946;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5947;
	goto L5948;
L5946:
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5945;
L5947:
	asu64(R1) = pto;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L5945;
L5948:
L5945:
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5950;
	asi64(R1) = lab_e;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L5950:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_forall(u64 p, u64 pindex, u64 plist, u64 pbody, i64 down) {
    u64 R1, R2, R3; 
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 pelse;
	u64 passign;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 a;
	i64 b;
	u64 dto;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plocal = asu64(R1);
	asu64(R1) = plocal;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	passign = asu64(R1);
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5953;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_e = asi64(R1);
	goto L5952;
L5953:
	asi64(R1) = lab_d;
	lab_e = asi64(R1);
L5952:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5955;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5955;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	dto = asu64(R1);
	asu64(R1) = dto;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = dto;
	asu64(R1) = mm_lib_createname(asu64(R1));
	pto = asu64(R1);
	asu64(R1) = dto;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pto;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pto;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5955:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5957;
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5957;
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = down;
	if (!asi64(R1)) goto L5961;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L5960;
L5961:
	asi64(R1) = down;
	if (asi64(R1)) goto L5959;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L5959;
L5960:
	goto L5958;
L5959:
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5958:
	goto L5956;
L5957:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5963;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L5965;
	R2 = 6;
	goto L5964;
L5965:
	R2 = 3;
L5964:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	goto L5962;
L5963:
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L5967;
	R2 = 3;
	goto L5966;
L5967:
	R2 = 6;
L5966:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L5962:
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L5956:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = passign;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	asi64(R3) = down;
	if (!asi64(R3)) goto L5969;
	R3 = 35;
	goto L5968;
L5969:
	R3 = 34;
L5968:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5971;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5972;
	goto L5973;
L5971:
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5970;
L5972:
	asu64(R1) = pto;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L5970;
L5973:
	asu64(R1) = dto;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5970:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5975;
	asi64(R1) = lab_e;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L5975:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_convert(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5978;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5979;
	goto L5980;
L5978:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	goto L5976;
	goto L5977;
L5979:
	R1 = 0;
	R2 = tou64("CONV/ERROR");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L5977;
L5980:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_convtopcl;
	asu64(R3) = p;
	R4 = 62;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5977:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = p;
	R2 = 53;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
L5976:
	return;
}

static void mm_blockpcl_do_swap(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = b;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	R2 = 36;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static i64 mm_blockpcl_checkdotchain(u64 p, u64 pname) {
    u64 R1, R2, R3; 
	i64 offset;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5984;
	goto L5985;
L5984:
	asu64(R1) = pname;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	goto L5982;
	goto L5983;
L5985:
	asu64(R1) = p;
	asu64(R2) = pname;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L5982;
L5983:
	R1 = 0;
	goto L5982;
L5982:
	return asi64(R1);
}

static void mm_blockpcl_do_dotref(u64 pdot) {
    u64 R1, R2, R3; 
	i64 imode;
	i64 offset;
	u64 a;
	u64 pname;
	R1 = 0;
	asu64(R2) = pdot;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	imode = asi64(R1);
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	if (!asi64(R1)) goto L5988;
	asi64(R1) = offset;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
L5988:
	asi64(R1) = imode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_dot(u64 pdot) {
    u64 R1, R2, R3; 
	i64 offset;
	u64 a;
	u64 pname;
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdot;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_storedot(u64 pdot, u64 pfield, u64 rhs) {
    u64 R1, R2, R3; 
	i64 offset;
	u64 a;
	u64 pname;
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pdot;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5992;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5992:
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 6;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdot;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_index(u64 p, u64 parray, u64 pindex) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	i64 offset;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = offset;
	asi64(R2) = scale;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_storeindex(u64 p, u64 parray, u64 pindex, u64 rhs) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5996;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L5996:
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = scale;
	R3 = 6;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_indexref(u64 parray, u64 pindex) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = scale;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	return;
}

static i64 mm_blockpcl_getindexoffset(u64 parray, u64 pindex) {
    u64 R1, R2; 
	i64 offset;
	i64 addoffset;
	R1 = 0;
	addoffset = asi64(R1);
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 35;
	if (asi64(R1) != asi64(R2)) goto L6000;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6001;
	R2 = 44;
	if (asi64(R1) != asi64(R2)) goto L6000;
L6001:
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6003;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L6005;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6004;
L6005:
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
L6004:
	addoffset = asi64(R1);
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pindex;
	*tou64p(R2) = asu64(R1);
L6003:
L6000:
	asi64(R1) = addoffset;
	goto L5998;
L5998:
	return asi64(R1);
}

static void mm_blockpcl_do_switch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 isref) {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 minlab;
	i64 maxlab;
	i64 n;
	i64 iscomplex;
	i64 i;
	i64 lab_a;
	i64 lab_d;
	i64 labjump;
	i64 elselab;
	i64 labstmt;
	i64 ax;
	i64 bx;
	i64 ismult;
	i64 mode;
	u8 looptype;
	u8 opc;
	struct $B95 labels;
	u64 w;
	u64 wt;
	u64 pjump;
	u64 psetup;
	u64 djump;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L6008;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L6009;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L6010;
	goto L6011;
L6008:
	R1 = 0;
	looptype = asu8(R1);
	R1 = 37;
	opc = asu8(R1);
	goto L6007;
L6009:
// mm_blockpcl.do_switch.dodosw:
	R1 = 1;
	looptype = asu8(R1);
	R1 = 37;
	opc = asu8(R1);
	goto L6007;
L6010:
	R1 = 2;
	looptype = asu8(R1);
	R1 = 38;
	opc = asu8(R1);
	goto L6007;
L6011:
	R1 = 3;
	looptype = asu8(R1);
L6007:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6013;
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6013;
	R1 = 1;
	goto L6014;
L6013:
	R1 = 0;
L6014:
	ismult = asi64(R1);
	R1 = 1000000;
	minlab = asi64(R1);
	R1 = -1000000;
	maxlab = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	iscomplex = asi64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L6016;
L6015:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6019;
L6018:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6022;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6023;
	goto L6024;
L6022:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
// mm_blockpcl.do_switch.dorange:
L6025:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L6028;
L6026:
	asi64(R1) = i;
	asi64(R2) = minlab;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	minlab = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = maxlab;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxlab = asi64(R1);
	i += 1; if (i <= bx) goto L6026;
L6028:
	goto L6021;
L6023:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L6025;
	goto L6021;
L6024:
	R1 = 0;
	asu64(R2) = w;
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Switch when2: not const: #");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L6021:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6019:
	asu64(R1) = w;
	if (asu64(R1)) goto L6018;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6016:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6015;
	asi64(R1) = maxlab;
	asi64(R2) = minlab;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1000;
	if (asi64(R1) <= asi64(R2)) goto L6030;
	R1 = 0;
	R2 = tou64("Switch too big");
	mm_support_gerror(asu64(R2), asu64(R1));
L6030:
	asu8(R1) = looptype;
	if (!asu8(R1)) goto L6032;
	asi64(R1) = mm_genpcl_definelabel();
	lab_a = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_a;
	asi64(R3) = lab_a;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L6031;
L6032:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
L6031:
	asi64(R1) = mm_genpcl_createfwdlabel();
	labjump = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	elselab = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6034;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6034:
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6036;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pjump = asu64(R1);
	asu64(R1) = pjump;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6038;
	R1 = 0;
	R2 = tou64("doswx not name");
	mm_support_gerror(asu64(R2), asu64(R1));
L6038:
	asu64(R1) = pjump;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	djump = asu64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = djump;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6040;
	R1 = 0;
	R2 = tou64("doswx not ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L6040:
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pc_api_pccurr;
	psetup = asu64(R1);
	asu64(R1) = pjump;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = mm_genpcl_pcldoswx;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6042;
	R1 = 0;
	R2 = tou64("doswx in main?");
	mm_support_gerror(asu64(R2), asu64(R1));
L6042:
	asu64(R1) = psetup;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = mm_genpcl_pcldoswx;
	*(struct $B17*)(R2) = (R1_B17);
	asu64(R1) = psetup;
	R2 = 1;
	R1 += (i64)R2*32;
	(R1_B17) = *(struct $B17*)(R1);
	asu64(R2) = mm_genpcl_pcldoswx;
	R3 = 1;
	R2 += (i64)R3*32;
	*(struct $B17*)(R2) = (R1_B17);
	R1 = 2;
	R2 = (u64)&pc_api_pccurr;
	*tou64p(R2) -= asu64(R1)*32;
L6036:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6044;
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L6046;
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L6046:
	goto L6043;
L6044:
	R1 = tou64("J1");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L6043:
	asi64(R1) = labjump;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = minlab;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = maxlab;
	if (asi64(R1) > asi64(R2)) goto L6049;
L6047:
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= maxlab) goto L6047;
L6049:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L6051;
L6050:
	asi64(R1) = mm_genpcl_definelabel();
	labstmt = asi64(R1);
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6054;
L6053:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6057;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6058;
	goto L6059;
L6057:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
	goto L6056;
L6058:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L6056;
L6059:
L6056:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L6062;
L6060:
	asi64(R1) = labstmt;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	i += 1; if (i <= bx) goto L6060;
L6062:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6054:
	asu64(R1) = w;
	if (asu64(R1)) goto L6053;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6064;
	R1 = 0;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6063;
L6064:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
L6063:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6066;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6066:
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6068;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6069;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6070;
	goto L6071;
L6068:
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6067;
L6069:
	asi64(R1) = lab_a;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6067;
L6070:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L6067;
L6071:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("J2");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L6067:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6051:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6050;
	asi64(R1) = elselab;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L6073;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6075;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6074;
L6075:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L6074:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6077;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6077:
L6073:
	asu8(R1) = looptype;
	if (!asu8(R1)) goto L6079;
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6081;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6082;
	goto L6083;
L6081:
	asi64(R1) = lab_a;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6080;
L6082:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L6080;
L6083:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("J3");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L6080:
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
L6079:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_select(u64 p, u64 a, u64 b, u64 c, i64 isref) {
    u64 R1, R2, R3, R4; 
	struct $B96 labels;
	i64 labend;
	i64 labjump;
	i64 n;
	i64 i;
	i64 elselab;
	i64 labstmt;
	i64 ismult;
	u64 q;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6085;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6085;
	R1 = 1;
	goto L6086;
L6085:
	R1 = 0;
L6086:
	ismult = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L6088;
L6087:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L6091;
	R1 = 0;
	R2 = tou64("selectx: too many labels");
	mm_support_gerror(asu64(R2), asu64(R1));
L6091:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6088:
	asu64(R1) = q;
	if (asu64(R1)) goto L6087;
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labjump = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	elselab = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6093;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6093:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = n;
	R3 = 1;
	R4 = 37;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labjump;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6096;
L6094:
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L6094;
L6096:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	goto L6098;
L6097:
	asi64(R1) = mm_genpcl_definelabel();
	labstmt = asi64(R1);
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asi64(R1) = labstmt;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6101;
	R1 = 0;
	asu64(R2) = q;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6100;
L6101:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
L6100:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6103;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6103:
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6098:
	asu64(R1) = q;
	if (asu64(R1)) goto L6097;
	asi64(R1) = elselab;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6105;
	R1 = 0;
	asu64(R2) = c;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6104;
L6105:
	asu64(R1) = c;
	mm_blockpcl_evalunit(asu64(R1));
L6104:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6107;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6107:
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_case(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 loopsw, i64 isref) {
    u64 R1, R2, R3, R4; 
	struct $B44 labtable;
	struct $B44 unittable;
	i64 ncases;
	i64 ismult;
	i64 a;
	i64 b;
	i64 lab_abc;
	i64 lab_d;
	i64 labelse;
	u64 w;
	u64 wt;
	u64 plower;
	u64 pupper;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 106;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	loopsw = asi64(R1);
	asu64(R1) = pindex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6110;
	R1 = 0;
	R2 = tou64("EMPTY CASE NOT DONE");
	mm_support_gerror(asu64(R2), asu64(R1));
L6110:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6111;
	asi64(R1) = loopsw;
	if (asi64(R1)) goto L6111;
	R1 = 1;
	goto L6112;
L6111:
	R1 = 0;
L6112:
	ismult = asi64(R1);
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L6114;
	asi64(R1) = mm_genpcl_definelabel();
	lab_abc = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_abc;
	asi64(R3) = lab_abc;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L6113;
L6114:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
L6113:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6116;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6116:
	R1 = 0;
	ncases = asi64(R1);
	asi64(R1) = mm_blockpcl_casedepth;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L6118;
	R1 = 0;
	R2 = tou64("case nested too deeply");
	mm_support_gerror(asu64(R2), asu64(R1));
L6118:
	asu64(R1) = p;
	R2 = (u64)&mm_blockpcl_casestmt;
	R3 = (u64)&mm_blockpcl_casedepth;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pwhenthen;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6120;
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6122;
	R1 = 0;
	R2 = tou64("case");
	mm_support_gerror(asu64(R2), asu64(R1));
L6122:
	goto L6123;
L6120:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L6125;
L6124:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asi64(R1) = ncases;
	R2 = 500;
	if (asi64(R1) < asi64(R2)) goto L6128;
	R1 = 0;
	R2 = tou64("too many cases");
	mm_support_gerror(asu64(R2), asu64(R1));
L6128:
	asi64(R1) = mm_genpcl_createfwdlabel();
	R2 = (u64)&labtable;
	R3 = (u64)&ncases;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&unittable;
	asi64(R3) = ncases;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6130;
L6129:
	asu64(R1) = w;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&labtable;
	asi64(R2) = ncases;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	asu64(R3) = w;
	R4 = 40;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L6134;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6133;
L6134:
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6133:
	asu64(R1) = w;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6130:
	asu64(R1) = w;
	if (asu64(R1)) goto L6129;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6125:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6124;
// mm_blockpcl.do_case.skip:
L6123:
	asi64(R1) = mm_genpcl_createfwdlabel();
	labelse = asi64(R1);
	asi64(R1) = labelse;
	R2 = (u64)&mm_blockpcl_caseelse;
	asi64(R3) = mm_blockpcl_casedepth;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = labelse;
	mm_blockpcl_genjumpl(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6137;
L6135:
	R1 = (u64)&labtable;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6139;
	R1 = 0;
	R2 = (u64)&unittable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6138;
L6139:
	R1 = (u64)&unittable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_evalunit(asu64(R1));
L6138:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6141;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6141:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L6143;
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6142;
L6143:
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
L6142:
	i += 1; if (i <= ncases) goto L6135;
L6137:
	asi64(R1) = labelse;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L6145;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L6147;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L6146;
L6147:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L6146:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L6149;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L6149:
L6145:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L6151;
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	goto L6150;
L6151:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
L6150:
	R1 = (u64)&mm_blockpcl_casedepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_dotindex(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 14;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_dotslice(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 15;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_read(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 m;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6156;
	asu64(R1) = mm_genpcl_pzero;
	a = asu64(R1);
L6156:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6158;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 23;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6157;
L6158:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6159;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L6159;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 24;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6157;
L6159:
	asi64(R1) = m;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6160;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 25;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6157;
L6160:
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(M)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("CAN'T READ THIS ITEM");
	mm_support_gerror(asu64(R2), asu64(R1));
L6157:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_readln(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L6163;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6165;
	R1 = 0;
	R2 = tou64("@dev no ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L6165:
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6167;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6168;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6168;
	goto L6169;
L6167:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 26;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6166;
L6168:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 27;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L6166;
L6169:
	R1 = 0;
	R2 = tou64("rd@dev?");
	mm_support_gerror(asu64(R2), asu64(R1));
L6166:
	goto L6162;
L6163:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 28;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L6162:
	return;
}

static void mm_blockpcl_docond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = lab;
	asu64(R2) = p;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_blockpcl_do_syscall(u64 p, u64 a) {
    u64 R1, R2, R3; 
	mm_genpcl_setfunctab();
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L6173;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L6174;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L6175;
	goto L6176;
L6173:
	asu64(R1) = mm_blockpcl_pnprocs;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6172;
L6174:
	asu64(R1) = mm_blockpcl_pprocname;
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = -8;
	R2 = 8;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L6172;
L6175:
	asu64(R1) = mm_blockpcl_pprocaddr;
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = -8;
	R2 = 8;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L6172;
L6176:
	R1 = tou64("SYSCALL/GENERIC");
	pc_api_gencomment(asu64(R1));
L6172:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_slice(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6179;
	asu64(R1) = a;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6181;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	mm_genpcl_genpushint(asi64(R1));
	goto L6180;
L6181:
	R1 = (u64)&mm_decls_ttlength;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_genpcl_genpushint(asi64(R1));
L6180:
	goto L6178;
L6179:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	mm_blockpcl_do_indexref(asu64(R2), asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6183;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6183;
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	mm_genpcl_genpushint(asi64(R1));
	goto L6182;
L6183:
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 44;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 43;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L6182:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L6178:
	R1 = 0;
	R2 = 7;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_assignblock(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6186;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6188;
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignarray(asu64(R2), asu64(R1));
	goto L6187;
L6188:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignrecord(asu64(R2), asu64(R1));
L6187:
	goto L6185;
L6186:
	R1 = 0;
	R2 = tou64("ASSIGN BLOCK");
	mm_support_gerror(asu64(R2), asu64(R1));
L6185:
	return;
}

static void mm_blockpcl_do_assignarray(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 passign;
	u64 pindex;
	u64 pconst;
	u64 q;
	i64 index;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6191;
	R1 = 0;
	R2 = tou64("Assignment not suitable for []char type");
	mm_support_gerror(asu64(R2), asu64(R1));
L6191:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pconst = asu64(R1);
	asu64(R1) = pconst;
	asu64(R2) = a;
	R3 = 46;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pindex = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pindex;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	asu64(R3) = pindex;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	index = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6193;
L6192:
	asi64(R1) = index;
	asu64(R2) = pconst;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = pconst;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	asu64(R2) = passign;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&index;
	(*toi64p(R1)) += 1;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6193:
	asu64(R1) = q;
	if (asu64(R1)) goto L6192;
	return;
}

static void mm_blockpcl_do_assignrecord(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 passign;
	u64 pdot;
	u64 pfield;
	u64 q;
	i64 m;
	i64 fieldtype;
	u64 d;
	u64 e;
	R1 = 4;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	pfield = asu64(R1);
	asu64(R1) = pfield;
	asu64(R2) = a;
	R3 = 49;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pdot = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pdot;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	asu64(R3) = pdot;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6197;
L6196:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6200;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6200;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	fieldtype = asi64(R1);
	asu64(R1) = e;
	asu64(R2) = pfield;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = fieldtype;
	R2 = R1;
	asu64(R3) = pdot;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	R2 = R1;
	asu64(R3) = pfield;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = passign;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pdot;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6200:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L6197:
	asu64(R1) = e;
	if (asu64(R1)) goto L6196;
	return;
}

static void mm_blockpcl_pushrhs(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6203;
	goto L6201;
L6203:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_pushrhs(asu64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
L6201:
	return;
}

static void mm_blockpcl_do_assignms(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 nlhs;
	i64 nrhs;
	u64 d;
	i64 i;
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	nlhs = asi64(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L6206;
	goto L6207;
L6206:
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6209;
	R1 = 0;
	R2 = tou64("multassign from fn: not simple fn");
	mm_support_gerror(asu64(R2), asu64(R1));
L6209:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nrhs = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L6205;
L6207:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6211;
	R1 = 0;
	R2 = tou64("DECONSTR SLICE NOT READY");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L6210;
L6211:
	R1 = 0;
	R2 = tou64("(a,b):=x; var only");
	mm_support_gerror(asu64(R2), asu64(R1));
L6210:
L6205:
	asu64(R1) = a;
	mm_blockpcl_poptomult(asu64(R1));
	asi64(R1) = nrhs;
	asi64(R2) = nlhs;
	if (asi64(R1) <= asi64(R2)) goto L6213;
	asu64(R1) = b;
	asu64(R1) = mm_lib_getprocretmodes(asu64(R1));
	d = asu64(R1);
	asi64(R1) = nlhs;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nrhs;
	if (asi64(R1) > asi64(R2)) goto L6216;
L6214:
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nrhs) goto L6214;
L6216:
L6213:
	return;
}

static void mm_blockpcl_do_assignmm(u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_pushrhs(asu64(R1));
	R1 = 0;
	R2 = 133;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_poptomult(asu64(R1));
	return;
}

static void mm_blockpcl_do_assignmdrem(u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_poptomult(asu64(R1));
	return;
}

static void mm_blockpcl_poptomult(u64 a) {
    u64 R1, R2, R3; 
L6220:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6224;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L6225;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L6225;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6225;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6226;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6227;
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L6227;
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L6227;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L6227;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L6228;
	goto L6229;
L6224:
	asu64(R1) = a;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6223;
L6225:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6223;
L6226:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6223;
L6227:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6223;
L6228:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 16;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L6223;
L6229:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Bad mult assign element");
	mm_support_gerror(asu64(R2), asu64(R1));
L6223:
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6220;
	return;
}

static void mm_blockpcl_do_recase(u64 p, u64 a) {
    u64 R1, R2, R3; 
	u64 q;
	u64 wt;
	u64 w;
	i64 destlab;
	i64 casevalue;
	asi64(R1) = mm_blockpcl_casedepth;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6232;
	R1 = 0;
	R2 = tou64("recase outside case stmt");
	mm_support_gerror(asu64(R2), asu64(R1));
L6232:
	asu64(R1) = a;
	if (!asu64(R1)) goto L6234;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	casevalue = asi64(R1);
	goto L6233;
L6234:
	R1 = (u64)&mm_blockpcl_caseelse;
	asi64(R2) = mm_blockpcl_casedepth;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_genjumpl(asi64(R1));
L6233:
	R1 = (u64)&mm_blockpcl_casestmt;
	asi64(R2) = mm_blockpcl_casedepth;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	destlab = asi64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
	goto L6236;
L6235:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6239;
L6238:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6242;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = w;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6242;
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = casevalue;
	if (asi64(R1) != asi64(R2)) goto L6242;
	asu64(R1) = w;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	destlab = asi64(R1);
	goto L6237;
L6242:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6239:
	asu64(R1) = w;
	if (asu64(R1)) goto L6238;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6236:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6235;
L6237:
	asi64(R1) = destlab;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6244;
	R1 = (u64)&mm_blockpcl_caseelse;
	asi64(R2) = mm_blockpcl_casedepth;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_genjumpl(asi64(R1));
	goto L6243;
L6244:
	asi64(R1) = destlab;
	mm_blockpcl_genjumpl(asi64(R1));
L6243:
	return;
}

static void mm_blockpcl_do_empty(u64 p, u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 41;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_typeconst(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	return;
}

static void mm_blockpcl_do_setinplace() {
    u64 R1, R2, R3; 
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6249;
	asu64(R1) = pc_api_pccurr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6249;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6249:
	return;
}

static u64 mm_assem_readassemline() {
    u64 R1; 
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_assem_assembleline(asi64(R1));
	goto L6250;
L6250:
	return asu64(R1);
}

static u64 mm_assem_readassemblock() {
    u64 R1, R2, R3, R4, R5; 
	u64 ulist;
	u64 ulistx;
	u64 u;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L6252:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6255;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L6256;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6257;
	goto L6258;
L6255:
	R1 = tou64("EOF: 'End' missing in Assembler code");
	mm_support_serror(asu64(R1));
	goto L6254;
L6256:
	R1 = 0;
	R2 = 0;
	R3 = 135;
	R4 = (u64)&mm_decls_lx;
	R5 = 0;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L6253;
	goto L6254;
L6257:
	goto L6254;
L6258:
	R1 = 0;
	asu64(R1) = mm_assem_assembleline(asi64(R1));
	u = asu64(R1);
	asu64(R1) = u;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L6254:
	goto L6252;
L6253:
	asu64(R1) = ulist;
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	goto L6251;
L6251:
	return asu64(R1);
}

static u64 mm_assem_assembleline(i64 oneline) {
    u64 R1, R2, R3; 
	u64 dlist;
	u64 dlistx;
	u64 p;
	u64 pname;
	u64 q;
	i64 opc;
	i64 noperands;
	u64 stname;
	R1 = 0;
	R2 = R1;
	dlistx = asu64(R2);
	dlist = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6261;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6261;
	R1 = 100;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 14;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = mm_decls_currproc;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = mm_decls_currproc;
	mm_lib_adddef(asu64(R2), asu64(R1));
	mm_lex_lex();
	asi64(R1) = oneline;
	if (!asi64(R1)) goto L6263;
	mm_lex_lex();
L6263:
	asu64(R1) = p;
	goto L6259;
	goto L6260;
L6261:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L6264;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_createname(asu64(R1));
	pname = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = pname;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6266;
L6267:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&dlistx;
	R3 = (u64)&dlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6271;
	mm_lex_lex();
L6271:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6272;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L6267;
L6272:
L6266:
	asu64(R1) = dlist;
	asu64(R2) = pname;
	R3 = 9;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L6259;
L6264:
L6260:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L6274;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6275;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6276;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L6277;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L6278;
	goto L6279;
L6274:
	R1 = 38;
	opc = asi64(R1);
// mm_assem.assembleline.doop:
L6280:
	R1 = 8;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	goto L6273;
L6275:
	R1 = 39;
	opc = asi64(R1);
	goto L6280;
	goto L6273;
L6276:
	R1 = 40;
	opc = asi64(R1);
	goto L6280;
	goto L6273;
L6277:
	R1 = 51;
	opc = asi64(R1);
	goto L6280;
	goto L6273;
L6278:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6282;
	R1 = 29;
	opc = asi64(R1);
	goto L6280;
L6282:
	goto L6283;
	goto L6273;
L6279:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6285;
	R1 = 8;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L6287;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L6288;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L6289;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L6290;
	goto L6291;
L6287:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6286;
L6288:
	R1 = 26;
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6286;
L6289:
	R1 = 58;
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6286;
L6290:
	R1 = 15;
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6286;
L6291:
	R1 = tou64("ASM");
	mm_lex_ps(asu64(R1));
	R1 = tou64("x64 op expected");
	mm_support_serror(asu64(R1));
L6286:
	mm_lex_lex();
	goto L6284;
L6285:
// mm_assem.assembleline.$else:
L6283:
	R1 = tou64("ASM");
	mm_lex_ps(asu64(R1));
	R1 = tou64("ASM???");
	mm_support_serror(asu64(R1));
L6284:
L6273:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6293;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6293;
	R1 = 0;
	noperands = asi64(R1);
L6294:
	asu64(R1) = mm_assem_readassemopnd();
	q = asu64(R1);
	R1 = (u64)&noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L6297;
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6296;
L6297:
	R1 = tou64("Too many asm opnds");
	mm_support_serror(asu64(R1));
L6296:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6299;
	goto L6295;
	goto L6298;
L6299:
	mm_lex_lex();
L6298:
	goto L6294;
L6295:
L6293:
	R1 = 4;
	mm_parse_checksymbol(asi64(R1));
	asu64(R1) = p;
	goto L6259;
L6259:
	return asu64(R1);
}

static u64 mm_assem_readassemopnd() {
    u64 R1, R2, R3; 
	u64 p;
	i64 reg;
	i64 regix;
	i64 scale;
	i64 prefixmode;
	u64 pcode;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6302;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6302;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6303;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6304;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6304;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L6305;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6306;
	goto L6307;
L6302:
	asu64(R1) = mm_parse_readunit();
	goto L6300;
	goto L6301;
L6303:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6309;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L6310;
	goto L6311;
L6309:
	R1 = 10;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 164;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L6300;
	goto L6308;
L6310:
	R1 = 11;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L6300;
	goto L6308;
L6311:
L6308:
	asu64(R1) = mm_parse_readunit();
	goto L6300;
	goto L6301;
L6304:
	asu64(R1) = mm_parse_readunit();
	goto L6300;
	goto L6301;
L6305:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6313;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6313;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6313;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6313;
	goto L6314;
L6313:
	goto L6312;
L6314:
	R1 = tou64("Bad prefix");
	mm_support_serror(asu64(R1));
L6312:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	prefixmode = asi64(R1);
	R1 = 11;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L6315;
	goto L6301;
L6306:
	R1 = 0;
	prefixmode = asi64(R1);
// mm_assem.readassemopnd.gotprefix:
L6315:
	R1 = 0;
	R2 = R1;
	regix = asi64(R2);
	reg = asi64(R1);
	R1 = 0;
	pcode = asu64(R1);
	R1 = 1;
	scale = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6317;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L6317;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	reg = asi64(R1);
	mm_lex_lex();
L6317:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L6319;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6319;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L6319;
	mm_lex_lex();
L6319:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6321;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L6321;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	regix = asi64(R1);
	mm_lex_lex();
L6321:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L6323;
	R1 = 62;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	scale = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6325;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6325;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6325;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6325;
	goto L6326;
L6325:
	goto L6324;
L6326:
	R1 = tou64("Bad scale");
	mm_support_serror(asu64(R1));
L6324:
	mm_lex_lex();
L6323:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6328;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6328;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6328;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6328;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6328;
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L6328;
	goto L6329;
L6328:
	asu64(R1) = mm_parse_readunit();
	pcode = asu64(R1);
	goto L6327;
L6329:
L6327:
	R1 = 12;
	mm_parse_checksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = pcode;
	R2 = 12;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6331;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6331;
	asi64(R1) = reg;
	regix = asi64(R1);
	R1 = 0;
	reg = asi64(R1);
L6331:
	asu64(R1) = pcode;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6333;
	asi64(R1) = reg;
	asi64(R2) = regix;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6333;
	R1 = tou64("Empty []");
	mm_support_serror(asu64(R1));
L6333:
	asi64(R1) = reg;
	asu64(R2) = p;
	R3 = 40;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = regix;
	asu64(R2) = p;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 42;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = prefixmode;
	asu64(R2) = p;
	R3 = 43;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L6300;
	goto L6301;
L6307:
	R1 = tou64("BAD OPND");
	mm_lex_ps(asu64(R1));
	R1 = tou64("ASM: Bad operand?");
	mm_support_serror(asu64(R1));
L6301:
	R1 = 0;
	goto L6300;
L6300:
	return asu64(R1);
}

static void mm_assem_initassemsymbols() {
    u64 R1, R2, R3, R4, R5; 
	struct $B17 str;
	i64 i;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	i64 av_6;
	i64 av_7;
	i64 av_8;
	i64 av_9;
	i64 av_10;
// PROC LOCAL STATICS GO HERE
	static struct $B12 mm_assem_initassemsymbols_regnames = {{
	(u64)"aframe",
	(u64)"dframe",
	(u64)"astack",
	(u64)"dstack",
	(u64)"dprog",
	(u64)"dsptr"    }};
	static struct $B26 mm_assem_initassemsymbols_regnos = {{
3855,
	4112,
	2569    }};
	static struct $B26 mm_assem_initassemsymbols_sizes = {{
2052,
	2052,
	2056    }};
	R1 = 1;
	i = asi64(R1);
	R1 = 151;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6337;
L6335:
	R1 = 0;
	asi64(R2) = i;
	R3 = 78;
	R4 = (u64)&mc_decls_mclnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	R5 = 2;
	R4 += (i64)R5;
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L6335;
L6337:
	R1 = 1;
	i = asi64(R1);
	R1 = 137;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6340;
L6338:
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_regindices;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 70;
	R4 = (u64)&mc_decls_dregnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_2) goto L6338;
L6340:
	R1 = 1;
	i = asi64(R1);
	R1 = 16;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6343;
L6341:
	R1 = 0;
	asi64(R2) = i;
	R3 = 71;
	R4 = (u64)&mc_decls_xmmregnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_3) goto L6341;
L6343:
	R1 = 1;
	i = asi64(R1);
	R1 = 8;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6346;
L6344:
	R1 = 0;
	asi64(R2) = i;
	R3 = 72;
	R4 = (u64)&mc_decls_fregnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_4) goto L6344;
L6346:
	R1 = 1;
	i = asi64(R1);
	R1 = 8;
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6349;
L6347:
	R1 = 0;
	asi64(R2) = i;
	R3 = 73;
	R4 = (u64)&mc_decls_mregnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_5) goto L6347;
L6349:
	R1 = 1;
	i = asi64(R1);
	R1 = 18;
	av_6 = asi64(R1);
	asi64(R1) = av_6;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6352;
L6350:
	R1 = 0;
	R2 = (u64)&mc_decls_jmpcccodes;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 74;
	R4 = (u64)&mc_decls_jmpccnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_6) goto L6350;
L6352:
	R1 = 1;
	i = asi64(R1);
	R1 = 16;
	av_7 = asi64(R1);
	asi64(R1) = av_7;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6355;
L6353:
	R1 = 0;
	R2 = (u64)&mc_decls_setcccodes;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 75;
	R4 = (u64)&mc_decls_setccnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_7) goto L6353;
L6355:
	R1 = 1;
	i = asi64(R1);
	R1 = 16;
	av_8 = asi64(R1);
	asi64(R1) = av_8;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6358;
L6356:
	R1 = 0;
	R2 = (u64)&mc_decls_cmovcccodes;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 76;
	R4 = (u64)&mc_decls_cmovccnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_8) goto L6356;
L6358:
	R1 = 1;
	i = asi64(R1);
	R1 = 5;
	av_9 = asi64(R1);
	asi64(R1) = av_9;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6361;
L6359:
	R1 = (u64)&mc_decls_segmentnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&str;
	asi64(R3) = strlen(asu64(R3));
	*tou8p(((i64)R2+(i64)R3-4)) = asu8(R1);
	R1 = 0;
	asi64(R2) = i;
	R3 = 77;
	R4 = (u64)&str;
	asu64(R4) = mlib_pcm_copyheapstring(asu64(R4));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_9) goto L6359;
L6361:
	R1 = 1;
	i = asi64(R1);
	R1 = 6;
	av_10 = asi64(R1);
	asi64(R1) = av_10;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6364;
L6362:
	R1 = (u64)&mm_assem_initassemsymbols_sizes;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_assem_initassemsymbols_regnos;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 70;
	R4 = (u64)&mm_assem_initassemsymbols_regnames;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	mm_lex_addreservedword(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_10) goto L6362;
L6364:
	return;
}

static void mm_assemaux_domcl_assem(u64 pcode) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pcode;
	if (!asu64(R1)) goto L6368;
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6367;
L6368:
	goto L6365;
L6367:
	asu64(R1) = pcode;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_assemaux_genasmopnd(asu64(R1));
	asu64(R2) = pcode;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mm_assemaux_genasmopnd(asu64(R2));
	asu64(R3) = pcode;
	R4 = 40;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pcode;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_mccodex;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pcode;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6370;
	R2 = 93;
	if (asi64(R1) == asi64(R2)) goto L6370;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6370;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6370;
	goto L6371;
L6370:
	asu64(R1) = pcode;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L6374;
	asu64(R1) = pcode;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6373;
L6374:
	R1 = 0;
	R2 = tou64("pcmpistr/no imm");
	mm_support_gerror(asu64(R2), asu64(R1));
L6373:
	asu64(R1) = pcode;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_mccodex;
	R3 = 32;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6369;
L6371:
L6369:
L6365:
	return;
}

static u64 mm_assemaux_genasmopnd(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 ax;
	u64 d;
	i64 offset;
	i64 labno;
	u64 a;
	u64 x;
	u64 y;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6377;
	R1 = 0;
	goto L6375;
L6377:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6379;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6380;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6381;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6382;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6383;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6384;
	goto L6385;
L6379:
	R1 = (u64)&mc_decls_regmodes;
	asu64(R2) = p;
	R3 = 44;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L6378;
L6380:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L6378;
L6381:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	d = asu64(R1);
	R1 = 0;
	R2 = R1;
	labno = asi64(R2);
	offset = asi64(R1);
	asu64(R1) = a;
	if (!asu64(R1)) goto L6387;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6389;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6390;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6391;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6392;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L6393;
	goto L6394;
L6389:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	offset = asi64(R1);
	goto L6388;
L6390:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6396;
	asu64(R1) = d;
	asi64(R1) = mm_assemaux_fixasmlabel(asu64(R1));
	labno = asi64(R1);
	R1 = 0;
	d = asu64(R1);
L6396:
	goto L6388;
L6391:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6398;
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6398;
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6400;
	asu64(R1) = d;
	asi64(R1) = mm_assemaux_fixasmlabel(asu64(R1));
	labno = asi64(R1);
	R1 = 0;
	d = asu64(R1);
L6400:
	goto L6397;
L6398:
	goto L6401;
L6397:
	asu64(R1) = a;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6404;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L6403;
L6404:
	asu64(R1) = y;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6402;
L6403:
	asu64(R1) = y;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
L6402:
	offset = asi64(R1);
	goto L6388;
L6392:
	asu64(R1) = a;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6406;
	R1 = tou64("");
	R2 = tou64("assume/unary");
	pc_api_merror(asu64(R2), asu64(R1));
L6406:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6408;
	R1 = 0;
	R2 = tou64("-name");
	mm_support_gerror(asu64(R2), asu64(R1));
L6408:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	offset = asi64(R1);
	goto L6388;
L6393:
	R1 = tou64("");
	R2 = tou64("ASSEM/SYSFN?");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L6388;
L6394:
// mm_assemaux.genasmopnd.error:
L6401:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Can't do memexpr");
	mm_support_gerror(asu64(R2), asu64(R1));
L6388:
L6387:
	asu64(R1) = d;
	asi64(R2) = labno;
	R3 = (u64)&mm_decls_ttsize;
	asu64(R4) = p;
	R5 = 43;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu32(R3) = *tou32p(((i64)R3+(i64)R4*4));
	R3 = toi64(tou32(R3));
	asi64(R4) = offset;
	asu64(R5) = p;
	R6 = 42;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asu64(R6) = p;
	R7 = 41;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = p;
	R8 = 40;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	goto L6378;
L6382:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6410;
	asu64(R1) = d;
	asi64(R1) = mm_assemaux_fixasmlabel(asu64(R1));
	labno = asi64(R1);
	asi64(R1) = labno;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L6409;
L6410:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
L6409:
	goto L6378;
L6383:
	R1 = 8;
	asu64(R2) = p;
	R3 = 40;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L6378;
L6384:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6412;
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6412;
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6415;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L6414;
L6415:
	asu64(R1) = y;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6413;
L6414:
	asu64(R1) = y;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
L6413:
	offset = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6417;
	asu64(R1) = d;
	asi64(R1) = mm_assemaux_fixasmlabel(asu64(R1));
	labno = asi64(R1);
	asi64(R1) = labno;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L6416;
L6417:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
L6416:
	asi64(R1) = offset;
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6411;
L6412:
	R1 = 0;
	R2 = tou64("ax:imm/add");
	mm_support_gerror(asu64(R2), asu64(R1));
L6411:
	goto L6378;
L6385:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("genasmopnd?");
	mm_support_gerror(asu64(R2), asu64(R1));
L6378:
	asu64(R1) = ax;
	goto L6375;
L6375:
	return asu64(R1);
}

static i64 mm_assemaux_fixasmlabel(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 100;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6420;
	R1 = 0;
	R2 = tou64("FIXASMLABEL: zero");
	mm_support_gerror(asu64(R2), asu64(R1));
L6420:
	asu64(R1) = d;
	R2 = 100;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L6418;
L6418:
	return asi64(R1);
}

static i64 mm_assemaux_checkasmlabel(u64 p) {
    u64 R1, R2; 
	u64 q;
	u64 d;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L6423;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6423;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6425;
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L6421;
L6425:
L6423:
	R1 = 0;
	goto L6421;
L6421:
	return asi64(R1);
}

static void mm_diags_printst(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = level;
	asu64(R2) = p;
	asu64(R3) = f;
	mm_diags_printstrec(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6428;
L6427:
	asi64(R1) = level;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	asu64(R3) = f;
	mm_diags_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6428:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6427;
	return;
}

static void mm_diags_printstrec(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3, R4, R5; struct $B86 R1_B86; 
	struct $B86 dd;
	u64 q;
	struct $B3 v;
	u64 d;
	i64 col;
	i64 offset;
	i64 n;
	struct $B16 str;
	i64 av_1;
	R1 = (u64)&v;
	d = asu64(R1);
	asu64(R1) = d;
	mlib_gs_init(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6433;
L6431:
	R1 = tou64("    ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L6431;
L6433:
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 45;
	R2 = 28;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 46;
	R2 = 12;
	R3 = (u64)&mm_tables_namenames;
	asu64(R4) = p;
	R5 = 78;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	asi64(R1) = mlib_gs_getcol(asu64(R1));
	col = asi64(R1);
	asu64(R1) = p;
	(R1_B86) = *(struct $B86*)(R1);
	dd = (R1_B86);
	R1 = tou64("[");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6435;
	R1 = tou64("Imp ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6434;
L6435:
	R1 = (u64)&mm_tables_scopenames;
	asu64(R2) = p;
	R3 = 170;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6434:
	R1 = (u64)&dd;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6437;
	R1 = tou64("Stat");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6437:
	R1 = (u64)&dd;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6439;
	R1 = (u64)&dd;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6439;
	R1 = (u64)&mm_tables_parammodenames;
	R2 = (u64)&dd;
	R3 = 160;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6439:
	R1 = (u64)&dd;
	R2 = 149;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6441;
	R1 = tou64("@@");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&dd;
	R2 = 149;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" maxalign:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&dd;
	R2 = 166;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6441:
	R1 = (u64)&dd;
	R2 = 161;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6443;
	R1 = tou64("Opt ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6443:
	R1 = (u64)&dd;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6445;
	R1 = tou64("Var:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&dd;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6445:
	R1 = (u64)&dd;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6447;
	R1 = (u64)&dd;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6449;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Modno#");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&dd;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6448;
L6449:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Subno#");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&dd;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6448:
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6447:
	R1 = (u64)&dd;
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L6451;
	R1 = tou64("U ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6451:
	R1 = (u64)&dd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6453;
	R1 = tou64("Threaded ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6453:
	R1 = tou64("]");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 61;
	asi64(R2) = col;
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R3) = d;
	mlib_gs_padto(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6455;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 45;
	R2 = 18;
	R3 = (u64)&str;
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6454;
L6455:
	R1 = 45;
	R2 = 18;
	R3 = tou64("()");
	asu64(R4) = d;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L6454:
	asu64(R1) = p;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6457;
	goto L6458;
L6457:
	R1 = tou64("Void ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	goto L6456;
L6458:
	asu64(R1) = p;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6456:
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6460;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6460;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6461;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6462;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6463;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6464;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6465;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6466;
	goto L6467;
L6460:
	R1 = tou64(" Offset:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6469;
	R1 = tou64(" Bitoffset:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 150;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(":");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 148;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
L6469:
	asu64(R1) = p;
	R2 = 136;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 143;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = tou64("%.*s");
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("v");
	asu64(R2) = p;
	R3 = 143;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64(".*");
	asu64(R2) = p;
	R3 = 136;
	R2 += (i64)R3;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = tou64(" UFLAGS:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("-");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 143;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6471;
	R1 = tou64("/:=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6471:
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6473;
	asu64(R1) = p;
	R2 = 162;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6473;
	R1 = tou64("...");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6473:
	goto L6459;
L6461:
	R1 = tou64("Index:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	R1 = tou64(" Nret:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	goto L6459;
L6462:
	R1 = tou64("Index/PCaddr:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6475;
	R1 = tou64(" Truename:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6475:
	goto L6459;
L6463:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6477;
	R1 = tou64("=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6477:
	goto L6459;
L6464:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6479;
	R1 = tou64(":=");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6479:
	goto L6459;
L6465:
	R1 = tou64("Const:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
	goto L6459;
L6466:
	asu64(R1) = p;
	R2 = 144;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6481;
	R1 = tou64("Baseclass:");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64("<HAS BASECLASS>");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
L6481:
	goto L6459;
L6467:
L6459:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6483;
	R1 = tou64(" @");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" +");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 151;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	mlib_gs_strint(asu64(R2), asi64(R1));
L6483:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6485;
	asu64(R1) = p;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	asu64(R2) = d;
	mlib_gs_strvar(asu64(R2), asu64(R1));
L6485:
	R1 = tou64(" Lineno: ???");
	asu64(R2) = d;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6487;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6487;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6487;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6487;
	goto L6488;
L6487:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6490;
	asu64(R1) = f;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
L6490:
	goto L6486;
L6488:
L6486:
	return;
}

static void mm_diags_printstflat(u64 f) {
    u64 R1, R2, R3; 
	u64 p;
	i64 av_1;
	i64 i;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("GLOBAL SYMBOL TABLE:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	i = asi64(R1);
	R1 = 65534;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6494;
L6492:
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6496;
	goto L6493;
L6496:
	asu64(R1) = p;
	R2 = 77;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6498;
	goto L6499;
L6498:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("5");
	asi64(R2) = i;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	asu64(R2) = p;
	R3 = 77;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = p;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L6501;
L6500:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("     ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	asu64(R2) = p;
	R3 = 77;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = p;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6504;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" (From #:#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6504:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6501:
	asu64(R1) = p;
	if (asu64(R1)) goto L6500;
	goto L6497;
L6499:
L6497:
L6493:
	i += 1; if (i <= av_1) goto L6492;
L6494:
	return;
}

static void mm_diags_printcode(u64 f, u64 caption) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 pp;
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L6507;
L6506:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L6512;
	case 2: goto L6513;
	case 3: goto L6514;
	default: goto L6511;
    };
// SWITCH
L6512:
	R1 = tou64("Sub");
	goto L6509;
L6513:
	R1 = tou64("Prog");
	goto L6509;
L6514:
	R1 = tou64("Exp");
	goto L6509;
L6511:
	R1 = tou64("Mod");
L6509:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6516;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" in record");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6516:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	R2 = tou64("1");
	R3 = 0;
	asu64(R4) = p;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L6507:
	asu64(R1) = pp;
	if (asu64(R1)) goto L6506;
	return;
}

static void mm_diags_printunit(u64 p, i64 level, u64 prefix, u64 dev) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	i64 t;
	u64 idname;
	i64 a;
	r32 x32;
	i64 av_1;
	i64 av_2;
	i64 i;
// PROC LOCAL STATICS GO HERE
	static i64 mm_diags_printunit_cmpchain = 0;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6519;
	goto L6517;
L6519:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	if (!asu32(R1)) goto L6521;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	mm_diags_currlineno = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	mm_diags_currfileno = asi64(R1);
L6521:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = prefix;
	asi64(R3) = level;
	asu64(R1) = mm_diags_getprefix(asi64(R3), asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	idname = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = idname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6523;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L6524;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6525;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6526;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6527;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L6528;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L6529;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6529;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6530;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6531;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L6532;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6532;
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L6533;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L6533;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L6533;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L6534;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6535;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6536;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6537;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6538;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L6539;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6540;
	goto L6541;
L6523:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6543;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" {");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("}");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6543:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = d;
	asu64(R1) = mm_lib_getdottedname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6545;
	R1 = tou64(" {Dotted}");
	goto L6544;
L6545:
	R1 = tou64("");
L6544:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6547;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Lastcall:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L6547:
	asu64(R1) = p;
	R2 = 40;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6549;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Addroffirst.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6549:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Moduleno:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6551;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" AV:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 41;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L6551:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("P.INDEX=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6522;
L6524:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L6522;
L6525:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asi64(R1) = t;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6553;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 256;
	if (asi64(R1) <= asi64(R2)) goto L6555;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("(LONGSTR)");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6554;
L6555:
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	if (!asu32(R1)) goto L6556;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\" *");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6554;
L6556:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6554:
	goto L6552;
L6553:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6558;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6558;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6558;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6558;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6559;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6559;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6559;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6559;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6560;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6560;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6561;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6561;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6562;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6563;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6564;
	goto L6565;
L6558:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = a;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6557;
L6559:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6557;
L6560:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = a;
	asu64(R1) = mlib_chr(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6557;
L6561:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6557;
L6562:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6567;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6566;
L6567:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("NIL");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6566:
	goto L6557;
L6563:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6569;
	R1 = tou64("True");
	goto L6568;
L6569:
	R1 = tou64("False");
L6568:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6557;
L6564:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<ARRAY>");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("P.STRTYPE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 45;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	R1 = tou64("P.SLENGTH=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6557;
L6565:
	msysc_m$print_startcon();
	R1 = tou64("TYPENAME(T)=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = t;
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<PRINTUNIT BAD CONST PROBABLY VOID");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6557:
L6552:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = t;
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6571;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" <isstr>(#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 45;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L6571:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L6573;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" *L");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6573:
	goto L6522;
L6526:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Len:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6522;
L6527:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6522;
L6528:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&mm_tables_bitfieldnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6522;
L6529:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Convmode:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6522;
L6530:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Len:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(" Makeax:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6522;
L6531:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Offset:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6522;
L6532:
	goto L6522;
L6533:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6522;
L6534:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&mm_tables_sysfnnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6522;
L6535:
	goto L6522;
L6536:
	goto L6522;
L6537:
	goto L6522;
L6538:
	goto L6522;
L6539:
	goto L6522;
L6540:
	R1 = 1;
	i = asi64(R1);
	R1 = 4;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6576;
L6574:
	asu64(R1) = p;
	R2 = 40;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6578;
	goto L6576;
L6578:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	i += 1; if (i <= av_1) goto L6574;
L6576:
	goto L6522;
L6541:
L6522:
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6580;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Is const");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6579;
L6580:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Not const");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6579:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6583;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L6584;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6585;
	goto L6586;
L6582:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6588;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Pcl<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6587;
L6588:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" no-op");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
L6587:
	goto L6581;
L6583:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Prop<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_propnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6581;
L6584:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Conv<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_convnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6581;
L6585:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Pclcond<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_ccnames;
	asu64(R2) = p;
	R3 = 64;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6581;
L6586:
L6581:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6591;
L6589:
	R1 = 0;
	asi64(R2) = i;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asi64(R2) = level;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 16;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = dev;
	mm_diags_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	i += 1; if (i <= av_2) goto L6589;
L6591:
L6517:
	return;
}

static void mm_diags_printunitlist(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6594;
	goto L6592;
L6594:
	goto L6596;
L6595:
	asu64(R1) = dev;
	asu64(R2) = prefix;
	asi64(R3) = level;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6596:
	asu64(R1) = p;
	if (asu64(R1)) goto L6595;
L6592:
	return;
}

static u64 mm_diags_getprefix(i64 level, u64 prefix, u64 p) {
    u64 R1, R2, R3; 
	struct $B41 indentstr;
	struct $B88 modestr;
	u64 isexpr;
	i64 av_1;
	R1 = 0;
	R2 = (u64)&indentstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = level;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L6600;
	R1 = 10;
	level = asi64(R1);
L6600:
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6603;
L6601:
	R1 = tou64("- ");
	R2 = (u64)&indentstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L6601;
L6603:
	R1 = tou64("S");
	isexpr = asu64(R1);
	R1 = (u64)&mm_tables_jisexpr;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6605;
	R1 = tou64("E");
	isexpr = asu64(R1);
L6605:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6607;
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L6607;
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L6607;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L6607;
	goto L6608;
L6607:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6610;
	R1 = tou64("S");
	isexpr = asu64(R1);
L6610:
	goto L6606;
L6608:
L6606:
	R1 = (u64)&modestr;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# #:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = isexpr;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6612;
	R1 = tou64("RES");
	goto L6611;
L6612:
	R1 = tou64("---");
L6611:
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&modestr;
	R3 = 256;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = tou64("-----------------------------");
	R2 = (u64)&modestr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 32;
	R2 = (u64)&modestr;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&modestr;
	R3 = 18;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = mm_diags_getlineinfok();
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&modestr;
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&indentstr;
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L6614;
	R1 = tou64(" ");
	R2 = (u64)&mm_diags_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L6614:
	R1 = (u64)&mm_diags_getprefix_str;
	goto L6598;
L6598:
	return asu64(R1);
}

static u64 mm_diags_getlineinfok() {
    u64 R1, R2; 
	R1 = (u64)&mm_diags_getlineinfok_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# # ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("Z2");
	asi64(R2) = mm_diags_currfileno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z4");
	asi64(R2) = mm_diags_currlineno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_diags_getlineinfok_str;
	goto L6615;
L6615:
	return asu64(R1);
}

static void mm_diags_printmodelist(u64 f) {
    u64 R1, R2, R3; 
	i64 mbase;
	i64 av_1;
	i64 m;
	i64 i;
// PROC LOCAL STATICS GO HERE
	static u64 mm_diags_printmodelist_tab = (u64)"\t";
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("MODELIST");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	m = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6619;
L6617:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("4");
	asi64(R2) = m;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Basetype:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mbase;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = 1;
	asi64(R2) = mbase;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("ttname:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("ttnamedef:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6621;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6620;
L6621:
	R1 = tou64("-");
L6620:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Target:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Sizeset");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttsizeset;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# Bounds: #..#  Length:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mbase;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L6623;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Mult:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6626;
L6624:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_ttmult;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	i += 1; if (i <= av_1) goto L6624;
L6626:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6623:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Signed:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttsigned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isreal:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isinteger:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isshort:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isref:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_printmodelist_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Isblock:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	m += 1; if (m <= mm_decls_ntypes) goto L6617;
L6619:
	return;
}

static void mm_diags_showprojectinfo(u64 dev) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 ps;
	u64 s;
	u8 isfirst;
	u8 ismain;
	i64 av_1;
	u64 pf;
	i64 i;
	i64 j;
// PROC LOCAL STATICS GO HERE
	static u64 mm_diags_showprojectinfo_tab = (u64)"    ";
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Project Structure:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("---------------------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Modules");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_nmodules;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6630;
L6628:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6632;
	asu64(R1) = pm;
	R2 = 18;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 18;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) == asi64(R2)) goto L6632;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6632:
	R1 = (u64)&mm_decls_subprogs;
	R2 = (u64)&mm_decls_moduletosub;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = i;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isfirst = asu8(R1);
	asu64(R1) = ps;
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = i;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	ismain = asu8(R1);
	asu8(R1) = isfirst;
	if (!asu8(R1)) goto L6634;
	asu8(R1) = ismain;
	if (!asu8(R1)) goto L6634;
	R1 = tou64("hm");
	s = asu64(R1);
	goto L6633;
L6634:
	asu8(R1) = isfirst;
	if (!asu8(R1)) goto L6635;
	R1 = tou64("h ");
	s = asu64(R1);
	goto L6633;
L6635:
	asu8(R1) = ismain;
	if (!asu8(R1)) goto L6636;
	R1 = tou64("m ");
	s = asu64(R1);
	goto L6633;
L6636:
	R1 = tou64("  ");
	s = asu64(R1);
L6633:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("2");
	asi64(R2) = i;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("16jl");
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("Sys:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Sub:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_subprogs;
	asu64(R2) = pm;
	R3 = 18;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Fileno:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	asu64(R1) = pm;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6638;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Alias:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6638:
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6640;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_space();
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_scopenames;
	asu64(R2) = pm;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 170;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L6640:
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6642;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_space();
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_scopenames;
	asu64(R2) = pm;
	R3 = 48;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 170;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L6642:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nmodules) goto L6628;
L6630:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Subprograms");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_nsubprogs;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("MAINSUBPROGNO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_mainsubprogno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6645;
L6643:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Sys:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = ps;
	R3 = 14;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 1;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L6647;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	j = asi64(R1);
	asu64(R1) = ps;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = j;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L6650;
L6648:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_space();
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("(");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(")");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	j += 1; if (j <= av_1) goto L6648;
L6650:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6647:
	i += 1; if (i <= mm_decls_nsubprogs) goto L6643;
L6645:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Sourcefiles");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6653;
L6651:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("  #:  Name=# File=# Path=# Spec=# Size=#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("2");
	asi64(R2) = i;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("jl16");
	asu64(R2) = pf;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("jl18");
	asu64(R2) = pf;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("20jl");
	asu64(R2) = pf;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("30jl");
	asu64(R2) = pf;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("7");
	asu64(R2) = pf;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nsourcefiles) goto L6651;
L6653:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Link files");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_decls_nlibfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6656;
L6654:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = mm_diags_showprojectinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("16jl");
	R2 = (u64)&mm_decls_libfiles;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nlibfiles) goto L6654;
L6656:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showlogfile() {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 logdev;
	i64 size;
	u64 ss;
	asi64(R1) = mm_decls_debugmode;
	if (asi64(R1)) goto L6659;
	goto L6657;
L6659:
	R1 = tou64("w");
	R2 = tou64("mx.log");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	logdev = asu64(R1);
	asu8(R1) = mm_decls_fshowmodules;
	if (!asu8(R1)) goto L6661;
	asu64(R1) = logdev;
	mm_diags_showprojectinfo(asu64(R1));
L6661:
	asu8(R1) = mm_decls_fshowasm;
	if (!asu8(R1)) goto L6663;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L6663;
	asu64(R1) = logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC ASSEMBLY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = logdev;
	R2 = tou64("asm");
	asu64(R3) = mm_decls_outfile;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6663:
	asu8(R1) = mm_decls_fshowpcl;
	if (!asu8(R1)) goto L6665;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L6665;
	asu64(R1) = logdev;
	R2 = tou64("pcl");
	asu64(R3) = mm_decls_outfile;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6665:
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L6667;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L6667;
	asu64(R1) = logdev;
	R2 = tou64("PSYMTAB");
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6667:
	asu8(R1) = mm_decls_fshowast3;
	if (!asu8(R1)) goto L6669;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L6669;
	asu64(R1) = logdev;
	R2 = tou64("AST3");
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6669:
	asu8(R1) = mm_decls_fshowast2;
	if (!asu8(R1)) goto L6671;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L6671;
	asu64(R1) = logdev;
	R2 = tou64("AST2");
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6671:
	asu8(R1) = mm_decls_fshowast1;
	if (!asu8(R1)) goto L6673;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L6673;
	asu64(R1) = logdev;
	R2 = tou64("AST1");
	mm_lib_addtolog(asu64(R2), asu64(R1));
L6673:
	asu8(R1) = mm_decls_fshowst;
	if (!asu8(R1)) goto L6675;
	asu64(R1) = logdev;
	R2 = tou64("SYMBOL TABLE");
	mm_diags_showsttree(asu64(R2), asu64(R1));
L6675:
	asu8(R1) = mm_decls_fshowstflat;
	if (!asu8(R1)) goto L6677;
	asu64(R1) = logdev;
	R2 = tou64("FLAT SYMBOL TABLE");
	mm_diags_showstflat(asu64(R2), asu64(R1));
L6677:
	asu8(R1) = mm_decls_fshowtypes;
	if (!asu8(R1)) goto L6679;
	asu64(R1) = logdev;
	mm_diags_printmodelist(asu64(R1));
L6679:
	asu64(R1) = logdev;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	size = asi64(R1);
	asu64(R1) = logdev;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = size;
	if (!asi64(R1)) goto L6681;
	msysc_m$print_startcon();
	R1 = tou64("PRESS KEY...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mlinux_os_getch();
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6683;
	R1 = 0;
	exit(R1);
L6683:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\m\\ed.bat ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mx.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = tou64("mm.m");
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L6685;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&str;
	asi64(R1) = mlinux_os_execwait(asu64(R3), asi64(R2), asu64(R1));
	goto L6684;
L6685:
	msysc_m$print_startcon();
	R1 = tou64("Diagnostic outputs written to");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mx.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6684:
L6681:
L6657:
	return;
}

static void mm_diags_showstflat(u64 caption, u64 f) {
    u64 R1; 
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	mm_diags_printstflat(asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showsttree(u64 caption, u64 f) {
    u64 R1, R2, R3; 
	u64 pp;
	u64 d;
	i64 i;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = mm_decls_stprogram;
	asu64(R3) = f;
	mm_diags_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Proc List:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L6689;
L6688:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#\t#.# (#) Mod:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("20jl");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L6689:
	asu64(R1) = pp;
	if (asu64(R1)) goto L6688;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("End\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("DLL Proc List:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ndllproctable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6693;
L6691:
	R1 = (u64)&mm_decls_dllproctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#\t#.# (#) Mod:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("20jl");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_ndllproctable) goto L6691;
L6693:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("End\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showast(u64 filename) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L6696;
	goto L6694;
L6696:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	asu64(R2) = f;
	mm_diags_printcode(asu64(R2), asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L6694:
	return;
}

static void mm_diags_printsymbol(u64 lp) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 l;
	asu64(R1) = lp;
	(R1_B3) = *(struct $B3*)(R1);
	l = (R1_B3);
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("%-18s");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = (u64)&l;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 6: case 15: case 19: case 21: case 24: case 25: case 26: case 27: case 28: case 29: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 41: case 42: case 43: goto L6712;
	case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 16: case 17: case 18: case 20: case 22: case 23: case 30: case 40: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 66: goto L6700;
	case 62: goto L6704;
	case 63: goto L6709;
	case 64: goto L6711;
	case 65: goto L6710;
	case 67: goto L6701;
	default: goto L6700;
    };
// SWITCH
L6701:
	R1 = (u64)&l;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&l;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_lex_printstrn(asu64(R2), asi64(R1));
	R1 = (u64)&l;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6703;
	msysc_m$print_startcon();
	R1 = tou64(" [#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L6703:
	goto L6698;
L6704:
	R1 = (u64)&l;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6706;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6707;
	goto L6708;
L6706:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("int");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6705;
L6707:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	R1 = tou64("word");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6705;
L6708:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6705:
	goto L6698;
L6709:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L6698;
L6710:
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&l;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L6698;
L6711:
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6698;
L6712:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L6698;
L6700:
	R1 = (u64)&l;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6714;
	msysc_m$print_startcon();
	R1 = tou64("SUBCODE:");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&l;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L6714:
L6698:
	msysc_m$print_startcon();
	msysc_m$print_space();
	R1 = tou64("LX.FILENO=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showtime(u64 caption, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("# # ms # %");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = caption;
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("5");
	asi64(R2) = t;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("5.1jr");
	asi64(R2) = t;
	asr64(R2) = tor64(asi64(R2));
	asr64(R3) = 1.000000000000000000e+002;
	asr64(R2) *= asr64(R3);
	asi64(R3) = mm_cli_compiletime;
	asr64(R3) = tor64(asi64(R3));
	asr64(R2) /= asr64(R3);
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_showtimings() {
    u64 R1, R2; 
	asi64(R1) = mlinux_os_clock();
	mm_cli_endclock = asi64(R1);
	asi64(R1) = mm_cli_endclock;
	asi64(R2) = mm_cli_startclock;
	asi64(R1) -= asi64(R2);
	mm_cli_compiletime = asi64(R1);
	asi64(R1) = mm_cli_loadtime;
	R2 = tou64("Load:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = mm_cli_parsetime;
	R2 = tou64("Parse:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = mm_cli_resolvetime;
	R2 = tou64("Resolve:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = mm_cli_typetime;
	R2 = tou64("Type:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = mm_cli_pcltime;
	R2 = tou64("PCL:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_mcltime;
	R2 = tou64("MCL:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_sstime;
	R2 = tou64("SS:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_exetime;
	R2 = tou64("EXE:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("-----------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mm_cli_compiletime;
	R2 = tou64("Total:");
	mm_diags_showtime(asu64(R2), asi64(R1));
	return;
}

static void mm_export_dummy_writeexports(u64 basefile, u64 modulename) {
	return;
}

static void mm_lex_lex() {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 lena;
	i64 lenb;
	u64 p;
	(R1_B3) = mm_decls_nextlx;
	mm_decls_lx = (R1_B3);
	asu64(R1) = mm_lex_lxstart;
	asu64(R2) = mm_lex_lxsource;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 23;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L6719:
	mm_lex_lexreadtoken();
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L6721;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L6722;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6723;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6724;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6725;
	goto L6726;
L6721:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6729;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6729;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6729;
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6728;
	asi64(R1) = mm_decls_assemmode;
	if (asi64(R1)) goto L6728;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6728;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6728;
L6729:
	goto L6727;
L6728:
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6720;
L6727:
	goto L6719;
L6722:
	mm_lex_doinclude();
	goto L6719;
L6723:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L6731;
	goto L6732;
L6731:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6734;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6735;
	goto L6736;
L6734:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6738;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6739;
	goto L6740;
L6738:
	R1 = 1000000;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L6737;
L6739:
	R1 = 1000000000;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L6737;
L6740:
	R1 = tou64("Can't do this unit index");
	mm_support_lxerror(asu64(R1));
L6737:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6733;
L6735:
	R1 = tou64("Unit suffix after float not implem");
	mm_support_lxerror(asu64(R1));
	goto L6733;
L6736:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6720;
L6733:
	goto L6730;
L6732:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6720;
L6730:
	goto L6719;
L6724:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6720;
	goto L6719;
L6725:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 47;
	if (asi64(R1) != asi64(R2)) goto L6742;
	R1 = 45;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6741;
L6742:
	goto L6720;
L6741:
	goto L6719;
L6726:
	goto L6720;
	goto L6719;
L6720:
	asi64(R1) = mm_lex_lxfileno;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 24;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void mm_lex_lexreadtoken() {
    u64 R1, R2, R3; 
	i64 c;
	i64 hsum;
	u64 sptr;
	u64 lxsvalue;
	i64 length;
	i64 commentseen;
	u64 p;
	u64 q;
	u8 instr;
	struct $B16 str;
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6744:
	asu64(R1) = mm_lex_lxsptr;
	mm_lex_lxstart = asu64(R1);
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L6867;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: goto L6747;
	case 9: case 32: goto L6864;
	case 10: goto L6866;
	case 13: goto L6865;
	case 33: goto L6773;
	case 34: goto L6862;
	case 35: goto L6781;
	case 36: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L6748;
	case 37: goto L6840;
	case 38: goto L6856;
	case 39: goto L6861;
	case 40: goto L6815;
	case 41: goto L6816;
	case 42: goto L6836;
	case 43: goto L6828;
	case 44: goto L6809;
	case 45: goto L6831;
	case 46: goto L6801;
	case 47: goto L6839;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L6764;
	case 58: goto L6811;
	case 59: goto L6810;
	case 60: goto L6845;
	case 61: goto L6841;
	case 62: goto L6851;
	case 63: goto L6822;
	case 64: goto L6821;
	case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: goto L6763;
	case 91: goto L6817;
	case 92: goto L6782;
	case 93: goto L6818;
	case 94: goto L6820;
	case 96: goto L6863;
	case 123: goto L6799;
	case 124: goto L6819;
	case 125: goto L6800;
	case 126: goto L6827;
	default: goto L6747;
    };
// SWITCH
L6748:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	lxsvalue = asu64(R1);
// mm_lex.lexreadtoken.doname:
L6749:
	asu64(R1) = lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
	asu64(R1) = mm_lex_lxsptr;
	sptr = asu64(R1);
L6750:
	R1 = (u64)&mm_lex_namemap;
	R2 = (u64)&sptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6752;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6753;
	goto L6754;
L6752:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L6750;
L6753:
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) += asu64(R2);
	asu64(R2) = sptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 32;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L6750;
L6754:
	asu64(R1) = sptr;
	R2 = 1;
	R1 -= (i64)R2;
	mm_lex_lxsptr = asu64(R1);
	goto L6751;
	goto L6750;
L6751:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L6756;
	asu64(R1) = lxsvalue;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = mm_lex_lxsptr;
	if (asu64(R1) != asu64(R2)) goto L6758;
	asu64(R1) = lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6760;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L6760;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L6761;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L6761;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L6761;
	goto L6762;
L6760:
	mm_lex_readrawstring();
	goto L6743;
	goto L6759;
L6761:
	asi64(R1) = c;
	mm_lex_readarraystring(asi64(R1));
	goto L6743;
	goto L6759;
L6762:
L6759:
L6758:
L6756:
	asi64(R1) = hsum;
	asu64(R2) = mm_lex_lxsptr;
	asu64(R3) = lxsvalue;
	asi64(R2) -= asi64(R3);
	asu64(R3) = lxsvalue;
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	goto L6743;
	goto L6744;
L6763:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	lxsvalue = asu64(R1);
	R1 = 32;
	asu64(R2) = lxsvalue;
	*tou8p(R2) += asu8(R1);
	goto L6749;
	goto L6744;
L6764:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	mm_lex_lxstart = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L6766;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L6766;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L6766;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6766;
	R2 = 120;
	if (asu64(R1) == asu64(R2)) goto L6767;
	R2 = 88;
	if (asu64(R1) == asu64(R2)) goto L6767;
	goto L6768;
L6766:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6765;
L6767:
	asu64(R1) = mm_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L6770;
	R2 = 50;
	if (asu64(R1) == asu64(R2)) goto L6771;
	goto L6772;
L6770:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	mm_lex_readhex();
	goto L6769;
L6771:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	mm_lex_readbin();
	goto L6769;
L6772:
	R1 = tou64("Bad base");
	mm_support_lxerror(asu64(R1));
L6769:
	goto L6765;
L6768:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	mm_lex_readdec();
L6765:
	goto L6743;
	goto L6744;
L6773:
// mm_lex.lexreadtoken.docomment:
L6775:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6777;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6778;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6779;
	goto L6780;
L6777:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6776;
	goto L6775;
L6778:
	goto L6776;
	goto L6775;
L6779:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6776;
	goto L6775;
L6780:
	goto L6775;
L6776:
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6781:
	R1 = 23;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6782:
	R1 = 0;
	commentseen = asi64(R1);
L6783:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L6785;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6786;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L6787;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6788;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L6788;
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L6789;
	goto L6790;
L6785:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6784;
	goto L6783;
L6786:
	goto L6784;
	goto L6783;
L6787:
	R1 = 59;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6743;
	goto L6783;
L6788:
	goto L6783;
L6789:
	R1 = 1;
	commentseen = asi64(R1);
	goto L6783;
L6790:
	asi64(R1) = commentseen;
	if (asi64(R1)) goto L6792;
	R1 = tou64("\\ not followed by eol");
	mm_support_lxerror(asu64(R1));
L6792:
	goto L6783;
L6784:
L6793:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L6795;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6796;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6797;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L6797;
	goto L6798;
L6795:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6793;
L6796:
	goto L6793;
L6797:
	goto L6793;
L6798:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6794;
	goto L6793;
L6794:
	goto L6744;
L6799:
	R1 = 13;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6800:
	R1 = 14;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6801:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L6803;
	goto L6804;
L6803:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L6806;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 22;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6805;
L6806:
	R1 = 21;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 21;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6805:
	goto L6743;
	goto L6802;
L6804:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L6808;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L6808;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = tou64(".123 not done");
	mm_support_lxerror(asu64(R1));
	goto L6743;
	goto L6807;
L6808:
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
L6807:
L6802:
	goto L6744;
L6809:
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6810:
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6811:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L6813;
	goto L6814;
L6813:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 6;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 28;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6812;
L6814:
	R1 = 5;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6812:
	goto L6743;
	goto L6744;
L6815:
	R1 = 9;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6816:
	R1 = 10;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6817:
	R1 = 11;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6818:
	R1 = 12;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6819:
	R1 = 16;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6820:
	R1 = 15;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6821:
	R1 = 17;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6822:
	R1 = (u64)&str;
	p = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 += (i64)R2;
	q = asu64(R1);
	goto L6824;
L6823:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L6824:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6826;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6826;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6823;
L6826:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 18;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6827:
	goto L6744;
L6828:
	R1 = 24;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L6830;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 61;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 84;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
L6830:
	goto L6743;
	goto L6744;
L6831:
	R1 = 25;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L6833;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L6834;
	goto L6835;
L6833:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 61;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 85;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6832;
L6834:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6832;
L6835:
L6832:
	goto L6743;
	goto L6744;
L6836:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 42;
	if (asu64(R1) != asu64(R2)) goto L6838;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 43;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6837;
L6838:
	R1 = 26;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6837:
	goto L6743;
	goto L6744;
L6839:
	R1 = 27;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6840:
	R1 = 28;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6841:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L6843;
	goto L6844;
L6843:
	R1 = 7;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6842;
L6844:
	R1 = 41;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6842:
	goto L6743;
	goto L6744;
L6845:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L6847;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L6848;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L6849;
	goto L6850;
L6847:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6846;
L6848:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 2;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6846;
L6849:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 34;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6846;
L6850:
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6846:
	goto L6743;
	goto L6744;
L6851:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L6853;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L6854;
	goto L6855;
L6853:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6852;
L6854:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 35;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6852;
L6855:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6852:
	goto L6743;
	goto L6744;
L6856:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L6858;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L6859;
	goto L6860;
L6858:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 20;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 57;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6857;
L6859:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 2;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6857;
L6860:
	R1 = 19;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 55;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6857:
	goto L6743;
	goto L6744;
L6861:
	R1 = 39;
	mm_lex_lxreadstring(asi64(R1));
	goto L6743;
	goto L6744;
L6862:
	R1 = 34;
	mm_lex_lxreadstring(asi64(R1));
	goto L6743;
	goto L6744;
L6863:
	mm_lex_readrawxname();
	goto L6743;
	goto L6744;
L6864:
	goto L6744;
L6865:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6866:
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6743;
	goto L6744;
L6867:
	asi64(R1) = mm_lex_sourcelevel;
	if (!asi64(R1)) goto L6869;
	mm_lex_unstacksource();
	goto L6743;
	goto L6868;
L6869:
	R1 = 59;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6743;
L6868:
	goto L6744;
L6747:
	R1 = tou64("Unknown char");
	mm_support_lxerror(asu64(R1));
	goto L6743;
	goto L6744;
L6743:
	return;
}

static void mm_lex_lexsetup() {
	mm_lex_inithashtable();
	return;
}

static void mm_lex_printstrn(u64 s, i64 length) {
    u64 R1, R2; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L6873;
	msysc_m$print_startcon();
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
L6873:
	return;
}

static void mm_lex_readrawstring() {
    u64 R1, R2, R3; 
	u64 dest;
	i64 c;
	R1 = 65;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	dest = asu64(R1);
L6875:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6877;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6878;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6878;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6878;
	goto L6879;
L6877:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L6881;
	R1 = 34;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6880;
L6881:
	goto L6876;
L6880:
	goto L6875;
L6878:
	R1 = tou64("Raw string not terminated");
	mm_support_lxerror(asu64(R1));
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L6876;
	goto L6875;
L6879:
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L6875;
L6876:
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lex_lookup(u64 name, i64 length, i64 hashindex) {
    u64 R1, R2, R3, R4; 
	i64 wrapped;
	i64 j;
	u64 d;
	asi64(R1) = hashindex;
	R2 = 65535;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L6883:
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6886;
	goto L6884;
L6886:
	asu64(R1) = d;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L6888;
	asi64(R1) = length;
	asu64(R2) = name;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6888;
	asu64(R1) = d;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 77;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6882;
L6888:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L6890;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L6892;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L6892:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L6890:
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	goto L6883;
L6884:
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mm_lex_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = name;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = d;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 77;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6882:
	return;
}

static i64 mm_lex_lookupsys(u64 name) {
    u64 R1, R2, R3; 
	i64 j;
	i64 wrapped;
	i64 hashvalue;
	asu64(R1) = name;
	asi64(R1) = mm_lex_gethashvaluez(asu64(R1));
	R2 = 65535;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L6894:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6897;
	goto L6895;
	goto L6896;
L6897:
	asu64(R1) = name;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6898;
	msysc_m$print_startcon();
	R1 = tou64("Lex dupl name:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L6898:
L6896:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L6900;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L6902;
	R1 = tou64("SYS:HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L6902:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L6900:
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6894;
L6895:
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lex_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = name;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	goto L6893;
L6893:
	return asi64(R1);
}

static i64 mm_lex_gethashvaluez(u64 s) {
    u64 R1, R2; 
	i64 c;
	i64 hsum;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6905;
	R1 = 0;
	goto L6903;
L6905:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
L6906:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6909;
	goto L6907;
L6909:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L6906;
L6907:
	asi64(R1) = hsum;
	goto L6903;
L6903:
	return asi64(R1);
}

static void mm_lex_inithashtable() {
    u64 R1, R2, R3; 
	i64 i;
	i64 av_1;
	R1 = 524288;
	R2 = 0;
	R3 = (u64)&mm_lex_hashtable;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	R1 = 174;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6913;
L6911:
	R1 = (u64)&mm_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mm_lex_lookupsys(asu64(R1));
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L6915;
	goto L6916;
L6915:
	R1 = (u64)&mm_tables_stsubcodes;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6914;
L6916:
	R1 = (u64)&mm_tables_stsubcodes;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6914:
	i += 1; if (i <= av_1) goto L6911;
L6913:
	return;
}

static void mm_lex_printhashtable() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("Hashtable:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_lex_addreservedword(u64 name, i64 symbol, i64 subcode, i64 regsize) {
    u64 R1, R2, R3; 
	asu64(R1) = name;
	asi64(R1) = mm_lex_lookupsys(asu64(R1));
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = symbol;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = subcode;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = regsize;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 164;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void mm_lex_doinclude() {
    u64 R1, R2, R3; 
	u64 file;
	u64 pf;
	mm_lex_lexreadtoken();
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L6921;
	R1 = tou64("include: string expected");
	mm_support_lxerror(asu64(R1));
L6921:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	file = asu64(R1);
	asu64(R1) = file;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = tou64("m");
	asu64(R2) = file;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	file = asu64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = mm_lex_lxfileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("");
	asu64(R3) = file;
	asu64(R1) = mm_support_getsupportfile(asu64(R3), asu64(R2), asu64(R1));
	pf = asu64(R1);
	mm_lex_lexreadtoken();
	R1 = 0;
	asu64(R2) = pf;
	R3 = 64;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	mm_lex_stacksource(asi64(R2), asi64(R1));
	return;
}

static void mm_lex_startlex(u64 file) {
    u64 R1, R2, R3; 
	asu64(R1) = file;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	mm_lex_lxsptr = asu64(R2);
	mm_lex_lxsource = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = file;
	R2 = 64;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	mm_lex_lxfileno = asi64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_lex_addnamestr(u64 name) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	struct $B3 oldlx;
	u64 symptr;
	(R1_B3) = mm_decls_nextlx;
	oldlx = (R1_B3);
	asu64(R1) = name;
	asi64(R1) = mm_lex_gethashvaluez(asu64(R1));
	asu64(R2) = name;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = name;
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B3) = oldlx;
	mm_decls_nextlx = (R1_B3);
	asu64(R1) = symptr;
	goto L6923;
L6923:
	return asu64(R1);
}

static void mm_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PS:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	mm_diags_printsymbol(asu64(R1));
	return;
}

static void mm_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_nextlx;
	mm_diags_printsymbol(asu64(R1));
	return;
}

static void mm_lex_psx(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	mm_diags_printsymbol(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_nextlx;
	mm_diags_printsymbol(asu64(R1));
	return;
}

static void mm_lex_stacksource(i64 fileno, i64 isimport) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asi64(R1) = mm_lex_sourcelevel;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L6929;
	R1 = tou64("Include file/macro overflow");
	mm_support_lxerror(asu64(R1));
L6929:
	R1 = (u64)&mm_lex_sourcelevel;
	(*toi64p(R1)) += 1;
	asu64(R1) = mm_lex_lxstart;
	R2 = (u64)&mm_lex_lxstart_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_lex_lxsource;
	R2 = (u64)&mm_lex_lxsource_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_lex_lxsptr_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mm_lex_lxfileno;
	R2 = (u64)&mm_lex_lxfileno_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	(R1_B3) = mm_decls_nextlx;
	R2 = (u64)&mm_lex_lxnextlx_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*(struct $B3*)(((i64)R2+(i64)R3*16-16)) = (R1_B3);
	asi64(R1) = mm_lex_lximport;
	R2 = (u64)&mm_lex_lximport_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = isimport;
	mm_lex_lximport = asi64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	mm_lex_lxsptr = asu64(R2);
	mm_lex_lxsource = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = fileno;
	mm_lex_lxfileno = asi64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_lex_unstacksource() {
    u64 R1, R2; struct $B3 R1_B3; 
	asi64(R1) = mm_lex_sourcelevel;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6932;
	R1 = (u64)&mm_lex_lxstart_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxstart = asu64(R1);
	R1 = (u64)&mm_lex_lxsource_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxsource = asu64(R1);
	R1 = (u64)&mm_lex_lxsptr_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxsptr = asu64(R1);
	R1 = (u64)&mm_lex_lxnextlx_stack;
	asi64(R2) = mm_lex_sourcelevel;
	(R1_B3) = *(struct $B3*)(((i64)R1+(i64)R2*16-16));
	mm_decls_nextlx = (R1_B3);
	R1 = (u64)&mm_lex_lxfileno_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxfileno = asi64(R1);
	R1 = (u64)&mm_lex_lximport_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_lex_lximport = asi64(R1);
	R1 = (u64)&mm_lex_sourcelevel;
	(*toi64p(R1)) -=1;
L6932:
	return;
}

static void mm_lex_readarraystring(i64 prefix) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 34;
	mm_lex_lxreadstring(asi64(R1));
	asi64(R1) = prefix;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L6935;
	R1 = 83;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6934;
L6935:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 2;
	R1 += (i64)R2;
	(*tou16p(R1)) -=1;
	R1 = 66;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6934:
	return;
}

static i64 mm_lex_setinttype(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 9223372036854775807;
	if (asu64(R1) > asu64(R2)) goto L6938;
	R1 = 3;
	goto L6937;
L6938:
	R1 = 4;
L6937:
	goto L6936;
L6936:
	return asi64(R1);
}

static void mm_lex_readrawxname() {
    u64 R1, R2, R3, R4; 
	i64 c;
	i64 hsum;
	i64 length;
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	hsum = asi64(R1);
	goto L6941;
L6940:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
L6941:
	R1 = (u64)&mm_lex_namemap;
	R2 = (u64)&mm_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6940;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6944;
	R1 = tou64("Bad ` name");
	mm_support_lxerror(asu64(R1));
L6944:
	asi64(R1) = hsum;
	asi64(R2) = length;
	R3 = (u64)&mm_decls_nextlx;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = 60;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6939;
L6939:
	return;
}

static void mm_lex_lxerror_s(u64 mess, u64 s) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_lxerror(asu64(R1));
	return;
}

static void mm_lex_lxreadstring(i64 termchar) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	i64 c;
	i64 d;
	i64 length;
	i64 hasescape;
	i64 a;
	i64 n;
	u64 str;
	i64 pass;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L6948;
	R1 = 65;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6947;
L6948:
	R1 = 64;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6947:
	R1 = 0;
	length = asi64(R1);
	R1 = 0;
	hasescape = asi64(R1);
	R1 = 0;
	t = asu64(R1);
	R1 = 1;
	pass = asi64(R1);
L6949:
	asu64(R1) = mm_lex_lxsptr;
	s = asu64(R1);
L6952:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6955;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6956;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6956;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6957;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6957;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6957;
	goto L6958;
L6955:
	R1 = 1;
	hasescape = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L6960;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L6960;
	R1 = 32;
	R2 = (u64)&c;
	*toi64p(R2) += asi64(R1);
L6960:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) == asi64(R2)) goto L6962;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L6963;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L6964;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L6964;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L6965;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L6966;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L6967;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L6968;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L6968;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L6969;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L6970;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L6970;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L6971;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L6972;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L6973;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L6974;
	goto L6975;
L6962:
	R1 = 7;
	c = asi64(R1);
	goto L6961;
L6963:
	R1 = 8;
	c = asi64(R1);
	goto L6961;
L6964:
	R1 = 13;
	c = asi64(R1);
	goto L6961;
L6965:
	R1 = 27;
	c = asi64(R1);
	goto L6961;
L6966:
	R1 = 12;
	c = asi64(R1);
	goto L6961;
L6967:
	goto L6977;
L6976:
	R1 = 1;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = mm_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6980;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L6980:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
L6977:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L6976;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
	goto L6961;
L6968:
	R1 = 10;
	c = asi64(R1);
	goto L6961;
L6969:
	R1 = 9;
	c = asi64(R1);
	goto L6961;
L6970:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6982;
	asu64(R1) = t;
	goto L6981;
L6982:
	R1 = 0;
L6981:
	R2 = 0;
	asi64(R3) = c;
	R4 = 117;
	if (asi64(R3) != asi64(R4)) goto L6984;
	R3 = 4;
	goto L6983;
L6984:
	R3 = 6;
L6983:
	R4 = (u64)&s;
	asi64(R2) = mm_lex_readhexcode(asu64(R4), asi64(R3), asi64(R2));
	asi64(R1) = mm_lex_getutf8(asi64(R2), asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	goto L6952;
	goto L6961;
L6971:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6986;
	R1 = 13;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L6986:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	R1 = 10;
	c = asi64(R1);
	goto L6961;
L6972:
	R1 = 0;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = mm_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	goto L6961;
L6973:
	R1 = 16;
	c = asi64(R1);
	goto L6961;
L6974:
	R1 = 0;
	c = asi64(R1);
	goto L6961;
L6975:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6988;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6989;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6990;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L6991;
	goto L6992;
L6988:
	R1 = 34;
	c = asi64(R1);
	goto L6987;
L6989:
	R1 = 92;
	c = asi64(R1);
	goto L6987;
L6990:
	R1 = 39;
	c = asi64(R1);
	goto L6987;
L6991:
	R1 = 0;
	c = asi64(R1);
	goto L6987;
L6992:
	asi64(R1) = c;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	R2 = tou64("Unknown string escape: \\%s");
	mm_lex_lxerror_s(asu64(R2), asu64(R1));
L6987:
L6961:
	goto L6954;
L6956:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L6994;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asi64(R2) = c;
	if (asi64(R1) != asi64(R2)) goto L6996;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L6995;
L6996:
	goto L6953;
L6995:
L6994:
	R1 = 1;
	hasescape = asi64(R1);
	goto L6954;
L6957:
	R1 = tou64("String not terminated");
	mm_support_lxerror(asu64(R1));
	goto L6954;
L6958:
L6954:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6998;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L6998:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	goto L6952;
L6953:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7000;
	asu64(R1) = t;
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = hasescape;
	if (!asi64(R1)) goto L7002;
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7001;
L7002:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7003;
	R1 = tou64("");
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
	goto L6946;
	goto L7001;
L7003:
	asi64(R1) = length;
	asu64(R2) = mm_lex_lxsptr;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
	goto L6946;
L7001:
	goto L6999;
L7000:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
L6999:
	pass += 1; if (pass <= 2) goto L6949;
L6946:
	return;
}

static i64 mm_lex_readhexcode(u64 s, i64 n, i64 sp) {
    u64 R1, R2; 
	i64 a;
	i64 c;
	i64 i;
	R1 = 0;
	a = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7007;
L7005:
	asi64(R1) = sp;
	if (!asi64(R1)) goto L7009;
	asi64(R1) = i;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7009;
L7010:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7010;
	goto L7008;
L7009:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
L7008:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L7014;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L7014;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L7013;
L7014:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L7015;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L7015;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L7013;
L7015:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7016;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7016;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	goto L7013;
L7016:
	R1 = tou64("Bad hex digit");
	mm_support_lxerror(asu64(R1));
L7013:
	i += 1; if (i <= n) goto L7005;
L7007:
	asi64(R1) = a;
	goto L7004;
L7004:
	return asi64(R1);
}

static i64 mm_lex_getutf8(i64 c, u64 s) {
    u64 R1, R2, R3, R4; 
	i64 n;
	struct $B3 str;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7019;
	R1 = (u64)&str;
	s = asu64(R1);
L7019:
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L7021;
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7020;
L7021:
	asi64(R1) = c;
	R2 = 2047;
	if (asi64(R1) > asi64(R2)) goto L7022;
	R1 = 2;
	n = asi64(R1);
	R1 = 192;
	asi64(R2) = c;
	R3 = 6;
	R4 = 10;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7020;
L7022:
	asi64(R1) = c;
	R2 = 65535;
	if (asi64(R1) > asi64(R2)) goto L7023;
	R1 = 3;
	n = asi64(R1);
	R1 = 224;
	asi64(R2) = c;
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7020;
L7023:
	asi64(R1) = c;
	R2 = 1114111;
	if (asi64(R1) > asi64(R2)) goto L7024;
	R1 = 4;
	n = asi64(R1);
	R1 = 240;
	asi64(R2) = c;
	R3 = 18;
	R4 = 20;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 12;
	R4 = 17;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7020;
L7024:
	R1 = 0;
	n = asi64(R1);
L7020:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = n;
	goto L7017;
L7017:
	return asi64(R1);
}

static void mm_lex_readdec() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 islong;
	i64 length;
	struct $B41 str;
	u64 a;
	i64 av_1;
	R1 = 0;
	islong = asi64(R1);
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L7026:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7029;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7029;
	asu64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7028;
L7029:
	asi64(R1) = c;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L7031;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7031;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7032;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7033;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7033;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7034;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7034;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L7035;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L7035;
	goto L7036;
L7031:
	asu64(R1) = pstart;
	mm_lex_lxsptr = asu64(R1);
	mm_lex_readreal();
	goto L7025;
	goto L7030;
L7032:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L7038;
	asu64(R1) = pstart;
	mm_lex_lxsptr = asu64(R1);
	mm_lex_readreal();
	goto L7025;
L7038:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7027;
	goto L7030;
L7033:
	goto L7030;
L7034:
	mm_lex_nodecimal();
	goto L7030;
L7035:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L7040;
	R1 = tou64("bin overflow");
	mm_support_lxerror(asu64(R1));
L7040:
	R1 = (u64)&str;
	dest = asu64(R1);
	R1 = 0;
	a = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7043;
L7041:
	asu64(R1) = dest;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 50;
	if (asu64(R1) < asu64(R2)) goto L7045;
	R1 = tou64("bad bin digit");
	mm_support_lxerror(asu64(R1));
L7045:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	if (--asi64(av_1)) goto L7041;
L7043:
	goto L7046;
	goto L7030;
L7036:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7027;
L7030:
L7028:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7048;
	R1 = tou64("Numlit too long");
	mm_support_lxerror(asu64(R1));
L7048:
	goto L7026;
L7027:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L7051;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7050;
	R1 = 20;
	asu64(R2) = mm_lex_u64maxstr;
	R3 = (u64)&str;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7050;
L7051:
	mm_lex_nodecimal();
L7050:
// mm_lex.readdec.finish:
L7046:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7025:
	return;
}

static void mm_lex_readhex() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B41 str;
	u64 a;
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L7053:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7056;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7056;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7055;
L7056:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L7057;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L7057;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L7055;
L7057:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L7058;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L7058;
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L7055;
L7058:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7060;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7060;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7061;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7061;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7062;
	goto L7063;
L7060:
	goto L7059;
L7061:
	mm_lex_nodecimal();
	goto L7059;
L7062:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7054;
	goto L7059;
L7063:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7054;
L7059:
L7055:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7065;
	R1 = tou64("Numlit too long");
	mm_support_lxerror(asu64(R1));
L7065:
	goto L7053;
L7054:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L7067;
	R1 = tou64("MAKEDEC");
	mm_support_lxerror(asu64(R1));
	goto L7052;
L7067:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7052:
	return;
}

static void mm_lex_readbin() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B41 str;
	u64 a;
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L7069:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L7072;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7072;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7073;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7073;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7074;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7074;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7075;
	goto L7076;
L7072:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7071;
L7073:
	goto L7071;
L7074:
	mm_lex_nodecimal();
	goto L7071;
L7075:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7070;
	goto L7071;
L7076:
	asi64(R1) = c;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L7078;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7078;
	R1 = tou64("bin bad digit");
	mm_support_lxerror(asu64(R1));
	goto L7077;
L7078:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7070;
L7077:
L7071:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7080;
	R1 = tou64("bin overflow");
	mm_support_lxerror(asu64(R1));
L7080:
	goto L7069;
L7070:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L7082;
	mm_lex_nodecimal();
L7082:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void mm_lex_readreal() {
    u64 R1, R2, R3; 
	i64 c;
	i64 negexpon;
	i64 dotseen;
	i64 length;
	i64 fractlen;
	i64 expon;
	i64 expseen;
	r64 x;
	struct $B41 str;
	u64 dest;
	u64 destend;
	u64 a;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 i;
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 100;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	R2 = R1;
	fractlen = asi64(R2);
	R2 = R1;
	expon = asi64(R2);
	R2 = R1;
	expseen = asi64(R2);
	R2 = R1;
	dotseen = asi64(R2);
	R2 = R1;
	negexpon = asi64(R2);
	length = asi64(R1);
L7084:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7087;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7087;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L7089;
	R1 = (u64)&fractlen;
	(*toi64p(R1)) += 1;
L7089:
	goto L7086;
L7087:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7091;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L7092;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7092;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7093;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7093;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7094;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7094;
	goto L7095;
L7091:
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L7097;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7085;
L7097:
	R1 = 1;
	dotseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7090;
L7092:
	asi64(R1) = expseen;
	if (!asi64(R1)) goto L7099;
	R1 = tou64("double expon");
	mm_support_lxerror(asu64(R1));
L7099:
	R1 = 1;
	expseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L7101;
L7100:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
L7101:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L7100;
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L7105;
	R2 = 45;
	if (asi64(R1) != asi64(R2)) goto L7104;
L7105:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L7107;
	R1 = 1;
	negexpon = asi64(R1);
L7107:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L7104:
	R1 = 0;
	expon = asi64(R1);
L7108:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7111;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L7111;
	asi64(R1) = expon;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	expon = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7113;
	R1 = tou64("expon?");
	mm_support_lxerror(asu64(R1));
L7113:
	goto L7110;
L7111:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7115;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7115;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L7116;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7116;
	goto L7117;
L7115:
	goto L7114;
L7116:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	mm_lex_nodecimal();
	goto L7083;
	goto L7114;
L7117:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7085;
L7114:
L7110:
	goto L7108;
	goto L7090;
L7093:
	goto L7090;
L7094:
	mm_lex_nodecimal();
	goto L7083;
	goto L7090;
L7095:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L7085;
L7090:
L7086:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L7119;
	R1 = tou64("r64lit too long");
	mm_support_lxerror(asu64(R1));
L7119:
	goto L7084;
L7085:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = expseen;
	if (!asi64(R1)) goto L7121;
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7121;
	asi64(R1) = dotseen;
	if (asi64(R1)) goto L7121;
	R1 = 0;
	a = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7124;
L7122:
	asu64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&str;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	i += 1; if (i <= length) goto L7122;
L7124:
	asi64(R1) = expon;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7127;
L7125:
	asu64(R1) = a;
	R2 = 10;
	asu64(R1) *= asu64(R2);
	a = asu64(R1);
	if (--asi64(av_1)) goto L7125;
L7127:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7083;
L7121:
	asi64(R1) = negexpon;
	if (!asi64(R1)) goto L7129;
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	expon = asi64(R1);
L7129:
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = dotseen;
	asi64(R1) += asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7132;
L7130:
	R1 = (u64)&str;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7134;
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 48;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	x = asr64(R1);
L7134:
	i += 1; if (i <= av_2) goto L7130;
L7132:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7136;
	asi64(R1) = expon;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7139;
L7137:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_3)) goto L7137;
L7139:
	goto L7135;
L7136:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7142;
L7140:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_4)) goto L7140;
L7142:
L7135:
	asr64(R1) = x;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 63;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7083:
	return;
}

static void mm_lex_nodecimal() {
    u64 R1; 
	R1 = tou64("Decimal not ready");
	mm_support_lxerror(asu64(R1));
	return;
}

static void mm_lex_start() {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 c;
	R1 = 0;
	c = asi64(R1);
	R1 = 255;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7147;
L7145:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L7151;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L7150;
L7151:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L7152;
	R2 = 57;
	if (asi64(R1) <= asi64(R2)) goto L7150;
L7152:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L7153;
	R2 = 36;
	if (asi64(R1) != asi64(R2)) goto L7149;
L7153:
L7150:
	R1 = 1;
	R2 = (u64)&mm_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7148;
L7149:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L7154;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L7154;
	R1 = 2;
	R2 = (u64)&mm_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7154:
L7148:
	c += 1; if (c <= av_1) goto L7145;
L7147:
	return;
}

static u64 mm_lib_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 88;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L7155;
L7155:
	return asu64(R1);
}

static u64 mm_lib_getduplnameptr(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = mm_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 78;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	asu64(R2) = p;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L7156;
L7156:
	return asu64(R1);
}

static void mm_lib_adddef(u64 owner, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (!asu64(R1)) goto L7159;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L7161;
	msysc_m$print_startcon();
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Duplicate name");
	mm_support_serror(asu64(R1));
L7161:
L7159:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7163;
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7162;
L7163:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7162:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 4;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L7164;
L7164:
	return asu64(R1);
}

static u64 mm_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L7165;
L7165:
	return asu64(R1);
}

static u64 mm_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L7166;
L7166:
	return asu64(R1);
}

static u64 mm_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L7167;
L7167:
	return asu64(R1);
}

static u64 mm_lib_createunit3(i64 tag, u64 p, u64 q, u64 r) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = u;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L7168;
L7168:
	return asu64(R1);
}

static void mm_lib_insertunit(u64 p, i64 tag) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 q;
	u64 nextunit;
	i64 mode;
	asu64(R1) = mm_lib_allocunitrec();
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = q;
	*(struct $B60*)(R2) = (R1_B60);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nextunit = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	memset(R1, 0, 65);
	asi64(R1) = tag;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = nextunit;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_lib_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = p;
	*(struct $B60*)(R2) = (R1_B60);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_createconstunit(u64 a, i64 t) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = u;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = u;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L7171;
L7171:
	return asu64(R1);
}

static u64 mm_lib_createstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 20;
	asu64(R2) = u;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7174;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L7173;
L7174:
	asi64(R1) = length;
	asu64(R2) = u;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L7173:
	asu64(R1) = u;
	goto L7172;
L7172:
	return asu64(R1);
}

static i64 mm_lib_newtypename(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_decls_ntypenames;
	R2 = 38000;
	if (asi64(R1) < asi64(R2)) goto L7177;
	R1 = tou64("Too many type names");
	mm_support_serror(asu64(R1));
L7177:
	R1 = (u64)&mm_decls_ntypenames;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	R2 = (u64)&mm_decls_typenames;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*32;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	R2 = (u64)&mm_decls_typenames;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*32;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_typenamepos;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*4;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_ntypenames;
	asi64(R1) = -asi64(R1);
	goto L7175;
L7175:
	return asi64(R1);
}

static i64 mm_lib_createusertype(u64 stname) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_decls_ntypes;
	R2 = 16000;
	if (asi64(R1) < asi64(R2)) goto L7180;
	msysc_m$print_startcon();
	asi64(R1) = mm_decls_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many types");
	mm_support_serror(asu64(R1));
L7180:
	R1 = (u64)&mm_decls_ntypes;
	(*toi64p(R1)) += 1;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttname;
	asi64(R3) = mm_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = stname;
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = mm_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = mm_decls_ntypes;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlineno;
	asi64(R3) = mm_decls_ntypes;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = mm_decls_ntypes;
	asu64(R2) = stname;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = mm_decls_ntypes;
	goto L7178;
L7178:
	return asi64(R1);
}

static i64 mm_lib_createusertypefromstr(u64 name) {
    u64 R1, R2, R3; 
	u64 stname;
	R1 = 5;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stmodule;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	goto L7181;
L7181:
	return asi64(R1);
}

static u64 mm_lib_getrangelwbunit(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L7184;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7183;
L7184:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
L7183:
	goto L7182;
L7182:
	return asu64(R1);
}

static u64 mm_lib_getrangeupbunit(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L7187;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7186;
L7187:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
L7186:
	goto L7185;
L7185:
	return asu64(R1);
}

static i64 mm_lib_createarraymode(u64 owner, i64 target, u64 dimexpr, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 k;
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7190;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7189;
L7190:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7189:
	R1 = 10;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = dimexpr;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7188;
L7188:
	return asi64(R1);
}

static i64 mm_lib_sameunit(u64 p, u64 q, u64 powner, u64 qowner) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = p;
	asu64(R2) = q;
	if (asu64(R1) != asu64(R2)) goto L7193;
	R1 = 1;
	goto L7191;
L7193:
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L7196;
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7195;
L7196:
	R1 = 0;
	goto L7191;
L7195:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L7198;
	R1 = 0;
	goto L7191;
L7198:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7200;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L7201;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7201;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7202;
	goto L7203;
L7200:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L7191;
	goto L7199;
L7201:
	R1 = 0;
	R2 = 0;
	asu64(R3) = q;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = mm_lib_sameunit(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7204;
	R1 = 0;
	R2 = 0;
	asu64(R3) = q;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = mm_lib_sameunit(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7204;
	R1 = 1;
	goto L7205;
L7204:
	R1 = 0;
L7205:
	goto L7191;
	goto L7199;
L7202:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L7207;
	asu64(R1) = powner;
	asu64(R2) = qowner;
	if (asu64(R1) != asu64(R2)) goto L7207;
	R1 = 1;
	goto L7191;
L7207:
	goto L7199;
L7203:
L7199:
	R1 = 0;
	goto L7191;
L7191:
	return asi64(R1);
}

static i64 mm_lib_createarraymodek(u64 owner, i64 target, i64 lower, i64 length, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 atype;
	i64 m;
	R1 = 10;
	atype = asi64(R1);
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7210;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7209;
L7210:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7209:
	asi64(R1) = atype;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7212;
	R1 = tou64("CREATEARRAYMODEK/TARGET NOT RESOLVED");
	mm_support_serror(asu64(R1));
L7212:
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = target;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7208;
L7208:
	return asi64(R1);
}

static u64 mm_lib_nextautotype() {
    u64 R1; 
	R1 = (u64)&mm_lib_nextautotype_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_autotypeno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_lib_nextautotype_str;
	goto L7213;
L7213:
	return asu64(R1);
}

static i64 mm_lib_createslicemode(u64 owner, i64 slicetype, i64 target, u64 dimexpr, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7216;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7215;
L7216:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7215:
	asi64(R1) = slicetype;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = dimexpr;
	if (!asu64(R1)) goto L7218;
	asu64(R1) = dimexpr;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L7217;
L7218:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L7217:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7214;
L7214:
	return asi64(R1);
}

static i64 mm_lib_createslicemodek(u64 owner, i64 target, i64 lower, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7221;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7220;
L7221:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7220:
	R1 = 11;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7219;
L7219:
	return asi64(R1);
}

static i64 mm_lib_createrefmode(u64 owner, i64 target, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 k;
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7224;
	R1 = 31;
	k = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L7227;
L7225:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7229;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = k;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = target;
	if (asi64(R1) != asi64(R2)) goto L7231;
	asi64(R1) = k;
	goto L7222;
L7231:
L7229:
	k += 1; if (k <= mm_decls_ntypes) goto L7225;
L7227:
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7223;
L7224:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7223:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	R2 = 7;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7222;
L7222:
	return asi64(R1);
}

static i64 mm_lib_createrefprocmode(u64 owner, u64 stproc, u64 paramlist, i64 kwd, i64 prettype, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mproc;
	asu64(R1) = stproc;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	mproc = asi64(R1);
	asu64(R1) = paramlist;
	asu64(R2) = stproc;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = prettype;
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 24;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = mproc;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7234;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L7233;
L7234:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7233:
	asi64(R1) = mproc;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	R2 = 7;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7232;
L7232:
	return asi64(R1);
}

static void mm_lib_copyttvalues(i64 dest, i64 source) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttsigned;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsigned;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisshort;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisblock;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_lib_getdottedname(u64 p) {
    u64 R1, R2; 
	struct $B16 str2;
	u64 owner;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	goto L7238;
L7237:
	R1 = (u64)&mm_lib_getdottedname_str;
	R2 = (u64)&str2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
L7238:
	asu64(R1) = owner;
	if (!asu64(R1)) goto L7240;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7237;
L7240:
	R1 = (u64)&mm_lib_getdottedname_str;
	goto L7236;
L7236:
	return asu64(R1);
}

static u64 mm_lib_getavname(u64 owner, i64 id) {
    u64 R1, R2, R3; 
	u64 p;
	struct $B17 str;
	u64 name;
	asi64(R1) = id;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7243;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7243;
	R1 = tou64("Auto frame not in proc");
	mm_support_serror(asu64(R1));
L7243:
	asi64(R1) = id;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7245;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("av_");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_nextavindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7244;
L7245:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("sv_");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_nextsvindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7244:
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	asi64(R1) = id;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 168;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = p;
	goto L7241;
L7241:
	return asu64(R1);
}

static void mm_lib_unionstr_clear(u64 u) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = u;
	*tou64p(R2) = asu64(R1);
	return;
}

static void mm_lib_unionstr_append(u64 u, i64 c) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7249;
	R1 = tou64("Uflags overflow/a");
	mm_support_serror(asu64(R1));
L7249:
	asu64(R1) = u;
	R2 = 7;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asi64(R1) = c;
	asu64(R2) = u;
	asu64(R3) = u;
	R4 = 7;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mm_lib_unionstr_concat(u64 u, u64 v) {
    u64 R1, R2, R3, R4; 
	i64 ulen;
	i64 vlen;
	i64 i;
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	ulen = asi64(R1);
	asu64(R1) = v;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	vlen = asi64(R1);
	asi64(R1) = ulen;
	asi64(R2) = vlen;
	asi64(R1) += asi64(R2);
	R2 = 7;
	if (asi64(R1) <= asi64(R2)) goto L7252;
	R1 = tou64("Uflags overflow/c");
	mm_support_serror(asu64(R1));
L7252:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = vlen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7255;
L7253:
	asu64(R1) = v;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = u;
	asi64(R3) = i;
	asi64(R4) = ulen;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= vlen) goto L7253;
L7255:
	asi64(R1) = ulen;
	asi64(R2) = vlen;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static i64 mm_lib_unionstr_last(u64 u) {
    u64 R1, R2, R3; 
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7258;
	asu64(R1) = u;
	asu64(R2) = u;
	R3 = 7;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L7256;
L7258:
	R1 = 0;
	goto L7256;
L7256:
	return asi64(R1);
}

static void mm_lib_unionstr_copy(u64 u, u64 v) {
    u64 R1, R2, R3; 
	R1 = 8;
	asu64(R2) = v;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mm_lib_createrecordmode(u64 owner, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7262;
	asu64(R1) = owner;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	goto L7261;
L7262:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7261:
	R1 = 8;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L7260;
L7260:
	return asi64(R1);
}

static i64 mm_lib_createtuplemode(u64 owner, u64 elements, i64 elementslen, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	i64 i;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7265;
	asu64(R1) = owner;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	goto L7264;
L7265:
	asi64(R1) = typedefx;
	m = asi64(R1);
L7264:
	R1 = 28;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = elementslen;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = elementslen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&mm_decls_ttmult;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = elementslen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7268;
L7266:
	R1 = (u64)&mm_decls_ttmult;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = i;
	R1 += (i64)R2*4-4;
	asu64(R2) = elements;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	i += 1; if (i <= elementslen) goto L7266;
L7268:
	asi64(R1) = m;
	goto L7263;
L7263:
	return asi64(R1);
}

static u64 mm_lib_strexpr(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mm_lib_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = mm_lib_exprstr;
	mm_lib_jevalx2(asu64(R2), asu64(R1));
	asu64(R1) = mm_lib_exprstr;
	goto L7269;
L7269:
	return asu64(R1);
}

static void mm_lib_jevalx2(u64 dest, u64 p) {
    u64 R1; 
	asu64(R1) = dest;
	mm_lib_jdest = asu64(R1);
	asu64(R1) = p;
	mm_lib_jevalx(asu64(R1));
	return;
}

static void mm_lib_jevalx(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 a;
	u64 b;
	struct $B46 str;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7273;
	goto L7271;
L7273:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7275;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7276;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L7277;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L7277;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L7278;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7278;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7278;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L7279;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7280;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7281;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L7281;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L7281;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7281;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7282;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7283;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L7284;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7285;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L7286;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L7287;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L7288;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L7288;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L7289;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L7290;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7291;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L7292;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7293;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7294;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7295;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L7296;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7297;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L7298;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L7298;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L7299;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L7300;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L7301;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L7302;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7303;
	goto L7304;
L7275:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7306;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7306;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7306;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7306;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7307;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7307;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7307;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7307;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7308;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7308;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7309;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7309;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7310;
	goto L7311;
L7306:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L7305;
L7307:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7305;
L7308:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L7305;
L7309:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7305;
L7310:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7313;
	asu64(R1) = p;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7313;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 250;
	if (asi64(R1) <= asi64(R2)) goto L7315;
	R1 = tou64("LONGSTR)");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7314;
L7315:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
L7314:
	R1 = tou64("\"");
	mm_lib_jadditem(asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("\"");
	mm_lib_jadditem(asu64(R1));
	goto L7271;
	goto L7312;
L7313:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L7312:
	goto L7305;
L7311:
	R1 = tou64("<EVAL/CONST PROBABLY VOID>");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L7305:
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7276:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7277:
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7278:
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L7317;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	goto L7316;
L7317:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
L7316:
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7279:
	R1 = (u64)&mm_tables_propnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7280:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	goto L7319;
L7318:
	asu64(R1) = q;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L7322;
	R1 = tou64(",");
	mm_lib_jadditem(asu64(R1));
L7322:
L7319:
	asu64(R1) = q;
	if (asu64(R1)) goto L7318;
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7281:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L7325;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L7324;
L7325:
	R1 = tou64(".");
	mm_lib_jadditem(asu64(R1));
L7324:
	R1 = tou64("[");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("]");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7282:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(".");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L7274;
L7283:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	q = asu64(R1);
	goto L7327;
L7326:
	asu64(R1) = q;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L7330;
	R1 = tou64(",");
	mm_lib_jadditem(asu64(R1));
L7330:
L7327:
	asu64(R1) = q;
	if (asu64(R1)) goto L7326;
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7284:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("..");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7285:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":=");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L7274;
L7286:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("|");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("|");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7287:
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7288:
	R1 = 1;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L7332;
	R1 = tou64("@");
	mm_lib_jadditem(asu64(R1));
L7332:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7289:
	R1 = tou64("shorten(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7290:
	R1 = tou64("cast(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7291:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L7334;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jevalx(asu64(R1));
	goto L7333;
L7334:
	R1 = tou64("-");
	mm_lib_jaddstr(asu64(R1));
L7333:
	goto L7274;
L7292:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("^");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7293:
	R1 = tou64("<JBLOCK>");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7294:
	R1 = tou64("<nullunit>");
	mm_lib_jaddstr(asu64(R1));
	goto L7274;
L7295:
	R1 = tou64("&");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L7336;
	R1 = tou64("+");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_lib_jdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
L7336:
	goto L7274;
L7296:
	R1 = tou64("&.");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L7274;
L7297:
	R1 = tou64("TYPESTR(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L7274;
L7298:
	R1 = tou64("$");
	mm_lib_jaddstr(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	mm_lib_jaddstr(asu64(R1));
	goto L7274;
L7299:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(".");
	mm_lib_jaddstr(asu64(R1));
	R1 = (u64)&mm_tables_bitfieldnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lib_jaddstr(asu64(R1));
	goto L7274;
L7300:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L7274;
L7301:
	R1 = (u64)&mm_tables_sysfnnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	mm_lib_jaddstr(asu64(R1));
	R1 = tou64("(");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L7338;
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
L7338:
	R1 = tou64(")");
	mm_lib_jaddstr(asu64(R1));
	goto L7274;
L7302:
	R1 = tou64("incr ");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L7274;
L7303:
	R1 = tou64("strinclude ");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L7274;
L7304:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("CAN'T DO JEVAL");
	mm_support_gerror(asu64(R2), asu64(R1));
L7274:
L7271:
	return;
}

static void mm_lib_jadditem(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = mm_lib_jdest;
	mm_support_gs_additem(asu64(R2), asu64(R1));
	return;
}

static void mm_lib_jaddstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = mm_lib_jdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static u64 mm_lib_strmode(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lib_strmode_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_lib_strmode_str;
	goto L7341;
L7341:
	return asu64(R1);
}

static u64 mm_lib_strmode2(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lib_strmode2_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_lib_strmode2_str;
	goto L7342;
L7342:
	return asu64(R1);
}

static void mm_lib_istrmode(i64 m, i64 expand, u64 dest) {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	u64 d;
	u64 q;
	i64 needcomma;
	i64 i;
	i64 target;
	i64 mbase;
	i64 n;
	struct $B3 sxx;
	u64 xx;
	u64 sdim;
	struct $B5 strdim;
	u64 prefix;
	struct $B17 tn;
	R1 = (u64)&sxx;
	xx = asu64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7345;
	R1 = tou64("*");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	(R1_B17) = *(struct $B17*)(((i64)R1+(i64)R2*32));
	tn = (R1_B17);
	R1 = (u64)&tn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7347;
	R1 = (u64)&tn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7347:
	R1 = (u64)&tn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7343;
L7345:
	asi64(R1) = m;
	R2 = 31;
	if (asi64(R1) >= asi64(R2)) goto L7349;
	asi64(R1) = m;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7349;
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7343;
L7349:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	mbase = asi64(R2);
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7351;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7352;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7353;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7354;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7355;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L7356;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7358;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7359;
	goto L7360;
L7351:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7362;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7362;
	asi64(R1) = target;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7361;
L7362:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L7361:
	goto L7350;
L7352:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L7364;
	R1 = (u64)&strdim;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	mm_support_gs_copytostr(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("@[#<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&strdim;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7363;
L7364:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	if (!asi32(R1)) goto L7366;
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7368;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7367;
L7368:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#..#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7367:
	goto L7365;
L7366:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7370;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[]");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L7369;
L7370:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#:]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7369:
L7365:
L7363:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L7350;
L7353:
	R1 = (u64)&mm_tables_stdnames;
	asi64(R2) = mbase;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	prefix = asu64(R1);
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L7372;
	R1 = (u64)&strdim;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	mm_support_gs_copytostr(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("@#[#:]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = prefix;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&strdim;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7371;
L7372:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7374;
	asu64(R1) = prefix;
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("[]");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7373;
L7374:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#[#:]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = prefix;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7373:
L7371:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L7350;
L7354:
	asi64(R1) = expand;
	if (asi64(R1)) goto L7376;
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7343;
L7376:
	R1 = tou64("");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = expand;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7378;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7378:
	R1 = tou64("(");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L7382;
L7379:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L7384;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7384:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7382:
	asu64(R1) = q;
	if (asu64(R1)) goto L7379;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7350;
L7355:
	R1 = tou64("void");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7350;
L7356:
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7350;
L7357:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = tou64("proc(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	goto L7386;
L7385:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L7389;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7389:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7386:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7385;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7391;
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = d;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L7391:
	goto L7350;
L7358:
	R1 = tou64("Tuple(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7394;
L7392:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_ttmult;
	asi64(R4) = m;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asi64(R4) = i;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4-4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = n;
	if (asi64(R1) >= asi64(R2)) goto L7396;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7396:
	i += 1; if (i <= n) goto L7392;
L7394:
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7350;
L7359:
	R1 = tou64("bitfield");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7350;
L7360:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 31;
	if (asi64(R1) >= asi64(R2)) goto L7398;
	R1 = tou64("Alias for:");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L7397;
L7398:
	msysc_m$print_startcon();
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("NEWSTRMODE");
	mm_support_mcerror(asu64(R1));
L7397:
L7350:
L7343:
	return;
}

static void mm_lib_addtoproclist(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_proclist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7401;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_proclistx = asu64(R2);
	mm_decls_proclist = asu64(R1);
	goto L7400;
L7401:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_proclistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_proclistx = asu64(R1);
L7400:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lib_addstatic(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_staticlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7404;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_staticlistx = asu64(R2);
	mm_decls_staticlist = asu64(R1);
	goto L7403;
L7404:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_staticlistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_staticlistx = asu64(R1);
L7403:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lib_addexpconst(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_constlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7407;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_constlistx = asu64(R2);
	mm_decls_constlist = asu64(R1);
	goto L7406;
L7407:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_constlistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_constlistx = asu64(R1);
L7406:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_typename(i64 m) {
    u64 R1, R2; 
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7410;
	R1 = (u64)&mm_decls_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L7408;
L7410:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7408;
L7408:
	return asu64(R1);
}

static u64 mm_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = (u64)&mm_decls_nunits;
	(*toi64p(R1)) += 1;
	R1 = 65;
	R2 = (u64)&mm_decls_nunitsmem;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&mm_lib_remainingunits;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) -= 1; asi64(R1) = asi64(R2);
	if (!asi64(R1)) goto L7413;
	asu64(R1) = mm_lib_unitheapptr;
	p = asu64(R1);
	R1 = (u64)&mm_lib_unitheapptr;
	(*tou64p(R1)) += 65;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 58;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L7411;
L7413:
	R1 = 2129920;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	mm_lib_unitheapptr = asu64(R2);
	p = asu64(R1);
	R1 = 2129920;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 32767;
	mm_lib_remainingunits = asi64(R1);
	R1 = (u64)&mm_lib_unitheapptr;
	(*tou64p(R1)) += 65;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 58;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L7411;
L7411:
	return asu64(R1);
}

static u64 mm_lib_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mm_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 78;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L7416;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7418;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7417;
L7418:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7417:
L7416:
	asu64(R1) = p;
	goto L7414;
L7414:
	return asu64(R1);
}

static u64 mm_lib_createnewmoduledef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3; 
	asi64(R1) = id;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	goto L7419;
L7419:
	return asu64(R1);
}

static u64 mm_lib_duplunit(u64 p, i64 lineno) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 q;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7422;
	R1 = 0;
	goto L7420;
L7422:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = q;
	*(struct $B60*)(R2) = (R1_B60);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7425;
L7423:
	R1 = 0;
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= av_1) goto L7423;
L7425:
	asu64(R1) = q;
	goto L7420;
L7420:
	return asu64(R1);
}

static i64 mm_lib_isconstunit(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L7426;
L7426:
	return asi64(R1);
}

static void mm_lib_getownername(u64 d, u64 dest) {
    u64 R1, R2; 
	u64 owner;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L7430;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7429;
L7430:
	goto L7427;
L7429:
	asu64(R1) = dest;
	asu64(R2) = owner;
	mm_lib_getownername(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7427:
	return;
}

static i64 mm_lib_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7433;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7434;
	goto L7435;
L7433:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	goto L7431;
	goto L7432;
L7434:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 166;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7437;
	R1 = 8;
	a = asi64(R1);
L7437:
	asi64(R1) = a;
	goto L7431;
	goto L7432;
L7435:
	R1 = (u64)&mm_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7439;
	R1 = 8;
	goto L7431;
L7439:
L7432:
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7441;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7441;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7441;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7441;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7442;
	goto L7443;
L7441:
	asi64(R1) = a;
	goto L7431;
	goto L7440;
L7442:
	R1 = 8;
	goto L7431;
	goto L7440;
L7443:
L7440:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("GETALIGN SIZE NOT 1248");
	mm_support_gerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L7431;
L7431:
	return asi64(R1);
}

static void mm_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7446;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L7445;
L7446:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7445:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static i64 mm_lib_storemode(u64 owner, i64 m, u64 pmode) {
    u64 R1, R2, R3; 
	u64 r;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7449;
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asi64(R1) = m;
	goto L7447;
L7449:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7451;
	asu64(R1) = owner;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = pmode;
	asu64(R2) = r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7453;
	R1 = tou64("PMODE=NIL");
	mm_support_serror(asu64(R1));
L7453:
	asi64(R1) = m;
	goto L7447;
L7451:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	r = asu64(R1);
	asu64(R1) = owner;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = pmode;
	asu64(R2) = r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	goto L7447;
L7447:
	return asi64(R1);
}

static i64 mm_lib_gettypebase(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7456;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7456;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7456;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7457;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7457;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7457;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7458;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7459;
	goto L7460;
L7456:
	R1 = 3;
	goto L7455;
L7457:
	R1 = 3;
	goto L7455;
L7458:
	R1 = 1;
	goto L7455;
L7459:
	R1 = 5;
	goto L7455;
L7460:
	asi64(R1) = m;
L7455:
	goto L7454;
L7454:
	return asi64(R1);
}

static void mm_lib_writegsfile(u64 filename, u64 d) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	return;
}

static void mm_lib_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7464;
	msysc_m$print_startcon();
	R1 = tou64("ATL ERROR");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7462;
L7464:
L7465:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7468;
	goto L7466;
L7468:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L7465;
L7466:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7462:
	return;
}

static u64 mm_lib_getprocretmodes(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7471;
	R1 = 0;
	R2 = tou64("multass/need multfn");
	mm_support_txerror(asu64(R2), asu64(R1));
L7471:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7473;
	goto L7474;
L7473:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7472;
L7474:
	R1 = (u64)&mm_decls_ttnamedef;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L7472:
	goto L7469;
L7469:
	return asu64(R1);
}

static i64 mm_lib_getpclmode(i64 t) {
    u64 R1, R2, R3; 
	i64 u;
	R1 = (u64)&mm_tables_stdpcl;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7477;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = t;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7479;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7480;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7481;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7482;
	goto L7483;
L7479:
	R1 = 6;
	u = asi64(R1);
	goto L7478;
L7480:
	R1 = 5;
	u = asi64(R1);
	goto L7478;
L7481:
	R1 = 4;
	u = asi64(R1);
	goto L7478;
L7482:
	R1 = 3;
	u = asi64(R1);
	goto L7478;
L7483:
L7478:
L7477:
	asi64(R1) = u;
	goto L7475;
L7475:
	return asi64(R1);
}

static void mm_libsources_loadbuiltins() {
    u64 R1, R2, R3; 
	u64 pf;
	u64 filename;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7487;
L7485:
	R1 = (u64)&mm_libsources_syslibnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	filename = asu64(R1);
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L7485;
L7487:
	return;
}

static u64 mm_modules_loadsp(u64 filename, i64 mainsub) {
    u64 R1, R2, R3, R4, R5; 
	u64 sp;
	struct $B45 modnames;
	struct $B45 aliases;
	struct $B45 paths;
	struct $B45 subnames;
	struct $B45 subpaths;
	i64 nmods;
	i64 nsubs;
	i64 hdrcode;
	i64 firstmod;
	i64 lastmod;
	i64 issyslib;
	u64 pm;
	u64 d;
	u64 stalias;
	u64 path;
	u64 name;
	u64 ext;
	u64 file2;
	u8 proj;
	u8 sepheader;
	i64 i;
	i64 j;
	R1 = 0;
	nmods = asi64(R1);
	R1 = 0;
	nsubs = asi64(R1);
	R1 = 0;
	issyslib = asi64(R1);
	R1 = 0;
	proj = asu8(R1);
	R1 = 0;
	sepheader = asu8(R1);
	asu64(R1) = mm_cli_syslibname;
	asu64(R2) = filename;
	asu64(R2) = mlib_extractbasefile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7490;
	R1 = 1;
	issyslib = asi64(R1);
L7490:
	R1 = 0;
	asu64(R2) = filename;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	ext = asu64(R1);
	R1 = tou64("m");
	asu64(R2) = ext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7492;
	asu64(R1) = ext;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_modules_fileext = asu64(R1);
L7492:
	asi64(R1) = issyslib;
	asu64(R2) = filename;
	asu64(R1) = mm_modules_loadmodule(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7494;
	R1 = tou64("");
	asu64(R2) = filename;
	R3 = tou64("Can't load lead module: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7494:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	path = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7497;
L7495:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7499;
	R1 = tou64("");
	asu64(R2) = sp;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Subprog already loaded: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7499:
	i += 1; if (i <= mm_decls_nsubprogs) goto L7495;
L7497:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lex_startlex(asu64(R1));
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 115;
	if (asi64(R1) != asi64(R2)) goto L7501;
	R1 = 1;
	proj = asu8(R1);
	R1 = 41;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
L7501:
L7502:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L7505;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7506;
	goto L7507;
L7505:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	hdrcode = asi64(R1);
	mm_lex_lex();
	asi64(R1) = hdrcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7509;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7510;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7511;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7512;
	goto L7513;
L7509:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7515;
	asi64(R1) = nmods;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L7517;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many modules in header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7517:
	asu64(R1) = name;
	R2 = (u64)&modnames;
	R3 = (u64)&nmods;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = path;
	R2 = (u64)&paths;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&aliases;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L7515:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L7519;
	R1 = tou64("as");
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7519;
	mm_lex_lex();
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L7521;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stalias = asu64(R1);
	mm_lex_lex();
	goto L7520;
L7521:
	R1 = 65;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	stalias = asu64(R1);
L7520:
	asu64(R1) = stalias;
	R2 = (u64)&aliases;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L7519:
	goto L7508;
L7510:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	asi64(R1) = nsubs;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L7523;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many imports in header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7523:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	R3 = (u64)&nsubs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = path;
	R2 = (u64)&subpaths;
	asi64(R3) = nsubs;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L7508;
L7511:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_modules_addlib(asu64(R1));
	goto L7508;
L7512:
	R1 = 65;
	mm_parse_checksymbol(asi64(R1));
	asu8(R1) = mm_decls_loadedfromma;
	if (asu8(R1)) goto L7525;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	path = asu64(R1);
L7525:
	goto L7508;
L7513:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Hdr cmd not ready");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7508:
	mm_lex_lex();
	goto L7504;
L7506:
	goto L7504;
L7507:
	goto L7503;
L7504:
	goto L7502;
L7503:
	asu8(R1) = proj;
	if (!asu8(R1)) goto L7527;
	R1 = 0;
	R2 = 0;
	R3 = 115;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L7527:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L7529;
	R1 = 1;
	sepheader = asu8(R1);
L7529:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nsubs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7532;
L7530:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7534;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Importing self");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7534:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&subnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	R4 = (u64)&subpaths;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R2) = mm_modules_getmodulefilename(asu64(R4), asu64(R3), asi64(R2));
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
	i += 1; if (i <= nsubs) goto L7530;
L7532:
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 30;
	if (asi64(R1) < asi64(R2)) goto L7536;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many subprogs");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7536:
	R1 = 16;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	sp = asu64(R1);
	asu64(R1) = sp;
	R2 = (u64)&mm_decls_subprogs;
	R3 = (u64)&mm_decls_nsubprogs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = sp;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mainsub;
	if (!asi64(R1)) goto L7538;
	asi64(R1) = mm_decls_nsubprogs;
	mm_decls_mainsubprogno = asi64(R1);
L7538:
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	asi64(R1) += asi64(R2);
	firstmod = asi64(R1);
	asi64(R1) = firstmod;
	asi64(R2) = nmods;
	asi64(R1) += asi64(R2);
	lastmod = asi64(R1);
	asi64(R1) = lastmod;
	R2 = 300;
	if (asi64(R1) <= asi64(R2)) goto L7540;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many modules");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7540:
	asi64(R1) = lastmod;
	mm_decls_nmodules = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 18;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 1;
	asu64(R2) = pm;
	R3 = 23;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = firstmod;
	asu64(R2) = pm;
	R3 = 16;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = d;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = (u64)&mm_decls_moduletosub;
	asi64(R3) = firstmod;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = sp;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = lastmod;
	asu64(R2) = sp;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = issyslib;
	asu64(R2) = sp;
	R3 = 14;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = firstmod;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nmods;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7543;
L7541:
	asi64(R1) = issyslib;
	asi64(R2) = issyslib;
	R3 = (u64)&modnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	R4 = (u64)&paths;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R2) = mm_modules_getmodulefilename(asu64(R4), asu64(R3), asi64(R2));
	asu64(R1) = mm_modules_loadmodule(asu64(R2), asi64(R1));
	pm = asu64(R1);
	R1 = (u64)&aliases;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	stalias = asu64(R1);
	asu64(R1) = pm;
	if (asu64(R1)) goto L7545;
	R1 = tou64("");
	R2 = (u64)&modnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = tou64("Can't load: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7545:
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = firstmod;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 18;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = stalias;
	if (!asu64(R1)) goto L7547;
	R1 = 15;
	asu64(R2) = stalias;
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	asu64(R2) = pm;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_decls_stprogram;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pm;
	R3 = 40;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = pm;
	R3 = 40;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7547:
	asi64(R1) = firstmod;
	asi64(R2) = i;
	asi64(R1) += asi64(R2);
	R2 = R1;
	asu64(R3) = pm;
	R4 = 16;
	*toi16p(((i64)R3+(i64)R4)) = asi16(R2);
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = d;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = (u64)&mm_decls_moduletosub;
	asu64(R3) = d;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7550;
L7548:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7552;
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl mod name:");
	mm_support_serror_s(asu64(R2), asu64(R1));
L7552:
	j += 1; if (j <= mm_decls_nmodules) goto L7548;
L7550:
	i += 1; if (i <= nmods) goto L7541;
L7543:
	asu64(R1) = sp;
	goto L7488;
L7488:
	return asu64(R1);
}

static u64 mm_modules_loadmodule(u64 filespec, i64 issyslib) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 pf;
	asi64(R1) = issyslib;
	asu64(R2) = filespec;
	asu64(R1) = mm_modules_loadsourcefile(asu64(R2), asi64(R1));
	pf = asu64(R1);
	asu64(R1) = pf;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7555;
	R1 = 0;
	goto L7553;
L7555:
	R1 = 64;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pf;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	asu64(R2) = pm;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	R2 = 64;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 20;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = issyslib;
	asu64(R2) = pm;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	goto L7553;
L7553:
	return asu64(R1);
}

static u64 mm_modules_loadsourcefile(u64 filespec, i64 issyslib) {
    u64 R1, R2, R3; 
	u64 pf;
	u64 s;
	u64 filename;
	struct $B15 str;
	i64 i;
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractfile(asu64(R1));
	filename = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7559;
L7557:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = filename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7561;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = issyslib;
	if (asi64(R1) != asi64(R2)) goto L7561;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L7556;
L7561:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L7557;
L7559:
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = issyslib;
	asu64(R2) = pf;
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	asu64(R2) = pf;
	R3 = 64;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L7563;
	R1 = 0;
	goto L7556;
L7563:
	asu64(R1) = s;
	asu64(R2) = pf;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	asu64(R2) = pf;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7565;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7565:
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pf;
	goto L7556;
L7556:
	return asu64(R1);
}

static u64 mm_modules_getmodulefilename(u64 path, u64 name, i64 issyslib) {
    u64 R1, R2; 
	asu64(R1) = path;
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = name;
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = issyslib;
	if (!asi64(R1)) goto L7568;
	R1 = tou64("m");
	goto L7567;
L7568:
	asu64(R1) = mm_modules_fileext;
L7567:
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_modules_getmodulefilename_str;
	goto L7566;
L7566:
	return asu64(R1);
}

static void mm_modules_addlib(u64 libname) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7572;
L7570:
	asu64(R1) = libname;
	R2 = (u64)&mm_decls_libfiles;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7574;
	goto L7569;
L7574:
	i += 1; if (i <= mm_decls_nlibfiles) goto L7570;
L7572:
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L7576;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many libs");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7576:
	asu64(R1) = libname;
	R2 = (u64)&mm_decls_libfiles;
	R3 = (u64)&mm_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L7569:
	return;
}

static void mm_modules_loadsyslib() {
    u64 R1, R2, R3; 
	struct $B15 str;
	u64 name;
	u8 frunpcl;
	u8 fgenpcl;
	asi64(R1) = mm_decls_passlevel;
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	frunpcl = asu8(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	fgenpcl = asu8(R1);
	asu8(R1) = mm_decls_dointlibs;
	if (!asu8(R1)) goto L7579;
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L7578;
L7579:
	R1 = tou64("C:/mx/");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L7578:
	asu8(R1) = mm_decls_msyslevel;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7581;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7582;
	goto L7583;
L7581:
	goto L7577;
	goto L7580;
L7582:
	R1 = 0;
	if (asu16(R1)) goto L7586;
	asi64(R1) = mlinux_os_iswindows();
	if (asi64(R1)) goto L7585;
L7586:
	R1 = tou64("msysminc");
	goto L7584;
L7585:
	R1 = tou64("msysmin");
L7584:
	name = asu64(R1);
	goto L7580;
L7583:
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L7588;
	asu8(R1) = mm_decls_clinux;
	if (asu8(R1)) goto L7588;
	R1 = 0;
	if (!asu16(R1)) goto L7590;
	R1 = tou64("msyswinc");
	name = asu64(R1);
	goto L7589;
L7590:
	asu8(R1) = frunpcl;
	if (asu8(R1)) goto L7592;
	asu8(R1) = fgenpcl;
	if (!asu8(R1)) goto L7591;
L7592:
	R1 = tou64("msyswini");
	name = asu64(R1);
	goto L7589;
L7591:
	R1 = tou64("msyswin");
	name = asu64(R1);
L7589:
	goto L7587;
L7588:
	R1 = tou64("msyslinc");
	name = asu64(R1);
L7587:
L7580:
	asu64(R1) = name;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_cli_syslibname = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L7594;
	msysc_m$print_startcon();
	R1 = tou64("SYSLIBNAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_cli_syslibname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7594:
	R1 = tou64(".m");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
L7577:
	return;
}

static void mm_modules_loadproject(u64 file) {
    u64 R1, R2, R3; 
	struct $B15 str;
	u64 file2;
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	asu8(R1) = mm_decls_dointlibs;
	if (!asu8(R1)) goto L7597;
	mm_libsources_loadbuiltins();
L7597:
	mm_modules_loadsyslib();
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L7599;
	R1 = tou64("ma");
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file2 = asu64(R1);
	asu64(R1) = file2;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L7601;
	asu64(R1) = file2;
	file = asu64(R1);
L7601:
L7599:
	R1 = tou64("ma");
	R2 = 0;
	asu64(R3) = file;
	asu64(R2) = mlib_extractext(asu64(R3), asi64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7603;
	msysc_m$print_startcon();
	R1 = tou64("LOADING FROM MA FILE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = file;
	mm_modules_loadmafile(asu64(R2), asu64(R1));
	R1 = 1;
	mm_decls_loadedfromma = asu8(R1);
	R1 = tou64("m");
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	file = asu64(R1);
L7603:
	R1 = 1;
	asu64(R2) = file;
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
	R1 = tou64("msvcrt");
	mm_modules_addlib(asu64(R1));
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L7605;
	R1 = tou64("user32");
	mm_modules_addlib(asu64(R1));
	R1 = tou64("gdi32");
	mm_modules_addlib(asu64(R1));
	R1 = tou64("kernel32");
	mm_modules_addlib(asu64(R1));
L7605:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_loadtime = asi64(R1);
	return;
}

static u64 mm_modules_readfileline(u64 s) {
    u64 R1, R2, R3; 
	struct $B96 str;
	u64 t;
	i64 n;
	i64 c;
	R1 = (u64)&str;
	t = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L7607:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7609;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7610;
	goto L7611;
L7609:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	goto L7608;
	goto L7607;
L7610:
	goto L7608;
	goto L7607;
L7611:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L7613;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L7613:
	goto L7607;
L7608:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$read_strline(asu64(R1));
	asu64(R1) = s;
	goto L7606;
L7606:
	return asu64(R1);
}

static u64 mm_modules_findnextlineheader(u64 s) {
    u64 R1, R2; 
	i64 c;
L7615:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7617;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7618;
	goto L7619;
L7617:
	R1 = 0;
	goto L7614;
	goto L7615;
L7618:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L7621;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L7621;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L7621;
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	goto L7614;
L7621:
	goto L7615;
L7619:
	goto L7615;
	R1 = 0;
	goto L7614;
L7614:
	return asu64(R1);
}

static void mm_modules_loadmafile(u64 filespec, u64 builtinstr) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	struct $B5 name;
	i64 sys;
	i64 support;
	u64 pf;
	i64 i;
	asu64(R1) = filespec;
	if (!asu64(R1)) goto L7624;
	asu64(R1) = filespec;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7626;
	R1 = tou64("");
	asu64(R2) = filespec;
	R3 = tou64("Can't find MA file ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7626:
	goto L7623;
L7624:
	asu64(R1) = builtinstr;
	s = asu64(R1);
L7623:
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R1) = mm_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("ma");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7628;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA: bad header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7628:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asu64(R1) = s;
	asu64(R1) = mm_modules_findnextlineheader(asu64(R1));
	s = asu64(R1);
L7629:
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7632;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Unexpected EOF in MA file");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
	goto L7630;
L7632:
	asu64(R1) = s;
	asu64(R1) = mm_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	sys = asi64(R1);
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	support = asi64(R1);
	R1 = tou64("end");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7634;
	goto L7630;
L7634:
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 300;
	if (asi64(R1) < asi64(R2)) goto L7636;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many files in MA");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7636:
	asu64(R1) = s;
	asu64(R1) = mm_modules_findnextlineheader(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7638;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA error");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L7638:
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	R1 = (u64)&name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = R1;
	asu64(R3) = pf;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = pf;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&name;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 3;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pf;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = s;
	asu64(R2) = pf;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64("");
	R2 = R1;
	asu64(R3) = pf;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = pf;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = sys;
	asu64(R2) = pf;
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = support;
	asu64(R2) = pf;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = t;
	s = asu64(R1);
	goto L7629;
L7630:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7641;
L7639:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	R1 = 0;
	asu64(R2) = pf;
	R3 = 32;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pf;
	R4 = 48;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= mm_decls_nsourcefiles) goto L7639;
L7641:
	return;
}

static void mm_name_rx_typetable() {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 31;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L7645;
L7643:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7647;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 144;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7649;
	asu64(R1) = d;
	mm_name_do_baseclass(asu64(R1));
L7649:
L7647:
	i += 1; if (i <= mm_decls_ntypes) goto L7643;
L7645:
	return;
}

static void mm_name_rx_unit(u64 owner, u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	u64 a;
	u64 b;
	i64 n;
	i64 oldnoexpand;
	i64 oldnoassem;
	i64 oldtag;
	i64 useparams;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 4: goto L7654;
	case 5: case 6: case 7: case 8: case 10: case 11: case 12: case 13: case 14: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 27: case 28: case 29: case 30: case 31: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: goto L7653;
	case 9: goto L7694;
	case 15: case 16: goto L7677;
	case 17: goto L7686;
	case 18: goto L7682;
	case 26: goto L7657;
	case 32: goto L7659;
	case 49: goto L7658;
	default: goto L7653;
    };
// SWITCH
L7654:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_resolvename(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7656;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L7656;
	asi64(R1) = mm_name_noexpand;
	if (asi64(R1)) goto L7656;
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
L7656:
	goto L7651;
L7657:
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	goto L7651;
L7658:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_resolvedot(asu64(R2), asu64(R1));
	goto L7651;
L7659:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	oldtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7661;
	asi64(R1) = mm_name_noexpand;
	oldnoexpand = asi64(R1);
	R1 = 1;
	mm_name_noexpand = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldnoexpand;
	mm_name_noexpand = asi64(R1);
	goto L7660;
L7661:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L7660:
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unitlist(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7663;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7665;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7666;
	goto L7667;
L7665:
	R1 = 58;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7669;
	asu64(R1) = b;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L7671;
L7670:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L7671:
	asu64(R1) = b;
	if (asu64(R1)) goto L7670;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L7669:
	goto L7664;
L7666:
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7674;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	b = asu64(R1);
	R1 = 0;
	useparams = asi64(R1);
	goto L7673;
L7674:
	R1 = 0;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	useparams = asi64(R1);
L7673:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
	asi64(R1) = useparams;
	if (!asi64(R1)) goto L7676;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7676;
	asi64(R1) = oldtag;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7676:
	goto L7664;
L7667:
L7664:
L7663:
	goto L7651;
L7677:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7679;
	R1 = 18;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L7679:
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7681;
	R1 = 18;
	asu64(R2) = b;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L7681:
	goto L7651;
L7682:
// mm_name.rx_unit.doistruel:
L7683:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7685;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L7685:
	goto L7651;
L7686:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7688;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7689;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7690;
	goto L7691;
L7688:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	R1 = 18;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L7683;
	goto L7687;
L7689:
	R1 = 19;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L7687;
L7690:
	R1 = 18;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L7687;
L7691:
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7693;
	R1 = 19;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L7693:
L7687:
	goto L7651;
L7694:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_resolvename(asu64(R2), asu64(R1));
	asi64(R1) = mm_name_noexpand;
	if (asi64(R1)) goto L7696;
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_name_noassem;
	oldnoassem = asi64(R1);
	R1 = 1;
	mm_name_noassem = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldnoassem;
	mm_name_noassem = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
L7696:
	goto L7651;
L7653:
// mm_name.rx_unit.doabc:
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7700;
L7698:
	asu64(R1) = p;
	R2 = 16;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = owner;
	mm_name_rx_unitlist(asu64(R2), asu64(R1));
	i += 1; if (i <= av_1) goto L7698;
L7700:
L7651:
	return;
}

static i64 mm_name_rx_module(i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	mm_decls_currmoduleno = asi64(R1);
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_decls_stprogram;
	mm_name_rx_passdef(asu64(R2), asu64(R1));
	R1 = 1;
	goto L7701;
L7701:
	return asi64(R1);
}

static void mm_name_rx_deflist(u64 owner, u64 p) {
    u64 R1, R2; 
	u64 pstart;
	asu64(R1) = p;
	pstart = asu64(R1);
	goto L7704;
L7703:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_passdef(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7704:
	asu64(R1) = p;
	if (asu64(R1)) goto L7703;
	return;
}

static void mm_name_rx_passdef(u64 owner, u64 p) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7708;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7708;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7709;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7710;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7711;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7711;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7711;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7711;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7712;
	goto L7713;
L7708:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L7707;
L7709:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	asu64(R1) = p;
	mm_name_currstproc = asu64(R1);
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = 0;
	mm_name_currstproc = asu64(R1);
	goto L7707;
L7710:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L7707;
L7711:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7715;
	asu64(R1) = p;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L7715:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7717;
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L7717:
	goto L7707;
L7712:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L7707;
L7713:
L7707:
	return;
}

static void mm_name_rx_unitlist(u64 owner, u64 p) {
    u64 R1, R2; 
	goto L7720;
L7719:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7720:
	asu64(R1) = p;
	if (asu64(R1)) goto L7719;
	return;
}

static u64 mm_name_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod) {
    u64 R1, R2, R3, R4; 
	i64 extcount;
	i64 subprogno;
	u64 p;
	u64 q;
	u64 powner;
	u64 extdef;
	u64 moddef;
	struct $B1 ambiglist;
	i64 i;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7724;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L7728;
L7725:
	asu64(R1) = q;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stnewname;
	if (asu64(R1) != asu64(R2)) goto L7730;
	asu64(R1) = q;
	goto L7722;
L7730:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7728:
	asu64(R1) = q;
	if (asu64(R1)) goto L7725;
L7724:
	asu64(R1) = stnewname;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = moduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	R1 = 0;
	extcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	moddef = asu64(R2);
	extdef = asu64(R1);
	goto L7734;
L7731:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	powner = asu64(R1);
	asu64(R1) = powner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7736;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7737;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7738;
	goto L7739;
L7736:
	asu64(R1) = powner;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = moduleno;
	if (asi64(R1) != asi64(R2)) goto L7741;
	asu64(R1) = p;
	goto L7722;
	goto L7740;
L7741:
	asu64(R1) = p;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7742;
	asu64(R1) = powner;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L7745;
	asu64(R1) = p;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7745;
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7744;
L7745:
	R1 = (u64)&extcount;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	extdef = asu64(R1);
	asi64(R1) = extcount;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L7747;
	asu64(R1) = extdef;
	R2 = (u64)&ambiglist;
	asi64(R3) = extcount;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L7747:
L7744:
L7742:
L7740:
	goto L7735;
L7737:
	asu64(R1) = powner;
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L7750;
	asu64(R1) = powner;
	asu64(R2) = owner;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L7749;
L7750:
	asu64(R1) = p;
	goto L7722;
L7749:
	goto L7735;
L7738:
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7752;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7752;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7753;
	goto L7754;
L7752:
	asi64(R1) = subprogno;
	R2 = (u64)&mm_decls_moduletosub;
	asu64(R3) = p;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L7756;
	asu64(R1) = p;
	moddef = asu64(R1);
	goto L7755;
L7756:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7759;
L7757:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7761;
	R1 = 1;
	asu64(R2) = p;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 10;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	moddef = asu64(R1);
	goto L7759;
L7761:
	i += 1; if (i <= mm_decls_nsubprogs) goto L7757;
L7759:
L7755:
	goto L7751;
L7753:
	asu64(R1) = p;
	goto L7722;
	goto L7751;
L7754:
L7751:
	goto L7735;
L7739:
L7735:
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7734:
	asu64(R1) = p;
	if (asu64(R1)) goto L7731;
	asi64(R1) = allowmod;
	if (!asi64(R1)) goto L7763;
	asu64(R1) = moddef;
	if (!asu64(R1)) goto L7763;
	asu64(R1) = moddef;
	goto L7722;
L7763:
	asu64(R1) = extdef;
	if (!asu64(R1)) goto L7765;
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L7767;
	R1 = tou64("mclib");
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7769;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7772;
L7770:
	R1 = (u64)&ambiglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	extdef = asu64(R1);
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = extdef;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= extcount) goto L7770;
L7772:
	R1 = tou64("mclib");
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L7774;
	R1 = 0;
	asu64(R2) = extdef;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Ambiguous ext name: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7774:
L7769:
L7767:
	asu64(R1) = extdef;
	goto L7722;
L7765:
	R1 = 0;
	goto L7722;
L7722:
	return asu64(R1);
}

static void mm_name_resolvename(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	i64 moduleno;
	i64 mode;
	i64 islet;
	struct $B15 str;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7777;
	goto L7775;
L7777:
	asi64(R1) = mm_name_allowmodname;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L7779;
	R1 = 0;
	islet = asi64(R1);
	R1 = 0;
	mode = asi64(R1);
	asu64(R1) = p;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L7781;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L7781;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L7781;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7782;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L7782;
	goto L7783;
L7781:
	R1 = 3;
	mode = asi64(R1);
	R1 = 1;
	islet = asi64(R1);
	goto L7780;
L7782:
	R1 = 23;
	mode = asi64(R1);
	goto L7780;
L7783:
L7780:
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7785;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_convucstring(asu64(R1));
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = tou64("pcl:Undefined: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L7784;
L7785:
	asi64(R1) = mode;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_addframevar(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 88;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = islet;
	asu64(R2) = e;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L7784:
L7779:
	asu64(R1) = e;
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 255;
	if (asi64(R1) >= asi64(R2)) goto L7787;
	asu64(R1) = e;
	R2 = 168;
	R1 += (i64)R2;
	(*tou16p(R1)) += 1;
L7787:
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7775:
	return;
}

static u64 mm_name_finddupl(u64 d, u64 pdupl) {
    u64 R1, R2; 
	asu64(R1) = pdupl;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7790;
	asu64(R1) = pdupl;
	goto L7788;
L7790:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
	goto L7792;
L7791:
	asu64(R1) = pdupl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L7795;
	asu64(R1) = pdupl;
	goto L7788;
L7795:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
L7792:
	asu64(R1) = pdupl;
	if (asu64(R1)) goto L7791;
	R1 = 0;
	goto L7788;
L7788:
	return asu64(R1);
}

static u64 mm_name_finddupl_sub(u64 d, u64 pdupl) {
    u64 R1, R2; 
	i64 subprogno;
	asu64(R1) = pdupl;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7798;
	asu64(R1) = pdupl;
	goto L7796;
L7798:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	goto L7800;
L7799:
	asu64(R1) = pdupl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) != asi64(R2)) goto L7803;
	asu64(R1) = pdupl;
	goto L7796;
L7803:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
L7800:
	asu64(R1) = pdupl;
	if (asu64(R1)) goto L7799;
	R1 = 0;
	goto L7796;
L7796:
	return asu64(R1);
}

static void mm_name_resolvedot(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 lhs;
	u64 rhs;
	u64 d;
	u64 e;
	u64 t;
	i64 m;
	i64 moduleno;
	i64 subprogno;
	i64 oldallowmod;
	asu64(R1) = p;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = p;
	R2 = 58;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = rhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asi64(R1) = mm_name_allowmodname;
	oldallowmod = asi64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	mm_name_allowmodname = asi64(R1);
	asu64(R1) = lhs;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldallowmod;
	mm_name_allowmodname = asi64(R1);
	asu64(R1) = lhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7806;
	goto L7807;
L7806:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7809;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7809;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7809;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7809;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7810;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7810;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7810;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7811;
	goto L7812;
L7809:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7814;
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L7814;
	goto L7815;
L7814:
	asu64(R1) = e;
	asu64(R2) = d;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7817;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7819;
	asu64(R1) = e;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L7821;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L7823;
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7823;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need export to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7823:
	goto L7820;
L7821:
	asu64(R1) = e;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = moduleno;
	if (asi64(R1) == asi64(R2)) goto L7824;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7826;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need global to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7826:
L7824:
L7820:
L7819:
// mm_name.resolvedot.domodule:
L7827:
	R1 = 4;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7829;
	goto L7830;
L7829:
	goto L7828;
L7830:
L7828:
	goto L7816;
L7817:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve .#");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7816:
	goto L7808;
L7810:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7832;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7833;
	goto L7834;
L7832:
	goto L7831;
L7833:
L7835:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7838;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7839;
	goto L7840;
L7838:
	goto L7836;
	goto L7837;
L7839:
	goto L7837;
L7840:
	R1 = 0;
	R2 = tou64("2:Record expected");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7837:
	goto L7835;
L7836:
	goto L7831;
L7834:
	R1 = 0;
	R2 = tou64("Record expected");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7831:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	t = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = t;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7842;
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7841;
L7842:
	R1 = 0;
	asu64(R2) = rhs;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7841:
	goto L7808;
L7811:
// mm_name.resolvedot.dosubprogid:
L7815:
	asu64(R1) = e;
	asu64(R2) = d;
	asu64(R1) = mm_name_finddupl_sub(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7844;
	asu64(R1) = e;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L7846;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L7848;
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7848;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need export to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7848:
L7846:
	goto L7827;
	goto L7843;
L7844:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve sub.#");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7843:
	goto L7808;
L7812:
L7808:
	goto L7805;
L7807:
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L7850;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7850:
L7805:
	return;
}

static void mm_name_fixmode(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 pmode;
	u64 a;
	u64 d;
	u64 e;
	u64 f;
	u64 owner;
	i64 m;
	i64 moduleno;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pmode = asu64(R1);
	asu64(R1) = pmode;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	owner = asu64(R2);
	d = asu64(R1);
	goto L7853;
L7852:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7853:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7852;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7856;
	asu64(R1) = d;
	if (!asu64(R1)) goto L7856;
	R1 = 0;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
L7856:
	asu64(R1) = e;
	if (!asu64(R1)) goto L7858;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7858;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	goto L7857;
L7858:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("2:Can't resolve tentative type: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L7857:
	return;
}

static void mm_name_fixusertypes() {
    u64 R1, R2; 
	u64 p;
	i64 npasses;
	i64 notresolved;
	u64 d;
	i64 i;
	R1 = 0;
	npasses = asi64(R1);
L7860:
	R1 = (u64)&npasses;
	(*toi64p(R1)) += 1;
	R1 = 0;
	notresolved = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypenames;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7865;
L7863:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = i;
	R1 += (i64)R2*32;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7867;
	R1 = (u64)&mm_decls_typenamepos;
	asi64(R2) = i;
	R1 += (i64)R2*4;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	mm_name_fixmode(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7869;
	R1 = (u64)&notresolved;
	(*toi64p(R1)) += 1;
L7869:
L7867:
	i += 1; if (i <= mm_decls_ntypenames) goto L7863;
L7865:
	asi64(R1) = npasses;
	R2 = 5;
	if (asi64(R1) <= asi64(R2)) goto L7871;
	msysc_m$print_startcon();
	R1 = tou64("Type phase errors - check these user types:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypenames;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7874;
L7872:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = i;
	R1 += (i64)R2*32;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7876;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7878;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7878:
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7876:
	i += 1; if (i <= mm_decls_ntypenames) goto L7872;
L7874:
	R1 = 0;
	R2 = tou64("Fixtypes: too many passes (cyclic ref?)");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7871:
	asi64(R1) = notresolved;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7860;
	return;
}

static u64 mm_name_addframevar(u64 owner, u64 d, i64 moduleno, i64 mode) {
    u64 R1, R2, R3; 
	u64 e;
	R1 = 11;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = mode;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = e;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = e;
	goto L7879;
L7879:
	return asu64(R1);
}

static u64 mm_name_copylistunit(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plist;
	u64 plistx;
	R1 = 0;
	R2 = R1;
	plistx = asu64(R2);
	plist = asu64(R1);
	goto L7882;
L7881:
	asu64(R1) = p;
	asu64(R1) = mm_name_copyunit(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&plistx;
	R3 = (u64)&plist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7882:
	asu64(R1) = p;
	if (asu64(R1)) goto L7881;
	asu64(R1) = plist;
	goto L7880;
L7880:
	return asu64(R1);
}

static u64 mm_name_copyunit(u64 p) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 q;
	u64 d;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7886;
	R1 = 0;
	goto L7884;
L7886:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7888;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_name_nmacroparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7891;
L7889:
	R1 = (u64)&mm_name_macroparamsgen;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L7893;
	R1 = (u64)&mm_name_macroargs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mm_name_copyunit(asu64(R1));
	goto L7884;
	goto L7891;
L7893:
	i += 1; if (i <= mm_name_nmacroparams) goto L7889;
L7891:
L7888:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = q;
	*(struct $B60*)(R2) = (R1_B60);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7896;
L7894:
	asu64(R1) = q;
	R2 = 16;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mm_name_copylistunit(asu64(R1));
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= av_1) goto L7894;
L7896:
	asu64(R1) = q;
	goto L7884;
L7884:
	return asu64(R1);
}

static void mm_name_replaceunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B60 R1_B60; 
	u64 pnext;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pnext = asu64(R1);
	asu64(R1) = q;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = p;
	*(struct $B60*)(R2) = (R1_B60);
	asu64(R1) = pnext;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_name_expandmacro(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	u64 pm;
	u64 pnew;
	i64 ignoreargs;
	asi64(R1) = mm_name_macrolevels;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L7900;
	R1 = 0;
	R2 = tou64("Too many macro levels (recursive macro?)");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7900:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	mm_name_nmacroparams = asi64(R1);
	goto L7902;
L7901:
	asi64(R1) = mm_name_nmacroparams;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L7905;
	R1 = 0;
	R2 = tou64("macro param overflow");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7905:
	asu64(R1) = pm;
	R2 = (u64)&mm_name_macroparams;
	R3 = (u64)&mm_name_nmacroparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_name_macroparamsgen;
	asi64(R3) = mm_name_nmacroparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L7902:
	asu64(R1) = pm;
	if (asu64(R1)) goto L7901;
	R1 = 0;
	mm_name_nmacroargs = asi64(R1);
	goto L7907;
L7906:
	asi64(R1) = mm_name_nmacroargs;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L7910;
	R1 = 0;
	R2 = tou64("macro arg overflow");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7910:
	asu64(R1) = b;
	R2 = (u64)&mm_name_macroargs;
	R3 = (u64)&mm_name_nmacroargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L7907:
	asu64(R1) = b;
	if (asu64(R1)) goto L7906;
	asi64(R1) = mm_name_nmacroargs;
	asi64(R2) = mm_name_nmacroparams;
	if (asi64(R1) >= asi64(R2)) goto L7912;
	msysc_m$print_startcon();
	R1 = tou64("NMACROARGS=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_name_nmacroargs;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mm_name_nmacroparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Too few macro args");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7912:
	R1 = 0;
	ignoreargs = asi64(R1);
	asi64(R1) = mm_name_nmacroargs;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7914;
	asi64(R1) = mm_name_nmacroparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7914;
	R1 = 1;
	ignoreargs = asi64(R1);
	R1 = 0;
	R2 = R1;
	mm_name_nmacroparams = asi64(R2);
	mm_name_nmacroargs = asi64(R1);
	goto L7913;
L7914:
	asi64(R1) = mm_name_nmacroargs;
	asi64(R2) = mm_name_nmacroparams;
	if (asi64(R1) <= asi64(R2)) goto L7915;
	R1 = 0;
	R2 = tou64("Too many macro args");
	mm_support_rxerror(asu64(R2), asu64(R1));
L7915:
L7913:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_name_copyunit(asu64(R1));
	pnew = asu64(R1);
	asi64(R1) = ignoreargs;
	if (asi64(R1)) goto L7917;
	asu64(R1) = pnew;
	asu64(R2) = p;
	mm_name_replaceunit(asu64(R2), asu64(R1));
	goto L7916;
L7917:
	asu64(R1) = pnew;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7916:
	return;
}

static void mm_name_duplfield(u64 owner, u64 p, u64 q) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7920;
	R1 = tou64("DUPLFIELD");
	mm_support_serror(asu64(R1));
L7920:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 92;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	R2 = 136;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 72;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void mm_name_do_baseclass(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 newd;
	u64 dbase;
	i64 normalexit;
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = p;
	R3 = 144;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	dbase = asu64(R1);
	asu64(R1) = dbase;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7923;
L7922:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 1;
	normalexit = asi64(R1);
	goto L7926;
L7925:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7929;
	R1 = 0;
	normalexit = asi64(R1);
	goto L7927;
L7929:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L7926:
	asu64(R1) = e;
	if (asu64(R1)) goto L7925;
L7927:
	asi64(R1) = normalexit;
	if (!asi64(R1)) goto L7931;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7933;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7933;
	goto L7934;
L7933:
	R1 = 17;
	asu64(R2) = d;
	asu64(R3) = p;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = newd;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7932;
L7934:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	asu64(R3) = p;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = d;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_name_duplfield(asu64(R3), asu64(R2), asu64(R1));
L7932:
	asu64(R1) = newd;
	asu64(R2) = p;
	mm_lib_adddef(asu64(R2), asu64(R1));
L7931:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7923:
	asu64(R1) = d;
	if (asu64(R1)) goto L7922;
	return;
}

static i64 mm_parse_parsemodule(u64 pm) {
    u64 R1, R2; 
	u64 owner;
	mm_parse_initparser();
	asu64(R1) = pm;
	R2 = 16;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	mm_decls_currmoduleno = asi64(R1);
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_decls_stmodule = asu64(R1);
	asu64(R1) = mm_decls_stmodule;
	mm_decls_currproc = asu64(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lex_startlex(asu64(R1));
	asu64(R1) = mm_decls_stmodule;
	owner = asu64(R1);
	mm_lex_lex();
	asu64(R1) = owner;
	mm_parse_readmoduledefs(asu64(R1));
	R1 = 1;
	goto L7935;
L7935:
	return asi64(R1);
}

static void mm_parse_readmoduledefs(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	i64 globalflag;
	R1 = 0;
	globalflag = asi64(R1);
L7937:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L7968;
	case 2: case 3: case 5: case 6: case 7: case 8: case 9: case 10: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 110: case 112: case 113: case 118: case 119: case 124: case 127: case 128: case 129: case 130: case 131: goto L7941;
	case 4: goto L7956;
	case 11: case 79: case 80: case 117: case 121: goto L7948;
	case 59: goto L7957;
	case 67: goto L7969;
	case 108: case 109: goto L7947;
	case 111: goto L7954;
	case 114: goto L7951;
	case 115: goto L7959;
	case 116: goto L7952;
	case 120: goto L7950;
	case 122: goto L7958;
	case 123: goto L7953;
	case 125: goto L7964;
	case 126: goto L7942;
	case 132: goto L7955;
	default: goto L7941;
    };
// SWITCH
L7942:
	asi64(R1) = globalflag;
	if (!asi64(R1)) goto L7944;
	R1 = tou64("global global?");
	mm_support_serror(asu64(R1));
L7944:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	globalflag = asi64(R1);
	asi64(R1) = globalflag;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7946;
	asu64(R1) = mm_decls_stmodule;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_nsubprogs;
	if (asi64(R1) == asi64(R2)) goto L7946;
	R1 = 2;
	globalflag = asi64(R1);
L7946:
	mm_lex_lex();
	goto L7939;
L7947:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7939;
L7948:
// mm_parse.readmoduledefs.dovar:
L7949:
	R1 = 0;
	R2 = 10;
	R3 = 0;
	asi64(R4) = globalflag;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7939;
L7950:
	mm_lex_lex();
	R1 = 120;
	R2 = 10;
	R3 = 0;
	asi64(R4) = globalflag;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7939;
L7951:
	asu64(R1) = owner;
	mm_parse_readimportmodule(asu64(R1));
	goto L7939;
L7952:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7939;
L7953:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7939;
L7954:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7939;
L7955:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7939;
L7956:
	mm_lex_lex();
	goto L7939;
L7957:
	goto L7938;
	goto L7939;
L7958:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L7939;
L7959:
L7960:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L7963;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L7960;
L7963:
	R1 = 0;
	R2 = 0;
	R3 = 115;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L7939;
L7964:
L7965:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L7965;
	goto L7939;
L7968:
	R1 = tou64("MODULE/DOT");
	mm_support_serror(asu64(R1));
	goto L7939;
L7969:
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L7971;
	goto L7949;
L7971:
	goto L7972;
	goto L7939;
L7941:
// mm_parse.readmoduledefs.doexec:
L7972:
	R1 = tou64("Code outside a function");
	mm_support_serror(asu64(R1));
L7939:
	goto L7937;
L7938:
	return;
}

static void mm_parse_initparser() {
    u64 R1; 
	u64 tabledataname;
	asu64(R1) = mm_decls_nullunit;
	if (asu64(R1)) goto L7975;
	R1 = 2;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	mm_decls_nullunit = asu64(R1);
L7975:
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	R1 = 0;
	mm_parse_varattribs = asi64(R1);
	R1 = 0;
	mm_parse_intabledata = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 0;
	mm_parse_inparamlist = asi64(R1);
	R1 = 0;
	mm_parse_inrecordbody = asi64(R1);
	R1 = 0;
	mm_parse_inimportmodule = asi64(R1);
	R1 = tou64("");
	tabledataname = asu64(R1);
	R1 = 0;
	mm_parse_labelseen = asi64(R1);
	R1 = 0;
	mm_parse_ndollar = asi64(R1);
	return;
}

static void mm_parse_skipsemi() {
    u64 R1, R2; 
	goto L7978;
L7977:
	mm_lex_lex();
L7978:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7977;
	return;
}

static u64 mm_parse_makeblock(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L7982;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7982;
	asu64(R1) = p;
	goto L7980;
L7982:
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L7980;
L7980:
	return asu64(R1);
}

static void mm_parse_checkequals() {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L7985;
	R1 = tou64("\"=\" expected");
	mm_support_serror(asu64(R1));
L7985:
	return;
}

static i64 mm_parse_getcurrline() {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	goto L7986;
L7986:
	return asi64(R1);
}

static i64 mm_parse_checkbegin(i64 fbrack) {
    u64 R1, R2; 
	i64 closesym;
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L7989;
	asi64(R1) = fbrack;
	if (!asi64(R1)) goto L7989;
	R1 = 10;
	closesym = asi64(R1);
	mm_lex_lex();
	goto L7988;
L7989:
	R1 = 87;
	closesym = asi64(R1);
L7988:
	asi64(R1) = closesym;
	goto L7987;
L7987:
	return asi64(R1);
}

static void mm_parse_checkbeginend(i64 closesym, i64 kwd, i64 startline) {
    u64 R1, R2, R3, R4; 
	mm_parse_skipsemi();
	asi64(R1) = closesym;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L7992;
	asi64(R1) = closesym;
	mm_parse_checksymbollex(asi64(R1));
	goto L7991;
L7992:
	asi64(R1) = startline;
	R2 = 0;
	asi64(R3) = kwd;
	asi64(R4) = closesym;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L7991:
	return;
}

static void mm_parse_checkend(i64 endsym, i64 endkwd1, i64 endkwd2, i64 startline) {
    u64 R1, R2, R3; 
	struct $B5 str;
	mm_parse_skipsemi();
	asi64(R1) = endsym;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L7995;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L7995;
	goto L7993;
L7995:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L7997;
	R1 = tou64("'End' expected");
	mm_support_serror(asu64(R1));
L7997:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7999;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L8002;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L8001;
L8002:
	mm_lex_lex();
	goto L7993;
	goto L8000;
L8001:
// mm_parse.checkend.error:
	R1 = tou64("Mismatched end ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = startline;
	if (!asi64(R1)) goto L8005;
	R1 = (u64)&str;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" (from line #)");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = startline;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L8005:
	R1 = (u64)&str;
	mm_support_serror(asu64(R1));
L8000:
L7999:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L8008;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L8007;
L8008:
	mm_lex_lex();
L8007:
L7993:
	return;
}

static u64 mm_parse_readvardef(u64 owner, i64 scope, i64 isstatic, i64 varid, i64 k) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 nvars;
	i64 m;
	i64 initcode;
	u64 stname;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8011;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	m = asi64(R1);
	goto L8010;
L8011:
	R1 = tou64("Readvar?");
	mm_support_serror(asu64(R1));
L8010:
	R1 = 0;
	nvars = asi64(R1);
	goto L8013;
L8012:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	asi64(R1) = varid;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stname;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = isstatic;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = k;
	R2 = 120;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = varid;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L8016;
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 11;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8016:
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = varid;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8018;
	asu64(R1) = stname;
	mm_lib_addstatic(asu64(R1));
L8018:
	mm_lex_lex();
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8021;
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L8020;
L8021:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8023;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8024;
	goto L8025;
L8023:
	R1 = 1;
	initcode = asi64(R1);
	goto L8022;
L8024:
	R1 = 2;
	initcode = asi64(R1);
	goto L8022;
L8025:
	R1 = 3;
	initcode = asi64(R1);
L8022:
	R1 = 1;
	asu64(R2) = stname;
	R3 = 168;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8027;
	asi64(R1) = varid;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8029;
	R1 = tou64("Non-variants can't use :=");
	mm_support_serror(asu64(R1));
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8031;
	R1 = tou64("Can't use := for statics inside procs");
	mm_support_serror(asu64(R1));
L8031:
L8029:
	goto L8026;
L8027:
	asi64(R1) = varid;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8033;
	R1 = tou64("Need 'static' for '='");
	mm_support_serror(asu64(R1));
	asu64(R1) = stname;
	mm_lib_addstatic(asu64(R1));
L8033:
L8026:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = initcode;
	asu64(R2) = stname;
	R3 = 171;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = varid;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8035;
	asu64(R1) = stname;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	asu64(R2) = mm_lib_createname(asu64(R2));
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 59;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8035:
	goto L8019;
L8020:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8036;
	asi64(R1) = k;
	R2 = 120;
	if (asi64(R1) != asi64(R2)) goto L8038;
	R1 = tou64("let@");
	mm_support_serror(asu64(R1));
L8038:
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8019;
L8036:
	asi64(R1) = k;
	R2 = 120;
	if (asi64(R1) != asi64(R2)) goto L8039;
	R1 = tou64("let needs :=/=");
	mm_support_serror(asu64(R1));
L8039:
L8019:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8041;
	goto L8014;
L8041:
	mm_lex_lex();
L8013:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8012;
L8014:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8043;
	R1 = tou64("No vars declared");
	mm_support_serror(asu64(R1));
L8043:
	asu64(R1) = ulist;
	goto L8009;
L8009:
	return asu64(R1);
}

static void mm_parse_readconstdef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	i64 nconsts;
	i64 deft;
	i64 m;
	u64 stname;
	mm_lex_lex();
	R1 = 0;
	nconsts = asi64(R1);
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8046;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	deft = asi64(R1);
	goto L8045;
L8046:
	R1 = 22;
	deft = asi64(R1);
L8045:
	goto L8048;
L8047:
	R1 = 9;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = deft;
	m = asi64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nconsts;
	(*toi64p(R1)) += 1;
	asi64(R1) = scope;
	asu64(R2) = stname;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8051;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L8051;
	asu64(R1) = stname;
	mm_lib_addexpconst(asu64(R1));
L8051:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8053;
	goto L8049;
L8053:
	mm_lex_lex();
L8048:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8047;
L8049:
	asi64(R1) = nconsts;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8055;
	R1 = tou64("No consts declared");
	mm_support_serror(asu64(R1));
L8055:
	return;
}

static u64 mm_parse_readlbrack() {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	u64 plower;
	i64 oldirp;
	i64 length;
	i64 usecomma;
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	plower = asu64(R1);
	R1 = 0;
	length = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8058;
	mm_lex_lex();
	asi64(R1) = mm_parse_inreadprint;
	oldirp = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	plower = asu64(R1);
	asi64(R1) = oldirp;
	mm_parse_inreadprint = asi64(R1);
	R1 = 5;
	mm_parse_checksymbollex(asi64(R1));
	goto L8057;
L8058:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8059;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8059;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	plower = asu64(R1);
	mm_lex_lex();
	mm_lex_lex();
	goto L8057;
L8059:
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8060;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8060;
	R1 = 63;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	mm_lex_lex();
	asu64(R1) = p;
	goto L8056;
	goto L8057;
L8060:
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8061;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8061;
	R1 = 63;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	R1 = 10;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = p;
	goto L8056;
L8061:
L8057:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8063;
	goto L8064;
L8063:
	mm_lex_lex();
	R1 = 20;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8056;
	goto L8062;
L8064:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
L8062:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8066;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8067;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8068;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8069;
	goto L8070;
L8066:
	mm_lex_lex();
	asu64(R1) = p;
	goto L8056;
	goto L8065;
L8067:
	R1 = 1;
	usecomma = asi64(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8072;
	mm_lex_lex();
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L8056;
L8072:
// mm_parse.readlbrack.docomma:
L8073:
	R1 = 1;
	length = asi64(R1);
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asi64(R1) = usecomma;
	if (!asi64(R1)) goto L8075;
L8076:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8080;
	goto L8078;
L8080:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8082;
	R1 = tou64(",, null expr not allowed");
	mm_support_serror(asu64(R1));
L8082:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8076;
L8078:
	goto L8074;
L8075:
L8083:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8087;
	goto L8085;
L8087:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8089;
	R1 = tou64(",, null expr not allowed");
	mm_support_serror(asu64(R1));
L8089:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8083;
L8085:
L8074:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = ulist;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L8056;
	goto L8065;
L8068:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8091;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8092;
	goto L8093;
L8091:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = q;
	asu64(R3) = p;
	asu64(R3) = mm_parse_fixcond(asu64(R3));
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 48;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L8056;
	goto L8090;
L8092:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = q;
	asu64(R3) = p;
	asu64(R3) = mm_parse_fixcond(asu64(R3));
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 48;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L8056;
	goto L8090;
L8093:
L8090:
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8095;
L8096:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8096;
	R1 = 16;
	mm_parse_checksymbol(asi64(R1));
	goto L8094;
L8095:
	mm_lex_lex();
L8094:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = ulist;
	asu64(R3) = p;
	R4 = 112;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L8056;
	goto L8065;
L8069:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8100;
	R1 = 0;
	usecomma = asi64(R1);
	goto L8073;
L8100:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L8101:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8105;
	goto L8103;
L8105:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8101;
L8103:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = ulist;
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	goto L8056;
	goto L8065;
L8070:
	R1 = tou64("(x ...");
	mm_support_serror(asu64(R1));
L8065:
	R1 = 0;
	goto L8056;
L8056:
	return asu64(R1);
}

static void mm_parse_addlistparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8108;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L8107;
L8108:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 152;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8107:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static u64 mm_parse_readcast() {
    u64 R1, R2, R3; 
	u64 p;
	i64 opc;
	i64 t;
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8111;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8112;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8113;
	goto L8114;
L8111:
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 26;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L8109;
	goto L8110;
L8112:
	R1 = 61;
	opc = asi64(R1);
	mm_lex_lex();
	goto L8110;
L8113:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L8116;
	mm_lex_lex();
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 26;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	mm_lex_lex();
	goto L8115;
L8116:
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L8115:
	asu64(R1) = p;
	goto L8109;
	goto L8110;
L8114:
	R1 = 58;
	opc = asi64(R1);
L8110:
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = mm_decls_currproc;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	goto L8109;
L8109:
	return asu64(R1);
}

static u64 mm_parse_readopc() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	i64 tag;
	i64 opc;
	i64 firstsym;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	firstsym = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L8119;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L8120;
	goto L8121;
L8119:
	R1 = 36;
	tag = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L8118;
L8120:
	R1 = 35;
	tag = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L8118;
L8121:
	R1 = 36;
	tag = asi64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
L8118:
	mm_lex_lex();
	asi64(R1) = firstsym;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L8123;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L8124;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L8125;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L8125;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L8125;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L8125;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L8125;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8125;
	goto L8126;
L8123:
	asu64(R1) = mm_parse_readterm2();
	goto L8117;
	goto L8122;
L8124:
	R1 = 60;
	opc = asi64(R1);
	goto L8122;
L8125:
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L8128;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8130;
	R1 = tou64("Needs (x,y)");
	mm_support_serror(asu64(R1));
L8130:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L8117;
	goto L8127;
L8128:
	R1 = tou64("READOPC/SINGLE OPND?");
	mm_support_serror(asu64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L8117;
L8127:
	goto L8122;
L8126:
	R1 = (u64)&mm_tables_symboloptypes;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8132;
	R1 = tou64("Can't be used as unary op");
	mm_support_serror(asu64(R1));
L8132:
L8122:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8134;
	mm_lex_lex();
	R1 = 39;
	tag = asi64(R1);
	asi64(R1) = firstsym;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L8136;
	goto L8137;
L8136:
	R1 = 105;
	opc = asi64(R1);
	goto L8135;
L8137:
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8139;
	R1 = tou64("op:= not available");
	mm_support_serror(asu64(R1));
L8139:
L8135:
L8134:
	asu64(R1) = mm_parse_readterm2();
	R2 = R1;
	q = asu64(R2);
	asi64(R2) = tag;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L8141;
	R1 = tou64("Too many opnds");
	mm_support_serror(asu64(R1));
L8141:
	asu64(R1) = p;
	goto L8117;
L8117:
	return asu64(R1);
}

static u64 mm_parse_readcompilervar() {
    u64 R1, R2, R3; 
	struct $B5 str;
	struct $B13 tm;
	u64 p;
	u64 currmodule;
// PROC LOCAL STATICS GO HERE
	static struct $B28 mm_parse_readcompilervar_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = mm_decls_currmoduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	currmodule = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 71: goto L8149;
	case 72: goto L8150;
	case 73: goto L8151;
	case 74: goto L8152;
	case 75: goto L8153;
	case 76: goto L8154;
	case 77: goto L8155;
	case 78: goto L8156;
	case 79: goto L8145;
	case 80: goto L8146;
	case 81: goto L8147;
	case 82: goto L8148;
	case 83: case 84: goto L8157;
	default: goto L8145;
    };
// SWITCH
L8146:
	R1 = 7;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8142;
	goto L8143;
L8147:
	R1 = 1;
	asr64(R2) = 3.141592653589793100e+000;
	asi64(R2) = asi64(R2);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8142;
	goto L8143;
L8148:
	R1 = 1;
	asr64(R2) = (1.0/0.0);
	asi64(R2) = asi64(R2);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8142;
	goto L8143;
L8149:
	R1 = 3;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asu64(R2) = mm_support_getlineno(asu64(R2));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8142;
	goto L8143;
L8150:
	R1 = (u64)&str;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asi64(R2) = mm_support_getlineno(asu64(R2));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L8143;
L8151:
	asu64(R1) = mm_decls_stmodule;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8143;
L8152:
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = currmodule;
	R3 = 20;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8143;
L8153:
	asu64(R1) = mm_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8143;
L8154:
	R1 = (u64)&tm;
	mlinux_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_parse_readcompilervar_monthnames;
	R2 = (u64)&tm;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L8143;
L8155:
	R1 = (u64)&tm;
	mlinux_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L8143;
L8156:
	R1 = tou64("Compiler:M6.4");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8143;
L8157:
	R1 = 6;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 83;
	asi64(R2) = asi64(R2)  ==  asi64(R3);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L8142;
	goto L8143;
L8145:
	R1 = (u64)&mm_tables_jtagnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("compiler var not impl: #");
	mm_support_serror_s(asu64(R2), asu64(R1));
L8143:
	mm_lex_lex();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R2) = mlib_pcm_copyheapstring(asu64(R2));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	goto L8142;
L8142:
	return asu64(R1);
}

static u64 mm_parse_readcastx() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 m;
	u64 p;
	mm_lex_lex();
	R1 = 58;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8160;
	R1 = 61;
	opc = asi64(R1);
	mm_lex_lex();
L8160:
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	m = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8162;
	asi64(R1) = opc;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L8164;
	R1 = tou64("@ type missing");
	mm_support_serror(asu64(R1));
L8164:
	R1 = 60;
	opc = asi64(R1);
	goto L8161;
L8162:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	m = asi64(R1);
L8161:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = mm_decls_currproc;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	goto L8158;
L8158:
	return asu64(R1);
}

static void mm_parse_checksymbol(i64 symbol) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L8167;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	asi64(R2) = symbol;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	mm_support_serror(asu64(R1));
L8167:
	return;
}

static void mm_parse_lexchecksymbol(i64 symbol) {
    u64 R1; 
	mm_lex_lex();
	asi64(R1) = symbol;
	mm_parse_checksymbol(asi64(R1));
	return;
}

static void mm_parse_checksymbollex(i64 symbol) {
    u64 R1; 
	asi64(R1) = symbol;
	mm_parse_checksymbol(asi64(R1));
	mm_lex_lex();
	return;
}

static i64 mm_parse_readtypespec(u64 owner, i64 typedefx) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	i64 t;
	i64 kwd;
	i64 sltype;
	i64 w;
	u64 x;
	u64 pupper;
	u64 plx;
	u64 dim;
	u64 length;
	struct $B84 dims;
	i64 ndims;
	i64 i;
	i64 n;
	i64 k;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8172;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L8173;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8174;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L8175;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L8175;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L8176;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L8177;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L8178;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L8179;
	goto L8180;
L8172:
// mm_parse.readtypespec.arraybounds:
	mm_lex_lex();
	R1 = 0;
	ndims = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
L8182:
	R1 = 0;
	length = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8186;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8185;
L8186:
	R1 = 0;
	dim = asu64(R1);
	goto L8184;
L8185:
	asu64(R1) = mm_parse_readunit();
	dim = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8188;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8188;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8189;
	goto L8190;
L8188:
	goto L8187;
L8189:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8192;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8192;
	asu64(R1) = mm_parse_readunit();
	length = asu64(R1);
	asu64(R1) = length;
	asu64(R2) = dim;
	R3 = 27;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	dim = asu64(R1);
	goto L8191;
L8192:
	asu64(R1) = dim;
	R2 = 27;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	dim = asu64(R1);
L8191:
	goto L8187;
L8190:
L8187:
L8184:
	asi64(R1) = ndims;
	R2 = 30;
	if (asi64(R1) < asi64(R2)) goto L8194;
	R1 = tou64("Too many array dims");
	mm_support_serror(asu64(R1));
L8194:
	asu64(R1) = dim;
	R2 = (u64)&dims;
	R3 = (u64)&ndims;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8196;
	goto L8183;
L8196:
	mm_lex_lex();
	goto L8182;
L8183:
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 12;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = ndims;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8199;
L8197:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8201;
	asi64(R1) = typedefx;
	goto L8200;
L8201:
	R1 = 0;
L8200:
	R2 = (u64)&dims;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R3) = t;
	asu64(R4) = owner;
	asi64(R1) = mm_lib_createarraymode(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	t = asi64(R1);
	i += -1; if (i >= 1) goto L8197;
L8199:
	asi64(R1) = t;
	goto L8170;
	goto L8171;
L8173:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	mm_lex_lex();
	goto L8171;
L8174:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8203;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	t = asi64(R1);
	mm_lex_lex();
	goto L8202;
L8203:
	asu64(R1) = d;
	R2 = 0;
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	t = asi64(R1);
L8202:
	goto L8171;
L8175:
	R1 = tou64("Use 'record name =' syntax");
	mm_support_serror(asu64(R1));
	goto L8171;
L8176:
	R1 = tou64("Top-level union not allowed");
	mm_support_serror(asu64(R1));
	goto L8171;
L8177:
// mm_parse.readtypespec.retry:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) != asi64(R2)) goto L8206;
	mm_lex_lex();
L8206:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L8208;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L8208;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L8209;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L8210;
	goto L8211;
L8208:
	asi64(R1) = typedefx;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readrefproc(asu64(R2), asi64(R1));
	t = asi64(R1);
	goto L8207;
L8209:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8213;
	goto L8214;
L8213:
	R1 = 20;
	t = asi64(R1);
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L8216;
	R1 = 12;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8216:
	goto L8212;
L8214:
	goto L8217;
L8212:
	mm_lex_lex();
	goto L8207;
L8210:
	mm_lex_lex();
	R1 = 0;
	t = asi64(R1);
	goto L8218;
	goto L8207;
L8211:
// mm_parse.readtypespec.readtarget:
L8217:
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
// mm_parse.readtypespec.gottarget:
L8218:
	asi64(R1) = typedefx;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	t = asi64(R1);
L8207:
	goto L8171;
L8178:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L8220;
	R1 = 20;
	t = asi64(R1);
	goto L8219;
L8220:
	R1 = 7;
	t = asi64(R1);
L8219:
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L8222;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8222:
	mm_lex_lex();
	goto L8171;
L8179:
	asi64(R1) = typedefx;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_parse_readslicetype(asu64(R3), asi64(R2), asi64(R1));
	t = asi64(R1);
	goto L8171;
L8180:
	R1 = tou64("Bad type starter");
	mm_support_serror(asu64(R1));
L8171:
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L8224;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8224:
	asi64(R1) = t;
	goto L8170;
L8170:
	return asi64(R1);
}

static i64 mm_parse_readslicetype(u64 owner, i64 slicetype, i64 typedefx) {
    u64 R1, R2, R3, R4, R5; 
	u64 plower;
	i64 t;
	R1 = 11;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8227;
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	plower = asu64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 5;
	mm_parse_checksymbol(asi64(R1));
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L8226;
L8227:
	R1 = 0;
	plower = asu64(R1);
L8226:
	mm_lex_lex();
	asi64(R1) = typedefx;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = typedefx;
	asu64(R2) = plower;
	asi64(R3) = t;
	asi64(R4) = slicetype;
	asu64(R5) = owner;
	asi64(R1) = mm_lib_createslicemode(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L8225;
L8225:
	return asi64(R1);
}

static u64 mm_parse_readslist(i64 iscall, i64 donulls) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	i64 oldinparamlist;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8230;
	asu64(R1) = ulist;
	goto L8228;
L8230:
	asi64(R1) = mm_parse_inparamlist;
	oldinparamlist = asi64(R1);
	asi64(R1) = iscall;
	mm_parse_inparamlist = asi64(R1);
L8231:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8234;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8235;
	goto L8236;
L8234:
	asi64(R1) = donulls;
	if (!asi64(R1)) goto L8238;
	R1 = 2;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L8237;
L8238:
	R1 = tou64("null comma expr not allowed");
	mm_support_serror(asu64(R1));
L8237:
	mm_lex_lex();
	goto L8233;
L8235:
	asi64(R1) = donulls;
	if (!asi64(R1)) goto L8240;
	asu64(R1) = mm_decls_nullunit;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8240:
	goto L8232;
	goto L8233;
L8236:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8243;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8242;
L8243:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8245;
	goto L8232;
L8245:
	goto L8241;
L8242:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8247;
	goto L8232;
L8247:
	R1 = tou64("SLIST?");
	mm_support_serror(asu64(R1));
L8241:
L8233:
	goto L8231;
L8232:
	asi64(R1) = oldinparamlist;
	mm_parse_inparamlist = asi64(R1);
	asu64(R1) = ulist;
	goto L8228;
L8228:
	return asu64(R1);
}

static u64 mm_parse_readindex(u64 p, i64 dot) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plower;
	u64 pupper;
	mm_lex_lex();
	asi64(R1) = dot;
	if (asi64(R1)) goto L8250;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8252;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L8253;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8253;
	goto L8254;
L8252:
// mm_parse.readindex.fullslice:
L8255:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	plower = asu64(R1);
	R1 = 3;
	asu64(R2) = plower;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	pupper = asu64(R1);
	R1 = 4;
	asu64(R2) = pupper;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pupper;
	asu64(R2) = plower;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 48;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L8248;
	goto L8251;
L8253:
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L8255;
	goto L8251;
L8254:
L8251:
L8250:
L8256:
	asi64(R1) = mm_parse_ndollar;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L8259;
	R1 = tou64("Too many nested a[$]");
	mm_support_serror(asu64(R1));
L8259:
	asu64(R1) = p;
	R2 = (u64)&mm_parse_dollarstack;
	R3 = (u64)&mm_parse_ndollar;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_parse_ndollar;
	(*toi64p(R1)) -=1;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8261;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = dot;
	if (!asi64(R3)) goto L8263;
	R3 = 52;
	goto L8262;
L8263:
	R3 = 48;
L8262:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8260;
L8261:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = dot;
	if (!asi64(R3)) goto L8265;
	R3 = 51;
	goto L8264;
L8265:
	R3 = 46;
L8264:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8260:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8267;
	goto L8257;
L8267:
	mm_lex_lex();
	goto L8256;
L8257:
	R1 = 12;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	goto L8248;
L8248:
	return asu64(R1);
}

static u64 mm_parse_readdotsuffix(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 p2;
	goto L8270;
L8269:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8273;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8274;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L8275;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L8276;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L8277;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L8278;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L8279;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L8280;
	goto L8281;
L8273:
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = mm_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L8272;
L8274:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = p;
	R3 = 49;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L8272;
L8275:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8283;
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8285;
	R1 = 9;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asu64(R2) = r;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8284;
L8285:
	R1 = 3;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = r;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8284:
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p2 = asu64(R1);
	asu64(R1) = p2;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L8282;
L8283:
// mm_parse.readdotsuffix.doprop:
L8286:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8282:
	mm_lex_lex();
	goto L8272;
L8276:
	asu64(R1) = p;
	R2 = 68;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	goto L8272;
L8277:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L8288;
	goto L8289;
L8288:
	goto L8287;
L8289:
	R1 = tou64("RDS:TYPEOF");
	mm_support_serror(asu64(R1));
L8287:
	mm_lex_lex();
	goto L8272;
L8278:
	R1 = 10;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8286;
	goto L8272;
L8279:
	R1 = 9;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8286;
	goto L8272;
L8280:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8291;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8291;
	asu64(R1) = p;
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 36;
	asu64(R2) = mm_lib_createunit1(asi64(R3), asu64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 9;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asu64(R2) = q;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8290;
L8291:
	goto L8292;
L8290:
	mm_lex_lex();
	asu64(R1) = q;
	p = asu64(R1);
	goto L8272;
L8281:
// mm_parse.readdotsuffix.error:
L8292:
	R1 = tou64("Unknown dot suffix");
	mm_support_serror(asu64(R1));
L8272:
L8270:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8269;
	asu64(R1) = p;
	goto L8268;
L8268:
	return asu64(R1);
}

static u64 mm_parse_readconstexpr(i64 needconst) {
    u64 R1; 
	asu64(R1) = mm_parse_readunit();
	goto L8293;
L8293:
	return asu64(R1);
}

static i64 mm_parse_readconstint() {
    u64 R1, R2; 
	i64 x;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8296;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	mm_lex_lex();
	asi64(R1) = x;
	goto L8294;
	goto L8295;
L8296:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L8297;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L8299;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	mm_lex_lex();
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L8294;
L8299:
L8297:
L8295:
	R1 = tou64("Can't do complex expr");
	mm_support_serror(asu64(R1));
	R1 = 0;
	goto L8294;
L8294:
	return asi64(R1);
}

static void mm_parse_readprocdef(u64 procowner, i64 scope) {
    u64 R1, R2, R3; 
	i64 kwd;
	i64 startline;
	i64 closesym;
	i64 shortfun;
	u64 stproc;
	u64 stname;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	shortfun = asi64(R1);
	R1 = 0;
	mm_parse_nforloops = asi64(R1);
	R1 = 1;
	mm_decls_assemmode = asi64(R1);
	asi64(R1) = scope;
	asu64(R2) = procowner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	stproc = asu64(R1);
	R1 = 0;
	mm_decls_assemmode = asi64(R1);
	mm_parse_checkequals();
	mm_lex_lex();
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	asi64(R1) = shortfun;
	if (asi64(R1)) goto L8302;
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
L8302:
	asu64(R1) = stproc;
	mm_parse_pushproc(asu64(R1));
	R1 = 0;
	mm_lib_nextavindex = asi64(R1);
	asu64(R1) = mm_parse_dretvar;
	if (!asu64(R1)) goto L8304;
	R1 = 11;
	asu64(R2) = mm_parse_dretvar;
	asu64(R3) = stproc;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asu64(R2) = stproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stname;
	asu64(R2) = stproc;
	mm_lib_adddef(asu64(R2), asu64(R1));
L8304:
	asu64(R1) = stproc;
	mm_lib_addtoproclist(asu64(R1));
	asi64(R1) = shortfun;
	if (!asi64(R1)) goto L8306;
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4;
	mm_parse_checksymbollex(asi64(R1));
	goto L8305;
L8306:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = startline;
	asi64(R2) = kwd;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
L8305:
	asu64(R1) = stproc;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	mm_parse_popproc();
	return;
}

static u64 mm_parse_readprocdecl(u64 procowner, i64 scope) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 varparams;
	i64 nparams;
	i64 nretvalues;
	i64 isthreaded;
	i64 subprogno;
	struct $B17 retmodes;
	u64 ms;
	u64 ps;
	u64 metadata;
	u64 truename;
	u64 pequiv;
	u64 stproc;
	u64 owner;
	u64 paramlist;
	u64 nameptr;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isthreaded = asi64(R1);
	R1 = 0;
	pequiv = asu64(R1);
	R1 = tou64("");
	metadata = asu64(R1);
	R1 = 0;
	truename = asu64(R1);
	R1 = 0;
	varparams = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L8309;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	truename = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8308;
L8309:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
L8308:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L8311;
	R1 = 7;
	goto L8310;
L8311:
	R1 = 6;
L8310:
	asu64(R2) = nameptr;
	asu64(R3) = procowner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L8313;
	R1 = 1;
	scope = asi64(R1);
L8313:
	asi64(R1) = isthreaded;
	asu64(R2) = stproc;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = truename;
	if (!asu64(R1)) goto L8315;
	asu64(R1) = truename;
	asu64(R2) = stproc;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8315:
	asu64(R1) = stproc;
	asu64(R2) = procowner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8317;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 11;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8317:
	asu64(R1) = stproc;
	owner = asu64(R1);
	asu64(R1) = stproc;
	mm_parse_pushproc(asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L8319;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 6;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	mm_lex_lex();
L8319:
	R1 = 0;
	paramlist = asu64(R1);
	R1 = 0;
	R2 = (u64)&retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8321;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8323;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = procowner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L8323:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8326;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8325;
L8326:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
	goto L8324;
L8325:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8328;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8327;
L8328:
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L8327:
L8324:
	goto L8320;
L8321:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8330;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8329;
L8330:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L8329:
L8320:
	R1 = 0;
	mm_parse_dretvar = asu64(R1);
	asi64(R1) = nretvalues;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8332;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8334;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_parse_dretvar = asu64(R1);
	mm_lex_lex();
L8334:
L8332:
	asi64(R1) = nretvalues;
	if (asi64(R1)) goto L8336;
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) != asi64(R2)) goto L8336;
	R1 = tou64("Function needs ret type");
	mm_support_serror(asu64(R1));
L8336:
	asi64(R1) = nretvalues;
	if (!asi64(R1)) goto L8338;
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L8338;
	R1 = tou64("Proc can't return value");
	mm_support_serror(asu64(R1));
L8338:
	asu64(R1) = paramlist;
	asu64(R2) = stproc;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nretvalues;
	asu64(R2) = stproc;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nretvalues;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8340;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8341;
	goto L8342;
L8340:
	R1 = 0;
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L8339;
L8341:
	asu64(R1) = stproc;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&retmodes;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	goto L8339;
L8342:
	R1 = 0;
	asi64(R2) = nretvalues;
	R3 = (u64)&retmodes;
	asu64(R4) = procowner;
	asi64(R1) = mm_lib_createtuplemode(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8339:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8344;
	R1 = tou64("READPROCDEF @");
	mm_support_serror(asu64(R1));
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8344:
	R1 = 0;
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = varparams;
	asu64(R2) = stproc;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = procowner;
	asu64(R2) = mm_decls_stmodule;
	if (asu64(R1) != asu64(R2)) goto L8346;
	asu64(R1) = stproc;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8348;
	R1 = tou64("start");
	asu64(R2) = stproc;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8348;
	asu64(R1) = stproc;
	R2 = (u64)&mm_decls_modules;
	asu64(R3) = mm_decls_stmodule;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8349;
	goto L8347;
L8348:
	asu64(R1) = stproc;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8350;
	R1 = tou64("main");
	asu64(R2) = stproc;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8350;
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = mm_decls_stmodule;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	R1 = (u64)&mm_decls_subprogs;
	asu64(R2) = mm_decls_stmodule;
	R3 = 95;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = ps;
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L8352;
	R1 = tou64("More than one main() in SP");
	mm_support_serror(asu64(R1));
L8352:
	asu64(R1) = mm_decls_stmodule;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ps;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = stproc;
	asu64(R2) = ms;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ps;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L8354;
	R1 = 3;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
// mm_parse.readprocdecl.dosigcheck:
L8349:
	asu64(R1) = stproc;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L8357;
	asu64(R1) = stproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8356;
L8357:
	R1 = tou64("Wrong 'main/start' sig");
	mm_support_serror(asu64(R1));
L8356:
L8354:
L8350:
L8347:
L8346:
	mm_parse_popproc();
	asu64(R1) = stproc;
	goto L8307;
L8307:
	return asu64(R1);
}

static u64 mm_parse_readparams(u64 procowner, u64 owner, u64 varparams, u64 nparams) {
    u64 R1, R2, R3; 
	u64 stlist;
	u64 stlistx;
	u64 stname;
	i64 parammode;
	i64 pmode;
	i64 m;
	i64 isoptional;
	i64 types;
	struct $B17 str;
	R1 = 0;
	R2 = R1;
	stlistx = asu64(R2);
	stlist = asu64(R1);
	R1 = 0;
	pmode = asi64(R1);
	R1 = 0;
	asu64(R2) = nparams;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	parammode = asi64(R1);
	R1 = 0;
	types = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8360;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8361;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8360;
L8361:
	R1 = 1;
	types = asi64(R1);
L8360:
L8362:
	R1 = 0;
	parammode = asi64(R1);
	R1 = 0;
	isoptional = asi64(R1);
	asi64(R1) = types;
	if (asi64(R1)) goto L8366;
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8365;
L8366:
	R1 = 0;
	asu64(R2) = procowner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	pmode = asi64(R1);
// mm_parse.readparams.gotmode:
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8369;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8370;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8369;
L8370:
L8371:
	asu64(R1) = nparams;
	(*toi64p(R1)) += 1;
	R1 = 36;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = nparams;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 12;
	R2 = (u64)&str;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = pmode;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = parammode;
	asu64(R2) = stname;
	R3 = 160;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8374;
	goto L8375;
L8374:
	goto L8372;
	goto L8373;
L8375:
L8373:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L8377;
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = varparams;
	*toi64p(R2) = asi64(R1);
	mm_lex_lex();
	goto L8372;
L8377:
	R1 = 0;
	asu64(R2) = procowner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	pmode = asi64(R1);
	goto L8371;
L8372:
	asu64(R1) = stlist;
	goto L8358;
L8369:
	goto L8364;
L8365:
	asi64(R1) = pmode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8378;
	R1 = tou64("Type expected");
	mm_support_serror(asu64(R1));
L8378:
L8364:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8380;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L8381;
	goto L8382;
L8380:
	R1 = 1;
	parammode = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8384;
	mm_lex_lex();
L8384:
	goto L8379;
L8381:
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = varparams;
	*toi64p(R2) = asi64(R1);
	mm_lex_lex();
	asu64(R1) = stlist;
	goto L8358;
	goto L8379;
L8382:
L8379:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	asu64(R1) = nparams;
	(*toi64p(R1)) += 1;
	R1 = 12;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	mm_lex_lex();
	asi64(R1) = parammode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8386;
	R1 = 0;
	asi64(R2) = pmode;
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	goto L8385;
L8386:
	asi64(R1) = pmode;
	m = asi64(R1);
L8385:
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = parammode;
	asu64(R2) = stname;
	R3 = 160;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = isoptional;
	asu64(R2) = stname;
	R3 = 161;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8388;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8388;
	goto L8389;
L8388:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 171;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 161;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8387;
L8389:
L8387:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8391;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8392;
	goto L8393;
L8391:
	mm_lex_lex();
	goto L8390;
L8392:
	goto L8363;
	goto L8390;
L8393:
	R1 = tou64("nameparams1");
	mm_support_serror(asu64(R1));
L8390:
	goto L8362;
L8363:
	asu64(R1) = stlist;
	goto L8358;
L8358:
	return asu64(R1);
}

static u64 mm_parse_readcondsuffix(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L8396;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L8397;
	goto L8398;
L8396:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = mm_parse_readunit();
	asu64(R2) = mm_parse_fixcond(asu64(R2));
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L8395;
L8397:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	R2 = 17;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 63;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = q;
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L8395;
L8398:
	asu64(R1) = p;
L8395:
	goto L8394;
L8394:
	return asu64(R1);
}

static u64 mm_parse_readif() {
    u64 R1, R2, R3, R4; 
	i64 pos1;
	i64 kwd;
	u64 clist;
	u64 clistx;
	u64 plist;
	u64 plistx;
	u64 pelse;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos1 = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = 0;
	R2 = R1;
	pelse = asu64(R2);
	R2 = R1;
	plistx = asu64(R2);
	R2 = R1;
	plist = asu64(R2);
	R2 = R1;
	clistx = asu64(R2);
	clist = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L8401;
	mm_lex_lex();
L8401:
	goto L8402;
L8403:
	mm_lex_lex();
// mm_parse.readif.nextif:
L8402:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	R2 = (u64)&clistx;
	R3 = (u64)&clist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_parse_skipsemi();
	R1 = 82;
	mm_parse_checksymbollex(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8407;
	asu64(R1) = clist;
	asu64(R2) = clistx;
	if (asu64(R1) != asu64(R2)) goto L8409;
	asi64(R1) = kwd;
	R2 = 81;
	if (asi64(R1) != asi64(R2)) goto L8409;
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = mm_parse_readunit();
	asu64(R3) = clist;
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8399;
	goto L8408;
L8409:
	R1 = tou64("then: not allowed");
	mm_support_serror(asu64(R1));
L8408:
L8407:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	R2 = (u64)&plistx;
	R3 = (u64)&plist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L8403;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L8411;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L8412;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L8412;
	goto L8413;
L8411:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8410;
L8412:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readswitchcase();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L8410;
L8413:
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L8410:
	asu64(R1) = pelse;
	asu64(R2) = plist;
	asu64(R3) = clist;
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8399;
L8399:
	return asu64(R1);
}

static u64 mm_parse_readgoto(i64 gototag) {
    u64 R1, R2; 
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asi64(R2) = gototag;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L8414;
L8414:
	return asu64(R1);
}

static u64 mm_parse_readunless() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	u64 pcond;
	u64 pthen;
	u64 pelse;
	u64 p;
	u64 q;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	R1 = 82;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L8417;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	goto L8416;
L8417:
	R1 = 0;
	pelse = asu64(R1);
L8416:
	R1 = 0;
	R2 = 0;
	R3 = 88;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pelse;
	asu64(R2) = pthen;
	asu64(R3) = pcond;
	R4 = 17;
	asu64(R3) = mm_lib_createunit1(asi64(R4), asu64(R3));
	R4 = R3;
	q = asu64(R4);
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 63;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8415;
L8415:
	return asu64(R1);
}

static u64 mm_parse_readswitchcase() {
    u64 R1, R2, R3, R4; 
	i64 pos1;
	i64 kwd;
	i64 opc;
	i64 pos2;
	i64 rangeused;
	i64 nwhen;
	u64 pexpr;
	u64 pwhenlist;
	u64 pwhenlistx;
	u64 pwhen;
	u64 pwhenx;
	u64 pelse;
	u64 p;
	u64 pthen;
	u64 pwhenthen;
	u64 pjump;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos1 = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = 0;
	pjump = asu64(R1);
	mm_lex_lex();
	mm_parse_skipsemi();
	asi64(R1) = opc;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L8420;
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	pjump = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 1;
	asu64(R2) = mm_decls_currproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8420:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L8422;
	asi64(R1) = kwd;
	R2 = 104;
	if (asi64(R1) != asi64(R2)) goto L8424;
	R1 = tou64("switch expr missing");
	mm_support_serror(asu64(R1));
L8424:
	R1 = 0;
	pexpr = asu64(R1);
	goto L8421;
L8422:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pexpr = asu64(R1);
	asu64(R1) = pjump;
	asu64(R2) = pexpr;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8421:
	R1 = 0;
	R2 = R1;
	pwhenlistx = asu64(R2);
	pwhenlist = asu64(R1);
	R1 = 0;
	rangeused = asi64(R1);
	R1 = 0;
	nwhen = asi64(R1);
	mm_parse_skipsemi();
	goto L8426;
L8425:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos2 = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	pwhenx = asu64(R2);
	pwhen = asu64(R1);
L8428:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&nwhen;
	(*toi64p(R1)) += 1;
	asi64(R1) = pos2;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8431;
	R1 = 1;
	rangeused = asi64(R1);
L8431:
	asu64(R1) = p;
	R2 = (u64)&pwhenx;
	R3 = (u64)&pwhen;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8433;
	goto L8429;
L8433:
	mm_lex_lex();
	goto L8428;
L8429:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8435;
	R1 = 82;
	mm_parse_checksymbol(asi64(R1));
L8435:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pwhen;
	R3 = 85;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pwhenthen = asu64(R1);
	asi64(R1) = pos2;
	asu64(R2) = pwhenthen;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pwhenthen;
	R2 = (u64)&pwhenlistx;
	R3 = (u64)&pwhenlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8426:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L8425;
	asi64(R1) = opc;
	R2 = 107;
	if (asi64(R1) != asi64(R2)) goto L8437;
	asi64(R1) = rangeused;
	if (asi64(R1)) goto L8437;
	asi64(R1) = nwhen;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L8439;
	R1 = 105;
	opc = asi64(R1);
L8439:
L8437:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L8441;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L8442;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L8443;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L8443;
	goto L8444;
L8441:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8440;
L8442:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readif();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L8440;
L8443:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readswitchcase();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L8440;
L8444:
	R1 = 0;
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L8440:
	asu64(R1) = pelse;
	asu64(R2) = pwhenlist;
	asu64(R3) = pexpr;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8418;
L8418:
	return asu64(R1);
}

static u64 mm_parse_readstop() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	mm_lex_lex();
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8447;
	asu64(R1) = mm_parse_readunit();
	R2 = 120;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8446;
L8447:
	R1 = 120;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
L8446:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L8445;
L8445:
	return asu64(R1);
}

static u64 mm_parse_readreturn() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	mm_lex_lex();
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8450;
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 89;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8449;
L8450:
	R1 = 89;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8449:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L8448;
L8448:
	return asu64(R1);
}

static u64 mm_parse_readdo() {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 pos;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 96;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 104;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8451;
L8451:
	return asu64(R1);
}

static u64 mm_parse_readto() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	i64 id;
	u64 p;
	u64 pcount;
	u64 pbody;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pcount = asu64(R1);
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 96;
	R3 = 94;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 11;
	id = asi64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8454;
	R1 = 10;
	id = asi64(R1);
L8454:
	asi64(R1) = id;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = pbody;
	asu64(R3) = pcount;
	R4 = 91;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8452;
L8452:
	return asu64(R1);
}

static u64 mm_parse_readwhile() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	u64 pcond;
	u64 pbody;
	u64 pincr;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	R1 = 0;
	pincr = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8457;
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pincr = asu64(R1);
L8457:
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 96;
	R3 = 97;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pincr;
	asu64(R2) = pbody;
	asu64(R3) = pcond;
	R4 = 97;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8455;
L8455:
	return asu64(R1);
}

static u64 mm_parse_readrepeat() {
    u64 R1, R2, R3; 
	i64 pos;
	u64 pbody;
	u64 pcond;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 99;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 98;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8458;
L8458:
	return asu64(R1);
}

static u64 mm_parse_readloopcontrol() {
    u64 R1, R2, R3; 
	i64 opc;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8461;
	R1 = tou64("all");
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8461;
	mm_lex_lex();
	R1 = 3;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8460;
L8461:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8462;
	R1 = 1;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8460;
L8462:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L8460:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L8459;
L8459:
	return asu64(R1);
}

static u64 mm_parse_readprint() {
    u64 R1, R2, R3, R4; 
	i64 oldinreadprint;
	i64 opc;
	i64 isfprint;
	i64 fshowname;
	u64 pformat;
	u64 pdev;
	u64 printlist;
	u64 printlistx;
	u64 p;
	u64 q;
	u64 expr;
	u64 s;
	asi64(R1) = mm_parse_inreadprint;
	oldinreadprint = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	asi64(R1) = opc;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L8465;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L8465;
	goto L8466;
L8465:
	R1 = 1;
	isfprint = asi64(R1);
	goto L8464;
L8466:
	R1 = 0;
	isfprint = asi64(R1);
L8464:
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	printlistx = asu64(R2);
	printlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8468;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pdev = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8470;
	mm_lex_lex();
	goto L8469;
L8470:
	goto L8471;
L8469:
L8468:
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L8473;
	asu64(R1) = mm_parse_readunit();
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8475;
	mm_lex_lex();
	goto L8474;
L8475:
	goto L8471;
L8474:
L8473:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L8477;
	goto L8471;
L8477:
L8478:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8481;
	R2 = 130;
	if (asi64(R1) == asi64(R2)) goto L8482;
	goto L8483;
L8481:
	R1 = 87;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L8480;
L8482:
	R1 = 88;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_lex_lex();
	goto L8480;
L8483:
	R1 = 0;
	fshowname = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L8485;
	R1 = 1;
	fshowname = asi64(R1);
	mm_lex_lex();
L8485:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8487;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = p;
	R3 = 86;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8487:
	asi64(R1) = fshowname;
	if (!asi64(R1)) goto L8489;
	asu64(R1) = p;
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	expr = asu64(R1);
	R1 = -1;
	R2 = tou64("=");
	asu64(R3) = expr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = expr;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_iconvucn(asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	R2 = R1;
	q = asu64(R2);
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8489:
	asu64(R1) = p;
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8480:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8491;
	goto L8479;
L8491:
	mm_lex_lex();
	goto L8478;
L8479:
// mm_parse.readprint.finish:
L8471:
	asi64(R1) = oldinreadprint;
	mm_parse_inreadprint = asi64(R1);
	asi64(R1) = opc;
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L8493;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8493;
	R1 = tou64("No print items");
	mm_support_serror(asu64(R1));
L8493:
	asi64(R1) = opc;
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L8495;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8495;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8495;
	R1 = tou64("No print items");
	mm_support_serror(asu64(R1));
L8495:
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L8497;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8499;
	R1 = tou64("No fmt str");
	mm_support_serror(asu64(R1));
L8499:
	asu64(R1) = printlist;
	asu64(R2) = pformat;
	asu64(R3) = pdev;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L8496;
L8497:
	asu64(R1) = printlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
L8496:
	goto L8463;
L8463:
	return asu64(R1);
}

static u64 mm_parse_readread() {
    u64 R1, R2, R3; 
	i64 oldinreadprint;
	i64 opc;
	u64 pformat;
	u64 pdev;
	u64 readlist;
	u64 readlistx;
	u64 p;
	u64 pread;
	asi64(R1) = mm_parse_inreadprint;
	oldinreadprint = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	readlistx = asu64(R2);
	readlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8502;
	asi64(R1) = opc;
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L8504;
	R1 = tou64("@ on read");
	mm_support_serror(asu64(R1));
L8504:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pdev = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8506;
	mm_lex_lex();
L8506:
L8502:
	asi64(R1) = opc;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L8508;
	asu64(R1) = pdev;
	R2 = 119;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L8508:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L8510;
	goto L8511;
L8510:
L8512:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8515;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pformat = asu64(R1);
	goto L8514;
L8515:
	R1 = 0;
	pformat = asu64(R1);
L8514:
	asu64(R1) = pformat;
	R2 = 118;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	pread = asu64(R1);
	asu64(R1) = pread;
	asu64(R2) = p;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8517;
	goto L8513;
L8517:
	mm_lex_lex();
	goto L8512;
L8513:
// mm_parse.readread.finish:
L8511:
	asi64(R1) = oldinreadprint;
	mm_parse_inreadprint = asi64(R1);
	asi64(R1) = opc;
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L8519;
	asu64(R1) = readlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8519;
	R1 = tou64("No read items");
	mm_support_serror(asu64(R1));
L8519:
	asu64(R1) = readlist;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L8500;
L8500:
	return asu64(R1);
}

static u64 mm_parse_readfor() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	i64 opc;
	u64 pindex;
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 pstep;
	u64 ptoinit;
	u64 plist;
	u64 passign;
	u64 pcond;
	u64 pbody;
	u64 pelse;
	u64 p;
	i64 i;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	plocal = asu64(R1);
	R1 = 0;
	ptoinit = asu64(R1);
	asu64(R1) = mm_parse_readname();
	pindex = asu64(R1);
	asi64(R1) = mm_parse_nforloops;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L8522;
	R1 = tou64("Too many for-loops");
	mm_support_serror(asu64(R1));
L8522:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_parse_nforloops;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8525;
L8523:
	R1 = (u64)&mm_parse_forindexvars;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pindex;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L8527;
	R1 = tou64("Re-using nested loop index");
	mm_support_serror(asu64(R1));
L8527:
	i += 1; if (i <= mm_parse_nforloops) goto L8523;
L8525:
	asu64(R1) = pindex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_parse_forindexvars;
	R3 = (u64)&mm_parse_nforloops;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8529;
	mm_lex_lex();
	asu64(R1) = mm_parse_readname();
	plocal = asu64(R1);
L8529:
	R1 = 93;
	opc = asi64(R1);
	R1 = 0;
	pstep = asu64(R1);
	R1 = 0;
	pcond = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L8532;
	R2 = 46;
	if (asi64(R1) != asi64(R2)) goto L8531;
L8532:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L8534;
	R1 = 94;
	opc = asi64(R1);
L8534:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	plist = asu64(R1);
	asu64(R1) = plist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8536;
	asu64(R1) = plist;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = plist;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	goto L8535;
L8536:
	asi64(R1) = opc;
	R2 = 93;
	if (asi64(R1) != asi64(R2)) goto L8538;
	R1 = 95;
	goto L8537;
L8538:
	R1 = 96;
L8537:
	opc = asi64(R1);
	R1 = 0;
	asu64(R2) = plist;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_getrangelwbunit(asu64(R1));
	pfrom = asu64(R1);
	R1 = 0;
	asu64(R2) = plist;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_getrangeupbunit(asu64(R1));
	pto = asu64(R1);
L8535:
	goto L8530;
L8531:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8540;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pfrom = asu64(R1);
	goto L8539;
L8540:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pfrom = asu64(R1);
L8539:
	R1 = 94;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8542;
	R1 = 94;
	goto L8541;
L8542:
	R1 = 93;
L8541:
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pto = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L8544;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	pstep = asu64(R1);
	asu64(R1) = pstep;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8546;
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8548;
	R1 = 0;
	pstep = asu64(R1);
L8548:
L8546:
L8544:
L8530:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L8550;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
L8550:
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	pelse = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L8552;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
L8552:
	R1 = 0;
	R2 = 96;
	R3 = 93;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pcond;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L8554;
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pbody = asu64(R1);
L8554:
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opc;
	R2 = 93;
	if (asi64(R1) == asi64(R2)) goto L8556;
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L8556;
	goto L8557;
L8556:
	asu64(R1) = plocal;
	if (!asu64(R1)) goto L8559;
	R1 = tou64("for i,x?");
	mm_support_serror(asu64(R1));
L8559:
	R1 = 73;
	asu64(R2) = pindex;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8561;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8561;
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	plocal = asu64(R1);
	R1 = 73;
	asu64(R2) = plocal;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pto;
	asu64(R2) = plocal;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	ptoinit = asu64(R1);
	asu64(R1) = ptoinit;
	asu64(R2) = pindex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = plocal;
	pto = asu64(R1);
L8561:
	asu64(R1) = pto;
	asu64(R2) = pfrom;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pstep;
	asu64(R2) = pto;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pfrom;
	asu64(R3) = pindex;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8555;
L8557:
	asu64(R1) = plocal;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8563;
	asu64(R1) = pindex;
	plocal = asu64(R1);
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	pindex = asu64(R1);
L8563:
	R1 = 73;
	asu64(R2) = pindex;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 76;
	asu64(R2) = plocal;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = plocal;
	asu64(R2) = pindex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pfrom;
	asu64(R2) = plocal;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pto;
	asu64(R2) = pfrom;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = pindex;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 0;
	asu64(R3) = plist;
	asu64(R2) = mm_lib_duplunit(asu64(R3), asi64(R2));
	R3 = 46;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	R2 = 0;
	asu64(R3) = plocal;
	asu64(R2) = mm_lib_duplunit(asu64(R3), asi64(R2));
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	asu64(R1) = passign;
	asu64(R2) = plist;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = plist;
	asu64(R3) = pindex;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8555:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mm_parse_nforloops;
	(*toi64p(R1)) -=1;
	asu64(R1) = p;
	goto L8520;
L8520:
	return asu64(R1);
}

static u64 mm_parse_readname() {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8566;
	R1 = tou64("Name expected");
	mm_support_serror(asu64(R1));
L8566:
	asu64(R1) = p;
	goto L8564;
L8564:
	return asu64(R1);
}

static void mm_parse_readtypedef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	u64 sttype;
	u64 stname;
	i64 t;
	i64 m;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 5;
	asu64(R2) = stname;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	sttype = asu64(R1);
	asu64(R1) = sttype;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = sttype;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	asu64(R2) = sttype;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = scope;
	asu64(R2) = sttype;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = sttype;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8569;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = t;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L8571;
	asi64(R1) = t;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L8570;
L8571:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8572;
	goto L8570;
L8572:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8574;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8575;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8576;
	goto L8577;
L8574:
	goto L8573;
L8575:
	goto L8573;
L8576:
	goto L8573;
L8577:
	asi64(R1) = t;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8573:
L8570:
	goto L8568;
L8569:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
L8568:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8579;
	asi64(R1) = t;
	asi64(R2) = m;
	mm_lib_copyttvalues(asi64(R2), asi64(R1));
	goto L8578;
L8579:
	R1 = 29;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L8578:
	return;
}

static void mm_parse_readrecordfields(u64 owner, i64 m) {
    u64 R1, R2, R3; 
	i64 nvars;
	i64 offset;
	u64 stname;
	u64 stbitfield;
	R1 = 0;
	nvars = asi64(R1);
	goto L8582;
L8581:
	R1 = 13;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	R1 = (u64)&mm_parse_unionpend;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8585;
	R1 = (u64)&mm_parse_unionpend;
	asu64(R2) = stname;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_copy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	R2 = (u64)&mm_parse_unionstring;
	mm_lib_unionstr_concat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_clear(asu64(R1));
	goto L8584;
L8585:
	asu64(R1) = stname;
	R2 = 136;
	R1 += (i64)R2;
	mm_lib_unionstr_clear(asu64(R1));
L8584:
	asu64(R1) = stname;
	mm_parse_unionlastvar = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8587;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8588;
	goto L8589;
L8587:
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = owner;
	asu64(R1) = mm_parse_readequivfield(asu64(R1));
	asu64(R2) = stname;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L8591;
	mm_lex_lex();
	asi64(R1) = mm_parse_readconstint();
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 9223372036854775807;
	if (asi64(R1) <= asi64(R2)) goto L8593;
	R1 = tou64("Offset>255");
	mm_support_serror(asu64(R1));
L8593:
	asi64(R1) = offset;
	asu64(R2) = stname;
	R3 = 151;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8591:
	goto L8586;
L8588:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
L8594:
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = 13;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stbitfield = asu64(R1);
	R1 = 27;
	asu64(R2) = stbitfield;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = stbitfield;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = stbitfield;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = stname;
	asu64(R2) = stbitfield;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 5;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = 62;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = stbitfield;
	R3 = 148;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8594;
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	goto L8586;
L8589:
L8586:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8598;
	goto L8583;
L8598:
	mm_lex_lex();
L8582:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8581;
L8583:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8600;
	R1 = tou64("No fields declared");
	mm_support_serror(asu64(R1));
L8600:
	return;
}

static void mm_parse_readtabledef(u64 owner, i64 scope) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 ncols;
	i64 nrows;
	i64 enums;
	i64 nextenumvalue;
	i64 firstval;
	i64 lastval;
	i64 startline;
	i64 closesym;
	i64 ltype;
	u64 stvar;
	u64 stenum;
	u64 stgen;
	struct $B29 varnameptrs;
	struct $B29 varlisttypes;
	struct $B29 plist;
	struct $B29 plistx;
	struct $B44 enumvalues;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	enums = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	mm_parse_tabledataname = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8603;
	asi64(R1) = enums;
	if (asi64(R1)) goto L8605;
	R1 = tou64("Use 'enumdata'");
	mm_support_serror(asu64(R1));
L8605:
	R1 = 1;
	enums = asi64(R1);
	mm_lex_lex();
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
L8603:
	R1 = 1;
	nextenumvalue = asi64(R1);
	R1 = 0;
	nrows = asi64(R1);
	R1 = 0;
	ncols = asi64(R1);
	goto L8607;
L8606:
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	ltype = asi64(R1);
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&ncols;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L8610;
	R1 = tou64("tabledata/too many columns");
	mm_support_serror(asu64(R1));
L8610:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&varnameptrs;
	asi64(R3) = ncols;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = ltype;
	R2 = (u64)&varlisttypes;
	asi64(R3) = ncols;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8612;
	mm_lex_lex();
	goto L8611;
L8612:
	goto L8608;
L8611:
L8607:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L8606;
L8608:
	mm_lex_lex();
	mm_parse_skipsemi();
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	mm_parse_skipsemi();
	R1 = 0;
	R2 = R1;
	lastval = asi64(R2);
	firstval = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8615;
L8613:
	R1 = 0;
	R2 = R1;
	R3 = (u64)&plistx;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	R2 = (u64)&plist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= ncols) goto L8613;
L8615:
	R1 = 1;
	mm_parse_intabledata = asi64(R1);
L8616:
	mm_parse_skipsemi();
	asi64(R1) = ncols;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8619;
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
L8619:
	R1 = (u64)&nrows;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L8621;
	R1 = tou64("tabledata:too many rows");
	mm_support_serror(asu64(R1));
L8621:
	asi64(R1) = enums;
	if (!asi64(R1)) goto L8623;
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stgen = asu64(R1);
	asu64(R1) = stgen;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_parse_tabledataname = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L8625;
	asi64(R1) = nrows;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8627;
	R1 = tou64("enum=x, 1st row only");
	mm_support_serror(asu64(R1));
L8627:
	mm_lex_lex();
	asi64(R1) = mm_parse_readconstint();
	nextenumvalue = asi64(R1);
L8625:
	asi64(R1) = nextenumvalue;
	R2 = (u64)&enumvalues;
	asi64(R3) = nrows;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 9;
	asu64(R2) = stgen;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stenum = asu64(R1);
	R1 = 3;
	asu64(R2) = stenum;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 3;
	asi64(R2) = nextenumvalue;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = stenum;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stenum;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stenum;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8629;
	asu64(R1) = stenum;
	mm_lib_addexpconst(asu64(R1));
L8629:
	asi64(R1) = nrows;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8631;
	asi64(R1) = nextenumvalue;
	firstval = asi64(R1);
L8631:
	asi64(R1) = nextenumvalue;
	lastval = asi64(R1);
	R1 = (u64)&nextenumvalue;
	(*toi64p(R1)) += 1;
	asi64(R1) = ncols;
	if (!asi64(R1)) goto L8633;
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
L8633:
L8623:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8636;
L8634:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&plistx;
	asi64(R3) = i;
	R2 += (i64)R3*8-8;
	R3 = (u64)&plist;
	asi64(R4) = i;
	R3 += (i64)R4*8-8;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = ncols;
	if (asi64(R1) != asi64(R2)) goto L8638;
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	goto L8637;
L8638:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
L8637:
	i += 1; if (i <= ncols) goto L8634;
L8636:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8640;
	goto L8617;
L8640:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = closesym;
	if (asi64(R1) != asi64(R2)) goto L8642;
	goto L8617;
L8642:
	goto L8616;
L8617:
	R1 = 0;
	mm_parse_intabledata = asi64(R1);
	mm_parse_skipsemi();
	asi64(R1) = startline;
	R2 = 132;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nrows;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8644;
	R1 = tou64("No table data");
	mm_support_serror(asu64(R1));
L8644:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8647;
L8645:
	R1 = 10;
	R2 = (u64)&varnameptrs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stvar = asu64(R1);
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = stvar;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nrows;
	asu64(R2) = stvar;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = stvar;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 9;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = stvar;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&varlisttypes;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = scope;
	asu64(R2) = stvar;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stvar;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stvar;
	mm_lib_addstatic(asu64(R1));
	i += 1; if (i <= ncols) goto L8645;
L8647:
	return;
}

static void mm_parse_readclassdef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	i64 kwd;
	i64 baseclass;
	i64 m;
	i64 startline;
	i64 closesym;
	i64 mrec;
	i64 isrecord;
	i64 align;
	u64 nameptr;
	u64 sttype;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	asi64(R1) = kwd;
	R2 = 111;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isrecord = asi64(R1);
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	mm_lex_lex();
	R1 = 0;
	baseclass = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8650;
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	baseclass = asi64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
L8650:
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 0;
	align = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8652;
	mm_lex_lex();
	R1 = 1;
	align = asi64(R1);
L8652:
	R1 = 5;
	asu64(R2) = nameptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	sttype = asu64(R1);
	asu64(R1) = sttype;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = sttype;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	asi64(R1) = m;
	asu64(R2) = owner;
	asi64(R1) = mm_lib_createrecordmode(asu64(R2), asi64(R1));
	mrec = asi64(R1);
	asu64(R1) = sttype;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = mrec;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = sttype;
	R2 = 144;
	R1 += (i64)R2;
	asi64(R2) = baseclass;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = align;
	asu64(R2) = sttype;
	R3 = 149;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	asi64(R1) = kwd;
	asu64(R2) = sttype;
	mm_parse_readclassbody(asu64(R2), asi64(R1));
	asi64(R1) = startline;
	asi64(R2) = kwd;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = scope;
	asu64(R2) = sttype;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_parse_readclassbody(u64 owner, i64 classkwd) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 t;
	i64 lbcount;
	R1 = 0;
	lbcount = asi64(R1);
	R1 = (u64)&mm_parse_unionstring;
	mm_lib_unionstr_clear(asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_clear(asu64(R1));
L8654:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L8656;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L8657;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L8657;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L8658;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L8659;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L8660;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8661;
	R2 = 132;
	if (asi64(R1) == asi64(R2)) goto L8662;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L8663;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L8664;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L8664;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L8665;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8665;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L8666;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L8667;
	goto L8668;
L8656:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L8654;
L8657:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	asu64(R1) = owner;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L8670;
	R1 = 0;
	asu64(R2) = owner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	goto L8669;
L8670:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
L8669:
	goto L8654;
L8658:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L8654;
L8659:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L8654;
L8660:
	R1 = tou64("Class eof?");
	mm_support_serror(asu64(R1));
	goto L8655;
	goto L8654;
L8661:
	mm_lex_lex();
	goto L8654;
L8662:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	goto L8654;
L8663:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	goto L8654;
L8664:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 112;
	if (asi64(R1) != asi64(R2)) goto L8672;
	R1 = 83;
	goto L8671;
L8672:
	R1 = 85;
L8671:
	R2 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
	R1 = 0;
	mm_parse_unionlastvar = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8674;
	R1 = (u64)&lbcount;
	(*toi64p(R1)) += 1;
	mm_lex_lex();
L8674:
	goto L8654;
L8665:
	R1 = (u64)&mm_parse_unionstring;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8676;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8678;
	asi64(R1) = lbcount;
	if (!asi64(R1)) goto L8678;
	mm_lex_lex();
	R1 = (u64)&lbcount;
	(*toi64p(R1)) -=1;
	goto L8677;
L8678:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&mm_parse_unionstring;
	asi64(R3) = mm_lib_unionstr_last(asu64(R3));
	R4 = 83;
	if (asi64(R3) != asi64(R4)) goto L8680;
	R3 = 112;
	goto L8679;
L8680:
	R3 = 113;
L8679:
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L8677:
	asu64(R1) = mm_parse_unionlastvar;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L8683;
	R1 = (u64)&mm_parse_unionpend;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8682;
L8683:
	R1 = tou64("Empty union group");
	mm_support_serror(asu64(R1));
L8682:
	asu64(R1) = mm_parse_unionlastvar;
	R2 = 136;
	R1 += (i64)R2;
	asi64(R1) = mm_lib_unionstr_last(asu64(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L8685;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L8685;
	goto L8686;
L8685:
	goto L8684;
L8686:
	R1 = 42;
	asu64(R2) = mm_parse_unionlastvar;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
L8684:
	R1 = 69;
	asu64(R2) = mm_parse_unionlastvar;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
	R1 = (u64)&mm_parse_unionstring;
	R2 = 7;
	R1 += (i64)R2;
	(*tou8p(R1)) -=1;
	goto L8675;
L8676:
	goto L8655;
L8675:
	goto L8654;
L8666:
	mm_lex_lex();
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8688;
// mm_parse.readclassbody.readmut:
L8689:
	R1 = (u64)&mm_parse_insiderecord;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	R1 = (u64)&mm_parse_insiderecord;
	(*toi64p(R1)) -=1;
	goto L8687;
L8688:
	R1 = 22;
	t = asi64(R1);
L8687:
	asi64(R1) = t;
	asu64(R2) = owner;
	mm_parse_readrecordfields(asu64(R2), asi64(R1));
	goto L8654;
L8667:
	R1 = tou64("Let not allowed");
	mm_support_serror(asu64(R1));
	goto L8654;
L8668:
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L8691;
	goto L8689;
	goto L8690;
L8691:
	goto L8655;
L8690:
	goto L8654;
L8655:
	asi64(R1) = lbcount;
	if (!asi64(R1)) goto L8693;
	R1 = tou64("LB?");
	mm_support_serror(asu64(R1));
L8693:
	return;
}

static void mm_parse_readimportmodule(u64 owner) {
    u64 R1, R2, R3; 
	i64 isnew;
	i64 startline;
	i64 closesym;
	u64 stname;
	u64 stname0;
	i64 i;
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L8696;
	R1 = tou64("nested importdll");
	mm_support_serror(asu64(R1));
L8696:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L8698;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	stname = asu64(R1);
	goto L8697;
L8698:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
L8697:
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 1;
	isnew = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8701;
L8699:
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_libfiles;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8703;
	R1 = 0;
	isnew = asi64(R1);
	goto L8701;
L8703:
	i += 1; if (i <= mm_decls_nlibfiles) goto L8699;
L8701:
	asi64(R1) = isnew;
	if (!asi64(R1)) goto L8705;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_modules_addlib(asu64(R1));
L8705:
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	R1 = 1;
	mm_parse_insidedllimport = asi64(R1);
	asu64(R1) = owner;
	mm_parse_readimportbody(asu64(R1));
	R1 = 0;
	mm_parse_insidedllimport = asi64(R1);
	asi64(R1) = startline;
	R2 = 114;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_parse_readimportbody(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	i64 pos;
	u64 d;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
L8707:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L8710;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L8710;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L8711;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L8712;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L8713;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L8714;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L8715;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8715;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L8715;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L8715;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8715;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L8715;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L8716;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L8717;
	goto L8718;
L8710:
// mm_parse.readimportbody.doproc:
	R1 = 0;
	asu64(R2) = owner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = mm_decls_ndllproctable;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L8721;
	R1 = tou64("Too many dll procs");
	mm_support_serror(asu64(R1));
L8721:
	asu64(R1) = d;
	R2 = (u64)&mm_decls_dllproctable;
	R3 = (u64)&mm_decls_ndllproctable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L8709;
L8711:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L8709;
L8712:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L8709;
L8713:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L8709;
L8714:
	mm_lex_lex();
	R1 = 119;
	R2 = 8;
	R3 = 0;
	R4 = 1;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8709;
L8715:
	R1 = 0;
	R2 = 8;
	R3 = 0;
	R4 = 1;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8709;
L8716:
	goto L8708;
	goto L8709;
L8717:
	goto L8708;
	goto L8709;
L8718:
	R1 = tou64("symbol");
	mm_lex_ps(asu64(R1));
	R1 = tou64("Not allowed in importmodule");
	mm_support_serror(asu64(R1));
L8709:
	goto L8707;
L8708:
	return;
}

static u64 mm_parse_readequivfield(u64 owner) {
    u64 R1, R2, R3; 
	u64 p;
	u64 d;
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	mm_lex_lex();
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L8724;
L8723:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8727;
	asu64(R1) = p;
	goto L8722;
L8727:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L8724:
	asu64(R1) = p;
	if (asu64(R1)) goto L8723;
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find @ field");
	mm_support_serror(asu64(R1));
	R1 = 0;
	goto L8722;
L8722:
	return asu64(R1);
}

static i64 mm_parse_readrefproc(u64 owner, i64 typedefx) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 kwd;
	i64 prettype;
	i64 m;
	i64 varparams;
	i64 nparams;
	struct $B17 retmodes;
	u64 paramlist;
	u64 stproc;
	i64 rettype2;
	i64 rettype3;
	i64 nretvalues;
	u64 name;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	paramlist = asu64(R1);
	R1 = 0;
	prettype = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = 0;
	varparams = asi64(R1);
	asu64(R1) = mm_lib_nextautotype();
	name = asu64(R1);
	R1 = 5;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stmodule;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asu64(R1) = stproc;
	asu64(R2) = mm_decls_stmodule;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) != asi64(R2)) goto L8730;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8732;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8734;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = owner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L8734:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8737;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8736;
L8737:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
	goto L8735;
L8736:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8739;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8738;
L8739:
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L8738:
L8735:
	goto L8731;
L8732:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8741;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8740;
L8741:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L8740:
L8731:
	asi64(R1) = nretvalues;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8743;
	R1 = tou64("Function needs return type");
	mm_support_serror(asu64(R1));
L8743:
	asi64(R1) = nretvalues;
	if (!asi64(R1)) goto L8745;
	asi64(R1) = kwd;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L8745;
	R1 = tou64("Proc can't return value");
	mm_support_serror(asu64(R1));
L8745:
	goto L8729;
L8730:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8747;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8749;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = owner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L8749:
	mm_lex_lex();
L8747:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8752;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8752;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8751;
L8752:
	R1 = tou64("proc can't have ret value");
	mm_support_serror(asu64(R1));
L8751:
L8729:
	asi64(R1) = typedefx;
	asi64(R2) = prettype;
	asi64(R3) = kwd;
	asu64(R4) = paramlist;
	asu64(R5) = stproc;
	asu64(R6) = owner;
	asi64(R1) = mm_lib_createrefprocmode(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	asu64(R1) = stproc;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&retmodes;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = nretvalues;
	asu64(R2) = stproc;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stproc;
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = varparams;
	asu64(R2) = stproc;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L8728;
L8728:
	return asi64(R1);
}

static void mm_parse_pushproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_parse_nprocstack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L8755;
	R1 = tou64("Too many nested proc");
	mm_support_serror(asu64(R1));
L8755:
	asu64(R1) = mm_decls_currproc;
	R2 = (u64)&mm_parse_procstack;
	R3 = (u64)&mm_parse_nprocstack;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	mm_decls_currproc = asu64(R1);
	return;
}

static void mm_parse_popproc() {
    u64 R1, R2, R3; 
	asi64(R1) = mm_parse_nprocstack;
	if (!asi64(R1)) goto L8758;
	R1 = (u64)&mm_parse_procstack;
	R2 = (u64)&mm_parse_nprocstack;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_decls_currproc = asu64(R1);
	goto L8757;
L8758:
	asu64(R1) = mm_decls_stmodule;
	mm_decls_currproc = asu64(R1);
L8757:
	return;
}

static i64 mm_parse_readreturntype(u64 owner, u64 retmodes) {
    u64 R1, R2, R3; 
	i64 nretvalues;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	asu64(R2) = retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 1;
	nretvalues = asi64(R1);
	goto L8761;
L8760:
	asi64(R1) = nretvalues;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L8764;
	R1 = tou64("Too many return values");
	mm_support_serror(asu64(R1));
L8764:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	asu64(R2) = retmodes;
	R3 = (u64)&nretvalues;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L8761:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8760;
	asi64(R1) = nretvalues;
	goto L8759;
L8759:
	return asi64(R1);
}

static u64 mm_parse_readset() {
    u64 R1, R2, R3; 
	i64 length;
	i64 nkeyvalues;
	i64 oldirp;
	u64 p;
	u64 ulist;
	u64 ulistx;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8767;
	goto L8768;
L8767:
	mm_lex_lex();
	R1 = 0;
	R2 = 22;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L8765;
	goto L8766;
L8768:
L8766:
	R1 = 0;
	length = asi64(R1);
	R1 = 0;
	nkeyvalues = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L8769:
	asi64(R1) = mm_parse_inreadprint;
	oldirp = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	asi64(R1) = oldirp;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L8772;
	R1 = (u64)&nkeyvalues;
	(*toi64p(R1)) += 1;
L8772:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8774;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8775;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8776;
	goto L8777;
L8774:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L8779;
	goto L8770;
L8779:
	goto L8773;
L8775:
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L8770;
	goto L8773;
L8776:
	goto L8770;
	goto L8773;
L8777:
	R1 = tou64("readset?");
	mm_support_serror(asu64(R1));
L8773:
	mm_parse_skipsemi();
	goto L8769;
L8770:
	mm_lex_lex();
	asi64(R1) = nkeyvalues;
	if (!asi64(R1)) goto L8781;
	asi64(R1) = length;
	asi64(R2) = nkeyvalues;
	if (asi64(R1) <= asi64(R2)) goto L8783;
	R1 = tou64("dict: mixed elements");
	mm_support_serror(asu64(R1));
L8783:
	asu64(R1) = ulist;
	R2 = 23;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8780;
L8781:
	asu64(R1) = ulist;
	R2 = 22;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L8780:
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8765;
L8765:
	return asu64(R1);
}

static i64 mm_parse_istypestarter() {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8786;
	R1 = 1;
	goto L8784;
L8786:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8788;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8790;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8791;
	goto L8792;
L8790:
	R1 = 1;
	goto L8784;
	goto L8789;
L8791:
	R1 = 1;
	goto L8784;
	goto L8789;
L8792:
L8789:
L8788:
	R1 = 0;
	goto L8784;
L8784:
	return asi64(R1);
}

static u64 mm_parse_readunit() {
    u64 R1, R2, R3; 
	u64 p;
	u64 pt;
	i64 pos;
	R1 = 0;
	pt = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	asu64(R1) = mm_parse_readterm2();
	pt = asu64(R1);
	R1 = (u64)&mm_tables_jisexpr;
	asu64(R2) = pt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8795;
	asu64(R1) = pt;
	goto L8793;
L8795:
	R1 = (u64)&mm_tables_endsexpr;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8797;
	asu64(R1) = pt;
	goto L8793;
L8797:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8799;
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	R1 = (u64)&mm_tables_endsexpr;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8801;
	asu64(R1) = p;
	asu64(R2) = pt;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8793;
L8801:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = pt;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8798;
L8799:
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8798:
	goto L8803;
L8802:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 0;
	asu64(R2) = mm_parse_readassignment(asu64(R2));
	R3 = 32;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8803:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8802;
	asu64(R1) = p;
	goto L8793;
L8793:
	return asu64(R1);
}

static u64 mm_parse_readassignment(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	u64 q;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readorterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8807;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8807:
	asu64(R1) = p;
	goto L8805;
L8805:
	return asu64(R1);
}

static u64 mm_parse_readorterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readandterms(asu64(R1));
	p = asu64(R1);
	goto L8810;
L8809:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8813;
	R1 = tou64("OR:=");
	mm_support_serror(asu64(R1));
L8813:
	R1 = 0;
	asu64(R1) = mm_parse_readandterms(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8810:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L8809;
	asu64(R1) = p;
	goto L8808;
L8808:
	return asu64(R1);
}

static u64 mm_parse_readandterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readcmpterms(asu64(R1));
	p = asu64(R1);
	goto L8816;
L8815:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8819;
	R1 = tou64("AND:=");
	mm_support_serror(asu64(R1));
L8819:
	R1 = 0;
	asu64(R1) = mm_parse_readcmpterms(asu64(R1));
	asu64(R2) = p;
	R3 = 15;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8816:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L8815;
	asu64(R1) = p;
	goto L8814;
L8814:
	return asu64(R1);
}

static u64 mm_parse_readcmpterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	i64 n;
	u64 ulist;
	u64 ulistx;
	u64 q;
	u32 genops;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readinterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8822;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L8822;
	asu64(R1) = p;
	goto L8820;
L8822:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asu64(R1) = p;
	R2 = 34;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = (u64)&genops;
	memset(R1, 0, 4);
L8823:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L8825;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L8825;
	goto L8826;
L8825:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L8828;
	R1 = tou64("cmpchain: Too many items");
	mm_support_serror(asu64(R1));
L8828:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&genops;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readinterms(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pos;
	asu64(R2) = q;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8823;
L8826:
	goto L8824;
	goto L8823;
L8824:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8830;
	R1 = 33;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&genops;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 64;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8829;
L8830:
	asu32(R1) = genops;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8829:
	asu64(R1) = p;
	goto L8820;
L8820:
	return asu64(R1);
}

static u64 mm_parse_readinterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readrangeterm(asu64(R1));
	p = asu64(R1);
L8832:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L8834;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L8834;
	goto L8835;
L8834:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readrangeterm(asu64(R1));
	asu64(R2) = p;
	R3 = 41;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8832;
L8835:
	goto L8833;
	goto L8832;
L8833:
	asu64(R1) = p;
	goto L8831;
L8831:
	return asu64(R1);
}

static u64 mm_parse_readrangeterm(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readaddterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8838;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readaddterms(asu64(R1));
	asu64(R2) = p;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8838:
	asu64(R1) = p;
	goto L8836;
L8836:
	return asu64(R1);
}

static u64 mm_parse_readaddterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 sym;
	i64 tag;
	i64 genop;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readmulterms(asu64(R1));
	p = asu64(R1);
L8840:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	sym = asi64(R2);
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L8842;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L8842;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L8842;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L8842;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8842;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L8842;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L8842;
	goto L8843;
L8842:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	genop = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8845;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 38;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8841;
L8845:
	R1 = 0;
	asu64(R1) = mm_parse_readmulterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8840;
L8843:
	goto L8841;
	goto L8840;
L8841:
	asu64(R1) = p;
	goto L8839;
L8839:
	return asu64(R1);
}

static u64 mm_parse_readmulterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 sym;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	p = asu64(R1);
L8847:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	sym = asi64(R2);
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L8849;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L8849;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8849;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L8849;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L8849;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L8849;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L8849;
	goto L8850;
L8849:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8852;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 38;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8848;
L8852:
	R1 = 0;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8847;
L8850:
	goto L8848;
	goto L8847;
L8848:
	asu64(R1) = p;
	goto L8846;
L8846:
	return asu64(R1);
}

static u64 mm_parse_readpowerterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8855;
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
L8855:
	goto L8857;
L8856:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 82;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L8857:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L8856;
	asu64(R1) = p;
	goto L8853;
L8853:
	return asu64(R1);
}

static u64 mm_parse_readterm2() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	u64 pbyte;
	u64 a;
	i64 oldipl;
	i64 opc;
	i64 oldinrp;
	i64 pos;
	i64 shift;
	i64 t;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	asu64(R1) = mm_parse_readterm();
	p = asu64(R1);
L8860:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8862;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8863;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8864;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8865;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8866;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L8867;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8868;
	goto L8869;
L8862:
	mm_lex_lex();
	asi64(R1) = mm_parse_inreadprint;
	oldinrp = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 1;
	R2 = 1;
	asu64(R1) = mm_parse_readslist(asi64(R2), asi64(R1));
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 90;
	if (asi64(R1) != asi64(R2)) goto L8871;
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8870;
L8871:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 32;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L8870:
	asi64(R1) = oldinrp;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	p = asu64(R1);
	goto L8860;
L8863:
	asu64(R1) = p;
	R2 = 53;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L8860;
L8864:
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L8860;
L8865:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readdotsuffix(asu64(R1));
	p = asu64(R1);
	goto L8860;
L8866:
	asi64(R1) = mm_parse_inreadprint;
	if (!asi64(R1)) goto L8873;
	goto L8861;
L8873:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = mm_parse_inparamlist;
	if (!asi64(R3)) goto L8875;
	R3 = 26;
	goto L8874;
L8875:
	R3 = 27;
L8874:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8860;
L8867:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L8877;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L8878;
	goto L8879;
L8877:
	R1 = 88;
	opc = asi64(R1);
	goto L8876;
L8878:
	R1 = 89;
	opc = asi64(R1);
	goto L8876;
L8879:
L8876:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8860;
L8868:
	R1 = tou64("X{...} not ready");
	mm_support_serror(asu64(R1));
	goto L8860;
L8869:
	goto L8861;
	goto L8860;
L8861:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8859;
L8859:
	return asu64(R1);
}

static u64 mm_parse_readterm() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	u64 a;
	i64 opc;
	i64 pos;
	i64 length;
	u8 strtype;
	u64 s;
	struct $B16 cstr;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: goto L8910;
	case 3: case 4: case 5: case 6: case 7: case 8: case 10: case 12: case 14: case 15: case 16: case 17: case 18: case 21: case 22: case 23: case 26: case 27: case 28: case 29: case 30: case 34: case 35: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 54: case 57: case 58: case 59: case 60: case 66: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 82: case 83: case 84: case 85: case 86: case 87: case 92: case 95: case 99: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 118: case 119: case 120: case 122: case 123: case 125: case 126: case 127: case 132: goto L8883;
	case 9: goto L8894;
	case 11: goto L8903;
	case 13: goto L8948;
	case 19: case 20: goto L8905;
	case 24: case 25: case 31: case 32: case 33: case 36: case 37: case 49: case 50: case 51: case 52: case 53: case 55: case 56: goto L8896;
	case 47: goto L8897;
	case 48: goto L8900;
	case 61: goto L8904;
	case 62: case 63: goto L8887;
	case 64: goto L8889;
	case 65: goto L8888;
	case 67: goto L8884;
	case 69: goto L8946;
	case 79: case 80: case 117: goto L8895;
	case 81: goto L8926;
	case 88: goto L8927;
	case 89: case 90: case 104: case 105: goto L8928;
	case 91: goto L8929;
	case 93: goto L8930;
	case 94: goto L8931;
	case 96: goto L8932;
	case 97: goto L8933;
	case 98: goto L8934;
	case 100: goto L8936;
	case 101: goto L8937;
	case 102: goto L8935;
	case 103: goto L8925;
	case 106: goto L8938;
	case 107: goto L8939;
	case 121: goto L8949;
	case 124: goto L8947;
	case 128: goto L8921;
	case 129: goto L8911;
	case 130: goto L8912;
	case 131: goto L8941;
	case 133: goto L8922;
	case 134: goto L8940;
	case 135: goto L8942;
	case 136: goto L8945;
	default: goto L8883;
    };
// SWITCH
L8884:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8886;
	asu64(R1) = mm_parse_readcast();
	p = asu64(R1);
	goto L8885;
L8886:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_createname(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	mm_lex_lex();
L8885:
	goto L8881;
L8887:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L8881;
L8888:
	R1 = (u64)&mm_decls_lx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	goto L8881;
L8889:
	R1 = (u64)&mm_decls_lx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L8891;
	R1 = tou64("Char const too long");
	mm_support_serror(asu64(R1));
L8891:
	R1 = 0;
	a = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L8893;
	asi64(R1) = length;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&a;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L8893:
	R1 = 5;
	asu64(R2) = a;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L8881;
L8894:
	asu64(R1) = mm_parse_readlbrack();
	p = asu64(R1);
	goto L8881;
L8895:
	asu64(R1) = mm_parse_readcast();
	p = asu64(R1);
	goto L8881;
L8896:
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L8881;
L8897:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8899;
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L8898;
L8899:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 17;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 63;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8898:
	goto L8881;
L8900:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8902;
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L8901;
L8902:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 18;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L8901:
	goto L8881;
L8903:
	asu64(R1) = mm_parse_readset();
	p = asu64(R1);
	goto L8881;
L8904:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 40;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8881;
L8905:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) != asi64(R2)) goto L8907;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8909;
	R1 = tou64("Params not allowed");
	mm_support_serror(asu64(R1));
L8909:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8907:
	goto L8881;
L8910:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 56;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8881;
L8911:
	asu64(R1) = mm_parse_readcompilervar();
	p = asu64(R1);
	goto L8881;
L8912:
	asi64(R1) = mm_parse_intabledata;
	if (!asi64(R1)) goto L8914;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8916;
	R1 = 0;
	R2 = (u64)&cstr;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_parse_tabledataname;
	R2 = (u64)&cstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&cstr;
	R3 = 1;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L8915;
L8916:
	asu64(R1) = mm_parse_tabledataname;
	s = asu64(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L8918;
	mm_lex_lex();
	mm_lex_lex();
	R1 = 62;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L8918:
	R1 = -1;
	asu64(R2) = s;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
L8915:
	goto L8913;
L8914:
	asi64(R1) = mm_parse_ndollar;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L8920;
	R1 = tou64("[$] No array");
	mm_support_serror(asu64(R1));
L8920:
	R1 = (u64)&mm_parse_dollarstack;
	asi64(R2) = mm_parse_ndollar;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8913:
	mm_lex_lex();
	goto L8881;
L8921:
	asu64(R1) = mm_parse_readcastx();
	p = asu64(R1);
	goto L8881;
L8922:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8924;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8924;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L8923;
L8924:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L8923:
	mm_lex_lex();
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 56;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 55;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8881;
L8925:
	R1 = 99;
	asu64(R1) = mm_parse_readgoto(asi64(R1));
	p = asu64(R1);
	goto L8881;
L8926:
	asu64(R1) = mm_parse_readif();
	p = asu64(R1);
	goto L8881;
L8927:
	asu64(R1) = mm_parse_readunless();
	p = asu64(R1);
	goto L8881;
L8928:
	asu64(R1) = mm_parse_readswitchcase();
	p = asu64(R1);
	goto L8881;
L8929:
	asu64(R1) = mm_parse_readrecase();
	p = asu64(R1);
	goto L8881;
L8930:
	asu64(R1) = mm_parse_readfor();
	p = asu64(R1);
	goto L8881;
L8931:
	asu64(R1) = mm_parse_readto();
	p = asu64(R1);
	goto L8881;
L8932:
	asu64(R1) = mm_parse_readdo();
	p = asu64(R1);
	goto L8881;
L8933:
	asu64(R1) = mm_parse_readwhile();
	p = asu64(R1);
	goto L8881;
L8934:
	asu64(R1) = mm_parse_readrepeat();
	p = asu64(R1);
	goto L8881;
L8935:
	asu64(R1) = mm_parse_readloopcontrol();
	p = asu64(R1);
	goto L8881;
L8936:
	asu64(R1) = mm_parse_readreturn();
	p = asu64(R1);
	goto L8881;
L8937:
	asu64(R1) = mm_parse_readstop();
	p = asu64(R1);
	goto L8881;
L8938:
	asu64(R1) = mm_parse_readprint();
	p = asu64(R1);
	goto L8881;
L8939:
	asu64(R1) = mm_parse_readread();
	p = asu64(R1);
	goto L8881;
L8940:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 111;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8881;
L8941:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	R2 = 121;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8881;
L8942:
	R1 = 1;
	asu64(R2) = mm_decls_currproc;
	R3 = 120;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	mm_decls_assemmode = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8944;
	asu64(R1) = mm_assem_readassemline();
	p = asu64(R1);
	goto L8943;
L8944:
	asu64(R1) = mm_assem_readassemblock();
	p = asu64(R1);
L8943:
	R1 = 0;
	mm_decls_assemmode = asi64(R1);
	goto L8881;
L8945:
	R1 = 90;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	goto L8881;
L8946:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	strtype = asu8(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 13;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu8(R1) = strtype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8881;
L8947:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 122;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L8881;
L8948:
	R1 = tou64("{...} not ready");
	mm_support_serror(asu64(R1));
	goto L8881;
L8949:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 24;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L8881;
L8883:
// mm_parse.readterm.doelse:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("LX.SYMBOL=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mm_parse_istypestarter();
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("readterm?");
	mm_support_serror(asu64(R1));
L8881:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8880;
L8880:
	return asu64(R1);
}

static void mm_parse_readmacrodef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	u64 nameptr;
	u64 stmacro;
	u64 paramlist;
	u64 paramlistx;
	u64 stname;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	R1 = 15;
	asu64(R2) = nameptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stmacro = asu64(R1);
	asu64(R1) = stmacro;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stmacro;
	owner = asu64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	paramlistx = asu64(R2);
	paramlist = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8953;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8955;
L8956:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L8959;
	goto L8960;
L8959:
	R1 = 16;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	R2 = (u64)&paramlistx;
	R3 = (u64)&paramlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8962;
	goto L8957;
L8962:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	goto L8958;
L8960:
	R1 = tou64("macro def params");
	mm_support_serror(asu64(R1));
L8958:
	goto L8956;
L8957:
L8955:
	mm_lex_lex();
L8953:
	asu64(R1) = paramlist;
	asu64(R2) = stmacro;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stmacro;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_parse_checkequals();
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stmacro;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_parse_readrecase() {
    u64 R1, R2; 
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L8965;
	mm_lex_lex();
	R1 = 113;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	goto L8964;
L8965:
	asu64(R1) = mm_parse_readunit();
	R2 = 113;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
L8964:
	goto L8963;
L8963:
	return asu64(R1);
}

static u64 mm_parse_fixcond(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	mm_parse_checknotempty(asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L8968;
	R1 = 18;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L8968:
	asu64(R1) = p;
	goto L8966;
L8966:
	return asu64(R1);
}

static u64 mm_parse_readsunit(i64 inwhile) {
    u64 R1, R2, R3, R4, R5; 
	i64 pos;
	i64 m;
	i64 sym;
	i64 opc;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	u64 stname;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L8970:
	goto L8974;
L8973:
	mm_lex_lex();
L8974:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8973;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 4: goto L9009;
	case 5: case 6: case 7: case 8: case 9: case 12: case 13: case 14: case 15: case 16: case 17: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 81: case 88: case 89: case 90: case 91: case 93: case 94: case 95: case 97: case 98: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 110: case 112: case 113: case 114: case 115: case 118: case 124: case 125: case 126: case 128: case 129: case 130: case 131: goto L8978;
	case 10: case 82: case 83: case 84: case 85: case 86: case 87: case 92: case 99: goto L9000;
	case 11: case 79: case 80: case 117: case 121: goto L8984;
	case 18: goto L9010;
	case 59: goto L8999;
	case 67: goto L9001;
	case 96: goto L9006;
	case 108: case 109: goto L8983;
	case 111: goto L8996;
	case 116: goto L8994;
	case 119: case 120: goto L8990;
	case 122: goto L8997;
	case 123: goto L8995;
	case 127: goto L8979;
	case 132: goto L8998;
	default: goto L8978;
    };
// SWITCH
L8979:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L8982;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L8981;
L8982:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	goto L8980;
L8981:
	R1 = 0;
	opc = asi64(R1);
L8980:
	asi64(R1) = opc;
	R2 = 10;
	R3 = 1;
	R4 = 0;
	asu64(R5) = mm_decls_currproc;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L8976;
L8983:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
	goto L8976;
L8984:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8987;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8987;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8986;
L8987:
	goto L8988;
	goto L8985;
L8986:
	R1 = 0;
	sym = asi64(R1);
	goto L8989;
L8985:
	goto L8976;
L8990:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	sym = asi64(R1);
	mm_lex_lex();
// mm_parse.readsunit.dovar:
L8989:
	asi64(R1) = sym;
	R2 = 11;
	R3 = 0;
	R4 = 0;
	asu64(R5) = mm_decls_currproc;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	q = asu64(R1);
	goto L8992;
L8991:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L8992:
	asu64(R1) = q;
	if (asu64(R1)) goto L8991;
	goto L8976;
L8994:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L8976;
L8995:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L8976;
L8996:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L8976;
L8997:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	goto L8976;
L8998:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	goto L8976;
L8999:
	msysc_m$print_startcon();
	asu64(R1) = mm_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Unexpected EOF in proc");
	mm_support_serror(asu64(R1));
	goto L8976;
L9000:
	goto L8972;
	goto L8976;
L9001:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9003;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L9004;
	goto L9005;
L9003:
	R1 = 100;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 14;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = mm_decls_currproc;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = mm_decls_currproc;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	mm_lex_lex();
	R1 = 4;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L9002;
L9004:
	R1 = 119;
	sym = asi64(R1);
	goto L8989;
	goto L8988;
	goto L9002;
L9005:
	goto L8988;
L9002:
	goto L8976;
L9006:
	asi64(R1) = inwhile;
	if (!asi64(R1)) goto L9008;
	goto L8972;
L9008:
	goto L8988;
	goto L8976;
L9009:
	goto L8976;
L9010:
	R1 = -1;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	R2 = 14;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9011;
	goto L8976;
L8978:
// mm_parse.readsunit.doexec:
L8988:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
// mm_parse.readsunit.doexec2:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L9014;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L9014;
	R1 = tou64("Possibly var/let needed");
	mm_support_serror(asu64(R1));
L9014:
// mm_parse.readsunit.doexec3:
L9011:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 96;
	if (asi64(R1) != asi64(R2)) goto L9016;
	goto L8972;
L9016:
L8976:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8970;
L8972:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9018;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9018;
	goto L9019;
L9018:
	goto L9017;
L9019:
	R1 = tou64("Readsunit: \";\" expected, or bad unit starter");
	mm_support_serror(asu64(R1));
L9017:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L9022;
	asu64(R1) = ulist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9021;
L9022:
	asu64(R1) = ulist;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L9020;
L9021:
	asu64(R1) = ulist;
L9020:
	goto L8969;
L8969:
	return asu64(R1);
}

static u64 mm_parse_readbxdata() {
    u64 R1, R2, R3; 
	u64 p;
	i64 curralloc;
	i64 n;
	u64 q;
	u64 r;
	u64 qnew;
	R1 = 4;
	curralloc = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	p = asu64(R1);
	asi64(R1) = curralloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	r = asu64(R2);
	q = asu64(R1);
L9024:
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L9027;
	goto L9025;
L9027:
	asi64(R1) = n;
	asi64(R2) = curralloc;
	if (asi64(R1) != asi64(R2)) goto L9029;
	R1 = 2;
	R2 = (u64)&curralloc;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = curralloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qnew = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = qnew;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qnew;
	asu64(R2) = r;
	asu64(R3) = q;
	asi64(R2) -= asi64(R3);
	R1 += (i64)R2;
	r = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = q;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = qnew;
	q = asu64(R1);
L9029:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9031;
	goto L9025;
L9031:
	goto L9024;
L9025:
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
	mm_lex_lex();
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L9023;
L9023:
	return asu64(R1);
}

static void mm_parse_checknotempty(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L9035;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9034;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9034;
L9035:
	R1 = tou64("Empty sunit");
	mm_support_serror(asu64(R1));
L9034:
	return;
}

static u64 mm_support_newsourcefile() {
    u64 R1, R2, R3; 
	u64 pf;
	R1 = 68;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pf = asu64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 300;
	if (asi64(R1) < asi64(R2)) goto L9038;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many sources");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L9038:
	asu64(R1) = pf;
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_nsourcefiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	asu64(R2) = pf;
	R3 = 64;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = pf;
	goto L9036;
L9036:
	return asu64(R1);
}

static void mm_support_mcerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("MC Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_serror_gen(u64 mess) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 42;
	mm_support_showdivider(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("Syntax Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_decls_currproc;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	mm_support_showerrorsource(asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_lx;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	R4 = 24;
	R5 = 31;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_showdivider(u64 ch) {
    u64 R1, R2; 
	i64 av_1;
	R1 = 87;
	av_1 = asi64(R1);
L9042:
	msysc_m$print_startcon();
	R1 = 0;
	asu64(R2) = ch;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L9042;
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_support_showerrorsource(i64 pos, u64 stproc) {
    u64 R1, R2, R3; 
	i64 fileno;
	i64 lineoffset;
	u64 errorline;
	u64 s;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	asi64(R1) = pos;
	asi64(R1) = mm_support_getfileno(asu64(R1));
	fileno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("    Line:     #");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = stproc;
	if (!asu64(R1)) goto L9047;
	asu64(R1) = stproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9047;
	msysc_m$print_startcon();
	R1 = tou64("    Function: #()");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = stproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9047:
	msysc_m$print_startcon();
	R1 = tou64("    Module:   # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	mm_support_showdivider(asu64(R1));
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourceline(asu64(R1));
	R2 = R1;
	errorline = asu64(R2);
	s = asu64(R1);
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourcepos(asu64(R1));
	asu64(R2) = errorline;
	asi64(R1) -= asi64(R2);
	lineoffset = asi64(R1);
	R1 = 6;
	av_1 = asi64(R1);
L9048:
	msysc_m$print_startcon();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L9048;
	goto L9052;
L9051:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L9052:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9054;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9051;
L9054:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = errorline;
	s = asu64(R1);
	R1 = 6;
	av_2 = asi64(R1);
L9055:
	msysc_m$print_startcon();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_2)) goto L9055;
	asi64(R1) = lineoffset;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L9060;
L9058:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L9062;
	msysc_m$print_startcon();
	R1 = 0;
	R2 = 9;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L9061;
L9062:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = 32;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L9061:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L9058;
L9060:
	msysc_m$print_startcon();
	R1 = tou64("^");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	mm_support_showdivider(asu64(R1));
	return;
}

static void mm_support_stopcompiler(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("PRESS key");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mlinux_os_getch();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_serror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_serror_gen(asu64(R1));
	return;
}

static void mm_support_serror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	mm_support_serror_gen(asu64(R1));
	return;
}

static void mm_support_error_gen(i64 pass, u64 mess, u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	if (!asu64(R1)) goto L9068;
	msysc_m$print_startcon();
	R1 = tou64("P.POS");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	goto L9067;
L9068:
	msysc_m$print_startcon();
	R1 = tou64("MMPOS");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = pc_decls_mmpos;
	pos = asi64(R1);
L9067:
	msysc_m$print_startcon();
	R1 = tou64("GETFILENO(POS)=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pos;
	asi64(R1) = mm_support_getfileno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 42;
	mm_support_showdivider(asu64(R1));
	asi64(R1) = pass;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L9070;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L9071;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L9072;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L9073;
	goto L9074;
L9070:
	msysc_m$print_startcon();
	R1 = tou64("RX Name Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9069;
L9071:
	msysc_m$print_startcon();
	R1 = tou64("TX Type Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9069;
L9072:
	msysc_m$print_startcon();
	R1 = tou64("GX Code Gen Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9069;
L9073:
	msysc_m$print_startcon();
	R1 = tou64("AX Code Gen Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9069;
L9074:
L9069:
	asu64(R1) = mm_decls_currproc;
	asi64(R2) = pos;
	mm_support_showerrorsource(asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = pos;
	asi64(R3) = mm_support_getfileno(asu64(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_rxerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 78;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_gerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 71;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror_s(u64 mess, u64 a, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror_ss(u64 mess, u64 a, u64 b) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_rxerror_s(u64 mess, u64 a, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 78;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_gerror_s(u64 mess, u64 s, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 71;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_lxerror_gen(u64 mess) {
    u64 R1, R2, R3, R4, R5; 
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Lex Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_lx;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	R4 = 24;
	R5 = 31;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_lxerror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_lxerror_gen(asu64(R1));
	return;
}

static void mm_support_loaderror(u64 mess, u64 mess2, u64 mess3) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess3;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_gs_additem(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9087;
	asu64(R1) = d;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = mm_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L9089;
	asi64(R1) = nextchar;
	asi64(R1) = mm_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L9089;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L9089:
L9087:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_support_gs_copytostr(u64 source, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9092;
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = source;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = s;
	asu64(R3) = source;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9091;
L9092:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L9091:
	return;
}

static i64 mm_support_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L9097;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L9096;
L9097:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L9098;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L9096;
L9098:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L9095;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L9095;
L9096:
	R1 = 1;
	goto L9093;
L9095:
	R1 = 0;
	goto L9093;
L9093:
	return asi64(R1);
}

static void mm_support_init_tt_tables() {
    u64 R1, R2, R3; 
	i64 i;
	i64 size;
	i64 bitsize;
	i64 s;
	i64 t;
	i64 u;
	i64 v;
	i64 av_1;
	R1 = 0;
	i = asi64(R1);
	R1 = 30;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L9102;
L9100:
	R1 = (u64)&mm_tables_stdnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_ttname;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = i;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_tables_stdsize;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9104;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9105;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9105;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9105;
	goto L9106;
L9104:
	R1 = 0;
	size = asi64(R1);
	goto L9103;
L9105:
	R1 = 1;
	size = asi64(R1);
	goto L9103;
L9106:
	asi64(R1) = bitsize;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
L9103:
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = i;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	asi64(R1) = i;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9108;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L9108;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9108;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9108;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9109;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9109;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9109;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9109;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9109;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9109;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9110;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9110;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9111;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9111;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L9111;
	goto L9112;
L9108:
	R1 = 1;
	R2 = (u64)&mm_decls_ttsigned;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9107;
L9109:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9107;
L9110:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9107;
L9111:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9107;
L9112:
L9107:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9114;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L9114;
	R1 = 1;
	R2 = (u64)&mm_decls_ttisshort;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9114:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = i;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9117;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9117;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9117;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L9116;
L9117:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9116:
	i += 1; if (i <= av_1) goto L9100;
L9102:
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 12;
	R2 = (u64)&mm_decls_tttarget;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 30;
	mm_decls_ntypes = asi64(R1);
	R1 = 0;
	R2 = 24;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	mm_tables_trefproc = asi64(R1);
	R1 = 0;
	R2 = 25;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	mm_tables_treflabel = asi64(R1);
	return;
}

static u64 mm_support_getsupportfile(u64 filename, u64 ext, u64 path) {
    u64 R1, R2, R3; 
	struct $B15 filespec;
	struct $B15 filespec2;
	u64 file;
	i64 fileno;
	u64 pfile;
	i64 i;
	asu64(R1) = filename;
	file = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9120;
	msysc_m$print_startcon();
	R1 = tou64("Get file:# (ext:#) (path:#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ext;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = path;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9120:
	asu64(R1) = ext;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L9122;
	asu64(R1) = ext;
	asu64(R2) = filename;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	file = asu64(R1);
L9122:
	asu8(R1) = mm_decls_loadedfromma;
	if (!asu8(R1)) goto L9124;
	asu64(R1) = file;
	asu64(R1) = mlib_extractfile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file = asu64(R1);
L9124:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9127;
L9125:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = file;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9129;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9129;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L9118;
L9129:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L9125;
L9127:
	asu64(R1) = file;
	asi64(R1) = mm_support_isabspath(asu64(R1));
	if (asi64(R1)) goto L9131;
	asu64(R1) = path;
	R2 = (u64)&filespec2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&filespec2;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&filespec2;
	file = asu64(R1);
L9131:
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9133;
	asi64(R1) = fileno;
	if (!asi64(R1)) goto L9133;
	msysc_m$print_startcon();
	R1 = tou64("Checkfile:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9133:
	asu64(R1) = file;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L9136;
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L9135;
L9136:
	R1 = tou64("");
	asu64(R2) = file;
	R3 = tou64("Can't find file: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L9135:
	R1 = 0;
	asu64(R2) = file;
	asu64(R1) = mm_modules_loadsourcefile(asu64(R2), asi64(R1));
	pfile = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9138;
	asu64(R1) = pfile;
	if (!asu64(R1)) goto L9138;
	msysc_m$print_startcon();
	R1 = tou64("Found:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9138:
	R1 = 1;
	asu64(R2) = pfile;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pfile;
	goto L9118;
L9118:
	return asu64(R1);
}

static i64 mm_support_isabspath(u64 filespec) {
    u64 R1, R2; 
	u64 path;
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	path = asu64(R1);
	asu64(R1) = path;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L9142;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L9142;
	asu64(R1) = path;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9141;
	asu64(R1) = path;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L9141;
L9142:
	R1 = 1;
	goto L9139;
L9141:
	R1 = 0;
	goto L9139;
L9139:
	return asi64(R1);
}

static void mm_support_initbblib() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 6;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9146;
L9144:
	R1 = 1;
	R2 = (u64)&mm_decls_typestarterset;
	R3 = (u64)&mm_tables_d_typestarterset;
	asi64(R4) = i;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L9144;
L9146:
	return;
}

static i64 mm_support_getfileno(u64 pos) {
    u64 R1, R2, R3; 
	i64 fileno;
	asu64(R1) = pos;
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9150;
	asi64(R1) = fileno;
	asi64(R2) = mm_decls_nsourcefiles;
	if (asi64(R1) <= asi64(R2)) goto L9149;
L9150:
	R1 = tou64("No file no");
	mlib_abortprogram(asu64(R1));
L9149:
	asi64(R1) = fileno;
	goto L9147;
L9147:
	return asi64(R1);
}

static i64 mm_support_getlineno(u64 pos) {
    u64 R1, R2; 
	u64 source;
	u64 sline;
	u64 s;
	i64 lineno;
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	source = asu64(R1);
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourceline(asu64(R1));
	sline = asu64(R1);
	asu64(R1) = sline;
	s = asu64(R1);
	R1 = 1;
	lineno = asi64(R1);
	goto L9153;
L9152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9156;
	R1 = (u64)&lineno;
	(*toi64p(R1)) += 1;
L9156:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
L9153:
	asu64(R1) = s;
	asu64(R2) = source;
	if (asu64(R1) >= asu64(R2)) goto L9152;
	asi64(R1) = lineno;
	goto L9151;
L9151:
	return asi64(R1);
}

static u64 mm_support_getsourceline(u64 pos) {
    u64 R1, R2; 
	u64 source;
	u64 s;
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	source = asu64(R1);
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcepos(asu64(R1));
	s = asu64(R1);
	goto L9159;
L9158:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
L9159:
	asu64(R1) = s;
	asu64(R2) = source;
	if (asu64(R1) <= asu64(R2)) goto L9161;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9158;
L9161:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9163;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L9163:
	asu64(R1) = s;
	goto L9157;
L9157:
	return asu64(R1);
}

static u64 mm_support_getsourcestart(u64 pos) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L9164;
L9164:
	return asu64(R1);
}

static u64 mm_support_getsourcepos(u64 pos) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pos;
	R3 = 0;
	R4 = 23;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R1 += (i64)R2;
	goto L9165;
L9165:
	return asu64(R1);
}

static i64 mm_support_mgetsourceinfo(i64 pos, u64 filename, u64 sourceline) {
    u64 R1, R2; 
	i64 lineno;
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	lineno = asi64(R1);
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	asu64(R2) = sourceline;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = filename;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = lineno;
	goto L9166;
L9166:
	return asi64(R1);
}

static void mm_support_do_writema(u64 inpfile) {
    u64 R1, R2, R3, R4; 
	struct $B15 filename;
	struct $B50 sflist;
	u64 f;
	i64 offset;
	i64 nfiles;
	i64 fileno;
	u64 pf;
	i64 i;
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9169;
	goto L9167;
L9169:
	R1 = tou64("ma");
	asu64(R2) = inpfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	nfiles = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9172;
L9170:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9174;
	asi64(R1) = i;
	R2 = (u64)&sflist;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L9174:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L9170;
L9172:
	asi64(R1) = nfiles;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9176;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA: no files");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L9176:
	R1 = tou64("wb");
	R2 = (u64)&filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L9178;
	R1 = tou64("");
	R2 = (u64)&filename;
	R3 = tou64("Can't create MA file ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L9178:
	asi64(R1) = mm_decls_fverbose;
	if (!asi64(R1)) goto L9180;
	msysc_m$print_startcon();
	R1 = tou64("Writing ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9180:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== MA # ===");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9183;
L9181:
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&sflist;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== # # # #/# ===");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pf;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pf;
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi64(R1) = mlib_getfilepos(asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pf;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	asu64(R3) = pf;
	R4 = 40;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= nfiles) goto L9181;
L9183:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== END ===");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9186;
L9184:
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&sflist;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pf;
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= nfiles) goto L9184;
L9186:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 0;
	exit(R1);
L9167:
	return;
}

static void mm_support_do_getinfo(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 fs;
	u64 pm;
	i64 i;
	asi64(R1) = mm_decls_passlevel;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9189;
	R1 = tou64("wb");
	R2 = tou64("list");
	asu64(R3) = filename;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	R3 = R2;
	fs = asu64(R3);
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L9191;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = fs;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_decls_stprogram;
	asu64(R2) = f;
	mm_support_getst(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L9191:
L9189:
	asi64(R1) = mm_decls_passlevel;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L9193;
	R1 = tou64("wb");
	R2 = tou64("proj");
	asu64(R3) = filename;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	R3 = R2;
	fs = asu64(R3);
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L9195;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = fs;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9198;
L9196:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("16jl");
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("16jl");
	R2 = (u64)&mm_decls_subprogs;
	asu64(R3) = pm;
	R4 = 18;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("q");
	asu64(R2) = pm;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	asu64(R1) = pm;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nmodules) goto L9196;
L9198:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L9195:
L9193:
	return;
}

static void mm_support_getst(u64 f, u64 d) {
    u64 R1, R2; 
	u64 q;
	asu64(R1) = d;
	asu64(R2) = f;
	mm_support_getstrec(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L9203;
L9200:
	asu64(R1) = q;
	asu64(R2) = f;
	mm_support_getst(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9203:
	asu64(R1) = q;
	if (asu64(R1)) goto L9200;
	return;
}

static void mm_support_getstrec(u64 f, u64 d) {
    u64 R1, R2, R3, R4, R5; 
	u64 name;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9206;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9206;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9206;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9206;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9206;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L9206;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9206;
	goto L9207;
L9206:
	goto L9205;
L9207:
	goto L9204;
L9205:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9209;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9209;
	goto L9204;
L9209:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jl");
	R2 = (u64)&mm_decls_subprogs;
	R3 = (u64)&mm_decls_moduletosub;
	asu64(R4) = d;
	R5 = 94;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = d;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("18jl");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9211;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9212;
	goto L9213;
L9211:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9215;
	R1 = tou64("funcid");
	goto L9214;
L9215:
	R1 = tou64("procid");
L9214:
	name = asu64(R1);
	goto L9210;
L9212:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9217;
	R1 = tou64("dllfuncid");
	goto L9216;
L9217:
	R1 = tou64("dllprocid");
L9216:
	name = asu64(R1);
	goto L9210;
L9213:
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	name = asu64(R1);
L9210:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jl");
	asu64(R2) = name;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("5");
	asu64(R2) = d;
	R3 = 88;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asi64(R2) = mm_support_getlineno(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9219;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9220;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9221;
	goto L9222;
L9219:
	R1 = tou64("Module");
	name = asu64(R1);
	goto L9218;
L9220:
	R1 = tou64("Subprog");
	name = asu64(R1);
	goto L9218;
L9221:
	R1 = tou64("Program");
	name = asu64(R1);
	goto L9218;
L9222:
	R1 = tou64("Export");
	name = asu64(R1);
L9218:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9224;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Import ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L9224:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jlq");
	R2 = 1;
	asu64(R3) = d;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("q");
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_modules;
	asu64(R4) = d;
	R5 = 94;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	R4 = 20;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9204:
	return;
}

static void mm_tables_start() {
    u64 R1, R2, R3, R4; 
	i64 genop;
	i64 s;
	i64 t;
	i64 a;
	i64 specop;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 12;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9228;
L9226:
	R1 = 1;
	R2 = (u64)&mm_tables_endsexpr;
	R3 = (u64)&mm_tables_exprendsymbols;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= av_1) goto L9226;
L9228:
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 18;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 19;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 43;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tpass(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 d;
	u64 a;
	u64 b;
	u64 c;
	u64 q;
	i64 oldmmpos;
	i64 m;
	i64 nparams;
	i64 paramtype;
	i64 restype;
	i64 amode;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9231;
	goto L9229;
L9231:
	asi64(R1) = mm_type_tpass_depth;
	R2 = 100;
	if (asi64(R1) != asi64(R2)) goto L9233;
	R1 = 0;
	R2 = tou64("TX looping detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9233:
	R1 = (u64)&mm_type_tpass_depth;
	(*toi64p(R1)) += 1;
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: case 7: goto L9238;
	case 2: case 3: case 5: case 9: case 23: case 25: case 26: case 27: case 29: case 30: case 31: case 42: case 43: case 44: case 45: case 47: case 50: case 54: case 57: case 63: case 64: case 69: case 70: case 71: case 72: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: goto L9236;
	case 4: goto L9237;
	case 6: goto L9269;
	case 8: goto L9299;
	case 10: case 11: goto L9302;
	case 12: goto L9303;
	case 13: goto L9341;
	case 14: goto L9344;
	case 15: case 16: goto L9257;
	case 17: case 18: case 19: goto L9258;
	case 20: goto L9285;
	case 21: goto L9262;
	case 22: goto L9343;
	case 24: goto L9342;
	case 28: goto L9247;
	case 32: goto L9255;
	case 33: case 35: goto L9241;
	case 34: goto L9335;
	case 36: goto L9243;
	case 37: goto L9244;
	case 38: goto L9245;
	case 39: goto L9246;
	case 40: goto L9261;
	case 41: goto L9242;
	case 46: goto L9253;
	case 48: goto L9268;
	case 49: goto L9256;
	case 51: case 52: goto L9267;
	case 53: goto L9254;
	case 55: goto L9248;
	case 56: goto L9251;
	case 58: goto L9259;
	case 59: goto L9340;
	case 60: goto L9282;
	case 61: goto L9260;
	case 62: goto L9239;
	case 65: case 66: goto L9240;
	case 67: goto L9304;
	case 68: goto L9321;
	case 73: case 74: goto L9320;
	case 86: goto L9307;
	case 87: case 88: goto L9298;
	case 89: goto L9272;
	case 90: goto L9322;
	case 91: goto L9281;
	case 92: goto L9252;
	case 93: case 94: goto L9279;
	case 95: case 96: goto L9280;
	case 97: goto L9290;
	case 98: goto L9294;
	case 99: goto L9288;
	case 100: goto L9289;
	case 101: case 102: case 103: goto L9287;
	case 104: goto L9271;
	case 105: case 106: goto L9266;
	case 107: case 108: case 109: case 110: goto L9265;
	case 111: goto L9263;
	case 112: goto L9264;
	case 113: goto L9315;
	case 114: case 115: case 116: case 117: goto L9273;
	case 118: goto L9309;
	case 119: goto L9308;
	case 120: goto L9286;
	case 121: goto L9270;
	case 122: goto L9336;
	default: goto L9236;
    };
// SWITCH
L9237:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tx_name(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9238:
	goto L9234;
L9239:
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9234;
L9240:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9234;
L9241:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_bin(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9242:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_tx_in(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9243:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_unary(asu64(R2), asu64(R1));
	goto L9234;
L9244:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_prop(asu64(R2), asu64(R1));
	goto L9234;
L9245:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_binto(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9246:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_unaryto(asu64(R2), asu64(R1));
	goto L9234;
L9247:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_assign(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9248:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 53;
	if (asi64(R1) != asi64(R2)) goto L9250;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9249;
L9250:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9249:
	goto L9234;
L9251:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_addroffirst(asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9252:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_if(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9253:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_type_tx_index(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9254:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_ptr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9255:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_callproc(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9256:
	asi64(R1) = lv;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_dot(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9257:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_andl(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9258:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_notl(asu64(R2), asu64(R1));
	goto L9234;
L9259:
	R1 = 1;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_convert(asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9260:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_typepun(asu64(R2), asu64(R1));
	goto L9234;
L9261:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_incrto(asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9262:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_makerange(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9263:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_swap(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9264:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_select(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9265:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_switch(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9266:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9267:
	asi64(R1) = lv;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_dotindex(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9268:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_slice(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9269:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_block(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9270:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9271:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9272:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_return(asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9273:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_type_fixchararray(asu64(R1));
	goto L9275;
L9274:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) != asi64(R2)) goto L9278;
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = R3;
	c = asu64(R4);
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 20;
	asu64(R3) = b;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9277;
L9278:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	R4 = R3;
	c = asu64(R4);
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9277:
	asu64(R1) = c;
	mm_type_fixchararray(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L9275:
	asu64(R1) = b;
	if (asu64(R1)) goto L9274;
	R1 = 0;
	R2 = 23;
	asu64(R3) = p;
	R4 = 32;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9279:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	mm_type_tx_for(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9280:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	mm_type_tx_forall(asu64(R3), asu64(R2), asu64(R1));
	goto L9234;
L9281:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9282:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9284;
	R1 = 0;
	R2 = tou64("cast() needs type");
	mm_support_txerror(asu64(R2), asu64(R1));
L9284:
	R1 = 1;
	asi64(R2) = t;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L9234;
L9285:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_makelist(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9286:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9287:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_exit(asu64(R2), asu64(R1));
	goto L9234;
L9288:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_goto(asu64(R2), asu64(R1));
	goto L9234;
L9289:
	goto L9234;
L9290:
	R1 = 0;
	R2 = 6;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L9292;
	R1 = 104;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L9291;
L9292:
	asu64(R1) = a;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L9293;
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9293:
L9291:
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9294:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (asi64(R1)) goto L9297;
	asu64(R1) = b;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L9296;
L9297:
	R1 = 0;
	R2 = tou64("repeat/const cond");
	mm_support_txerror(asu64(R2), asu64(R1));
L9296:
	goto L9234;
L9298:
	goto L9234;
L9299:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9301;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9301:
	R1 = 1;
	mm_type_inassem = asi64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = c;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	mm_type_inassem = asi64(R1);
	goto L9234;
L9302:
	goto L9234;
L9303:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9304:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L9306;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	m = asi64(R1);
	goto L9305;
L9306:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
L9305:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9234;
L9307:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9308:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9234;
L9309:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9311;
	R1 = 0;
	R2 = 5;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9311:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9314;
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9313;
L9314:
	asi64(R1) = t;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	t = asi64(R1);
L9313:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9234;
L9315:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9317;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9319;
	R1 = 0;
	R2 = tou64("recase must be const");
	mm_support_txerror(asu64(R2), asu64(R1));
L9319:
L9317:
	goto L9234;
L9320:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9234;
L9321:
	asi64(R1) = lv;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_bitfield(asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9322:
	R1 = 0;
	restype = asi64(R1);
	R1 = 0;
	paramtype = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L9324;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L9325;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L9326;
	goto L9327;
L9324:
	R1 = 3;
	restype = asi64(R1);
	goto L9323;
L9325:
	R1 = 3;
	paramtype = asi64(R1);
	R1 = 20;
	restype = asi64(R1);
	goto L9323;
L9326:
	R1 = 3;
	paramtype = asi64(R1);
	R1 = 7;
	restype = asi64(R1);
	goto L9323;
L9327:
L9323:
	asi64(R1) = paramtype;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9329;
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9331;
	R1 = 0;
	R2 = tou64("sys: arg missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L9331:
	R1 = 0;
	asi64(R2) = paramtype;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9333;
	R1 = 0;
	R2 = tou64("sys: too many args");
	mm_support_txerror(asu64(R2), asu64(R1));
L9333:
	goto L9328;
L9329:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9334;
	R1 = 0;
	R2 = tou64("sys: too many args");
	mm_support_txerror(asu64(R2), asu64(R1));
L9334:
L9328:
	asi64(R1) = restype;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9234;
L9335:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_cmpchain(asu64(R2), asu64(R1));
	goto L9234;
L9336:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9338;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9338;
	goto L9339;
L9338:
	goto L9337;
L9339:
	R1 = 0;
	R2 = tou64("Clear scalar?");
	mm_support_txerror(asu64(R2), asu64(R1));
L9337:
	goto L9234;
L9340:
	goto L9234;
L9341:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_strinclude(asu64(R2), asu64(R1));
	goto L9234;
L9342:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_makeslice(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9343:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_makeset(asu64(R3), asu64(R2), asi64(R1));
	goto L9234;
L9344:
	goto L9234;
L9236:
	msysc_m$print_startcon();
	R1 = tou64("TXUNIT: CAN'T DO:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
// mm_type.tpass.doelse:
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9348;
L9346:
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	R4 = 16;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L9346;
L9348:
L9234:
	asu64(R1) = p;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9350;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L9350;
	goto L9351;
L9350:
	goto L9349;
L9351:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L9353;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9353;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L9353;
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L9353:
L9349:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9355;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9357;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L9357;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L9357;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L9357;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9358;
	goto L9359;
L9357:
	goto L9356;
L9358:
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9362;
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L9361;
L9362:
L9361:
	goto L9356;
L9359:
L9356:
L9355:
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_type_tpass_depth;
	(*toi64p(R1)) -=1;
L9229:
	return;
}

static void mm_type_tx_allprocs() {
    u64 R1, R2, R3; 
	u64 pp;
	u64 pcode;
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L9365;
L9364:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_decls_currproc = asu64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcode = asu64(R1);
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	R3 = 122;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 1;
	if (asi64(R2) <= asi64(R3)) goto L9368;
	R2 = 28;
	goto L9367;
L9368:
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
L9367:
	asu64(R3) = pcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9370;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L9371;
	goto L9372;
L9370:
	goto L9369;
L9371:
	goto L9369;
L9372:
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L9374;
	R1 = 89;
	asu64(R2) = pcode;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pcode;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pcode;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9374:
L9369:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L9365:
	asu64(R1) = pp;
	if (asu64(R1)) goto L9364;
	return;
}

static void mm_type_tx_block(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	goto L9377;
L9376:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L9377:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9379;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L9376;
L9379:
	asu64(R1) = a;
	if (!asu64(R1)) goto L9381;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9383;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L9382;
L9383:
	R1 = 0;
L9382:
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9381:
	return;
}

static void mm_type_tx_typetable() {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 31;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L9387;
L9385:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L9389;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	d = asu64(R2);
	mm_type_tx_passdef(asu64(R1));
L9389:
	asi64(R1) = i;
	mm_type_setmodesize(asi64(R1));
	i += 1; if (i <= mm_decls_ntypes) goto L9385;
L9387:
	return;
}

static void mm_type_setmodesize(i64 m) {
    u64 R1, R2, R3; 
	i64 size;
	i64 target;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L9392;
	goto L9390;
L9392:
	R1 = (u64)&mm_decls_ttlineno;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9394;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9395;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9396;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L9396;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9397;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L9398;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L9399;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L9400;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L9401;
	goto L9402;
L9394:
	asi64(R1) = m;
	mm_type_setarraysize(asi64(R1));
	goto L9393;
L9395:
	asi64(R1) = m;
	mm_type_setrecordsize(asi64(R1));
	goto L9393;
L9396:
	goto L9393;
L9397:
	asi64(R1) = m;
	mm_type_setslicesize(asi64(R1));
	goto L9393;
L9398:
	R1 = 0;
	R2 = tou64("SETMODESIZE/AUTO?");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L9393;
L9399:
	goto L9393;
L9400:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = target;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = target;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L9393;
L9401:
	goto L9393;
L9402:
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = R1;
	size = asi64(R2);
	if (!asi64(R1)) goto L9404;
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	goto L9390;
L9404:
	msysc_m$print_startcon();
	R1 = tou64("SIZE 0:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STDNAMES[TTBASETYPE[M]]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_stdnames;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Can't set mode size");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9393:
L9390:
	return;
}

static void mm_type_setarraysize(i64 m) {
    u64 R1, R2, R3; 
	i64 lower;
	i64 length;
	i64 elemsize;
	i64 target;
	i64 size;
	u64 pdim;
	u64 a;
	u64 b;
	R1 = (u64)&mm_decls_ttsizeset;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9407;
	goto L9405;
L9407:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pdim = asu64(R1);
	asu64(R1) = pdim;
	if (!asu64(R1)) goto L9409;
	asu64(R1) = pdim;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = pdim;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = pdim;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = pdim;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L9411;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L9412;
	goto L9413;
L9411:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	lower = asi64(R1);
	asu64(R1) = b;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	goto L9410;
L9412:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	lower = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L9415;
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	length = asi64(R1);
	goto L9414;
L9415:
	R1 = 0;
	length = asi64(R1);
L9414:
	goto L9410;
L9413:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pdim;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdim;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	length = asi64(R1);
	R1 = 1;
	lower = asi64(R1);
L9410:
	goto L9408;
L9409:
	R1 = 1;
	lower = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L9408:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L9417;
	R1 = 0;
	R2 = tou64("Neg length");
	mm_support_txerror(asu64(R2), asu64(R1));
L9417:
	R1 = 0;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	elemsize = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	R2 = R1;
	size = asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttsizeset;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	mm_type_checkblocktype(asi64(R1));
L9405:
	return;
}

static void mm_type_setslicesize(i64 m) {
    u64 R1, R2, R3; 
	u64 pdim;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L9420;
	goto L9418;
L9420:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pdim = asu64(R1);
	asu64(R1) = pdim;
	if (!asu64(R1)) goto L9422;
	asu64(R1) = pdim;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = pdim;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdim;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L9421;
L9422:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L9421:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = 11;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
L9418:
	return;
}

static i64 mm_type_tx_module(i64 n) {
    u64 R1, R2; 
	struct $B30 m;
	u64 d;
	i64 globalflag;
	i64 status;
	asi64(R1) = n;
	mm_decls_currmoduleno = asi64(R1);
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_tx_passdef(asu64(R1));
	R1 = 1;
	goto L9423;
L9423:
	return asi64(R1);
}

static void mm_type_tx_passdef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 oldmmpos;
	u64 q;
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9426;
	goto L9424;
L9426:
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L9428;
L9427:
	asu64(R1) = d;
	mm_type_tx_passdef(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L9428:
	asu64(R1) = d;
	if (asu64(R1)) goto L9427;
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9431;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9432;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9433;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9433;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9433;
	goto L9434;
L9431:
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	goto L9430;
L9432:
	asu64(R1) = p;
	mm_type_tx_namedconst(asu64(R1));
	goto L9430;
L9433:
	asu64(R1) = p;
	mm_type_tx_namedef(asu64(R1));
	goto L9430;
L9434:
L9430:
	R1 = 1;
	asu64(R2) = p;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
L9424:
	return;
}

static void mm_type_tx_unitlist(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	goto L9437;
L9436:
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L9437:
	asu64(R1) = p;
	if (asu64(R1)) goto L9436;
	return;
}

static void mm_type_tx_namedef(u64 d) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mold;
	i64 inidataold;
	u64 dcode;
	u64 pequiv;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9441;
	R1 = 0;
	R2 = tou64("Circular reference detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9441:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9443;
	goto L9439;
L9443:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = m;
	mm_type_setmodesize(asi64(R1));
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dcode = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9445;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pequiv = asu64(R1);
	asu64(R1) = pequiv;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L9447;
	asu64(R1) = pequiv;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pequiv;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L9447:
	asu64(R1) = pequiv;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9449;
	R1 = 0;
	R2 = tou64("@name needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L9449:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pequiv;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9445:
	asu64(R1) = dcode;
	if (!asu64(R1)) goto L9451;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9451;
	asi64(R1) = m;
	mold = asi64(R1);
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L9453;
	asu64(R1) = dcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9453;
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L9453;
	R1 = 0;
	R2 = 20;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9452;
L9453:
	asi64(R1) = mm_type_inidata;
	inidataold = asi64(R1);
	R1 = 1;
	mm_type_inidata = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = inidataold;
	mm_type_inidata = asi64(R1);
L9452:
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9455;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9455;
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9455:
	asi64(R1) = mold;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L9457;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9459;
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = mold;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9459;
	R1 = 59;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = mold;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9458;
L9459:
	asi64(R1) = mold;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9460;
	asi64(R1) = mold;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9460:
L9458:
L9457:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9462;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_checkconstexpr(asu64(R1));
L9462:
	goto L9450;
L9451:
	asu64(R1) = dcode;
	if (!asu64(R1)) goto L9463;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L9463;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L9463;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9463;
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L9450;
L9463:
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L9450:
L9439:
	return;
}

static void mm_type_tx_namedconst(u64 d) {
    u64 R1, R2, R3; 
	i64 m;
	u64 q;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9466;
	R1 = 0;
	R2 = tou64("Circular const reference detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9466:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9468;
	goto L9464;
L9468:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asi64(R2) = m;
	R3 = 22;
	if (asi64(R2) != asi64(R3)) goto L9470;
	R2 = 23;
	goto L9469;
L9470:
	asi64(R2) = m;
L9469:
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	asi64(R1) = m;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L9472;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9472:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9474;
	goto L9475;
L9474:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9477;
	R1 = 0;
	R2 = tou64("Bad const type");
	mm_support_txerror(asu64(R2), asu64(R1));
L9477:
	goto L9473;
L9475:
L9473:
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L9464:
	return;
}

static void mm_type_checkconstexpr(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 pmode;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9480;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L9480;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9481;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L9482;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L9483;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L9484;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L9484;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9485;
	goto L9486;
L9480:
	goto L9478;
	goto L9479;
L9481:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L9488;
L9487:
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9488:
	asu64(R1) = q;
	if (asu64(R1)) goto L9487;
	goto L9479;
L9482:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9491;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L9490;
L9491:
	goto L9492;
L9490:
	goto L9479;
L9483:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_checkconstexpr(asu64(R1));
	goto L9479;
L9484:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9494;
	goto L9495;
L9494:
	goto L9493;
L9495:
	goto L9492;
L9493:
	goto L9479;
L9485:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9497;
	goto L9478;
L9497:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L9499;
	goto L9478;
L9499:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L9501;
	goto L9478;
L9501:
	goto L9492;
	goto L9479;
L9486:
// mm_type.checkconstexpr.error:
L9492:
	msysc_m$print_startcon();
	R1 = tou64("JTAGNAMES[P.TAG]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("Getconstexpr: not const");
	mm_support_txerror(asu64(R2), asu64(R1));
L9479:
L9478:
	return;
}

static i64 mm_type_getconstint(u64 q) {
    u64 R1, R2, R3; 
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9505;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L9504;
L9505:
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L9502;
	goto L9503;
L9504:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9506;
	asu64(R1) = q;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L9502;
	goto L9503;
L9506:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Getconstint: not i32/64");
	mm_support_txerror(asu64(R2), asu64(R1));
L9503:
	R1 = 0;
	goto L9502;
L9502:
	return asi64(R1);
}

static void mm_type_makenewconst(u64 p, i64 x, i64 t) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9509;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9509:
	return;
}

static void mm_type_tx_name(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	u64 d;
	i64 oldmmpos;
	u64 pcode;
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9512;
	goto L9510;
L9512:
	asu64(R1) = p;
	R2 = 2;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9514;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9515;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9515;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9515;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9516;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9516;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9517;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9518;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L9519;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9520;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9521;
	goto L9522;
L9514:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L9524;
	R1 = 0;
	R2 = tou64("&const");
	mm_support_txerror(asu64(R2), asu64(R1));
L9524:
	asu64(R1) = d;
	mm_type_tx_namedconst(asu64(R1));
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcode = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L9526;
	asu64(R1) = pcode;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L9525;
L9526:
	asu64(R1) = pcode;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L9525:
	asu64(R1) = pcode;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pcode;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9513;
L9515:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9528;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L9528;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't use 'let' as lvalue: ");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9528:
	asu64(R1) = d;
	mm_type_tx_namedef(asu64(R1));
	asi64(R1) = mm_type_inassem;
	if (asi64(R1)) goto L9530;
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9532;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9534;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 53;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9534:
L9532:
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	goto L9529;
L9530:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9529:
	goto L9513;
L9516:
	asi64(R1) = mm_tables_trefproc;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9513;
L9517:
	asi64(R1) = mm_tables_treflabel;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9513;
L9518:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Module name can't be used on it's own: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L9513;
L9519:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9513;
L9520:
	R1 = 62;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9513;
L9521:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9536;
	R1 = 0;
	R2 = tou64("Can't init dllvar");
	mm_support_txerror(asu64(R2), asu64(R1));
L9536:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9513;
L9522:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_tables_namenames;
	asu64(R3) = d;
	R4 = 78;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("TNAME? # #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9513:
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
L9510:
	return;
}

static void mm_type_tx_bin(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 q;
	i64 amode;
	i64 bmode;
	i64 abase;
	i64 bbase;
	i64 cmode;
	i64 resmode;
	i64 relop;
	i64 simpleset;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L9539;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L9540;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L9541;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L9542;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L9543;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L9543;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L9543;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L9543;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L9543;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L9543;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L9544;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L9544;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L9545;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L9546;
	R2 = 81;
	if (asi64(R1) == asi64(R2)) goto L9546;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L9547;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L9547;
	goto L9548;
L9539:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9550;
	goto L9537;
L9550:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9552;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9554;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9554;
	asu64(R1) = b;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9554;
	asu64(R1) = p;
	mm_type_combinestrings(asu64(R1));
	goto L9537;
L9554:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9556;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 57;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9537;
L9556:
L9552:
	goto L9538;
L9540:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9558;
	goto L9537;
L9558:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9560;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9562;
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L9564;
	R1 = 59;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9537;
	goto L9563;
L9564:
	R1 = 0;
	R2 = tou64("ref-ref: not compat");
	mm_support_txerror(asu64(R2), asu64(R1));
L9563:
L9562:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9566;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 58;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9537;
L9566:
L9560:
	goto L9538;
L9541:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9568;
	goto L9537;
L9568:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9570;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9572;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9572;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9572;
	asu64(R1) = p;
	mm_type_mulstrings(asu64(R1));
	goto L9537;
L9572:
L9570:
	goto L9538;
L9542:
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9575;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9575;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L9574;
L9575:
	asi64(R1) = bmode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9576;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9576;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L9574;
L9576:
	R1 = 47;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9577;
L9574:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumf(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9579;
	goto L9537;
L9579:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9581;
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9581;
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L9537;
L9581:
	goto L9538;
L9543:
// mm_type.tx_bin.doidiv:
L9577:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumi(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9583;
	goto L9537;
L9583:
	goto L9538;
L9544:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9585;
	goto L9537;
L9585:
	goto L9538;
L9545:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9587;
	goto L9537;
L9587:
	goto L9538;
L9546:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9537;
	goto L9538;
L9547:
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9590;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9590;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L9589;
L9590:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9537;
L9589:
	goto L9538;
L9548:
	asu64(R1) = p;
	R2 = 64;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9592;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9594;
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9537;
L9594:
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9596;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9596;
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9598;
	R1 = 0;
	R2 = tou64("Cmp ref/ref not compat");
	mm_support_txerror(asu64(R2), asu64(R1));
L9598:
	goto L9537;
L9596:
	asu64(R1) = p;
	R2 = 64;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9601;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9600;
L9601:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L9603;
	goto L9537;
L9603:
L9600:
	goto L9591;
L9592:
	R1 = 0;
	R2 = tou64("txbin?");
	mm_support_txerror(asu64(R2), asu64(R1));
L9591:
L9538:
	msysc_m$print_startcon();
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	asi64(R2) = bmode;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("BIN/CAN'T RESOLVE MODES");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9537:
	return;
}

static void mm_type_tx_binto(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 abase;
	i64 bbase;
	i64 amode;
	i64 bmode;
	i64 opc;
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = bmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	bbase = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 93;
	if (asi64(R1) != asi64(R2)) goto L9606;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = abase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9606;
	R1 = 94;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9606:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L9608;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L9609;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L9610;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L9610;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L9610;
	R2 = 97;
	if (asi64(R1) == asi64(R2)) goto L9610;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L9610;
	goto L9611;
L9608:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9613;
	asi64(R1) = bbase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9613;
	R1 = 0;
	R2 = tou64("to:ref+ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L9613:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9615;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9615;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 103;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9604;
L9615:
	goto L9607;
L9609:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9617;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9617;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 104;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9604;
L9617:
	goto L9607;
L9610:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L9604;
	goto L9607;
L9611:
L9607:
	asi64(R1) = abase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9619;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9619;
	R1 = 0;
	asi64(R2) = abase;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L9618;
L9619:
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = abase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9620;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9620;
	R1 = 0;
	asi64(R2) = abase;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L9618;
L9620:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9622;
	R1 = 1;
	asi64(R2) = bmode;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("BIN: modes not compatible: # #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9622:
L9618:
L9604:
	return;
}

static i64 mm_type_getdominantmode(i64 amode, i64 bmode) {
    u64 R1, R2; 
	i64 abase;
	i64 bbase;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = bmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	bbase = asi64(R1);
	asi64(R1) = abase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9625;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L9625;
	asi64(R1) = abase;
	asi64(R2) = bbase;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	goto L9623;
L9625:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9627;
	R1 = 0;
	R2 = tou64("Getdom: no dominant mode");
	mm_support_txerror(asu64(R2), asu64(R1));
L9627:
	asi64(R1) = amode;
	goto L9623;
L9623:
	return asi64(R1);
}

static void mm_type_tx_cmpchain(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 u;
	i64 genop;
	u64 q;
	u64 r;
	i64 av_1;
	i64 i;
	asu64(R1) = a;
	q = asu64(R1);
	goto L9630;
L9629:
	R1 = 0;
	R2 = 23;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	asu64(R2) = a;
	if (asu64(R1) != asu64(R2)) goto L9633;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L9632;
L9633:
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L9632:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9630:
	asu64(R1) = q;
	if (asu64(R1)) goto L9629;
	asu64(R1) = a;
	q = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L9635;
L9634:
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = q;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9635:
	asu64(R1) = q;
	if (asu64(R1)) goto L9634;
	R1 = 1;
	i = asi64(R1);
	R1 = 4;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9639;
L9637:
	asu64(R1) = p;
	R2 = 40;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	genop = asi64(R1);
	asi64(R1) = genop;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9641;
	goto L9639;
L9641:
	asi64(R1) = u;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 32;
	R2 += (i64)R3;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
	i += 1; if (i <= av_1) goto L9637;
L9639:
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_callproc(u64 p, u64 a, u64 pargs, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	u64 e;
	u64 pm;
	struct $B93 paramlist;
	struct $B93 arglist;
	struct $B93 newarglist;
	i64 nparams;
	i64 i;
	i64 j;
	i64 k;
	i64 nargs;
	i64 m;
	i64 kwdused;
	i64 qm;
	i64 ismproc;
	u64 name;
	u64 ulist;
	u64 ulistx;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = R1;
	nparams = asi64(R2);
	nargs = asi64(R1);
	R1 = 0;
	ismproc = asi64(R1);
// mm_type.tx_callproc.retry:
L9643:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9645;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L9646;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L9646;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9646;
	goto L9647;
L9645:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9650;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L9649;
L9650:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	ismproc = asi64(R1);
// mm_type.tx_callproc.getparams:
L9651:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L9653;
L9652:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L9656;
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L9658;
	R1 = 0;
	R2 = tou64("Param overflow");
	mm_support_txerror(asu64(R2), asu64(R1));
L9658:
	asu64(R1) = e;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L9656:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L9653:
	asu64(R1) = e;
	if (asu64(R1)) goto L9652;
	goto L9648;
L9649:
	goto L9660;
L9659:
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9660:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9659;
	goto L9662;
L9648:
	goto L9644;
L9646:
	R1 = 0;
	R2 = tou64("Can't do ifx/function");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L9644;
L9647:
// mm_type.tx_callproc.dorefproc:
L9662:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) != asi64(R2)) goto L9664;
	asu64(R1) = pargs;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tmethodcall(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pargs = asu64(R1);
	goto L9643;
L9664:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L9666;
	R1 = 0;
	R2 = tou64("Function pointer expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9666:
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9668;
	R1 = 0;
	R2 = tou64("Function expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9668:
	goto L9651;
L9644:
	asu64(R1) = pargs;
	q = asu64(R1);
	goto L9670;
L9669:
	asi64(R1) = nargs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L9673;
	R1 = 0;
	R2 = tou64("Param overflow");
	mm_support_txerror(asu64(R2), asu64(R1));
L9673:
	asu64(R1) = q;
	R2 = (u64)&arglist;
	R3 = (u64)&nargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9670:
	asu64(R1) = q;
	if (asu64(R1)) goto L9669;
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L9675;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9675;
	R1 = 0;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
L9675:
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9677;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9680;
L9678:
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L9682;
	R1 = 0;
	R2 = (u64)&paramlist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&arglist;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L9681;
L9682:
	R1 = 0;
	R2 = 23;
	R3 = (u64)&arglist;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9681:
	i += 1; if (i <= nargs) goto L9678;
L9680:
	goto L9642;
L9677:
	R1 = 0;
	k = asi64(R1);
	R1 = 0;
	kwdused = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9685;
L9683:
	R1 = 0;
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nparams) goto L9683;
L9685:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9688;
L9686:
	R1 = (u64)&arglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L9690;
	goto L9691;
L9690:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9695;
L9692:
	asu64(R1) = name;
	R2 = (u64)&paramlist;
	asi64(R3) = j;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L9697;
	goto L9694;
L9697:
	j += 1; if (j <= nparams) goto L9692;
L9695:
	R1 = 0;
	asu64(R2) = name;
	R3 = tou64("Can't find kwd param: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9694:
	R1 = (u64)&newarglist;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L9699;
	R1 = 0;
	asu64(R2) = name;
	R3 = tou64("Kwd: # already used or was implicit");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9699:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&newarglist;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	kwdused = asi64(R1);
	goto L9689;
L9691:
	asi64(R1) = kwdused;
	if (!asi64(R1)) goto L9701;
	R1 = 0;
	R2 = tou64("Normal param follows kwd");
	mm_support_txerror(asu64(R2), asu64(R1));
L9701:
	asi64(R1) = k;
	asi64(R2) = nparams;
	if (asi64(R1) < asi64(R2)) goto L9703;
	msysc_m$print_startcon();
	R1 = tou64("K=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = k;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("NPARAMS=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Too many params supplied");
	mm_support_txerror(asu64(R2), asu64(R1));
L9703:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L9705;
	R1 = 0;
	goto L9704;
L9705:
	asu64(R1) = q;
L9704:
	R2 = (u64)&newarglist;
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L9689:
	i += 1; if (i <= nargs) goto L9686;
L9688:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9708;
L9706:
	R1 = (u64)&newarglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pm = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9710;
	asu64(R1) = pm;
	R2 = 161;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9712;
	R1 = 0;
	R2 = 0;
	asi64(R3) = i;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Param not optional: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9712:
	asu64(R1) = pm;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L9714;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pm;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L9713;
L9714:
	R1 = 3;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L9713:
L9710:
	i += 1; if (i <= nparams) goto L9706;
L9708:
	R1 = 0;
	ulist = asu64(R1);
	R1 = 0;
	ulistx = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L9717;
L9715:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pm = asu64(R1);
	R1 = (u64)&newarglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = pm;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9719;
	R1 = 1;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = pm;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = R2;
	m = asi64(R3);
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qm = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = qm;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9721;
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = qm;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("&param: type mismatch");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9721:
	R1 = 55;
	asu64(R2) = q;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = pm;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9718;
L9719:
	R1 = 0;
	asu64(R2) = pm;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L9718:
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	i += 1; if (i <= nparams) goto L9715;
L9717:
	asu64(R1) = ulist;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9642:
	return;
}

static void mm_type_tx_unary(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 size;
	i64 amode;
	i64 mbase;
	i64 tmax;
	i64 x;
	i64 xhigh;
	i64 resmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asi64(R1) = amode;
	resmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L9724;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L9725;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L9725;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L9725;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L9726;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L9726;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L9726;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L9727;
	goto L9728;
L9724:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	resmode = asi64(R1);
	goto L9723;
L9725:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) <= asi64(R2)) goto L9730;
	R1 = 0;
	R2 = tou64("not num");
	mm_support_txerror(asu64(R2), asu64(R1));
L9730:
	goto L9723;
L9726:
	asi64(R1) = amode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L9732;
	R1 = 0;
	R2 = tou64("toboolt");
	mm_support_txerror(asu64(R2), asu64(R1));
L9732:
	goto L9723;
L9727:
	R1 = 3;
	resmode = asi64(R1);
	goto L9723;
L9728:
	msysc_m$print_startcon();
	R1 = tou64("TTT");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9723:
	asi64(R1) = resmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_prop(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 size;
	i64 amode;
	i64 mbase;
	i64 tmax;
	i64 x;
	i64 xhigh;
	i64 resmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asi64(R1) = amode;
	resmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9735;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9735;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9735;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9735;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9735;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9736;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L9736;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L9737;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9737;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9738;
	goto L9739;
L9735:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_do_bounds(asu64(R2), asu64(R1));
	goto L9733;
	goto L9734;
L9736:
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 62;
	if (asi64(R2) != asi64(R3)) goto L9741;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	goto L9740;
L9741:
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
L9740:
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 7;
	if (asi64(R2) != asi64(R3)) goto L9743;
	R2 = 1;
	goto L9742;
L9743:
	R2 = 8;
L9742:
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	R1 = 0;
	asi64(R2) = size;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	resmode = asi64(R1);
	goto L9734;
L9737:
	R1 = 3;
	resmode = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L9745;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	goto L9744;
L9745:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
L9744:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L9747;
	asi64(R1) = mbase;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9749;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L9750;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9751;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9752;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9753;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9753;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9753;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9753;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9753;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L9753;
	goto L9754;
L9749:
	R1 = -128;
	x = asi64(R1);
	goto L9748;
L9750:
	R1 = -32768;
	x = asi64(R1);
	goto L9748;
L9751:
	R1 = -2147483648;
	x = asi64(R1);
	goto L9748;
L9752:
	R1 = 0x8000000000000000;
	x = asi64(R1);
	goto L9748;
L9753:
	R1 = 0;
	x = asi64(R1);
	goto L9748;
L9754:
	R1 = 0;
	R2 = 1;
	asi64(R3) = mbase;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do minvalue on #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9748:
	goto L9746;
L9747:
	asi64(R1) = mbase;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L9756;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L9757;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L9758;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L9759;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L9760;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L9760;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L9761;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L9762;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9763;
	goto L9764;
L9756:
	R1 = 127;
	x = asi64(R1);
	goto L9755;
L9757:
	R1 = 32767;
	x = asi64(R1);
	goto L9755;
L9758:
	R1 = 2147483647;
	x = asi64(R1);
	goto L9755;
L9759:
	R1 = 9223372036854775807;
	x = asi64(R1);
	goto L9755;
L9760:
	R1 = 255;
	x = asi64(R1);
	goto L9755;
L9761:
	R1 = 65535;
	x = asi64(R1);
	goto L9755;
L9762:
	R1 = 4294967295;
	x = asi64(R1);
	goto L9755;
L9763:
	R1 = 0;
	x = asi64(R1);
	R1 = (u64)&x;
	(*toi64p(R1)) -=1;
	R1 = 4;
	resmode = asi64(R1);
	goto L9755;
L9764:
	R1 = 0;
	R2 = 1;
	asi64(R3) = mbase;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do maxvalue on #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9755:
L9746:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9734;
L9738:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L9766;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	amode = asi64(R1);
	goto L9765;
L9766:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
L9765:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asi64(R2) = amode;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L9733;
	goto L9734;
L9739:
	msysc_m$print_startcon();
	R1 = tou64("PROP");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L9734:
	asi64(R1) = resmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9733:
	return;
}

static void mm_type_tx_unaryto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L9769;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L9769;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L9769;
	goto L9770;
L9769:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L9772;
	R1 = 0;
	R2 = tou64("Not int");
	mm_support_txerror(asu64(R2), asu64(R1));
L9772:
	goto L9768;
L9770:
L9768:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	u64 pc;
	u64 pl;
	i64 u;
	asu64(R1) = pcond;
	pc = asu64(R1);
	asu64(R1) = plist;
	pl = asu64(R1);
	R1 = 0;
	u = asi64(R1);
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L9775;
	asi64(R1) = t;
	u = asi64(R1);
L9775:
	goto L9779;
L9776:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pc;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = pl;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9781;
	asi64(R1) = u;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9783;
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L9782;
L9783:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L9784;
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9786;
	R1 = 0;
	R2 = tou64("IF/LV?");
	mm_support_txerror(asu64(R2), asu64(R1));
L9786:
	goto L9782;
L9784:
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L9782:
L9781:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = pl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pl = asu64(R1);
L9779:
	asu64(R1) = pc;
	if (asu64(R1)) goto L9776;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9788;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9788;
	R1 = 0;
	R2 = tou64("else needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L9788:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = pelse;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9790;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L9792;
	asu64(R1) = pelse;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9794;
	R1 = 0;
	R2 = tou64("IF/LV2?");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L9793;
L9794:
	asu64(R1) = pelse;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L9793:
L9792:
L9790:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9796;
	asu64(R1) = plist;
	pl = asu64(R1);
	goto L9800;
L9797:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9802;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pl;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L9802:
	asu64(R1) = pl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pl = asu64(R1);
L9800:
	asu64(R1) = pl;
	if (asu64(R1)) goto L9797;
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9804;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pelse;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L9804:
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9796:
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = plist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L9806;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9806;
	asu64(R1) = pcond;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L9808;
	asu64(R1) = plist;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L9807;
L9808:
	asu64(R1) = pcond;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L9809;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L9811;
	R1 = 6;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	pelse = asu64(R1);
L9811:
	asu64(R1) = pelse;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L9809:
L9807:
L9806:
	return;
}

static void mm_type_tx_incrto(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9814;
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L9816;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L9817;
	goto L9818;
L9816:
	R1 = 86;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9815;
L9817:
	R1 = 87;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9815;
L9818:
L9815:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9813;
L9814:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L9820;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L9821;
	goto L9822;
L9820:
	R1 = 84;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9819;
L9821:
	R1 = 85;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9819;
L9822:
L9819:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9813:
	R1 = 0;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_tx_for(u64 pindex, u64 pfrom, u64 pbody) {
    u64 R1, R2, R3, R4; 
	u64 pto;
	u64 pstep;
	u64 plocal;
	u64 plist;
	i64 u;
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = pto;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pstep = asu64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = pindex;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pindex;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9825;
	R1 = 0;
	R2 = tou64("Loop index not a variable");
	mm_support_txerror(asu64(R2), asu64(R1));
L9825:
	asu64(R1) = pindex;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = pindex;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pfrom;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pto;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pstep;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_type_tx_forall(u64 pindex, u64 plist, u64 pbody) {
    u64 R1, R2, R3, R4; 
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 passign;
	i64 u;
	i64 mlist;
	i64 elemtype;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plocal = asu64(R1);
	asu64(R1) = plocal;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	passign = asu64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = pindex;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = pfrom;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = pto;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = plist;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = plist;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mlist = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9828;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9829;
	goto L9830;
L9828:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	goto L9827;
L9829:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	goto L9827;
L9830:
	R1 = 0;
	R2 = tou64("forall/can't iterate");
	mm_support_txerror(asu64(R2), asu64(R1));
L9827:
	R1 = 0;
	R2 = 23;
	asu64(R3) = plocal;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = plocal;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L9832;
	asi64(R1) = elemtype;
	asu64(R2) = plocal;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = plocal;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L9832:
	R1 = 0;
	R2 = 23;
	asu64(R3) = passign;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_type_tx_index(u64 p, u64 a, u64 b, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 emode;
	i64 pmode;
	i64 tmode;
	i64 tbasemode;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9835;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9835;
	R1 = 0;
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't index: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9835:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_tx_makerange(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 9;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_ptr(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9839;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9840;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9841;
	goto L9842;
L9839:
	R1 = 0;
	R2 = tou64("Deref Void");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L9838;
L9840:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9838;
L9841:
	msysc_m$print_startcon();
	R1 = tou64("DEREF SLICE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9838;
L9842:
	R1 = 0;
	R2 = tou64("PTR: need ref T");
	mm_support_txerror(asu64(R2), asu64(R1));
L9838:
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_setrecordsize(i64 m) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	struct $B89 fieldlist;
	i64 i;
	i64 nfields;
	i64 indent;
	i64 nrfields;
	i64 size;
	i64 index;
	i64 maxalign;
	u64 d;
	u64 e;
	u64 flags;
	i64 flag;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L9845;
	goto L9843;
L9845:
	R1 = (u64)&mm_type_setrecordsize_depth;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L9847;
	R1 = tou64("Recursive record?");
	mm_support_serror(asu64(R1));
L9847:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	R1 = 83;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L9849;
L9848:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9852;
	asi64(R1) = nfields;
	R2 = 200;
	if (asi64(R1) < asi64(R2)) goto L9854;
	R1 = 0;
	R2 = tou64("srs:too many fields");
	mm_support_gerror(asu64(R2), asu64(R1));
L9854:
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_type_setmodesize(asi64(R1));
	asu64(R1) = e;
	R2 = 136;
	R1 += (i64)R2;
	flags = asu64(R1);
L9855:
	asu64(R1) = flags;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 83;
	if (asu64(R1) == asu64(R2)) goto L9857;
	R2 = 85;
	if (asu64(R1) == asu64(R2)) goto L9857;
	goto L9858;
L9857:
	asu64(R1) = flags;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	asi64(R1) = flag;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&flags;
	(*tou64p(R1)) += 1;
	goto L9855;
L9858:
	goto L9856;
	goto L9855;
L9856:
	asu64(R1) = e;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L9859:
	R1 = (u64)&flags;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	asi64(R1) = flag;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L9862;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L9863;
	goto L9864;
L9862:
	goto L9861;
L9863:
	R1 = 69;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L9861;
L9864:
	goto L9860;
L9861:
	goto L9859;
L9860:
L9852:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L9849:
	asu64(R1) = e;
	if (asu64(R1)) goto L9848;
	R1 = 69;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&fieldlist;
	asi64(R3) = nfields;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	mm_type_countedfields = asi64(R1);
	R1 = 2;
	index = asi64(R1);
	R1 = 1;
	maxalign = asi64(R1);
	R1 = (u64)&maxalign;
	asu64(R2) = d;
	R3 = 149;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
	R4 = (u64)&size;
	R5 = (u64)&index;
	R6 = (u64)&fieldlist;
	R7 = 83;
	mm_type_scanrecord(asi64(R7), asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 149;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L9866;
	asi64(R1) = maxalign;
	asi64(R2) = size;
	asi64(R1) = mm_type_roundoffset(asi64(R2), asi64(R1));
	size = asi64(R1);
	asi64(R1) = maxalign;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L9865;
L9866:
	R1 = 1;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9868;
	R1 = 8;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L9867;
L9868:
	asi64(R1) = size;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9869;
	R1 = 4;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L9867;
L9869:
	asi64(R1) = size;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9870;
	R1 = 2;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L9870:
L9867:
L9865:
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	asi64(R1) = mm_type_countedfields;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = m;
	mm_type_checkblocktype(asi64(R1));
	R1 = (u64)&mm_type_setrecordsize_depth;
	(*toi64p(R1)) -=1;
L9843:
	return;
}

static void mm_type_checkblocktype(i64 m) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9873;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L9873;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L9873;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9873;
	goto L9874;
L9873:
	R1 = 0;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9872;
L9874:
L9872:
	return;
}

static void mm_type_scanrecord(i64 state, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 e;
	u64 f;
	u64 ea;
	i64 size;
	i64 fieldsize;
	i64 bitoffset;
	i64 alignment;
	i64 newoffset;
	R1 = 0;
	size = asi64(R1);
	R1 = 0;
	bitoffset = asi64(R1);
	goto L9877;
L9876:
	asu64(R1) = f;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L9880;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L9880;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L9881;
	goto L9882;
L9880:
	asu64(R1) = maxalign;
	asi64(R2) = calign;
	asi64(R3) = offset;
	R4 = (u64)&fieldsize;
	asu64(R5) = index;
	asu64(R6) = fields;
	asu64(R7) = f;
	mm_type_scanrecord(asi64(R7), asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L9879;
L9881:
	asi64(R1) = state;
	R2 = 85;
	if (asi64(R1) != asi64(R2)) goto L9884;
	R1 = (u64)&mm_type_countedfields;
	(*toi64p(R1)) += 1;
L9884:
	asi64(R1) = size;
	asu64(R2) = isize;
	*toi64p(R2) = asi64(R1);
	goto L9875;
	goto L9879;
L9882:
	asu64(R1) = f;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L9886;
	R1 = 0;
	fieldsize = asi64(R1);
	asu64(R1) = f;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ea = asu64(R1);
	asu64(R1) = ea;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = bitoffset;
	asu64(R2) = f;
	R3 = 150;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 148;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&bitoffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = bitoffset;
	R2 = (u64)&mm_decls_ttsize;
	asu64(R3) = f;
	R4 = 128;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	R3 = 8;
	asi64(R2) *= asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L9888;
	R1 = 0;
	R2 = tou64("Bit fields overflow type");
	mm_support_txerror(asu64(R2), asu64(R1));
L9888:
	goto L9885;
L9886:
	asu64(R1) = f;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L9889;
	R1 = 0;
	bitoffset = asi64(R1);
	asu64(R1) = f;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	fieldsize = asi64(R1);
	asu64(R1) = e;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = f;
	R3 = 151;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9885;
L9889:
	R1 = 0;
	bitoffset = asi64(R1);
	asi64(R1) = state;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L9891;
	R1 = (u64)&mm_type_countedfields;
	(*toi64p(R1)) += 1;
L9891:
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = f;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	fieldsize = asi64(R1);
	asi64(R1) = calign;
	if (!asi64(R1)) goto L9893;
	asu64(R1) = f;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asu64(R2) = maxalign;
	asi64(R2) = *toi64p(R2);
	if (asi64(R1) <= asi64(R2)) goto L9895;
	asi64(R1) = alignment;
	asu64(R2) = maxalign;
	*toi64p(R2) = asi64(R1);
L9895:
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = mm_type_roundoffset(asi64(R2), asi64(R1));
	newoffset = asi64(R1);
	asi64(R1) = newoffset;
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L9892;
L9893:
	asi64(R1) = offset;
	newoffset = asi64(R1);
L9892:
	asi64(R1) = newoffset;
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = newoffset;
	offset = asi64(R1);
L9885:
L9879:
	asi64(R1) = state;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L9897;
	asi64(R1) = fieldsize;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = fieldsize;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L9896;
L9897:
	asi64(R1) = size;
	asi64(R2) = fieldsize;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	size = asi64(R1);
L9896:
L9877:
	asu64(R1) = fields;
	asu64(R2) = index;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) += 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L9876;
L9875:
	return;
}

static i64 mm_type_roundoffset(i64 offset, i64 alignment) {
    u64 R1, R2; 
	i64 mask;
	asi64(R1) = alignment;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L9900;
	asi64(R1) = offset;
	goto L9898;
L9900:
	asi64(R1) = alignment;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mask = asi64(R1);
	goto L9902;
L9901:
	R1 = (u64)&offset;
	(*toi64p(R1)) += 1;
L9902:
	asi64(R1) = offset;
	asi64(R2) = mask;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L9901;
	asi64(R1) = offset;
	goto L9898;
L9898:
	return asi64(R1);
}

static void mm_type_tx_convert(u64 p, u64 a, i64 hard) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L9906;
	goto L9907;
L9906:
	R1 = 0;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	mm_type_tx_makelist(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L9905;
L9907:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = hard;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L9905:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	return;
}

static void mm_type_tx_makelist(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3, R4, R5; struct $B60 R1_B60; 
	i64 alength;
	i64 tlength;
	i64 elemtype;
	i64 newt;
	i64 i;
	i64 nfields;
	i64 isconst;
	i64 m;
	u64 q;
	u64 b;
	u64 e;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alength = asi64(R1);
	R1 = 0;
	newt = asi64(R1);
	R1 = 1;
	isconst = asi64(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tlength = asi64(R1);
	asi64(R1) = tlength;
	if (!asi64(R1)) goto L9910;
	asi64(R1) = alength;
	asi64(R2) = tlength;
	if (asi64(R1) >= asi64(R2)) goto L9912;
	R1 = 0;
	asi64(R2) = tlength;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = 0;
	asi64(R3) = alength;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Too few elements");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L9911;
L9912:
	asi64(R1) = alength;
	asi64(R2) = tlength;
	if (asi64(R1) <= asi64(R2)) goto L9913;
	R1 = 0;
	asi64(R2) = tlength;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = 0;
	asi64(R3) = alength;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Too many elements");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L9913:
L9911:
L9910:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L9915;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9916;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9917;
	goto L9918;
L9915:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	asi64(R1) = tlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9920;
	R1 = 0;
	asi64(R2) = alength;
	R3 = (u64)&mm_decls_ttlower;
	asi64(R4) = t;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asi64(R4) = elemtype;
	R5 = 0;
	asi64(R1) = mm_lib_createarraymodek(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	newt = asi64(R1);
	goto L9919;
L9920:
	asi64(R1) = t;
	newt = asi64(R1);
L9919:
	asu64(R1) = a;
	q = asu64(R1);
	goto L9922;
L9921:
	asi64(R1) = lv;
	asi64(R2) = elemtype;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9925;
	R1 = 0;
	isconst = asi64(R1);
L9925:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9922:
	asu64(R1) = q;
	if (asu64(R1)) goto L9921;
	asi64(R1) = newt;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L9914;
L9916:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	goto L9927;
L9926:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9930;
	goto L9932;
L9931:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L9935;
	goto L9933;
L9935:
L9932:
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L9931;
L9933:
	asi64(R1) = lv;
	asu64(R2) = e;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L9937;
	R1 = 0;
	isconst = asi64(R1);
L9937:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9930:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L9927:
	asu64(R1) = q;
	if (!asu64(R1)) goto L9938;
	asu64(R1) = e;
	if (asu64(R1)) goto L9926;
L9938:
	goto L9940;
L9939:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L9940:
	asu64(R1) = e;
	if (!asu64(R1)) goto L9942;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L9939;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L9939;
L9942:
	asu64(R1) = q;
	if (asu64(R1)) goto L9945;
	asu64(R1) = e;
	if (!asu64(R1)) goto L9944;
L9945:
	R1 = 0;
	R2 = tou64("Can't initialise unions");
	mm_support_txerror(asu64(R2), asu64(R1));
L9944:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9914;
L9917:
	msysc_m$print_startcon();
	R1 = tou64("TSLICE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L9914;
L9918:
	R1 = 0;
	R2 = 1;
	asi64(R3) = t;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Unknown makelist type: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9914:
	asi64(R1) = isconst;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = p;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L9947;
	asi64(R1) = mm_type_inidata;
	if (asi64(R1)) goto L9949;
	asi64(R1) = isconst;
	if (!asi64(R1)) goto L9949;
	R1 = 10;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = e;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = e;
	mm_lib_addstatic(asu64(R1));
	R1 = 0;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B60) = *(struct $B60*)(R1);
	asu64(R2) = q;
	*(struct $B60*)(R2) = (R1_B60);
	asu64(R1) = q;
	asu64(R2) = e;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L9949:
L9947:
	return;
}

static void mm_type_tx_makeslicefromlist(u64 p, u64 a, i64 t) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MAKESLICE/TX");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("MAKESLICE FROM LIST NOT READY");
	mm_support_txerror(asu64(R2), asu64(R1));
	return;
}

static void mm_type_tx_makeslice(u64 p, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("MAKESLICE/TX");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9953;
	R1 = 0;
	R2 = tou64("slice init not ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L9953:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L9955;
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9957;
	R1 = 0;
	R2 = tou64("slice/ptr mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L9957:
L9955:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	msysc_m$print_startcon();
	R1 = tou64("MKSLICE2");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_makeset(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9962;
L9959:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L9964;
	R1 = 0;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L9964:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L9962:
	asu64(R1) = a;
	if (asu64(R1)) goto L9959;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_dot(u64 p, u64 a, u64 b, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 recmode;
	i64 recbasemode;
	i64 i;
	i64 j;
	i64 newtag;
	i64 tmode;
	u64 q;
	u64 pindex;
	u64 d;
	u64 dequiv;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	recmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	recbasemode = asi64(R1);
	goto L9967;
L9966:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = tmode;
	R2 = R1;
	asu64(R3) = a;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	recmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	recbasemode = asi64(R1);
L9967:
	asi64(R1) = recbasemode;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9966;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9970;
	R1 = 0;
	R2 = tou64("Bad record type");
	mm_support_txerror(asu64(R2), asu64(R1));
L9970:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L9972;
	asi64(R1) = recmode;
	asu64(R2) = d;
	asu64(R1) = mm_type_resolvefield(asu64(R2), asi64(R1));
	R2 = R1;
	asu64(R3) = b;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	d = asu64(R1);
L9972:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L9974;
	asu64(R1) = d;
	R2 = 150;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	asu64(R2) = d;
	R3 = 148;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	j = asi64(R1);
	asu64(R1) = d;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dequiv = asu64(R1);
	asu64(R1) = dequiv;
	asu64(R2) = b;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = dequiv;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) != asi64(R2)) goto L9976;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pindex = asu64(R1);
	R1 = 51;
	newtag = asi64(R1);
	goto L9975;
L9976:
	R1 = 3;
	asi64(R2) = j;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = 3;
	asi64(R3) = i;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pindex = asu64(R1);
	R1 = 9;
	asu64(R2) = pindex;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pindex;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pindex;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 52;
	newtag = asi64(R1);
L9975:
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	asi64(R1) = newtag;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pindex;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L9965;
L9974:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
L9965:
	return;
}

static u64 mm_type_resolvefield(u64 d, i64 m) {
    u64 R1, R2, R3; 
	u64 e;
	u64 t;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9979;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L9980;
	goto L9981;
L9979:
	goto L9978;
L9980:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L9983;
	R1 = 0;
	R2 = tou64("3:record expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9983:
	goto L9978;
L9981:
	R1 = 0;
	R2 = tou64("4:record expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L9978:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	t = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = t;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L9985;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9985:
	asu64(R1) = e;
	goto L9977;
L9977:
	return asu64(R1);
}

static void mm_type_tx_andl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 6;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_convintconst(u64 p, i64 x) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_sliceptr(u64 p, u64 a) {
    u64 R1, R2, R3, R4, R5; 
	i64 m;
	i64 tmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L9990;
	goto L9991;
L9990:
	goto L9989;
L9991:
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("SLICEPTR #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L9989:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&mm_decls_ttlower;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&mm_decls_tttarget;
	asi64(R5) = m;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5*4));
	R4 = toi64(toi32(R4));
	R5 = 0;
	asi64(R1) = mm_lib_createarraymodek(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	tmode = asi64(R1);
	R1 = 0;
	asi64(R2) = tmode;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_swap(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 av;
	i64 bv;
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 23;
	asu64(R2) = b;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L9994;
	R1 = 0;
	R2 = tou64("SWAP: type mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L9994:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_select(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	i64 i;
	i64 u;
	u64 q;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	goto L9997;
L9996:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	asu64(R2) = b;
	if (asu64(R1) != asu64(R2)) goto L10000;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L9999;
L10000:
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L9999:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L9997:
	asu64(R1) = q;
	if (asu64(R1)) goto L9996;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	goto L10002;
L10001:
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = q;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L10002:
	asu64(R1) = q;
	if (asu64(R1)) goto L10001;
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_case(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 amode;
	i64 u;
	u64 wt;
	u64 w;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 106;
	if (asi64(R1) != asi64(R2)) goto L10006;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L10006;
	R1 = 0;
	R2 = tou64("&docase");
	mm_support_gerror(asu64(R2), asu64(R1));
L10006:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10008;
	R1 = 23;
	amode = asi64(R1);
	goto L10007;
L10008:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
L10007:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10010;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = amode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L10010;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	amode = asi64(R1);
L10010:
	R1 = 0;
	u = asi64(R1);
	asu64(R1) = b;
	wt = asu64(R1);
	goto L10012;
L10011:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L10015;
L10014:
	R1 = 0;
	R2 = 23;
	asu64(R3) = w;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L10018;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10020;
	R1 = 0;
	R2 = tou64("case: need int index");
	mm_support_txerror(asu64(R2), asu64(R1));
L10020:
	goto L10017;
L10018:
	asi64(R1) = amode;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10022;
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = w;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10024;
	R1 = 0;
	R2 = tou64("CASE/BOOL?");
	mm_support_txerror(asu64(R2), asu64(R1));
	R1 = 18;
	asu64(R2) = w;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L10024:
	goto L10021;
L10022:
	R1 = 0;
	asi64(R2) = amode;
	asu64(R3) = w;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L10021:
L10017:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L10015:
	asu64(R1) = w;
	if (asu64(R1)) goto L10014;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = wt;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10026;
	asi64(R1) = u;
	if (!asi64(R1)) goto L10028;
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	goto L10027;
L10028:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
L10027:
L10026:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L10012:
	asu64(R1) = wt;
	if (asu64(R1)) goto L10011;
	asu64(R1) = c;
	if (!asu64(R1)) goto L10030;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10032;
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L10032:
	goto L10029;
L10030:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10033;
	R1 = 0;
	R2 = tou64("case needs else");
	mm_support_txerror(asu64(R2), asu64(R1));
L10033:
L10029:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10035;
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10034;
L10035:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10034:
	return;
}

static void mm_type_tx_notl(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_typepun(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 smode;
	i64 tmode;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10039;
	goto L10040;
L10039:
	R1 = 0;
	R2 = tou64("TYPEPUN/LIST");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L10038;
L10040:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	smode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = smode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10043;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = tmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10042;
L10043:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = smode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10044;
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = tmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10042;
L10044:
	R1 = 0;
	R2 = tou64("Invalid type-punning; only real<->int");
	mm_support_txerror(asu64(R2), asu64(R1));
L10042:
	asi64(R1) = tmode;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L10047;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L10046;
L10047:
	R1 = 3;
	tmode = asi64(R1);
L10046:
	asi64(R1) = tmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10038:
	return;
}

static void mm_type_tx_exit(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10050;
	goto L10048;
L10050:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10052;
	R1 = 0;
	R2 = tou64("exit/etc not const");
	mm_support_txerror(asu64(R2), asu64(R1));
L10052:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L10048:
	return;
}

static void mm_type_tx_goto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 m;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L10056;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L10055;
L10056:
	R1 = 0;
	R2 = tou64("goto: not label");
	mm_support_txerror(asu64(R2), asu64(R1));
L10055:
	return;
}

static void mm_type_tx_switch(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	struct $B96 valueset;
	u64 wt;
	u64 w;
	i64 ax;
	i64 bx;
	i64 i;
	i64 u;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L10059;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L10059;
	R1 = 0;
	R2 = tou64("&doswitch");
	mm_support_gerror(asu64(R2), asu64(R1));
L10059:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L10061;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10063;
	R1 = 0;
	R2 = tou64("not ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L10063:
	goto L10060;
L10061:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L10060:
	R1 = 2048;
	R2 = 0;
	R3 = (u64)&valueset;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 0;
	u = asi64(R1);
	asu64(R1) = b;
	wt = asu64(R1);
	goto L10065;
L10064:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L10068;
L10067:
	R1 = 0;
	R2 = 23;
	asu64(R3) = w;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	asi64(R1) = mm_lib_isconstunit(asu64(R1));
	if (asi64(R1)) goto L10071;
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = w;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("Switch not constant");
	mm_support_txerror(asu64(R2), asu64(R1));
L10071:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = w;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L10073;
	goto L10074;
L10073:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
// mm_type.tx_switch.dorange:
L10075:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L10078;
L10076:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L10081;
	asi64(R1) = i;
	R2 = 2047;
	if (asi64(R1) <= asi64(R2)) goto L10080;
L10081:
	R1 = 0;
	R2 = tou64("switch: value out of range");
	mm_support_txerror(asu64(R2), asu64(R1));
L10080:
	R1 = (u64)&valueset;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10083;
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Duplicate switch value");
	mm_support_txerror(asu64(R2), asu64(R1));
L10083:
	R1 = 1;
	R2 = (u64)&valueset;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= bx) goto L10076;
L10078:
	goto L10072;
L10074:
	R1 = 0;
	R2 = 3;
	asu64(R3) = w;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10085;
	R1 = 0;
	R2 = tou64("Switch value: not const int");
	mm_support_txerror(asu64(R2), asu64(R1));
L10085:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L10075;
L10072:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L10068:
	asu64(R1) = w;
	if (asu64(R1)) goto L10067;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = wt;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10087;
	asi64(R1) = u;
	if (!asi64(R1)) goto L10089;
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	goto L10088;
L10089:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
L10088:
L10087:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L10065:
	asu64(R1) = wt;
	if (asu64(R1)) goto L10064;
	asu64(R1) = c;
	if (!asu64(R1)) goto L10091;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10093;
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L10093:
	goto L10090;
L10091:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10094;
	R1 = 0;
	R2 = tou64("switch needs else");
	mm_support_txerror(asu64(R2), asu64(R1));
L10094:
L10090:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10096;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L10098;
L10097:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10101;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = b;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L10101:
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = w;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L10098:
	asu64(R1) = w;
	if (asu64(R1)) goto L10097;
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L10103;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = c;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10102;
L10103:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10102:
	goto L10095;
L10096:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10095:
	return;
}

static void mm_type_tx_addroffirst(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	i64 m;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10106;
	R1 = 0;
	R2 = tou64("&. ref[] expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L10106:
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10108;
	R1 = 1;
	asu64(R2) = a;
	R3 = 40;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10108:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_return(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	i64 m;
	i64 nvalues;
	i64 nret;
	i64 i;
	u64 pmult;
	u64 q;
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nret = asi64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10111;
	asi64(R1) = nret;
	if (!asi64(R1)) goto L10113;
	R1 = 0;
	R2 = tou64("return value(s) missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L10113:
	goto L10109;
	goto L10110;
L10111:
	asi64(R1) = nret;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10114;
	R1 = 0;
	R2 = tou64("Superfluous return value");
	mm_support_txerror(asu64(R2), asu64(R1));
L10114:
L10110:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10116;
	R1 = 25;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nret;
	if (asi64(R1) == asi64(R2)) goto L10118;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10120;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10120;
	goto L10121;
L10120:
	R1 = 0;
	R2 = tou64("return constructor not supported");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L10119;
L10121:
	R1 = 0;
	R2 = tou64("Wrong number of return values");
	mm_support_txerror(asu64(R2), asu64(R1));
L10119:
L10118:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10124;
L10122:
	R1 = 0;
	asu64(R2) = pmult;
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= nret) goto L10122;
L10124:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10126;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10125;
L10126:
	R1 = 28;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10125:
	goto L10115;
L10116:
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L10128;
	R1 = 0;
	R2 = tou64("RETERROR?");
	mm_support_txerror(asu64(R2), asu64(R1));
L10128:
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10130;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10129;
L10130:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L10129:
L10115:
	R1 = (u64)&mm_decls_ttisshort;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10132;
	R1 = 0;
	R2 = tou64("SHORT RET TYPE");
	mm_support_txerror(asu64(R2), asu64(R1));
L10132:
L10109:
	return;
}

static void mm_type_tx_dotindex(u64 p, u64 a, u64 b, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 pmode;
	u64 i;
	u64 j;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	pmode = asi64(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10135;
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10137;
	R1 = 61;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	R2 = R1;
	asu64(R3) = a;
	R4 = 53;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10136;
L10137:
	R1 = 0;
	R2 = tou64("a.[i]: not int/str value");
	mm_support_txerror(asu64(R2), asu64(R1));
L10136:
L10135:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L10139;
	goto L10140;
L10139:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	i = asu64(R1);
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	j = asu64(R1);
	asu64(R1) = i;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = j;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L10142;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10142;
	asu64(R1) = i;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = j;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L10144;
	asu64(R1) = b;
	R2 = 16;
	R1 += (i64)R2;
	asu64(R2) = b;
	R3 = 24;
	R2 += (i64)R3;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L10144:
L10142:
	goto L10138;
L10140:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L10138:
	asi64(R1) = pmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_slice(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10147;
	R1 = 0;
	R2 = 1;
	R3 = 12;
	asu64(R4) = mm_decls_currproc;
	asi64(R1) = mm_lib_createslicemodek(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10146;
L10147:
	R1 = 1;
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10149;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10150;
	goto L10151;
L10149:
	R1 = 0;
	R2 = 1;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu64(R4) = mm_decls_currproc;
	asi64(R1) = mm_lib_createslicemodek(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10148;
L10150:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10148;
L10151:
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(A.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("a[i..j]: not array");
	mm_support_txerror(asu64(R2), asu64(R1));
L10148:
L10146:
	return;
}

static void mm_type_twiden(u64 p, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 u;
	i64 mbase;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = R2;
	m = asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	asi64(R1) = mbase;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10154;
	goto L10152;
L10154:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L10156;
	goto L10152;
L10156:
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = mbase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10158;
	goto L10152;
L10158:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10160;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L10160;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L10160;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L10160;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L10160;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L10160;
	goto L10161;
L10160:
	R1 = 58;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10159;
L10161:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("widen? #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10159:
L10152:
	return;
}

static void mm_type_tstringslice(u64 p, i64 slicemode) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	u64 prange;
	i64 length;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = slicemode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L10164;
	R1 = 0;
	R2 = tou64("Not char slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L10164:
	asu64(R1) = p;
	a = asu64(R1);
	R1 = 48;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10166;
	goto L10165;
L10166:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	b = asu64(R1);
	R1 = 36;
	asu64(R2) = b;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 3;
	R3 = 1;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	prange = asu64(R1);
	R1 = 9;
	asu64(R2) = prange;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = prange;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L10165:
	asi64(R1) = slicemode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_bitfield(u64 p, u64 a, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 j;
	i64 bitsize;
	i64 topbit;
	u64 r;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10169;
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10169;
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10171;
	R1 = 61;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	R2 = R1;
	asu64(R3) = a;
	R4 = 53;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10170;
L10171:
	R1 = 0;
	R2 = tou64("Int/ref needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L10170:
L10169:
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_ttbasetype;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	topbit = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10173;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10174;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10175;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10176;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10176;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10177;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10178;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L10179;
	goto L10180;
L10173:
	R1 = 0;
	i = asi64(R1);
	R1 = 7;
	j = asi64(R1);
	goto L10172;
L10174:
	asi64(R1) = topbit;
	j = asi64(R1);
	asi64(R1) = topbit;
	R2 = 7;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	goto L10172;
L10175:
	R1 = 0;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L10172;
L10176:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L10182;
	R1 = 0;
	R2 = tou64("Can't assign");
	mm_support_txerror(asu64(R2), asu64(R1));
L10182:
	R1 = 0;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L10172;
L10177:
	asi64(R1) = topbit;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L10172;
L10178:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	j = asi64(R1);
	goto L10172;
L10179:
	asi64(R1) = bitsize;
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	i = asi64(R1);
	asi64(R1) = topbit;
	j = asi64(R1);
	goto L10172;
L10180:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("BITFIELD");
	mm_support_txerror(asu64(R2), asu64(R1));
L10172:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) != asi64(R2)) goto L10184;
	R1 = 51;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L10186;
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	mm_type_addnotl(asu64(R1));
L10186:
	goto L10183;
L10184:
	R1 = 3;
	asi64(R2) = j;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = 3;
	asi64(R3) = i;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	R1 = 1;
	asu64(R2) = r;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = r;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 9;
	asu64(R2) = r;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 52;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L10183:
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_deref(u64 a, i64 needres) {
    u64 R1, R2, R3; 
	i64 abasemode;
	i64 tmode;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abasemode = asi64(R1);
	goto L10189;
L10188:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = tmode;
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abasemode = asi64(R1);
L10189:
	asi64(R1) = abasemode;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10188;
	return;
}

static void mm_type_tmethodcall(u64 p, u64 pdot, u64 pargs) {
    u64 R1, R2, R3; 
	i64 mrec;
	u64 prec;
	u64 pfield;
	u64 pfunc;
	u64 d;
	u64 e;
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	prec = asu64(R1);
	asu64(R1) = pdot;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfield = asu64(R1);
	asu64(R1) = prec;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mrec = asi64(R1);
	asu64(R1) = pfield;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mrec;
	asu64(R2) = d;
	asu64(R1) = mm_type_resolvefield(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10193;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve method:");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10193:
	asu64(R1) = e;
	asu64(R1) = mm_lib_createname(asu64(R1));
	pfunc = asu64(R1);
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pfunc;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pargs;
	asu64(R2) = prec;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pfunc;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = prec;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_type_do_bounds(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 mbase;
	i64 opc;
	i64 lower;
	i64 upper;
	R1 = 1;
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L10196;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	m = asi64(R1);
L10196:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10198;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10199;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10200;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L10201;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10202;
	goto L10203;
L10198:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10205;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10205;
	goto L10206;
L10205:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L10194;
	goto L10204;
L10206:
// mm_type.do_bounds.error:
L10207:
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("lwb/upb/len?");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10204:
	goto L10197;
L10199:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10209;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10210;
	goto L10211;
L10209:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L10208;
L10210:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10208;
L10211:
	goto L10207;
L10208:
	goto L10197;
L10200:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10213;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10214;
	goto L10215;
L10213:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L10212;
L10214:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10212;
L10215:
	goto L10207;
L10212:
	goto L10197;
L10201:
	R1 = 9;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10217;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10218;
	goto L10219;
L10217:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10194;
	goto L10216;
L10218:
	goto L10216;
L10219:
	goto L10207;
L10216:
	goto L10197;
L10202:
	asi64(R1) = mbase;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10221;
	R1 = 0;
	R2 = tou64("Not slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L10221:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10197;
L10203:
L10197:
L10194:
	return;
}

static void mm_type_addnotl(u64 p) {
    u64 R1, R2, R3; 
	R1 = 17;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 63;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tevaluate(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	u64 pname;
	i64 offset;
	i64 tag;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	tag = asi64(R1);
	R1 = (u64)&mm_tables_jisexpr;
	asi64(R2) = tag;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L10225;
	asu64(R1) = p;
	mm_type_tevalbinop(asu64(R1));
	goto L10224;
L10225:
	R1 = (u64)&mm_tables_jisexpr;
	asi64(R2) = tag;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10226;
	asu64(R1) = p;
	mm_type_tevalmonop(asu64(R1));
	goto L10224;
L10226:
	asi64(R1) = tag;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L10228;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L10229;
	goto L10230;
L10228:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L10232;
	asu64(R1) = a;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = b;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10234;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10234;
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 60;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10234:
L10232:
	goto L10227;
L10229:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = (u64)&offset;
	asu64(R2) = a;
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	pname = asu64(R1);
	asu64(R1) = pname;
	if (!asu64(R1)) goto L10236;
	asu64(R1) = pname;
	asu64(R2) = a;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10238;
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L10237;
L10238:
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
L10237:
L10236:
	goto L10227;
L10230:
L10227:
L10224:
	return;
}

static u64 mm_type_addrdotindex(u64 p, u64 offset) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 axmode;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L10241;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L10242;
	goto L10243;
L10241:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10245;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = offset;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L10244;
L10245:
	asu64(R1) = offset;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = q;
L10244:
	goto L10240;
L10242:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	axmode = asi64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10247;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10249;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = axmode;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = axmode;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = offset;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L10248;
L10249:
	asu64(R1) = offset;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L10251;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = axmode;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = axmode;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = offset;
	*toi64p(R2) += asi64(R1);
L10251:
	asu64(R1) = q;
L10248:
	goto L10246;
L10247:
	R1 = 0;
L10246:
	goto L10240;
L10243:
	R1 = 0;
L10240:
	goto L10239;
L10239:
	return asu64(R1);
}

static void mm_type_tevalbinop(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 a;
	i64 b;
	i64 c;
	i64 offset;
	r64 x;
	r64 y;
	r64 z;
	u64 lhs;
	u64 rhs;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = rhs;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L10255;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10254;
L10255:
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L10257;
	asu64(R1) = rhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10257;
	asu64(R1) = lhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10259;
	asu64(R1) = rhs;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = lhs;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	offset = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L10261;
	asi64(R1) = offset;
	asi64(R1) = -asi64(R1);
	offset = asi64(R1);
L10261:
	asu64(R1) = lhs;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10263;
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = lhs;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L10262;
L10263:
	asi64(R1) = offset;
	asu64(R2) = lhs;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
L10262:
	asu64(R1) = lhs;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L10259:
L10257:
	goto L10252;
L10254:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10265;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	y = asr64(R1);
	goto L10264;
L10265:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
L10264:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10267;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10267;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10268;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10268;
	goto L10269;
L10267:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L10271;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L10272;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L10273;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L10274;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L10275;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L10276;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L10277;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L10278;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L10279;
	goto L10280;
L10271:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L10270;
L10272:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L10270;
L10273:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) *= asi64(R2);
	c = asi64(R1);
	goto L10270;
L10274:
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10282;
	R1 = 0;
	R2 = tou64("x/0");
	mm_support_txerror(asu64(R2), asu64(R1));
L10282:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	c = asi64(R1);
	goto L10270;
L10275:
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10284;
	R1 = 0;
	R2 = tou64("x rem 0");
	mm_support_txerror(asu64(R2), asu64(R1));
L10284:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) %= asi64(R2);
	c = asi64(R1);
	goto L10270;
L10276:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) <<= asi64(R2);
	c = asi64(R1);
	goto L10270;
L10277:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) &= asi64(R2);
	c = asi64(R1);
	goto L10270;
L10278:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) |= asi64(R2);
	c = asi64(R1);
	goto L10270;
L10279:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	c = asi64(R1);
	goto L10270;
L10280:
	goto L10252;
L10270:
	goto L10266;
L10268:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L10286;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L10287;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L10288;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L10289;
	goto L10290;
L10286:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) += asr64(R2);
	z = asr64(R1);
	goto L10285;
L10287:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) -= asr64(R2);
	z = asr64(R1);
	goto L10285;
L10288:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) *= asr64(R2);
	z = asr64(R1);
	goto L10285;
L10289:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) = pow(asr64(R1), asr64(R2));
	z = asr64(R1);
	goto L10285;
L10290:
	goto L10252;
L10285:
	goto L10266;
L10269:
	goto L10252;
L10266:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10292;
	R1 = 0;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L10291;
L10292:
	R1 = 0;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L10291:
L10252:
	return;
}

static void mm_type_tevalmonop(u64 p) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	i64 c;
	r64 x;
	r64 z;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10295;
	goto L10293;
L10295:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10297;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10297;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10298;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10298;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10299;
	goto L10300;
L10297:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L10303;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L10302;
L10303:
	goto L10304;
L10302:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L10306;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L10307;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L10308;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L10309;
	goto L10310;
L10306:
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L10305;
L10307:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10305;
L10308:
	asi64(R1) = a;
	asi64(R1) = ~asi64(R1);
	c = asi64(R1);
	goto L10305;
L10309:
	asi64(R1) = a;
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L10305;
L10310:
	goto L10293;
L10305:
	goto L10296;
L10298:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L10312;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L10313;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L10314;
	goto L10315;
L10312:
	asr64(R1) = x;
	asr64(R1) = -asr64(R1);
	z = asr64(R1);
	goto L10311;
L10313:
	asr64(R1) = x;
	asr64(R1) = atan(asr64(R1));
	z = asr64(R1);
	goto L10311;
L10314:
	asr64(R1) = x;
	asr64(R1) = sqrt(asr64(R1));
	z = asr64(R1);
	goto L10311;
L10315:
	goto L10293;
L10311:
	goto L10296;
L10299:
// mm_type.tevalmonop.dobool:
L10304:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L10317;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L10318;
	goto L10319;
L10317:
	asi64(R1) = a;
	asi64(R1) = !!asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10316;
L10318:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10316;
L10319:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L10321;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L10322;
	goto L10323;
L10321:
	asi64(R1) = a;
	asi64(R1) = !!asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10320;
L10322:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10320;
L10323:
L10320:
L10316:
	goto L10296;
L10300:
	goto L10293;
L10296:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10325;
	R1 = 0;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L10324;
L10325:
	R1 = 0;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L10324:
L10293:
	return;
}

static i64 mm_type_iscondtrue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10327;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10327;
	R1 = 1;
	goto L10328;
L10327:
	R1 = 0;
L10328:
	goto L10326;
L10326:
	return asi64(R1);
}

static i64 mm_type_iscondfalse(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10330;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10330;
	R1 = 1;
	goto L10331;
L10330:
	R1 = 0;
L10331:
	goto L10329;
L10329:
	return asi64(R1);
}

static void mm_type_fixchararray(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L10334;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L10334;
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L10334;
	R1 = 0;
	R2 = 20;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L10334:
	return;
}

static void mm_type_combinestrings(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	i64 alen;
	i64 blen;
	i64 clen;
	i64 needterm;
	u8 atype;
	u8 btype;
	u8 ctype;
	u64 s;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alen = asi64(R1);
	asu64(R1) = b;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	blen = asi64(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	atype = asu8(R1);
	asu64(R1) = b;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	btype = asu8(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	asu8(R2) = btype;
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L10337;
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L10337;
	R1 = 0;
	needterm = asi64(R1);
	R1 = 66;
	ctype = asu8(R1);
	goto L10336;
L10337:
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L10339;
	asu8(R1) = btype;
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L10338;
L10339:
	R1 = 0;
	R2 = tou64("Mixed str+bin strings");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L10336;
L10338:
	R1 = (u64)&alen;
	(*toi64p(R1)) -=1;
	R1 = (u64)&blen;
	(*toi64p(R1)) -=1;
	R1 = 1;
	needterm = asi64(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L10342;
	asu8(R1) = btype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L10341;
L10342:
	R1 = 83;
	ctype = asu8(R1);
	goto L10340;
L10341:
	R1 = 0;
	ctype = asu8(R1);
L10340:
L10336:
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	clen = asi64(R1);
	asi64(R1) = blen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10344;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L10335;
	goto L10343;
L10344:
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10345;
	asu64(R1) = b;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L10335;
L10345:
L10343:
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asi64(R1) = alen;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	asi64(R4) = alen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = needterm;
	if (!asi64(R1)) goto L10347;
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = clen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10347:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu8(R1) = atype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10335:
	return;
}

static void mm_type_mulstrings(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	i64 alen;
	i64 scale;
	i64 clen;
	i64 needterm;
	u8 atype;
	u8 ctype;
	u64 s;
	u64 t;
	i64 av_1;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alen = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	scale = asi64(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	atype = asu8(R1);
	R1 = (u64)&alen;
	(*toi64p(R1)) -=1;
	R1 = 1;
	needterm = asi64(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L10350;
	R1 = 1;
	needterm = asi64(R1);
L10350:
	asi64(R1) = alen;
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	clen = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10353;
	asi64(R1) = clen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10353;
	asi64(R1) = clen;
	R2 = 100000;
	if (asi64(R1) > asi64(R2)) goto L10353;
	asi64(R1) = alen;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L10352;
L10353:
	R1 = 0;
	R2 = tou64("mulstr");
	mm_support_txerror(asu64(R2), asu64(R1));
L10352:
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	s = asu64(R2);
	t = asu64(R1);
	asi64(R1) = scale;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L10356;
L10354:
	asi64(R1) = alen;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = alen;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	if (--asi64(av_1)) goto L10354;
L10356:
	asi64(R1) = needterm;
	if (!asi64(R1)) goto L10358;
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = clen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L10358:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu8(R1) = atype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_strinclude(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 fileno;
	u64 pf;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10362;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10361;
L10362:
	R1 = 0;
	R2 = tou64("strincl/not string");
	mm_support_txerror(asu64(R2), asu64(R1));
L10361:
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = p;
	R3 = 57;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	fileno = asi64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("");
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mm_support_getsupportfile(asu64(R3), asu64(R2), asu64(R1));
	pf = asu64(R1);
	asu64(R1) = pf;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = a;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L10364;
	asu64(R1) = a;
	R2 = 40;
	R1 += (i64)R2;
	(*tou32p(R1)) -=1;
L10364:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	return;
}

static void mm_type_coerceunit(u64 p, i64 t, i64 hard) {
    u64 R1, R2, R3, R4, R5; 
	i64 opc;
	i64 s;
	i64 n;
	i64 sbase;
	i64 tbase;
	i64 starg;
	i64 ttarg;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10368;
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L10367;
L10368:
	goto L10365;
L10367:
	asi64(R1) = s;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10370;
	R1 = 0;
	R2 = tou64("Void expression/return value missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L10370:
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L10372;
	goto L10365;
L10372:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	R1 = 0;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	starg = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	ttarg = asi64(R1);
	asi64(R1) = s;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10374;
	R1 = 20;
	sbase = asi64(R1);
L10374:
	asi64(R1) = t;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10376;
	R1 = 20;
	tbase = asi64(R1);
L10376:
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10378;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10378;
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L10380;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10380;
	R1 = (u64)&mm_tables_softconvtable;
	asi64(R2) = sbase;
	R1 += (i64)R2*10-10;
	asi64(R2) = tbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	opc = asi64(R1);
	goto L10379;
L10380:
	asi64(R1) = tbase;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10382;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10382;
	goto L10383;
L10382:
	R1 = 7;
	opc = asi64(R1);
// mm_type.coerceunit.checkhard:
L10384:
	asi64(R1) = hard;
	if (asi64(R1)) goto L10386;
	R1 = 9;
	opc = asi64(R1);
L10386:
	goto L10381;
L10383:
	asi64(R1) = tbase;
	R2 = 12;
	if (asi64(R1) < asi64(R2)) goto L10388;
	R2 = 19;
	if (asi64(R1) > asi64(R2)) goto L10388;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = sbase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10390;
	asi64(R1) = hard;
	if (asi64(R1)) goto L10392;
	R1 = 10;
	opc = asi64(R1);
	goto L10391;
L10392:
	R1 = 3;
	opc = asi64(R1);
L10391:
L10390:
	goto L10387;
L10388:
	asi64(R1) = tbase;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10394;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L10395;
	goto L10396;
L10394:
	R1 = 8;
	opc = asi64(R1);
	goto L10393;
L10395:
	R1 = 7;
	opc = asi64(R1);
	goto L10393;
L10396:
L10393:
L10387:
L10381:
L10379:
	goto L10377;
L10378:
	asi64(R1) = sbase;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10398;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10399;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10400;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10401;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10402;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L10403;
	goto L10404;
L10398:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10407;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10406;
L10407:
	R1 = 7;
	opc = asi64(R1);
L10406:
	goto L10397;
L10399:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10409;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10409;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10410;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10411;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10412;
	goto L10413;
L10409:
	R1 = 7;
	opc = asi64(R1);
	goto L10384;
	goto L10408;
L10410:
	asi64(R1) = starg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10416;
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10415;
L10416:
	R1 = 7;
	opc = asi64(R1);
	goto L10414;
L10415:
// mm_type.coerceunit.checkref:
L10417:
	R1 = 7;
	opc = asi64(R1);
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10419;
	goto L10384;
L10419:
L10414:
	goto L10408;
L10411:
	goto L10417;
	goto L10408;
L10412:
	R1 = 8;
	opc = asi64(R1);
	goto L10408;
L10413:
L10408:
	goto L10397;
L10400:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10421;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10421;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10422;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L10423;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10424;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10425;
	goto L10426;
L10421:
	R1 = 7;
	opc = asi64(R1);
	goto L10384;
	goto L10420;
L10422:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10429;
	asi64(R1) = hard;
	if (!asi64(R1)) goto L10428;
L10429:
	R1 = 7;
	opc = asi64(R1);
	goto L10427;
L10428:
	R1 = 9;
	opc = asi64(R1);
L10427:
	goto L10420;
L10423:
	R1 = 8;
	opc = asi64(R1);
	goto L10420;
L10424:
	asi64(R1) = ttarg;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L10432;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L10431;
L10432:
	R1 = 11;
	opc = asi64(R1);
L10431:
	goto L10420;
L10425:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L10434;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10434;
	R1 = 7;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10436;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = p;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = t;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = t;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	goto L10435;
L10436:
	R1 = 0;
	R2 = tou64("Array not empty");
	mm_support_txerror(asu64(R2), asu64(R1));
L10435:
L10434:
	goto L10420;
L10426:
L10420:
	goto L10397;
L10401:
	asi64(R1) = tbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10438;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10439;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10440;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10441;
	goto L10442;
L10438:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10444;
	R1 = 7;
	opc = asi64(R1);
L10444:
	goto L10437;
L10439:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10446;
	R1 = 12;
	opc = asi64(R1);
L10446:
	goto L10437;
L10440:
	asi64(R1) = starg;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L10449;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L10448;
L10449:
	R1 = 13;
	opc = asi64(R1);
L10448:
	goto L10437;
L10441:
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10451;
	R1 = 13;
	opc = asi64(R1);
L10451:
	goto L10437;
L10442:
L10437:
	goto L10397;
L10402:
	asi64(R1) = tbase;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10453;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10454;
	goto L10455;
L10453:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10457;
	R1 = 7;
	opc = asi64(R1);
L10457:
	goto L10452;
L10454:
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10460;
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10459;
L10460:
	R1 = 0;
	R2 = tou64("COERCE/SLICEPTR");
	mm_support_gerror(asu64(R2), asu64(R1));
L10459:
	goto L10452;
L10455:
L10452:
	goto L10397;
L10403:
	asi64(R1) = tbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10462;
	R1 = 7;
	opc = asi64(R1);
L10462:
	goto L10397;
L10404:
L10397:
L10377:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	mm_type_applyconversion(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L10365:
	return;
}

static void mm_type_applyconversion(u64 p, i64 s, i64 t, i64 opc) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10465;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L10466;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10467;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10468;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L10469;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10470;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L10471;
	goto L10472;
L10465:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do conversion: # => #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L10464;
L10466:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Need explicit cast: # => #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L10464;
L10467:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10463;
	goto L10464;
L10468:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	asi64(R1) = mm_type_tevalconvert(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10474;
	goto L10463;
L10474:
	R1 = 59;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10463;
	goto L10464;
L10469:
	R1 = 48;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10463;
	goto L10464;
L10470:
	asi64(R1) = t;
	asu64(R2) = p;
	mm_type_tstringslice(asu64(R2), asi64(R1));
	goto L10463;
	goto L10464;
L10471:
	R1 = 56;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10463;
	goto L10464;
L10472:
L10464:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	asi64(R1) = mm_type_tevalconvert(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L10476;
	goto L10463;
L10476:
	R1 = 58;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = s;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10478;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	t = asi64(R1);
L10478:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L10463:
	return;
}

static void mm_type_checkmodes(i64 s, i64 t) {
    u64 R1, R2, R3; 
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10481;
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Type-compare error: # <-> #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L10481:
	return;
}

static i64 mm_type_comparemodes(i64 s, i64 t) {
    u64 R1, R2, R3; 
	i64 sbase;
	i64 tbase;
	i64 starg;
	i64 ttarg;
	u64 d;
	u64 e;
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L10484;
	R1 = 1;
	goto L10482;
L10484:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	starg = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	ttarg = asi64(R1);
	asi64(R1) = sbase;
	asi64(R2) = tbase;
	if (asi64(R1) != asi64(R2)) goto L10486;
	asi64(R1) = sbase;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L10488;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L10489;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10490;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L10491;
	goto L10492;
L10488:
	asi64(R1) = starg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10495;
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10494;
L10495:
	R1 = 1;
	goto L10482;
L10494:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	goto L10482;
	goto L10487;
L10489:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10497;
	R1 = 0;
	goto L10482;
L10497:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	if (asi64(R1) == asi64(R2)) goto L10500;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10500;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10499;
L10500:
	R1 = 1;
	goto L10482;
L10499:
	goto L10487;
L10490:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	goto L10482;
	goto L10487;
L10491:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = s;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	e = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L10502;
	asu64(R1) = e;
	if (!asu64(R1)) goto L10502;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10504;
	R1 = 0;
	goto L10482;
L10504:
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10506;
	asu64(R1) = e;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L10506;
	R1 = 1;
	goto L10482;
L10506:
L10502:
	goto L10487;
L10492:
L10487:
	goto L10485;
L10486:
	asi64(R1) = sbase;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L10509;
	asi64(R1) = tbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L10508;
L10509:
	asi64(R1) = sbase;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L10507;
	asi64(R1) = tbase;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L10507;
L10508:
	R1 = 1;
	goto L10482;
	goto L10485;
L10507:
L10485:
	R1 = 0;
	goto L10482;
L10482:
	return asi64(R1);
}

static i64 mm_type_tevalconvert(u64 p, i64 s, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	r64 x;
	r64 z;
	i64 a;
	i64 c;
	i64 sbase;
	i64 tbase;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L10512;
	R1 = 0;
	goto L10510;
L10512:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asi64(R1) = s;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = t;
	asi64(R1) |= asi64(R2);
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L10514;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L10514;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L10515;
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L10516;
	R2 = 196625;
	if (asi64(R1) == asi64(R2)) goto L10517;
	R2 = 196623;
	if (asi64(R1) == asi64(R2)) goto L10518;
	goto L10519;
L10514:
	asi64(R1) = a;
	asr64(R1) = tor64(asi64(R1));
	z = asr64(R1);
	goto L10513;
L10515:
	asr64(R1) = x;
	R1 = toi64(asr64(R1));
	c = asi64(R1);
	goto L10513;
L10516:
	asr64(R1) = x;
	z = asr64(R1);
	goto L10513;
L10517:
	asi64(R1) = a;
	asi64(R1) = toi64(tou8(R1));
	c = asi64(R1);
	goto L10513;
L10518:
	asi64(R1) = a;
	asi64(R1) = toi64(toi16(R1));
	c = asi64(R1);
	goto L10513;
L10519:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10521;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10521;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = s;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = t;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	if (asi64(R1) != asi64(R2)) goto L10521;
	asi64(R1) = a;
	c = asi64(R1);
	goto L10520;
L10521:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	asi64(R2) = tbase;
	if (asi64(R1) != asi64(R2)) goto L10523;
	R1 = 1;
	goto L10510;
L10523:
	R1 = 0;
	goto L10510;
L10520:
L10513:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10525;
	asi64(R1) = t;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L10524;
L10525:
	asi64(R1) = t;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L10524:
	R1 = 1;
	goto L10510;
L10510:
	return asi64(R1);
}

static void mm_type_tx_assign(u64 p, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 mm;
	i64 needres;
	u64 d;
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	needres = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10528;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L10529;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L10529;
	goto L10530;
L10528:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10532;
	asi64(R1) = needres;
	if (!asi64(R1)) goto L10534;
	R1 = 0;
	R2 = tou64("Mult assign has no result");
	mm_support_txerror(asu64(R2), asu64(R1));
L10534:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_assignmultmult(asu64(R3), asu64(R2), asu64(R1));
	goto L10531;
L10532:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_assignmultscalar(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L10531:
	goto L10526;
	goto L10527;
L10529:
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	mm_type_tx_dotindex(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10526;
	goto L10527;
L10530:
L10527:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10536;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L10536;
	asu64(R1) = p;
	R2 = 59;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10536;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10535;
L10536:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
L10535:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = needres;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L10538;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L10538;
	asi64(R1) = m;
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = b;
	mm_type_tx_makeslicefromlist(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L10537;
L10538:
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L10541;
	R2 = 48;
	if (asi64(R1) != asi64(R2)) goto L10540;
L10541:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10539;
L10540:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L10542;
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10539;
L10542:
	asi64(R1) = m;
	mm = asi64(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10544;
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	mm = asi64(R1);
L10544:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L10546;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L10547;
	goto L10548;
L10546:
	R1 = 0;
	asi64(R2) = mm;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10545;
L10547:
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L10545;
L10548:
	R1 = 0;
	asi64(R2) = mm;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L10545:
	asi64(R1) = mm;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L10550;
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L10550;
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	asu64(R3) = b;
	R4 = 53;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	if (asi64(R1) > asi64(R2)) goto L10550;
	asi64(R1) = needres;
	if (asi64(R1)) goto L10550;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L10550:
L10539:
L10537:
L10526:
	return;
}

static void mm_type_tx_assignmultmult(u64 pp, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 lhs;
	u64 rhs;
	R1 = 29;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = b;
	R3 = 40;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	if (asi64(R1) == asi64(R2)) goto L10553;
	R1 = 0;
	R2 = tou64("Mult assign: count mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L10553:
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L10555;
	R1 = 0;
	R2 = tou64("Invalid assignment");
	mm_support_txerror(asu64(R2), asu64(R1));
L10555:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = lhs;
	p = asu64(R1);
	goto L10559;
L10556:
	R1 = 23;
	asu64(R2) = p;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L10559:
	asu64(R1) = p;
	if (asu64(R1)) goto L10556;
	asu64(R1) = lhs;
	p = asu64(R1);
	asu64(R1) = rhs;
	q = asu64(R1);
	goto L10563;
L10560:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L10563:
	asu64(R1) = q;
	if (asu64(R1)) goto L10560;
	return;
}

static void mm_type_tx_assignmultscalar(u64 pp, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 alist;
	i64 nretmodes;
	i64 i;
	i64 alength;
	u64 pmult;
	u64 d;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	alist = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alength = asi64(R1);
	R1 = 0;
	nretmodes = asi64(R1);
	R1 = 30;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L10566;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L10567;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L10568;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L10569;
	goto L10570;
L10566:
	asu64(R1) = b;
	asu64(R1) = mm_lib_getprocretmodes(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nretmodes = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L10572;
	R1 = 0;
	R2 = tou64("Not a tuple");
	mm_support_txerror(asu64(R2), asu64(R1));
L10572:
	asi64(R1) = alength;
	asi64(R2) = nretmodes;
	if (asi64(R1) <= asi64(R2)) goto L10574;
	R1 = 0;
	R2 = tou64("mult ass/mult returns don't agree in number");
	mm_support_txerror(asu64(R2), asu64(R1));
L10574:
	asi64(R1) = nretmodes;
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L10576;
	R1 = 0;
	R2 = tou64("mult ass rhs needs fn yielding 2+ values");
	mm_support_txerror(asu64(R2), asu64(R1));
L10576:
	asu64(R1) = alist;
	p = asu64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L10580;
L10577:
	asu64(R1) = pmult;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) += 1; asi64(R2) = asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L10580:
	asu64(R1) = p;
	if (asu64(R1)) goto L10577;
	goto L10565;
L10567:
	asi64(R1) = alength;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10582;
	R1 = 0;
	R2 = tou64("(a,b):=slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L10582:
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = b;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = alist;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = alist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_type_tpasslv(asu64(R2), asi64(R1));
	goto L10565;
L10568:
	goto L10565;
L10569:
	goto L10565;
L10570:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 35;
	if (asi64(R1) != asi64(R2)) goto L10584;
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) != asi64(R2)) goto L10584;
	asi64(R1) = alength;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L10586;
	R1 = 0;
	R2 = tou64("(a,b):=divrem");
	mm_support_txerror(asu64(R2), asu64(R1));
L10586:
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = alist;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = alist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 31;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10583;
L10584:
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't expand to mult values:");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L10583:
L10565:
	asi64(R1) = t;
	asu64(R2) = pp;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tpasslv(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	R2 = 23;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L10589;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L10589;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L10591;
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = p;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("PassLV type mismatch: #:=#");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L10591:
L10589:
	return;
}

static i64 mm_type_dobinnumx(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10594;
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10594;
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10592;
L10594:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10596;
	asi64(R1) = bmode;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L10597;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L10596;
L10597:
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = amode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10592;
	goto L10595;
L10596:
	asi64(R1) = amode;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L10599;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L10598;
L10599:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10598;
	asi64(R1) = bmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = bmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10592;
L10598:
L10595:
	R1 = 0;
	goto L10592;
L10592:
	return asi64(R1);
}

static i64 mm_type_dobinnumf(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L10602;
	asi64(R1) = bmode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L10602;
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10600;
L10602:
	R1 = 0;
	goto L10600;
L10600:
	return asi64(R1);
}

static i64 mm_type_dobinnumi(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10606;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10606;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L10605;
L10606:
	asi64(R1) = bmode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L10607;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L10607;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L10605;
L10607:
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L10603;
L10605:
	R1 = 0;
	goto L10603;
L10603:
	return asi64(R1);
}

static i64 mm_type_tx_in(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 simpleset;
	i64 amode;
	i64 bmode;
	u64 q;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	simpleset = asi64(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L10610;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L10614;
L10611:
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L10616;
	R1 = 0;
	simpleset = asi64(R1);
	goto L10613;
L10616:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L10614:
	asu64(R1) = q;
	if (asu64(R1)) goto L10611;
L10613:
L10610:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L10618;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L10619;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L10618;
L10619:
	asi64(R1) = simpleset;
	if (!asi64(R1)) goto L10618;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L10621;
	R1 = 43;
	goto L10620;
L10621:
	R1 = 44;
L10620:
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L10617;
L10618:
	R1 = 0;
	R2 = tou64("doin");
	mm_support_txerror(asu64(R2), asu64(R1));
L10617:
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L10623;
	asu64(R1) = p;
	mm_type_addnotl(asu64(R1));
L10623:
	R1 = 1;
	goto L10608;
L10608:
	return asi64(R1);
}

static void pcl_start() {
	mc_genss_start();
	mc_decls_start();
	mc_writeasm_start();
	return;
}

static void mm_start() {
	mm_genpcl_start();
	mm_lex_start();
	mm_tables_start();
	return;
}

static struct $B87 $procaddr = {{
(u64)&mc_genmcl_px_nop,
(u64)&mc_genmcl_px_dupl,
(u64)&mc_genmcl_px_double,
(u64)&mc_genmcl_px_opnd,
(u64)&mc_genmcl_px_type,
(u64)&mc_genmcl_px_comment,
(u64)&mc_genmcl_px_proc,
(u64)&mc_genmcl_px_endproc,
(u64)&mc_genmcl_px_endprog,
(u64)&mc_genmcl_px_istatic,
(u64)&mc_genmcl_px_zstatic,
(u64)&mc_genmcl_px_data,
(u64)&mc_genmcl_px_label,
(u64)&mc_genmcl_px_load,
(u64)&mc_genmcl_px_store,
(u64)&mc_genmcl_px_add,
(u64)&mc_genmcl_px_sub,
(u64)&mc_genmcl_px_mul,
(u64)&mc_genmcl_px_div,
(u64)&mc_genmcl_px_eval,
(u64)&mc_genmcl_px_widen,
(u64)&mc_genmcl_px_jump,
(u64)&mc_genmcl_px_ijump,
(u64)&mc_genmcl_px_neg,
(u64)&mc_genmcl_px_abs,
(u64)&mc_genmcl_px_bitnot,
(u64)&mc_genmcl_px_not,
(u64)&mc_genmcl_px_toboolt,
(u64)&mc_genmcl_px_sqr,
(u64)&mc_genmcl_px_sqrt,
(u64)&mc_genmcl_px_jumpcc,
(u64)&mc_genmcl_px_jumpt,
(u64)&mc_genmcl_px_jumpf,
(u64)&mc_genmcl_px_bitand,
(u64)&mc_genmcl_px_bitor,
(u64)&mc_genmcl_px_bitxor,
(u64)&mc_genmcl_px_shl,
(u64)&mc_genmcl_px_shr,
(u64)&mc_genmcl_px_retproc,
(u64)&mc_genmcl_px_retfn,
(u64)&mc_genmcl_px_setcall,
(u64)&mc_genmcl_px_setarg,
(u64)&mc_genmcl_px_callp,
(u64)&mc_genmcl_px_jumpret,
(u64)&mc_genmcl_px_jumpretm,
(u64)&mc_genmcl_px_startmx,
(u64)&mc_genmcl_px_resetmx,
(u64)&mc_genmcl_px_stop,
(u64)&mc_genmcl_px_incrto,
(u64)&mc_genmcl_px_decrto,
(u64)&mc_genmcl_px_incrload,
(u64)&mc_genmcl_px_decrload,
(u64)&mc_genmcl_px_loadincr,
(u64)&mc_genmcl_px_loaddecr,
(u64)&mc_genmcl_px_forup,
(u64)&mc_genmcl_px_fordown,
(u64)&mc_genmcl_px_iload,
(u64)&mc_genmcl_px_iloadx,
(u64)&mc_genmcl_px_istore,
(u64)&mc_genmcl_px_istorex,
(u64)&mc_genmcl_px_storem,
(u64)&mc_genmcl_px_addpx,
(u64)&mc_genmcl_px_subpx,
(u64)&mc_genmcl_px_to,
(u64)&mc_genmcl_px_iswap,
(u64)&mc_genmcl_px_swapstk,
(u64)&mc_genmcl_px_labeldef,
(u64)&mc_genmcl_px_addto,
(u64)&mc_genmcl_px_subto,
(u64)&mc_genmcl_px_multo,
(u64)&mc_genmcl_px_bitandto,
(u64)&mc_genmcl_px_bitorto,
(u64)&mc_genmcl_px_bitxorto,
(u64)&mc_genmcl_px_shlto,
(u64)&mc_genmcl_px_shrto,
(u64)&mc_genmcl_px_fix,
(u64)&mc_genmcl_px_float,
(u64)&mc_genmcl_px_idiv,
(u64)&mc_genmcl_px_irem,
(u64)&mc_genmcl_px_idivrem,
(u64)&mc_genmcl_px_clear,
(u64)&mc_genmcl_px_subp,
(u64)&mc_genmcl_px_switch,
(u64)&mc_genmcl_px_switchu,
(u64)&mc_genmcl_px_swlabel,
(u64)&mc_genmcl_px_endsw,
(u64)&mc_genmcl_px_fwiden,
(u64)&mc_genmcl_px_fnarrow,
(u64)&mc_genmcl_px_truncate,
(u64)&mc_genmcl_px_typepun,
(u64)&mc_genmcl_px_unload,
(u64)&mc_genmcl_px_loadbit,
(u64)&mc_genmcl_px_assem,
(u64)&mc_genmcl_px_sin,
(u64)&mc_genmcl_px_cos,
(u64)&mc_genmcl_px_tan,
(u64)&mc_genmcl_px_asin,
(u64)&mc_genmcl_px_acos,
(u64)&mc_genmcl_px_atan,
(u64)&mc_genmcl_px_log,
(u64)&mc_genmcl_px_log10,
(u64)&mc_genmcl_px_exp,
(u64)&mc_genmcl_px_round,
(u64)&mc_genmcl_px_floor,
(u64)&mc_genmcl_px_ceil,
(u64)&mc_genmcl_px_atan2,
(u64)&mc_genmcl_px_fmod,
(u64)&mc_genmcl_px_setcc,
(u64)&mc_genmcl_px_min,
(u64)&mc_genmcl_px_max,
(u64)&mc_genmcl_px_power,
(u64)&mc_genmcl_px_minto,
(u64)&mc_genmcl_px_maxto,
(u64)&mc_genmcl_px_negto,
(u64)&mc_genmcl_px_absto,
(u64)&mc_genmcl_px_addpxto,
(u64)&mc_genmcl_px_subpxto,
(u64)&mc_genmcl_px_divto,
(u64)&mc_genmcl_px_bitnotto,
(u64)&mc_genmcl_px_notto,
(u64)&mc_genmcl_px_toboolto,
(u64)&mc_genmcl_px_sign,
(u64)&mc_genmcl_px_loadbf,
(u64)&mc_genmcl_px_storebit,
(u64)&mc_genmcl_px_storebf,
(u64)&mc_genmcl_px_loadall,
(u64)&mc_genmcl_px_setjmp,
(u64)&mc_genmcl_px_longjmp,
(u64)&mc_genmcl_px_initdswx,
(u64)&mc_auxmcl_do_addrmode}};

static struct $B87 $procname = {{
(u64)"px_nop",
(u64)"px_dupl",
(u64)"px_double",
(u64)"px_opnd",
(u64)"px_type",
(u64)"px_comment",
(u64)"px_proc",
(u64)"px_endproc",
(u64)"px_endprog",
(u64)"px_istatic",
(u64)"px_zstatic",
(u64)"px_data",
(u64)"px_label",
(u64)"px_load",
(u64)"px_store",
(u64)"px_add",
(u64)"px_sub",
(u64)"px_mul",
(u64)"px_div",
(u64)"px_eval",
(u64)"px_widen",
(u64)"px_jump",
(u64)"px_ijump",
(u64)"px_neg",
(u64)"px_abs",
(u64)"px_bitnot",
(u64)"px_not",
(u64)"px_toboolt",
(u64)"px_sqr",
(u64)"px_sqrt",
(u64)"px_jumpcc",
(u64)"px_jumpt",
(u64)"px_jumpf",
(u64)"px_bitand",
(u64)"px_bitor",
(u64)"px_bitxor",
(u64)"px_shl",
(u64)"px_shr",
(u64)"px_retproc",
(u64)"px_retfn",
(u64)"px_setcall",
(u64)"px_setarg",
(u64)"px_callp",
(u64)"px_jumpret",
(u64)"px_jumpretm",
(u64)"px_startmx",
(u64)"px_resetmx",
(u64)"px_stop",
(u64)"px_incrto",
(u64)"px_decrto",
(u64)"px_incrload",
(u64)"px_decrload",
(u64)"px_loadincr",
(u64)"px_loaddecr",
(u64)"px_forup",
(u64)"px_fordown",
(u64)"px_iload",
(u64)"px_iloadx",
(u64)"px_istore",
(u64)"px_istorex",
(u64)"px_storem",
(u64)"px_addpx",
(u64)"px_subpx",
(u64)"px_to",
(u64)"px_iswap",
(u64)"px_swapstk",
(u64)"px_labeldef",
(u64)"px_addto",
(u64)"px_subto",
(u64)"px_multo",
(u64)"px_bitandto",
(u64)"px_bitorto",
(u64)"px_bitxorto",
(u64)"px_shlto",
(u64)"px_shrto",
(u64)"px_fix",
(u64)"px_float",
(u64)"px_idiv",
(u64)"px_irem",
(u64)"px_idivrem",
(u64)"px_clear",
(u64)"px_subp",
(u64)"px_switch",
(u64)"px_switchu",
(u64)"px_swlabel",
(u64)"px_endsw",
(u64)"px_fwiden",
(u64)"px_fnarrow",
(u64)"px_truncate",
(u64)"px_typepun",
(u64)"px_unload",
(u64)"px_loadbit",
(u64)"px_assem",
(u64)"px_sin",
(u64)"px_cos",
(u64)"px_tan",
(u64)"px_asin",
(u64)"px_acos",
(u64)"px_atan",
(u64)"px_log",
(u64)"px_log10",
(u64)"px_exp",
(u64)"px_round",
(u64)"px_floor",
(u64)"px_ceil",
(u64)"px_atan2",
(u64)"px_fmod",
(u64)"px_setcc",
(u64)"px_min",
(u64)"px_max",
(u64)"px_power",
(u64)"px_minto",
(u64)"px_maxto",
(u64)"px_negto",
(u64)"px_absto",
(u64)"px_addpxto",
(u64)"px_subpxto",
(u64)"px_divto",
(u64)"px_bitnotto",
(u64)"px_notto",
(u64)"px_toboolto",
(u64)"px_sign",
(u64)"px_loadbf",
(u64)"px_storebit",
(u64)"px_storebf",
(u64)"px_loadall",
(u64)"px_setjmp",
(u64)"px_longjmp",
(u64)"px_initdswx",
(u64)"do_addrmode"}};

static i64 $nprocs = 130;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

