/*
Info header for C distribution.
Project: 'MM': M Compiler with x64 native code target for Windows

Typical Build Instructions (needs 64-bit compiler)

  gcc -O3 mm.c -omm.exe

This program compiles an entire M project from its lead module.

Output is a single .exe, .obj or .asm file depending on options. Default
output is .exe file.

Dependencies:

Requires a 64-bit C compiler to bootstrap this C version compiler.
No other dependencies to run the compiler.

Run as follows:

    mm hello               # compile hello.m project to hello.exe

    mm hello -c            # compile hello.m project to single hello.asm file

Other options:

    -c                    # Generate only intermediate asm output file
    -exe                  # Generate executable via C compiler (default)
    -obj                  # Generate single object file
 
    -run                  # For -exe mode only: run resulting executable

    -help                 # Full info

Test hello.m file:

    proc start =
      println "Hello, World!"
    end

For bigger M examples, see github site.

*/

/*
  M to C  Whole Program Translator
  Input:  mm.m plus imported modules
  Output: mm.c (this file, or renamed from that)
          File represents entire program
  Target: C 64-bit
  OS:     Linux

  Modules:
  Module 1: mm.m
  Module 2: ./mm_decls.m
  Module 3: <Built-in: clibnewc.m>
  Module 4: ./mm_tables.m
  Module 5: ./mm_mcldecls.m
  Module 6: ./mm_start.m
  Module 7: <Built-in: msysnewc.m>
  Module 8: <Built-in: mlib.m>
  Module 9: <Built-in: oslinux.m>
  Module 10: ./mm_support.m
  Module 11: ./mm_lib.m
  Module 12: ./mm_lex.m
  Module 13: ./mm_diags.m
  Module 14: ./mm_genwx64.m
  Module 15: ./mm_genpcl.m
  Module 16: ./mm_libpcl.m
  Module 17: ./mm_blockpcl.m
  Module 18: ./mm_genmcl.m
  Module 19: ./mm_libmcl.m
  Module 20: ./var_tables.m
  Module 21: ./ma_genss.m
  Module 22: ./ma_decls.m
  Module 23: ./ma_lib.m
  Module 24: ./ma_objdecls.m
  Module 25: ./ma_writeobj.m
  Module 26: ./ma_writeexe.m
  Module 27: ./ma_disasm.m
  Module 28: ./mm_parse.m
  Module 29: ./mm_name.m
  Module 30: ./mm_type.m

*********** Start of C Code **********/


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

#pragma pack(1)

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef unsigned char byte;

typedef void* var;

typedef struct {int a,b,c,d;} i128;
typedef struct {int a,b,c,d;} u128;

#ifndef CALLBACK
#define CALLBACK
#endif

#if (UINTPTR_MAX<0xFFFFFFFFFFFFFFFF)
	#error "Need 64-bit target. Try -m64"
#endif

/* Forward Struct Declarations */
struct mm_decls_fwdrec;
struct mm_decls_lexrec;
struct mm_decls_uflagsrec;
struct mm_decls_fieldrec;
struct mm_decls_strec;
struct mm_decls_unitrec;
struct mm_decls_modulerec;
struct mm_decls_dllprocrec;
struct mm_decls_procrec;
struct mm_decls_userxrec;
struct mm_mcldecls_opndrec;
struct mm_mcldecls_mclrec;
struct msysnewc_procinforec;
struct msysnewc_fmtrec;
struct mlib_strbuffer;
struct oslinux_termios;
struct oslinux_rsystemtime;
struct mm_libpcl_pclopndrec;
struct mm_libpcl_pclrec;
struct ma_decls_relocrec;
struct ma_decls_dbuffer;
struct ma_objdecls_imagefileheader;
struct ma_objdecls_imagedir;
struct ma_objdecls_optionalheader;
struct ma_objdecls_imagesectionheader;
struct ma_objdecls_imagesymbol;
struct ma_objdecls_importdirrec;
struct ma_objdecls_coffrelocrec;
struct ma_objdecls_auxsectionrec;
struct ma_writeexe_sectionrec;
struct ma_writeexe_importrec;
struct ma_writeexe_dllrec;

/* Struct Definitions */
struct mm_decls_fwdrec {
    struct mm_decls_fwdrec* nextfwd;
    int32_t offset;
    int16_t reltype;
    int16_t seg;
};

struct mm_decls_lexrec {
    union {
        int64_t value;
        double xvalue;
        uint64_t uvalue;
        uint8_t *  svalue;
        i128 *  pvalue128;
    };
    struct mm_decls_strec *  symptr;
    int32_t hashvalue;
    int32_t length;
    int32_t lineno;
    byte symbol;
    byte subcode;
    byte fileno;
    byte spare;
};

struct mm_decls_uflagsrec {
    byte codes[7];
    byte ulength;
};

struct mm_decls_fieldrec {
    uint8_t *  name;
    int16_t recordtype;
    int16_t fieldtype;
    int32_t fieldoffset;
};

struct mm_decls_strec {
    uint8_t *  name;
    struct mm_decls_strec* owner;
    struct mm_decls_strec* deflist;
    struct mm_decls_strec* deflistx;
    struct mm_decls_strec* nextdef;
    struct mm_decls_strec* nextdupl;
    struct mm_decls_strec* firstdupl;
    union {
        struct mm_decls_strec* nextparam;
    };
    struct mm_decls_unitrec *  code;
    union {
        struct mm_decls_strec* paramlist;
        struct mm_decls_uflagsrec uflags;
    };
    union {
        struct mm_decls_strec* equivfield;
        struct mm_decls_unitrec *  equivvar;
    };
    union {
        uint8_t *  truename;
        uint8_t *  metadata;
        uint8_t *  macrovalue;
        struct mm_decls_strec* nulldef;
    };
    union {
        int32_t modelist[4];
        int32_t mode;
    };
    byte namelen;
    byte symbol;
    byte nameid;
    byte txdone;
    int32_t subcode;
    union {
        int32_t index;
        int32_t labelno;
    };
    union {
        int32_t offset;
        int32_t baseclass;
    };
    int32_t lineno;
    byte isglobal;
    byte isstatic;
    byte equals;
    byte at;
    byte parammode;
    byte optional;
    union {
        byte varparams;
        byte bitoffset;
    };
    byte used;
    union {
        byte asmused;
        byte bitfieldwidth;
    };
    byte circflag;
    byte fflang;
    byte moduleno;
    byte imported;
    byte nretvalues;
    byte namecat;
    union {
        byte align;
        byte dllindex;
        byte extmodno;
    };
    byte islet;
    byte simplefunc;
    byte maxalign;
    byte reftype;
    byte segment;
    struct mm_decls_fwdrec *  fwdrefs;
    int32_t stindex;
    int32_t importindex;
    int32_t regsize;
};

struct mm_decls_unitrec {
    int32_t tag;
    int32_t lineno;
    struct mm_decls_unitrec* nextunit;
    union {
        struct mm_decls_strec *  def;
        int64_t value;
        uint64_t uvalue;
        double xvalue;
        uint8_t *  svalue;
        i128 *  pvalue128;
        u128 *  puvalue128;
        struct mm_decls_strec *  labeldef;
        struct {
            int64_t range_lower;
            int64_t range_upper;
        };
        struct {
            uint64_t value_lower;
            int64_t value_upper;
        };
        struct {
            uint64_t uvalue_lower;
            uint64_t uvalue_upper;
        };
    };
    union {
        int32_t opcode;
        int32_t index;
        int32_t whenlabel;
        int32_t trylevel;
        int32_t slength;
        int32_t length;
        struct {
            byte dottedname;
            byte avcode;
        };
        int32_t offset;
        struct {
            byte reg;
            byte regix;
            byte scale;
            byte prefixmode;
            byte regsize;
            byte cond;
            byte spare2;
            byte spare3;
        };
        uint64_t reginfo;
    };
    int32_t mode;
    int32_t moduleno;
    int32_t addroffirst;
    int32_t isconst;
    int32_t popflag;
    int32_t ifretflag;
    int32_t newmode;
    int32_t isastring;
    int32_t makearray;
    int32_t initlet;
    struct mm_decls_unitrec* a;
    struct mm_decls_unitrec* b;
    struct mm_decls_unitrec* c;
};

struct mm_decls_modulerec {
    uint8_t *  name;
    struct mm_decls_strec *  stmodule;
    int64_t fileno;
    union {
        uint8_t *  asmstr;
        uint8_t *  clangstr;
    };
    int64_t strlength;
    byte importmap[50];
    struct mm_decls_strec *  stinitproc;
};

struct mm_decls_dllprocrec {
    uint8_t *  name;
    void (*address)(void);
    int64_t dllindex;
};

struct mm_decls_procrec {
    struct mm_decls_strec *  def;
    struct mm_decls_procrec* nextproc;
};

struct mm_decls_userxrec {
    struct mm_decls_strec *  owner;
    int32_t *  pmode;
    struct mm_decls_userxrec* nextmode;
};

struct mm_mcldecls_opndrec {
    union {
        struct mm_decls_strec *  def;
        int64_t value;
        double xvalue;
        uint8_t *  svalue;
        int64_t labelno;
        int64_t sysfn;
    };
    byte size;
    byte mode;
    byte reg;
    byte regix;
    byte valtype;
    byte scale;
    byte addrsize;
    byte spare;
    int32_t offset;
    int32_t spare2;
};

struct mm_mcldecls_mclrec {
    struct mm_mcldecls_mclrec* nextmcl;
    struct mm_mcldecls_opndrec *  a;
    struct mm_mcldecls_opndrec *  b;
    byte opcode;
    union {
        byte cond;
        byte isglobal;
        byte sysindex;
    };
    byte fileno;
    byte c;
    int64_t lineno;
};

struct msysnewc_procinforec {
    uint16_t fnindex;
    byte rettype;
    byte nparams;
    byte paramlist[12];
};

struct msysnewc_fmtrec {
    byte minwidth;
    int8_t precision;
    byte base;
    uint8_t quotechar;
    uint8_t padchar;
    uint8_t realfmt;
    uint8_t plus;
    uint8_t sepchar;
    uint8_t lettercase;
    uint8_t justify;
    uint8_t suffix;
    uint8_t usigned;
    uint8_t charmode;
    uint8_t heapmode;
    uint8_t param;
    byte spare;
};

struct mlib_strbuffer {
    uint8_t *  strptr;
    int32_t length;
    int32_t allocated;
};

struct oslinux_termios {
    int32_t c_iflag;
    int32_t c_oflag;
    int32_t c_cflag;
    int32_t c_lflag;
    uint8_t c_line;
    uint8_t c_cc[32];
    byte filler[3];
    int32_t c_ispeed;
    int32_t c_ospeed;
};

struct oslinux_rsystemtime {
    int32_t year;
    int32_t month;
    int32_t dayofweek;
    int32_t day;
    int32_t hour;
    int32_t minute;
    int32_t second;
    int64_t milliseconds;
};

struct mm_libpcl_pclopndrec {
    union {
        struct mm_decls_strec *  def;
        struct mm_decls_unitrec *  code;
        int64_t value;
        uint64_t uvalue;
        double xvalue;
        uint8_t *  svalue;
        i128 *  pvalue128;
        u128 *  puvalue128;
        int64_t labelno;
        int64_t pbytes;
        int64_t floatmap;
    };
    int16_t optype;
    int16_t size;
    union {
        int32_t fbytes;
        int32_t nargs;
    };
};

struct mm_libpcl_pclrec {
    int16_t opcode;
    union {
        int16_t cond;
        int16_t align;
        int16_t index;
    };
    int32_t size;
    int16_t mode;
    int16_t mode2;
    byte catmode;
    byte catmode2;
    byte isglobal;
    byte isfunction;
    byte isvariadic;
    byte spare3;
    int16_t fileno;
    int32_t lineno;
    struct mm_libpcl_pclrec* nextpcl;
    struct mm_libpcl_pclopndrec a;
    struct mm_libpcl_pclopndrec b;
};

struct ma_decls_relocrec {
    struct ma_decls_relocrec* nextreloc;
    int64_t reloctype;
    int64_t offset;
    int64_t stindex;
};

struct ma_decls_dbuffer {
    byte *  pstart;
    union {
        byte *  pcurr;
        uint16_t *  pcurr16;
        uint32_t *  pcurr32;
        uint64_t *  pcurr64;
    };
    byte *  pend;
    int64_t alloc;
};

struct ma_objdecls_imagefileheader {
    uint16_t machine;
    uint16_t nsections;
    uint32_t timedatestamp;
    uint32_t symtaboffset;
    uint32_t nsymbols;
    uint16_t optheadersize;
    uint16_t characteristics;
};

struct ma_objdecls_imagedir {
    uint32_t virtualaddr;
    uint32_t size;
};

struct ma_objdecls_optionalheader {
    uint16_t magic;
    byte majorlv;
    byte minorlv;
    uint32_t codesize;
    uint32_t idatasize;
    uint32_t zdatasize;
    uint32_t entrypoint;
    uint32_t codebase;
    uint64_t imagebase;
    uint32_t sectionalignment;
    uint32_t filealignment;
    uint16_t majorosv;
    uint16_t minorosv;
    uint16_t majorimagev;
    uint16_t minorimagev;
    uint16_t majorssv;
    uint16_t minorssv;
    uint32_t win32version;
    uint32_t imagesize;
    uint32_t headerssize;
    uint32_t checksum;
    uint16_t subsystem;
    uint16_t dllcharacteristics;
    uint64_t stackreserve;
    uint64_t stackcommit;
    uint64_t heapreserve;
    uint64_t heapcommit;
    uint32_t loaderflags;
    uint32_t rvadims;
    struct ma_objdecls_imagedir exporttable;
    struct ma_objdecls_imagedir importtable;
    struct ma_objdecls_imagedir resourcetable;
    struct ma_objdecls_imagedir exceptiontable;
    struct ma_objdecls_imagedir certtable;
    struct ma_objdecls_imagedir basereloctable;
    struct ma_objdecls_imagedir debug;
    struct ma_objdecls_imagedir architecture;
    struct ma_objdecls_imagedir globalptr;
    struct ma_objdecls_imagedir tlstable;
    struct ma_objdecls_imagedir loadconfigtable;
    struct ma_objdecls_imagedir boundimport;
    struct ma_objdecls_imagedir iat;
    struct ma_objdecls_imagedir delayimportdescr;
    struct ma_objdecls_imagedir clrheader;
    struct ma_objdecls_imagedir reserved;
};

struct ma_objdecls_imagesectionheader {
    uint8_t name[8];
    union {
        uint32_t physical_address;
        uint32_t virtual_size;
    };
    uint32_t virtual_address;
    uint32_t rawdata_size;
    uint32_t rawdata_offset;
    uint32_t relocations_ptr;
    uint32_t linenos_offset;
    uint16_t nrelocs;
    uint16_t nlinenos;
    uint32_t characteristics;
};

struct ma_objdecls_imagesymbol {
    union {
        uint8_t shortname[8];
        struct {
            uint32_t shortx;
            uint32_t longx;
        };
        uint64_t longname;
    };
    uint32_t value;
    int16_t sectionno;
    uint16_t symtype;
    byte storageclass;
    byte nauxsymbols;
};

struct ma_objdecls_importdirrec {
    uint32_t implookuprva;
    uint32_t timedatestamp;
    uint32_t fwdchain;
    uint32_t namerva;
    uint32_t impaddressrva;
};

struct ma_objdecls_coffrelocrec {
    int32_t virtualaddr;
    int32_t stindex;
    int16_t reloctype;
};

struct ma_objdecls_auxsectionrec {
    int32_t length;
    int16_t nrelocs;
    int16_t nlines;
    int32_t checksum;
    int16_t sectionno;
    int32_t dummy;
};

struct ma_writeexe_sectionrec {
    union {
        struct ma_decls_dbuffer *  data;
        byte *  bytedata;
    };
    uint8_t *  name;
    int64_t segtype;
    int64_t rawsize;
    int64_t rawoffset;
    int64_t virtsize;
    int64_t virtoffset;
    struct ma_decls_relocrec *  relocs;
    int64_t nrelocs;
};

struct ma_writeexe_importrec {
    struct mm_decls_strec *  def;
    int64_t libno;
    uint8_t *  name;
    int64_t hintnameoffset;
    int64_t iatoffset;
    int64_t thunkoffset;
};

struct ma_writeexe_dllrec {
    uint8_t *  name;
    int64_t nprocs;
    int64_t nametableoffset;
    int64_t addrtableoffset;
    int64_t dllnameoffset;
    int64_t dllextraoffset;
};


/* PROCDECLS */
void start(void);
void mm_start_start_common(int64_t itarget);
static void mm_start_debugcompiler(void);
static void mm_start_do_loadmodules(void);
static void mm_start_do_parse(void);
static void mm_start_do_name(void);
static void mm_start_do_type(void);
static void mm_start_do_runprog(void);
static int64_t mm_start_loadmainmodule(uint8_t * filespec);
static int64_t mm_start_addmodule(uint8_t * modulename,int64_t fileno,int64_t * exportflag);
static int64_t mm_start_loadimport(uint8_t * modulename,int64_t * exportflag,uint8_t * ownername);
static int64_t mm_start_readimportlist(struct mm_decls_modulerec * m,uint8_t * (*importnames)[],byte (*importflags)[],int64_t maximports);
static void mm_start_pslex(void);
static void mm_start_initdata(void);
static void mm_start_initsearchdirs(void);
static void mm_start_addsearchdir(uint8_t * path);
static void mm_start_showsearchdirs(void);
static void mm_start_showast(uint8_t * filename);
static void mm_start_showstflat(uint8_t * caption,void * f);
static void mm_start_showsttree(uint8_t * caption,void * f);
void mm_start_showtiming(void);
static void mm_start_getinputoptions(void);
static void mm_start_do_option(int64_t sw,uint8_t * value);
static void mm_start_showcaption(void);
static void mm_start_addtolog(uint8_t * filename,void * logdest);
static void mm_start_addoptionvar(uint8_t * name,uint8_t * value);
void mm_start_addmodulemapping(uint8_t * old,uint8_t * newx,uint8_t * optionname,uint8_t * valuename);
static void mm_start_dosetoptionvar(uint8_t * s);
static int64_t mm_start_findoptionvar(uint8_t * name);
static void mm_start_getpsname(uint8_t * dest);
static void mm_start_domapmodule(void);
uint8_t * mm_start_mapimport(uint8_t * name);
static void mm_start_do_writema(void);
static void mm_start_starttimer(void);
static void mm_start_stoptimer(uint8_t * mess);
int64_t msysnewc_m_getdotindex(uint64_t a,int64_t i);
void msysnewc_m_setdotindex(uint64_t * a,int64_t i,int64_t x);
int64_t msysnewc_m_getdotslice(uint64_t a,int64_t i,int64_t j);
void msysnewc_m_setdotslice(uint64_t * a,int64_t i,int64_t j,uint64_t x);
int64_t msysnewc_m_get_nprocs(void);
int64_t msysnewc_m_get_nexports(void);
void * msysnewc_m_get_procname(int64_t n);
uint8_t * msysnewc_m_get_procaddr(int64_t n);
void * msysnewc_m_get_procexport(int64_t n);
static void msysnewc_pushio(void);
void msysnewc_m_print_startfile(void * dev);
void msysnewc_m_print_startstr(uint8_t * s);
void msysnewc_m_print_startptr(uint8_t * * p);
void msysnewc_m_print_startcon(void);
void msysnewc_m_print_setfmt(uint8_t * format);
void msysnewc_m_print_end(void);
void msysnewc_m_print_ptr(void * a,uint8_t * fmtstyle);
void msysnewc_m_print_i64(int64_t a,uint8_t * fmtstyle);
void msysnewc_m_print_u64(uint64_t a,uint8_t * fmtstyle);
void msysnewc_m_print_r64(double x,uint8_t * fmtstyle);
void msysnewc_m_print_r32(float x,uint8_t * fmtstyle);
void msysnewc_m_print_c8(int64_t a,uint8_t * fmtstyle);
void msysnewc_m_print_str(uint8_t * s,uint8_t * fmtstyle);
void msysnewc_m_print_newline(void);
void msysnewc_m_print_nogap(void);
void msysnewc_printstr(uint8_t * s);
void msysnewc_printstr_n(uint8_t * s,int64_t n);
void msysnewc_printstrn_app(uint8_t * s,int64_t length,void * f);
static uint8_t * msysnewc_makezstring(uint8_t * s,int64_t n,uint8_t * local);
static void msysnewc_freezstring(uint8_t * t,int64_t n);
static void msysnewc_printchar(int64_t ch);
void msysnewc_nextfmtchars(int64_t lastx);
void msysnewc_strtofmt(uint8_t * s,int64_t slen,struct msysnewc_fmtrec * fmt);
static int64_t msysnewc_domultichar(uint8_t * p,int64_t n,uint8_t * dest,struct msysnewc_fmtrec * fmt);
static int64_t msysnewc_expandstr(uint8_t * s,uint8_t * t,int64_t n,struct msysnewc_fmtrec * fmt);
static uint64_t msysnewc_xdivrem(uint64_t a,uint64_t b,uint64_t * remainder);
static int64_t msysnewc_u64tostr(uint64_t aa,uint8_t * s,uint64_t base,int64_t sep);
static int64_t msysnewc_i64tostrfmt(int64_t aa,uint8_t * s,struct msysnewc_fmtrec * fmt);
static int64_t msysnewc_u64tostrfmt(int64_t aa,uint8_t * s,struct msysnewc_fmtrec * fmt);
static int64_t msysnewc_i64mintostr(uint8_t * s,int64_t base,int64_t sep);
static int64_t msysnewc_strtostrfmt(uint8_t * s,uint8_t * t,int64_t n,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_i64(int64_t a,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_u64(uint64_t a,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_r64(double x,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_str(uint8_t * s,struct msysnewc_fmtrec * fmt);
static struct msysnewc_fmtrec * msysnewc_getfmt(uint8_t * fmtstyle);
uint8_t * msysnewc_strint(int64_t a,uint8_t * fmtstyle);
void msysnewc_getstrint(int64_t a,uint8_t * dest);
uint8_t * msysnewc_strword(uint64_t a,uint8_t * fmtstyle);
uint8_t * msysnewc_strreal(double a,uint8_t * fmtstyle);
static uint8_t * msysnewc_getstr(uint8_t * s,struct msysnewc_fmtrec * fmt);
static void msysnewc_initreadbuffer(void);
void msysnewc_m_read_conline(void);
void msysnewc_m_read_fileline(void * f);
void msysnewc_m_read_strline(uint8_t * s);
static uint8_t * msysnewc_readitem(int64_t * itemlength);
int64_t msysnewc_strtoint(uint8_t * s,int64_t length,int64_t base);
int64_t msysnewc_m_read_i64(int64_t fmt);
double msysnewc_m_read_r64(int64_t fmt);
void msysnewc_m_read_str(uint8_t * dest,int64_t destlen,int64_t fmt);
void msysnewc_readstr(uint8_t * dest,int64_t fmt,int64_t destlen);
void msysnewc_rereadln(void);
void msysnewc_reread(void);
int64_t msysnewc_valint(uint8_t * s,int64_t fmt);
double msysnewc_valreal(uint8_t * s);
static void msysnewc_iconvlcn(uint8_t * s,int64_t n);
static void msysnewc_iconvucn(uint8_t * s,int64_t n);
static void msysnewc_convlcstring(uint8_t * s);
static void msysnewc_convucstring(uint8_t * s);
int64_t msysnewc_m_power_i64(int64_t n,int64_t a);
void msysnewc_m_intoverflow(void);
void msysnewc_m_dotindex(uint64_t i,uint64_t a);
void msysnewc_m_dotslice(uint64_t j,uint64_t i,uint64_t a);
void msysnewc_m_popdotindex(uint64_t i,uint64_t * p,uint64_t x);
void msysnewc_m_popdotslice(uint64_t j,uint64_t i,uint64_t * p,uint64_t x);
int64_t msysnewc_m_imin(int64_t a,int64_t b);
int64_t msysnewc_m_imax(int64_t a,int64_t b);
double msysnewc_m_sign(double x);
void * mlib_pcm_alloc(int64_t n);
void mlib_pcm_freestr(uint8_t * s);
void mlib_pcm_free(void * p,int64_t n);
void mlib_pcm_freeac(void * p,int64_t alloc);
void mlib_pcm_copymem4(void * p,void * q,int64_t n);
void mlib_pcm_clearmem(void * p,int64_t n);
void mlib_pcm_init(void);
int64_t mlib_pcm_getac(int64_t size);
void * mlib_pcm_newblock(int64_t itemsize);
int64_t mlib_pcm_round(int64_t n);
int64_t mlib_pcm_array(int64_t n);
void mlib_pcm_printfreelist(int64_t size,uint64_t * p);
void mlib_pcm_diags(uint8_t * caption);
void * mlib_pcm_allocz(int64_t n);
uint8_t * mlib_pcm_copyheapstring(uint8_t * s);
uint8_t * mlib_pcm_copyheapstringn(uint8_t * s,int64_t n);
uint8_t * mlib_pcm_copyheapblock(uint8_t * s,int64_t length);
static void mlib_addtomemalloc(int32_t * ptr,int64_t size);
static void mlib_removefrommemalloc(int32_t * ptr,int64_t size);
void * mlib_allocmem(int64_t n);
void * mlib_reallocmem(void * p,int64_t n);
void mlib_abortprogram(uint8_t * s);
int64_t mlib_getfilesize(void * handlex);
void mlib_readrandom(void * handlex,byte * mem,int64_t offset,int64_t size);
int64_t mlib_writerandom(void * handlex,byte * mem,int64_t offset,int64_t size);
int64_t mlib_setfilepos(void * file,int64_t offset);
int64_t mlib_getfilepos(void * file);
byte * mlib_readfile(uint8_t * filename);
int64_t mlib_writefile(uint8_t * filename,byte * data,int64_t size);
int64_t mlib_checkfile(uint8_t * file);
void mlib_readlinen(void * handlex,uint8_t * buffer,int64_t size);
void mlib_iconvlcn(uint8_t * s,int64_t n);
void mlib_iconvucn(uint8_t * s,int64_t n);
void mlib_convlcstring(uint8_t * s);
void mlib_convucstring(uint8_t * s);
uint8_t * mlib_changeext(uint8_t * s,uint8_t * newext);
uint8_t * mlib_extractext(uint8_t * s,int64_t period);
uint8_t * mlib_extractpath(uint8_t * s);
uint8_t * mlib_extractfile(uint8_t * s);
uint8_t * mlib_extractbasefile(uint8_t * s);
uint8_t * mlib_addext(uint8_t * s,uint8_t * newext);
void * mlib_alloctable(int64_t n,int64_t size);
void * mlib_zalloctable(int64_t n,int64_t size);
void mlib_checkfreelists(uint8_t * s);
void * mlib_pcm_alloc32(void);
void mlib_pcm_free32(void * p);
void mlib_outbyte(void * f,int64_t x);
void mlib_outword16(void * f,uint64_t x);
void mlib_outword(void * f,uint64_t x);
void mlib_outword64(void * f,uint64_t x);
int64_t mlib_myeof(void * f);
void * mlib_pcm_smallallocz(int64_t n);
void * mlib_pcm_smallalloc(int64_t n);
void mlib_strbuffer_add(struct mlib_strbuffer * dest,uint8_t * s,int64_t n);
void mlib_gs_init(struct mlib_strbuffer * dest);
void mlib_gs_free(struct mlib_strbuffer * dest);
void mlib_gs_str(struct mlib_strbuffer * dest,uint8_t * s);
void mlib_gs_char(struct mlib_strbuffer * dest,int64_t c);
void mlib_gs_strn(struct mlib_strbuffer * dest,uint8_t * s,int64_t length);
void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s);
void mlib_gs_strint(struct mlib_strbuffer * dest,int64_t a);
void mlib_gs_strln(struct mlib_strbuffer * dest,uint8_t * s);
void mlib_gs_strsp(struct mlib_strbuffer * dest,uint8_t * s);
void mlib_gs_line(struct mlib_strbuffer * dest);
int64_t mlib_gs_getcol(struct mlib_strbuffer * dest);
void mlib_gs_leftstr(struct mlib_strbuffer * dest,uint8_t * s,int64_t w,int64_t padch);
void mlib_gs_leftint(struct mlib_strbuffer * dest,int64_t a,int64_t w,int64_t padch);
void mlib_gs_padto(struct mlib_strbuffer * dest,int64_t col,int64_t ch);
void mlib_gs_println(struct mlib_strbuffer * dest,void * f);
int64_t mlib_nextcmdparam(int64_t * paramno,uint8_t * * name,uint8_t * * value,uint8_t * defext);
static int64_t mlib_readnextfileitem(uint8_t * * fileptr,uint8_t * * item);
void mlib_ipadstr(uint8_t * s,int64_t width,uint8_t * padchar);
uint8_t * mlib_padstr(uint8_t * s,int64_t width,uint8_t * padchar);
uint8_t * mlib_chr(int64_t c);
int64_t mlib_cmpstring(uint8_t * s,uint8_t * t);
int64_t mlib_cmpstringn(uint8_t * s,uint8_t * t,int64_t n);
int64_t mlib_eqstring(uint8_t * s,uint8_t * t);
int64_t mlib_cmpbytes(void * p,void * q,int64_t n);
int64_t mlib_eqbytes(void * p,void * q,int64_t n);
void mlib_mseed(uint64_t a,uint64_t b);
uint64_t mlib_mrandom(void);
int64_t mlib_mrandomp(void);
int64_t mlib_mrandomint(int64_t n);
int64_t mlib_mrandomrange(int64_t a,int64_t b);
double mlib_mrandomreal(void);
double mlib_mrandomreal1(void);
byte * mlib_checkpackfile(void);
extern void sleep(uint32_t _1);
extern void * dlopen(uint8_t * _1,int32_t _2);
extern void * dlsym(void * _1,uint8_t * _2);
extern int32_t tcgetattr(int32_t _1,struct oslinux_termios * _2);
extern int32_t tcsetattr(int32_t _1,int32_t _2,struct oslinux_termios * _3);
void oslinux_os_init(void);
int64_t oslinux_os_execwait(uint8_t * cmdline,int64_t newconsole,uint8_t * workdir);
int64_t oslinux_os_execcmd(uint8_t * cmdline,int64_t newconsole);
int64_t oslinux_os_getch(void);
int64_t oslinux_os_kbhit(void);
void oslinux_os_flushkeys(void);
void * oslinux_os_getconsolein(void);
void * oslinux_os_getconsoleout(void);
void * oslinux_os_proginstance(void);
uint64_t oslinux_os_getdllinst(uint8_t * name);
void * oslinux_os_getdllprocaddr(int64_t hlib,uint8_t * name);
void oslinux_os_initwindows(void);
int64_t oslinux_os_getchx(void);
uint8_t * oslinux_os_getos(void);
int64_t oslinux_os_gethostsize(void);
int64_t oslinux_os_iswindows(void);
int64_t oslinux_os_shellexec(uint8_t * opc,uint8_t * file);
void oslinux_os_sleep(int64_t a);
void * oslinux_os_getstdin(void);
void * oslinux_os_getstdout(void);
uint8_t * oslinux_os_gethostname(void);
uint8_t * oslinux_os_getmpath(void);
void oslinux_os_exitprocess(int64_t x);
int64_t oslinux_os_clock(void);
int64_t oslinux_os_getclockspersec(void);
void oslinux_os_setmesshandler(void * addr);
int64_t oslinux_os_hpcounter(void);
int64_t oslinux_os_hpfrequency(void);
int64_t oslinux_os_filelastwritetime(uint8_t * filename);
void oslinux_os_getsystime(struct oslinux_rsystemtime * tm);
void oslinux_os_peek(void);
int64_t mm_support_loadsourcefile(uint8_t * filespec);
int64_t mm_support_loadbuiltin(uint8_t * shortfile,uint8_t * text);
int64_t mm_support_loadbundledfile(uint8_t * filespec,int64_t support);
void mm_support_mcerror(uint8_t * mess);
void mm_support_serror_gen(uint8_t * mess);
static void mm_support_stopcompiler(uint8_t * filename,int64_t lineno);
void mm_support_serror(uint8_t * mess);
void mm_support_serror_s(uint8_t * mess,uint8_t * a);
void mm_support_error_gen(int64_t pass,uint8_t * mess,struct mm_decls_unitrec * p);
void mm_support_rxerror(uint8_t * mess,struct mm_decls_unitrec * p);
void mm_support_gerror(uint8_t * mess,struct mm_decls_unitrec * p);
void mm_support_axerror(uint8_t * mess);
void mm_support_txerror(uint8_t * mess,struct mm_decls_unitrec * p);
void mm_support_txerror_s(uint8_t * mess,uint8_t * a,struct mm_decls_unitrec * p);
void mm_support_txerror_ss(uint8_t * mess,uint8_t * a,uint8_t * b);
void mm_support_rxerror_s(uint8_t * mess,uint8_t * a,struct mm_decls_unitrec * p);
void mm_support_gerror_s(uint8_t * mess,uint8_t * s,struct mm_decls_unitrec * p);
void mm_support_lxerror_gen(uint8_t * mess);
void mm_support_lxerror_s(uint8_t * mess,uint8_t * a);
void mm_support_lxerror(uint8_t * mess);
int64_t mm_support_testelem(byte (*p)[],int64_t n);
void mm_support_setelem(byte (*p)[],int64_t n);
int64_t mm_support_nextpoweroftwo(int64_t x);
void mm_support_loaderror(uint8_t * mess,uint8_t * mess2,uint8_t * mess3);
void mm_support_gs_additem(struct mlib_strbuffer * dest,uint8_t * s);
void mm_support_gs_copytostr(struct mlib_strbuffer * source,uint8_t * s);
int64_t mm_support_isalphanum(int64_t c);
void mm_support_inittypetables(void);
void mm_support_addspecialtypes(void);
static uint8_t * mm_support_findfile(uint8_t * filename);
uint8_t * mm_support_findstdlib(uint8_t * name);
int64_t mm_support_getmainfile(uint8_t * filename);
int64_t mm_support_getmodulefile(uint8_t * modulename,uint8_t * ownername);
int64_t mm_support_getsupportfile(uint8_t * filename);
void mm_support_writemafile(uint8_t * leadmodule,uint8_t * destfile);
void mm_support_loadmafile(void);
struct mm_decls_strec * mm_lib_newstrec(void);
void mm_lib_initqclib(void);
struct mm_decls_strec * mm_lib_getduplnameptr(struct mm_decls_strec * owner,struct mm_decls_strec * symptr,int64_t id);
void mm_lib_adddef(struct mm_decls_strec * owner,struct mm_decls_strec * p);
void mm_lib_adddef_nodupl(struct mm_decls_strec * owner,struct mm_decls_strec * p);
struct mm_decls_unitrec * mm_lib_createname(struct mm_decls_strec * p);
struct mm_decls_unitrec * mm_lib_createunit0(int64_t tag);
struct mm_decls_unitrec * mm_lib_createunit1(int64_t tag,struct mm_decls_unitrec * p);
struct mm_decls_unitrec * mm_lib_createunit2(int64_t tag,struct mm_decls_unitrec * p,struct mm_decls_unitrec * q);
struct mm_decls_unitrec * mm_lib_createunit3(int64_t tag,struct mm_decls_unitrec * p,struct mm_decls_unitrec * q,struct mm_decls_unitrec * r);
void mm_lib_insertunit(struct mm_decls_unitrec * p,int64_t tag);
void mm_lib_deleteunit(struct mm_decls_unitrec * p,struct mm_decls_unitrec * q);
struct mm_decls_unitrec * mm_lib_createconstunit(uint64_t a,int64_t t);
struct mm_decls_unitrec * mm_lib_createstringconstunit(uint8_t * s,int64_t length);
int64_t mm_lib_getoptocode(int64_t opc);
int64_t mm_lib_createtype(struct mm_decls_strec * d);
int64_t mm_lib_createusertype(struct mm_decls_strec * stname);
int64_t mm_lib_createusertypefromstr(uint8_t * name);
int64_t mm_lib_getconstvalue(struct mm_decls_unitrec * p,int64_t id);
struct mm_decls_unitrec * mm_lib_getrangelwbunit(struct mm_decls_unitrec * p);
struct mm_decls_unitrec * mm_lib_getrangeupbunit(struct mm_decls_unitrec * p);
int64_t mm_lib_createarraymode(struct mm_decls_strec * owner,int64_t target,struct mm_decls_unitrec * dimexpr,int64_t typedefx);
int64_t mm_lib_createarraymodek(struct mm_decls_strec * owner,int64_t target,int64_t lower,int64_t length,int64_t typedefx);
uint8_t * mm_lib_nextautotype(void);
void mm_lib_converttoslice(int64_t t,int64_t sltype);
int64_t mm_lib_createslicemode(struct mm_decls_strec * owner,int64_t target,struct mm_decls_unitrec * dimexpr,int64_t typedefx);
int64_t mm_lib_createslicemodek(struct mm_decls_strec * owner,int64_t target,int64_t lower,int64_t typedefx);
int64_t mm_lib_createstringmode(int64_t t,int64_t length,int64_t typedefx);
int64_t mm_lib_createrefmode(struct mm_decls_strec * owner,int64_t target,int64_t typedefx);
int64_t mm_lib_createrefprocmode(struct mm_decls_strec * owner,struct mm_decls_strec * stproc,struct mm_decls_strec * paramlist,int64_t kwd,int64_t prettype,int64_t typedefx);
void mm_lib_setnameptr(struct mm_decls_unitrec * p);
uint8_t * mm_lib_getdottedname(struct mm_decls_strec * p);
struct mm_decls_strec * mm_lib_getavname(struct mm_decls_strec * owner,int64_t id);
void mm_lib_unionstr_clear(struct mm_decls_uflagsrec * u);
void mm_lib_unionstr_append(struct mm_decls_uflagsrec * u,int64_t c);
void mm_lib_unionstr_concat(struct mm_decls_uflagsrec * u,struct mm_decls_uflagsrec * v);
int64_t mm_lib_unionstr_last(struct mm_decls_uflagsrec * u);
void mm_lib_unionstr_copy(struct mm_decls_uflagsrec * u,struct mm_decls_uflagsrec * v);
void mm_lib_unionstr_print(struct mm_decls_uflagsrec * u);
int64_t mm_lib_createrecordmode(struct mm_decls_strec * owner,int64_t typedefx);
void mm_lib_convertstring(uint8_t * s,uint8_t * t);
struct mlib_strbuffer * mm_lib_strexpr(struct mm_decls_unitrec * p);
static void mm_lib_jeval(struct mlib_strbuffer * dest,struct mm_decls_unitrec * p);
uint8_t * mm_lib_getopcjname(int64_t opc);
uint8_t * mm_lib_strmode(int64_t m,int64_t expand);
uint8_t * mm_lib_strmode2(int64_t m,int64_t expand);
void mm_lib_istrmode(int64_t m,int64_t expand,uint8_t * dest);
int64_t mm_lib_countunits(struct mm_decls_unitrec * p);
struct mm_decls_strec * mm_lib_finddefstr(struct mm_decls_strec * owner,uint8_t * name);
void mm_lib_addtoproclist(struct mm_decls_strec * d);
void mm_lib_addstatic(struct mm_decls_strec * d);
int64_t mm_lib_newusertypex(struct mm_decls_strec * d,struct mm_decls_strec * e);
uint8_t * mm_lib_typename(int64_t m);
struct mm_decls_unitrec * mm_lib_allocunitrec(void);
struct mm_decls_strec * mm_lib_createdupldef(struct mm_decls_strec * owner,struct mm_decls_strec * symptr,int64_t id);
struct mm_decls_strec * mm_lib_createnewmoduledef(struct mm_decls_strec * owner,struct mm_decls_strec * symptr);
void mm_lib_storemode(int64_t id,struct mm_decls_strec * owner,int64_t m,int32_t * p);
struct mm_decls_unitrec * mm_lib_duplunit(struct mm_decls_unitrec * p,int64_t lineno);
int64_t mm_lib_iscallbackfn(struct mm_decls_strec * p);
int64_t mm_lib_isstringconst(struct mm_decls_unitrec * p);
int64_t mm_lib_checkblockreturn(struct mm_decls_unitrec * p);
int64_t mm_lib_isconstint(struct mm_decls_unitrec * a);
int64_t mm_lib_isconstunit(struct mm_decls_unitrec * a);
uint8_t * mm_lib_faststrint(int64_t a);
uint8_t * mm_lib_getfullname(struct mm_decls_strec * d,int64_t fromassem);
void mm_lib_getownername(struct mm_decls_strec * d,uint8_t * dest);
int64_t mm_lib_isnumericmode(int64_t m);
int64_t mm_lib_isrefmode(int64_t m);
uint8_t * mm_lib_strconstopnd(struct mm_decls_unitrec * p);
int64_t mm_lib_gettypecat_t(int64_t m);
int64_t mm_lib_getalignment(int64_t m);
int64_t mm_lib_ispoweroftwo(int64_t x);
void mm_lib_addlistunit(struct mm_decls_unitrec * * ulist,struct mm_decls_unitrec * * ulistx,struct mm_decls_unitrec * p);
int64_t mm_lib_issimpletype(int64_t m);
int64_t mm_lib_getpacktype(int64_t m);
uint64_t mm_lib_getlow128(i128 * a);
uint64_t mm_lib_gethigh128(i128 * a);
void mm_lib_putlow128(i128 * a,uint64_t x);
void mm_lib_puthigh128(i128 * a,uint64_t x);
void mm_lex_lexreadtoken(void);
static void mm_lex_lxreadstring(int64_t termchar);
static void mm_lex_readnumber(int64_t base);
static void mm_lex_readdecimalnumber(void);
static void mm_lex_readrealnumber(uint8_t * intstart,int64_t intlen,int64_t base);
static double mm_lex_readrealbest(int64_t intlen,int64_t fractlen,int64_t expon,uint8_t * realstr);
static int64_t mm_lex_readexponent(int64_t base);
void mm_lex_printsymbol(struct mm_decls_lexrec * lp);
static void mm_lex_stringtonumber(uint8_t * s,int64_t length,int64_t base);
static void mm_lex_stringtodecimalnumber(uint8_t * s,int64_t length,int64_t suffix);
void mm_lex_lexsetup(void);
void mm_lex_printstrn(uint8_t * s,int64_t length);
static uint8_t * mm_lex_scannumber(int64_t base);
static void mm_lex_readrawstring(void);
static int64_t mm_lex_lookup(void);
int64_t mm_lex_gethashvaluez(uint8_t * s);
static void mm_lex_inithashtable(void);
void mm_lex_addreservedword(uint8_t * name,int64_t symbol,int64_t subcode,int64_t regsize);
static int64_t mm_lex_dolexdirective(int64_t index);
static void mm_lex_lexreadline(void);
void mm_lex_startlex(uint8_t * caption,int64_t fileno);
uint8_t * mm_lex_convertzstring(uint8_t * s,int64_t length);
struct mm_decls_strec * mm_lex_addnamestr(uint8_t * name);
struct mm_decls_strec * mm_lex_findname(uint8_t * name);
void mm_lex_ps1(uint8_t * caption);
void mm_lex_ps2(uint8_t * caption);
void mm_lex_ps(uint8_t * caption);
void mm_lex_lex(void);
void mm_lex_showhashtablesize(void);
int64_t mm_lex_checkname(uint8_t * name,int64_t length);
static uint8_t * mm_lex_getstrfile(uint8_t * filename,int32_t * length);
static void mm_lex_stacksourcefile(uint8_t * file,int64_t ismainmodule);
static void mm_lex_stacksource(uint8_t * sptr,int64_t fileno,int64_t isfile);
static void mm_lex_unstacksource(void);
static void mm_lex_readarraystring(int64_t prefix);
static i128 * mm_lex_stringtonumber128(uint8_t * s,int64_t length,int64_t base);
static int64_t mm_lex_setinttype(uint64_t a);
static void mm_lex_readrawxname(void);
void mm_diags_printmodelist(void * f);
void mm_diags_printst(void * f,struct mm_decls_strec * p,int64_t level);
static void mm_diags_printstrec(void * f,struct mm_decls_strec * p,int64_t level);
void mm_diags_printstflat(void * f);
void mm_diags_printcode(void * f,uint8_t * caption);
void mm_diags_printunit(struct mm_decls_unitrec * p,int64_t level,uint8_t * prefix,void * dev);
static void mm_diags_printunitlist(void * dev,struct mm_decls_unitrec * p,int64_t level,uint8_t * prefix);
static uint8_t * mm_diags_getprefix(int64_t level,uint8_t * prefix,struct mm_decls_unitrec * p);
static uint8_t * mm_diags_getlineinfok(void);
void mm_genwx64_do_codegen_debug(void);
void mm_genwx64_do_codegen(void);
void mm_genwx64_showpcl(uint8_t * filename);
void mm_genwx64_showmcl(uint8_t * filename);
void mm_genwx64_showss(uint8_t * filename,int64_t fexe);
static void mm_genwx64_writegsfile(uint8_t * filename,struct mlib_strbuffer * d);
void mm_genwx64_showhelp(void);
void mm_genwx64_initassemsymbols(void);
static void mm_genwx64_addsearchlib(uint8_t * name);
int64_t mm_genpcl_codegen_pcl(void);
static void mm_genpcl_genprocdef(struct mm_decls_strec * p);
static void mm_genpcl_genprocentry(int64_t fbytes,int64_t pbytes,int64_t isstart);
static void mm_genpcl_genframedef(struct mm_decls_strec * d);
static void mm_genpcl_dostaticvar(struct mm_decls_strec * d);
static void mm_genpcl_dostaticvariant(struct mm_decls_strec * d);
static void mm_genpcl_genidata(struct mm_decls_unitrec * p,int64_t doterm,int64_t am);
static void mm_genpcl_geninitproc(void);
static void mm_genpcl_initframedef(struct mm_decls_strec * d);
static void mm_genpcl_freeframevar(struct mm_decls_strec * d);
static int64_t mm_genpcl_getconstframeoffset(struct mm_decls_unitrec * p);
void mm_libpcl_pclinit(void);
void mm_libpcl_initpcdest(void);
void mm_libpcl_genpc(int64_t opcode,struct mm_libpcl_pclopndrec * a,struct mm_libpcl_pclopndrec * b);
static void mm_libpcl_addpcl(struct mm_libpcl_pclrec * p);
void mm_libpcl_genpc_condlab(int64_t opcode,int64_t cond,int64_t lab);
struct mm_libpcl_pclrec * mm_libpcl_lastpc(void);
void mm_libpcl_genpcstr(int64_t opcode,uint8_t * s);
static struct mm_libpcl_pclopndrec * mm_libpcl_newpclopnd(void);
struct mm_libpcl_pclopndrec * mm_libpcl_duplopnd(struct mm_libpcl_pclopndrec * a);
static void mm_libpcl_writepclblock(struct mm_libpcl_pclrec * m);
struct mlib_strbuffer * mm_libpcl_writepclcode(uint8_t * caption);
void mm_libpcl_gencomment(uint8_t * s);
struct mm_libpcl_pclopndrec * mm_libpcl_genstrimm(uint8_t * s,int64_t length);
struct mm_libpcl_pclopndrec * mm_libpcl_genname(uint8_t * s);
struct mm_libpcl_pclopndrec * mm_libpcl_gensys(int64_t fnindex);
static void mm_libpcl_writepcl(int64_t index,struct mm_libpcl_pclrec * pcl);
uint8_t * mm_libpcl_strpcl(struct mm_libpcl_pclrec * pcl);
static uint8_t * mm_libpcl_strmodev(int64_t m);
uint8_t * mm_libpcl_stropnd(struct mm_libpcl_pclopndrec * a);
uint8_t * mm_libpcl_getprocname(struct mm_decls_strec * d);
uint8_t * mm_libpcl_strlabel(int64_t n);
int64_t mm_libpcl_isframe(struct mm_decls_strec * d);
void mm_libpcl_genreturn(int64_t fbytes,int64_t pbytes);
struct mm_libpcl_pclopndrec * mm_libpcl_genint(int64_t x,int64_t size);
struct mm_libpcl_pclopndrec * mm_libpcl_genint128(i128 * pa);
struct mm_libpcl_pclopndrec * mm_libpcl_genreal(double x,int64_t size);
struct mm_libpcl_pclopndrec * mm_libpcl_genassem_u(struct mm_decls_unitrec * p);
struct mm_libpcl_pclopndrec * mm_libpcl_genlabel(int64_t x,int64_t isglobal);
struct mm_libpcl_pclopndrec * mm_libpcl_genmem_u(struct mm_decls_unitrec * p,int64_t size);
struct mm_libpcl_pclopndrec * mm_libpcl_genmem_d(struct mm_decls_strec * d,int64_t size);
struct mm_libpcl_pclopndrec * mm_libpcl_genmemaddr_u(struct mm_decls_unitrec * p);
struct mm_libpcl_pclopndrec * mm_libpcl_genmemaddr_d(struct mm_decls_strec * d);
int64_t mm_libpcl_getopndsize_u(struct mm_decls_unitrec * p);
int64_t mm_libpcl_getopndsize_d(struct mm_decls_strec * d);
int64_t mm_libpcl_isint32const(struct mm_decls_unitrec * p);
int64_t mm_libpcl_roundto(int64_t a,int64_t n);
void mm_libpcl_pushstack(int64_t n);
void mm_libpcl_popstack(int64_t n);
int64_t mm_libpcl_definelabel(void);
int64_t mm_libpcl_createfwdlabel(void);
void mm_libpcl_definefwdlabel(int64_t lab);
void mm_libpcl_genjumpl(int64_t lab);
void mm_libpcl_do_syscallproc(int64_t fnindex,int64_t nparams,int64_t retmode);
static uint8_t * mm_libpcl_strmemopnd(struct mm_decls_strec * d);
static uint8_t * mm_libpcl_strmemaddropnd(struct mm_decls_strec * d);
int64_t mm_libpcl_roundsizetg(int64_t size);
int64_t mm_libpcl_getpclop(int64_t tag);
static uint8_t * mm_libpcl_strshortmode(int64_t m);
int64_t mm_libpcl_islogical(struct mm_decls_unitrec * p);
void mm_libpcl_makefloatopnds(void);
void mm_libpcl_setpclcat_u(struct mm_decls_unitrec * p);
void mm_libpcl_setpclcat_t(int64_t m);
void mm_libpcl_setpclmode_u(struct mm_decls_unitrec * p);
void mm_libpcl_setpclmode_t(int64_t m);
void mm_blockpcl_evalunit(struct mm_decls_unitrec * p);
static void mm_blockpcl_evalref(struct mm_decls_unitrec * p);
static void mm_blockpcl_genjumpcond(int64_t opc,struct mm_decls_unitrec * p,int64_t lab);
static void mm_blockpcl_gcomparejump(int64_t jumpopc,struct mm_decls_unitrec * p,struct mm_decls_unitrec * lhs,struct mm_decls_unitrec * rhs,int64_t lab);
static void mm_blockpcl_genjumpl(int64_t lab);
static int64_t mm_blockpcl_reversecond(int64_t op);
static void mm_blockpcl_stacklooplabels(int64_t a,int64_t b,int64_t c,int64_t d);
static int64_t mm_blockpcl_findlooplabel(int64_t k,int64_t n);
static void mm_blockpcl_unimpl(uint8_t * mess);
static void mm_blockpcl_do_const(struct mm_decls_unitrec * p);
static void mm_blockpcl_do_null(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_name(struct mm_decls_unitrec * p);
static void mm_blockpcl_do_block(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_decimal(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_callproc(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t fncall);
static void mm_blockpcl_do_return(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_returnmult(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_assign(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t fstore);
static void mm_blockpcl_do_shallowcopy(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_to(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_if(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t isref);
static void mm_blockpcl_do_longif(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t isref);
static void mm_blockpcl_do_for(struct mm_decls_unitrec * p,struct mm_decls_unitrec * ivar,struct mm_decls_unitrec * pbody,struct mm_decls_unitrec * pautovar,int64_t down);
static void mm_blockpcl_do_cfor(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_while(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pcond,struct mm_decls_unitrec * pbody);
static void mm_blockpcl_do_repeat(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_goto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_gotoblock(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_labeldef(struct mm_decls_unitrec * p);
static void mm_blockpcl_do_exit(struct mm_decls_unitrec * p,int64_t k);
static void mm_blockpcl_do_do(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_case(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pindex,struct mm_decls_unitrec * pwhenthen,struct mm_decls_unitrec * pelse,int64_t loopsw,int64_t isref);
static void mm_blockpcl_do_emptycase(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pindex,struct mm_decls_unitrec * pwhenthen,struct mm_decls_unitrec * pelse,int64_t loopsw,int64_t isref);
static void mm_blockpcl_do_switch(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pindex,struct mm_decls_unitrec * pwhenthen,struct mm_decls_unitrec * pelse,int64_t loopsw,int64_t isref);
static void mm_blockpcl_do_swap(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_select(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t isref);
static void mm_blockpcl_do_print(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_read(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_readln(struct mm_decls_unitrec * a);
static void mm_blockpcl_do_cprint(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_cprintln(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_sprint(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_sfprint(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_sread(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_sreadln(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_stop(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_try(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_except(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_yield(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_raise(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_eval(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_lambda(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_andl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_orl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_xorl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_notl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_istruel(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_makelist(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_evalrest(struct mm_decls_unitrec * a);
static void mm_blockpcl_do_makerange(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_makeset(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_makedict(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_exprlist(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_multexpr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_keyword(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_keyvalue(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_applyop(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_applyopx(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_andand(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_eq(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_ne(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_lt(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_le(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_gt(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_ge(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_isequal(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_muldiv(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc);
static void mm_blockpcl_do_bin(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc);
static void mm_blockpcl_do_shl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc,int64_t opcc);
static void mm_blockpcl_do_shlto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc,int64_t opcc);
static void mm_blockpcl_do_setcc(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_setccx(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_clamp(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_index(struct mm_decls_unitrec * p,int64_t doref);
static void mm_blockpcl_do_slice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t doref);
static void mm_blockpcl_do_keyindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t doref);
static void mm_blockpcl_do_makeslice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_dotindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_dotslice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_anddotindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_anddotslice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_dot(struct mm_decls_unitrec * p,int64_t doref);
static int64_t mm_blockpcl_checkdotchain(struct mm_decls_unitrec * p,struct mm_decls_unitrec * * pname);
static void mm_blockpcl_do_dotattr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_atan2(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_power(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_ptr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_addrof(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_convert(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_convertref(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_autocast(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_typepun(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_typeconst(struct mm_decls_unitrec * p);
static void mm_blockpcl_do_operator(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_upper(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_unary(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t opc);
static void mm_blockpcl_do_maths(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t sysfn,int64_t pclopc);
static void mm_blockpcl_do_sqr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_sign(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_fmod(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_bitwidth(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_bytesize(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_typeof(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_typestr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_sliceptr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_minvalue(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_maxvalue(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_incr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_incrx(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t opc);
static void mm_blockpcl_do_binto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc);
static void mm_blockpcl_do_unaryto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t opc);
static void mm_blockpcl_do_cvlineno(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_cvmodulename(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_cvfilename(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_assignblock(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_callff(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_strec * d,int64_t fncall);
static void mm_blockpcl_do_recase(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_do_assem(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_blockpcl_pushrhs(struct mm_decls_unitrec * a);
static void mm_blockpcl_do_multassign(struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static int64_t mm_blockpcl_isshortconst(struct mm_decls_unitrec * p);
static int64_t mm_blockpcl_isshortmem(struct mm_decls_unitrec * p);
static void mm_blockpcl_do_popindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t opc);
static void mm_blockpcl_do_popslice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t opc);
static void mm_blockpcl_do_popkeyindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t opc);
static void mm_blockpcl_do_popdot(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * c,int64_t offset,int64_t opc);
static void mm_blockpcl_do_assignarray(struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_blockpcl_do_assignrecord(struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
void mm_genmcl_codegen_mcl(void);
static void mm_genmcl_convertpcl(struct mm_libpcl_pclrec * p);
static void mm_genmcl_inithandlers(void);
static void mm_genmcl_unimpl(uint8_t * mess);
static void mm_genmcl_pc_dummy(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_comment(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_blank(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_label(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_labelname(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_startmult(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_resetmult(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_endmult(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_stackall(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_procentry(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_procexit(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_zstatic(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_istatic(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_equiv(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_initmemz_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushmem_d8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_dpushmem_d8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushmem_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushmem_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushmem_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushmem_x4(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushmem_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushmem_blk(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushint(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushint128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushreal_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushreal_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushreal_x4(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushstr(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_makeint(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_makereal(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_makestr(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_makedec(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_stackargs(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushaddr(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushptr_d8_proc(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushptr_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushptr_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushptr_x4(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushptr_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushptr_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushretslot_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushretslot_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushretslot_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushretslot_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushffretval_pushretval_d8_d124_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushffretval_pushretval_x8_x4(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_pushretval_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_moveretval_d8_d124_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_moveretval_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_moveretval_x8_x4(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popmem_popmemz_d8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popmem_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popmem_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popmem_x4(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popmem_popmemz_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popmem_blk(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popmem_storemem_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popptr_d8_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popptr_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popptr_x4(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popptr_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popptr_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storeptr_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storeptr_d8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storeptr_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storemem_d8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storemem_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storemem_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storemem_x4(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storemem_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_storeptr(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_unstack(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popretval_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popretval_d8_d124_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popretval_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_free_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_free_d16(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_free_x4_x8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_free_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_freemem_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_add_sub_i64_u64_c64_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_add_i128_u128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sub_i128_u128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_add_sub_mul_div_r32_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_add_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sub_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_mul_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_div_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_idiv_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_irem_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_iand_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_ior_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_ixor_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shl_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shr_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_min_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_max_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_power_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_append_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_appendto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_concat_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_concatto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_slice_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_in_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_neg_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_abs_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_inot_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_notl_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_istruel_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sqrt_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sin_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_cos_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_tan_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_asin_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_acos_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_atan_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_exp_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_ln_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_log_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_round_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_floor_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_ceil_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_fract_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_asc_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_chr_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_lwb_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_upb_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_len_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_bounds_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_addto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_subto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_multo_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_divto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_idivto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_iremto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_iandto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_iorto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_ixorto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shlto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shrto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_minto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_maxto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_negto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_absto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_inotto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_notlto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_mul_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_mul_i128_u128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_idiv_i128_u128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_idiv_irem_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_neg_i64_u64_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_neg_i128_u128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_neg_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_neg_r32(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_neg(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_abs_i64_u64_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_abs_r32(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_abs_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_inot_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_notl_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_istruel_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_call(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_return(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_callptr(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_syscall(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_callff(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_callptrff(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jump(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jumpcc_i64_u64_ref_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jumpccimm_i64_u64_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jumpcc_i128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jumpcc_u128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jumpcc_r32_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jumpcc_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jumpfalse_jumptrue_i64_u64_r64_ref_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_jumpinyz_jumpnotinyz_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_casejumpeq_i64_u64_r64_ref_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_setjumpeq_setjumpeqx_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_setjumpne_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_switch(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_switchlab(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_endswitch(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_info(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_setcc_i64_u64_ref_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_setcc(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_setcc_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_compare(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_isequal(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_iand_ior_ixor_i64_u64_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_iand_ior_ixor_i128_u128(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_iandc_i64_u64_c64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shl_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shr_i64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shr_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shlc_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shrc_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shr(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_in(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_min_max_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_min_max_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_addoffset_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_subref_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_suboffset_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_concat(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_append(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_andl(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_orl(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_index_indexref_ax_sx(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_indexmem_ax(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_indexref_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_index_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popindex_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_dotindex_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popdotindex_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popindex_storeindex_ax_sx(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_dotindex_i64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_dotslice(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popdotindex_d8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popdotslice_d8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_dot_dotref_rec(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_popdot_storedot_rec(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_lwb(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_upb(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_upb_sx(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_len_sx(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_lenstr_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_bounds(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sqrt_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sqr_i64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sqr_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_power_i64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_power_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sign_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sign_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sin_cos_tan_asin_acos_atan_ln_log_exp_floor_ceil_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_round(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_fract(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_fmod(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_addto_subto_iandto_iorto_ixorto_i64_u64_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_addmemto_submemto_iandmemto_iormemto_ixormemto_i64_u64_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_addto_subto_iandto_iorto_ixorto_i32_i16_i8_u32_u16_u8_c16_c8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_addto_multo_r64_r32(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_subto_divto_r64_r32(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_multo_i64_u64_i32_u32_i16_u16_i8_u8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_idivto_iremto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shlto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shlcto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shrcto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shlcmemto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shrcmemto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shrto_i64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_shrto_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_minto(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_minto_maxto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_minto_maxto_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_maxto(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_addoffsetto_suboffsetto_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_concatto(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_appendto(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_negto_inotto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_negto_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_absto_i64_u64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_absto_r32_r64(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_incrtomem_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_decrtomem_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_incrtomem_decrtomem_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_incrtomem_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_decrtomem_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_incrto_decrto_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_incrto_decrto_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_incrto_decrto_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_preincrtox_predecrtox_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_postincrtox_postdecrtox_d8_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_preincrtox_predecrtox_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_postincrtox_postdecrtox_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_preincrtox_predecrtox_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_postincrtox_postdecrtox_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_uwiden_iwiden(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_ifix(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_ifloat(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_fwiden(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_fnarrow(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_softtruncate(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_truncate(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_typepun(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_box(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_unbox(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_swap_d8(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_swap_d124(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_makerange(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_makelist_var(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_makeslice(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_slicelen_sliceupb(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_sliceptr(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_slice_ax(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_slice_ref(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_slice_sx(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_assem(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_assem_d8(struct mm_libpcl_pclrec * p);
static struct mm_mcldecls_opndrec * mm_genmcl_genasmopnd(struct mm_decls_unitrec * p);
static void mm_genmcl_pc_db_dw_dd_dq(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_resb(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_resw(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_resd(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_resq(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_copyblock(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_csegment(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_isegment(struct mm_libpcl_pclrec * p);
static void mm_genmcl_pc_zsegment(struct mm_libpcl_pclrec * p);
static void mm_genmcl_showopndstack(void);
static void mm_genmcl_showopndstack_s(void);
static int64_t mm_genmcl_findop(uint8_t * name);
static int64_t mm_genmcl_findcat(uint8_t * name);
static void mm_genmcl_dohandler(uint8_t * name,void (*fnaddr)(void));
static void mm_genmcl_fixdivopnds_d8(void);
static void mm_genmcl_doshiftn(struct mm_libpcl_pclrec * p,int64_t opc);
static void mm_genmcl_doshiftnto(struct mm_libpcl_pclrec * p,int64_t opc);
static void mm_genmcl_docallff(int64_t nargs,int64_t floatmap,int64_t isfunction,int64_t isvariadic);
static void mm_genmcl_docmaths1(uint8_t * name);
static void mm_genmcl_docmaths2(uint8_t * name);
static void mm_genmcl_call128handler_f(int64_t fnindex,int64_t n);
static void mm_genmcl_call128handler_p(int64_t fnindex,int64_t n);
static void mm_genmcl_call64handler_f(int64_t fnindex,int64_t n);
static void mm_genmcl_call64handler_p(int64_t fnindex,int64_t n);
static void mm_genmcl_calldothandler(int64_t fnindex,int64_t nargs);
static void mm_genmcl_callpopdothandler(int64_t fnindex,int64_t nargs);
static void mm_genmcl_genstringtable(void);
void mm_genmcl_genstring(uint8_t * s,int64_t length,int64_t doterm);
static void mm_genmcl_gendb(int64_t a);
static void mm_genmcl_gendw(int64_t a);
static void mm_genmcl_gendbstring(uint8_t * s,int64_t length);
static void mm_genmcl_gendq(int64_t a);
static void mm_genmcl_gendqname(struct mm_decls_strec * d);
static void mm_genmcl_gendqlabel(int64_t lab);
static void mm_genmcl_genrealtable(void);
static void mm_genmcl_genfunctiondata(void);
static void mm_genmcl_gensysfntable(void);
static void mm_genmcl_genabsneg(void);
void mm_libmcl_mclinit(void);
void mm_libmcl_initmcdest(void);
void mm_libmcl_genmc(int64_t opcode,struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
void mm_libmcl_genmc_cond(int64_t opcode,int64_t cond,struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
struct mm_mcldecls_mclrec * mm_libmcl_lastmc(void);
void mm_libmcl_genmcstr(int64_t opcode,uint8_t * s);
static struct mm_mcldecls_opndrec * mm_libmcl_newmclopnd(void);
struct mm_mcldecls_opndrec * mm_libmcl_duplopnd(struct mm_mcldecls_opndrec * a);
struct mm_mcldecls_opndrec * mm_libmcl_genxreg(int64_t xreg,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genindex(int64_t areg,int64_t ireg,int64_t scale,int64_t offset,int64_t size,int64_t labno,struct mm_decls_strec * def);
static void mm_libmcl_writemclblock(struct mm_mcldecls_mclrec * m);
struct mlib_strbuffer * mm_libmcl_writemclcode(uint8_t * caption);
void mm_libmcl_gencomment_mc(uint8_t * s);
struct mm_mcldecls_opndrec * mm_libmcl_genstrimm_mc(uint8_t * s,int64_t length);
struct mm_mcldecls_opndrec * mm_libmcl_genname_mc(uint8_t * s);
void mm_libmcl_genmc_sys(int64_t fnindex);
int64_t mm_libmcl_getsysfnlabel(int64_t fnindex);
static void mm_libmcl_writemcl(int64_t index,struct mm_mcldecls_mclrec * mcl);
void mm_libmcl_strmcl(struct mm_mcldecls_mclrec * mcl);
void mm_libmcl_stropnd(struct mm_mcldecls_opndrec * a,int64_t sizeprefix,int64_t debug);
void mm_libmcl_strvalue(struct mm_mcldecls_opndrec * a);
void mm_libmcl_setsegment(int64_t seg,int64_t align);
uint8_t * mm_libmcl_getprocname(struct mm_decls_strec * d);
int64_t mm_libmcl_widenstr(uint8_t * s,int64_t w);
uint8_t * mm_libmcl_strlabel(int64_t n);
int64_t mm_libmcl_isframe(struct mm_decls_strec * d);
uint8_t * mm_libmcl_getsizeprefix(int64_t size,int64_t enable);
int64_t mm_libmcl_needsizeprefix(int64_t opcode,struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
struct mm_mcldecls_opndrec * mm_libmcl_changeopndsize(struct mm_mcldecls_opndrec * a,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_applyoffset(struct mm_mcldecls_opndrec * a,int64_t offset,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genint_mc(int64_t x,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genrealmem_mc(double x,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genrealimm_mc(double x,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genimm(struct mm_decls_unitrec * p,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genlabel_mc(int64_t x);
struct mm_mcldecls_opndrec * mm_libmcl_genlabel_mem(int64_t x);
struct mm_mcldecls_opndrec * mm_libmcl_genmem_u_mc(struct mm_decls_unitrec * p,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genmem_d_mc(struct mm_decls_strec * d,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genmemaddr_u_mc(struct mm_decls_unitrec * p);
struct mm_mcldecls_opndrec * mm_libmcl_genmemaddr_d_mc(struct mm_decls_strec * d);
struct mm_mcldecls_opndrec * mm_libmcl_genreg(int64_t reg,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genreg0(int64_t reg,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genireg(int64_t reg,int64_t size,int64_t offset);
int64_t mm_libmcl_getopndsize_u(struct mm_decls_unitrec * p);
int64_t mm_libmcl_getopndsize_d(struct mm_decls_strec * d);
int64_t mm_libmcl_getmclcond(int64_t opc,int64_t m);
int64_t mm_libmcl_getmclcond_i(int64_t opc);
int64_t mm_libmcl_getmclcond_u(int64_t opc);
int64_t mm_libmcl_roundsizetg(int64_t size);
uint8_t * mm_libmcl_getregname(int64_t reg,int64_t size);
uint8_t * mm_libmcl_fgetregname(int64_t reg,int64_t size);
static int64_t mm_libmcl_issimple0(struct mm_decls_unitrec * p);
int64_t mm_libmcl_isintconst(struct mm_decls_unitrec * p);
int64_t mm_libmcl_isint32const(struct mm_decls_unitrec * p);
static int64_t mm_libmcl_sameoperand(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
void mm_libmcl_genmsource(int64_t lineno);
int64_t mm_libmcl_roundto(int64_t a,int64_t n);
void mm_libmcl_pushstack_mc(int64_t n);
void mm_libmcl_popstack_mc(int64_t n);
int64_t mm_libmcl_definelabel_mc(void);
int64_t mm_libmcl_createfwdlabel_mc(void);
void mm_libmcl_definefwdlabel_mc(int64_t lab);
void mm_libmcl_genjumpl_mc(int64_t lab);
int64_t mm_libmcl_getstringindex(uint8_t * s,int64_t length);
int64_t mm_libmcl_getrealindex(double x,int64_t size);
static void mm_libmcl_extendstringtable(void);
static void mm_libmcl_extendrealtable(void);
void mm_libmcl_genmc_loadint_d8(int64_t a);
void mm_libmcl_genmc_loadint_d16(uint64_t low,uint64_t high);
void mm_libmcl_genmc_loadint_vari64(int64_t a);
void mm_libmcl_genmc_loadword_d8(uint64_t a);
void mm_libmcl_genmc_loadreal_d8(double x);
void mm_libmcl_genmc_loadreal_d4(double x);
void mm_libmcl_genmc_loadreal_x8(double x);
void mm_libmcl_genmc_loadreal_x4(double x);
void mm_libmcl_genmc_loadmem_d8(struct mm_decls_strec * d);
void mm_libmcl_genmc_loadmem_d16(struct mm_decls_strec * d);
void mm_libmcl_genmc_loadmem_x8(struct mm_decls_strec * d);
void mm_libmcl_genmc_loadmem_x4(struct mm_decls_strec * d);
void mm_libmcl_genmc_loadmem_d124(struct mm_decls_strec * d,int64_t m);
void mm_libmcl_genmc_loadmemaddr(struct mm_decls_strec * d);
void mm_libmcl_genmc_loadptr_d8(int64_t offset);
void mm_libmcl_genmc_loadptr_d16(int64_t offset);
void mm_libmcl_genmc_storeptr_d8(int64_t offset);
void mm_libmcl_genmc_storeptr_d16(int64_t offset);
void mm_libmcl_genmc_storeptr_x8(int64_t offset);
void mm_libmcl_genmc_storeptr_x4(int64_t offset);
void mm_libmcl_genmc_loadptr_d124(int64_t m,int64_t offset);
void mm_libmcl_genmc_storeptr_d124(int64_t m,int64_t offset);
void mm_libmcl_genmc_floadmem(struct mm_decls_strec * d);
void mm_libmcl_genmc_loadmemw(struct mm_decls_strec * d);
void mm_libmcl_genmc_loadstr(uint8_t * s,int64_t length);
void mm_libmcl_pushalloperands(void);
void mm_libmcl_newopnd_d8(void);
void mm_libmcl_newopnd_d16(void);
void mm_libmcl_newopnd_x8(void);
void mm_libmcl_newstackopnd_d8(void);
void mm_libmcl_newstackopnd_d16(void);
void mm_libmcl_newstackopnd_var(void);
void mm_libmcl_newstackopnd_x8(void);
void mm_libmcl_genmc_storemem_d8(struct mm_decls_strec * d);
void mm_libmcl_genmc_storemem_d16(struct mm_decls_strec * d);
void mm_libmcl_genmc_storemem_x8(struct mm_decls_strec * d);
void mm_libmcl_genmc_storemem_x4(struct mm_decls_strec * d);
void mm_libmcl_genmc_storemem_d124(struct mm_decls_strec * d,int64_t m);
void mm_libmcl_genmc_storeretval_d8(int64_t offset);
void mm_libmcl_genmc_storeretval_d16_var(int64_t offset);
void mm_libmcl_genmc_storeretval_x8(int64_t offset);
void mm_libmcl_genmc_storememx(struct mm_decls_strec * d,int64_t m);
void mm_libmcl_genmc_storememw(struct mm_decls_strec * d);
void mm_libmcl_getopnds(int64_t n);
void mm_libmcl_getopndn_d8(int64_t n);
void mm_libmcl_popopnd(void);
void mm_libmcl_poparg(void);
void mm_libmcl_newretvalopnd_d8(void);
void mm_libmcl_newretvalopnd_d16(void);
void mm_libmcl_newretvalopnd_x8(void);
int64_t mm_libmcl_getnextreg(void);
void mm_libmcl_checktwofreeregs(void);
static int64_t mm_libmcl_getnexttempreg(void);
static int64_t mm_libmcl_getnexttempxreg(void);
static int64_t mm_libmcl_getnextxreg(void);
void mm_libmcl_freereg(int64_t r);
void mm_libmcl_freexreg(int64_t xr);
void mm_libmcl_gerrorc(uint8_t * mess);
struct mm_mcldecls_opndrec * mm_libmcl_genopndind(int64_t offset,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_gettempopnd_d8(void);
void mm_libmcl_freetempopnd_d8(struct mm_mcldecls_opndrec * p);
int64_t mm_libmcl_gettempreg_d8(void);
void mm_libmcl_freetempreg_d8(int64_t reg);
struct mm_mcldecls_opndrec * mm_libmcl_gettempopnd_x8(void);
void mm_libmcl_freetempopnd_x8(struct mm_mcldecls_opndrec * p);
void mm_libmcl_swapopnds(int64_t m,int64_t n);
void mm_libmcl_dupltop(void);
struct mm_mcldecls_opndrec * mm_libmcl_genopnd(int64_t offset,int64_t size);
struct mm_mcldecls_opndrec * mm_libmcl_genopndh(int64_t offset);
struct mm_mcldecls_opndrec * mm_libmcl_genopndindh(int64_t offset,int64_t size);
static void mm_libmcl_asmstr(uint8_t * s);
static void mm_libmcl_asmchar(int64_t c);
static void mm_libmcl_asmint(int64_t a);
void mm_libmcl_checkmcl(uint8_t * caption);
void ma_genss_genss(void);
static void ma_genss_doinstr(struct mm_mcldecls_mclrec * m,int64_t index);
static void ma_genss_genbyte(int64_t x);
static void ma_genss_genword(int64_t x);
static void ma_genss_gendword(int64_t x);
static void ma_genss_genqword(int64_t x);
static void ma_genss_genopnd(struct mm_mcldecls_opndrec * a,int64_t size);
static void ma_genss_addrelocitem(int64_t reloctype,struct mm_decls_strec * d);
static int64_t ma_genss_getstindex(struct mm_decls_strec * d);
static void ma_genss_genrel32(struct mm_mcldecls_opndrec * a);
static struct mm_decls_strec * ma_genss_getdef(struct mm_mcldecls_opndrec * a,int64_t dneeded);
static void ma_genss_genabs32(struct mm_mcldecls_opndrec * a);
static void ma_genss_genabs64(struct mm_mcldecls_opndrec * a);
static int64_t ma_genss_getrel32(struct mm_decls_strec * d,int64_t offset);
static void ma_genss_dofwdrefs(struct mm_decls_strec * d);
static void ma_genss_genrex(void);
static int64_t ma_genss_isbytesized(int64_t x);
static int64_t ma_genss_isdwordsized(int64_t x);
static void ma_genss_do_push(struct mm_mcldecls_opndrec * a);
static void ma_genss_do_pop(struct mm_mcldecls_opndrec * a);
static void ma_genss_do_inc(struct mm_mcldecls_opndrec * a,int64_t code);
static void ma_genss_do_neg(struct mm_mcldecls_opndrec * a,int64_t code);
static void ma_genss_genamode(struct mm_mcldecls_opndrec * a,int64_t am);
static int64_t ma_genss_makemodrm(int64_t mode,int64_t opc,int64_t rm);
static void ma_genss_setopsize(struct mm_mcldecls_opndrec * a);
static void ma_genss_setaddrsize(struct mm_mcldecls_opndrec * a);
static int64_t ma_genss_getdispsize(struct mm_mcldecls_opndrec * a,int64_t * offset);
static int64_t ma_genss_genrm(struct mm_mcldecls_opndrec * a,int64_t opc);
static void ma_genss_genrmbyte(int64_t mode,int64_t opc,int64_t rm);
static int64_t ma_genss_makeam(int64_t m,int64_t s,int64_t d);
static void ma_genss_do_arith(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t code);
static void ma_genss_do_mov(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
static int64_t ma_genss_getregcoder(int64_t reg);
static int64_t ma_genss_getregcodeb(int64_t reg);
static int64_t ma_genss_getregcodebx(int64_t reg);
static int64_t ma_genss_getregcoderx(int64_t reg);
static void ma_genss_do_lea(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
static void ma_genss_do_movsx(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc);
static void ma_genss_checkhighreg(struct mm_mcldecls_opndrec * a);
static void ma_genss_do_exch(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
static void ma_genss_do_movsxd(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
static void ma_genss_do_imul2(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
static void ma_genss_do_imul3(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,struct mm_mcldecls_opndrec * c);
static void ma_genss_do_shift(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc);
static void ma_genss_do_test(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
static void ma_genss_do_loop(struct mm_mcldecls_opndrec * a,int64_t opc);
static void ma_genss_do_jcxz(struct mm_mcldecls_opndrec * a,int64_t opsize);
static void ma_genss_do_setcc(int64_t cond,struct mm_mcldecls_opndrec * a);
static void ma_genss_do_movxmm(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t size);
static void ma_genss_do_arithxmm(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t prefix,int64_t opc);
static void ma_genss_do_logicxmm(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc,int64_t size);
static void ma_genss_do_convertfloat(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t prefix);
static void ma_genss_do_fix(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t prefix,int64_t opc);
static void ma_genss_do_float(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t prefix);
static void ma_genss_do_call(struct mm_mcldecls_opndrec * a);
static void ma_genss_do_jmp(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_mclrec * m);
static int64_t ma_genss_getcurrdatalen(int64_t id);
static void ma_genss_do_cmovcc(int64_t cond,struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
static void ma_genss_do_fmem(struct mm_mcldecls_opndrec * a,int64_t freal,int64_t code);
static int64_t ma_genss_getr32bits(double x);
static void ma_genss_genrel8(struct mm_mcldecls_opndrec * a);
static int64_t ma_genss_checkshortjump(struct mm_mcldecls_mclrec * m,struct mm_decls_strec * d);
static struct mm_decls_fwdrec * ma_genss_addfwdref(struct mm_decls_fwdrec * p,int64_t offset,int64_t reltype,int64_t seg);
static void ma_genss_switchseg(int64_t newseg);
static void ma_genss_do_movdqx(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc);
static void ma_genss_do_popcnt(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b);
static void ma_genss_do_bsf(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc);
static void ma_genss_extendsymboltable(void);
static void ma_genss_showopnd(uint8_t * caption,struct mm_mcldecls_opndrec * a);
static void ma_genss_do_pcmpistri(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t c,int64_t opc);
void ma_lib_initlib(int64_t nlabels);
static uint8_t * ma_lib_getsizetag(int64_t size);
struct ma_decls_dbuffer * ma_lib_buffercreate(int64_t size);
static void ma_lib_bufferexpand(struct ma_decls_dbuffer * a);
void ma_lib_buffercheck(struct ma_decls_dbuffer * a,int64_t n);
int64_t ma_lib_bufferlength(struct ma_decls_dbuffer * a);
void * ma_lib_bufferelemptr(struct ma_decls_dbuffer * a,int64_t offset);
void ma_lib_addbyte(struct ma_decls_dbuffer * a,int64_t x);
void ma_lib_addword(struct ma_decls_dbuffer * a,int64_t x);
void ma_lib_adddword(struct ma_decls_dbuffer * a,int64_t x);
void ma_lib_addqword(struct ma_decls_dbuffer * a,int64_t x);
void ma_writeobj_writess(uint8_t * outfile);
static void ma_writeobj_writerecord(void * r,int64_t length);
static void ma_writeobj_writerelocs(struct ma_decls_relocrec * r,int64_t nrelocs);
static void ma_writeobj_writedata(struct ma_decls_dbuffer * data);
static void ma_writeobj_writesymboltable(void);
static void ma_writeobj_writestringtable(void);
static struct ma_objdecls_imagesymbol * ma_writeobj_makesymbol(uint8_t * name,int64_t namelen,int64_t value,int64_t sectionno,int64_t symtype,int64_t storage,int64_t naux);
static void ma_writeobj_addsymbol(struct ma_objdecls_imagesymbol * r);
static void ma_writeobj_initsymboltable(uint8_t * filename);
static struct ma_objdecls_imagesymbol * ma_writeobj_strtoaux(uint8_t * s);
static struct ma_objdecls_auxsectionrec * ma_writeobj_sectiontoaux(struct ma_decls_dbuffer * data,int64_t nrelocs);
static int64_t ma_writeobj_addstringentry(uint8_t * s,int64_t length);
static void ma_writeobj_convertsymboltable(void);
static void ma_writeobj_writecoff(uint8_t * outfile);
void ma_writeexe_writeexe(uint8_t * outfile);
void ma_writeexe_genexe(uint8_t * entrypoint);
static void ma_writeexe_loadlibs(void);
struct mlib_strbuffer * ma_writeexe_writessdata(int64_t fexe);
void ma_writeexe_initsectiontable(void);
static void ma_writeexe_showssdata(int64_t fexe);
static void ma_writeexe_showsectiondata(struct ma_writeexe_sectionrec * d);
static void ma_writeexe_showsectioncode(struct ma_writeexe_sectionrec * p);
static void ma_writeexe_showsectionrelocs2(uint8_t * caption,struct ma_decls_relocrec * relocs,int64_t nrelocs);
static void ma_writeexe_gs_value(uint8_t * caption,int64_t value);
static void ma_writeexe_showsymboltable2(void);
static void ma_writeexe_showimporttable(void);
static int64_t ma_writeexe_roundtoblock(int64_t n,int64_t align);
static void ma_writeexe_showsections(void);
static uint8_t * ma_writeexe_extractlibname(uint8_t * name,int64_t * libno,int64_t moduleno);
static void ma_writeexe_scanst(void);
static void ma_writeexe_relocdata(struct ma_writeexe_sectionrec * s);
static void ma_writeexe_writerecordx(void * r,int64_t length);
static void ma_writeexe_writedosstub(void);
static void ma_writeexe_writepesig(void);
static void ma_writeexe_writepadding(int64_t offset);
static void ma_writeexe_writefileheader(void);
static void ma_writeexe_writeoptheader(void);
static void ma_writeexe_writesectionheader(struct ma_writeexe_sectionrec * s);
static void ma_writeexe_writesectiondata(struct ma_writeexe_sectionrec * s);
static void ma_writeexe_getoffsets(void);
static int64_t ma_writeexe_imported(struct mm_decls_strec * d);
static int64_t ma_writeexe_exported(struct mm_decls_strec * d);
static void ma_writeexe_addsearchlib(uint8_t * name);
static void ma_writeexe_setuplibfiles(void);
uint8_t * ma_disasm_decodeinstr(byte * * cptr,byte * baseaddr);
static void ma_disasm_decodetwobyteinstr(void);
static void ma_disasm_decodeaddr(int64_t w);
static int64_t ma_disasm_readbyte(void);
static int64_t ma_disasm_readsbyte(void);
static uint64_t ma_disasm_readword16(void);
static int64_t ma_disasm_readint16(void);
static uint64_t ma_disasm_readword32(void);
static int64_t ma_disasm_readint32(void);
static int64_t ma_disasm_readint64(void);
static int64_t ma_disasm_getreg(int64_t regcode,int64_t upper);
static uint8_t * ma_disasm_strreg(int64_t reg,int64_t opsize);
static uint8_t * ma_disasm_strfreg(int64_t freg);
static void ma_disasm_printaddrmode(int64_t xmm);
static void ma_disasm_genstr(uint8_t * s);
static void ma_disasm_genintd(int64_t a);
static void ma_disasm_genhex(int64_t a);
static int64_t ma_disasm_readimm(void);
static int64_t ma_disasm_readimm8(void);
static uint8_t * ma_disasm_strxmm(int64_t reg);
static uint8_t * ma_disasm_strmmx(int64_t reg);
static void ma_disasm_decode8087(int64_t ttt);
static void ma_disasm_do87arith(uint8_t * opcstr,int64_t ttt,int64_t freg);
static void ma_disasm_do87mem(uint8_t * opcstr,int64_t mf);
static void ma_disasm_getsil(int64_t * reg);
static void ma_disasm_getsilx(int64_t * reg);
int64_t mm_parse_parsemodule(int64_t n);
int64_t mm_parse_readmoduledefs(struct mm_decls_strec * owner);
static void mm_parse_initparser(void);
static void mm_parse_skipsemi(void);
static struct mm_decls_unitrec * mm_parse_makeblock(struct mm_decls_unitrec * p);
static struct mm_decls_unitrec * mm_parse_makestmtblock(struct mm_decls_unitrec * p);
static void mm_parse_checkequals(void);
static int64_t mm_parse_getcurrline(void);
static int64_t mm_parse_checkbegin(int64_t fbrack);
static void mm_parse_checkbeginend(int64_t closesym,int64_t kwd,int64_t startline);
static void mm_parse_checkend(int64_t endsym,int64_t endkwd1,int64_t endkwd2,int64_t startline);
static struct mm_decls_unitrec * mm_parse_readvardef(struct mm_decls_strec * owner,int64_t isglobal,int64_t isstatic,int64_t varid,int64_t k);
static void mm_parse_readconstdef(struct mm_decls_strec * owner,int64_t isglobal);
static struct mm_decls_unitrec * mm_parse_readlbrack(void);
static void mm_parse_addlistparam(struct mm_decls_strec * * ulist,struct mm_decls_strec * * ulistx,struct mm_decls_strec * p);
static struct mm_decls_unitrec * mm_parse_readcast(void);
static struct mm_decls_unitrec * mm_parse_readopc(void);
static struct mm_decls_unitrec * mm_parse_readsprint(void);
static struct mm_decls_unitrec * mm_parse_readsread(void);
static struct mm_decls_unitrec * mm_parse_readcompilervar(void);
static struct mm_decls_unitrec * mm_parse_readcastx(void);
void mm_parse_checksymbol(int64_t symbol);
static int64_t mm_parse_readtypespec(struct mm_decls_strec * owner,int64_t typedefx);
static int64_t mm_parse_readslicetype(struct mm_decls_strec * owner,int64_t typedefx);
static struct mm_decls_unitrec * mm_parse_readslist(int64_t iscall,int64_t donulls);
static struct mm_decls_unitrec * mm_parse_readindex(struct mm_decls_unitrec * p,int64_t dot);
static struct mm_decls_unitrec * mm_parse_readdotsuffix(struct mm_decls_unitrec * p);
int64_t mm_parse_isconstexpr(struct mm_decls_unitrec * p);
static struct mm_decls_unitrec * mm_parse_readkeyindex(struct mm_decls_unitrec * p);
static struct mm_decls_unitrec * mm_parse_readconstexpr(int64_t needconst);
static int64_t mm_parse_readconstint(void);
static void mm_parse_readprocdef(struct mm_decls_strec * procowner,int64_t isglobal,int64_t fflang);
struct mm_decls_strec * mm_parse_readprocdecl(struct mm_decls_strec * procowner,int64_t isglobal,int64_t fflang);
static struct mm_decls_strec * mm_parse_readparams(struct mm_decls_strec * procowner,struct mm_decls_strec * owner,int64_t fflang,int64_t * varparams,int64_t * nparams);
static struct mm_decls_strec * mm_parse_readparams_types(struct mm_decls_strec * procowner,struct mm_decls_strec * owner,int64_t fflang,int64_t * varparams,int64_t * nparams,int64_t pmode,int64_t parammode);
static struct mm_decls_unitrec * mm_parse_readcondsuffix(struct mm_decls_unitrec * p);
static struct mm_decls_unitrec * mm_parse_readif(void);
static struct mm_decls_unitrec * mm_parse_readgoto(int64_t gototag);
static struct mm_decls_unitrec * mm_parse_readunless(void);
static struct mm_decls_unitrec * mm_parse_readswitchcase(void);
static struct mm_decls_unitrec * mm_parse_readstop(void);
static struct mm_decls_unitrec * mm_parse_readreturn(void);
static struct mm_decls_unitrec * mm_parse_readdo(void);
static struct mm_decls_unitrec * mm_parse_readto(void);
static struct mm_decls_unitrec * mm_parse_readwhile(void);
static struct mm_decls_unitrec * mm_parse_readrepeat(void);
static struct mm_decls_unitrec * mm_parse_readloopcontrol(void);
static struct mm_decls_unitrec * mm_parse_readprint(void);
static struct mm_decls_unitrec * mm_parse_readread(void);
static struct mm_decls_unitrec * mm_parse_readtry(void);
static struct mm_decls_unitrec * mm_parse_readraise(void);
static struct mm_decls_unitrec * mm_parse_readfor(void);
void mm_parse_readtypedef(struct mm_decls_strec * owner,int64_t isglobal);
void mm_parse_readrecordfields(struct mm_decls_strec * owner,int64_t m);
void mm_parse_readtabledef(struct mm_decls_strec * owner,int64_t isglobal);
void mm_parse_readclassdef(struct mm_decls_strec * owner,int64_t isglobal);
static void mm_parse_readclassbody(struct mm_decls_strec * owner,int64_t classkwd);
static int64_t mm_parse_readenumtype(struct mm_decls_strec * owner,int64_t typedefx,int64_t isglobal);
static void mm_parse_readimportmodule(struct mm_decls_strec * owner);
static void mm_parse_readimportbody(struct mm_decls_strec * owner);
static struct mm_decls_strec * mm_parse_readequivfield(struct mm_decls_strec * owner);
static struct mm_decls_unitrec * mm_parse_readapplyop(int64_t inexpr);
static int64_t mm_parse_readrefproc(struct mm_decls_strec * owner,int64_t typedefx,int64_t fflang);
static void mm_parse_pushproc(struct mm_decls_strec * p);
static void mm_parse_popproc(void);
static struct mm_decls_unitrec * mm_parse_readassemline(void);
static struct mm_decls_unitrec * mm_parse_readassemblock(void);
static struct mm_decls_unitrec * mm_parse_assembleline(int64_t oneline);
static struct mm_decls_unitrec * mm_parse_readassemopnd(void);
static struct mm_decls_unitrec * mm_parse_makeastring(void);
static int64_t mm_parse_readreturntype(struct mm_decls_strec * owner,int64_t (*retmodes)[]);
static struct mm_decls_unitrec * mm_parse_readset(void);
static int64_t mm_parse_istypestarter(void);
static struct mm_decls_unitrec * mm_parse_readunit(void);
static struct mm_decls_unitrec * mm_parse_readfactor(int64_t level);
static struct mm_decls_unitrec * mm_parse_readterm2(void);
static struct mm_decls_unitrec * mm_parse_readterm(void);
static struct mm_decls_unitrec * mm_parse_readxunit(void);
static struct mm_decls_unitrec * mm_parse_readsunit(int64_t inwhile);
static void mm_parse_readmacrodef(struct mm_decls_strec * owner,int64_t isglobal);
static void mm_parse_readimportalias(struct mm_decls_strec * dimport);
static void mm_parse_domappedalias(struct mm_decls_strec * dimport,struct mm_decls_strec * stimport);
static struct mm_decls_unitrec * mm_parse_readrecase(void);
static struct mm_decls_unitrec * mm_parse_createblock(struct mm_decls_unitrec * p,struct mm_decls_unitrec * q);
static void mm_parse_adddocstring(uint8_t * s,int64_t n);
void mm_name_rx_typetable(void);
void mm_name_rx_unit(struct mm_decls_strec * owner,struct mm_decls_unitrec * p);
int64_t mm_name_rx_module(int64_t n);
void mm_name_rx_deflist(struct mm_decls_strec * owner,struct mm_decls_strec * p);
void mm_name_rx_passdef(struct mm_decls_strec * owner,struct mm_decls_strec * p);
static void mm_name_rx_unitlist(struct mm_decls_strec * owner,struct mm_decls_unitrec * p);
struct mm_decls_strec * mm_name_resolvetopname(struct mm_decls_strec * owner,struct mm_decls_strec * stnewname,int64_t moduleno,int64_t fmodule,int64_t fdoambig);
void mm_name_resolvename(struct mm_decls_strec * owner,struct mm_decls_unitrec * p);
struct mm_decls_strec * mm_name_finddupl(struct mm_decls_strec * d,struct mm_decls_strec * pdupl);
static void mm_name_resolvedot(struct mm_decls_strec * owner,struct mm_decls_unitrec * p);
static void mm_name_fixmode(struct mm_decls_strec * owner,struct mm_decls_strec * p);
static int64_t mm_name_fixmode2(struct mm_decls_strec * owner,int64_t m);
void mm_name_fixusertypes(void);
static void mm_name_rx_assem(struct mm_decls_strec * owner,struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
struct mm_decls_strec * mm_name_resolve_equiv_name(struct mm_decls_strec * owner,struct mm_decls_strec * p);
static struct mm_decls_strec * mm_name_addframevar(struct mm_decls_strec * owner,struct mm_decls_strec * d,int64_t moduleno,int64_t mode);
static void mm_name_converteqeq(struct mm_decls_strec * owner,struct mm_decls_unitrec * p);
static struct mm_decls_unitrec * mm_name_copylistunit(struct mm_decls_unitrec * p);
static struct mm_decls_unitrec * mm_name_copyunit(struct mm_decls_unitrec * p);
static void mm_name_replaceunit(struct mm_decls_unitrec * p,struct mm_decls_unitrec * q);
static void mm_name_expandmacro(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_name_duplfield(struct mm_decls_strec * owner,struct mm_decls_strec * p,struct mm_decls_strec * q);
static void mm_name_do_baseclass(struct mm_decls_strec * p);
void mm_type_tx_allprocs(void);
static void mm_type_tpass(struct mm_decls_unitrec * p,int64_t t,int64_t lv);
static void mm_type_tx_block(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t,int64_t lv);
void mm_type_tx_typetable(void);
static void mm_type_setmodesize(int64_t m);
static void mm_type_setarraysize(int64_t m);
static void mm_type_setslicesize(int64_t m);
static void mm_type_tcond(struct mm_decls_unitrec * p);
int64_t mm_type_tx_module(int64_t n);
void mm_type_tx_passdef(struct mm_decls_strec * p);
static void mm_type_tx_unitlist(struct mm_decls_unitrec * p,int64_t t,int64_t lv);
static void mm_type_tx_namedef(struct mm_decls_strec * d);
void mm_type_tx_namedconst(struct mm_decls_strec * d);
static void mm_type_tx_expr(struct mm_decls_unitrec * p,int64_t t);
static void mm_type_checkconstexpr(struct mm_decls_unitrec * p);
static int64_t mm_type_getconstint(struct mm_decls_unitrec * q,int64_t t);
static void mm_type_tevaluate(struct mm_decls_unitrec * p);
static void mm_type_tevalbinop(struct mm_decls_unitrec * p);
static void mm_type_tevalmonop(struct mm_decls_unitrec * p);
static void mm_type_tevalconvert(struct mm_decls_unitrec * p);
static void mm_type_makenewconst(struct mm_decls_unitrec * p,int64_t x,int64_t t);
static void mm_type_tx_name(struct mm_decls_unitrec * p,int64_t t,int64_t lv);
static void mm_type_getdominantmode(int64_t tag,int64_t s,int64_t t,int64_t * u,int64_t * v);
static void mm_type_getdominantmodepp(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t * u,int64_t * v);
static void mm_type_coerceunit(struct mm_decls_unitrec * p,int64_t t,int64_t hard);
static void mm_type_tx_add(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_mul(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_shl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_iand(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_eq(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_isequal(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_lt(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_callproc(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * pargs,int64_t t);
static void mm_type_tx_neg(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_if(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t t,int64_t lv);
static void mm_type_tx_longif(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t t,int64_t lv);
static void mm_type_tx_preincr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t);
static void mm_type_tx_for(struct mm_decls_unitrec * pindex,struct mm_decls_unitrec * pbody,struct mm_decls_unitrec * ptemps);
static void mm_type_tx_index(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t t,int64_t lv);
static void mm_type_tx_keyindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t lv);
static void mm_type_tx_makerange(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_makeset(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t);
static void mm_type_tx_makedict(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t);
static void mm_type_tx_ptr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t,int64_t lv);
static void mm_type_setrecordsize(int64_t m);
static void mm_type_scanrecord(int64_t state,struct mm_decls_strec * (*fields)[],int64_t * index,int64_t * isize,int64_t offset,int64_t calign,int64_t * maxalign);
static int64_t mm_type_roundoffset(int64_t offset,int64_t alignment);
int64_t mm_type_getalignment(int64_t m);
static void mm_type_tx_convert(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t hard);
static void mm_type_tx_makelist(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t,int64_t lv);
static void mm_type_tx_dot(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t lv);
static struct mm_decls_strec * mm_type_resolvefield(struct mm_decls_strec * d,int64_t m);
static int64_t mm_type_comparemodes(int64_t s,int64_t t);
static int64_t mm_type_isboolunit(struct mm_decls_unitrec * p);
static void mm_type_checkbool(int64_t m);
static void mm_type_tx_andl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_convintconst(struct mm_decls_unitrec * p,int64_t x);
static void mm_type_tx_upb(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_len(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_lenstr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_lwb(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_bounds(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_sliceptr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_inot(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_atan2(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_swap(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_sqrt(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_select(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t t,int64_t lv);
static void mm_type_tx_case(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t t,int64_t lv);
static void mm_type_tx_notl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_istruel(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_addto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_iandto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_negto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_typepun(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t lv);
static void mm_type_tx_bytesize(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_exit(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_goto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_switch(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t t,int64_t lv);
static void mm_type_tx_power(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_addroffirst(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t);
static void mm_type_tx_minvalue(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_tx_return(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t);
static void mm_type_tx_dotindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t lv);
static void mm_type_tx_slice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_assign(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t t);
static void mm_type_tx_multassign(struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_in(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static struct mm_decls_strec * mm_type_getprocretmodes(struct mm_decls_unitrec * p);
static void mm_type_tx_exprlist(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t);
static void mm_type_tx_sign(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a);
static void mm_type_fixvoidunit(struct mm_decls_unitrec * a);
static void mm_type_twiden(struct mm_decls_unitrec * p,int64_t lv);
static int64_t mm_type_twidenshort(struct mm_decls_unitrec * p);
static void mm_type_tx_head(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_tx_concat(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_twidenopnd(struct mm_decls_unitrec * p);
static void mm_type_joinstrings(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b);
static void mm_type_removeaddrof(struct mm_decls_unitrec * p);
static void mm_type_tstringslice(struct mm_decls_unitrec * p,int64_t slicemode);
static void mm_type_tx_bitfield(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t lv);
static void mm_type_deref(struct mm_decls_unitrec * a);
static void mm_type_tmethodcall(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pdot,struct mm_decls_unitrec * pargs);

/* VARS */
int64_t mm_decls_ntypes;
int64_t mm_decls_nuserxtypes;
int64_t mm_decls_userxtypebase;
struct mm_decls_userxrec *  mm_decls_userxmodelist;
int32_t mm_decls_ttmodule[40000];
struct mm_decls_strec *  mm_decls_ttnamedef[40000];
struct mm_decls_strec *  mm_decls_ttowner[40000];
int32_t mm_decls_ttbasetype[40000];
uint8_t *  mm_decls_ttname[40000];
byte mm_decls_tttypecat[40000];
byte mm_decls_ttbitwidth[40000];
int32_t mm_decls_ttsize[40000];
byte mm_decls_ttsizeset[40000];
int32_t mm_decls_ttlower[40000];
int32_t mm_decls_ttlength[40000];
struct mm_decls_unitrec *  mm_decls_ttdimexpr[40000];
int32_t mm_decls_tttarget[40000];
byte mm_decls_ttusercat[40000];
int32_t mm_decls_ttlineno[40000];
byte mm_decls_ttisint[40000];
byte mm_decls_ttisword[40000];
byte mm_decls_ttischar[40000];
byte mm_decls_ttiswordchar[40000];
byte mm_decls_ttisreal[40000];
byte mm_decls_ttisinteger[40000];
byte mm_decls_ttisnumeric[40000];
byte mm_decls_ttisshortint[40000];
byte mm_decls_ttisbit[40000];
byte mm_decls_ttisref[40000];
byte mm_decls_ttisvar[40000];
byte mm_decls_typestarterset[40000];
struct mm_decls_strec *  mm_decls_ttnamedefx[4000];
struct mm_decls_strec *  mm_decls_ttnamedefx2[4000];
int64_t mm_decls_ttlinenox[4000];
int64_t mm_decls_ttxmap[4000];
byte mm_decls_ttxmoduleno[4000];
byte mm_decls_exprstarterset[154];
struct mm_decls_modulerec mm_decls_moduletable[51];
uint8_t *  mm_decls_inputfiles[51];
uint8_t *  mm_decls_libfiles[51];
uint8_t *  mm_decls_sourcefilenames[251];
uint8_t *  mm_decls_sourcefilepaths[251];
uint8_t *  mm_decls_sourcefiletext[251];
int64_t mm_decls_sourcefilesizes[251];
byte mm_decls_issupportfile[251];
int64_t mm_decls_nmodules;
int64_t mm_decls_nsourcefiles;
int64_t mm_decls_ninputfiles;
int64_t mm_decls_nlibfiles;
uint8_t *  mm_decls_mafilenames[251];
int64_t mm_decls_mafilesizes[251];
int64_t mm_decls_mafileoffsets[251];
uint8_t *  mm_decls_mafiletext[251];
byte mm_decls_mafilefileno[251];
byte mm_decls_mafilesupport[251];
int64_t mm_decls_nmafiles;
uint8_t *  mm_decls_mafilesource;
struct mm_decls_strec *  mm_decls_currmodule;
int64_t mm_decls_currmoduleno;
uint8_t *  mm_decls_searchdirs[10];
int64_t mm_decls_nsearchdirs = (int64_t)0;
struct mm_decls_strec *  mm_decls_stprogram;
struct mm_decls_strec *  mm_decls_stmodule;
struct mm_decls_strec *  mm_decls_stsysmodule;
struct mm_decls_strec *  mm_decls_alldeflist;
int64_t mm_decls_optflag = (int64_t)0;
struct mm_decls_unitrec *  mm_decls_nullunit;
uint8_t *  mm_decls_libpaths[10];
int64_t mm_decls_nlibpaths;
int64_t mm_decls_mlineno = (int64_t)0;
int64_t mm_decls_alineno = (int64_t)0;
int64_t mm_decls_debug = (int64_t)0;
int64_t mm_decls_assemmode = (int64_t)0;
int64_t mm_decls_totalstrings = (int64_t)0;
int64_t mm_decls_ndllnametable;
int64_t mm_decls_ndllproctable;
uint8_t *  mm_decls_dllnametable[50];
uint64_t mm_decls_dllinsttable[50];
struct mm_decls_dllprocrec mm_decls_dllproctable[500];
int64_t mm_decls_ncmdparams;
uint8_t *  mm_decls_cmdparamtable[33];
struct mm_decls_procrec *  mm_decls_proclist;
int64_t mm_decls_nproclist;
struct mm_decls_procrec *  mm_decls_staticlist;
int64_t mm_decls_nstaticlist;
struct mm_decls_strec *  mm_decls_currproc;
uint8_t *  mm_decls_modenames[3] = {(uint8_t*)"compile_mode",(uint8_t*)"link_mode",(uint8_t*)"run_mode"};
uint8_t *  mm_decls_targetnames[7] = {(uint8_t*)"wx64",(uint8_t*)"wc64",(uint8_t*)"lx64",(uint8_t*)"lc64",(uint8_t*)"lc32",(uint8_t*)"wc32",(uint8_t*)"no32"};
uint8_t *  mm_decls_targetosnames[7] = {(uint8_t*)"windows",(uint8_t*)"windows",(uint8_t*)"linux",(uint8_t*)"linux",(uint8_t*)"linux",(uint8_t*)"windows",(uint8_t*)"none"};
uint8_t *  mm_decls_targetlangnames[7] = {(uint8_t*)"x64",(uint8_t*)"clang",(uint8_t*)"x64",(uint8_t*)"clang",(uint8_t*)"clang",(uint8_t*)"clang",(uint8_t*)"clang"};
uint8_t *  mm_decls_targetexts[7] = {(uint8_t*)"asm",(uint8_t*)"c",(uint8_t*)"asm",(uint8_t*)"c",(uint8_t*)"c",(uint8_t*)"c",(uint8_t*)"c"};
byte mm_decls_tg_ctarget[7] = {(uint8_t)0u,(uint8_t)1u,(uint8_t)0u,(uint8_t)1u,(uint8_t)1u,(uint8_t)1u,(uint8_t)1u};
byte mm_decls_tg_targetbits[7] = {(uint8_t)64u,(uint8_t)64u,(uint8_t)64u,(uint8_t)64u,(uint8_t)32u,(uint8_t)32u,(uint8_t)64u};
byte mm_decls_tg_islinux[7] = {(uint8_t)0u,(uint8_t)0u,(uint8_t)1u,(uint8_t)1u,(uint8_t)1u,(uint8_t)0u,(uint8_t)0u};
uint8_t *  mm_decls_ccnames[3] = {(uint8_t*)"gcc_cc",(uint8_t*)"tcc_cc",(uint8_t*)"bcc_cc"};
int64_t mm_decls_target;
int64_t mm_decls_ctarget = (int64_t)0;
int64_t mm_decls_islinux = (int64_t)0;
int64_t mm_decls_targetbits;
int64_t mm_decls_targetsize;
int64_t mm_decls_fverbose = (int64_t)1;
byte mm_decls_fdebugcompiler;
int64_t mm_decls_fhpcounter = (int64_t)0;
byte mm_decls_fnomsys;
int64_t mm_decls_fvarnames = (int64_t)0;
int64_t mm_decls_fbundled = (int64_t)0;
uint8_t *  mm_decls_mafilename;
int64_t mm_decls_fwritema;
int64_t mm_decls_fexe;
int64_t mm_decls_fobj;
int64_t mm_decls_fwritelibs;
int64_t mm_decls_fshowtiming;
int64_t mm_decls_fshowss;
int64_t mm_decls_fshowpcl1;
int64_t mm_decls_fshowpcl2;
int64_t mm_decls_fshowmcl1;
int64_t mm_decls_fshowasm;
int64_t mm_decls_fshowast1;
int64_t mm_decls_fshowast2;
int64_t mm_decls_fshowast3;
int64_t mm_decls_fshowst;
int64_t mm_decls_fshowstflat;
int64_t mm_decls_fshowtypes;
int64_t mm_decls_ccompiler = (int64_t)1;
int64_t mm_decls_foptimise;
int64_t mm_decls_fshowrecs;
int64_t mm_decls_fuseax;
int64_t mm_decls_fcheckunusedlocals = (int64_t)0;
int64_t mm_decls_dointlibs = (int64_t)1;
struct mm_decls_lexrec mm_decls_lx;
struct mm_decls_lexrec mm_decls_nextlx;
int64_t mm_decls_labelno = (int64_t)0;
uint8_t *  mm_decls_infotext;
int64_t mm_decls_nalllines;
int64_t mm_decls_prescanmode;
uint8_t *  mm_decls_genericmodules[25];
uint8_t *  mm_decls_actualmodules[25];
int64_t mm_decls_nmodulemap;
uint8_t *  mm_decls_cclibtable[10];
int64_t mm_decls_ncclibs;
int64_t mm_decls_nsmall;
int64_t mm_decls_nallnos;
int64_t mm_decls_nasmint;
int64_t mm_decls_nasmintsmall;
int64_t mm_decls_npcl;
int64_t mm_decls_nmcl;
int64_t mm_decls_nunits;
int64_t mm_decls_ntokens;
int64_t mm_decls_nnames;
int64_t mm_decls_nints;
int64_t mm_decls_nstringconsts;
int64_t mm_decls_cc_mode;
int64_t mm_decls_passlevel = (int64_t)6;
uint8_t *  mm_decls_outfile;
uint8_t *  mm_decls_outfilesource;
uint8_t *  mm_decls_outfilebin;
uint8_t *  mm_decls_destfilename;
uint8_t *  mm_decls_linkoption;
int64_t mm_decls_sysfnlabels[181];
int64_t mm_decls_sysfnproclabels[181];
uint8_t *  mm_decls_docstrings[20];
int64_t mm_decls_ndocstrings;
int64_t mm_decls_nexit;
int64_t mm_decls_nnestedexit;
int64_t mm_decls_nprocs;
int64_t mm_decls_nallnames;
int64_t mm_decls_nkeywords;
int64_t mm_decls_nidents;
int64_t mm_decls_nallparams;
int64_t mm_decls_nsimple;
int64_t mm_decls_nonebased;
int64_t mm_decls_nzerobased;
int64_t mm_decls_notherbased;
int64_t mm_decls_nalladds;
int64_t mm_decls_nalladd3s;
uint8_t *  mm_tables_stdtypenames[38] = {
    (uint8_t*)"void",
    (uint8_t*)"i8",
    (uint8_t*)"i16",
    (uint8_t*)"i32",
    (uint8_t*)"i64",
    (uint8_t*)"i128",
    (uint8_t*)"u8",
    (uint8_t*)"u16",
    (uint8_t*)"u32",
    (uint8_t*)"u64",
    (uint8_t*)"u128",
    (uint8_t*)"r32",
    (uint8_t*)"r64",
    (uint8_t*)"c8",
    (uint8_t*)"c16",
    (uint8_t*)"c64",
    (uint8_t*)"u1",
    (uint8_t*)"u2",
    (uint8_t*)"u4",
    (uint8_t*)"ref",
    (uint8_t*)"tany",
    (uint8_t*)"bf",
    (uint8_t*)"range",
    (uint8_t*)"sx",
    (uint8_t*)"ax",
    (uint8_t*)"rec",
    (uint8_t*)"proc",
    (uint8_t*)"d124",
    (uint8_t*)"x4",
    (uint8_t*)"d8",
    (uint8_t*)"x8",
    (uint8_t*)"d16",
    (uint8_t*)"blk",
    (uint8_t*)"var",
    (uint8_t*)"tauto",
    (uint8_t*)"lab",
    (uint8_t*)"mult",
    (uint8_t*)"tlast"
};
byte mm_tables_stdtypebits[38] = {
    (uint8_t)0u,
    (uint8_t)8u,
    (uint8_t)16u,
    (uint8_t)32u,
    (uint8_t)64u,
    (uint8_t)128u,
    (uint8_t)8u,
    (uint8_t)16u,
    (uint8_t)32u,
    (uint8_t)64u,
    (uint8_t)128u,
    (uint8_t)32u,
    (uint8_t)64u,
    (uint8_t)8u,
    (uint8_t)16u,
    (uint8_t)64u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)4u,
    (uint8_t)64u,
    (uint8_t)0u,
    (uint8_t)8u,
    (uint8_t)128u,
    (uint8_t)128u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)64u,
    (uint8_t)64u,
    (uint8_t)64u,
    (uint8_t)64u,
    (uint8_t)128u,
    (uint8_t)0u,
    (uint8_t)64u,
    (uint8_t)0u,
    (uint8_t)8u,
    (uint8_t)0u,
    (uint8_t)0u
};
byte mm_tables_stdtypecode[38] = {
    (uint8_t)0u,
    (uint8_t)73u,
    (uint8_t)73u,
    (uint8_t)73u,
    (uint8_t)73u,
    (uint8_t)73u,
    (uint8_t)85u,
    (uint8_t)85u,
    (uint8_t)85u,
    (uint8_t)85u,
    (uint8_t)85u,
    (uint8_t)82u,
    (uint8_t)82u,
    (uint8_t)85u,
    (uint8_t)85u,
    (uint8_t)85u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)80u,
    (uint8_t)0u,
    (uint8_t)85u,
    (uint8_t)0u,
    (uint8_t)65u,
    (uint8_t)65u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)65u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u
};
byte mm_tables_stdtypecat[38] = {
    (uint8_t)0u,
    (uint8_t)27u,
    (uint8_t)27u,
    (uint8_t)27u,
    (uint8_t)29u,
    (uint8_t)31u,
    (uint8_t)27u,
    (uint8_t)27u,
    (uint8_t)27u,
    (uint8_t)29u,
    (uint8_t)31u,
    (uint8_t)27u,
    (uint8_t)29u,
    (uint8_t)27u,
    (uint8_t)27u,
    (uint8_t)29u,
    (uint8_t)27u,
    (uint8_t)27u,
    (uint8_t)27u,
    (uint8_t)29u,
    (uint8_t)0u,
    (uint8_t)27u,
    (uint8_t)31u,
    (uint8_t)31u,
    (uint8_t)32u,
    (uint8_t)32u,
    (uint8_t)26u,
    (uint8_t)27u,
    (uint8_t)28u,
    (uint8_t)29u,
    (uint8_t)30u,
    (uint8_t)31u,
    (uint8_t)32u,
    (uint8_t)33u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u
};
byte mm_tables_stdtypebase[38] = {
    (uint8_t)0u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)5u,
    (uint8_t)9u,
    (uint8_t)9u,
    (uint8_t)9u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)15u,
    (uint8_t)15u,
    (uint8_t)15u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u
};
int64_t mm_tables_trefproc;
int64_t mm_tables_treflabel;
int64_t mm_tables_trefchar;
uint8_t *  mm_tables_packtypenames[20] = {
    (uint8_t*)"tp_void",
    (uint8_t*)"tp_i64",
    (uint8_t*)"tp_u64",
    (uint8_t*)"tp_r64",
    (uint8_t*)"tp_pvoid",
    (uint8_t*)"tp_pi8",
    (uint8_t*)"tp_pi16",
    (uint8_t*)"tp_pi32",
    (uint8_t*)"tp_pi64",
    (uint8_t*)"tp_pi128",
    (uint8_t*)"tp_pu8",
    (uint8_t*)"tp_pu16",
    (uint8_t*)"tp_pu32",
    (uint8_t*)"tp_pu64",
    (uint8_t*)"tp_pu128",
    (uint8_t*)"tp_pr32",
    (uint8_t*)"tp_pr64",
    (uint8_t*)"tp_pstruct",
    (uint8_t*)"tp_stringz",
    (uint8_t*)"tp_variant"
};
int64_t mm_tables_packtypewidths[20] = {
    (int64_t)0,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64
};
uint8_t *  mm_tables_jtagnames[253] = {
    (uint8_t*)"j_none",
    (uint8_t*)"j_const",
    (uint8_t*)"j_null",
    (uint8_t*)"j_name",
    (uint8_t*)"j_block",
    (uint8_t*)"j_stmtblock",
    (uint8_t*)"j_decimal",
    (uint8_t*)"j_assem",
    (uint8_t*)"j_assemmacro",
    (uint8_t*)"j_assemreg",
    (uint8_t*)"j_assemxreg",
    (uint8_t*)"j_assemmem",
    (uint8_t*)"j_andl",
    (uint8_t*)"j_orl",
    (uint8_t*)"j_xorl",
    (uint8_t*)"j_notl",
    (uint8_t*)"j_istruel",
    (uint8_t*)"j_andb",
    (uint8_t*)"j_orb",
    (uint8_t*)"j_makelist",
    (uint8_t*)"j_makerange",
    (uint8_t*)"j_makeset",
    (uint8_t*)"j_makedict",
    (uint8_t*)"j_makeslice",
    (uint8_t*)"j_exprlist",
    (uint8_t*)"j_multexpr",
    (uint8_t*)"j_returnmult",
    (uint8_t*)"j_keyword",
    (uint8_t*)"j_keyvalue",
    (uint8_t*)"j_assignx",
    (uint8_t*)"j_deepcopyx",
    (uint8_t*)"j_callfn",
    (uint8_t*)"j_callmfn",
    (uint8_t*)"j_applyop",
    (uint8_t*)"j_applyopx",
    (uint8_t*)"j_andand",
    (uint8_t*)"j_eq",
    (uint8_t*)"j_ne",
    (uint8_t*)"j_lt",
    (uint8_t*)"j_le",
    (uint8_t*)"j_gt",
    (uint8_t*)"j_ge",
    (uint8_t*)"j_isequal",
    (uint8_t*)"j_add",
    (uint8_t*)"j_sub",
    (uint8_t*)"j_mul",
    (uint8_t*)"j_div",
    (uint8_t*)"j_idiv",
    (uint8_t*)"j_irem",
    (uint8_t*)"j_idivrem",
    (uint8_t*)"j_iand",
    (uint8_t*)"j_ior",
    (uint8_t*)"j_ixor",
    (uint8_t*)"j_shl",
    (uint8_t*)"j_shr",
    (uint8_t*)"j_in",
    (uint8_t*)"j_notin",
    (uint8_t*)"j_inrev",
    (uint8_t*)"j_inrange",
    (uint8_t*)"j_inset",
    (uint8_t*)"j_min",
    (uint8_t*)"j_max",
    (uint8_t*)"j_subref",
    (uint8_t*)"j_addoffset",
    (uint8_t*)"j_suboffset",
    (uint8_t*)"j_concat",
    (uint8_t*)"j_append",
    (uint8_t*)"j_clamp",
    (uint8_t*)"j_left",
    (uint8_t*)"j_right",
    (uint8_t*)"j_head",
    (uint8_t*)"j_tail",
    (uint8_t*)"j_init",
    (uint8_t*)"j_last",
    (uint8_t*)"j_take",
    (uint8_t*)"j_drop",
    (uint8_t*)"j_dupl",
    (uint8_t*)"j_ireverse",
    (uint8_t*)"j_reverse",
    (uint8_t*)"j_insert",
    (uint8_t*)"j_delete",
    (uint8_t*)"j_prepend",
    (uint8_t*)"j_zip",
    (uint8_t*)"j_convlc",
    (uint8_t*)"j_convuc",
    (uint8_t*)"j_flexptr",
    (uint8_t*)"j_stringz",
    (uint8_t*)"j_sliceptr",
    (uint8_t*)"j_index",
    (uint8_t*)"j_slice",
    (uint8_t*)"j_dotindex",
    (uint8_t*)"j_dotslice",
    (uint8_t*)"j_anddotindex",
    (uint8_t*)"j_anddotslice",
    (uint8_t*)"j_keyindex",
    (uint8_t*)"j_dot",
    (uint8_t*)"j_dotattr",
    (uint8_t*)"j_atan2",
    (uint8_t*)"j_power",
    (uint8_t*)"j_ptr",
    (uint8_t*)"j_addrof",
    (uint8_t*)"j_addroffirst",
    (uint8_t*)"j_convert",
    (uint8_t*)"j_convertref",
    (uint8_t*)"j_autocast",
    (uint8_t*)"j_typepun",
    (uint8_t*)"j_typeconst",
    (uint8_t*)"j_operator",
    (uint8_t*)"j_upper",
    (uint8_t*)"j_neg",
    (uint8_t*)"j_abs",
    (uint8_t*)"j_inot",
    (uint8_t*)"j_chr",
    (uint8_t*)"j_asc",
    (uint8_t*)"j_sqrt",
    (uint8_t*)"j_sqr",
    (uint8_t*)"j_cube",
    (uint8_t*)"j_sign",
    (uint8_t*)"j_sin",
    (uint8_t*)"j_cos",
    (uint8_t*)"j_tan",
    (uint8_t*)"j_asin",
    (uint8_t*)"j_acos",
    (uint8_t*)"j_atan",
    (uint8_t*)"j_ln",
    (uint8_t*)"j_lg",
    (uint8_t*)"j_log",
    (uint8_t*)"j_exp",
    (uint8_t*)"j_round",
    (uint8_t*)"j_floor",
    (uint8_t*)"j_ceil",
    (uint8_t*)"j_fract",
    (uint8_t*)"j_fmod",
    (uint8_t*)"j_lwb",
    (uint8_t*)"j_upb",
    (uint8_t*)"j_len",
    (uint8_t*)"j_bounds",
    (uint8_t*)"j_lenstr",
    (uint8_t*)"j_bitwidth",
    (uint8_t*)"j_bytesize",
    (uint8_t*)"j_typeof",
    (uint8_t*)"j_typestr",
    (uint8_t*)"j_bitfield",
    (uint8_t*)"j_minvalue",
    (uint8_t*)"j_maxvalue",
    (uint8_t*)"j_preincrx",
    (uint8_t*)"j_predecrx",
    (uint8_t*)"j_postincrx",
    (uint8_t*)"j_postdecrx",
    (uint8_t*)"j_incr",
    (uint8_t*)"j_decr",
    (uint8_t*)"j_addto",
    (uint8_t*)"j_subto",
    (uint8_t*)"j_multo",
    (uint8_t*)"j_divto",
    (uint8_t*)"j_idivto",
    (uint8_t*)"j_iremto",
    (uint8_t*)"j_iandto",
    (uint8_t*)"j_iorto",
    (uint8_t*)"j_ixorto",
    (uint8_t*)"j_shlto",
    (uint8_t*)"j_shrto",
    (uint8_t*)"j_andlto",
    (uint8_t*)"j_orlto",
    (uint8_t*)"j_appendto",
    (uint8_t*)"j_concatto",
    (uint8_t*)"j_minto",
    (uint8_t*)"j_maxto",
    (uint8_t*)"j_addoffsetto",
    (uint8_t*)"j_suboffsetto",
    (uint8_t*)"j_negto",
    (uint8_t*)"j_absto",
    (uint8_t*)"j_inotto",
    (uint8_t*)"j_notlto",
    (uint8_t*)"j_isvoid",
    (uint8_t*)"j_isdef",
    (uint8_t*)"j_isint",
    (uint8_t*)"j_isreal",
    (uint8_t*)"j_isstring",
    (uint8_t*)"j_islist",
    (uint8_t*)"j_isrecord",
    (uint8_t*)"j_isarray",
    (uint8_t*)"j_isset",
    (uint8_t*)"j_ispointer",
    (uint8_t*)"j_ismutable",
    (uint8_t*)"j_cvlineno",
    (uint8_t*)"j_cvstrlineno",
    (uint8_t*)"j_cvmodulename",
    (uint8_t*)"j_cvfilename",
    (uint8_t*)"j_cvfunction",
    (uint8_t*)"j_cvdate",
    (uint8_t*)"j_cvtime",
    (uint8_t*)"j_cvversion",
    (uint8_t*)"j_cvtypename",
    (uint8_t*)"j_cvtargetbits",
    (uint8_t*)"j_cvtargetsize",
    (uint8_t*)"j_cvtargetcode",
    (uint8_t*)"j_whenthen",
    (uint8_t*)"j_elsif",
    (uint8_t*)"j_fmtitem",
    (uint8_t*)"j_nogap",
    (uint8_t*)"j_callproc",
    (uint8_t*)"j_callmproc",
    (uint8_t*)"j_return",
    (uint8_t*)"j_syscall",
    (uint8_t*)"j_assign",
    (uint8_t*)"j_shallowcopy",
    (uint8_t*)"j_deepcopy",
    (uint8_t*)"j_to",
    (uint8_t*)"j_if",
    (uint8_t*)"j_longif",
    (uint8_t*)"j_forup",
    (uint8_t*)"j_fordown",
    (uint8_t*)"j_cfor",
    (uint8_t*)"j_while",
    (uint8_t*)"j_repeat",
    (uint8_t*)"j_goto",
    (uint8_t*)"j_gotoblock",
    (uint8_t*)"j_labeldef",
    (uint8_t*)"j_restart",
    (uint8_t*)"j_redo",
    (uint8_t*)"j_next",
    (uint8_t*)"j_exit",
    (uint8_t*)"j_do",
    (uint8_t*)"j_case",
    (uint8_t*)"j_docase",
    (uint8_t*)"j_switch",
    (uint8_t*)"j_doswitch",
    (uint8_t*)"j_swap",
    (uint8_t*)"j_select",
    (uint8_t*)"j_recase",
    (uint8_t*)"j_print",
    (uint8_t*)"j_println",
    (uint8_t*)"j_fprint",
    (uint8_t*)"j_fprintln",
    (uint8_t*)"j_cprint",
    (uint8_t*)"j_cprintln",
    (uint8_t*)"j_sprint",
    (uint8_t*)"j_sfprint",
    (uint8_t*)"j_read",
    (uint8_t*)"j_readln",
    (uint8_t*)"j_sread",
    (uint8_t*)"j_sreadln",
    (uint8_t*)"j_stop",
    (uint8_t*)"j_try",
    (uint8_t*)"j_except",
    (uint8_t*)"j_yield",
    (uint8_t*)"j_raise",
    (uint8_t*)"j_eval",
    (uint8_t*)"j_lambda",
    (uint8_t*)"j_emitc",
    (uint8_t*)"j_mag",
    (uint8_t*)"j_dummy"
};
byte mm_tables_jisexpr[253] = {
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u
};
uint8_t *  mm_tables_fflangnames[6] = {(uint8_t*)"noff",(uint8_t*)"windowsff",(uint8_t*)"clangff",(uint8_t*)"mlangff",(uint8_t*)"callbackff",(uint8_t*)"dummyff"};
uint8_t *  mm_tables_bitfieldnames[8] = {(uint8_t*)"bf_msb",(uint8_t*)"bf_lsb",(uint8_t*)"bf_msbit",(uint8_t*)"bf_lsbit",(uint8_t*)"bf_msw",(uint8_t*)"bf_lsw",(uint8_t*)"bf_odd",(uint8_t*)"bf_even"};
uint8_t *  mm_tables_symbolnames[154] = {
    (uint8_t*)"errorsym",
    (uint8_t*)"dotsym",
    (uint8_t*)"lexdotsym",
    (uint8_t*)"anddotsym",
    (uint8_t*)"commasym",
    (uint8_t*)"semisym",
    (uint8_t*)"colonsym",
    (uint8_t*)"dcolonsym",
    (uint8_t*)"assignsym",
    (uint8_t*)"deepcopysym",
    (uint8_t*)"sendtosym",
    (uint8_t*)"lbracksym",
    (uint8_t*)"rbracksym",
    (uint8_t*)"lsqsym",
    (uint8_t*)"rsqsym",
    (uint8_t*)"lcurlysym",
    (uint8_t*)"rcurlysym",
    (uint8_t*)"ptrsym",
    (uint8_t*)"barsym",
    (uint8_t*)"dbarsym",
    (uint8_t*)"atsym",
    (uint8_t*)"datsym",
    (uint8_t*)"questionsym",
    (uint8_t*)"addrsym",
    (uint8_t*)"daddrsym",
    (uint8_t*)"poundsym",
    (uint8_t*)"curlsym",
    (uint8_t*)"gatesym",
    (uint8_t*)"rangesym",
    (uint8_t*)"ellipsissym",
    (uint8_t*)"hashsym",
    (uint8_t*)"opsym",
    (uint8_t*)"opsym2",
    (uint8_t*)"bitfieldsym",
    (uint8_t*)"eolsym",
    (uint8_t*)"eofsym",
    (uint8_t*)"rawnamesym",
    (uint8_t*)"rawxnamesym",
    (uint8_t*)"docstringsym",
    (uint8_t*)"incrsym",
    (uint8_t*)"intconstsym",
    (uint8_t*)"decimalconstsym",
    (uint8_t*)"realconstsym",
    (uint8_t*)"charconstsym",
    (uint8_t*)"wcharconstsym",
    (uint8_t*)"stringconstsym",
    (uint8_t*)"astringconstsym",
    (uint8_t*)"wstringconstsym",
    (uint8_t*)"unitnamesym",
    (uint8_t*)"namesym",
    (uint8_t*)"ksourcedirsym",
    (uint8_t*)"regsym",
    (uint8_t*)"xregsym",
    (uint8_t*)"fregsym",
    (uint8_t*)"mregsym",
    (uint8_t*)"jmpccsym",
    (uint8_t*)"setccsym",
    (uint8_t*)"movccsym",
    (uint8_t*)"segnamesym",
    (uint8_t*)"asmopcodesym",
    (uint8_t*)"stdtypesym",
    (uint8_t*)"machinetypesym",
    (uint8_t*)"ktypeofsym",
    (uint8_t*)"ksubrangesym",
    (uint8_t*)"koutsym",
    (uint8_t*)"kicharsym",
    (uint8_t*)"kifsym",
    (uint8_t*)"kthensym",
    (uint8_t*)"kelsifsym",
    (uint8_t*)"kelsesym",
    (uint8_t*)"kelsecasesym",
    (uint8_t*)"kelseswitchsym",
    (uint8_t*)"kelseselectsym",
    (uint8_t*)"kendsym",
    (uint8_t*)"kunlesssym",
    (uint8_t*)"kcasesym",
    (uint8_t*)"kdocasesym",
    (uint8_t*)"krecasesym",
    (uint8_t*)"kwhensym",
    (uint8_t*)"kforsym",
    (uint8_t*)"kforallsym",
    (uint8_t*)"kforeachsym",
    (uint8_t*)"ktosym",
    (uint8_t*)"kbysym",
    (uint8_t*)"kdosym",
    (uint8_t*)"kwhilesym",
    (uint8_t*)"krepeatsym",
    (uint8_t*)"kuntilsym",
    (uint8_t*)"kreturnsym",
    (uint8_t*)"kstopsym",
    (uint8_t*)"kloopsym",
    (uint8_t*)"kgotosym",
    (uint8_t*)"kswitchsym",
    (uint8_t*)"kdoswitchsym",
    (uint8_t*)"kprintsym",
    (uint8_t*)"ksprintsym",
    (uint8_t*)"kreadsym",
    (uint8_t*)"ksreadsym",
    (uint8_t*)"ksreadlnsym",
    (uint8_t*)"kprocsym",
    (uint8_t*)"kfunctionsym",
    (uint8_t*)"klabelsym",
    (uint8_t*)"krecordsym",
    (uint8_t*)"kstructsym",
    (uint8_t*)"kunionsym",
    (uint8_t*)"kimportsym",
    (uint8_t*)"kimportmodulesym",
    (uint8_t*)"kimportpathsym",
    (uint8_t*)"kmapmodulesym",
    (uint8_t*)"kmodulesym",
    (uint8_t*)"ktypesym",
    (uint8_t*)"ktypeattrsym",
    (uint8_t*)"krefsym",
    (uint8_t*)"kmutsym",
    (uint8_t*)"kletsym",
    (uint8_t*)"kslicesym",
    (uint8_t*)"karraysym",
    (uint8_t*)"kmacrosym",
    (uint8_t*)"kexpandsym",
    (uint8_t*)"koperatorsym",
    (uint8_t*)"kconstsym",
    (uint8_t*)"klocalssym",
    (uint8_t*)"kenumsym",
    (uint8_t*)"knewsym",
    (uint8_t*)"kclasssym",
    (uint8_t*)"kdoblocksym",
    (uint8_t*)"kblockdefsym",
    (uint8_t*)"kdirectivesym",
    (uint8_t*)"kfflangsym",
    (uint8_t*)"kglobalsym",
    (uint8_t*)"kstaticsym",
    (uint8_t*)"ktrysym",
    (uint8_t*)"kexceptsym",
    (uint8_t*)"kfinallysym",
    (uint8_t*)"kraisesym",
    (uint8_t*)"kyieldsym",
    (uint8_t*)"kextendsym",
    (uint8_t*)"kcastsym",
    (uint8_t*)"ktypeconstsym",
    (uint8_t*)"compilervarsym",
    (uint8_t*)"dollarsym",
    (uint8_t*)"kevalsym",
    (uint8_t*)"ktabledatasym",
    (uint8_t*)"kmapsym",
    (uint8_t*)"kapplyopsym",
    (uint8_t*)"kstacksym",
    (uint8_t*)"kclampsym",
    (uint8_t*)"kswapsym",
    (uint8_t*)"kerrorsym",
    (uint8_t*)"sysconstsym",
    (uint8_t*)"kassemsym",
    (uint8_t*)"kemitcsym",
    (uint8_t*)"ksyscallsym",
    (uint8_t*)"kdummysym"
};
uint8_t *  mm_tables_sourcedirnames[15] = {
    (uint8_t*)"emitcdir",
    (uint8_t*)"ifdir",
    (uint8_t*)"elsifdir",
    (uint8_t*)"elsedir",
    (uint8_t*)"endifdir",
    (uint8_t*)"debuglinedir",
    (uint8_t*)"includedir",
    (uint8_t*)"endincludedir",
    (uint8_t*)"commentdir",
    (uint8_t*)"endcommentdir",
    (uint8_t*)"strincludedir",
    (uint8_t*)"binincludedir",
    (uint8_t*)"cclibdir",
    (uint8_t*)"targetlangdir",
    (uint8_t*)"enddir"
};
uint8_t *  mm_tables_parammodenames[4] = {(uint8_t*)"Var ",(uint8_t*)"In ",(uint8_t*)"Out ",(uint8_t*)"Opt "};
uint8_t *  mm_tables_namecatnames[8] = {(uint8_t*)"-",(uint8_t*)"proc",(uint8_t*)"gproc",(uint8_t*)"dllproc",(uint8_t*)"dllmodule",(uint8_t*)"dllvar",(uint8_t*)"static",(uint8_t*)"frame"};
byte mm_tables_qualifiedname[8] = {(uint8_t)0u,(uint8_t)1u,(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)1u,(uint8_t)1u};
uint8_t *  mm_tables_namenames[21] = {
    (uint8_t*)"nullid",
    (uint8_t*)"programid",
    (uint8_t*)"moduleid",
    (uint8_t*)"dllmoduleid",
    (uint8_t*)"typeid",
    (uint8_t*)"procid",
    (uint8_t*)"dllprocid",
    (uint8_t*)"dllvarid",
    (uint8_t*)"constid",
    (uint8_t*)"staticid",
    (uint8_t*)"frameid",
    (uint8_t*)"paramid",
    (uint8_t*)"fieldid",
    (uint8_t*)"genfieldid",
    (uint8_t*)"enumid",
    (uint8_t*)"labelid",
    (uint8_t*)"blockid",
    (uint8_t*)"aliasid",
    (uint8_t*)"macroid",
    (uint8_t*)"macroparamid",
    (uint8_t*)"linkid"
};
byte mm_tables_defaultnamecat[21] = {
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)4u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)3u,
    (uint8_t)5u,
    (uint8_t)0u,
    (uint8_t)6u,
    (uint8_t)7u,
    (uint8_t)7u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u
};
uint8_t *  mm_tables_stnames[275] = {
    (uint8_t*)"if",
    (uint8_t*)"then",
    (uint8_t*)"elsif",
    (uint8_t*)"else",
    (uint8_t*)"elsecase",
    (uint8_t*)"elseswitch",
    (uint8_t*)"case",
    (uint8_t*)"docase",
    (uint8_t*)"recase",
    (uint8_t*)"when",
    (uint8_t*)"for",
    (uint8_t*)"forall",
    (uint8_t*)"foreach",
    (uint8_t*)"to",
    (uint8_t*)"downto",
    (uint8_t*)"by",
    (uint8_t*)"do",
    (uint8_t*)"end",
    (uint8_t*)"while",
    (uint8_t*)"repeat",
    (uint8_t*)"until",
    (uint8_t*)"always",
    (uint8_t*)"return",
    (uint8_t*)"yield",
    (uint8_t*)"stop",
    (uint8_t*)"restart",
    (uint8_t*)"redo",
    (uint8_t*)"loop",
    (uint8_t*)"next",
    (uint8_t*)"exit",
    (uint8_t*)"goto",
    (uint8_t*)"go",
    (uint8_t*)"switch",
    (uint8_t*)"doswitch",
    (uint8_t*)"tabledata",
    (uint8_t*)"clamp",
    (uint8_t*)"eval",
    (uint8_t*)"print",
    (uint8_t*)"println",
    (uint8_t*)"fprint",
    (uint8_t*)"fprintln",
    (uint8_t*)"cprint",
    (uint8_t*)"cprintln",
    (uint8_t*)"sprint",
    (uint8_t*)"sfprint",
    (uint8_t*)"cp",
    (uint8_t*)"cpl",
    (uint8_t*)"read",
    (uint8_t*)"readln",
    (uint8_t*)"cast",
    (uint8_t*)"proc",
    (uint8_t*)"function",
    (uint8_t*)"threadedproc",
    (uint8_t*)"threadedfunction",
    (uint8_t*)"type",
    (uint8_t*)"class",
    (uint8_t*)"record",
    (uint8_t*)"struct",
    (uint8_t*)"union",
    (uint8_t*)"ref",
    (uint8_t*)"mut",
    (uint8_t*)"var",
    (uint8_t*)"let",
    (uint8_t*)"include",
    (uint8_t*)"strinclude",
    (uint8_t*)"bininclude",
    (uint8_t*)"emitc",
    (uint8_t*)"cclib",
    (uint8_t*)"macro",
    (uint8_t*)"operator",
    (uint8_t*)"assem",
    (uint8_t*)"asm",
    (uint8_t*)"static",
    (uint8_t*)"const",
    (uint8_t*)"enum",
    (uint8_t*)"$get_nprocs",
    (uint8_t*)"$get_procname",
    (uint8_t*)"$get_procaddr",
    (uint8_t*)"$get_nexports",
    (uint8_t*)"$get_procexport",
    (uint8_t*)"$nprocs",
    (uint8_t*)"$nexports",
    (uint8_t*)"$procnames",
    (uint8_t*)"$procaddrs",
    (uint8_t*)"$procexports",
    (uint8_t*)"importdll",
    (uint8_t*)"importlib",
    (uint8_t*)"import",
    (uint8_t*)"importpath",
    (uint8_t*)"mapmodule",
    (uint8_t*)"unless",
    (uint8_t*)"try",
    (uint8_t*)"except",
    (uint8_t*)"finally",
    (uint8_t*)"raise",
    (uint8_t*)"out",
    (uint8_t*)"global",
    (uint8_t*)"export",
    (uint8_t*)"clang",
    (uint8_t*)"mlang",
    (uint8_t*)"windows",
    (uint8_t*)"callback",
    (uint8_t*)"swap",
    (uint8_t*)"void",
    (uint8_t*)"int",
    (uint8_t*)"word",
    (uint8_t*)"real",
    (uint8_t*)"ichar",
    (uint8_t*)"int8",
    (uint8_t*)"int16",
    (uint8_t*)"int32",
    (uint8_t*)"int64",
    (uint8_t*)"int128",
    (uint8_t*)"i8",
    (uint8_t*)"i16",
    (uint8_t*)"i32",
    (uint8_t*)"i64",
    (uint8_t*)"i128",
    (uint8_t*)"real32",
    (uint8_t*)"real64",
    (uint8_t*)"r32",
    (uint8_t*)"r64",
    (uint8_t*)"float32",
    (uint8_t*)"float64",
    (uint8_t*)"byte",
    (uint8_t*)"u1",
    (uint8_t*)"u2",
    (uint8_t*)"u4",
    (uint8_t*)"u8",
    (uint8_t*)"u16",
    (uint8_t*)"u32",
    (uint8_t*)"u64",
    (uint8_t*)"u128",
    (uint8_t*)"word8",
    (uint8_t*)"word16",
    (uint8_t*)"word32",
    (uint8_t*)"word64",
    (uint8_t*)"word128",
    (uint8_t*)"bit",
    (uint8_t*)"bit2",
    (uint8_t*)"bit4",
    (uint8_t*)"char",
    (uint8_t*)"wchar",
    (uint8_t*)"char64",
    (uint8_t*)"array",
    (uint8_t*)"auto",
    (uint8_t*)"variant",
    (uint8_t*)"string",
    (uint8_t*)"decimal",
    (uint8_t*)"intm",
    (uint8_t*)"intp",
    (uint8_t*)"wordm",
    (uint8_t*)"wordp",
    (uint8_t*)"slice",
    (uint8_t*)"typeof",
    (uint8_t*)"subrange",
    (uint8_t*)"million",
    (uint8_t*)"billion",
    (uint8_t*)"thousand",
    (uint8_t*)"kb",
    (uint8_t*)"mb",
    (uint8_t*)"gb",
    (uint8_t*)"$lineno",
    (uint8_t*)"$strlineno",
    (uint8_t*)"$filename",
    (uint8_t*)"$modulename",
    (uint8_t*)"$function",
    (uint8_t*)"$date",
    (uint8_t*)"$time",
    (uint8_t*)"$version",
    (uint8_t*)"$typename",
    (uint8_t*)"$targetbits",
    (uint8_t*)"$targetsize",
    (uint8_t*)"$targetcode",
    (uint8_t*)"$",
    (uint8_t*)"and",
    (uint8_t*)"andb",
    (uint8_t*)"or",
    (uint8_t*)"orb",
    (uint8_t*)"xor",
    (uint8_t*)"iand",
    (uint8_t*)"ior",
    (uint8_t*)"ixor",
    (uint8_t*)"in",
    (uint8_t*)"notin",
    (uint8_t*)"inrev",
    (uint8_t*)"rem",
    (uint8_t*)"divrem",
    (uint8_t*)"min",
    (uint8_t*)"max",
    (uint8_t*)"not",
    (uint8_t*)"inot",
    (uint8_t*)"istrue",
    (uint8_t*)"abs",
    (uint8_t*)"$neg",
    (uint8_t*)"asc",
    (uint8_t*)"tochr",
    (uint8_t*)"sqrt",
    (uint8_t*)"sqr",
    (uint8_t*)"cube",
    (uint8_t*)"cos",
    (uint8_t*)"sin",
    (uint8_t*)"tan",
    (uint8_t*)"asin",
    (uint8_t*)"acos",
    (uint8_t*)"atan",
    (uint8_t*)"atan2",
    (uint8_t*)"sign",
    (uint8_t*)"ln",
    (uint8_t*)"log",
    (uint8_t*)"lg",
    (uint8_t*)"exp",
    (uint8_t*)"round",
    (uint8_t*)"floor",
    (uint8_t*)"ceil",
    (uint8_t*)"fract",
    (uint8_t*)"fmod",
    (uint8_t*)"insert",
    (uint8_t*)"delete",
    (uint8_t*)"prepend",
    (uint8_t*)"append",
    (uint8_t*)"concat",
    (uint8_t*)"convlc",
    (uint8_t*)"convuc",
    (uint8_t*)"flexptr",
    (uint8_t*)"sliceptr",
    (uint8_t*)"stringz",
    (uint8_t*)"len",
    (uint8_t*)"lwb",
    (uint8_t*)"upb",
    (uint8_t*)"bounds",
    (uint8_t*)"lenstr",
    (uint8_t*)"bitwidth",
    (uint8_t*)"bytes",
    (uint8_t*)"minvalue",
    (uint8_t*)"maxvalue",
    (uint8_t*)"typestr",
    (uint8_t*)"isvoid",
    (uint8_t*)"isdef",
    (uint8_t*)"isint",
    (uint8_t*)"msb",
    (uint8_t*)"lsb",
    (uint8_t*)"msbit",
    (uint8_t*)"lsbit",
    (uint8_t*)"msw",
    (uint8_t*)"lsw",
    (uint8_t*)"odd",
    (uint8_t*)"even",
    (uint8_t*)"endif",
    (uint8_t*)"fi",
    (uint8_t*)"endcase",
    (uint8_t*)"esac",
    (uint8_t*)"enddocase",
    (uint8_t*)"endswitch",
    (uint8_t*)"enddoswitch",
    (uint8_t*)"endfor",
    (uint8_t*)"endforall",
    (uint8_t*)"od",
    (uint8_t*)"endproc",
    (uint8_t*)"endfunction",
    (uint8_t*)"endwhile",
    (uint8_t*)"endto",
    (uint8_t*)"enddo",
    (uint8_t*)"endunless",
    (uint8_t*)"endmodule",
    (uint8_t*)"endimportmodule",
    (uint8_t*)"endtry",
    (uint8_t*)"endrecord",
    (uint8_t*)"endclass",
    (uint8_t*)"endassem",
    (uint8_t*)"$caligned",
    (uint8_t*)"nil",
    (uint8_t*)"con",
    (uint8_t*)"pi",
    (uint8_t*)"$$dummy"
};
int64_t mm_tables_stsymbols[275] = {
    (int64_t)67,
    (int64_t)68,
    (int64_t)69,
    (int64_t)70,
    (int64_t)71,
    (int64_t)72,
    (int64_t)76,
    (int64_t)77,
    (int64_t)78,
    (int64_t)79,
    (int64_t)80,
    (int64_t)81,
    (int64_t)82,
    (int64_t)83,
    (int64_t)83,
    (int64_t)84,
    (int64_t)85,
    (int64_t)74,
    (int64_t)86,
    (int64_t)87,
    (int64_t)88,
    (int64_t)88,
    (int64_t)89,
    (int64_t)136,
    (int64_t)90,
    (int64_t)91,
    (int64_t)91,
    (int64_t)91,
    (int64_t)91,
    (int64_t)91,
    (int64_t)92,
    (int64_t)92,
    (int64_t)93,
    (int64_t)94,
    (int64_t)143,
    (int64_t)147,
    (int64_t)142,
    (int64_t)95,
    (int64_t)95,
    (int64_t)95,
    (int64_t)95,
    (int64_t)95,
    (int64_t)95,
    (int64_t)96,
    (int64_t)96,
    (int64_t)95,
    (int64_t)95,
    (int64_t)97,
    (int64_t)97,
    (int64_t)138,
    (int64_t)100,
    (int64_t)101,
    (int64_t)100,
    (int64_t)101,
    (int64_t)111,
    (int64_t)125,
    (int64_t)103,
    (int64_t)104,
    (int64_t)105,
    (int64_t)113,
    (int64_t)114,
    (int64_t)114,
    (int64_t)115,
    (int64_t)51,
    (int64_t)51,
    (int64_t)51,
    (int64_t)51,
    (int64_t)51,
    (int64_t)118,
    (int64_t)120,
    (int64_t)151,
    (int64_t)151,
    (int64_t)131,
    (int64_t)121,
    (int64_t)123,
    (int64_t)153,
    (int64_t)153,
    (int64_t)153,
    (int64_t)153,
    (int64_t)153,
    (int64_t)153,
    (int64_t)153,
    (int64_t)153,
    (int64_t)153,
    (int64_t)153,
    (int64_t)107,
    (int64_t)107,
    (int64_t)106,
    (int64_t)108,
    (int64_t)109,
    (int64_t)75,
    (int64_t)132,
    (int64_t)133,
    (int64_t)134,
    (int64_t)135,
    (int64_t)65,
    (int64_t)130,
    (int64_t)130,
    (int64_t)129,
    (int64_t)129,
    (int64_t)129,
    (int64_t)129,
    (int64_t)148,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)66,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)117,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)61,
    (int64_t)62,
    (int64_t)62,
    (int64_t)62,
    (int64_t)62,
    (int64_t)116,
    (int64_t)63,
    (int64_t)64,
    (int64_t)49,
    (int64_t)49,
    (int64_t)49,
    (int64_t)49,
    (int64_t)49,
    (int64_t)49,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)140,
    (int64_t)141,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)32,
    (int64_t)33,
    (int64_t)32,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)34,
    (int64_t)34,
    (int64_t)34,
    (int64_t)34,
    (int64_t)34,
    (int64_t)34,
    (int64_t)34,
    (int64_t)34,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)74,
    (int64_t)21,
    (int64_t)150,
    (int64_t)150,
    (int64_t)150,
    (int64_t)0
};
int64_t mm_tables_stsubcodes[275] = {
    (int64_t)209,
    (int64_t)0,
    (int64_t)209,
    (int64_t)0,
    (int64_t)224,
    (int64_t)226,
    (int64_t)224,
    (int64_t)225,
    (int64_t)230,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)219,
    (int64_t)220,
    (int64_t)220,
    (int64_t)221,
    (int64_t)222,
    (int64_t)0,
    (int64_t)1,
    (int64_t)226,
    (int64_t)227,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)231,
    (int64_t)232,
    (int64_t)233,
    (int64_t)234,
    (int64_t)235,
    (int64_t)236,
    (int64_t)237,
    (int64_t)238,
    (int64_t)231,
    (int64_t)232,
    (int64_t)239,
    (int64_t)240,
    (int64_t)102,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)7,
    (int64_t)11,
    (int64_t)12,
    (int64_t)1,
    (int64_t)13,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)46,
    (int64_t)48,
    (int64_t)49,
    (int64_t)47,
    (int64_t)50,
    (int64_t)51,
    (int64_t)52,
    (int64_t)53,
    (int64_t)54,
    (int64_t)55,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)2,
    (int64_t)2,
    (int64_t)3,
    (int64_t)1,
    (int64_t)4,
    (int64_t)0,
    (int64_t)0,
    (int64_t)4,
    (int64_t)9,
    (int64_t)12,
    (int64_t)0,
    (int64_t)1,
    (int64_t)2,
    (int64_t)3,
    (int64_t)4,
    (int64_t)5,
    (int64_t)1,
    (int64_t)2,
    (int64_t)3,
    (int64_t)4,
    (int64_t)5,
    (int64_t)11,
    (int64_t)12,
    (int64_t)11,
    (int64_t)12,
    (int64_t)11,
    (int64_t)12,
    (int64_t)6,
    (int64_t)16,
    (int64_t)17,
    (int64_t)18,
    (int64_t)6,
    (int64_t)7,
    (int64_t)8,
    (int64_t)9,
    (int64_t)10,
    (int64_t)6,
    (int64_t)7,
    (int64_t)8,
    (int64_t)9,
    (int64_t)10,
    (int64_t)16,
    (int64_t)17,
    (int64_t)18,
    (int64_t)13,
    (int64_t)14,
    (int64_t)15,
    (int64_t)0,
    (int64_t)34,
    (int64_t)33,
    (int64_t)33,
    (int64_t)33,
    (int64_t)73,
    (int64_t)105,
    (int64_t)87,
    (int64_t)119,
    (int64_t)23,
    (int64_t)0,
    (int64_t)0,
    (int64_t)2,
    (int64_t)3,
    (int64_t)1,
    (int64_t)4,
    (int64_t)5,
    (int64_t)6,
    (int64_t)185,
    (int64_t)186,
    (int64_t)188,
    (int64_t)187,
    (int64_t)189,
    (int64_t)190,
    (int64_t)191,
    (int64_t)192,
    (int64_t)193,
    (int64_t)194,
    (int64_t)195,
    (int64_t)196,
    (int64_t)0,
    (int64_t)12,
    (int64_t)17,
    (int64_t)13,
    (int64_t)18,
    (int64_t)14,
    (int64_t)50,
    (int64_t)51,
    (int64_t)52,
    (int64_t)55,
    (int64_t)56,
    (int64_t)57,
    (int64_t)48,
    (int64_t)49,
    (int64_t)60,
    (int64_t)61,
    (int64_t)15,
    (int64_t)111,
    (int64_t)16,
    (int64_t)110,
    (int64_t)109,
    (int64_t)113,
    (int64_t)112,
    (int64_t)114,
    (int64_t)115,
    (int64_t)116,
    (int64_t)119,
    (int64_t)118,
    (int64_t)120,
    (int64_t)121,
    (int64_t)122,
    (int64_t)123,
    (int64_t)97,
    (int64_t)117,
    (int64_t)124,
    (int64_t)126,
    (int64_t)125,
    (int64_t)127,
    (int64_t)128,
    (int64_t)129,
    (int64_t)130,
    (int64_t)131,
    (int64_t)132,
    (int64_t)79,
    (int64_t)80,
    (int64_t)81,
    (int64_t)66,
    (int64_t)65,
    (int64_t)83,
    (int64_t)84,
    (int64_t)85,
    (int64_t)87,
    (int64_t)86,
    (int64_t)135,
    (int64_t)133,
    (int64_t)134,
    (int64_t)136,
    (int64_t)137,
    (int64_t)138,
    (int64_t)139,
    (int64_t)143,
    (int64_t)144,
    (int64_t)141,
    (int64_t)174,
    (int64_t)175,
    (int64_t)176,
    (int64_t)1,
    (int64_t)2,
    (int64_t)3,
    (int64_t)4,
    (int64_t)5,
    (int64_t)6,
    (int64_t)7,
    (int64_t)8,
    (int64_t)67,
    (int64_t)67,
    (int64_t)76,
    (int64_t)76,
    (int64_t)77,
    (int64_t)93,
    (int64_t)94,
    (int64_t)80,
    (int64_t)81,
    (int64_t)85,
    (int64_t)100,
    (int64_t)101,
    (int64_t)86,
    (int64_t)83,
    (int64_t)85,
    (int64_t)75,
    (int64_t)110,
    (int64_t)107,
    (int64_t)132,
    (int64_t)103,
    (int64_t)125,
    (int64_t)151,
    (int64_t)1,
    (int64_t)1,
    (int64_t)4,
    (int64_t)2,
    (int64_t)0
};
int64_t mm_tables_oplist[39] = {
    (int64_t)43,
    (int64_t)44,
    (int64_t)45,
    (int64_t)46,
    (int64_t)47,
    (int64_t)48,
    (int64_t)49,
    (int64_t)12,
    (int64_t)13,
    (int64_t)14,
    (int64_t)50,
    (int64_t)17,
    (int64_t)51,
    (int64_t)18,
    (int64_t)52,
    (int64_t)53,
    (int64_t)54,
    (int64_t)55,
    (int64_t)56,
    (int64_t)57,
    (int64_t)36,
    (int64_t)37,
    (int64_t)38,
    (int64_t)41,
    (int64_t)39,
    (int64_t)40,
    (int64_t)42,
    (int64_t)60,
    (int64_t)61,
    (int64_t)98,
    (int64_t)97,
    (int64_t)63,
    (int64_t)64,
    (int64_t)62,
    (int64_t)65,
    (int64_t)66,
    (int64_t)29,
    (int64_t)30,
    (int64_t)20
};
int64_t mm_tables_oppriolist[39] = {
    (int64_t)4,
    (int64_t)4,
    (int64_t)3,
    (int64_t)3,
    (int64_t)3,
    (int64_t)3,
    (int64_t)3,
    (int64_t)7,
    (int64_t)8,
    (int64_t)6,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)3,
    (int64_t)3,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)4,
    (int64_t)4,
    (int64_t)2,
    (int64_t)3,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)1,
    (int64_t)1,
    (int64_t)5
};
byte mm_tables_jtagpriotable[253];
uint8_t *  mm_tables_convnames[33] = {
    (uint8_t*)"c_none",
    (uint8_t*)"c_soft",
    (uint8_t*)"c_hard",
    (uint8_t*)"c_bool",
    (uint8_t*)"c_iwiden",
    (uint8_t*)"c_uwiden",
    (uint8_t*)"c_ifloat",
    (uint8_t*)"c_ufloat",
    (uint8_t*)"c_ifix",
    (uint8_t*)"c_ufix",
    (uint8_t*)"c_diwiden",
    (uint8_t*)"c_duwiden",
    (uint8_t*)"c_difloat",
    (uint8_t*)"c_dufloat",
    (uint8_t*)"c_difix",
    (uint8_t*)"c_dufix",
    (uint8_t*)"c_dfnarrow",
    (uint8_t*)"c_dfwiden",
    (uint8_t*)"c_narrow",
    (uint8_t*)"c_softtruncate",
    (uint8_t*)"c_truncate",
    (uint8_t*)"c_fnarrow",
    (uint8_t*)"c_fwiden",
    (uint8_t*)"c_inttoref",
    (uint8_t*)"c_reftoint",
    (uint8_t*)"c_reftoref",
    (uint8_t*)"c_anytovar",
    (uint8_t*)"c_anytodecimal",
    (uint8_t*)"c_ichartostring",
    (uint8_t*)"c_vartoany",
    (uint8_t*)"c_decimaltoany",
    (uint8_t*)"c_stringtoichar",
    (uint8_t*)"c_error"
};
byte mm_tables_dominantmode[32][32];
byte mm_tables_conversionops[32][32];
byte mm_tables_typesetuptable[56][4] = {
    {(uint8_t)4u,(uint8_t)4u,(uint8_t)4u,(uint8_t)0u},
    {(uint8_t)4u,(uint8_t)5u,(uint8_t)5u,(uint8_t)4u},
    {(uint8_t)4u,(uint8_t)9u,(uint8_t)4u,(uint8_t)1u},
    {(uint8_t)4u,(uint8_t)10u,(uint8_t)5u,(uint8_t)5u},
    {(uint8_t)4u,(uint8_t)15u,(uint8_t)4u,(uint8_t)19u},
    {(uint8_t)4u,(uint8_t)11u,(uint8_t)12u,(uint8_t)6u},
    {(uint8_t)4u,(uint8_t)12u,(uint8_t)12u,(uint8_t)6u},
    {(uint8_t)4u,(uint8_t)19u,(uint8_t)0u,(uint8_t)23u},
    {(uint8_t)5u,(uint8_t)4u,(uint8_t)5u,(uint8_t)19u},
    {(uint8_t)5u,(uint8_t)5u,(uint8_t)5u,(uint8_t)0u},
    {(uint8_t)5u,(uint8_t)9u,(uint8_t)5u,(uint8_t)1u},
    {(uint8_t)5u,(uint8_t)10u,(uint8_t)5u,(uint8_t)1u},
    {(uint8_t)5u,(uint8_t)15u,(uint8_t)5u,(uint8_t)19u},
    {(uint8_t)5u,(uint8_t)19u,(uint8_t)0u,(uint8_t)23u},
    {(uint8_t)9u,(uint8_t)4u,(uint8_t)4u,(uint8_t)1u},
    {(uint8_t)9u,(uint8_t)5u,(uint8_t)5u,(uint8_t)5u},
    {(uint8_t)9u,(uint8_t)9u,(uint8_t)9u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)10u,(uint8_t)10u,(uint8_t)5u},
    {(uint8_t)9u,(uint8_t)15u,(uint8_t)9u,(uint8_t)19u},
    {(uint8_t)9u,(uint8_t)11u,(uint8_t)12u,(uint8_t)7u},
    {(uint8_t)9u,(uint8_t)12u,(uint8_t)12u,(uint8_t)7u},
    {(uint8_t)9u,(uint8_t)19u,(uint8_t)0u,(uint8_t)23u},
    {(uint8_t)10u,(uint8_t)4u,(uint8_t)5u,(uint8_t)1u},
    {(uint8_t)10u,(uint8_t)5u,(uint8_t)5u,(uint8_t)1u},
    {(uint8_t)10u,(uint8_t)9u,(uint8_t)10u,(uint8_t)0u},
    {(uint8_t)10u,(uint8_t)10u,(uint8_t)10u,(uint8_t)0u},
    {(uint8_t)10u,(uint8_t)15u,(uint8_t)10u,(uint8_t)19u},
    {(uint8_t)10u,(uint8_t)19u,(uint8_t)0u,(uint8_t)23u},
    {(uint8_t)15u,(uint8_t)4u,(uint8_t)4u,(uint8_t)1u},
    {(uint8_t)15u,(uint8_t)5u,(uint8_t)5u,(uint8_t)5u},
    {(uint8_t)15u,(uint8_t)9u,(uint8_t)9u,(uint8_t)1u},
    {(uint8_t)15u,(uint8_t)10u,(uint8_t)10u,(uint8_t)5u},
    {(uint8_t)15u,(uint8_t)15u,(uint8_t)15u,(uint8_t)0u},
    {(uint8_t)15u,(uint8_t)11u,(uint8_t)12u,(uint8_t)7u},
    {(uint8_t)15u,(uint8_t)12u,(uint8_t)12u,(uint8_t)7u},
    {(uint8_t)15u,(uint8_t)19u,(uint8_t)0u,(uint8_t)23u},
    {(uint8_t)11u,(uint8_t)4u,(uint8_t)11u,(uint8_t)8u},
    {(uint8_t)11u,(uint8_t)5u,(uint8_t)11u,(uint8_t)8u},
    {(uint8_t)11u,(uint8_t)9u,(uint8_t)11u,(uint8_t)9u},
    {(uint8_t)11u,(uint8_t)15u,(uint8_t)11u,(uint8_t)9u},
    {(uint8_t)11u,(uint8_t)11u,(uint8_t)11u,(uint8_t)0u},
    {(uint8_t)11u,(uint8_t)12u,(uint8_t)12u,(uint8_t)22u},
    {(uint8_t)11u,(uint8_t)19u,(uint8_t)0u,(uint8_t)32u},
    {(uint8_t)12u,(uint8_t)4u,(uint8_t)12u,(uint8_t)8u},
    {(uint8_t)12u,(uint8_t)9u,(uint8_t)12u,(uint8_t)9u},
    {(uint8_t)12u,(uint8_t)15u,(uint8_t)12u,(uint8_t)9u},
    {(uint8_t)12u,(uint8_t)11u,(uint8_t)12u,(uint8_t)21u},
    {(uint8_t)12u,(uint8_t)12u,(uint8_t)12u,(uint8_t)0u},
    {(uint8_t)12u,(uint8_t)19u,(uint8_t)0u,(uint8_t)32u},
    {(uint8_t)19u,(uint8_t)4u,(uint8_t)0u,(uint8_t)24u},
    {(uint8_t)19u,(uint8_t)5u,(uint8_t)0u,(uint8_t)32u},
    {(uint8_t)19u,(uint8_t)9u,(uint8_t)0u,(uint8_t)24u},
    {(uint8_t)19u,(uint8_t)10u,(uint8_t)0u,(uint8_t)32u},
    {(uint8_t)19u,(uint8_t)11u,(uint8_t)0u,(uint8_t)32u},
    {(uint8_t)19u,(uint8_t)12u,(uint8_t)0u,(uint8_t)32u},
    {(uint8_t)19u,(uint8_t)19u,(uint8_t)19u,(uint8_t)25u}
};
int64_t mm_tables_d_exprstarterset[31] = {
    (int64_t)12,
    (int64_t)14,
    (int64_t)18,
    (int64_t)24,
    (int64_t)32,
    (int64_t)50,
    (int64_t)40,
    (int64_t)41,
    (int64_t)42,
    (int64_t)43,
    (int64_t)44,
    (int64_t)46,
    (int64_t)61,
    (int64_t)96,
    (int64_t)98,
    (int64_t)99,
    (int64_t)124,
    (int64_t)141,
    (int64_t)140,
    (int64_t)147,
    (int64_t)145,
    (int64_t)149,
    (int64_t)113,
    (int64_t)138,
    (int64_t)4,
    (int64_t)47,
    (int64_t)63,
    (int64_t)67,
    (int64_t)153,
    (int64_t)33,
    (int64_t)27
};
int64_t mm_tables_d_typestarterset[9] = {(int64_t)61,(int64_t)14,(int64_t)113,(int64_t)123,(int64_t)103,(int64_t)66,(int64_t)63,(int64_t)116,(int64_t)117};
byte mm_tables_exprtermset[155];
byte mm_tables_condopset[253];
byte mm_tables_d_boolunitset[15] = {
    (uint8_t)36u,
    (uint8_t)37u,
    (uint8_t)38u,
    (uint8_t)39u,
    (uint8_t)41u,
    (uint8_t)40u,
    (uint8_t)17u,
    (uint8_t)18u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)14u,
    (uint8_t)58u,
    (uint8_t)59u
};
byte mm_tables_boolunitset[253];
byte mm_tables_d_refunitset[14] = {
    (uint8_t)3u,
    (uint8_t)95u,
    (uint8_t)88u,
    (uint8_t)209u,
    (uint8_t)229u,
    (uint8_t)210u,
    (uint8_t)24u,
    (uint8_t)100u,
    (uint8_t)99u,
    (uint8_t)25u,
    (uint8_t)90u,
    (uint8_t)91u,
    (uint8_t)142u,
    (uint8_t)89u
};
byte mm_tables_refunitset[253];
byte mm_tables_d_binopset[32] = {
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)36u,
    (uint8_t)37u,
    (uint8_t)38u,
    (uint8_t)39u,
    (uint8_t)40u,
    (uint8_t)41u,
    (uint8_t)43u,
    (uint8_t)44u,
    (uint8_t)45u,
    (uint8_t)46u,
    (uint8_t)47u,
    (uint8_t)48u,
    (uint8_t)50u,
    (uint8_t)51u,
    (uint8_t)52u,
    (uint8_t)53u,
    (uint8_t)54u,
    (uint8_t)60u,
    (uint8_t)61u,
    (uint8_t)17u,
    (uint8_t)18u,
    (uint8_t)62u,
    (uint8_t)63u,
    (uint8_t)64u,
    (uint8_t)65u,
    (uint8_t)98u,
    (uint8_t)14u,
    (uint8_t)49u,
    (uint8_t)97u,
    (uint8_t)132u
};
byte mm_tables_binopset[253];
byte mm_tables_d_monopset[31] = {
    (uint8_t)109u,
    (uint8_t)110u,
    (uint8_t)111u,
    (uint8_t)115u,
    (uint8_t)116u,
    (uint8_t)117u,
    (uint8_t)118u,
    (uint8_t)119u,
    (uint8_t)120u,
    (uint8_t)121u,
    (uint8_t)122u,
    (uint8_t)123u,
    (uint8_t)124u,
    (uint8_t)125u,
    (uint8_t)126u,
    (uint8_t)127u,
    (uint8_t)128u,
    (uint8_t)129u,
    (uint8_t)130u,
    (uint8_t)131u,
    (uint8_t)133u,
    (uint8_t)134u,
    (uint8_t)135u,
    (uint8_t)136u,
    (uint8_t)87u,
    (uint8_t)138u,
    (uint8_t)139u,
    (uint8_t)143u,
    (uint8_t)144u,
    (uint8_t)15u,
    (uint8_t)16u
};
byte mm_tables_monopset[253];
uint8_t *  mm_tables_sysfnnames[181] = {
    (uint8_t*)"sysfn_pushcallback",
    (uint8_t*)"sysfn_popcallback",
    (uint8_t*)"sysfn_mul_i128",
    (uint8_t*)"sysfn_idiv_i128",
    (uint8_t*)"sysfn_dotindex",
    (uint8_t*)"sysfn_dotslice",
    (uint8_t*)"sysfn_popdotindex",
    (uint8_t*)"sysfn_popdotslice",
    (uint8_t*)"sysfn_power_i64",
    (uint8_t*)"sysfn_callff_4",
    (uint8_t*)"sysfn_callff_5",
    (uint8_t*)"sysfn_callff_6",
    (uint8_t*)"sysfn_callff_7",
    (uint8_t*)"sysfn_callff_8",
    (uint8_t*)"sysfn_callff_9",
    (uint8_t*)"sysfn_callff_10",
    (uint8_t*)"sysfn_callff_11",
    (uint8_t*)"sysfn_callff_12",
    (uint8_t*)"sysfn_callff_13",
    (uint8_t*)"sysfn_callff_14",
    (uint8_t*)"sysfn_init",
    (uint8_t*)"sysfn_stop",
    (uint8_t*)"sysfn_print_startfile",
    (uint8_t*)"sysfn_print_startstr",
    (uint8_t*)"sysfn_print_startptr",
    (uint8_t*)"sysfn_print_startcon",
    (uint8_t*)"sysfn_print_setfmt",
    (uint8_t*)"sysfn_print_nogap",
    (uint8_t*)"sysfn_print_i64",
    (uint8_t*)"sysfn_print_u64",
    (uint8_t*)"sysfn_print_r64",
    (uint8_t*)"sysfn_print_i128",
    (uint8_t*)"sysfn_print_u128",
    (uint8_t*)"sysfn_print_str",
    (uint8_t*)"sysfn_print_strsl",
    (uint8_t*)"sysfn_print_ptr",
    (uint8_t*)"sysfn_print_c8",
    (uint8_t*)"sysfn_print_newline",
    (uint8_t*)"sysfn_print_end",
    (uint8_t*)"sysfn_read_i64",
    (uint8_t*)"sysfn_read_r64",
    (uint8_t*)"sysfn_read_str",
    (uint8_t*)"sysfn_read_fileline",
    (uint8_t*)"sysfn_read_strline",
    (uint8_t*)"sysfn_read_conline",
    (uint8_t*)"sysfn_get_nprocs",
    (uint8_t*)"sysfn_get_nexports",
    (uint8_t*)"sysfn_get_procname",
    (uint8_t*)"sysfn_get_procaddr",
    (uint8_t*)"sysfn_get_procexport",
    (uint8_t*)"sysfn_nprocs",
    (uint8_t*)"sysfn_nexports",
    (uint8_t*)"sysfn_procnames",
    (uint8_t*)"sysfn_procaddrs",
    (uint8_t*)"sysfn_procexports",
    (uint8_t*)"sysfn_sin",
    (uint8_t*)"sysfn_cos",
    (uint8_t*)"sysfn_tan",
    (uint8_t*)"sysfn_asin",
    (uint8_t*)"sysfn_acos",
    (uint8_t*)"sysfn_atan",
    (uint8_t*)"sysfn_ln",
    (uint8_t*)"sysfn_lg",
    (uint8_t*)"sysfn_log",
    (uint8_t*)"sysfn_exp",
    (uint8_t*)"sysfn_floor",
    (uint8_t*)"sysfn_ceil",
    (uint8_t*)"sysfn_fract",
    (uint8_t*)"sysfn_round",
    (uint8_t*)"sysfn_lenstr_stringz",
    (uint8_t*)"sysfn_initmemz_var",
    (uint8_t*)"sysfn_freemem_var",
    (uint8_t*)"sysfn_free_var",
    (uint8_t*)"sysfn_share_var",
    (uint8_t*)"sysfn_unshare_var",
    (uint8_t*)"sysfn_dupl_var",
    (uint8_t*)"sysfn_popmem_var",
    (uint8_t*)"sysfn_storemem_var",
    (uint8_t*)"sysfn_add_var",
    (uint8_t*)"sysfn_sub_var",
    (uint8_t*)"sysfn_mul_var",
    (uint8_t*)"sysfn_div_var",
    (uint8_t*)"sysfn_idiv_var",
    (uint8_t*)"sysfn_irem_var",
    (uint8_t*)"sysfn_power_var",
    (uint8_t*)"sysfn_eq_var",
    (uint8_t*)"sysfn_ne_var",
    (uint8_t*)"sysfn_lt_var",
    (uint8_t*)"sysfn_le_var",
    (uint8_t*)"sysfn_ge_var",
    (uint8_t*)"sysfn_gt_var",
    (uint8_t*)"sysfn_isequal_var",
    (uint8_t*)"sysfn_iand_var",
    (uint8_t*)"sysfn_ior_var",
    (uint8_t*)"sysfn_ixor_var",
    (uint8_t*)"sysfn_shl_var",
    (uint8_t*)"sysfn_shr_var",
    (uint8_t*)"sysfn_andl_var",
    (uint8_t*)"sysfn_orl_var",
    (uint8_t*)"sysfn_append_var",
    (uint8_t*)"sysfn_concat_var",
    (uint8_t*)"sysfn_min_var",
    (uint8_t*)"sysfn_max_var",
    (uint8_t*)"sysfn_in_var",
    (uint8_t*)"sysfn_neg_var",
    (uint8_t*)"sysfn_abs_var",
    (uint8_t*)"sysfn_inot_var",
    (uint8_t*)"sysfn_notl_var",
    (uint8_t*)"sysfn_istruel_var",
    (uint8_t*)"sysfn_sqrt_var",
    (uint8_t*)"sysfn_sin_var",
    (uint8_t*)"sysfn_cos_var",
    (uint8_t*)"sysfn_tan_var",
    (uint8_t*)"sysfn_asin_var",
    (uint8_t*)"sysfn_acos_var",
    (uint8_t*)"sysfn_atan_var",
    (uint8_t*)"sysfn_exp_var",
    (uint8_t*)"sysfn_ln_var",
    (uint8_t*)"sysfn_log_var",
    (uint8_t*)"sysfn_round_var",
    (uint8_t*)"sysfn_floor_var",
    (uint8_t*)"sysfn_ceil_var",
    (uint8_t*)"sysfn_fract_var",
    (uint8_t*)"sysfn_asc_var",
    (uint8_t*)"sysfn_chr_var",
    (uint8_t*)"sysfn_lwb_var",
    (uint8_t*)"sysfn_upb_var",
    (uint8_t*)"sysfn_len_var",
    (uint8_t*)"sysfn_bounds_var",
    (uint8_t*)"sysfn_addto_var",
    (uint8_t*)"sysfn_subto_var",
    (uint8_t*)"sysfn_multo_var",
    (uint8_t*)"sysfn_divto_var",
    (uint8_t*)"sysfn_idivto_var",
    (uint8_t*)"sysfn_iremto_var",
    (uint8_t*)"sysfn_iandto_var",
    (uint8_t*)"sysfn_iorto_var",
    (uint8_t*)"sysfn_ixorto_var",
    (uint8_t*)"sysfn_shlto_var",
    (uint8_t*)"sysfn_shrto_var",
    (uint8_t*)"sysfn_andto_var",
    (uint8_t*)"sysfn_orto_var",
    (uint8_t*)"sysfn_appendto_var",
    (uint8_t*)"sysfn_concatto_var",
    (uint8_t*)"sysfn_minto_var",
    (uint8_t*)"sysfn_maxto_var",
    (uint8_t*)"sysfn_negto_var",
    (uint8_t*)"sysfn_absto_var",
    (uint8_t*)"sysfn_inotto_var",
    (uint8_t*)"sysfn_notlto_var",
    (uint8_t*)"sysfn_incrto_var",
    (uint8_t*)"sysfn_decrto_var",
    (uint8_t*)"sysfn_new_var",
    (uint8_t*)"sysfn_print_var",
    (uint8_t*)"sysfn_tostr_var",
    (uint8_t*)"sysfn_getdot_var",
    (uint8_t*)"sysfn_putdot_var",
    (uint8_t*)"sysfn_getindex_var",
    (uint8_t*)"sysfn_putindex_var",
    (uint8_t*)"sysfn_getdotindex_var",
    (uint8_t*)"sysfn_putdotindex_var",
    (uint8_t*)"sysfn_getslice_var",
    (uint8_t*)"sysfn_putslice_var",
    (uint8_t*)"sysfn_getdotslice_var",
    (uint8_t*)"sysfn_putdotslice_var",
    (uint8_t*)"sysfn_getkeyindex_var",
    (uint8_t*)"sysfn_putkeyindex_var",
    (uint8_t*)"sysfn_insert_var",
    (uint8_t*)"sysfn_delete_var",
    (uint8_t*)"sysfn_resize_var",
    (uint8_t*)"sysfn_make_int",
    (uint8_t*)"sysfn_make_real",
    (uint8_t*)"sysfn_make_string",
    (uint8_t*)"sysfn_make_dec",
    (uint8_t*)"sysfn_make_list",
    (uint8_t*)"sysfn_make_listz",
    (uint8_t*)"sysfn_make_array",
    (uint8_t*)"sysfn_make_range",
    (uint8_t*)"sysfn_var_to_int",
    (uint8_t*)"sysfn_var_to_real",
    (uint8_t*)"sysfn_var_to_string"
};
uint8_t *  mm_mcldecls_opndnames_ma[6] = {(uint8_t*)"a_none",(uint8_t*)"a_reg",(uint8_t*)"a_imm",(uint8_t*)"a_mem",(uint8_t*)"a_cond",(uint8_t*)"a_xreg"};
uint8_t *  mm_mcldecls_valtypenames[9] = {(uint8_t*)"no_val",(uint8_t*)"intimm_val",(uint8_t*)"realimm_val",(uint8_t*)"realmem_val",(uint8_t*)"stringimm_val",(uint8_t*)"def_val",(uint8_t*)"label_val",(uint8_t*)"name_val",(uint8_t*)"syscall_val"};
uint8_t *  mm_mcldecls_mclnames[143] = {
    (uint8_t*)"m_comment",
    (uint8_t*)"m_blank",
    (uint8_t*)"m_labelname",
    (uint8_t*)"m_define",
    (uint8_t*)"m_label",
    (uint8_t*)"m_nop",
    (uint8_t*)"m_param",
    (uint8_t*)"m_mov",
    (uint8_t*)"m_push",
    (uint8_t*)"m_pop",
    (uint8_t*)"m_lea",
    (uint8_t*)"m_cmovcc",
    (uint8_t*)"m_movd",
    (uint8_t*)"m_movq",
    (uint8_t*)"m_movsx",
    (uint8_t*)"m_movzx",
    (uint8_t*)"m_movsxd",
    (uint8_t*)"m_call",
    (uint8_t*)"m_ret",
    (uint8_t*)"m_retn",
    (uint8_t*)"m_jmp",
    (uint8_t*)"m_jmpcc",
    (uint8_t*)"m_xchg",
    (uint8_t*)"m_add",
    (uint8_t*)"m_sub",
    (uint8_t*)"m_adc",
    (uint8_t*)"m_sbb",
    (uint8_t*)"m_imul",
    (uint8_t*)"m_mul",
    (uint8_t*)"m_imul2",
    (uint8_t*)"m_imul3",
    (uint8_t*)"m_idiv",
    (uint8_t*)"m_div",
    (uint8_t*)"m_andx",
    (uint8_t*)"m_orx",
    (uint8_t*)"m_xorx",
    (uint8_t*)"m_test",
    (uint8_t*)"m_cmp",
    (uint8_t*)"m_shl",
    (uint8_t*)"m_sar",
    (uint8_t*)"m_shr",
    (uint8_t*)"m_rol",
    (uint8_t*)"m_ror",
    (uint8_t*)"m_rcl",
    (uint8_t*)"m_rcr",
    (uint8_t*)"m_neg",
    (uint8_t*)"m_notx",
    (uint8_t*)"m_inc",
    (uint8_t*)"m_dec",
    (uint8_t*)"m_cbw",
    (uint8_t*)"m_cwd",
    (uint8_t*)"m_cdq",
    (uint8_t*)"m_cqo",
    (uint8_t*)"m_setcc",
    (uint8_t*)"m_bsf",
    (uint8_t*)"m_bsr",
    (uint8_t*)"m_sqrtsd",
    (uint8_t*)"m_sqrtss",
    (uint8_t*)"m_addss",
    (uint8_t*)"m_subss",
    (uint8_t*)"m_mulss",
    (uint8_t*)"m_divss",
    (uint8_t*)"m_addsd",
    (uint8_t*)"m_subsd",
    (uint8_t*)"m_mulsd",
    (uint8_t*)"m_divsd",
    (uint8_t*)"m_comiss",
    (uint8_t*)"m_comisd",
    (uint8_t*)"m_xorpd",
    (uint8_t*)"m_xorps",
    (uint8_t*)"m_andpd",
    (uint8_t*)"m_andps",
    (uint8_t*)"m_pxor",
    (uint8_t*)"m_pand",
    (uint8_t*)"m_cvtss2si",
    (uint8_t*)"m_cvtsd2si",
    (uint8_t*)"m_cvttss2si",
    (uint8_t*)"m_cvttsd2si",
    (uint8_t*)"m_cvtsi2ss",
    (uint8_t*)"m_cvtsi2sd",
    (uint8_t*)"m_cvtsd2ss",
    (uint8_t*)"m_cvtss2sd",
    (uint8_t*)"m_movdqa",
    (uint8_t*)"m_movdqu",
    (uint8_t*)"m_pcmpistri",
    (uint8_t*)"m_pcmpistrm",
    (uint8_t*)"m_fld",
    (uint8_t*)"m_fst",
    (uint8_t*)"m_fstp",
    (uint8_t*)"m_fild",
    (uint8_t*)"m_fist",
    (uint8_t*)"m_fistp",
    (uint8_t*)"m_fadd",
    (uint8_t*)"m_fsub",
    (uint8_t*)"m_fmul",
    (uint8_t*)"m_fdiv",
    (uint8_t*)"m_fsqrt",
    (uint8_t*)"m_fsin",
    (uint8_t*)"m_fcos",
    (uint8_t*)"m_fsincos",
    (uint8_t*)"m_fptan",
    (uint8_t*)"m_fpatan",
    (uint8_t*)"m_fabs",
    (uint8_t*)"m_fchs",
    (uint8_t*)"m_minss",
    (uint8_t*)"m_maxss",
    (uint8_t*)"m_minsd",
    (uint8_t*)"m_maxsd",
    (uint8_t*)"m_db",
    (uint8_t*)"m_dw",
    (uint8_t*)"m_dd",
    (uint8_t*)"m_dq",
    (uint8_t*)"m_ddoffset",
    (uint8_t*)"m_segment",
    (uint8_t*)"m_isegment",
    (uint8_t*)"m_zsegment",
    (uint8_t*)"m_csegment",
    (uint8_t*)"m_align",
    (uint8_t*)"m_resb",
    (uint8_t*)"m_resw",
    (uint8_t*)"m_resd",
    (uint8_t*)"m_resq",
    (uint8_t*)"m_xlat",
    (uint8_t*)"m_loopnz",
    (uint8_t*)"m_loopz",
    (uint8_t*)"m_loopcx",
    (uint8_t*)"m_jecxz",
    (uint8_t*)"m_jrcxz",
    (uint8_t*)"m_cmpsb",
    (uint8_t*)"m_cmpsw",
    (uint8_t*)"m_cmpsd",
    (uint8_t*)"m_cmpsq",
    (uint8_t*)"m_rdtsc",
    (uint8_t*)"m_popcnt",
    (uint8_t*)"m_finit",
    (uint8_t*)"m_fldz",
    (uint8_t*)"m_fld1",
    (uint8_t*)"m_fldpi",
    (uint8_t*)"m_fld2t",
    (uint8_t*)"m_fld2e",
    (uint8_t*)"m_fldlg2",
    (uint8_t*)"m_fldln2",
    (uint8_t*)"m_halt"
};
byte mm_mcldecls_mclnopnds[143] = {
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)3u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)2u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u
};
byte mm_mcldecls_mclcodes[143] = {
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)144u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)232u,
    (uint8_t)195u,
    (uint8_t)0u,
    (uint8_t)233u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)5u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)5u,
    (uint8_t)4u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)7u,
    (uint8_t)6u,
    (uint8_t)4u,
    (uint8_t)1u,
    (uint8_t)6u,
    (uint8_t)0u,
    (uint8_t)7u,
    (uint8_t)4u,
    (uint8_t)7u,
    (uint8_t)5u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)3u,
    (uint8_t)2u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)188u,
    (uint8_t)189u,
    (uint8_t)81u,
    (uint8_t)81u,
    (uint8_t)88u,
    (uint8_t)92u,
    (uint8_t)89u,
    (uint8_t)94u,
    (uint8_t)88u,
    (uint8_t)92u,
    (uint8_t)89u,
    (uint8_t)94u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)87u,
    (uint8_t)87u,
    (uint8_t)84u,
    (uint8_t)84u,
    (uint8_t)239u,
    (uint8_t)219u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)102u,
    (uint8_t)243u,
    (uint8_t)99u,
    (uint8_t)98u,
    (uint8_t)0u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)0u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)193u,
    (uint8_t)233u,
    (uint8_t)201u,
    (uint8_t)249u,
    (uint8_t)250u,
    (uint8_t)254u,
    (uint8_t)255u,
    (uint8_t)251u,
    (uint8_t)242u,
    (uint8_t)243u,
    (uint8_t)225u,
    (uint8_t)224u,
    (uint8_t)93u,
    (uint8_t)95u,
    (uint8_t)93u,
    (uint8_t)95u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)4u,
    (uint8_t)8u,
    (uint8_t)215u,
    (uint8_t)224u,
    (uint8_t)225u,
    (uint8_t)226u,
    (uint8_t)227u,
    (uint8_t)227u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)49u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)238u,
    (uint8_t)232u,
    (uint8_t)235u,
    (uint8_t)233u,
    (uint8_t)234u,
    (uint8_t)236u,
    (uint8_t)237u,
    (uint8_t)244u
};
uint8_t *  mm_mcldecls_regnames[21] = {
    (uint8_t*)"rnone",
    (uint8_t*)"r0",
    (uint8_t*)"r1",
    (uint8_t*)"r2",
    (uint8_t*)"r3",
    (uint8_t*)"r4",
    (uint8_t*)"r5",
    (uint8_t*)"r6",
    (uint8_t*)"r7",
    (uint8_t*)"r8",
    (uint8_t*)"r9",
    (uint8_t*)"r10",
    (uint8_t*)"r11",
    (uint8_t*)"r12",
    (uint8_t*)"r13",
    (uint8_t*)"r14",
    (uint8_t*)"r15",
    (uint8_t*)"r16",
    (uint8_t*)"r17",
    (uint8_t*)"r18",
    (uint8_t*)"r19"
};
byte mm_mcldecls_regcodes[21] = {
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)7u,
    (uint8_t)3u,
    (uint8_t)6u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)15u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)5u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)7u,
    (uint8_t)5u,
    (uint8_t)6u
};
uint8_t *  mm_mcldecls_condnames[20] = {
    (uint8_t*)"ov",
    (uint8_t*)"nov",
    (uint8_t*)"ltu",
    (uint8_t*)"geu",
    (uint8_t*)"eq",
    (uint8_t*)"ne",
    (uint8_t*)"leu",
    (uint8_t*)"gtu",
    (uint8_t*)"s",
    (uint8_t*)"ns",
    (uint8_t*)"p",
    (uint8_t*)"np",
    (uint8_t*)"lt",
    (uint8_t*)"ge",
    (uint8_t*)"le",
    (uint8_t*)"gt",
    (uint8_t*)"flt",
    (uint8_t*)"fge",
    (uint8_t*)"fle",
    (uint8_t*)"fgt"
};
uint8_t *  mm_mcldecls_asmcondnames[20] = {
    (uint8_t*)"o",
    (uint8_t*)"no",
    (uint8_t*)"b",
    (uint8_t*)"ae",
    (uint8_t*)"z",
    (uint8_t*)"nz",
    (uint8_t*)"be",
    (uint8_t*)"a",
    (uint8_t*)"s",
    (uint8_t*)"ns",
    (uint8_t*)"p",
    (uint8_t*)"np",
    (uint8_t*)"l",
    (uint8_t*)"ge",
    (uint8_t*)"le",
    (uint8_t*)"g",
    (uint8_t*)"b",
    (uint8_t*)"ae",
    (uint8_t*)"be",
    (uint8_t*)"a"
};
uint8_t *  mm_mcldecls_dregnames[136] = {
    (uint8_t*)"d0",
    (uint8_t*)"d1",
    (uint8_t*)"d2",
    (uint8_t*)"d3",
    (uint8_t*)"d4",
    (uint8_t*)"d5",
    (uint8_t*)"d6",
    (uint8_t*)"d7",
    (uint8_t*)"d8",
    (uint8_t*)"d9",
    (uint8_t*)"d10",
    (uint8_t*)"d11",
    (uint8_t*)"d12",
    (uint8_t*)"d13",
    (uint8_t*)"d14",
    (uint8_t*)"d15",
    (uint8_t*)"a0",
    (uint8_t*)"a1",
    (uint8_t*)"a2",
    (uint8_t*)"a3",
    (uint8_t*)"a4",
    (uint8_t*)"a5",
    (uint8_t*)"a6",
    (uint8_t*)"a7",
    (uint8_t*)"a8",
    (uint8_t*)"a9",
    (uint8_t*)"a10",
    (uint8_t*)"a11",
    (uint8_t*)"a12",
    (uint8_t*)"a13",
    (uint8_t*)"a14",
    (uint8_t*)"a15",
    (uint8_t*)"w0",
    (uint8_t*)"w1",
    (uint8_t*)"w2",
    (uint8_t*)"w3",
    (uint8_t*)"w4",
    (uint8_t*)"w5",
    (uint8_t*)"w6",
    (uint8_t*)"w7",
    (uint8_t*)"w8",
    (uint8_t*)"w9",
    (uint8_t*)"w10",
    (uint8_t*)"w11",
    (uint8_t*)"w12",
    (uint8_t*)"w13",
    (uint8_t*)"w14",
    (uint8_t*)"w15",
    (uint8_t*)"b0",
    (uint8_t*)"b1",
    (uint8_t*)"b2",
    (uint8_t*)"b3",
    (uint8_t*)"b4",
    (uint8_t*)"b5",
    (uint8_t*)"b6",
    (uint8_t*)"b7",
    (uint8_t*)"b8",
    (uint8_t*)"b9",
    (uint8_t*)"b10",
    (uint8_t*)"b11",
    (uint8_t*)"b12",
    (uint8_t*)"b13",
    (uint8_t*)"b14",
    (uint8_t*)"b15",
    (uint8_t*)"b16",
    (uint8_t*)"b17",
    (uint8_t*)"b18",
    (uint8_t*)"b19",
    (uint8_t*)"rax",
    (uint8_t*)"rbx",
    (uint8_t*)"rcx",
    (uint8_t*)"rdx",
    (uint8_t*)"rsi",
    (uint8_t*)"rdi",
    (uint8_t*)"rbp",
    (uint8_t*)"rsp",
    (uint8_t*)"r8",
    (uint8_t*)"r9",
    (uint8_t*)"r10",
    (uint8_t*)"r11",
    (uint8_t*)"r12",
    (uint8_t*)"r13",
    (uint8_t*)"r14",
    (uint8_t*)"r15",
    (uint8_t*)"eax",
    (uint8_t*)"ebx",
    (uint8_t*)"ecx",
    (uint8_t*)"edx",
    (uint8_t*)"esi",
    (uint8_t*)"edi",
    (uint8_t*)"ebp",
    (uint8_t*)"esp",
    (uint8_t*)"r8d",
    (uint8_t*)"r9d",
    (uint8_t*)"r10d",
    (uint8_t*)"r11d",
    (uint8_t*)"r12d",
    (uint8_t*)"r13d",
    (uint8_t*)"r14d",
    (uint8_t*)"r15d",
    (uint8_t*)"ax",
    (uint8_t*)"bx",
    (uint8_t*)"cx",
    (uint8_t*)"dx",
    (uint8_t*)"si",
    (uint8_t*)"di",
    (uint8_t*)"bp",
    (uint8_t*)"sp",
    (uint8_t*)"r8w",
    (uint8_t*)"r9w",
    (uint8_t*)"r10w",
    (uint8_t*)"r11w",
    (uint8_t*)"r12w",
    (uint8_t*)"r13w",
    (uint8_t*)"r14w",
    (uint8_t*)"r15w",
    (uint8_t*)"al",
    (uint8_t*)"bl",
    (uint8_t*)"cl",
    (uint8_t*)"dl",
    (uint8_t*)"ah",
    (uint8_t*)"bh",
    (uint8_t*)"ch",
    (uint8_t*)"dh",
    (uint8_t*)"sil",
    (uint8_t*)"dil",
    (uint8_t*)"bpl",
    (uint8_t*)"spl",
    (uint8_t*)"r8b",
    (uint8_t*)"r9b",
    (uint8_t*)"r10b",
    (uint8_t*)"r11b",
    (uint8_t*)"r12b",
    (uint8_t*)"r13b",
    (uint8_t*)"r14b",
    (uint8_t*)"r15b"
};
byte mm_mcldecls_regsizes[136] = {
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)8u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)4u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u
};
byte mm_mcldecls_regindices[136] = {
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)4u,
    (uint8_t)5u,
    (uint8_t)6u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)4u,
    (uint8_t)5u,
    (uint8_t)6u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)4u,
    (uint8_t)5u,
    (uint8_t)6u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)4u,
    (uint8_t)5u,
    (uint8_t)6u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)17u,
    (uint8_t)18u,
    (uint8_t)19u,
    (uint8_t)20u,
    (uint8_t)1u,
    (uint8_t)5u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)6u,
    (uint8_t)4u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)1u,
    (uint8_t)5u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)6u,
    (uint8_t)4u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)1u,
    (uint8_t)5u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)6u,
    (uint8_t)4u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)1u,
    (uint8_t)5u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)17u,
    (uint8_t)18u,
    (uint8_t)19u,
    (uint8_t)20u,
    (uint8_t)6u,
    (uint8_t)4u,
    (uint8_t)15u,
    (uint8_t)16u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u
};
uint8_t *  mm_mcldecls_xmmregnames[16] = {
    (uint8_t*)"xmm0",
    (uint8_t*)"xmm1",
    (uint8_t*)"xmm2",
    (uint8_t*)"xmm3",
    (uint8_t*)"xmm4",
    (uint8_t*)"xmm5",
    (uint8_t*)"xmm6",
    (uint8_t*)"xmm7",
    (uint8_t*)"xmm8",
    (uint8_t*)"xmm9",
    (uint8_t*)"xmm10",
    (uint8_t*)"xmm11",
    (uint8_t*)"xmm12",
    (uint8_t*)"xmm13",
    (uint8_t*)"xmm14",
    (uint8_t*)"xmm15"
};
uint8_t *  mm_mcldecls_fregnames[8] = {(uint8_t*)"st0",(uint8_t*)"st1",(uint8_t*)"st2",(uint8_t*)"st3",(uint8_t*)"st4",(uint8_t*)"st5",(uint8_t*)"st6",(uint8_t*)"st7"};
uint8_t *  mm_mcldecls_mregnames[8] = {(uint8_t*)"mmx0",(uint8_t*)"mmx1",(uint8_t*)"mmx2",(uint8_t*)"mmx3",(uint8_t*)"mmx4",(uint8_t*)"mmx5",(uint8_t*)"mmx6",(uint8_t*)"mmx7"};
uint8_t *  mm_mcldecls_jmpccnames[18] = {
    (uint8_t*)"jo",
    (uint8_t*)"jno",
    (uint8_t*)"jb",
    (uint8_t*)"jae",
    (uint8_t*)"jz",
    (uint8_t*)"jnz",
    (uint8_t*)"jbe",
    (uint8_t*)"ja",
    (uint8_t*)"js",
    (uint8_t*)"jns",
    (uint8_t*)"jp",
    (uint8_t*)"jnp",
    (uint8_t*)"jl",
    (uint8_t*)"jge",
    (uint8_t*)"jle",
    (uint8_t*)"jg",
    (uint8_t*)"jc",
    (uint8_t*)"jnc"
};
byte mm_mcldecls_jmpcccodes[18] = {
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)4u,
    (uint8_t)5u,
    (uint8_t)6u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)15u,
    (uint8_t)2u,
    (uint8_t)3u
};
uint8_t *  mm_mcldecls_setccnames[18] = {
    (uint8_t*)"seto",
    (uint8_t*)"setno",
    (uint8_t*)"setb",
    (uint8_t*)"setae",
    (uint8_t*)"setz",
    (uint8_t*)"setnz",
    (uint8_t*)"setbe",
    (uint8_t*)"seta",
    (uint8_t*)"sets",
    (uint8_t*)"setns",
    (uint8_t*)"setp",
    (uint8_t*)"setnp",
    (uint8_t*)"setl",
    (uint8_t*)"setge",
    (uint8_t*)"setle",
    (uint8_t*)"setg",
    (uint8_t*)"setc",
    (uint8_t*)"setnc"
};
byte mm_mcldecls_setcccodes[18] = {
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)4u,
    (uint8_t)5u,
    (uint8_t)6u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)15u,
    (uint8_t)2u,
    (uint8_t)3u
};
uint8_t *  mm_mcldecls_cmovccnames[18] = {
    (uint8_t*)"cmovo",
    (uint8_t*)"cmovno",
    (uint8_t*)"cmovb",
    (uint8_t*)"cmovae",
    (uint8_t*)"cmovz",
    (uint8_t*)"cmovnz",
    (uint8_t*)"cmovbe",
    (uint8_t*)"cmova",
    (uint8_t*)"cmovs",
    (uint8_t*)"cmovns",
    (uint8_t*)"cmovp",
    (uint8_t*)"cmovnp",
    (uint8_t*)"cmovl",
    (uint8_t*)"cmovge",
    (uint8_t*)"cmovle",
    (uint8_t*)"cmovg",
    (uint8_t*)"cmovc",
    (uint8_t*)"cmovnc"
};
byte mm_mcldecls_cmovcccodes[18] = {
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)3u,
    (uint8_t)4u,
    (uint8_t)5u,
    (uint8_t)6u,
    (uint8_t)7u,
    (uint8_t)8u,
    (uint8_t)9u,
    (uint8_t)10u,
    (uint8_t)11u,
    (uint8_t)12u,
    (uint8_t)13u,
    (uint8_t)14u,
    (uint8_t)15u,
    (uint8_t)2u,
    (uint8_t)3u
};
uint8_t *  mm_mcldecls_segmentnames[6] = {(uint8_t*)"no_seg",(uint8_t*)"code_seg",(uint8_t*)"idata_seg",(uint8_t*)"zdata_seg",(uint8_t*)"rodata_seg",(uint8_t*)"impdata_seg"};
uint8_t *  mm_mcldecls_reftypenames[3] = {(uint8_t*)"extern_ref",(uint8_t*)"fwd_ref",(uint8_t*)"back_ref"};
int64_t mm_mcldecls_nallmcl;
int64_t mm_mcldecls_mcltable[143];
static uint8_t *  mm_start_optionnames[33] = {
    (uint8_t*)"exe",
    (uint8_t*)"obj",
    (uint8_t*)"gcc",
    (uint8_t*)"tcc",
    (uint8_t*)"bcc",
    (uint8_t*)"opt",
    (uint8_t*)"c",
    (uint8_t*)"link",
    (uint8_t*)"run",
    (uint8_t*)"load",
    (uint8_t*)"parse",
    (uint8_t*)"ma",
    (uint8_t*)"name",
    (uint8_t*)"type",
    (uint8_t*)"gen1",
    (uint8_t*)"gen2",
    (uint8_t*)"gen3",
    (uint8_t*)"gen4",
    (uint8_t*)"time",
    (uint8_t*)"v",
    (uint8_t*)"vv",
    (uint8_t*)"q",
    (uint8_t*)"h",
    (uint8_t*)"help",
    (uint8_t*)"ext",
    (uint8_t*)"out",
    (uint8_t*)"nosys",
    (uint8_t*)"unused",
    (uint8_t*)"debug",
    (uint8_t*)"set",
    (uint8_t*)"recs",
    (uint8_t*)"writelibs",
    (uint8_t*)"ax"
};
static int64_t mm_start_totallines = (int64_t)0;
static int64_t mm_start_nstringobjects = (int64_t)0;
static uint8_t *  mm_start_extraparams[128];
static uint8_t *  mm_start_extravalues[128];
static int64_t mm_start_nextraparams = (int64_t)0;
static uint8_t *  mm_start_optionvars[25];
static uint8_t *  mm_start_optionvalues[25];
static int64_t mm_start_noptionvars;
int64_t mm_start_startclock;
int64_t mm_start_endclock;
static void *  msysnewc__fnaddresses[]= {
    &start,
    &mm_start_start_common,
    &mm_start_debugcompiler,
    &mm_start_do_loadmodules,
    &mm_start_do_parse,
    &mm_start_do_name,
    &mm_start_do_type,
    &mm_start_do_runprog,
    &mm_start_loadmainmodule,
    &mm_start_addmodule,
    &mm_start_loadimport,
    &mm_start_readimportlist,
    &mm_start_pslex,
    &mm_start_initdata,
    &mm_start_initsearchdirs,
    &mm_start_addsearchdir,
    &mm_start_showsearchdirs,
    &mm_start_showast,
    &mm_start_showstflat,
    &mm_start_showsttree,
    &mm_start_showtiming,
    &mm_start_getinputoptions,
    &mm_start_do_option,
    &mm_start_showcaption,
    &mm_start_addtolog,
    &mm_start_addoptionvar,
    &mm_start_addmodulemapping,
    &mm_start_dosetoptionvar,
    &mm_start_findoptionvar,
    &mm_start_getpsname,
    &mm_start_domapmodule,
    &mm_start_mapimport,
    &mm_start_do_writema,
    &mm_start_starttimer,
    &mm_start_stoptimer,
    &msysnewc_m_getdotindex,
    &msysnewc_m_setdotindex,
    &msysnewc_m_getdotslice,
    &msysnewc_m_setdotslice,
    &msysnewc_m_get_nprocs,
    &msysnewc_m_get_nexports,
    &msysnewc_m_get_procname,
    &msysnewc_m_get_procaddr,
    &msysnewc_m_get_procexport,
    &msysnewc_pushio,
    &msysnewc_m_print_startfile,
    &msysnewc_m_print_startstr,
    &msysnewc_m_print_startptr,
    &msysnewc_m_print_startcon,
    &msysnewc_m_print_setfmt,
    &msysnewc_m_print_end,
    &msysnewc_m_print_ptr,
    &msysnewc_m_print_i64,
    &msysnewc_m_print_u64,
    &msysnewc_m_print_r64,
    &msysnewc_m_print_r32,
    &msysnewc_m_print_c8,
    &msysnewc_m_print_str,
    &msysnewc_m_print_newline,
    &msysnewc_m_print_nogap,
    &msysnewc_printstr,
    &msysnewc_printstr_n,
    &msysnewc_printstrn_app,
    &msysnewc_makezstring,
    &msysnewc_freezstring,
    &msysnewc_printchar,
    &msysnewc_nextfmtchars,
    &msysnewc_strtofmt,
    &msysnewc_domultichar,
    &msysnewc_expandstr,
    &msysnewc_xdivrem,
    &msysnewc_u64tostr,
    &msysnewc_i64tostrfmt,
    &msysnewc_u64tostrfmt,
    &msysnewc_i64mintostr,
    &msysnewc_strtostrfmt,
    &msysnewc_tostr_i64,
    &msysnewc_tostr_u64,
    &msysnewc_tostr_r64,
    &msysnewc_tostr_str,
    &msysnewc_getfmt,
    &msysnewc_strint,
    &msysnewc_getstrint,
    &msysnewc_strword,
    &msysnewc_strreal,
    &msysnewc_getstr,
    &msysnewc_initreadbuffer,
    &msysnewc_m_read_conline,
    &msysnewc_m_read_fileline,
    &msysnewc_m_read_strline,
    &msysnewc_readitem,
    &msysnewc_strtoint,
    &msysnewc_m_read_i64,
    &msysnewc_m_read_r64,
    &msysnewc_m_read_str,
    &msysnewc_readstr,
    &msysnewc_rereadln,
    &msysnewc_reread,
    &msysnewc_valint,
    &msysnewc_valreal,
    &msysnewc_iconvlcn,
    &msysnewc_iconvucn,
    &msysnewc_convlcstring,
    &msysnewc_convucstring,
    &msysnewc_m_power_i64,
    &msysnewc_m_intoverflow,
    &msysnewc_m_dotindex,
    &msysnewc_m_dotslice,
    &msysnewc_m_popdotindex,
    &msysnewc_m_popdotslice,
    &msysnewc_m_imin,
    &msysnewc_m_imax,
    &msysnewc_m_sign,
    &mlib_pcm_alloc,
    &mlib_pcm_freestr,
    &mlib_pcm_free,
    &mlib_pcm_freeac,
    &mlib_pcm_copymem4,
    &mlib_pcm_clearmem,
    &mlib_pcm_init,
    &mlib_pcm_getac,
    &mlib_pcm_newblock,
    &mlib_pcm_round,
    &mlib_pcm_array,
    &mlib_pcm_printfreelist,
    &mlib_pcm_diags,
    &mlib_pcm_allocz,
    &mlib_pcm_copyheapstring,
    &mlib_pcm_copyheapstringn,
    &mlib_pcm_copyheapblock,
    &mlib_addtomemalloc,
    &mlib_removefrommemalloc,
    &mlib_allocmem,
    &mlib_reallocmem,
    &mlib_abortprogram,
    &mlib_getfilesize,
    &mlib_readrandom,
    &mlib_writerandom,
    &mlib_setfilepos,
    &mlib_getfilepos,
    &mlib_readfile,
    &mlib_writefile,
    &mlib_checkfile,
    &mlib_readlinen,
    &mlib_iconvlcn,
    &mlib_iconvucn,
    &mlib_convlcstring,
    &mlib_convucstring,
    &mlib_changeext,
    &mlib_extractext,
    &mlib_extractpath,
    &mlib_extractfile,
    &mlib_extractbasefile,
    &mlib_addext,
    &mlib_alloctable,
    &mlib_zalloctable,
    &mlib_checkfreelists,
    &mlib_pcm_alloc32,
    &mlib_pcm_free32,
    &mlib_outbyte,
    &mlib_outword16,
    &mlib_outword,
    &mlib_outword64,
    &mlib_myeof,
    &mlib_pcm_smallallocz,
    &mlib_pcm_smallalloc,
    &mlib_strbuffer_add,
    &mlib_gs_init,
    &mlib_gs_free,
    &mlib_gs_str,
    &mlib_gs_char,
    &mlib_gs_strn,
    &mlib_gs_strvar,
    &mlib_gs_strint,
    &mlib_gs_strln,
    &mlib_gs_strsp,
    &mlib_gs_line,
    &mlib_gs_getcol,
    &mlib_gs_leftstr,
    &mlib_gs_leftint,
    &mlib_gs_padto,
    &mlib_gs_println,
    &mlib_nextcmdparam,
    &mlib_readnextfileitem,
    &mlib_ipadstr,
    &mlib_padstr,
    &mlib_chr,
    &mlib_cmpstring,
    &mlib_cmpstringn,
    &mlib_eqstring,
    &mlib_cmpbytes,
    &mlib_eqbytes,
    &mlib_mseed,
    &mlib_mrandom,
    &mlib_mrandomp,
    &mlib_mrandomint,
    &mlib_mrandomrange,
    &mlib_mrandomreal,
    &mlib_mrandomreal1,
    &mlib_checkpackfile,
    &oslinux_os_init,
    &oslinux_os_execwait,
    &oslinux_os_execcmd,
    &oslinux_os_getch,
    &oslinux_os_kbhit,
    &oslinux_os_flushkeys,
    &oslinux_os_getconsolein,
    &oslinux_os_getconsoleout,
    &oslinux_os_proginstance,
    &oslinux_os_getdllinst,
    &oslinux_os_getdllprocaddr,
    &oslinux_os_initwindows,
    &oslinux_os_getchx,
    &oslinux_os_getos,
    &oslinux_os_gethostsize,
    &oslinux_os_iswindows,
    &oslinux_os_shellexec,
    &oslinux_os_sleep,
    &oslinux_os_getstdin,
    &oslinux_os_getstdout,
    &oslinux_os_gethostname,
    &oslinux_os_getmpath,
    &oslinux_os_exitprocess,
    &oslinux_os_clock,
    &oslinux_os_getclockspersec,
    &oslinux_os_setmesshandler,
    &oslinux_os_hpcounter,
    &oslinux_os_hpfrequency,
    &oslinux_os_filelastwritetime,
    &oslinux_os_getsystime,
    &oslinux_os_peek,
    &mm_support_loadsourcefile,
    &mm_support_loadbuiltin,
    &mm_support_loadbundledfile,
    &mm_support_mcerror,
    &mm_support_serror_gen,
    &mm_support_stopcompiler,
    &mm_support_serror,
    &mm_support_serror_s,
    &mm_support_error_gen,
    &mm_support_rxerror,
    &mm_support_gerror,
    &mm_support_axerror,
    &mm_support_txerror,
    &mm_support_txerror_s,
    &mm_support_txerror_ss,
    &mm_support_rxerror_s,
    &mm_support_gerror_s,
    &mm_support_lxerror_gen,
    &mm_support_lxerror_s,
    &mm_support_lxerror,
    &mm_support_testelem,
    &mm_support_setelem,
    &mm_support_nextpoweroftwo,
    &mm_support_loaderror,
    &mm_support_gs_additem,
    &mm_support_gs_copytostr,
    &mm_support_isalphanum,
    &mm_support_inittypetables,
    &mm_support_addspecialtypes,
    &mm_support_findfile,
    &mm_support_findstdlib,
    &mm_support_getmainfile,
    &mm_support_getmodulefile,
    &mm_support_getsupportfile,
    &mm_support_writemafile,
    &mm_support_loadmafile,
    &mm_lib_newstrec,
    &mm_lib_initqclib,
    &mm_lib_getduplnameptr,
    &mm_lib_adddef,
    &mm_lib_adddef_nodupl,
    &mm_lib_createname,
    &mm_lib_createunit0,
    &mm_lib_createunit1,
    &mm_lib_createunit2,
    &mm_lib_createunit3,
    &mm_lib_insertunit,
    &mm_lib_deleteunit,
    &mm_lib_createconstunit,
    &mm_lib_createstringconstunit,
    &mm_lib_getoptocode,
    &mm_lib_createtype,
    &mm_lib_createusertype,
    &mm_lib_createusertypefromstr,
    &mm_lib_getconstvalue,
    &mm_lib_getrangelwbunit,
    &mm_lib_getrangeupbunit,
    &mm_lib_createarraymode,
    &mm_lib_createarraymodek,
    &mm_lib_nextautotype,
    &mm_lib_converttoslice,
    &mm_lib_createslicemode,
    &mm_lib_createslicemodek,
    &mm_lib_createstringmode,
    &mm_lib_createrefmode,
    &mm_lib_createrefprocmode,
    &mm_lib_setnameptr,
    &mm_lib_getdottedname,
    &mm_lib_getavname,
    &mm_lib_unionstr_clear,
    &mm_lib_unionstr_append,
    &mm_lib_unionstr_concat,
    &mm_lib_unionstr_last,
    &mm_lib_unionstr_copy,
    &mm_lib_unionstr_print,
    &mm_lib_createrecordmode,
    &mm_lib_convertstring,
    &mm_lib_strexpr,
    &mm_lib_jeval,
    &mm_lib_getopcjname,
    &mm_lib_strmode,
    &mm_lib_strmode2,
    &mm_lib_istrmode,
    &mm_lib_countunits,
    &mm_lib_finddefstr,
    &mm_lib_addtoproclist,
    &mm_lib_addstatic,
    &mm_lib_newusertypex,
    &mm_lib_typename,
    &mm_lib_allocunitrec,
    &mm_lib_createdupldef,
    &mm_lib_createnewmoduledef,
    &mm_lib_storemode,
    &mm_lib_duplunit,
    &mm_lib_iscallbackfn,
    &mm_lib_isstringconst,
    &mm_lib_checkblockreturn,
    &mm_lib_isconstint,
    &mm_lib_isconstunit,
    &mm_lib_faststrint,
    &mm_lib_getfullname,
    &mm_lib_getownername,
    &mm_lib_isnumericmode,
    &mm_lib_isrefmode,
    &mm_lib_strconstopnd,
    &mm_lib_gettypecat_t,
    &mm_lib_getalignment,
    &mm_lib_ispoweroftwo,
    &mm_lib_addlistunit,
    &mm_lib_issimpletype,
    &mm_lib_getpacktype,
    &mm_lib_getlow128,
    &mm_lib_gethigh128,
    &mm_lib_putlow128,
    &mm_lib_puthigh128,
    &mm_lex_lexreadtoken,
    &mm_lex_lxreadstring,
    &mm_lex_readnumber,
    &mm_lex_readdecimalnumber,
    &mm_lex_readrealnumber,
    &mm_lex_readrealbest,
    &mm_lex_readexponent,
    &mm_lex_printsymbol,
    &mm_lex_stringtonumber,
    &mm_lex_stringtodecimalnumber,
    &mm_lex_lexsetup,
    &mm_lex_printstrn,
    &mm_lex_scannumber,
    &mm_lex_readrawstring,
    &mm_lex_lookup,
    &mm_lex_gethashvaluez,
    &mm_lex_inithashtable,
    &mm_lex_addreservedword,
    &mm_lex_dolexdirective,
    &mm_lex_lexreadline,
    &mm_lex_startlex,
    &mm_lex_convertzstring,
    &mm_lex_addnamestr,
    &mm_lex_findname,
    &mm_lex_ps1,
    &mm_lex_ps2,
    &mm_lex_ps,
    &mm_lex_lex,
    &mm_lex_showhashtablesize,
    &mm_lex_checkname,
    &mm_lex_getstrfile,
    &mm_lex_stacksourcefile,
    &mm_lex_stacksource,
    &mm_lex_unstacksource,
    &mm_lex_readarraystring,
    &mm_lex_stringtonumber128,
    &mm_lex_setinttype,
    &mm_lex_readrawxname,
    &mm_diags_printmodelist,
    &mm_diags_printst,
    &mm_diags_printstrec,
    &mm_diags_printstflat,
    &mm_diags_printcode,
    &mm_diags_printunit,
    &mm_diags_printunitlist,
    &mm_diags_getprefix,
    &mm_diags_getlineinfok,
    &mm_genwx64_do_codegen_debug,
    &mm_genwx64_do_codegen,
    &mm_genwx64_showpcl,
    &mm_genwx64_showmcl,
    &mm_genwx64_showss,
    &mm_genwx64_writegsfile,
    &mm_genwx64_showhelp,
    &mm_genwx64_initassemsymbols,
    &mm_genwx64_addsearchlib,
    &mm_genpcl_codegen_pcl,
    &mm_genpcl_genprocdef,
    &mm_genpcl_genprocentry,
    &mm_genpcl_genframedef,
    &mm_genpcl_dostaticvar,
    &mm_genpcl_dostaticvariant,
    &mm_genpcl_genidata,
    &mm_genpcl_geninitproc,
    &mm_genpcl_initframedef,
    &mm_genpcl_freeframevar,
    &mm_genpcl_getconstframeoffset,
    &mm_libpcl_pclinit,
    &mm_libpcl_initpcdest,
    &mm_libpcl_genpc,
    &mm_libpcl_addpcl,
    &mm_libpcl_genpc_condlab,
    &mm_libpcl_lastpc,
    &mm_libpcl_genpcstr,
    &mm_libpcl_newpclopnd,
    &mm_libpcl_duplopnd,
    &mm_libpcl_writepclblock,
    &mm_libpcl_writepclcode,
    &mm_libpcl_gencomment,
    &mm_libpcl_genstrimm,
    &mm_libpcl_genname,
    &mm_libpcl_gensys,
    &mm_libpcl_writepcl,
    &mm_libpcl_strpcl,
    &mm_libpcl_strmodev,
    &mm_libpcl_stropnd,
    &mm_libpcl_getprocname,
    &mm_libpcl_strlabel,
    &mm_libpcl_isframe,
    &mm_libpcl_genreturn,
    &mm_libpcl_genint,
    &mm_libpcl_genint128,
    &mm_libpcl_genreal,
    &mm_libpcl_genassem_u,
    &mm_libpcl_genlabel,
    &mm_libpcl_genmem_u,
    &mm_libpcl_genmem_d,
    &mm_libpcl_genmemaddr_u,
    &mm_libpcl_genmemaddr_d,
    &mm_libpcl_getopndsize_u,
    &mm_libpcl_getopndsize_d,
    &mm_libpcl_isint32const,
    &mm_libpcl_roundto,
    &mm_libpcl_pushstack,
    &mm_libpcl_popstack,
    &mm_libpcl_definelabel,
    &mm_libpcl_createfwdlabel,
    &mm_libpcl_definefwdlabel,
    &mm_libpcl_genjumpl,
    &mm_libpcl_do_syscallproc,
    &mm_libpcl_strmemopnd,
    &mm_libpcl_strmemaddropnd,
    &mm_libpcl_roundsizetg,
    &mm_libpcl_getpclop,
    &mm_libpcl_strshortmode,
    &mm_libpcl_islogical,
    &mm_libpcl_makefloatopnds,
    &mm_libpcl_setpclcat_u,
    &mm_libpcl_setpclcat_t,
    &mm_libpcl_setpclmode_u,
    &mm_libpcl_setpclmode_t,
    &mm_blockpcl_evalunit,
    &mm_blockpcl_evalref,
    &mm_blockpcl_genjumpcond,
    &mm_blockpcl_gcomparejump,
    &mm_blockpcl_genjumpl,
    &mm_blockpcl_reversecond,
    &mm_blockpcl_stacklooplabels,
    &mm_blockpcl_findlooplabel,
    &mm_blockpcl_unimpl,
    &mm_blockpcl_do_const,
    &mm_blockpcl_do_null,
    &mm_blockpcl_do_name,
    &mm_blockpcl_do_block,
    &mm_blockpcl_do_decimal,
    &mm_blockpcl_do_callproc,
    &mm_blockpcl_do_return,
    &mm_blockpcl_do_returnmult,
    &mm_blockpcl_do_assign,
    &mm_blockpcl_do_shallowcopy,
    &mm_blockpcl_do_to,
    &mm_blockpcl_do_if,
    &mm_blockpcl_do_longif,
    &mm_blockpcl_do_for,
    &mm_blockpcl_do_cfor,
    &mm_blockpcl_do_while,
    &mm_blockpcl_do_repeat,
    &mm_blockpcl_do_goto,
    &mm_blockpcl_do_gotoblock,
    &mm_blockpcl_do_labeldef,
    &mm_blockpcl_do_exit,
    &mm_blockpcl_do_do,
    &mm_blockpcl_do_case,
    &mm_blockpcl_do_emptycase,
    &mm_blockpcl_do_switch,
    &mm_blockpcl_do_swap,
    &mm_blockpcl_do_select,
    &mm_blockpcl_do_print,
    &mm_blockpcl_do_read,
    &mm_blockpcl_do_readln,
    &mm_blockpcl_do_cprint,
    &mm_blockpcl_do_cprintln,
    &mm_blockpcl_do_sprint,
    &mm_blockpcl_do_sfprint,
    &mm_blockpcl_do_sread,
    &mm_blockpcl_do_sreadln,
    &mm_blockpcl_do_stop,
    &mm_blockpcl_do_try,
    &mm_blockpcl_do_except,
    &mm_blockpcl_do_yield,
    &mm_blockpcl_do_raise,
    &mm_blockpcl_do_eval,
    &mm_blockpcl_do_lambda,
    &mm_blockpcl_do_andl,
    &mm_blockpcl_do_orl,
    &mm_blockpcl_do_xorl,
    &mm_blockpcl_do_notl,
    &mm_blockpcl_do_istruel,
    &mm_blockpcl_do_makelist,
    &mm_blockpcl_evalrest,
    &mm_blockpcl_do_makerange,
    &mm_blockpcl_do_makeset,
    &mm_blockpcl_do_makedict,
    &mm_blockpcl_do_exprlist,
    &mm_blockpcl_do_multexpr,
    &mm_blockpcl_do_keyword,
    &mm_blockpcl_do_keyvalue,
    &mm_blockpcl_do_applyop,
    &mm_blockpcl_do_applyopx,
    &mm_blockpcl_do_andand,
    &mm_blockpcl_do_eq,
    &mm_blockpcl_do_ne,
    &mm_blockpcl_do_lt,
    &mm_blockpcl_do_le,
    &mm_blockpcl_do_gt,
    &mm_blockpcl_do_ge,
    &mm_blockpcl_do_isequal,
    &mm_blockpcl_do_muldiv,
    &mm_blockpcl_do_bin,
    &mm_blockpcl_do_shl,
    &mm_blockpcl_do_shlto,
    &mm_blockpcl_do_setcc,
    &mm_blockpcl_do_setccx,
    &mm_blockpcl_do_clamp,
    &mm_blockpcl_do_index,
    &mm_blockpcl_do_slice,
    &mm_blockpcl_do_keyindex,
    &mm_blockpcl_do_makeslice,
    &mm_blockpcl_do_dotindex,
    &mm_blockpcl_do_dotslice,
    &mm_blockpcl_do_anddotindex,
    &mm_blockpcl_do_anddotslice,
    &mm_blockpcl_do_dot,
    &mm_blockpcl_checkdotchain,
    &mm_blockpcl_do_dotattr,
    &mm_blockpcl_do_atan2,
    &mm_blockpcl_do_power,
    &mm_blockpcl_do_ptr,
    &mm_blockpcl_do_addrof,
    &mm_blockpcl_do_convert,
    &mm_blockpcl_do_convertref,
    &mm_blockpcl_do_autocast,
    &mm_blockpcl_do_typepun,
    &mm_blockpcl_do_typeconst,
    &mm_blockpcl_do_operator,
    &mm_blockpcl_do_upper,
    &mm_blockpcl_do_unary,
    &mm_blockpcl_do_maths,
    &mm_blockpcl_do_sqr,
    &mm_blockpcl_do_sign,
    &mm_blockpcl_do_fmod,
    &mm_blockpcl_do_bitwidth,
    &mm_blockpcl_do_bytesize,
    &mm_blockpcl_do_typeof,
    &mm_blockpcl_do_typestr,
    &mm_blockpcl_do_sliceptr,
    &mm_blockpcl_do_minvalue,
    &mm_blockpcl_do_maxvalue,
    &mm_blockpcl_do_incr,
    &mm_blockpcl_do_incrx,
    &mm_blockpcl_do_binto,
    &mm_blockpcl_do_unaryto,
    &mm_blockpcl_do_cvlineno,
    &mm_blockpcl_do_cvmodulename,
    &mm_blockpcl_do_cvfilename,
    &mm_blockpcl_do_assignblock,
    &mm_blockpcl_do_callff,
    &mm_blockpcl_do_recase,
    &mm_blockpcl_do_assem,
    &mm_blockpcl_pushrhs,
    &mm_blockpcl_do_multassign,
    &mm_blockpcl_isshortconst,
    &mm_blockpcl_isshortmem,
    &mm_blockpcl_do_popindex,
    &mm_blockpcl_do_popslice,
    &mm_blockpcl_do_popkeyindex,
    &mm_blockpcl_do_popdot,
    &mm_blockpcl_do_assignarray,
    &mm_blockpcl_do_assignrecord,
    &mm_genmcl_codegen_mcl,
    &mm_genmcl_convertpcl,
    &mm_genmcl_inithandlers,
    &mm_genmcl_unimpl,
    &mm_genmcl_pc_dummy,
    &mm_genmcl_pc_comment,
    &mm_genmcl_pc_blank,
    &mm_genmcl_pc_label,
    &mm_genmcl_pc_labelname,
    &mm_genmcl_pc_startmult,
    &mm_genmcl_pc_resetmult,
    &mm_genmcl_pc_endmult,
    &mm_genmcl_pc_stackall,
    &mm_genmcl_pc_procentry,
    &mm_genmcl_pc_procexit,
    &mm_genmcl_pc_zstatic,
    &mm_genmcl_pc_istatic,
    &mm_genmcl_pc_equiv,
    &mm_genmcl_pc_initmemz_var,
    &mm_genmcl_pc_pushmem_d8,
    &mm_genmcl_pc_dpushmem_d8,
    &mm_genmcl_pc_pushmem_x8,
    &mm_genmcl_pc_pushmem_d124,
    &mm_genmcl_pc_pushmem_d16,
    &mm_genmcl_pc_pushmem_x4,
    &mm_genmcl_pc_pushmem_var,
    &mm_genmcl_pc_pushmem_blk,
    &mm_genmcl_pc_pushint,
    &mm_genmcl_pc_pushint128,
    &mm_genmcl_pc_pushreal_r64,
    &mm_genmcl_pc_pushreal_x8,
    &mm_genmcl_pc_pushreal_x4,
    &mm_genmcl_pc_pushstr,
    &mm_genmcl_pc_makeint,
    &mm_genmcl_pc_makereal,
    &mm_genmcl_pc_makestr,
    &mm_genmcl_pc_makedec,
    &mm_genmcl_pc_stackargs,
    &mm_genmcl_pc_pushaddr,
    &mm_genmcl_pc_pushptr_d8_proc,
    &mm_genmcl_pc_pushptr_d16,
    &mm_genmcl_pc_pushptr_x8,
    &mm_genmcl_pc_pushptr_x4,
    &mm_genmcl_pc_pushptr_d124,
    &mm_genmcl_pc_pushptr_var,
    &mm_genmcl_pc_pushretslot_d8_d124,
    &mm_genmcl_pc_pushretslot_d16,
    &mm_genmcl_pc_pushretslot_var,
    &mm_genmcl_pc_pushretslot_x8,
    &mm_genmcl_pc_pushffretval_pushretval_d8_d124_var,
    &mm_genmcl_pc_pushffretval_pushretval_x8_x4,
    &mm_genmcl_pc_pushretval_d16,
    &mm_genmcl_pc_moveretval_d8_d124_var,
    &mm_genmcl_pc_moveretval_d16,
    &mm_genmcl_pc_moveretval_x8_x4,
    &mm_genmcl_pc_popmem_popmemz_d8,
    &mm_genmcl_pc_popmem_d16,
    &mm_genmcl_pc_popmem_x8,
    &mm_genmcl_pc_popmem_x4,
    &mm_genmcl_pc_popmem_popmemz_d124,
    &mm_genmcl_pc_popmem_blk,
    &mm_genmcl_pc_popmem_storemem_var,
    &mm_genmcl_pc_popptr_d8_x8,
    &mm_genmcl_pc_popptr_d16,
    &mm_genmcl_pc_popptr_x4,
    &mm_genmcl_pc_popptr_d124,
    &mm_genmcl_pc_popptr_var,
    &mm_genmcl_pc_storeptr_var,
    &mm_genmcl_pc_storeptr_d8,
    &mm_genmcl_pc_storeptr_d124,
    &mm_genmcl_pc_storemem_d8,
    &mm_genmcl_pc_storemem_d16,
    &mm_genmcl_pc_storemem_x8,
    &mm_genmcl_pc_storemem_x4,
    &mm_genmcl_pc_storemem_d124,
    &mm_genmcl_pc_storeptr,
    &mm_genmcl_pc_unstack,
    &mm_genmcl_pc_popretval_d16,
    &mm_genmcl_pc_popretval_d8_d124_var,
    &mm_genmcl_pc_popretval_x8,
    &mm_genmcl_pc_free_d8_d124,
    &mm_genmcl_pc_free_d16,
    &mm_genmcl_pc_free_x4_x8,
    &mm_genmcl_pc_free_var,
    &mm_genmcl_pc_freemem_var,
    &mm_genmcl_pc_add_sub_i64_u64_c64_ref,
    &mm_genmcl_pc_add_i128_u128,
    &mm_genmcl_pc_sub_i128_u128,
    &mm_genmcl_pc_add_sub_mul_div_r32_r64,
    &mm_genmcl_pc_add_var,
    &mm_genmcl_pc_sub_var,
    &mm_genmcl_pc_mul_var,
    &mm_genmcl_pc_div_var,
    &mm_genmcl_pc_idiv_var,
    &mm_genmcl_pc_irem_var,
    &mm_genmcl_pc_iand_var,
    &mm_genmcl_pc_ior_var,
    &mm_genmcl_pc_ixor_var,
    &mm_genmcl_pc_shl_var,
    &mm_genmcl_pc_shr_var,
    &mm_genmcl_pc_min_var,
    &mm_genmcl_pc_max_var,
    &mm_genmcl_pc_power_var,
    &mm_genmcl_pc_append_var,
    &mm_genmcl_pc_appendto_var,
    &mm_genmcl_pc_concat_var,
    &mm_genmcl_pc_concatto_var,
    &mm_genmcl_pc_slice_var,
    &mm_genmcl_pc_in_var,
    &mm_genmcl_pc_neg_var,
    &mm_genmcl_pc_abs_var,
    &mm_genmcl_pc_inot_var,
    &mm_genmcl_pc_notl_var,
    &mm_genmcl_pc_istruel_var,
    &mm_genmcl_pc_sqrt_var,
    &mm_genmcl_pc_sin_var,
    &mm_genmcl_pc_cos_var,
    &mm_genmcl_pc_tan_var,
    &mm_genmcl_pc_asin_var,
    &mm_genmcl_pc_acos_var,
    &mm_genmcl_pc_atan_var,
    &mm_genmcl_pc_exp_var,
    &mm_genmcl_pc_ln_var,
    &mm_genmcl_pc_log_var,
    &mm_genmcl_pc_round_var,
    &mm_genmcl_pc_floor_var,
    &mm_genmcl_pc_ceil_var,
    &mm_genmcl_pc_fract_var,
    &mm_genmcl_pc_asc_var,
    &mm_genmcl_pc_chr_var,
    &mm_genmcl_pc_lwb_var,
    &mm_genmcl_pc_upb_var,
    &mm_genmcl_pc_len_var,
    &mm_genmcl_pc_bounds_var,
    &mm_genmcl_pc_addto_var,
    &mm_genmcl_pc_subto_var,
    &mm_genmcl_pc_multo_var,
    &mm_genmcl_pc_divto_var,
    &mm_genmcl_pc_idivto_var,
    &mm_genmcl_pc_iremto_var,
    &mm_genmcl_pc_iandto_var,
    &mm_genmcl_pc_iorto_var,
    &mm_genmcl_pc_ixorto_var,
    &mm_genmcl_pc_shlto_var,
    &mm_genmcl_pc_shrto_var,
    &mm_genmcl_pc_minto_var,
    &mm_genmcl_pc_maxto_var,
    &mm_genmcl_pc_negto_var,
    &mm_genmcl_pc_absto_var,
    &mm_genmcl_pc_inotto_var,
    &mm_genmcl_pc_notlto_var,
    &mm_genmcl_pc_mul_i64_u64,
    &mm_genmcl_pc_mul_i128_u128,
    &mm_genmcl_pc_idiv_i128_u128,
    &mm_genmcl_pc_idiv_irem_i64_u64,
    &mm_genmcl_pc_neg_i64_u64_c64,
    &mm_genmcl_pc_neg_i128_u128,
    &mm_genmcl_pc_neg_r64,
    &mm_genmcl_pc_neg_r32,
    &mm_genmcl_pc_neg,
    &mm_genmcl_pc_abs_i64_u64_c64,
    &mm_genmcl_pc_abs_r32,
    &mm_genmcl_pc_abs_r64,
    &mm_genmcl_pc_inot_i64_u64,
    &mm_genmcl_pc_notl_d8_d124,
    &mm_genmcl_pc_istruel_d8_d124,
    &mm_genmcl_pc_call,
    &mm_genmcl_pc_return,
    &mm_genmcl_pc_callptr,
    &mm_genmcl_pc_syscall,
    &mm_genmcl_pc_callff,
    &mm_genmcl_pc_callptrff,
    &mm_genmcl_pc_jump,
    &mm_genmcl_pc_jumpcc_i64_u64_ref_c64,
    &mm_genmcl_pc_jumpccimm_i64_u64_c64,
    &mm_genmcl_pc_jumpcc_i128,
    &mm_genmcl_pc_jumpcc_u128,
    &mm_genmcl_pc_jumpcc_r32_r64,
    &mm_genmcl_pc_jumpcc_var,
    &mm_genmcl_pc_jumpfalse_jumptrue_i64_u64_r64_ref_c64,
    &mm_genmcl_pc_jumpinyz_jumpnotinyz_i64_u64,
    &mm_genmcl_pc_casejumpeq_i64_u64_r64_ref_c64,
    &mm_genmcl_pc_setjumpeq_setjumpeqx_d8_d124,
    &mm_genmcl_pc_setjumpne_d8_d124,
    &mm_genmcl_pc_switch,
    &mm_genmcl_pc_switchlab,
    &mm_genmcl_pc_endswitch,
    &mm_genmcl_pc_info,
    &mm_genmcl_pc_setcc_i64_u64_ref_c64,
    &mm_genmcl_pc_setcc,
    &mm_genmcl_pc_setcc_var,
    &mm_genmcl_pc_compare,
    &mm_genmcl_pc_isequal,
    &mm_genmcl_pc_iand_ior_ixor_i64_u64_c64,
    &mm_genmcl_pc_iand_ior_ixor_i128_u128,
    &mm_genmcl_pc_iandc_i64_u64_c64,
    &mm_genmcl_pc_shl_i64_u64,
    &mm_genmcl_pc_shr_i64,
    &mm_genmcl_pc_shr_u64,
    &mm_genmcl_pc_shlc_i64_u64,
    &mm_genmcl_pc_shrc_i64_u64,
    &mm_genmcl_pc_shr,
    &mm_genmcl_pc_in,
    &mm_genmcl_pc_min_max_i64_u64,
    &mm_genmcl_pc_min_max_r64,
    &mm_genmcl_pc_addoffset_ref,
    &mm_genmcl_pc_subref_i64_u64,
    &mm_genmcl_pc_suboffset_ref,
    &mm_genmcl_pc_concat,
    &mm_genmcl_pc_append,
    &mm_genmcl_pc_andl,
    &mm_genmcl_pc_orl,
    &mm_genmcl_pc_index_indexref_ax_sx,
    &mm_genmcl_pc_indexmem_ax,
    &mm_genmcl_pc_indexref_var,
    &mm_genmcl_pc_index_var,
    &mm_genmcl_pc_popindex_var,
    &mm_genmcl_pc_dotindex_var,
    &mm_genmcl_pc_popdotindex_var,
    &mm_genmcl_pc_popindex_storeindex_ax_sx,
    &mm_genmcl_pc_dotindex_i64,
    &mm_genmcl_pc_dotslice,
    &mm_genmcl_pc_popdotindex_d8,
    &mm_genmcl_pc_popdotslice_d8,
    &mm_genmcl_pc_dot_dotref_rec,
    &mm_genmcl_pc_popdot_storedot_rec,
    &mm_genmcl_pc_lwb,
    &mm_genmcl_pc_upb,
    &mm_genmcl_pc_upb_sx,
    &mm_genmcl_pc_len_sx,
    &mm_genmcl_pc_lenstr_ref,
    &mm_genmcl_pc_bounds,
    &mm_genmcl_pc_sqrt_r64,
    &mm_genmcl_pc_sqr_i64,
    &mm_genmcl_pc_sqr_r64,
    &mm_genmcl_pc_power_i64,
    &mm_genmcl_pc_power_r64,
    &mm_genmcl_pc_sign_i64_u64,
    &mm_genmcl_pc_sign_r64,
    &mm_genmcl_pc_sin_cos_tan_asin_acos_atan_ln_log_exp_floor_ceil_r64,
    &mm_genmcl_pc_round,
    &mm_genmcl_pc_fract,
    &mm_genmcl_pc_fmod,
    &mm_genmcl_pc_addto_subto_iandto_iorto_ixorto_i64_u64_ref,
    &mm_genmcl_pc_addmemto_submemto_iandmemto_iormemto_ixormemto_i64_u64_ref,
    &mm_genmcl_pc_addto_subto_iandto_iorto_ixorto_i32_i16_i8_u32_u16_u8_c16_c8,
    &mm_genmcl_pc_addto_multo_r64_r32,
    &mm_genmcl_pc_subto_divto_r64_r32,
    &mm_genmcl_pc_multo_i64_u64_i32_u32_i16_u16_i8_u8,
    &mm_genmcl_pc_idivto_iremto_i64_u64,
    &mm_genmcl_pc_shlto_i64_u64,
    &mm_genmcl_pc_shlcto_i64_u64,
    &mm_genmcl_pc_shrcto_i64_u64,
    &mm_genmcl_pc_shlcmemto_i64_u64,
    &mm_genmcl_pc_shrcmemto_i64_u64,
    &mm_genmcl_pc_shrto_i64,
    &mm_genmcl_pc_shrto_u64,
    &mm_genmcl_pc_minto,
    &mm_genmcl_pc_minto_maxto_i64_u64,
    &mm_genmcl_pc_minto_maxto_r64,
    &mm_genmcl_pc_maxto,
    &mm_genmcl_pc_addoffsetto_suboffsetto_ref,
    &mm_genmcl_pc_concatto,
    &mm_genmcl_pc_appendto,
    &mm_genmcl_pc_negto_inotto_i64_u64,
    &mm_genmcl_pc_negto_r64,
    &mm_genmcl_pc_absto_i64_u64,
    &mm_genmcl_pc_absto_r32_r64,
    &mm_genmcl_pc_incrtomem_d8_d124,
    &mm_genmcl_pc_decrtomem_d8_d124,
    &mm_genmcl_pc_incrtomem_decrtomem_ref,
    &mm_genmcl_pc_incrtomem_var,
    &mm_genmcl_pc_decrtomem_var,
    &mm_genmcl_pc_incrto_decrto_d8_d124,
    &mm_genmcl_pc_incrto_decrto_ref,
    &mm_genmcl_pc_incrto_decrto_var,
    &mm_genmcl_pc_preincrtox_predecrtox_d8_d124,
    &mm_genmcl_pc_postincrtox_postdecrtox_d8_d124,
    &mm_genmcl_pc_preincrtox_predecrtox_ref,
    &mm_genmcl_pc_postincrtox_postdecrtox_ref,
    &mm_genmcl_pc_preincrtox_predecrtox_var,
    &mm_genmcl_pc_postincrtox_postdecrtox_var,
    &mm_genmcl_pc_uwiden_iwiden,
    &mm_genmcl_pc_ifix,
    &mm_genmcl_pc_ifloat,
    &mm_genmcl_pc_fwiden,
    &mm_genmcl_pc_fnarrow,
    &mm_genmcl_pc_softtruncate,
    &mm_genmcl_pc_truncate,
    &mm_genmcl_pc_typepun,
    &mm_genmcl_pc_box,
    &mm_genmcl_pc_unbox,
    &mm_genmcl_pc_swap_d8,
    &mm_genmcl_pc_swap_d124,
    &mm_genmcl_pc_makerange,
    &mm_genmcl_pc_makelist_var,
    &mm_genmcl_pc_makeslice,
    &mm_genmcl_pc_slicelen_sliceupb,
    &mm_genmcl_pc_sliceptr,
    &mm_genmcl_pc_slice_ax,
    &mm_genmcl_pc_slice_ref,
    &mm_genmcl_pc_slice_sx,
    &mm_genmcl_pc_assem,
    &mm_genmcl_pc_assem_d8,
    &mm_genmcl_genasmopnd,
    &mm_genmcl_pc_db_dw_dd_dq,
    &mm_genmcl_pc_resb,
    &mm_genmcl_pc_resw,
    &mm_genmcl_pc_resd,
    &mm_genmcl_pc_resq,
    &mm_genmcl_pc_copyblock,
    &mm_genmcl_pc_csegment,
    &mm_genmcl_pc_isegment,
    &mm_genmcl_pc_zsegment,
    &mm_genmcl_showopndstack,
    &mm_genmcl_showopndstack_s,
    &mm_genmcl_findop,
    &mm_genmcl_findcat,
    &mm_genmcl_dohandler,
    &mm_genmcl_fixdivopnds_d8,
    &mm_genmcl_doshiftn,
    &mm_genmcl_doshiftnto,
    &mm_genmcl_docallff,
    &mm_genmcl_docmaths1,
    &mm_genmcl_docmaths2,
    &mm_genmcl_call128handler_f,
    &mm_genmcl_call128handler_p,
    &mm_genmcl_call64handler_f,
    &mm_genmcl_call64handler_p,
    &mm_genmcl_calldothandler,
    &mm_genmcl_callpopdothandler,
    &mm_genmcl_genstringtable,
    &mm_genmcl_genstring,
    &mm_genmcl_gendb,
    &mm_genmcl_gendw,
    &mm_genmcl_gendbstring,
    &mm_genmcl_gendq,
    &mm_genmcl_gendqname,
    &mm_genmcl_gendqlabel,
    &mm_genmcl_genrealtable,
    &mm_genmcl_genfunctiondata,
    &mm_genmcl_gensysfntable,
    &mm_genmcl_genabsneg,
    &mm_libmcl_mclinit,
    &mm_libmcl_initmcdest,
    &mm_libmcl_genmc,
    &mm_libmcl_genmc_cond,
    &mm_libmcl_lastmc,
    &mm_libmcl_genmcstr,
    &mm_libmcl_newmclopnd,
    &mm_libmcl_duplopnd,
    &mm_libmcl_genxreg,
    &mm_libmcl_genindex,
    &mm_libmcl_writemclblock,
    &mm_libmcl_writemclcode,
    &mm_libmcl_gencomment_mc,
    &mm_libmcl_genstrimm_mc,
    &mm_libmcl_genname_mc,
    &mm_libmcl_genmc_sys,
    &mm_libmcl_getsysfnlabel,
    &mm_libmcl_writemcl,
    &mm_libmcl_strmcl,
    &mm_libmcl_stropnd,
    &mm_libmcl_strvalue,
    &mm_libmcl_setsegment,
    &mm_libmcl_getprocname,
    &mm_libmcl_widenstr,
    &mm_libmcl_strlabel,
    &mm_libmcl_isframe,
    &mm_libmcl_getsizeprefix,
    &mm_libmcl_needsizeprefix,
    &mm_libmcl_changeopndsize,
    &mm_libmcl_applyoffset,
    &mm_libmcl_genint_mc,
    &mm_libmcl_genrealmem_mc,
    &mm_libmcl_genrealimm_mc,
    &mm_libmcl_genimm,
    &mm_libmcl_genlabel_mc,
    &mm_libmcl_genlabel_mem,
    &mm_libmcl_genmem_u_mc,
    &mm_libmcl_genmem_d_mc,
    &mm_libmcl_genmemaddr_u_mc,
    &mm_libmcl_genmemaddr_d_mc,
    &mm_libmcl_genreg,
    &mm_libmcl_genreg0,
    &mm_libmcl_genireg,
    &mm_libmcl_getopndsize_u,
    &mm_libmcl_getopndsize_d,
    &mm_libmcl_getmclcond,
    &mm_libmcl_getmclcond_i,
    &mm_libmcl_getmclcond_u,
    &mm_libmcl_roundsizetg,
    &mm_libmcl_getregname,
    &mm_libmcl_fgetregname,
    &mm_libmcl_issimple0,
    &mm_libmcl_isintconst,
    &mm_libmcl_isint32const,
    &mm_libmcl_sameoperand,
    &mm_libmcl_genmsource,
    &mm_libmcl_roundto,
    &mm_libmcl_pushstack_mc,
    &mm_libmcl_popstack_mc,
    &mm_libmcl_definelabel_mc,
    &mm_libmcl_createfwdlabel_mc,
    &mm_libmcl_definefwdlabel_mc,
    &mm_libmcl_genjumpl_mc,
    &mm_libmcl_getstringindex,
    &mm_libmcl_getrealindex,
    &mm_libmcl_extendstringtable,
    &mm_libmcl_extendrealtable,
    &mm_libmcl_genmc_loadint_d8,
    &mm_libmcl_genmc_loadint_d16,
    &mm_libmcl_genmc_loadint_vari64,
    &mm_libmcl_genmc_loadword_d8,
    &mm_libmcl_genmc_loadreal_d8,
    &mm_libmcl_genmc_loadreal_d4,
    &mm_libmcl_genmc_loadreal_x8,
    &mm_libmcl_genmc_loadreal_x4,
    &mm_libmcl_genmc_loadmem_d8,
    &mm_libmcl_genmc_loadmem_d16,
    &mm_libmcl_genmc_loadmem_x8,
    &mm_libmcl_genmc_loadmem_x4,
    &mm_libmcl_genmc_loadmem_d124,
    &mm_libmcl_genmc_loadmemaddr,
    &mm_libmcl_genmc_loadptr_d8,
    &mm_libmcl_genmc_loadptr_d16,
    &mm_libmcl_genmc_storeptr_d8,
    &mm_libmcl_genmc_storeptr_d16,
    &mm_libmcl_genmc_storeptr_x8,
    &mm_libmcl_genmc_storeptr_x4,
    &mm_libmcl_genmc_loadptr_d124,
    &mm_libmcl_genmc_storeptr_d124,
    &mm_libmcl_genmc_floadmem,
    &mm_libmcl_genmc_loadmemw,
    &mm_libmcl_genmc_loadstr,
    &mm_libmcl_pushalloperands,
    &mm_libmcl_newopnd_d8,
    &mm_libmcl_newopnd_d16,
    &mm_libmcl_newopnd_x8,
    &mm_libmcl_newstackopnd_d8,
    &mm_libmcl_newstackopnd_d16,
    &mm_libmcl_newstackopnd_var,
    &mm_libmcl_newstackopnd_x8,
    &mm_libmcl_genmc_storemem_d8,
    &mm_libmcl_genmc_storemem_d16,
    &mm_libmcl_genmc_storemem_x8,
    &mm_libmcl_genmc_storemem_x4,
    &mm_libmcl_genmc_storemem_d124,
    &mm_libmcl_genmc_storeretval_d8,
    &mm_libmcl_genmc_storeretval_d16_var,
    &mm_libmcl_genmc_storeretval_x8,
    &mm_libmcl_genmc_storememx,
    &mm_libmcl_genmc_storememw,
    &mm_libmcl_getopnds,
    &mm_libmcl_getopndn_d8,
    &mm_libmcl_popopnd,
    &mm_libmcl_poparg,
    &mm_libmcl_newretvalopnd_d8,
    &mm_libmcl_newretvalopnd_d16,
    &mm_libmcl_newretvalopnd_x8,
    &mm_libmcl_getnextreg,
    &mm_libmcl_checktwofreeregs,
    &mm_libmcl_getnexttempreg,
    &mm_libmcl_getnexttempxreg,
    &mm_libmcl_getnextxreg,
    &mm_libmcl_freereg,
    &mm_libmcl_freexreg,
    &mm_libmcl_gerrorc,
    &mm_libmcl_genopndind,
    &mm_libmcl_gettempopnd_d8,
    &mm_libmcl_freetempopnd_d8,
    &mm_libmcl_gettempreg_d8,
    &mm_libmcl_freetempreg_d8,
    &mm_libmcl_gettempopnd_x8,
    &mm_libmcl_freetempopnd_x8,
    &mm_libmcl_swapopnds,
    &mm_libmcl_dupltop,
    &mm_libmcl_genopnd,
    &mm_libmcl_genopndh,
    &mm_libmcl_genopndindh,
    &mm_libmcl_asmstr,
    &mm_libmcl_asmchar,
    &mm_libmcl_asmint,
    &mm_libmcl_checkmcl,
    &ma_genss_genss,
    &ma_genss_doinstr,
    &ma_genss_genbyte,
    &ma_genss_genword,
    &ma_genss_gendword,
    &ma_genss_genqword,
    &ma_genss_genopnd,
    &ma_genss_addrelocitem,
    &ma_genss_getstindex,
    &ma_genss_genrel32,
    &ma_genss_getdef,
    &ma_genss_genabs32,
    &ma_genss_genabs64,
    &ma_genss_getrel32,
    &ma_genss_dofwdrefs,
    &ma_genss_genrex,
    &ma_genss_isbytesized,
    &ma_genss_isdwordsized,
    &ma_genss_do_push,
    &ma_genss_do_pop,
    &ma_genss_do_inc,
    &ma_genss_do_neg,
    &ma_genss_genamode,
    &ma_genss_makemodrm,
    &ma_genss_setopsize,
    &ma_genss_setaddrsize,
    &ma_genss_getdispsize,
    &ma_genss_genrm,
    &ma_genss_genrmbyte,
    &ma_genss_makeam,
    &ma_genss_do_arith,
    &ma_genss_do_mov,
    &ma_genss_getregcoder,
    &ma_genss_getregcodeb,
    &ma_genss_getregcodebx,
    &ma_genss_getregcoderx,
    &ma_genss_do_lea,
    &ma_genss_do_movsx,
    &ma_genss_checkhighreg,
    &ma_genss_do_exch,
    &ma_genss_do_movsxd,
    &ma_genss_do_imul2,
    &ma_genss_do_imul3,
    &ma_genss_do_shift,
    &ma_genss_do_test,
    &ma_genss_do_loop,
    &ma_genss_do_jcxz,
    &ma_genss_do_setcc,
    &ma_genss_do_movxmm,
    &ma_genss_do_arithxmm,
    &ma_genss_do_logicxmm,
    &ma_genss_do_convertfloat,
    &ma_genss_do_fix,
    &ma_genss_do_float,
    &ma_genss_do_call,
    &ma_genss_do_jmp,
    &ma_genss_getcurrdatalen,
    &ma_genss_do_cmovcc,
    &ma_genss_do_fmem,
    &ma_genss_getr32bits,
    &ma_genss_genrel8,
    &ma_genss_checkshortjump,
    &ma_genss_addfwdref,
    &ma_genss_switchseg,
    &ma_genss_do_movdqx,
    &ma_genss_do_popcnt,
    &ma_genss_do_bsf,
    &ma_genss_extendsymboltable,
    &ma_genss_showopnd,
    &ma_genss_do_pcmpistri,
    &ma_lib_initlib,
    &ma_lib_getsizetag,
    &ma_lib_buffercreate,
    &ma_lib_bufferexpand,
    &ma_lib_buffercheck,
    &ma_lib_bufferlength,
    &ma_lib_bufferelemptr,
    &ma_lib_addbyte,
    &ma_lib_addword,
    &ma_lib_adddword,
    &ma_lib_addqword,
    &ma_writeobj_writess,
    &ma_writeobj_writerecord,
    &ma_writeobj_writerelocs,
    &ma_writeobj_writedata,
    &ma_writeobj_writesymboltable,
    &ma_writeobj_writestringtable,
    &ma_writeobj_makesymbol,
    &ma_writeobj_addsymbol,
    &ma_writeobj_initsymboltable,
    &ma_writeobj_strtoaux,
    &ma_writeobj_sectiontoaux,
    &ma_writeobj_addstringentry,
    &ma_writeobj_convertsymboltable,
    &ma_writeobj_writecoff,
    &ma_writeexe_writeexe,
    &ma_writeexe_genexe,
    &ma_writeexe_loadlibs,
    &ma_writeexe_writessdata,
    &ma_writeexe_initsectiontable,
    &ma_writeexe_showssdata,
    &ma_writeexe_showsectiondata,
    &ma_writeexe_showsectioncode,
    &ma_writeexe_showsectionrelocs2,
    &ma_writeexe_gs_value,
    &ma_writeexe_showsymboltable2,
    &ma_writeexe_showimporttable,
    &ma_writeexe_roundtoblock,
    &ma_writeexe_showsections,
    &ma_writeexe_extractlibname,
    &ma_writeexe_scanst,
    &ma_writeexe_relocdata,
    &ma_writeexe_writerecordx,
    &ma_writeexe_writedosstub,
    &ma_writeexe_writepesig,
    &ma_writeexe_writepadding,
    &ma_writeexe_writefileheader,
    &ma_writeexe_writeoptheader,
    &ma_writeexe_writesectionheader,
    &ma_writeexe_writesectiondata,
    &ma_writeexe_getoffsets,
    &ma_writeexe_imported,
    &ma_writeexe_exported,
    &ma_writeexe_addsearchlib,
    &ma_writeexe_setuplibfiles,
    &ma_disasm_decodeinstr,
    &ma_disasm_decodetwobyteinstr,
    &ma_disasm_decodeaddr,
    &ma_disasm_readbyte,
    &ma_disasm_readsbyte,
    &ma_disasm_readword16,
    &ma_disasm_readint16,
    &ma_disasm_readword32,
    &ma_disasm_readint32,
    &ma_disasm_readint64,
    &ma_disasm_getreg,
    &ma_disasm_strreg,
    &ma_disasm_strfreg,
    &ma_disasm_printaddrmode,
    &ma_disasm_genstr,
    &ma_disasm_genintd,
    &ma_disasm_genhex,
    &ma_disasm_readimm,
    &ma_disasm_readimm8,
    &ma_disasm_strxmm,
    &ma_disasm_strmmx,
    &ma_disasm_decode8087,
    &ma_disasm_do87arith,
    &ma_disasm_do87mem,
    &ma_disasm_getsil,
    &ma_disasm_getsilx,
    &mm_parse_parsemodule,
    &mm_parse_readmoduledefs,
    &mm_parse_initparser,
    &mm_parse_skipsemi,
    &mm_parse_makeblock,
    &mm_parse_makestmtblock,
    &mm_parse_checkequals,
    &mm_parse_getcurrline,
    &mm_parse_checkbegin,
    &mm_parse_checkbeginend,
    &mm_parse_checkend,
    &mm_parse_readvardef,
    &mm_parse_readconstdef,
    &mm_parse_readlbrack,
    &mm_parse_addlistparam,
    &mm_parse_readcast,
    &mm_parse_readopc,
    &mm_parse_readsprint,
    &mm_parse_readsread,
    &mm_parse_readcompilervar,
    &mm_parse_readcastx,
    &mm_parse_checksymbol,
    &mm_parse_readtypespec,
    &mm_parse_readslicetype,
    &mm_parse_readslist,
    &mm_parse_readindex,
    &mm_parse_readdotsuffix,
    &mm_parse_isconstexpr,
    &mm_parse_readkeyindex,
    &mm_parse_readconstexpr,
    &mm_parse_readconstint,
    &mm_parse_readprocdef,
    &mm_parse_readprocdecl,
    &mm_parse_readparams,
    &mm_parse_readparams_types,
    &mm_parse_readcondsuffix,
    &mm_parse_readif,
    &mm_parse_readgoto,
    &mm_parse_readunless,
    &mm_parse_readswitchcase,
    &mm_parse_readstop,
    &mm_parse_readreturn,
    &mm_parse_readdo,
    &mm_parse_readto,
    &mm_parse_readwhile,
    &mm_parse_readrepeat,
    &mm_parse_readloopcontrol,
    &mm_parse_readprint,
    &mm_parse_readread,
    &mm_parse_readtry,
    &mm_parse_readraise,
    &mm_parse_readfor,
    &mm_parse_readtypedef,
    &mm_parse_readrecordfields,
    &mm_parse_readtabledef,
    &mm_parse_readclassdef,
    &mm_parse_readclassbody,
    &mm_parse_readenumtype,
    &mm_parse_readimportmodule,
    &mm_parse_readimportbody,
    &mm_parse_readequivfield,
    &mm_parse_readapplyop,
    &mm_parse_readrefproc,
    &mm_parse_pushproc,
    &mm_parse_popproc,
    &mm_parse_readassemline,
    &mm_parse_readassemblock,
    &mm_parse_assembleline,
    &mm_parse_readassemopnd,
    &mm_parse_makeastring,
    &mm_parse_readreturntype,
    &mm_parse_readset,
    &mm_parse_istypestarter,
    &mm_parse_readunit,
    &mm_parse_readfactor,
    &mm_parse_readterm2,
    &mm_parse_readterm,
    &mm_parse_readxunit,
    &mm_parse_readsunit,
    &mm_parse_readmacrodef,
    &mm_parse_readimportalias,
    &mm_parse_domappedalias,
    &mm_parse_readrecase,
    &mm_parse_createblock,
    &mm_parse_adddocstring,
    &mm_name_rx_typetable,
    &mm_name_rx_unit,
    &mm_name_rx_module,
    &mm_name_rx_deflist,
    &mm_name_rx_passdef,
    &mm_name_rx_unitlist,
    &mm_name_resolvetopname,
    &mm_name_resolvename,
    &mm_name_finddupl,
    &mm_name_resolvedot,
    &mm_name_fixmode,
    &mm_name_fixmode2,
    &mm_name_fixusertypes,
    &mm_name_rx_assem,
    &mm_name_resolve_equiv_name,
    &mm_name_addframevar,
    &mm_name_converteqeq,
    &mm_name_copylistunit,
    &mm_name_copyunit,
    &mm_name_replaceunit,
    &mm_name_expandmacro,
    &mm_name_duplfield,
    &mm_name_do_baseclass,
    &mm_type_tx_allprocs,
    &mm_type_tpass,
    &mm_type_tx_block,
    &mm_type_tx_typetable,
    &mm_type_setmodesize,
    &mm_type_setarraysize,
    &mm_type_setslicesize,
    &mm_type_tcond,
    &mm_type_tx_module,
    &mm_type_tx_passdef,
    &mm_type_tx_unitlist,
    &mm_type_tx_namedef,
    &mm_type_tx_namedconst,
    &mm_type_tx_expr,
    &mm_type_checkconstexpr,
    &mm_type_getconstint,
    &mm_type_tevaluate,
    &mm_type_tevalbinop,
    &mm_type_tevalmonop,
    &mm_type_tevalconvert,
    &mm_type_makenewconst,
    &mm_type_tx_name,
    &mm_type_getdominantmode,
    &mm_type_getdominantmodepp,
    &mm_type_coerceunit,
    &mm_type_tx_add,
    &mm_type_tx_mul,
    &mm_type_tx_shl,
    &mm_type_tx_iand,
    &mm_type_tx_eq,
    &mm_type_tx_isequal,
    &mm_type_tx_lt,
    &mm_type_tx_callproc,
    &mm_type_tx_neg,
    &mm_type_tx_if,
    &mm_type_tx_longif,
    &mm_type_tx_preincr,
    &mm_type_tx_for,
    &mm_type_tx_index,
    &mm_type_tx_keyindex,
    &mm_type_tx_makerange,
    &mm_type_tx_makeset,
    &mm_type_tx_makedict,
    &mm_type_tx_ptr,
    &mm_type_setrecordsize,
    &mm_type_scanrecord,
    &mm_type_roundoffset,
    &mm_type_getalignment,
    &mm_type_tx_convert,
    &mm_type_tx_makelist,
    &mm_type_tx_dot,
    &mm_type_resolvefield,
    &mm_type_comparemodes,
    &mm_type_isboolunit,
    &mm_type_checkbool,
    &mm_type_tx_andl,
    &mm_type_convintconst,
    &mm_type_tx_upb,
    &mm_type_tx_len,
    &mm_type_tx_lenstr,
    &mm_type_tx_lwb,
    &mm_type_tx_bounds,
    &mm_type_tx_sliceptr,
    &mm_type_tx_inot,
    &mm_type_tx_atan2,
    &mm_type_tx_swap,
    &mm_type_tx_sqrt,
    &mm_type_tx_select,
    &mm_type_tx_case,
    &mm_type_tx_notl,
    &mm_type_tx_istruel,
    &mm_type_tx_addto,
    &mm_type_tx_iandto,
    &mm_type_tx_negto,
    &mm_type_tx_typepun,
    &mm_type_tx_bytesize,
    &mm_type_tx_exit,
    &mm_type_tx_goto,
    &mm_type_tx_switch,
    &mm_type_tx_power,
    &mm_type_tx_addroffirst,
    &mm_type_tx_minvalue,
    &mm_type_tx_return,
    &mm_type_tx_dotindex,
    &mm_type_tx_slice,
    &mm_type_tx_assign,
    &mm_type_tx_multassign,
    &mm_type_tx_in,
    &mm_type_getprocretmodes,
    &mm_type_tx_exprlist,
    &mm_type_tx_sign,
    &mm_type_fixvoidunit,
    &mm_type_twiden,
    &mm_type_twidenshort,
    &mm_type_tx_head,
    &mm_type_tx_concat,
    &mm_type_twidenopnd,
    &mm_type_joinstrings,
    &mm_type_removeaddrof,
    &mm_type_tstringslice,
    &mm_type_tx_bitfield,
    &mm_type_deref,
    &mm_type_tmethodcall,
0};
static uint8_t *  msysnewc__fnnames[]= {
    (byte*)"start",
    (byte*)"start_common",
    (byte*)"debugcompiler",
    (byte*)"do_loadmodules",
    (byte*)"do_parse",
    (byte*)"do_name",
    (byte*)"do_type",
    (byte*)"do_runprog",
    (byte*)"loadmainmodule",
    (byte*)"addmodule",
    (byte*)"loadimport",
    (byte*)"readimportlist",
    (byte*)"pslex",
    (byte*)"initdata",
    (byte*)"initsearchdirs",
    (byte*)"addsearchdir",
    (byte*)"showsearchdirs",
    (byte*)"showast",
    (byte*)"showstflat",
    (byte*)"showsttree",
    (byte*)"showtiming",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"showcaption",
    (byte*)"addtolog",
    (byte*)"addoptionvar",
    (byte*)"addmodulemapping",
    (byte*)"dosetoptionvar",
    (byte*)"findoptionvar",
    (byte*)"getpsname",
    (byte*)"domapmodule",
    (byte*)"mapimport",
    (byte*)"do_writema",
    (byte*)"starttimer",
    (byte*)"stoptimer",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_get_nprocs",
    (byte*)"m_get_nexports",
    (byte*)"m_get_procname",
    (byte*)"m_get_procaddr",
    (byte*)"m_get_procexport",
    (byte*)"pushio",
    (byte*)"m_print_startfile",
    (byte*)"m_print_startstr",
    (byte*)"m_print_startptr",
    (byte*)"m_print_startcon",
    (byte*)"m_print_setfmt",
    (byte*)"m_print_end",
    (byte*)"m_print_ptr",
    (byte*)"m_print_i64",
    (byte*)"m_print_u64",
    (byte*)"m_print_r64",
    (byte*)"m_print_r32",
    (byte*)"m_print_c8",
    (byte*)"m_print_str",
    (byte*)"m_print_newline",
    (byte*)"m_print_nogap",
    (byte*)"printstr",
    (byte*)"printstr_n",
    (byte*)"printstrn_app",
    (byte*)"makezstring",
    (byte*)"freezstring",
    (byte*)"printchar",
    (byte*)"nextfmtchars",
    (byte*)"strtofmt",
    (byte*)"domultichar",
    (byte*)"expandstr",
    (byte*)"xdivrem",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"i64mintostr",
    (byte*)"strtostrfmt",
    (byte*)"tostr_i64",
    (byte*)"tostr_u64",
    (byte*)"tostr_r64",
    (byte*)"tostr_str",
    (byte*)"getfmt",
    (byte*)"strint",
    (byte*)"getstrint",
    (byte*)"strword",
    (byte*)"strreal",
    (byte*)"getstr",
    (byte*)"initreadbuffer",
    (byte*)"m_read_conline",
    (byte*)"m_read_fileline",
    (byte*)"m_read_strline",
    (byte*)"readitem",
    (byte*)"strtoint",
    (byte*)"m_read_i64",
    (byte*)"m_read_r64",
    (byte*)"m_read_str",
    (byte*)"readstr",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"valint",
    (byte*)"valreal",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"m_power_i64",
    (byte*)"m_intoverflow",
    (byte*)"m_dotindex",
    (byte*)"m_dotslice",
    (byte*)"m_popdotindex",
    (byte*)"m_popdotslice",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"m_sign",
    (byte*)"pcm_alloc",
    (byte*)"pcm_freestr",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_copymem4",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_array",
    (byte*)"pcm_printfreelist",
    (byte*)"pcm_diags",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"pcm_copyheapstringn",
    (byte*)"pcm_copyheapblock",
    (byte*)"addtomemalloc",
    (byte*)"removefrommemalloc",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"setfilepos",
    (byte*)"getfilepos",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"alloctable",
    (byte*)"zalloctable",
    (byte*)"checkfreelists",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword",
    (byte*)"outword64",
    (byte*)"myeof",
    (byte*)"pcm_smallallocz",
    (byte*)"pcm_smallalloc",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparam",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"mseed",
    (byte*)"mrandom",
    (byte*)"mrandomp",
    (byte*)"mrandomint",
    (byte*)"mrandomrange",
    (byte*)"mrandomreal",
    (byte*)"mrandomreal1",
    (byte*)"checkpackfile",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_flushkeys",
    (byte*)"os_getconsolein",
    (byte*)"os_getconsoleout",
    (byte*)"os_proginstance",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_gethostsize",
    (byte*)"os_iswindows",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_getmpath",
    (byte*)"os_exitprocess",
    (byte*)"os_clock",
    (byte*)"os_getclockspersec",
    (byte*)"os_setmesshandler",
    (byte*)"os_hpcounter",
    (byte*)"os_hpfrequency",
    (byte*)"os_filelastwritetime",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"loadsourcefile",
    (byte*)"loadbuiltin",
    (byte*)"loadbundledfile",
    (byte*)"mcerror",
    (byte*)"serror_gen",
    (byte*)"stopcompiler",
    (byte*)"serror",
    (byte*)"serror_s",
    (byte*)"error_gen",
    (byte*)"rxerror",
    (byte*)"gerror",
    (byte*)"axerror",
    (byte*)"txerror",
    (byte*)"txerror_s",
    (byte*)"txerror_ss",
    (byte*)"rxerror_s",
    (byte*)"gerror_s",
    (byte*)"lxerror_gen",
    (byte*)"lxerror_s",
    (byte*)"lxerror",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"nextpoweroftwo",
    (byte*)"loaderror",
    (byte*)"gs_additem",
    (byte*)"gs_copytostr",
    (byte*)"isalphanum",
    (byte*)"inittypetables",
    (byte*)"addspecialtypes",
    (byte*)"findfile",
    (byte*)"findstdlib",
    (byte*)"getmainfile",
    (byte*)"getmodulefile",
    (byte*)"getsupportfile",
    (byte*)"writemafile",
    (byte*)"loadmafile",
    (byte*)"newstrec",
    (byte*)"initqclib",
    (byte*)"getduplnameptr",
    (byte*)"adddef",
    (byte*)"adddef_nodupl",
    (byte*)"createname",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createunit3",
    (byte*)"insertunit",
    (byte*)"deleteunit",
    (byte*)"createconstunit",
    (byte*)"createstringconstunit",
    (byte*)"getoptocode",
    (byte*)"createtype",
    (byte*)"createusertype",
    (byte*)"createusertypefromstr",
    (byte*)"getconstvalue",
    (byte*)"getrangelwbunit",
    (byte*)"getrangeupbunit",
    (byte*)"createarraymode",
    (byte*)"createarraymodek",
    (byte*)"nextautotype",
    (byte*)"converttoslice",
    (byte*)"createslicemode",
    (byte*)"createslicemodek",
    (byte*)"createstringmode",
    (byte*)"createrefmode",
    (byte*)"createrefprocmode",
    (byte*)"setnameptr",
    (byte*)"getdottedname",
    (byte*)"getavname",
    (byte*)"unionstr_clear",
    (byte*)"unionstr_append",
    (byte*)"unionstr_concat",
    (byte*)"unionstr_last",
    (byte*)"unionstr_copy",
    (byte*)"unionstr_print",
    (byte*)"createrecordmode",
    (byte*)"convertstring",
    (byte*)"strexpr",
    (byte*)"jeval",
    (byte*)"getopcjname",
    (byte*)"strmode",
    (byte*)"strmode2",
    (byte*)"istrmode",
    (byte*)"countunits",
    (byte*)"finddefstr",
    (byte*)"addtoproclist",
    (byte*)"addstatic",
    (byte*)"newusertypex",
    (byte*)"typename",
    (byte*)"allocunitrec",
    (byte*)"createdupldef",
    (byte*)"createnewmoduledef",
    (byte*)"storemode",
    (byte*)"duplunit",
    (byte*)"iscallbackfn",
    (byte*)"isstringconst",
    (byte*)"checkblockreturn",
    (byte*)"isconstint",
    (byte*)"isconstunit",
    (byte*)"faststrint",
    (byte*)"getfullname",
    (byte*)"getownername",
    (byte*)"isnumericmode",
    (byte*)"isrefmode",
    (byte*)"strconstopnd",
    (byte*)"gettypecat_t",
    (byte*)"getalignment",
    (byte*)"ispoweroftwo",
    (byte*)"addlistunit",
    (byte*)"issimpletype",
    (byte*)"getpacktype",
    (byte*)"getlow128",
    (byte*)"gethigh128",
    (byte*)"putlow128",
    (byte*)"puthigh128",
    (byte*)"lexreadtoken",
    (byte*)"lxreadstring",
    (byte*)"readnumber",
    (byte*)"readdecimalnumber",
    (byte*)"readrealnumber",
    (byte*)"readrealbest",
    (byte*)"readexponent",
    (byte*)"printsymbol",
    (byte*)"stringtonumber",
    (byte*)"stringtodecimalnumber",
    (byte*)"lexsetup",
    (byte*)"printstrn",
    (byte*)"scannumber",
    (byte*)"readrawstring",
    (byte*)"lookup",
    (byte*)"gethashvaluez",
    (byte*)"inithashtable",
    (byte*)"addreservedword",
    (byte*)"dolexdirective",
    (byte*)"lexreadline",
    (byte*)"startlex",
    (byte*)"convertzstring",
    (byte*)"addnamestr",
    (byte*)"findname",
    (byte*)"ps1",
    (byte*)"ps2",
    (byte*)"ps",
    (byte*)"lex",
    (byte*)"showhashtablesize",
    (byte*)"checkname",
    (byte*)"getstrfile",
    (byte*)"stacksourcefile",
    (byte*)"stacksource",
    (byte*)"unstacksource",
    (byte*)"readarraystring",
    (byte*)"stringtonumber128",
    (byte*)"setinttype",
    (byte*)"readrawxname",
    (byte*)"printmodelist",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"printstflat",
    (byte*)"printcode",
    (byte*)"printunit",
    (byte*)"printunitlist",
    (byte*)"getprefix",
    (byte*)"getlineinfok",
    (byte*)"do_codegen_debug",
    (byte*)"do_codegen",
    (byte*)"showpcl",
    (byte*)"showmcl",
    (byte*)"showss",
    (byte*)"writegsfile",
    (byte*)"showhelp",
    (byte*)"initassemsymbols",
    (byte*)"addsearchlib",
    (byte*)"codegen_pcl",
    (byte*)"genprocdef",
    (byte*)"genprocentry",
    (byte*)"genframedef",
    (byte*)"dostaticvar",
    (byte*)"dostaticvariant",
    (byte*)"genidata",
    (byte*)"geninitproc",
    (byte*)"initframedef",
    (byte*)"freeframevar",
    (byte*)"getconstframeoffset",
    (byte*)"pclinit",
    (byte*)"initpcdest",
    (byte*)"genpc",
    (byte*)"addpcl",
    (byte*)"genpc_condlab",
    (byte*)"lastpc",
    (byte*)"genpcstr",
    (byte*)"newpclopnd",
    (byte*)"duplopnd",
    (byte*)"writepclblock",
    (byte*)"writepclcode",
    (byte*)"gencomment",
    (byte*)"genstrimm",
    (byte*)"genname",
    (byte*)"gensys",
    (byte*)"writepcl",
    (byte*)"strpcl",
    (byte*)"strmodev",
    (byte*)"stropnd",
    (byte*)"getprocname",
    (byte*)"strlabel",
    (byte*)"isframe",
    (byte*)"genreturn",
    (byte*)"genint",
    (byte*)"genint128",
    (byte*)"genreal",
    (byte*)"genassem_u",
    (byte*)"genlabel",
    (byte*)"genmem_u",
    (byte*)"genmem_d",
    (byte*)"genmemaddr_u",
    (byte*)"genmemaddr_d",
    (byte*)"getopndsize_u",
    (byte*)"getopndsize_d",
    (byte*)"isint32const",
    (byte*)"roundto",
    (byte*)"pushstack",
    (byte*)"popstack",
    (byte*)"definelabel",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"genjumpl",
    (byte*)"do_syscallproc",
    (byte*)"strmemopnd",
    (byte*)"strmemaddropnd",
    (byte*)"roundsizetg",
    (byte*)"getpclop",
    (byte*)"strshortmode",
    (byte*)"islogical",
    (byte*)"makefloatopnds",
    (byte*)"setpclcat_u",
    (byte*)"setpclcat_t",
    (byte*)"setpclmode_u",
    (byte*)"setpclmode_t",
    (byte*)"evalunit",
    (byte*)"evalref",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"genjumpl",
    (byte*)"reversecond",
    (byte*)"stacklooplabels",
    (byte*)"findlooplabel",
    (byte*)"unimpl",
    (byte*)"do_const",
    (byte*)"do_null",
    (byte*)"do_name",
    (byte*)"do_block",
    (byte*)"do_decimal",
    (byte*)"do_callproc",
    (byte*)"do_return",
    (byte*)"do_returnmult",
    (byte*)"do_assign",
    (byte*)"do_shallowcopy",
    (byte*)"do_to",
    (byte*)"do_if",
    (byte*)"do_longif",
    (byte*)"do_for",
    (byte*)"do_cfor",
    (byte*)"do_while",
    (byte*)"do_repeat",
    (byte*)"do_goto",
    (byte*)"do_gotoblock",
    (byte*)"do_labeldef",
    (byte*)"do_exit",
    (byte*)"do_do",
    (byte*)"do_case",
    (byte*)"do_emptycase",
    (byte*)"do_switch",
    (byte*)"do_swap",
    (byte*)"do_select",
    (byte*)"do_print",
    (byte*)"do_read",
    (byte*)"do_readln",
    (byte*)"do_cprint",
    (byte*)"do_cprintln",
    (byte*)"do_sprint",
    (byte*)"do_sfprint",
    (byte*)"do_sread",
    (byte*)"do_sreadln",
    (byte*)"do_stop",
    (byte*)"do_try",
    (byte*)"do_except",
    (byte*)"do_yield",
    (byte*)"do_raise",
    (byte*)"do_eval",
    (byte*)"do_lambda",
    (byte*)"do_andl",
    (byte*)"do_orl",
    (byte*)"do_xorl",
    (byte*)"do_notl",
    (byte*)"do_istruel",
    (byte*)"do_makelist",
    (byte*)"evalrest",
    (byte*)"do_makerange",
    (byte*)"do_makeset",
    (byte*)"do_makedict",
    (byte*)"do_exprlist",
    (byte*)"do_multexpr",
    (byte*)"do_keyword",
    (byte*)"do_keyvalue",
    (byte*)"do_applyop",
    (byte*)"do_applyopx",
    (byte*)"do_andand",
    (byte*)"do_eq",
    (byte*)"do_ne",
    (byte*)"do_lt",
    (byte*)"do_le",
    (byte*)"do_gt",
    (byte*)"do_ge",
    (byte*)"do_isequal",
    (byte*)"do_muldiv",
    (byte*)"do_bin",
    (byte*)"do_shl",
    (byte*)"do_shlto",
    (byte*)"do_setcc",
    (byte*)"do_setccx",
    (byte*)"do_clamp",
    (byte*)"do_index",
    (byte*)"do_slice",
    (byte*)"do_keyindex",
    (byte*)"do_makeslice",
    (byte*)"do_dotindex",
    (byte*)"do_dotslice",
    (byte*)"do_anddotindex",
    (byte*)"do_anddotslice",
    (byte*)"do_dot",
    (byte*)"checkdotchain",
    (byte*)"do_dotattr",
    (byte*)"do_atan2",
    (byte*)"do_power",
    (byte*)"do_ptr",
    (byte*)"do_addrof",
    (byte*)"do_convert",
    (byte*)"do_convertref",
    (byte*)"do_autocast",
    (byte*)"do_typepun",
    (byte*)"do_typeconst",
    (byte*)"do_operator",
    (byte*)"do_upper",
    (byte*)"do_unary",
    (byte*)"do_maths",
    (byte*)"do_sqr",
    (byte*)"do_sign",
    (byte*)"do_fmod",
    (byte*)"do_bitwidth",
    (byte*)"do_bytesize",
    (byte*)"do_typeof",
    (byte*)"do_typestr",
    (byte*)"do_sliceptr",
    (byte*)"do_minvalue",
    (byte*)"do_maxvalue",
    (byte*)"do_incr",
    (byte*)"do_incrx",
    (byte*)"do_binto",
    (byte*)"do_unaryto",
    (byte*)"do_cvlineno",
    (byte*)"do_cvmodulename",
    (byte*)"do_cvfilename",
    (byte*)"do_assignblock",
    (byte*)"do_callff",
    (byte*)"do_recase",
    (byte*)"do_assem",
    (byte*)"pushrhs",
    (byte*)"do_multassign",
    (byte*)"isshortconst",
    (byte*)"isshortmem",
    (byte*)"do_popindex",
    (byte*)"do_popslice",
    (byte*)"do_popkeyindex",
    (byte*)"do_popdot",
    (byte*)"do_assignarray",
    (byte*)"do_assignrecord",
    (byte*)"codegen_mcl",
    (byte*)"convertpcl",
    (byte*)"inithandlers",
    (byte*)"unimpl",
    (byte*)"pc_dummy",
    (byte*)"pc_comment",
    (byte*)"pc_blank",
    (byte*)"pc_label",
    (byte*)"pc_labelname",
    (byte*)"pc_startmult",
    (byte*)"pc_resetmult",
    (byte*)"pc_endmult",
    (byte*)"pc_stackall",
    (byte*)"pc_procentry",
    (byte*)"pc_procexit",
    (byte*)"pc_zstatic",
    (byte*)"pc_istatic",
    (byte*)"pc_equiv",
    (byte*)"pc_initmemz_var",
    (byte*)"pc_pushmem_d8",
    (byte*)"pc_dpushmem_d8",
    (byte*)"pc_pushmem_x8",
    (byte*)"pc_pushmem_d124",
    (byte*)"pc_pushmem_d16",
    (byte*)"pc_pushmem_x4",
    (byte*)"pc_pushmem_var",
    (byte*)"pc_pushmem_blk",
    (byte*)"pc_pushint",
    (byte*)"pc_pushint128",
    (byte*)"pc_pushreal_r64",
    (byte*)"pc_pushreal_x8",
    (byte*)"pc_pushreal_x4",
    (byte*)"pc_pushstr",
    (byte*)"pc_makeint",
    (byte*)"pc_makereal",
    (byte*)"pc_makestr",
    (byte*)"pc_makedec",
    (byte*)"pc_stackargs",
    (byte*)"pc_pushaddr",
    (byte*)"pc_pushptr_d8_proc",
    (byte*)"pc_pushptr_d16",
    (byte*)"pc_pushptr_x8",
    (byte*)"pc_pushptr_x4",
    (byte*)"pc_pushptr_d124",
    (byte*)"pc_pushptr_var",
    (byte*)"pc_pushretslot_d8_d124",
    (byte*)"pc_pushretslot_d16",
    (byte*)"pc_pushretslot_var",
    (byte*)"pc_pushretslot_x8",
    (byte*)"pc_pushffretval_pushretval_d8_d124_var",
    (byte*)"pc_pushffretval_pushretval_x8_x4",
    (byte*)"pc_pushretval_d16",
    (byte*)"pc_moveretval_d8_d124_var",
    (byte*)"pc_moveretval_d16",
    (byte*)"pc_moveretval_x8_x4",
    (byte*)"pc_popmem_popmemz_d8",
    (byte*)"pc_popmem_d16",
    (byte*)"pc_popmem_x8",
    (byte*)"pc_popmem_x4",
    (byte*)"pc_popmem_popmemz_d124",
    (byte*)"pc_popmem_blk",
    (byte*)"pc_popmem_storemem_var",
    (byte*)"pc_popptr_d8_x8",
    (byte*)"pc_popptr_d16",
    (byte*)"pc_popptr_x4",
    (byte*)"pc_popptr_d124",
    (byte*)"pc_popptr_var",
    (byte*)"pc_storeptr_var",
    (byte*)"pc_storeptr_d8",
    (byte*)"pc_storeptr_d124",
    (byte*)"pc_storemem_d8",
    (byte*)"pc_storemem_d16",
    (byte*)"pc_storemem_x8",
    (byte*)"pc_storemem_x4",
    (byte*)"pc_storemem_d124",
    (byte*)"pc_storeptr",
    (byte*)"pc_unstack",
    (byte*)"pc_popretval_d16",
    (byte*)"pc_popretval_d8_d124_var",
    (byte*)"pc_popretval_x8",
    (byte*)"pc_free_d8_d124",
    (byte*)"pc_free_d16",
    (byte*)"pc_free_x4_x8",
    (byte*)"pc_free_var",
    (byte*)"pc_freemem_var",
    (byte*)"pc_add_sub_i64_u64_c64_ref",
    (byte*)"pc_add_i128_u128",
    (byte*)"pc_sub_i128_u128",
    (byte*)"pc_add_sub_mul_div_r32_r64",
    (byte*)"pc_add_var",
    (byte*)"pc_sub_var",
    (byte*)"pc_mul_var",
    (byte*)"pc_div_var",
    (byte*)"pc_idiv_var",
    (byte*)"pc_irem_var",
    (byte*)"pc_iand_var",
    (byte*)"pc_ior_var",
    (byte*)"pc_ixor_var",
    (byte*)"pc_shl_var",
    (byte*)"pc_shr_var",
    (byte*)"pc_min_var",
    (byte*)"pc_max_var",
    (byte*)"pc_power_var",
    (byte*)"pc_append_var",
    (byte*)"pc_appendto_var",
    (byte*)"pc_concat_var",
    (byte*)"pc_concatto_var",
    (byte*)"pc_slice_var",
    (byte*)"pc_in_var",
    (byte*)"pc_neg_var",
    (byte*)"pc_abs_var",
    (byte*)"pc_inot_var",
    (byte*)"pc_notl_var",
    (byte*)"pc_istruel_var",
    (byte*)"pc_sqrt_var",
    (byte*)"pc_sin_var",
    (byte*)"pc_cos_var",
    (byte*)"pc_tan_var",
    (byte*)"pc_asin_var",
    (byte*)"pc_acos_var",
    (byte*)"pc_atan_var",
    (byte*)"pc_exp_var",
    (byte*)"pc_ln_var",
    (byte*)"pc_log_var",
    (byte*)"pc_round_var",
    (byte*)"pc_floor_var",
    (byte*)"pc_ceil_var",
    (byte*)"pc_fract_var",
    (byte*)"pc_asc_var",
    (byte*)"pc_chr_var",
    (byte*)"pc_lwb_var",
    (byte*)"pc_upb_var",
    (byte*)"pc_len_var",
    (byte*)"pc_bounds_var",
    (byte*)"pc_addto_var",
    (byte*)"pc_subto_var",
    (byte*)"pc_multo_var",
    (byte*)"pc_divto_var",
    (byte*)"pc_idivto_var",
    (byte*)"pc_iremto_var",
    (byte*)"pc_iandto_var",
    (byte*)"pc_iorto_var",
    (byte*)"pc_ixorto_var",
    (byte*)"pc_shlto_var",
    (byte*)"pc_shrto_var",
    (byte*)"pc_minto_var",
    (byte*)"pc_maxto_var",
    (byte*)"pc_negto_var",
    (byte*)"pc_absto_var",
    (byte*)"pc_inotto_var",
    (byte*)"pc_notlto_var",
    (byte*)"pc_mul_i64_u64",
    (byte*)"pc_mul_i128_u128",
    (byte*)"pc_idiv_i128_u128",
    (byte*)"pc_idiv_irem_i64_u64",
    (byte*)"pc_neg_i64_u64_c64",
    (byte*)"pc_neg_i128_u128",
    (byte*)"pc_neg_r64",
    (byte*)"pc_neg_r32",
    (byte*)"pc_neg",
    (byte*)"pc_abs_i64_u64_c64",
    (byte*)"pc_abs_r32",
    (byte*)"pc_abs_r64",
    (byte*)"pc_inot_i64_u64",
    (byte*)"pc_notl_d8_d124",
    (byte*)"pc_istruel_d8_d124",
    (byte*)"pc_call",
    (byte*)"pc_return",
    (byte*)"pc_callptr",
    (byte*)"pc_syscall",
    (byte*)"pc_callff",
    (byte*)"pc_callptrff",
    (byte*)"pc_jump",
    (byte*)"pc_jumpcc_i64_u64_ref_c64",
    (byte*)"pc_jumpccimm_i64_u64_c64",
    (byte*)"pc_jumpcc_i128",
    (byte*)"pc_jumpcc_u128",
    (byte*)"pc_jumpcc_r32_r64",
    (byte*)"pc_jumpcc_var",
    (byte*)"pc_jumpfalse_jumptrue_i64_u64_r64_ref_c64",
    (byte*)"pc_jumpinyz_jumpnotinyz_i64_u64",
    (byte*)"pc_casejumpeq_i64_u64_r64_ref_c64",
    (byte*)"pc_setjumpeq_setjumpeqx_d8_d124",
    (byte*)"pc_setjumpne_d8_d124",
    (byte*)"pc_switch",
    (byte*)"pc_switchlab",
    (byte*)"pc_endswitch",
    (byte*)"pc_info",
    (byte*)"pc_setcc_i64_u64_ref_c64",
    (byte*)"pc_setcc",
    (byte*)"pc_setcc_var",
    (byte*)"pc_compare",
    (byte*)"pc_isequal",
    (byte*)"pc_iand_ior_ixor_i64_u64_c64",
    (byte*)"pc_iand_ior_ixor_i128_u128",
    (byte*)"pc_iandc_i64_u64_c64",
    (byte*)"pc_shl_i64_u64",
    (byte*)"pc_shr_i64",
    (byte*)"pc_shr_u64",
    (byte*)"pc_shlc_i64_u64",
    (byte*)"pc_shrc_i64_u64",
    (byte*)"pc_shr",
    (byte*)"pc_in",
    (byte*)"pc_min_max_i64_u64",
    (byte*)"pc_min_max_r64",
    (byte*)"pc_addoffset_ref",
    (byte*)"pc_subref_i64_u64",
    (byte*)"pc_suboffset_ref",
    (byte*)"pc_concat",
    (byte*)"pc_append",
    (byte*)"pc_andl",
    (byte*)"pc_orl",
    (byte*)"pc_index_indexref_ax_sx",
    (byte*)"pc_indexmem_ax",
    (byte*)"pc_indexref_var",
    (byte*)"pc_index_var",
    (byte*)"pc_popindex_var",
    (byte*)"pc_dotindex_var",
    (byte*)"pc_popdotindex_var",
    (byte*)"pc_popindex_storeindex_ax_sx",
    (byte*)"pc_dotindex_i64",
    (byte*)"pc_dotslice",
    (byte*)"pc_popdotindex_d8",
    (byte*)"pc_popdotslice_d8",
    (byte*)"pc_dot_dotref_rec",
    (byte*)"pc_popdot_storedot_rec",
    (byte*)"pc_lwb",
    (byte*)"pc_upb",
    (byte*)"pc_upb_sx",
    (byte*)"pc_len_sx",
    (byte*)"pc_lenstr_ref",
    (byte*)"pc_bounds",
    (byte*)"pc_sqrt_r64",
    (byte*)"pc_sqr_i64",
    (byte*)"pc_sqr_r64",
    (byte*)"pc_power_i64",
    (byte*)"pc_power_r64",
    (byte*)"pc_sign_i64_u64",
    (byte*)"pc_sign_r64",
    (byte*)"pc_sin_cos_tan_asin_acos_atan_ln_log_exp_floor_ceil_r64",
    (byte*)"pc_round",
    (byte*)"pc_fract",
    (byte*)"pc_fmod",
    (byte*)"pc_addto_subto_iandto_iorto_ixorto_i64_u64_ref",
    (byte*)"pc_addmemto_submemto_iandmemto_iormemto_ixormemto_i64_u64_ref",
    (byte*)"pc_addto_subto_iandto_iorto_ixorto_i32_i16_i8_u32_u16_u8_c16_c8",
    (byte*)"pc_addto_multo_r64_r32",
    (byte*)"pc_subto_divto_r64_r32",
    (byte*)"pc_multo_i64_u64_i32_u32_i16_u16_i8_u8",
    (byte*)"pc_idivto_iremto_i64_u64",
    (byte*)"pc_shlto_i64_u64",
    (byte*)"pc_shlcto_i64_u64",
    (byte*)"pc_shrcto_i64_u64",
    (byte*)"pc_shlcmemto_i64_u64",
    (byte*)"pc_shrcmemto_i64_u64",
    (byte*)"pc_shrto_i64",
    (byte*)"pc_shrto_u64",
    (byte*)"pc_minto",
    (byte*)"pc_minto_maxto_i64_u64",
    (byte*)"pc_minto_maxto_r64",
    (byte*)"pc_maxto",
    (byte*)"pc_addoffsetto_suboffsetto_ref",
    (byte*)"pc_concatto",
    (byte*)"pc_appendto",
    (byte*)"pc_negto_inotto_i64_u64",
    (byte*)"pc_negto_r64",
    (byte*)"pc_absto_i64_u64",
    (byte*)"pc_absto_r32_r64",
    (byte*)"pc_incrtomem_d8_d124",
    (byte*)"pc_decrtomem_d8_d124",
    (byte*)"pc_incrtomem_decrtomem_ref",
    (byte*)"pc_incrtomem_var",
    (byte*)"pc_decrtomem_var",
    (byte*)"pc_incrto_decrto_d8_d124",
    (byte*)"pc_incrto_decrto_ref",
    (byte*)"pc_incrto_decrto_var",
    (byte*)"pc_preincrtox_predecrtox_d8_d124",
    (byte*)"pc_postincrtox_postdecrtox_d8_d124",
    (byte*)"pc_preincrtox_predecrtox_ref",
    (byte*)"pc_postincrtox_postdecrtox_ref",
    (byte*)"pc_preincrtox_predecrtox_var",
    (byte*)"pc_postincrtox_postdecrtox_var",
    (byte*)"pc_uwiden_iwiden",
    (byte*)"pc_ifix",
    (byte*)"pc_ifloat",
    (byte*)"pc_fwiden",
    (byte*)"pc_fnarrow",
    (byte*)"pc_softtruncate",
    (byte*)"pc_truncate",
    (byte*)"pc_typepun",
    (byte*)"pc_box",
    (byte*)"pc_unbox",
    (byte*)"pc_swap_d8",
    (byte*)"pc_swap_d124",
    (byte*)"pc_makerange",
    (byte*)"pc_makelist_var",
    (byte*)"pc_makeslice",
    (byte*)"pc_slicelen_sliceupb",
    (byte*)"pc_sliceptr",
    (byte*)"pc_slice_ax",
    (byte*)"pc_slice_ref",
    (byte*)"pc_slice_sx",
    (byte*)"pc_assem",
    (byte*)"pc_assem_d8",
    (byte*)"genasmopnd",
    (byte*)"pc_db_dw_dd_dq",
    (byte*)"pc_resb",
    (byte*)"pc_resw",
    (byte*)"pc_resd",
    (byte*)"pc_resq",
    (byte*)"pc_copyblock",
    (byte*)"pc_csegment",
    (byte*)"pc_isegment",
    (byte*)"pc_zsegment",
    (byte*)"showopndstack",
    (byte*)"showopndstack_s",
    (byte*)"findop",
    (byte*)"findcat",
    (byte*)"dohandler",
    (byte*)"fixdivopnds_d8",
    (byte*)"doshiftn",
    (byte*)"doshiftnto",
    (byte*)"docallff",
    (byte*)"docmaths1",
    (byte*)"docmaths2",
    (byte*)"call128handler_f",
    (byte*)"call128handler_p",
    (byte*)"call64handler_f",
    (byte*)"call64handler_p",
    (byte*)"calldothandler",
    (byte*)"callpopdothandler",
    (byte*)"genstringtable",
    (byte*)"genstring",
    (byte*)"gendb",
    (byte*)"gendw",
    (byte*)"gendbstring",
    (byte*)"gendq",
    (byte*)"gendqname",
    (byte*)"gendqlabel",
    (byte*)"genrealtable",
    (byte*)"genfunctiondata",
    (byte*)"gensysfntable",
    (byte*)"genabsneg",
    (byte*)"mclinit",
    (byte*)"initmcdest",
    (byte*)"genmc",
    (byte*)"genmc_cond",
    (byte*)"lastmc",
    (byte*)"genmcstr",
    (byte*)"newmclopnd",
    (byte*)"duplopnd",
    (byte*)"genxreg",
    (byte*)"genindex",
    (byte*)"writemclblock",
    (byte*)"writemclcode",
    (byte*)"gencomment_mc",
    (byte*)"genstrimm_mc",
    (byte*)"genname_mc",
    (byte*)"genmc_sys",
    (byte*)"getsysfnlabel",
    (byte*)"writemcl",
    (byte*)"strmcl",
    (byte*)"stropnd",
    (byte*)"strvalue",
    (byte*)"setsegment",
    (byte*)"getprocname",
    (byte*)"widenstr",
    (byte*)"strlabel",
    (byte*)"isframe",
    (byte*)"getsizeprefix",
    (byte*)"needsizeprefix",
    (byte*)"changeopndsize",
    (byte*)"applyoffset",
    (byte*)"genint_mc",
    (byte*)"genrealmem_mc",
    (byte*)"genrealimm_mc",
    (byte*)"genimm",
    (byte*)"genlabel_mc",
    (byte*)"genlabel_mem",
    (byte*)"genmem_u_mc",
    (byte*)"genmem_d_mc",
    (byte*)"genmemaddr_u_mc",
    (byte*)"genmemaddr_d_mc",
    (byte*)"genreg",
    (byte*)"genreg0",
    (byte*)"genireg",
    (byte*)"getopndsize_u",
    (byte*)"getopndsize_d",
    (byte*)"getmclcond",
    (byte*)"getmclcond_i",
    (byte*)"getmclcond_u",
    (byte*)"roundsizetg",
    (byte*)"getregname",
    (byte*)"fgetregname",
    (byte*)"issimple0",
    (byte*)"isintconst",
    (byte*)"isint32const",
    (byte*)"sameoperand",
    (byte*)"genmsource",
    (byte*)"roundto",
    (byte*)"pushstack_mc",
    (byte*)"popstack_mc",
    (byte*)"definelabel_mc",
    (byte*)"createfwdlabel_mc",
    (byte*)"definefwdlabel_mc",
    (byte*)"genjumpl_mc",
    (byte*)"getstringindex",
    (byte*)"getrealindex",
    (byte*)"extendstringtable",
    (byte*)"extendrealtable",
    (byte*)"genmc_loadint_d8",
    (byte*)"genmc_loadint_d16",
    (byte*)"genmc_loadint_vari64",
    (byte*)"genmc_loadword_d8",
    (byte*)"genmc_loadreal_d8",
    (byte*)"genmc_loadreal_d4",
    (byte*)"genmc_loadreal_x8",
    (byte*)"genmc_loadreal_x4",
    (byte*)"genmc_loadmem_d8",
    (byte*)"genmc_loadmem_d16",
    (byte*)"genmc_loadmem_x8",
    (byte*)"genmc_loadmem_x4",
    (byte*)"genmc_loadmem_d124",
    (byte*)"genmc_loadmemaddr",
    (byte*)"genmc_loadptr_d8",
    (byte*)"genmc_loadptr_d16",
    (byte*)"genmc_storeptr_d8",
    (byte*)"genmc_storeptr_d16",
    (byte*)"genmc_storeptr_x8",
    (byte*)"genmc_storeptr_x4",
    (byte*)"genmc_loadptr_d124",
    (byte*)"genmc_storeptr_d124",
    (byte*)"genmc_floadmem",
    (byte*)"genmc_loadmemw",
    (byte*)"genmc_loadstr",
    (byte*)"pushalloperands",
    (byte*)"newopnd_d8",
    (byte*)"newopnd_d16",
    (byte*)"newopnd_x8",
    (byte*)"newstackopnd_d8",
    (byte*)"newstackopnd_d16",
    (byte*)"newstackopnd_var",
    (byte*)"newstackopnd_x8",
    (byte*)"genmc_storemem_d8",
    (byte*)"genmc_storemem_d16",
    (byte*)"genmc_storemem_x8",
    (byte*)"genmc_storemem_x4",
    (byte*)"genmc_storemem_d124",
    (byte*)"genmc_storeretval_d8",
    (byte*)"genmc_storeretval_d16_var",
    (byte*)"genmc_storeretval_x8",
    (byte*)"genmc_storememx",
    (byte*)"genmc_storememw",
    (byte*)"getopnds",
    (byte*)"getopndn_d8",
    (byte*)"popopnd",
    (byte*)"poparg",
    (byte*)"newretvalopnd_d8",
    (byte*)"newretvalopnd_d16",
    (byte*)"newretvalopnd_x8",
    (byte*)"getnextreg",
    (byte*)"checktwofreeregs",
    (byte*)"getnexttempreg",
    (byte*)"getnexttempxreg",
    (byte*)"getnextxreg",
    (byte*)"freereg",
    (byte*)"freexreg",
    (byte*)"gerrorc",
    (byte*)"genopndind",
    (byte*)"gettempopnd_d8",
    (byte*)"freetempopnd_d8",
    (byte*)"gettempreg_d8",
    (byte*)"freetempreg_d8",
    (byte*)"gettempopnd_x8",
    (byte*)"freetempopnd_x8",
    (byte*)"swapopnds",
    (byte*)"dupltop",
    (byte*)"genopnd",
    (byte*)"genopndh",
    (byte*)"genopndindh",
    (byte*)"asmstr",
    (byte*)"asmchar",
    (byte*)"asmint",
    (byte*)"checkmcl",
    (byte*)"genss",
    (byte*)"doinstr",
    (byte*)"genbyte",
    (byte*)"genword",
    (byte*)"gendword",
    (byte*)"genqword",
    (byte*)"genopnd",
    (byte*)"addrelocitem",
    (byte*)"getstindex",
    (byte*)"genrel32",
    (byte*)"getdef",
    (byte*)"genabs32",
    (byte*)"genabs64",
    (byte*)"getrel32",
    (byte*)"dofwdrefs",
    (byte*)"genrex",
    (byte*)"isbytesized",
    (byte*)"isdwordsized",
    (byte*)"do_push",
    (byte*)"do_pop",
    (byte*)"do_inc",
    (byte*)"do_neg",
    (byte*)"genamode",
    (byte*)"makemodrm",
    (byte*)"setopsize",
    (byte*)"setaddrsize",
    (byte*)"getdispsize",
    (byte*)"genrm",
    (byte*)"genrmbyte",
    (byte*)"makeam",
    (byte*)"do_arith",
    (byte*)"do_mov",
    (byte*)"getregcoder",
    (byte*)"getregcodeb",
    (byte*)"getregcodebx",
    (byte*)"getregcoderx",
    (byte*)"do_lea",
    (byte*)"do_movsx",
    (byte*)"checkhighreg",
    (byte*)"do_exch",
    (byte*)"do_movsxd",
    (byte*)"do_imul2",
    (byte*)"do_imul3",
    (byte*)"do_shift",
    (byte*)"do_test",
    (byte*)"do_loop",
    (byte*)"do_jcxz",
    (byte*)"do_setcc",
    (byte*)"do_movxmm",
    (byte*)"do_arithxmm",
    (byte*)"do_logicxmm",
    (byte*)"do_convertfloat",
    (byte*)"do_fix",
    (byte*)"do_float",
    (byte*)"do_call",
    (byte*)"do_jmp",
    (byte*)"getcurrdatalen",
    (byte*)"do_cmovcc",
    (byte*)"do_fmem",
    (byte*)"getr32bits",
    (byte*)"genrel8",
    (byte*)"checkshortjump",
    (byte*)"addfwdref",
    (byte*)"switchseg",
    (byte*)"do_movdqx",
    (byte*)"do_popcnt",
    (byte*)"do_bsf",
    (byte*)"extendsymboltable",
    (byte*)"showopnd",
    (byte*)"do_pcmpistri",
    (byte*)"initlib",
    (byte*)"getsizetag",
    (byte*)"buffercreate",
    (byte*)"bufferexpand",
    (byte*)"buffercheck",
    (byte*)"bufferlength",
    (byte*)"bufferelemptr",
    (byte*)"addbyte",
    (byte*)"addword",
    (byte*)"adddword",
    (byte*)"addqword",
    (byte*)"writess",
    (byte*)"writerecord",
    (byte*)"writerelocs",
    (byte*)"writedata",
    (byte*)"writesymboltable",
    (byte*)"writestringtable",
    (byte*)"makesymbol",
    (byte*)"addsymbol",
    (byte*)"initsymboltable",
    (byte*)"strtoaux",
    (byte*)"sectiontoaux",
    (byte*)"addstringentry",
    (byte*)"convertsymboltable",
    (byte*)"writecoff",
    (byte*)"writeexe",
    (byte*)"genexe",
    (byte*)"loadlibs",
    (byte*)"writessdata",
    (byte*)"initsectiontable",
    (byte*)"showssdata",
    (byte*)"showsectiondata",
    (byte*)"showsectioncode",
    (byte*)"showsectionrelocs2",
    (byte*)"gs_value",
    (byte*)"showsymboltable2",
    (byte*)"showimporttable",
    (byte*)"roundtoblock",
    (byte*)"showsections",
    (byte*)"extractlibname",
    (byte*)"scanst",
    (byte*)"relocdata",
    (byte*)"writerecordx",
    (byte*)"writedosstub",
    (byte*)"writepesig",
    (byte*)"writepadding",
    (byte*)"writefileheader",
    (byte*)"writeoptheader",
    (byte*)"writesectionheader",
    (byte*)"writesectiondata",
    (byte*)"getoffsets",
    (byte*)"imported",
    (byte*)"exported",
    (byte*)"addsearchlib",
    (byte*)"setuplibfiles",
    (byte*)"decodeinstr",
    (byte*)"decodetwobyteinstr",
    (byte*)"decodeaddr",
    (byte*)"readbyte",
    (byte*)"readsbyte",
    (byte*)"readword16",
    (byte*)"readint16",
    (byte*)"readword32",
    (byte*)"readint32",
    (byte*)"readint64",
    (byte*)"getreg",
    (byte*)"strreg",
    (byte*)"strfreg",
    (byte*)"printaddrmode",
    (byte*)"genstr",
    (byte*)"genintd",
    (byte*)"genhex",
    (byte*)"readimm",
    (byte*)"readimm8",
    (byte*)"strxmm",
    (byte*)"strmmx",
    (byte*)"decode8087",
    (byte*)"do87arith",
    (byte*)"do87mem",
    (byte*)"getsil",
    (byte*)"getsilx",
    (byte*)"parsemodule",
    (byte*)"readmoduledefs",
    (byte*)"initparser",
    (byte*)"skipsemi",
    (byte*)"makeblock",
    (byte*)"makestmtblock",
    (byte*)"checkequals",
    (byte*)"getcurrline",
    (byte*)"checkbegin",
    (byte*)"checkbeginend",
    (byte*)"checkend",
    (byte*)"readvardef",
    (byte*)"readconstdef",
    (byte*)"readlbrack",
    (byte*)"addlistparam",
    (byte*)"readcast",
    (byte*)"readopc",
    (byte*)"readsprint",
    (byte*)"readsread",
    (byte*)"readcompilervar",
    (byte*)"readcastx",
    (byte*)"checksymbol",
    (byte*)"readtypespec",
    (byte*)"readslicetype",
    (byte*)"readslist",
    (byte*)"readindex",
    (byte*)"readdotsuffix",
    (byte*)"isconstexpr",
    (byte*)"readkeyindex",
    (byte*)"readconstexpr",
    (byte*)"readconstint",
    (byte*)"readprocdef",
    (byte*)"readprocdecl",
    (byte*)"readparams",
    (byte*)"readparams_types",
    (byte*)"readcondsuffix",
    (byte*)"readif",
    (byte*)"readgoto",
    (byte*)"readunless",
    (byte*)"readswitchcase",
    (byte*)"readstop",
    (byte*)"readreturn",
    (byte*)"readdo",
    (byte*)"readto",
    (byte*)"readwhile",
    (byte*)"readrepeat",
    (byte*)"readloopcontrol",
    (byte*)"readprint",
    (byte*)"readread",
    (byte*)"readtry",
    (byte*)"readraise",
    (byte*)"readfor",
    (byte*)"readtypedef",
    (byte*)"readrecordfields",
    (byte*)"readtabledef",
    (byte*)"readclassdef",
    (byte*)"readclassbody",
    (byte*)"readenumtype",
    (byte*)"readimportmodule",
    (byte*)"readimportbody",
    (byte*)"readequivfield",
    (byte*)"readapplyop",
    (byte*)"readrefproc",
    (byte*)"pushproc",
    (byte*)"popproc",
    (byte*)"readassemline",
    (byte*)"readassemblock",
    (byte*)"assembleline",
    (byte*)"readassemopnd",
    (byte*)"makeastring",
    (byte*)"readreturntype",
    (byte*)"readset",
    (byte*)"istypestarter",
    (byte*)"readunit",
    (byte*)"readfactor",
    (byte*)"readterm2",
    (byte*)"readterm",
    (byte*)"readxunit",
    (byte*)"readsunit",
    (byte*)"readmacrodef",
    (byte*)"readimportalias",
    (byte*)"domappedalias",
    (byte*)"readrecase",
    (byte*)"createblock",
    (byte*)"adddocstring",
    (byte*)"rx_typetable",
    (byte*)"rx_unit",
    (byte*)"rx_module",
    (byte*)"rx_deflist",
    (byte*)"rx_passdef",
    (byte*)"rx_unitlist",
    (byte*)"resolvetopname",
    (byte*)"resolvename",
    (byte*)"finddupl",
    (byte*)"resolvedot",
    (byte*)"fixmode",
    (byte*)"fixmode2",
    (byte*)"fixusertypes",
    (byte*)"rx_assem",
    (byte*)"resolve_equiv_name",
    (byte*)"addframevar",
    (byte*)"converteqeq",
    (byte*)"copylistunit",
    (byte*)"copyunit",
    (byte*)"replaceunit",
    (byte*)"expandmacro",
    (byte*)"duplfield",
    (byte*)"do_baseclass",
    (byte*)"tx_allprocs",
    (byte*)"tpass",
    (byte*)"tx_block",
    (byte*)"tx_typetable",
    (byte*)"setmodesize",
    (byte*)"setarraysize",
    (byte*)"setslicesize",
    (byte*)"tcond",
    (byte*)"tx_module",
    (byte*)"tx_passdef",
    (byte*)"tx_unitlist",
    (byte*)"tx_namedef",
    (byte*)"tx_namedconst",
    (byte*)"tx_expr",
    (byte*)"checkconstexpr",
    (byte*)"getconstint",
    (byte*)"tevaluate",
    (byte*)"tevalbinop",
    (byte*)"tevalmonop",
    (byte*)"tevalconvert",
    (byte*)"makenewconst",
    (byte*)"tx_name",
    (byte*)"getdominantmode",
    (byte*)"getdominantmodepp",
    (byte*)"coerceunit",
    (byte*)"tx_add",
    (byte*)"tx_mul",
    (byte*)"tx_shl",
    (byte*)"tx_iand",
    (byte*)"tx_eq",
    (byte*)"tx_isequal",
    (byte*)"tx_lt",
    (byte*)"tx_callproc",
    (byte*)"tx_neg",
    (byte*)"tx_if",
    (byte*)"tx_longif",
    (byte*)"tx_preincr",
    (byte*)"tx_for",
    (byte*)"tx_index",
    (byte*)"tx_keyindex",
    (byte*)"tx_makerange",
    (byte*)"tx_makeset",
    (byte*)"tx_makedict",
    (byte*)"tx_ptr",
    (byte*)"setrecordsize",
    (byte*)"scanrecord",
    (byte*)"roundoffset",
    (byte*)"getalignment",
    (byte*)"tx_convert",
    (byte*)"tx_makelist",
    (byte*)"tx_dot",
    (byte*)"resolvefield",
    (byte*)"comparemodes",
    (byte*)"isboolunit",
    (byte*)"checkbool",
    (byte*)"tx_andl",
    (byte*)"convintconst",
    (byte*)"tx_upb",
    (byte*)"tx_len",
    (byte*)"tx_lenstr",
    (byte*)"tx_lwb",
    (byte*)"tx_bounds",
    (byte*)"tx_sliceptr",
    (byte*)"tx_inot",
    (byte*)"tx_atan2",
    (byte*)"tx_swap",
    (byte*)"tx_sqrt",
    (byte*)"tx_select",
    (byte*)"tx_case",
    (byte*)"tx_notl",
    (byte*)"tx_istruel",
    (byte*)"tx_addto",
    (byte*)"tx_iandto",
    (byte*)"tx_negto",
    (byte*)"tx_typepun",
    (byte*)"tx_bytesize",
    (byte*)"tx_exit",
    (byte*)"tx_goto",
    (byte*)"tx_switch",
    (byte*)"tx_power",
    (byte*)"tx_addroffirst",
    (byte*)"tx_minvalue",
    (byte*)"tx_return",
    (byte*)"tx_dotindex",
    (byte*)"tx_slice",
    (byte*)"tx_assign",
    (byte*)"tx_multassign",
    (byte*)"tx_in",
    (byte*)"getprocretmodes",
    (byte*)"tx_exprlist",
    (byte*)"tx_sign",
    (byte*)"fixvoidunit",
    (byte*)"twiden",
    (byte*)"twidenshort",
    (byte*)"tx_head",
    (byte*)"tx_concat",
    (byte*)"twidenopnd",
    (byte*)"joinstrings",
    (byte*)"removeaddrof",
    (byte*)"tstringslice",
    (byte*)"tx_bitfield",
    (byte*)"deref",
    (byte*)"tmethodcall",
(byte*)""};
static struct msysnewc_procinforec msysnewc__fnexports[]= {
	{0, 0,0, {0,0,0, 0,0,0, 0,0,0, 0,0,0}}}
;
static int64_t msysnewc__fnnprocs=1451;
static int64_t msysnewc__fnnexports=0;
static int64_t msysnewc_fmtparam;
int64_t msysnewc_needgap = (int64_t)0;
static int64_t msysnewc_outdev = (int64_t)1;
static void *  msysnewc_outchan = 0;
static uint8_t *  msysnewc_fmtstr = 0;
static void *  msysnewc_outchan_stack[10];
static int64_t msysnewc_outdev_stack[10];
static uint8_t *  msysnewc_fmtstr_stack[10];
static byte msysnewc_needgap_stack[10];
static uint8_t *  msysnewc_ptr_stack[10];
static int64_t msysnewc_niostack = (int64_t)0;
static uint8_t msysnewc_digits[16] = {
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F'
};
static struct msysnewc_fmtrec msysnewc_defaultfmt = {
    (uint8_t)0u,
    (int8_t)0,
    (uint8_t)10u,
    (uint64_t)0u,
    ' ',
    'f',
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    'R',
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    (uint8_t)0u
};
static uint8_t *  msysnewc_rd_buffer;
static int64_t msysnewc_rd_length;
static uint8_t *  msysnewc_rd_pos;
static uint8_t *  msysnewc_rd_lastpos;
static int64_t msysnewc_termchar;
static int64_t msysnewc_itemerror;
int64_t msysnewc_nsysparams;
uint8_t *  msysnewc_sysparams[128];
static uint64_t msysnewc_callbackstack[9][8];
static int64_t msysnewc_ncallbacks = (int64_t)0;
static uint64_t msysnewc_mask63 = (uint64_t)9223372036854775807u;
static double msysnewc_offset64 = (double)9223372036854775800.;
static double msysnewc_offset32 = (double)9223372036854775800.;
int64_t mlib_mdebug;
uint64_t mlib_allocupper[301];
int64_t mlib_alloccode;
int64_t mlib_allocbytes;
int64_t mlib_fdebug = (int64_t)0;
int64_t mlib_rfsize;
static uint64_t mlib_maxmemory;
static int64_t mlib_maxalloccode;
static byte mlib_pcm_setup = (uint8_t)0u;
static int64_t mlib_show = (int64_t)0;
int64_t mlib_memtotal = (int64_t)0;
int64_t mlib_smallmemtotal = (int64_t)0;
int64_t mlib_smallmemobjs = (int64_t)0;
int64_t mlib_maxmemtotal = (int64_t)0;
static int32_t *  mlib_memalloctable[500001];
static int32_t mlib_memallocsize[500001];
static byte *  mlib_pcheapstart;
static byte *  mlib_pcheapend;
static byte *  mlib_pcheapptr;
static byte mlib_sizeindextable[2049];
uint64_t *  mlib_freelist[9];
uint8_t *  mlib_pmnames[6] = {(uint8_t*)"pm_end",(uint8_t*)"pm_option",(uint8_t*)"pm_sourcefile",(uint8_t*)"pm_libfile",(uint8_t*)"pm_colon",(uint8_t*)"pm_extra"};
static int64_t mlib_seed[2] = {(int64_t)2993073034246558322,(int64_t)1617678968452121188};
static int64_t oslinux_init_flag = (int64_t)0;
byte mm_support_bytemasks[8] = {(uint8_t)1u,(uint8_t)2u,(uint8_t)4u,(uint8_t)8u,(uint8_t)16u,(uint8_t)32u,(uint8_t)64u,(uint8_t)128u};
static int64_t mm_lib_autotypeno = (int64_t)0;
int64_t mm_lib_nextavindex = (int64_t)0;
static int64_t mm_lib_nextsvindex = (int64_t)0;
static struct mlib_strbuffer mm_lib_exprstrvar;
static struct mlib_strbuffer *  mm_lib_exprstr = &mm_lib_exprstrvar;
static int64_t mm_lib_opc_codes[46] = {
    (int64_t)43,
    (int64_t)44,
    (int64_t)45,
    (int64_t)46,
    (int64_t)109,
    (int64_t)36,
    (int64_t)37,
    (int64_t)38,
    (int64_t)39,
    (int64_t)40,
    (int64_t)41,
    (int64_t)50,
    (int64_t)51,
    (int64_t)52,
    (int64_t)111,
    (int64_t)53,
    (int64_t)54,
    (int64_t)12,
    (int64_t)13,
    (int64_t)15,
    (int64_t)151,
    (int64_t)152,
    (int64_t)153,
    (int64_t)154,
    (int64_t)155,
    (int64_t)156,
    (int64_t)157,
    (int64_t)158,
    (int64_t)159,
    (int64_t)160,
    (int64_t)161,
    (int64_t)162,
    (int64_t)163,
    (int64_t)164,
    (int64_t)165,
    (int64_t)166,
    (int64_t)167,
    (int64_t)170,
    (int64_t)171,
    (int64_t)172,
    (int64_t)173,
    (int64_t)145,
    (int64_t)147,
    (int64_t)146,
    (int64_t)148,
    (int64_t)0
};
static uint8_t *  mm_lib_opc_names[46] = {
    (uint8_t*)"+",
    (uint8_t*)"-",
    (uint8_t*)"*",
    (uint8_t*)"/",
    (uint8_t*)"-",
    (uint8_t*)"=",
    (uint8_t*)"<>",
    (uint8_t*)"<",
    (uint8_t*)"<=",
    (uint8_t*)">",
    (uint8_t*)">=",
    (uint8_t*)"iand",
    (uint8_t*)"ior",
    (uint8_t*)"ixor",
    (uint8_t*)"inot",
    (uint8_t*)"<<",
    (uint8_t*)">>",
    (uint8_t*)"and",
    (uint8_t*)"or",
    (uint8_t*)"not",
    (uint8_t*)"+:=",
    (uint8_t*)"-:=",
    (uint8_t*)"*:=",
    (uint8_t*)"/:=",
    (uint8_t*)"%:=",
    (uint8_t*)"rem:=",
    (uint8_t*)"iand:=",
    (uint8_t*)"ior:=",
    (uint8_t*)"ixor:=",
    (uint8_t*)"<<:=",
    (uint8_t*)">>:=",
    (uint8_t*)"and:=",
    (uint8_t*)"or:=",
    (uint8_t*)"append:=",
    (uint8_t*)"concat:=",
    (uint8_t*)"min:=",
    (uint8_t*)"max:=",
    (uint8_t*)"-:=",
    (uint8_t*)"abs:=",
    (uint8_t*)"inot:=",
    (uint8_t*)"not:=",
    (uint8_t*)"++",
    (uint8_t*)"++",
    (uint8_t*)"--",
    (uint8_t*)"--",
    (uint8_t*)""
};
static struct mm_decls_unitrec *  mm_lib_unitheapptr = 0;
static int64_t mm_lib_remainingunits = (int64_t)0;
static struct mlib_strbuffer mm_lib_sbuffer;
struct mlib_strbuffer *  mm_lib_dest = &mm_lib_sbuffer;
uint8_t *  mm_lib_framevarname;
int64_t mm_lex_nlookups;
int64_t mm_lex_nclashes;
static uint8_t *  mm_lex_lxstart_stack[20];
static uint8_t *  mm_lex_lxsptr_stack[20];
static int64_t mm_lex_lxfileno_stack[20];
static int64_t mm_lex_lxlineno_stack[20];
static byte mm_lex_isfile_stack[20];
static int64_t mm_lex_sourcelevel = (int64_t)0;
static uint8_t *  mm_lex_lxstart;
static uint8_t *  mm_lex_lxsptr;
static int64_t mm_lex_lxifcond;
static int64_t mm_lex_longsuffix;
struct mm_decls_strec mm_lex_hashtable[32768];
static uint8_t *  mm_lex_maxnumlist[16] = {
    (uint8_t*)"",
    (uint8_t*)"1111111111111111111111111111111111111111111111111111111111111111",
    (uint8_t*)"11112220022122120101211020120210210211220",
    (uint8_t*)"33333333333333333333333333333333",
    (uint8_t*)"2214220303114400424121122430",
    (uint8_t*)"3520522010102100444244423",
    (uint8_t*)"45012021522523134134601",
    (uint8_t*)"1777777777777777777777",
    (uint8_t*)"145808576354216723756",
    (uint8_t*)"18446744073709551615",
    (uint8_t*)"335500516A429071284",
    (uint8_t*)"839365134A2A240713",
    (uint8_t*)"219505A9511A867B72",
    (uint8_t*)"8681049ADB03DB171",
    (uint8_t*)"2C1D56B648C6CD110",
    (uint8_t*)"FFFFFFFFFFFFFFFF"
};
static int64_t mm_lex_maxnumlen[16];
static int64_t mm_diags_currlineno;
uint8_t *  mm_genwx64_stdlibnames[5] = {(uint8_t*)"msysnew.m",(uint8_t*)"mlib.m",(uint8_t*)"clibnew.m",(uint8_t*)"oswindows.m",(uint8_t*)"oswindll.m"};
uint8_t *  mm_genwx64_stdlibtext[5] = {\
(uint8_t*)"import clib\r\nimport mlib\r\n\r\nglobal record procinforec=\r\n\tword16\t\tfnindex\r\n\tbyte\t\trettype\r\n\tbyte\t\tnparams\r\n\t[12]byte\tparamlist\r\nend\r\n\r\n!for print/read routines\r\n!------------------------------------------\r\nrecord fmtrec=\t! (default)\r\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\r\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\r\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\r\n\r\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\r\n\tchar\tpadchar\t\t! Pc, Z (' ')\r\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\r\n\r\n\tchar\tplus\t\t! (0)   0 or '+'\r\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\r\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\r\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\r\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\r\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\r\n\tchar\tcharmode\t! C,D (0)  0 or 'C' or 'D'\to/p int as int or single char or double/multi-char\r\n\tchar\theapmode\t! M (0)  'M' for str-functions, return ptr tp heap string\r\n\tchar\tparam\t\t! Use int value for <fmtparam>\r\n\tbyte\tspare\r\nend\r\n\r\nint fmtparam\t\t\t!as set with :'V'\r\n\r\nenum (std_io,file_io,str_io)\r\n\r\nconst comma = ','\r\n\r\nglobal int needgap\t\t\t= 0\r\nint outdev\t\t\t= std_io\r\nfilehandle outchan\t= nil\r\nref char fmtstr \t= nil\r\n\r\nconst maxiostack=10\r\n[maxiostack]filehandle\toutchan_stack\r\n[maxiostack]int\t\t\toutdev_stack\r\n[maxiostack]ref char\tfmtstr_stack\r\n[maxiostack]byte\t\tneedgap_stack\r\n\r\n[maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\r\nint niostack=0\r\n\r\n[0:]char digits=A\"0123456789ABCDEF\"\r\nconst onesixty=360\r\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\r\n\r\n!Read buffer vars\r\nconst rd_buffersize = 16384\t!total capacity of line buffer\r\n\r\nref char rd_buffer\t\t! point to start of read buffer\r\nint rd_length\t\t\t! length of this line (as read by readln)\r\nref char rd_pos\t\t\t! current position it's up to (next read starts here)\r\nref char rd_lastpos\t\t! set by sread() just before reading used for reread()\r\nint termchar\t\t\t! terminator char set by readxxx()\r\nint itemerror\t\t\t!\tset by some read functions, eg for reals\r\n\r\n!------------------------------------------\r\n\r\nconst maxparam=128\r\nglobal int nsysparams\r\nglobal [maxparam]ichar sysparams\r\n\r\nconst maxcallback=8\r\n[0..maxcallback,8]word64 callbackstack\r\nint ncallbacks=0\r\n\r\nword64 mask63\t= 0x7FFF'FFFF'FFFF'FFFF\r\nreal offset64\t= 9223372036854775808.0\t\t! 2**63 as r64\r\nreal offset32\t= 9223372036854775808.0\t\t! 2**63 as r32\r\n\r\nglobal proc m$init=\r\nint32 nargs\r\nint nargs64\r\nref[]ichar args\r\nref[]ichar env\r\nstatic [128]byte startupinfo\t\t\t! 68 or 104 bytes\r\nint res\r\nichar s\r\n\r\n!CPL \"M$INIT\"\r\n\r\nres:=__getmainargs(&nargs,cast(&args),cast(&env),0,cast(&startupinfo))\r\n\r\nnsysparams:=nargs\r\n\r\nif nsysparams>maxparam then\r\n\tprintf(\"Too many params\\n\")\r\n\tstop 50\r\nfi\r\n\r\nnargs64:=nargs\t\t\t!bug when using 32-bit limit when compild with mm\r\nfor i:=1 to nargs64 do\r\n\tsysparams[i]:=args^[i]\r\nod\r\nend\r\n\r\nglobal proc m$stop(int n)=\r\n\r\nassem\r\n\tmov d10,[n]\r\n\tmov d0,`exit\r\n\tcall m$callff_4\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_4=\r\n!0..4 params have been loaded to R10..13\r\n!The foreign function address is in D0\r\n!set up the stack, keeping it aligned, and call the function, adjusting the\r\n!stack before returning.\r\n!For functions rather than procs, the return value will be in A0/D0/XMM0\r\n\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\r\n\tsub Dstack,40\t\t\t!add an extra 8 bytes to align\r\n\tcall D0\r\n\tadd Dstack,40\t\t\t!unstack the dummy 4 params, plus 8 more bytes\r\n\tret\r\n\r\naligned:\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,32\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_5=\r\n!one param already pushed. \r\n!\r\n!There might be another way to do this:\r\n!leave retaddr in place, move P5 this side of retaddr, but leave original P5\r\n!there, and use retn 8 to skip it\r\n\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\tpush D2\t\t\t\t\t!P5\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,48\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,40\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_6=\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,56\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,48\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_7=\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,64\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,56\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_8=\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,72\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,64\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_9=\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,80\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,72\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_10=\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\tpop D7\t\t\t\t\t!P10\r\n\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\r\n\tpush D7\t\t\t\t\t!P10\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,88\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\tpop D7\t\t\t\t\t!P10\r\n\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\r\n\tpush D7\t\t\t\t\t!P10\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,80\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_11=\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\tpop D7\t\t\t\t\t!P10\r\n\tpop D8\t\t\t\t\t!P11\r\n\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\r\n\tpush D8\t\t\t\t\t!P11\r\n\tpush D7\t\t\t\t\t!P10\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,96\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\tpop D7\t\t\t\t\t!P10\r\n\tpop D8\t\t\t\t\t!P11\r\n\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\r\n\tpush D8\t\t\t\t\t!P11\r\n\tpush D7\t\t\t\t\t!P10\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,88\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_12=\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\tpop D7\t\t\t\t\t!P10\r\n\tpop D8\t\t\t\t\t!P11\r\n\tpop D9\t\t\t\t\t!P12\r\n\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\r\n\tpush D9\t\t\t\t\t!P12\r\n\tpush D8\t\t\t\t\t!P11\r\n\tpush D7\t\t\t\t\t!P10\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,104\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\tpop D7\t\t\t\t\t!P10\r\n\tpop D8\t\t\t\t\t!P11\r\n\tpop D9\t\t\t\t\t!P12\r\n\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\r\n\tpush D9\t\t\t\t\t!P12\r\n\tpush D8\t\t\t\t\t!P11\r\n\tpush D7\t\t\t\t\t!P10\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,96\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal threadedproc m$callff_14=\r\nstatic word64 p13,p14\r\nassem\r\n\ttest Astack,8\t\t\t!should be 0 if aligned\r\n\tjz aligned\r\nunaligned:\t\t\t\t\t!need to move param5 down\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\tpop D7\t\t\t\t\t!P10\r\n\tpop D8\t\t\t\t\t!P11\r\n\tpop D9\t\t\t\t\t!P12\r\n\tpop u64 [p13]\t\t\t!P12\r\n\tpop u64 [p14]\t\t\t!P14\r\n\r\n\tpush D1\t\t\t\t\t!ret addr on top\r\n\tsub Dstack,8\t\t\t!dummy value to align stack\r\n\r\n\tpush u64 [p14]\t\t!P14\r\n\tpush u64 [p13]\t\t!P13\r\n\tpush D9\t\t\t\t\t!P12\r\n\tpush D8\t\t\t\t\t!P11\r\n\tpush D7\t\t\t\t\t!P10\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,120\t\t\t!pop all, including dummy value\r\n\tret\r\n\r\naligned:\t\t\t\t\t!one value and ret addr pushed, allow space for four more\r\n\tpop D1\t\t\t\t\t!ret addr\r\n\r\n\tpop D2\t\t\t\t\t!P5\r\n\tpop D3\t\t\t\t\t!P6\r\n\tpop D4\t\t\t\t\t!P7\r\n\tpop D5\t\t\t\t\t!P8\r\n\tpop D6\t\t\t\t\t!P9\r\n\tpop D7\t\t\t\t\t!P10\r\n\tpop D8\t\t\t\t\t!P11\r\n\tpop D9\t\t\t\t\t!P12\r\n\tpop u64 [p13]\t\t\t!P12\r\n\tpop u64 [p14]\t\t\t!P14\r\n\r\n\tpush D1\t\t\t\t\t!push ret addr back\r\n\r\n\tpush u64 [p14]\t\t!P14\r\n\tpush u64 [p13]\t\t!P13\r\n\tpush D9\t\t\t\t\t!P12\r\n\tpush D8\t\t\t\t\t!P11\r\n\tpush D7\t\t\t\t\t!P10\r\n\tpush D6\t\t\t\t\t!P9\r\n\tpush D5\t\t\t\t\t!P8\r\n\tpush D4\t\t\t\t\t!P7\r\n\tpush D3\t\t\t\t\t!P6\r\n\tpush D2\t\t\t\t\t!P5 now this side of ret address\r\n\r\n\tsub Dstack,32\r\n\tcall D0\r\n\tadd Dstack,112\t\t\t!pop all\r\n\tret\r\nend\r\n\r\nend\r\n\r\nglobal proc m$pushcallback=\r\n!save registers rbx, rsi,rdi, r12..r15 to small stack\r\n!Note must take care not to overwrite any of those while saving\r\n\r\n!if ncallbacks=maxcallback then\r\n!\tprintln \"Callback overflow\"\r\n!\tstop 1\r\n!fi\r\n\r\nassem\r\n\tinc word32 [ncallbacks]\r\n\tmov A2,[ncallbacks]\r\n\tshl A2,6\t\t\t\t\t!8x8 bytes is size per entry\r\n\tlea D2,[A2+callbackstack]\r\n\r\n\tmov [D2],rbx\r\n\tmov [D2+8],rsi\r\n\tmov [D2+16],rdi\r\n\tmov [D2+24],r12\r\n\tmov [D2+32],r13\r\n\tmov [D2+40],r14\r\n\tmov [D2+48],r15\r\nend\r\nend\r\n\r\nglobal proc m$popcallback=\r\n!restore registers rbx, rsi,rdi, r12..r15 from small stack\r\nassem\r\n\tmov A2,[ncallbacks]\r\n\tshl A2,6\t\t\t\t\t!8x8 bytes is size per entry\r\n\tlea D2,[A2+callbackstack]\r\n\tmov rbx,[D2]\r\n\tmov rsi,[D2+8]\r\n\tmov rdi,[D2+16]\r\n\tmov r12,[D2+24]\r\n\tmov r13,[D2+32]\r\n\tmov r14,[D2+40]\r\n\tmov r15,[D2+48]\r\n\tdec word32 [ncallbacks]\r\nend\r\nend\r\n\r\nglobal function m$lenstr_stringz(ref char s)int=\r\n\tstrlen(s)\r\nend\r\n\r\nglobal function m$getdotindex(word64 a,int i)int=\r\n!return (a iand (1dw<<i))>>i\r\nreturn (a iand (1<<i))>>i\r\nend\r\n\r\nglobal proc m$setdotindex(ref word64 a, int i,x)=\r\nref word32 a32\r\n\r\n!see comments on setdotslice\r\nif i>=32 then\r\n\ta^:=(a^ iand inot (1<<i)) ior (word64(x)<<i)\r\n\r\nelse\r\n\ta32:=cast(a)\r\n\ta32^:=(a32^ iand inot (1<<i)) ior (word(x)<<i)\r\nfi\r\nend\r\n\r\nglobal function m$getdotslice(word64 a,int i,j)int=\r\nif i>=j then\r\n\treturn (a>>j)  iand  inot(0xFFFF'FFFF'FFFF'FFFF<<(i-j+1))\r\nelse\r\n\treturn (a>>i)  iand  inot(0xFFFF'FFFF'FFFF'FFFF<<(j-i+1))\r\nfi\r\nend\r\n\r\nglobal proc m$setdotslice(ref word64 a, int i,j,word64 x)=\r\n!a^:=(a^ iand inot (1dw<<i)) ior (word64(x)<<i)\r\nint w\r\nword64 mask64\r\nword mask\r\nref word32 a32\r\n\r\nif i>j then println \"SETDOTSLICE?\"; stop 52 fi\r\n\r\n!when j>=32, assume 64 bit dest, otherwise assume 32 bits to avoid writing\r\n!to bytes beyond the 32-bit value\r\n!THIS WILL BE A PROBLEM IF writing to 8/16 bit values too\r\n\r\nif j>=32 then\r\n\tmask64:=inot((0xFFFF'FFFF'FFFF'FFFF<<(j-i+1)))<<i\t\t\t!shifted field of w 1s\r\n\ta^:=(a^ iand inot mask64) ior x<<i\r\nelse\r\n\ta32:=cast(a)\r\n\tmask:=inot((0xFFFF'FFFF'FFFF'FFFF<<(j-i+1)))<<i\t\t\t!shifted field of w 1s\r\n\ta32^:=(a32^ iand inot mask) ior x<<i\r\nfi\r\n\r\nend\r\n\r\nfunction m$get_nprocs:int=\r\n\tassem\r\n\t\tmov D0,[$nprocs]\r\n\tend\r\nend\r\n\r\nfunction m$get_procname(int n)ichar=\r\n\tassem\r\n\t\tlea D0,[$procnames]\r\n\t\tmov D1,[n]\r\n\t\tmov D0,[D0+D1*8-8]\r\n!\t\tmov D0,[sss]\r\n\tend\r\nend\r\n\r\nfunction m$get_procaddr(int n)ref proc=\r\n\tassem\r\n\t\tlea D0,[$procaddrs]\r\n\t\tmov D1,[n]\r\n\t\tmov D0,[D0+D1*8-8]\r\n\tend\r\nend\r\n\r\nglobal function m$get_nexports:int=\r\n\tassem\r\n\t\tmov D0,[$nexports]\r\n\tend\r\nend\r\n\r\nglobal function m$get_procexport(int n)ref void=\r\n\tassem\r\n\t\tlea D0,[$procexports]\r\n\t\tmov D1,[n]\r\n\t\tshl D1,1\r\n\t\tlea D0,[D0+D1*8-16]\r\n\tend\r\nend\r\n\r\nproc pushio=\r\n\tif niostack>=maxiostack then\r\n\t\tprintf(\"Too many io levels\\n\")\r\n\t\tstop 53\r\n\tfi\r\n\t++niostack\r\n\toutchan_stack[niostack]\t:= outchan\r\n\toutdev_stack[niostack]\t:= outdev\r\n\tfmtstr_stack[niostack]\t:= fmtstr\r\n\tneedgap_stack[niostack]\t:= needgap\r\n\tneedgap:=0\r\n\tfmtstr:=nil\r\n\toutchan:=nil\r\nend\r\n\r\nglobal proc m$print_startfile(ref void dev)=\r\n\tpushio()\r\n\toutchan:=cast(dev)\r\n\tif dev then\r\n\t\toutdev:=file_io\r\n\telse\r\n\t\toutdev:=std_io\r\n\tfi\r\nend\r\n\r\nglobal proc m$print_startstr(ref char s)=\r\n\tref ref char p\r\n\tpushio()\r\n\r\n\tptr_stack[niostack]:=s\r\n\tp:=&ptr_stack[niostack]\r\n\r\n\toutchan:=cast(p)\r\n\toutdev:=str_io\r\nend\r\n\r\nglobal proc m$print_startptr(ref ref char p)=\r\n\tpushio()\r\n\r\n\toutchan:=cast(p)\r\n\toutdev:=str_io\r\nend\r\n\r\nglobal proc m$print_startcon=\r\n\tpushio()\r\n\toutdev:=std_io\r\nend\r\n\r\nglobal proc m$print_setfmt(ref char format)=\r\n\tfmtstr:=format\r\nend\r\n\r\nglobal proc m$print_end=\r\n\tneedgap:=0\r\n\tnextfmtchars(1)\r\n\tif niostack=0 then return fi\r\n\toutchan\t:= outchan_stack[niostack]\r\n\toutdev\t:= outdev_stack[niostack]\r\n\tfmtstr\t:= fmtstr_stack[niostack]\r\n\tneedgap\t:= needgap_stack[niostack]\r\n\t--niostack\r\nend\r\n\r\nglobal proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\r\n\tarray[20]char s\r\n\r\n\tif fmtstyle=nil then\r\n\t\tfmtstyle:=\"z8H\"\r\n\tfi\r\n\tm$print_u64(a,fmtstyle)\r\nend\r\n\r\n!global proc m$print_bool(int a,ichar fmtstyle=nil)=\r\n!\t[20]char s\r\n!\tnextfmtchars()\r\n!\tprintstr((a|\"T\"|\"F\"))\r\n!\tneedgap:=1\r\n!end\r\n\r\nglobal proc m$print_i64(int64 a,ichar fmtstyle=nil)=\r\n\tarray[40]char s\r\n\tfmtrec fmt\r\n\tint n\r\n\r\n!CPL \"PRINTI64\",=FMTSTYLE\r\n!\r\n\r\n\tnextfmtchars()\r\n\r\n\tif fmtstyle=nil then\r\n\t\tif a>=0 then\r\n\t\t\tn:=u64tostr(a,&.s,10,0)\r\n\t\telse\r\n\t\t\ts[1]:='-'\r\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\r\n\t\tfi\r\n\t\tprintstr_n(&.s,n)\r\n\r\n\telse\r\n\t\tstrtofmt(fmtstyle,-1,&fmt)\r\n\t\tif fmt.param='V' then\r\n\t\t\tfmtparam:=a\r\n!CPL \"SET FMTPARAM TO\",A\r\n\t\t\tneedgap:=0\r\n\t\telse\r\n\t\t\ttostr_i64(a,&fmt)\r\n\t\tfi\r\n\tfi\r\n\tneedgap:=1\r\nend\r\n\r\nglobal proc m$print_u64(word64 a,ichar fmtstyle=nil)=\r\n\tarray[40]char s\r\n\tfmtrec fmt\r\n\r\n\tnextfmtchars()\r\n\tif fmtstyle=nil then\r\n\t\tsprintf(&.s,\"%llu\",a)\r\n\t\tprintstr(&.s)\r\n\telse\r\n\t\tstrtofmt(fmtstyle,-1,&fmt)\r\n\t\ttostr_u64(a,&fmt)\r\n\tfi\r\n\tneedgap:=1\r\nend\r\n\r\nglobal proc m$print_i128(int128 a,ichar fmtstyle=nil)=\r\n\tarray[40]char s\r\n\tfmtrec fmt\r\n\r\n\tnextfmtchars()\r\n\tstrtofmt(fmtstyle,-1,&fmt)\r\n\tif a>=0 then\r\n\t\ttostr_u128(a,&fmt,0)\r\n\telse\r\n\t\ttostr_u128(-a,&fmt,1)\r\n\tfi\r\n\r\n\tneedgap:=1\r\nend\r\n\r\nglobal proc m$print_u128(word128 a,ichar fmtstyle=nil)=\r\n\tarray[40]char s\r\n\tfmtrec fmt\r\n\r\n\tnextfmtchars()\r\n\tstrtofmt(fmtstyle,-1,&fmt)\r\n\ttostr_u128(a,&fmt,0)\r\n\tneedgap:=1\r\nend\r\n\r\nglobal proc m$print_r64(real x,ichar fmtstyle=nil)=\r\n\tarray[360]char s\r\n\tfmtrec fmt\r\n\r\n\tnextfmtchars()\r\n\tif fmtstyle=nil then\r\n\t\tsprintf(&.s,\"%f\",x)\r\n\t\tprintstr(&.s)\r\n\telse\r\n\t\tstrtofmt(fmtstyle,-1,&fmt)\r\n\t\ttostr_r64(x,&fmt)\r\n\tfi\r\n\r\n\tneedgap:=1\r\nend\r\n\r\nglobal proc m$print_r32(real32 x,ichar fmtstyle=nil)=\r\n\tm$print_r64(x,fmtstyle)\r\nend\r\n\r\nglobal proc m$print_c8(int64 a,ichar fmtstyle=nil)=\r\n\tarray[40]char s\r\n\tfmtrec fmt\r\n\tint n\r\n\r\n\tnextfmtchars()\r\n\r\n\ts[1]:=a\r\n\ts[2]:=0\r\n\tprintstr(&.s)\r\n\tneedgap:=1\r\nend\r\n\r\nglobal proc m$print_str(ichar s, fmtstyle=nil)=\r\n\tnextfmtchars()\r\n\tfmtrec fmt\r\n\tif fmtstyle=nil then\r\n\t\tprintstr(s)\r\n\telse\r\n\t\tstrtofmt(fmtstyle,-1,&fmt)\r\n\t\ttostr_str(s,&fmt)\r\n\tfi\r\n\tneedgap:=1\r\nend\r\n\r\n!global proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\r\n!\tnextfmtchars()\r\n!\tfmtrec fmt\r\n!\tif fmtstyle=nil then\r\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\r\n!\telse\r\n!\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\r\n!!\t\tstrtofmt(fmtstyle,-1,&fmt)\r\n!!\t\ttostr_str(s,&fmt)\r\n!\tfi\r\n!\tneedgap:=1\r\n!end\r\n\r\n!global proc m$print_flexstr(object s, ichar fmtstyle=nil)=\r\n!\tnextfmtchars()\r\n!\tfmtrec fmt\r\n!\r\n!\tif fmtstyle=nil then\r\n!\t\tif s^.length then\r\n!\t\t\tprintstr_n(s^.strptr,s^.length)\r\n!\t\tfi\r\n!\telse\r\n!\t\tstrtofmt(fmtstyle,-1,&fmt)\r\n!\t\ttostr_str(str_stringz(s),&fmt)\r\n!\tfi\r\n!\tneedgap:=1\r\n!end\r\n\r\nglobal proc m$print_newline=\r\n\tneedgap:=0\r\n\tnextfmtchars(1)\r\n\tprintstr(\"\\w\")\r\nend\r\n\r\nglobal proc m$print_nogap=\r\n\tneedgap:=0\r\nend\r\n\r\nglobal proc printstr(ichar s)=\r\n\tint n\r\n\tref ref char p\r\n\r\n\tcase outdev\r\n\twhen std_io then\r\n\t\tprintf(\"%s\",s)\r\n\twhen file_io then\r\n\t\tfprintf(outchan,\"%s\",s)\r\n\twhen str_io then\r\n\t\tp:=cast(outchan)\r\n\t\tstrcpy(p^,s)\r\n\t\tp^+:=strlen(s)\r\n\tesac\r\nend\r\n\r\nglobal proc printstr_n(ichar s,int n=-1)=\r\n\tref ref char p\r\n\r\n\tcase n\r\n\twhen -1 then n:=strlen(s)\r\n\twhen 0 then return\r\n\tesac\r\n\r\n\tcase outdev\r\n\twhen str_io then\r\n\t\tp:=cast(outchan)\r\n\t\tmemcpy(p^,s,n)\r\n\t\tp^+:=n\r\n\t\tp^^:=0\r\n\twhen file_io then\r\n\t\tfprintf(outchan,\"%.*s\",n,s)\r\n\twhen std_io then\r\n\t\tprintf(\"%.*s\",n,s)\r\n\tesac\r\nend\r\n\r\nglobal proc printstrn_app(ichar s, int length, filehandle f=nil)=\r\nif length then\r\n!\temitc \"printf(\"\"%.*s\"\",(i32)length,s);\"\r\n\tif f=nil then\r\n\t\tprintf(\"%.*s\",length,s)\r\n\telse\r\n\t\tfprintf(f,\"%.*s\",length,s)\r\n\tfi\r\nfi\r\nend\r\n\r\nproc printchar(int ch)=\r\n\tref ref char p\r\n\tcase outdev\r\n\twhen std_io then\r\n\t\tprintf(\"%c\",ch)\r\n\twhen file_io then\r\n\t\tfprintf(outchan,\"%c\",ch)\r\n\twhen str_io then\r\n\t\tp:=cast(outchan)\r\n\t\tp^^:=ch\r\n\t\tp^+:=1\r\n\t\tp^^:=0\r\n\tesac\r\nend\r\n\r\nglobal proc nextfmtchars(int lastx=0)=\r\n\tchar c\r\n\tref char pstart\r\n\tint n\r\n\r\n\tif not fmtstr then\t\t\t!format not in use\r\n\t\tif needgap then\r\n\t\t\tprintchar(' ')\r\n!\t\tprintstr_n(\" \",1)\r\n\t\tfi\r\n\t\tneedgap:=0\r\n\t\treturn\r\n\tfi\r\n\r\n\tpstart:=fmtstr\r\n\tn:=0\r\n\r\n\twhile (1) do\r\n\t\tc:=fmtstr^\r\n\t\tswitch c\r\n\t\twhen '#' then\r\n\t\t\tif lastx then\r\n\t\t\t\tgoto skip\r\n\t\t\tfi\r\n\t\t\t++fmtstr\r\n\t\t\tif n then\r\n\t\t\t\tprintstr_n(pstart,n)\r\n\t\t\tfi\r\n\t\t\treturn\r\n\t\twhen 0 then\r\n\t\t\tif n then\r\n\t\t\t\tprintstr_n(pstart,n)\r\n\t\t\telsif not lastx then\r\n!\t\t\t\tprintstr_n(\"|\",1)\r\n\t\t\tfi\r\n\t\t\treturn\r\n\t\twhen '~' then\r\n\t\t\tif n then\r\n\t\t\t\tprintstr_n(pstart,n)\r\n\t\t\t\tn:=0\r\n\t\t\tfi\r\n\t\t\t++fmtstr\r\n\t\t\tc:=fmtstr^\r\n\t\t\tif c then\r\n\t\t\t\t++fmtstr\r\n\t\t\t\tprintchar(c)\r\n\t\t\tfi\r\n\t\t\tpstart:=fmtstr\r\n\t\telse\r\n\tskip::\r\n\t\t\t++n\r\n\t\t\t++fmtstr\r\n\t\tendswitch\r\n\tod\r\nend\r\n\r\nglobal proc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\r\n!convert format code string in s, to fmtrec at fmt^\r\n!Format code is a string containing the following char codes (upper or lower when mostly)\r\n!n\tWidth\r\n!.n\tMax width/precision\r\n!A\tConvert to upper when\r\n!a\tConvert to lower when\r\n!B\tBinary\r\n!C\tShow int as single n-bit (unicode) character\r\n!D\tShow int as multi-bit (unicode) character\r\n!E,F,G\tSpecify format for double (corresponds to C format codes)\r\n!F\r\n!G\r\n!H\tHex\r\n!JC\tJustify centre\r\n!JL\tJustify left\r\n!JR\tJustify right\r\n!M\tHEAPMODE???\r\n!O\tOctal\r\n!Pc\tUse padding char c\r\n!Q\tAdd double quotes around string (and deal with embedded quotes)\r\n!'\tAdd single quotes around string (and deal with embedded quotes)\r\n!Sc\tUse separator char c between every 3 or 4 digits\r\n!Tc\tUse terminator char c (typically B or H)\r\n!U\tShow ints as unsigned\r\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\r\n!W\tUnsigned\r\n!Xn\tUse base n (n is hex 0 to F)\r\n!Z\tUse \"0\" padding\r\n!+\tAlways have + or - in front of integers\r\n!~\tQuote char is ~\r\n!*\tSame as n but uses parameter set with :'V' on previous int\r\n\r\n\tchar c\r\n\tbyte wset\r\n\tint n\r\n\tarray[0:100]char str\r\n\r\n\tfmt^:=defaultfmt\r\n\r\n\tif s=nil then return fi\r\n\r\n\tif slen=-1 then slen:=strlen(s) fi\r\n\r\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\r\n\tstr[slen]:=0\r\n\ts:=&.str\r\n\r\n\twset:=0\r\n\twhile s^ do\r\n\t\tc:=s^\r\n\t\t++s\r\n\t\tswitch c\r\n\t\twhen 'B', 'b' then fmt^.base:=2\r\n\t\twhen 'H', 'h' then fmt^.base:=16\r\n\t\twhen 'O', 'o' then fmt^.base:=8\r\n\t\twhen 'X', 'x' then\r\n\t\t\tc:=s^\r\n\t\t\tif c then\r\n\t\t\t\tswitch c\r\n\t\t\t\twhen '0'..'9' then c:=c-'0'\r\n\t\t\t\twhen 'A'..'F' then c:=c-'A'+10\r\n\t\t\t\twhen 'a'..'f' then c:=c-'a'+10\r\n\t\t\t\telse\r\n\t\t\t\t\tc:=10\r\n\t\t\t\tend\r\n\t\t\t\tfmt^.base:=c\r\n\t\t\t\t++s\r\n\t\t\tfi\r\n\t\twhen 'Q', 'q' then fmt^.quotechar:='\"'\r\n\t\twhen '~' then fmt^.quotechar:='~'\r\n\t\twhen 'J', 'j' then\r\n\t\t\tfmt^.justify:=toupper(s^)\r\n\t\t\tif s^ then\r\n\t\t\t\t++s\r\n\t\t\tfi\r\n\t\twhen 'A' then fmt^.lettercase:='A'\r\n\t\twhen 'a' then fmt^.lettercase:='a'\r\n\t\twhen 'Z', 'z' then fmt^.padchar:='0'\r\n\t\twhen 'S', 's' then\r\n\t\t\tfmt^.sepchar:=s^\r\n\t\t\tif s^ then\r\n\t\t\t\t++s\r\n\t\t\tfi\r\n\t\twhen 'P', 'p' then\r\n\t\t\tfmt^.padchar:=s^\r\n\t\t\tif s^ then\r\n\t\t\t\t++s\r\n\t\t\tfi\r\n\t\twhen 'T', 't' then\r\n\t\t\tfmt^.suffix:=s^\r\n\t\t\tif s^ then\r\n\t\t\t\t++s\r\n\t\t\tfi\r\n\t\twhen 'W', 'w' then fmt^.usigned:='W'\r\n\t\twhen 'E', 'e' then fmt^.realfmt:='e'\r\n\t\twhen 'F', 'f' then fmt^.realfmt:='f'\r\n\t\twhen 'G', 'g' then fmt^.realfmt:='g'\r\n! when '0','1','2','3','4','5','6','7','8','9' then\r\n\t\twhen '.' then\r\n\t\t\twset:=1\r\n\t\twhen comma,'_' then fmt^.sepchar:=c\r\n\t\twhen '+' then fmt^.plus:='+'\r\n\t\twhen 'D', 'd' then fmt^.charmode:='D'\r\n\t\twhen 'C', 'c' then fmt^.charmode:='C'\r\n\t\twhen 'M', 'm' then fmt^.heapmode:='M'\r\n\t\twhen 'V','v' then fmt.param:='V'\r\n\t\twhen '*' then\r\n\t\t\tn:=fmtparam\r\n\t\t\tgoto gotwidth\r\n!\t\t\tif wset then\r\n!CPL \"FMT/* WSET\",FMTPARAM\r\n!\t\t\t\tfmt.minwidth:=fmtparam\r\n!\t\t\telse\r\n!CPL \"FMT/*\",FMTPARAM\r\n!\t\t\t\tfmt.precision:=fmtparam\r\n!\t\t\tfi\r\n\t\telse\r\n\t\t\tif c>='0' and c<='9' then\r\n\t\t\t\tn:=c-'0'\r\n\t\t\t\tdo\r\n\t\t\t\t\tc:=s^\r\n\t\t\t\t\tif s^=0 then\r\n\t\t\t\t\t\texit\r\n\t\t\t\t\tfi\r\n\t\t\t\t\tif c>='0' and c<='9' then\r\n\t\t\t\t\t\t++s\r\n\t\t\t\t\t\tn:=n*10+c-'0'\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\texit\r\n\t\t\t\t\tfi\r\n\t\t\t\tod\r\ngotwidth::\r\n\t\t\t\tif not wset then\r\n\t\t\t\t\tfmt^.minwidth:=n\r\n\t\t\t\t\twset:=1\r\n\t\t\t\telse\r\n\t\t\t\t\tfmt^.precision:=n\r\n\t\t\t\tfi\r\n\t\t\tfi\r\n\t\tendswitch\r\n\tod\r\nend\r\n\r\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\r\n!there are n (4 or 8) chars at p.!\r\n!There could be 0 to 4 or 8 printable chars converted to string at dest\r\n\tarray[0:20]char str\r\n\tref char q\r\n\tint i,nchars\r\n\r\n\tq:=&.str\r\n\r\n\tnchars:=n\r\n\r\n\tto n do\r\n\t\tif p^=0 then exit fi\r\n\t\tq^:=p^\r\n\t\t++q\r\n\t\t++p\r\n\tod\r\n\tq^:=0\r\n\r\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\r\nend\r\n\r\nfunction expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\r\n!s contains a partly stringified value.\r\n!widen s if necessary, according to fmt, and copy result to t\r\n!n is current length of s\r\n!note) = for non-numeric strings, fmt^.base should be set to 0, to avoid moving\r\n!a leading +/- when right-justifying with '0' padding.\r\n!t MUST be big enough for the expanded string; caller must take care of this\r\n!result will be zero-terminated, for use in this module\r\n\r\n\tint i,w,m\r\n\r\n!check to see if result is acceptable as it is\r\n\tw:=fmt^.minwidth\r\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\r\n\t\tstrncpy(t,s,n)\r\n\t\t(t+n)^:=0\r\n\t\treturn n\r\n\tfi\r\n\r\n\tif fmt^.justify='L' then\t! left-justify\r\n\t\tstrncpy(t,s,n)\r\n\t\tt+:=n\r\n\t\tfor i:=1 to w-n do\r\n\t\t\tt^:=fmt^.padchar\r\n\t\t\t++t\r\n\t\tod\r\n\t\tt^:=0\r\n\telsif fmt^.justify='R' then\r\n\t\tif fmt^.padchar='0' and fmt^.base and (s^='-' or s^='+') then ! need to move sign outside \r\n\t\t\tt^:=s^\r\n\t\t\t++t\r\n\t\t\tto w-n do\r\n\t\t\t\tt^:=fmt^.padchar\r\n\t\t\t\t++t\r\n\t\t\tod\r\n\t\t\tstrncpy(t,s+1,n-1)\r\n\t\t\t(t+n-1)^:=0\r\n\t\telse\r\n\t\t\tto w-n do\r\n\t\t\t\tt^:=fmt^.padchar\r\n\t\t\t\t++t\r\n\t\t\tod\r\n\t\t\tstrncpy(t,s,n)\r\n\t\t\t(t+n)^:=0\r\n\t\tfi\r\n\r\n\telse\t\t\t\t! centre-justify?\r\n\r\n\t\tm:=(w-n+1)/2\r\n\t\tto m do\r\n\t\t\tt^:=fmt^.padchar\r\n\t\t\t++t\r\n\t\tod\r\n\t\tstrncpy(t,s,n)\r\n\t\tt+:=n\r\n\t\tto w-n-m do\r\n\t\t\tt^:=fmt^.padchar\r\n\t\t\t++t\r\n\t\tod\r\n\t\tt^:=0\r\n\r\n\tfi\r\n\treturn w\r\nend\r\n\r\n!function xdivrem(word64 a,b)word64,word64=\r\n!\tassem\r\n!\t\txor rdx,rdx\r\n!\t\tmov rax,[a]\r\n!\t\tdiv u64 [b]\r\n!\t\tmov D1,rdx\r\n!\tend\r\n!end\r\n\r\n!function xdivrem(word64 a,b, &remainder)word64=\r\n!\tword64 q,r\r\n!\tassem\r\n!\t\txor rdx,rdx\r\n!\t\tmov rax,[a]\r\n!\t\tdiv u64 [b]\r\n!\t\tmov [q],rax\t\r\n!\t\tmov [r],rdx\t\r\n!\tend\r\n!\tremainder:=r\r\n!\treturn q\r\n!end\r\n\r\nfunction mdivrem(word64 a,b)word64,word64=\r\n\tword64 q,r\r\n\tassem\r\n\t\txor rdx,rdx\r\n\t\tmov rax,[a]\r\n\t\tdiv u64 [b]\r\n\t\tmov [q],rax\t\r\n\t\tmov [r],rdx\t\r\n\tend\r\n\treturn (q,r)\r\n!\tremainder:=r\r\n!\treturn q\r\nend\r\n\r\nfunction u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\r\n!convert 64-bit int a to string in s^\r\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\r\n!result when a=minint (will give \"<minint>\")\r\n\tarray[0:onesixty]char t\r\n\tu64 dd\r\n\tint i,j,k,g\r\n\tint cc\r\n\tint dummy\r\n\tref char s0\r\n\r\n\ti:=0\r\n\tk:=0\r\n\tg:=(base=10|3|4)\r\n\r\n\trepeat\r\n!\t\taa:=xdivrem(aa,base,dd)\r\n\t\t(aa,dd):=mdivrem(aa,base)\r\n\r\n\t\tt[++i]:=digits[dd]\r\n\r\n!!\t\taa:=aa/base\r\n\r\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\r\n!out a full length binary\r\n!so perhaps move this out to expandstr\r\n\t\t++k\r\n\t\tif sep and aa<>0 and k=g then\r\n\t\t\tt[++i]:=sep\r\n\t\t\tk:=0\r\n\t\tfi\r\n\tuntil aa=0\r\n\r\n\tj:=i\r\n\ts0:=s\r\n\twhile i do\r\n\t\ts^:=t[i--]\r\n\t\t++s\r\n\tod\r\n\ts^:=0\r\n\r\n\treturn j\r\nend\r\n\r\nfunction u128tostr(u128 aa,ref char s,word base,int sep)int =\r\n!convert 128-bit int a to string in s^\r\n!base is number base, usually 10 but can be 2 to 16\r\n\tarray[0:160]char t\r\n\tu64 dd\r\n\tint i,j,k,g\r\n\tint dummy\r\n\tref char s0\r\n\r\n\ti:=0\r\n\tk:=0\r\n\tg:=(base=10|3|4)\r\n\r\n!CPL \"U128/BASE\",BASE\r\n\trepeat\r\n\t\taa:=xdivrem128(aa,base,dd)\r\n\t\tt[++i]:=digits[dd]\r\n\r\n!CPL =DD\r\n\r\n!\t\tt[++i]:=digits[aa rem base]\r\n!\t\taa:=aa/base\r\n\r\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\r\n!out a full length binary\r\n!so perhaps move this out to expandstr\r\n\t\t++k\r\n\t\tif sep and aa<>0 and k=g then\r\n\t\t\tt[++i]:=sep\r\n\t\t\tk:=0\r\n\t\tfi\r\n\tuntil aa=0\r\n\r\n\tj:=i\r\n\ts0:=s\r\n\twhile i do\r\n\t\ts^:=t[i--]\r\n\t\t++s\r\n\tod\r\n\ts^:=0\r\n\r\n\treturn j\r\nend\r\n\r\nfunction xdivrem128(word128 a, word64 b, &remainder)word128=\r\n\tword128 d,e,r\r\n\tword rlow\r\n\r\n\td:=a/b\r\n\tr:=a-d*b\r\n\r\n\tassem\r\n\t\tmov d0,[r]\r\n\t\tmov [rlow],d0\r\n\tend\r\n\tremainder:=rlow\r\n\treturn d\r\nend\r\n\r\nfunction i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\r\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\r\n!convert a to a string in s, according to fmt\r\n!a basic conversion is done first,: the field manipulation is done\r\n!signed=1 for int, 0 for u32 (fmt^.unsigned forces ints to be treated as longs)\r\n!returns length of s\r\n\tarray[0:onesixty]char str\t\t\t\t! allow for binary with separators!\r\n\tint i,j,k,n,w,usigned\r\n\tstatic u64 mindint=0x8000'0000'0000'0000\r\n\r\n\tusigned:=0\r\n\tif fmt^.usigned then\r\n\t\tusigned:=1\r\n\tfi\r\n\r\n\tif aa=mindint and not usigned then\t\t! minint\r\n\r\n\t\tstr[0]:='-'\r\n\t\tn:=i64mintostr(&str[1],fmt^.base,fmt^.sepchar)+1\r\n\telse\r\n\t\tif (not usigned and aa<-0) or fmt^.plus then\r\n\t\t\tif aa<0 then\r\n\t\t\t\taa:=-aa\r\n\t\t\t\tstr[0]:='-'\r\n\t\t\telse\r\n\t\t\t\tstr[0]:='+'\r\n\t\t\tfi\r\n\t\t\tn:=u64tostr(aa,&str[1],fmt^.base,fmt^.sepchar)+1\r\n\t\telse\r\n\t\t\tn:=u64tostr(aa,&.str,fmt^.base,fmt^.sepchar)\r\n\t\tfi\r\n\tfi\r\n\r\n\tif fmt^.suffix then\r\n\t\tstr[n]:=fmt^.suffix\r\n\t\tstr[++n]:=0\r\n\tfi\r\n\r\n!str uses upper cases for hex/etc see if lc needed\r\n\tif (fmt^.base>10 or fmt^.suffix) and fmt^.lettercase='a'\tthen\t! need lower when\r\n\t\tconvlcstring(&.str)\r\n\tfi\r\n\r\n!at this point, n is the str length including signs and suffix\r\n\treturn expandstr(&.str,s,n,fmt)\r\nend\r\n\r\nfunction u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\r\n!see i64tostrfmt\r\n\tarray[0:onesixty]char str\t\t\t\t! allow for binary with separators!\r\n\tint i,j,k,n,w\r\n\r\n\tn:=u64tostr(aa,&.str,fmt^.base,fmt^.sepchar)\r\n\r\n\tif fmt^.suffix then\r\n\t\tstr[n]:=fmt^.suffix\r\n\t\tstr[++n]:=0\r\n\tfi\r\n\r\n!str uses upper cases for hex/etc see if lc needed\r\n\tif (fmt^.base>10 or fmt^.suffix) and fmt^.lettercase='a'\tthen\t! need lower when\r\n\t\tconvlcstring(&.str)\r\n\tfi\r\n\r\n!at this point, n is the str length including signs and suffix\r\n\treturn expandstr(&.str,s,n,fmt)\r\nend\r\n\r\nfunction u128tostrfmt(i128 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\r\n!see i64tostrfmt\r\n\tarray[0:onesixty]char str\t\t\t\t! allow for binary with separators!\r\n\tint i,j,k,n,w\r\n\r\n\tn:=u128tostr(aa,&.str,fmt^.base,fmt^.sepchar)\r\n\r\n\tif fmt^.suffix then\r\n\t\tstr[n]:=fmt^.suffix\r\n\t\tstr[++n]:=0\r\n\tfi\r\n\r\n!str uses upper cases for hex/etc see if lc needed\r\n\tif (fmt^.base>10 or fmt^.suffix) and fmt^.lettercase='a'\tthen\t! need lower when\r\n\t\tconvlcstring(&.str)\r\n\tfi\r\n\r\n!at this point, n is the str length including signs and suffix\r\n\treturn expandstr(&.str,s,n,fmt)\r\nend\r\n\r\nfunction i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\r\n!convert minint to string in s do not include minus sign\r\n!return number of chars in string\r\n\tarray[0:onesixty]char t\r\n\tint i,j,k,g,neg\r\n\r\n\tswitch base\r\n\twhen 10 then\r\n\t\tstrcpy(&t[0],\"9223372036854775808\")\r\n\t\tj:=3\r\n\twhen 16 then\r\n\t\tstrcpy(&t[0],\"8000000000000000\")\r\n\t\tj:=1\r\n\twhen 2 then\r\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\r\n\t\tj:=7\r\n\telse\r\n\t\tstrcpy(&t[0],\"<mindint>\")\r\n\tendswitch\r\n\r\n\ti:=strlen(&t[0])\r\n\ts+:=i\r\n\tif sep then\r\n\t\ts+:=j\r\n\tfi\r\n\ts^:=0\r\n\r\n\tk:=0\r\n\tg:=(base=10|3|4)\r\n\r\n\twhile i do\r\n\t\t--s\r\n\t\ts^:=t[i-- -1]\r\n\t\tif sep and i and ++k=g then\r\n\t\t\t--s\r\n\t\t\ts^:=sep\r\n\t\t\tk:=0\r\n\t\tfi\r\n\tod\r\n\treturn strlen(s)\r\nend\r\n\r\nfunction strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\r\n!s is a string process according to fmtrec fmt^, and return result in t\r\n!caller should check whether any changes are required to s (now it can just use s), but this\r\n!check is done here anyway (with a simple copy to t)\r\n!n is current length of s\r\n!return length of t\r\n!Three processing stages:\r\n!1 Basic input string s\r\n!2 Additions or mods: quotes, suffix, when conversion\r\n!3 Width adjustment\r\n!1 is detected here, 2 is done here, 3 is done by expandstr\r\n\tref char u,v\r\n\tarray[256]char str\r\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\r\n\r\n\tnheap:=0\r\n\r\n\tif fmt^.quotechar or fmt^.lettercase then\t\t! need local copy\r\n\t\tif n<256 then\r\n\t\t\tu:=&.str\r\n\t\telse\r\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\r\n\t\t\tu:=pcm_alloc(nheap)\r\n\t\tfi\r\n\t\tif fmt^.quotechar then\r\n\t\t\tv:=u\r\n\t\t\tv^:=fmt^.quotechar\r\n\t\t\t++v\r\n\t\t\tif n then\r\n\t\t\t\tstrcpy(v,s)\r\n\t\t\t\tv+:=n\r\n\t\t\tfi\r\n\t\t\tv^:=fmt^.quotechar\r\n\t\t\t++v\r\n\t\t\tv^:=0\r\n\t\t\tn+:=2\r\n\t\telse\r\n\t\t\tmemcpy(u,s,n)\r\n\t\tfi\r\n\t\tswitch fmt^.lettercase\r\n\t\twhen 'a' then\t! need lower when\r\n\t\t\tconvlcstring(u)\r\n\t\twhen 'A' then\r\n\t\t\tconvucstring(u)\r\n\t\tendswitch\r\n\t\ts:=u\r\n\tfi\r\n\r\n\tw:=fmt^.minwidth\r\n\tif w>n then\r\n\t\tn:=expandstr(s,t,n,fmt)\r\n\telse\r\n\t\tmemcpy(t,s,n)\r\n\tfi\r\n\tif nheap then\r\n\t\tpcm_free(u,nheap)\r\n\tfi\r\n\treturn n\r\nend\r\n\r\nproc tostr_i64(int64 a, ref fmtrec fmt)=\r\n\tarray[360]char str\r\n\tint n\r\n\r\n\tcase fmt^.charmode\r\n\twhen 0 then\r\n\t\tn:=i64tostrfmt(a,&.str,fmt)\r\n\twhen 'D','d' then\r\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\r\n\r\n\telse\t\t\t\t\t\t!assume 'C'\r\n\t\tprintchar(a)\t\t\t!no other formatting allowed\r\n\t\treturn\r\n\tesac\r\n\r\n\tprintstr_n(&.str,n)\r\nend\r\n\r\nproc tostr_u64(word64 a, ref fmtrec fmt)=\r\n\tarray[360]char str\r\n\tint n\r\n\r\n\tcase fmt^.charmode\r\n\twhen 'D','d' then\r\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\r\n\r\n\twhen 'C','c' then\r\n\t\tprintchar(a)\t\t\t!no other formatting allowed\r\n\t\treturn\r\n\r\n\telse\r\n\t\tn:=u64tostrfmt(a,&.str,fmt)\r\n\tesac\r\n\r\n\tprintstr_n(&.str,n)\r\nend\r\n\r\nproc tostr_u128(word128 a, ref fmtrec fmt,int neg)=\r\n\tarray[360]char str\r\n\tint n\r\n\r\n[2]INT XX @&A\r\n\r\n\tcase fmt^.charmode\r\n\twhen 'D','d' then\r\n\t\tn:=domultichar(ref char(&a),16,&.str,fmt)\r\n\r\n\twhen 'C','c' then\r\n\t\tprintchar(a)\t\t\t!no other formatting allowed\r\n\t\treturn\r\n\r\n\telse\r\n\t\tif neg then\r\n\t\t\tstr[1]:='-'\r\n\t\t\tn:=u128tostrfmt(a,&str[2],fmt)+1\r\n\t\telse\r\n\t\t\tn:=u128tostrfmt(a,&.str,fmt)\r\n\t\tfi\r\n\tesac\r\n\r\n\tprintstr_n(&.str,n)\r\nend\r\n\r\nproc tostr_r64(real x,ref fmtrec fmt) =\r\n\tarray[360]char str,str2\r\n\tarray[0:10]char cfmt\r\n\tint n\r\n\r\n\tcfmt[0]:='%'\r\n\r\n\tif fmt^.precision then\r\n\t\tcfmt[1]:='.'\r\n\t\tcfmt[2]:='*'\r\n\t\tcfmt[3]:=fmt^.realfmt\r\n\t\tcfmt[4]:=0\r\n\t\tsprintf(&.str,&.cfmt,fmt^.precision,x)\r\n\telse\r\n\t\tcfmt[1]:=fmt^.realfmt\r\n\t\tcfmt[2]:=0\r\n\t\tsprintf(&.str,&.cfmt,x)\r\n\tfi\r\n\r\n!at this point, n is the str length including signs and suffix\r\n\r\n!(TRY TAKING N FROM RESULT OF SPRINTF ABOVE)\r\n\tn:=strlen(&.str)\t\t! current length\r\n\r\n\tif n<fmt^.minwidth then\r\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\r\n\t\tstrcpy(&.str,&.str2)\r\n\tfi\r\n\r\n\tprintstr_n(&.str,n)\r\nend\r\n\r\nproc tostr_str(ref char s, ref fmtrec fmt) =\r\n\tint oldlen,newlen,n\r\n\tref char t\r\n\r\n!try and work out size of formatted string\r\n\toldlen:=strlen(s)\r\n\tnewlen:=oldlen\r\n\r\n\tif fmt^.quotechar or fmt^.minwidth>newlen or fmt^.lettercase or fmt.precision then\r\n\t\tif fmt^.quotechar then\r\n\t\t\tnewlen+:=2\r\n\t\tfi\r\n\t\tif fmt^.minwidth>newlen then\r\n\t\t\tnewlen:=fmt^.minwidth\r\n\t\tfi\r\n\t\tt:=pcm_alloc(newlen+1)\r\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\r\n\t\tif fmt.precision then\r\n\t\t\tn min:=fmt.precision\r\n\t\tfi\r\n\r\n\t\tprintstr_n(t,n)\r\n\t\tpcm_free(t,newlen+1)\r\n\telse\r\n\t\tprintstr_n(s,oldlen)\r\n\tfi\r\nend\r\n\r\nglobal function getfmt(ichar fmtstyle)ref fmtrec=\r\n\tstatic fmtrec fmt\r\n\tif fmtstyle then\r\n\t\tstrtofmt(fmtstyle,-1,&fmt)\r\n\t\treturn &fmt\r\n\telse\r\n\t\treturn &defaultfmt\r\n\tfi\r\nend\r\n\r\nglobal function strint(int64 a, ichar fmtstyle=nil)ichar=\r\n\tstatic [100]char str\r\n\tref fmtrec fmt\r\n\r\n\tm$print_startstr(&.str)\r\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\r\n\tm$print_end()\r\n\treturn getstr(&.str,fmt)\r\nend\r\n\r\nglobal proc getstrint(int64 a, ichar dest)=\r\n\tm$print_startstr(dest)\r\n\ttostr_i64(a,getfmt(nil))\r\n\tm$print_end()\r\nend\r\n\r\nglobal function strword(word64 a, ichar fmtstyle=nil)ichar=\r\n\tstatic [100]char str\r\n\tref fmtrec fmt\r\n\r\n\tm$print_startstr(&.str)\r\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\r\n\tm$print_end()\r\n\treturn getstr(&.str,fmt)\r\nend\r\n\r\nglobal function strreal(real a, ichar fmtstyle=nil)ichar=\r\n\tstatic [320]char str\r\n\tref fmtrec fmt\r\n\r\n\tm$print_startstr(&.str)\r\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\r\n\tm$print_end()\r\n\treturn getstr(&.str,fmt)\r\nend\r\n\r\nfunction getstr(ichar s, ref fmtrec fmt)ichar=\r\n\tif fmt^.heapmode then\r\n\t\treturn pcm_copyheapstring(s)\r\n\telse\r\n\t\treturn s\r\n\tfi\r\nend\r\n\r\nproc initreadbuffer=\r\n\tif rd_buffer then return fi\r\n\trd_buffer:=pcm_alloc(rd_buffersize)\r\n\trd_buffer^:=0\r\n\trd_pos:=rd_lastpos:=rd_buffer\r\nend\r\n\r\nglobal proc m$read_conline=\r\n\tinitreadbuffer()\r\n\r\n\treadlinen(nil,rd_buffer,rd_buffersize)\r\n\r\n\trd_length:=strlen(rd_buffer)\r\n\trd_pos:=rd_buffer\r\n\trd_lastpos:=nil\r\nend\r\n\r\nglobal proc m$read_fileline(filehandle f)=\r\n\tinitreadbuffer()\r\n\treadlinen(f,rd_buffer,rd_buffersize)\r\n\r\n\trd_length:=strlen(rd_buffer)\r\n\trd_pos:=rd_buffer\r\n\trd_lastpos:=nil\r\nend\r\n\r\nglobal proc m$read_strline(ichar s)=\r\n\tint n\r\n\r\n\tinitreadbuffer()\r\n\tn:=strlen(s)\r\n\r\n\tif n<rd_buffersize then\r\n\t\tstrcpy(rd_buffer,s)\r\n\telse\r\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\r\n\t\t(rd_buffer+rd_buffersize-1)^:=0\r\n\tfi\r\n\trd_length:=n\r\n\trd_pos:=rd_buffer\r\n\trd_lastpos:=nil\r\nend\r\n\r\nfunction readitem(int &itemlength)ref char =\r\n!read next item from rd_buffer\r\n!identify a substring that can contain a name, int, real, string or filename\r\n!return updated position of s that points past the item and past the immediate\r\n!terminator \r\n!information about the read item is returned in itemstr, which points to\r\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\r\n!Item can be quoted, then the item points inside the quotes\r\n!Any embedded quotes are removed, and the characters moved up. The item will\r\n!be that reduced subsequence\r\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\r\n!I can mitigate this by adding spaces between the end of the item, and the next item,\r\n!overwriting also the terminator. But this won't restore the line if one of the next\r\n!reads is literal, using 'L' or 'C' codes.\r\n\tref char p,s,itemstr\r\n\tchar quotechar, c\r\n\r\n\tunless rd_buffer then \r\n\t\tinitreadbuffer()\r\n!abortprogram(\"No readln\")\r\n\tend unless\r\n\r\n\r\n\ts:=rd_pos\r\n\r\n!scan string, eliminating leading white space\r\n\twhile s^=' ' or s^=9 do\r\n\t\t++s\r\n\tod\r\n\r\n\titemstr:=s\t\t\t\t!assume starts here\r\n\trd_lastpos:=rd_pos:=s\r\n\r\n\tif s^=0 then\t\t\t! No more chars left to read return null string\r\n\t\ttermchar:=0\r\n\t\titemlength:=0\r\n\t\treturn s\r\n\tfi\r\n\r\n\tquotechar:=0\t\t\t! Allow possible enclosing single or double quotes\r\n\tif s^='\"' then\r\n\t\tquotechar:='\"'\r\n\t\t++s\r\n\telsif s^='\\'' then\r\n\t\tquotechar:='\\''\r\n\t\t++s\r\n\tfi\r\n\r\n!loop reading characters until separator or end reached\r\n\tp:=itemstr:=s\r\n\r\n\twhile s^ do\r\n\t\tc:=s++^\r\n\t\tswitch c\r\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\r\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\r\n\t\t\t\tgoto normalchar\r\n\t\t\tfi\r\n\t\t\ttermchar:=c\r\n\t\t\texit\r\n\t\telse\r\n\tnormalchar::\r\n\t\t\tif c=quotechar then\r\n\t\t\t\tif s^=quotechar then\t! embedded quote\r\n\t\t\t\t\tp^:=c\r\n\t\t\t\t\t++s\r\n\t\t\t\t\t++p\r\n\t\t\t\telse\t\t\t\t\t! end of name\r\n\t\t\t\t\ttermchar:=s^\r\n\t\t\t\t\tif termchar=',' or termchar='=' then\r\n\t\t\t\t\t\t++s\r\n\t\t\t\t\t\ttermchar:=s^\r\n\t\t\t\t\tfi\r\n\t\t\t\t\texit\r\n\t\t\t\tfi\r\n\t\t\telse\r\n\t\t\t\tp^:=c\r\n\t\t\t\t++p\r\n\t\t\tfi\r\n\t\tendswitch\r\n\tod\r\n\r\n\tif s^=0 then\r\n\t\ttermchar:=0\r\n\tfi\r\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\r\n\trd_pos:=s\r\n\r\n\treturn itemstr\r\nend\r\n\r\nglobal function strtoint(ichar s,int length=-1, base=10)int64=\r\n!return point to next char after terminator (which can be just off length of string)\r\n\tbyte signd\r\n\tword64 aa\r\n\tchar c,d\r\n\r\n\titemerror:=0\r\n\r\n\tif length=-1 then\r\n\t\tlength:=strlen(s)\r\n\tfi\r\n!check for sign\r\n\tsignd:=0\r\n\tif length and s^='-' then\r\n\t\tsignd:=1; ++s; --length\r\n\telsif length and s^='+' then\r\n\t\t++s; --length\r\n\tfi\r\n\r\n\taa:=0\r\n\twhile length do\r\n\t\tc:=s++^\r\n\t\t--length\r\n\t\tswitch c\r\n\t\twhen 'A'..'F' then d:=c-'A'+10\r\n\t\twhen 'a'..'f' then d:=c-'a'+10\r\n\t\twhen '0'..'9' then d:=c-'0'\r\n\t\twhen '_', '\\'' then\r\n\t\t\tnext\r\n\t\telse\r\n\t\t\titemerror:=1\r\n\t\t\texit\r\n\t\tendswitch\r\n\r\n\t\tif d>=base then\r\n\t\t\titemerror:=1\r\n\t\t\texit\r\n\t\tfi\r\n\t\taa:=aa*base+d\r\n\tod\r\n\r\n\tif signd then\r\n\t\treturn -aa\r\n\telse\r\n\t\treturn aa\r\n\tfi\r\nend\r\n\r\nglobal function m$read_i64(int fmt=0)int64=\r\n\tref char s\r\n\tint length,c\r\n\tint64 aa\r\n\r\n\tcase fmt\r\n\twhen 'C','c' then\r\n\t\trd_lastpos:=rd_pos\r\n\t\tif rd_pos^ then\r\n\t\t\treturn rd_pos++^\r\n\t\telse\r\n\t\t\treturn 0\r\n\t\tfi\r\n\twhen 'T','t' then\r\n\t\treturn termchar\r\n\twhen 'E','e' then\r\n\t\treturn itemerror\r\n\tesac\r\n\r\n\ts:=readitem(length)\r\n\r\n\r\n\tcase fmt\r\n\twhen 0,'I','i' then\r\n\t\treturn strtoint(s,length)\r\n\twhen 'B','b' then\r\n\t\treturn strtoint(s,length,2)\r\n\twhen 'H','h' then\r\n\t\treturn strtoint(s,length,16)\r\n\tesac\r\n\treturn 0\r\nend\r\n\r\nglobal function m$read_r64(int fmt=0)real=\r\n\tarray[512]char str\r\n\tref char s\r\n\tint length\r\n\tint32 numlength\r\n\treal x\r\n\r\n\ts:=readitem(length)\r\n\r\n\tif length=0 or length>=str.len then\t\t!assume not a real\r\n\t\treturn 0.0\r\n\tfi\r\n\tmemcpy(&.str,s,length)\r\n\tstr[length+1]:=0\r\n\r\n\titemerror:=0\r\n\r\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\r\n\t\tx:=0.0\r\n\t\titemerror:=1\r\n\tfi\r\n\r\n\treturn x\r\nend\r\n\r\nglobal proc m$read_strold(ref char dest, int destlen=0,fmt=0)=\r\n\tref char s\r\n\tint length,numlength\r\n\treal x\r\n\r\n\titemerror:=0\r\n\tif fmt='L' or fmt='l' then\r\n\t\ts:=rd_pos\r\n\t\tlength:=rd_buffer+rd_length-rd_pos\r\n\r\n\telse\r\n\t\ts:=readitem(length)\r\n\r\n\t\tif fmt='N' or fmt='n' then\r\n\t\t\ticonvlcn(s,length)\r\n\t\tfi\r\n\tfi\r\n\r\n\tif destlen>0 then\r\n\t\tif length>=destlen then\r\n\t\t\tlength:=destlen-1\r\n\t\t\titemerror:=1\r\n\t\tfi\r\n\tfi\r\n\tmemcpy(dest,s,length)\r\n\t(dest+length)^:=0\r\nend\r\n\r\nglobal function m$read_str(int fmt=0)ichar t=\r\n\tref char s\r\n\tint length,numlength\r\n\treal x\r\n\r\n\titemerror:=0\r\n\tif fmt='L' or fmt='l' then\r\n\t\ts:=rd_pos\r\n\t\tlength:=rd_buffer+rd_length-rd_pos\r\n\r\n\telse\r\n\t\ts:=readitem(length)\r\n\r\n\t\tif fmt='N' or fmt='n' then\r\n\t\t\ticonvlcn(s,length)\r\n\t\tfi\r\n\tfi\r\n\r\n\tt:=pcm_alloc(length+1)\r\n\tmemcpy(t,s,length)\r\n\t(t+length)^:=0\r\n\treturn t\r\nend\r\n\r\nglobal proc readstr(ref char dest, int fmt=0,destlen=0)=\r\n\tm$read_strold(dest,destlen,fmt)\r\nend\r\n\r\nglobal proc rereadln=\r\n\trd_pos:=rd_buffer\r\n\trd_lastpos:=rd_pos\r\nend\r\n\r\nglobal proc reread=\r\n\trd_pos:=rd_lastpos\r\nend\r\n\r\nglobal function valint(ichar s, int fmt=0)int64=\r\nref char old_pos, old_lastpos\r\nint64 aa\r\n\r\ninitreadbuffer()\r\nold_pos:=rd_pos\r\nold_lastpos:=rd_lastpos\r\n\r\nrd_pos:=s\r\naa:=m$read_i64(fmt)\r\nrd_pos:=old_pos\r\nrd_lastpos:=old_lastpos\r\nreturn aa\r\nend\r\n\r\nglobal function valreal(ichar s)real=\r\nref char old_pos, old_lastpos\r\nreal x\r\n\r\ninitreadbuffer()\r\nold_pos:=rd_pos\r\nold_lastpos:=rd_lastpos\r\n\r\nrd_pos:=s\r\nx:=m$read_r64()\r\nrd_pos:=old_pos\r\nrd_lastpos:=old_lastpos\r\nreturn x\r\nend\r\n\r\nproc iconvlcn(ref char s,int n) =\t\t!ICONVLCN\r\nto n do\r\n\ts^:=tolower(s^)\r\n\t++s\r\nod\r\nend\r\n\r\nproc iconvucn(ref char s,int n) =\t\t!ICONVUCN\r\nto n do\r\n\ts^:=toupper(s^)\r\n\t++s\r\nod\r\nend\r\n\r\nproc convlcstring(ref char s)=\t\t!CONVLCSTRING\r\nwhile (s^) do\r\n\ts^:=tolower(s^)\r\n\t++s\r\nod\r\nend\r\n\r\nproc convucstring(ref char s)=\t\t!CONVUCSTRING\r\nwhile (s^) do\r\n\ts^:=toupper(s^)\r\n\t++s\r\nod\r\nend\r\n\r\n!GLOBAL PROC M$PRINT_U32(word32 a, ref void fmt)=\r\n!\tm$print_u64(a,nil)\r\n!end\r\n!\r\n!GLOBAL PROC M$PRINT_I32(int32 a, ref void fmt)=\r\n!\tm$print_i64(a,nil)\r\n!end\r\n!\r\n!GLOBAL PROC M$STARTPRINT(ref void dev)=\r\n!\tm$print_startfile(dev)\r\n!end\r\n!\r\n!GLOBAL PROC M$STARTPRINTCON=\r\n!\tm$print_startcon()\r\n!end\r\n!\r\n!GLOBAL PROC M$ENDPRINT=\r\n!\tm$print_end()\r\n!end\r\n\r\nglobal threadedproc m$ufloat_r64u64=\r\n\tassem\r\n\t\tcmp D10,0\r\n\t\tjl fl1\r\n!number is positive, so can treat like i64\r\n\t\tcvtsi2sd XMM15,D10\r\n\t\tret\r\nfl1:\t\t\t\t\t\t!negative value\r\n\t\tand D10,[mask63]\t\t!clear top bit (subtract 2**63)\r\n\t\tcvtsi2sd XMM15,D10\r\n\t\taddsd XMM15,[offset64]\t!(add 2**63 back to result)\r\n\t\tret\r\n\tend\r\nend\r\n\r\nglobal threadedproc m$ufloat_r64u32=\r\n\tassem\r\n\t\tmov D10,D10\t\t\t\t! clear top half (already done if value just moved there)\r\n\t\tcvtsi2sd XMM15,D10\r\n\t\tret\r\n\tend\r\nend\r\n\r\nglobal threadedproc m$ufloat_r32u32=\r\n\tassem\r\n\t\tmov D10,D10\r\n\t\tcvtsi2ss XMM15,D10\r\n\t\tret\r\n\tend\r\nend\r\n\r\nglobal threadedproc m$ufloat_r32u64=\r\n\tassem\r\n\t\tcmp D10,0\r\n\t\tjl fl2\r\n!number is positive, so can treat like i64\r\n\t\tcvtsi2ss XMM15,D10\r\n\t\tret\r\nfl2:\t\t\t\t\t\t!negative value\r\n\t\tand D10,[mask63]\t\t!clear top bit (subtract 2**63)\r\n\t\tcvtsi2ss XMM15,D10\r\n\t\taddss XMM15,[offset32]\t!(add 2**63 back to result)\r\n\t\tret\r\n\tend\r\nend\r\n\r\n!global function m$power_i64(int64 n,a)int64=\r\n!if n<0 then\r\n!\treturn 0\r\n!elsif n=0 then\r\n!\treturn 1\r\n!elsif n=1 then\r\n!\treturn a\r\n!elsif (n iand 1)=0 then\r\n!!\treturn ipower(a*a,n/2)\r\n!\treturn m$power_i64(a*a,n/2)\r\n!else\t\t\t!assume odd\r\n!\treturn m$power_i64(a*a,(n-1)/2)*a\r\n!fi\r\n!end\r\n\r\nglobal function m$power_i64(int64 n,a)int64=\r\nif n<0 then\r\n\treturn 0\r\nelsif n=0 then\r\n\treturn 1\r\nelsif n=1 then\r\n\treturn a\r\nelsif (n iand 1)=0 then\r\n!\treturn ipower(a*a,n/2)\r\n\treturn m$power_i64(n/2,sqr a)\r\nelse\t\t\t!assume odd\r\n\treturn m$power_i64((n-1)/2,sqr a)*a\r\nfi\r\nend\r\n\r\nglobal proc m$intoverflow=\r\n\tabortprogram(\"Integer overflow detected\")\r\nend\r\n\r\nglobal proc m$mul_i128(word128 bb,aa)=\r\n!CPL \"$MUL128\"\r\n\tassem\r\n\t\tmov d2,[aa]\t\t\t!a1\r\n\t\tmov d3,[aa+8]\t\t!a2\r\n\t\tmov d4,[bb]\t\t\t!b1\r\n\t\tmov d5,[bb+8]\t\t!b2\r\n\r\n\r\n\t\tmov d0,d2\t\t\t!a1\r\n\t\timul2 d0,d5\t\t\t!*b2\t\r\n\t\tmov d6,d0\t\t\t!=>d6\r\n\r\n\t\tmov d0,d3\t\t\t!a2\r\n\t\timul2 d0,d4\t\t\t!*b1\r\n\t\tmov d7,d0\t\t\t!=>d7\r\n\r\n\t\tmov d0,d2\t\t\t!a1\r\n\t\tmul d4\t\t\t\t!*b1\r\n\t\tadd d11,d6\t\t\t! + a1*b2<<64\r\n\t\tadd d11,d7\t\t\t! + a2*b1<<64\r\n\t\tmov d1,d11\r\n\tend\r\nend\r\n\r\nglobal proc m$idiv_i128(word128 bb,aa)=\r\n!does 128/64 bits only\r\n\tassem\r\n\t\tmov d2,[aa]\r\n\t\tmov d3,[aa+8]\r\n\r\n\t\tmov d4,[bb]\r\n\t\tor d4,d4\r\n\t\tjz divbyzero\r\n\r\n\t\tmov d0,d3\t\t!a2\r\n\t\txor d11,d11\r\n\t\tdiv d4\t\t\t!a2/b\r\n\t\tmov d6,d0\t\t! => c2\r\n\t\tmul d4\t\t\t!c2*b\r\n\t\tsub d3,d0\t\t!a2-:=c2*b\r\n\r\n\t\tmov d0,d2\r\n\t\tmov d11,d3\t\t!a2:a1\r\n\t\tdiv d4\t\t\t!/b\r\n\t\tmov d1,d6\r\n\tend\r\n\treturn\r\n\r\nasm divbyzero:\r\nCPL \"DIV BY ZERO\"\r\n\tstop 1\r\nend\r\n\r\nglobal proc m$dotindex(word i,a)=\r\n!return a.[i] in d0\r\n\tassem\r\n\t\tmov d0,[a]\r\n\t\tmov cl,[i]\r\n\t\tshr d0,cl\r\n\t\tand d0,1\r\n\tend\t\r\nend\r\n\r\nglobal proc m$dotslice(word j,i,a)=\r\n!return a.[i..j] in d0; assumes j>=i\r\n\tassem\r\n\t\tmov d0,[a]\r\n\t\tmov rcx,[i]\r\n\t\tshr d0,cl\r\n\t\tsub rcx,[j]\r\n\t\tneg rcx\t\t\t\t!j-1\r\n\t\tmov d2,0xFFFF'FFFF'FFFF'FFFE\r\n\t\tshl d2,cl\r\n\t\tnot d2\r\n\t\tand d0,d2\r\n\tend\t\r\nend\r\n\r\nglobal proc m$popdotindex(word i,ref word p,word x)=\r\n!p^.[i]:=x\r\n\tassem\r\n\t\tmov d3,[p]\r\n\t\tmov cl,[i]\r\n\t\tmov d0,[d3]\r\n\t\tmov d1,1\r\n\t\tshl d1,cl\t\t\t!000001000\r\n\t\tnot d1\t\t\t\t!111110111\r\n\t\tand d0,d1\t\t\t!clear that bit in dest\r\n\t\tmov d1,[x]\r\n\t\tand d1,1\r\n\t\tshl d1,cl\r\n\t\tor d0,d1\r\n\t\tmov [d3],d0\r\n\tend\t\r\nend\r\n\r\nglobal proc m$popdotslice(word j,i, ref word p, word x)=\r\n!p^.[i..j]:=x\r\n\tassem\r\n!d3 = p\r\n!d4 = x, then shifted then masked x\r\n!d5 = i\r\n!d6 = clear mask\r\n\r\n\t\tmov d3,[p]\r\n\t\tmov d4,[x]\r\n\t\tmov d5,[i]\r\n\t\tmov rcx,d5\t\t\t!i\r\n\t\tshl d4,cl\t\t\t!x<<i\r\n\t\tmov rcx,[j]\r\n\t\tsub rcx,d5\t\t\t!j-i\r\n\t\tinc rcx\t\t\t\t!j-i+1\r\n\t\tmov d2,0xFFFF'FFFF'FFFF'FFFF\r\n\t\tshl d2,cl\t\t\t!...111100000     (assume 5-bit slice)\r\n\t\tnot d2\t\t\t\t!...000011111\r\n\t\tmov rcx,d5\t\t\t!i\r\n\t\tshl d2,cl\t\t\t!...000011111000  (assume i=3)\r\n\t\tand d4,d2\t\t\t!mask x (truncate extra bits)\r\n\t\tmov d0,[d3]\r\n\t\tnot d2\t\t\t\t!...111100000111\r\n\t\tand d0,d2\t\t\t!clear dest bits\r\n\t\tor d0,d4\t\t\t!add in new bits\r\n\t\tmov [d3],d0\r\n\tend\t\r\nend\r\n\r\n\r\nglobal function m$sin(real x)real = {`sin(x)}\r\nglobal function m$cos(real x)real = {`cos(x)}\r\nglobal function m$tan(real x)real = {`tan(x)}\r\nglobal function m$asin(real x)real = {`asin(x)}\r\nglobal function m$acos(real x)real = {`acos(x)}\r\nglobal function m$atan(real x)real = {`atan(x)}\r\nglobal function m$ln(real x)real = {`log(x)}\r\n!global function m$lg(real x)real = {`lg(x)}\r\nglobal function m$log(real x)real = {`log10(x)}\r\nglobal function m$exp(real x)real = {`exp(x)}\r\nglobal function m$floor(real x)real = {`floor(x)}\r\nglobal function m$ceil(real x)real = {`ceil(x)}\r\nglobal function m$fract(real x)real = {abortprogram(\"FRACT\");0}\r\nglobal function m$round(real x)real = {abortprogram(\"ROUND\");0}\r\n",\
(uint8_t*)"import msys\r\nimport clib\r\nimport oslib\r\n\r\n!const mem_check=1\r\nconst mem_check=0\r\n\r\nGLOBAL INT MDEBUG\r\n\r\n\r\nglobal [0..300]u64 allocupper\r\nglobal int alloccode\t\t\t\t!set by heapalloc\r\nglobal int allocbytes\t\t\t\t!set by heapalloc\r\nglobal int fdebug=0\r\nglobal int rfsize\r\n\r\nconst threshold=1<<25\r\nconst alloc_step=1<<25\r\nword maxmemory\r\nint  maxalloccode\r\n\r\nbyte pcm_setup=0\r\n\r\nint show=0\r\n\r\nglobal int memtotal=0\r\nglobal int64 smallmemtotal=0\r\nglobal int smallmemobjs=0\r\nglobal int maxmemtotal=0\r\n\r\n!store all allocated pointers\r\nconst int maxmemalloc=500000\r\n[maxmemalloc+1]ref int32 memalloctable\r\n[maxmemalloc+1]int32 memallocsize\r\n\r\nconst pcheapsize=1048576*2\r\nref byte pcheapstart\r\nref byte pcheapend\t\t\t!points to first address past heap\r\nref byte pcheapptr\r\n\r\nconst int maxblockindex = 8 \t\t!2048\r\nglobal const int maxblocksize = 2048\r\n\r\n[0:maxblocksize+1]byte sizeindextable\t!convert byte size to block index 1..maxblockindex\r\n\r\nconst int size16   = 1\t\t\t!the various index codes\r\nconst int size32   = 2\r\nconst int size64   = 3\r\nconst int size128  = 4\r\nconst int size256  = 5\r\nconst int size512  = 6\r\nconst int size1024 = 7\r\nconst int size2048 = 8\r\n\r\nGLOBAL [0:9]ref wordp freelist\r\n\r\nglobal record strbuffer =\r\n\tichar strptr\r\n\tint32 length\r\n\tint32 allocated\r\nend\r\n\r\nglobal tabledata() [0:]ichar pmnames=\r\n\t(pm_end=0,\t\t$),\r\n\t(pm_option,\t\t$),\r\n\t(pm_sourcefile,\t$),\r\n\t(pm_libfile,\t$),\r\n\t(pm_colon,\t\t$),\r\n\t(pm_extra,\t\t$),\r\nend\r\n\r\n[2]int seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)\r\n\r\nglobal function pcm_alloc(int n)ref void =\t\t!PCM_ALLOC\r\nref byte p\r\n!int i\r\n\r\n!IF MDEBUG THEN\r\n!CPL \"PCMALLOC\",N\r\n!FI\r\nif not pcm_setup then\r\n\tpcm_init()\r\n!\tabortprogram(\"need pcm_init\")\r\nfi\r\n\r\nif n>maxblocksize then\t\t\t!large block allocation\r\n\talloccode:=pcm_getac(n)\r\n\tallocbytes:=allocupper[alloccode]\r\n\r\n\tp:=allocmem(allocbytes)\r\n\tif not p then\r\n\t\tabortprogram(\"pcm_alloc failure\")\r\n\tfi\r\n\r\nif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\r\n\r\n\treturn p\r\nfi\r\n\r\nalloccode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\r\n\r\nif alloccode=0 then\t\t\t\t\t!sizes below 16 bytes (can I adjust sizeindextable to?)\r\n\talloccode:=1\r\nfi\r\nallocbytes:=allocupper[alloccode]\r\n\r\nSMALLMEMTOTAL+:=ALLOCBYTES\r\n!IF MDEBUG THEN\r\n!CPL \"PCMALLOC/ALLOCBYTES\",ALLOCBYTES\r\n!FI\r\n\r\nif p:=ref byte(freelist[alloccode]) then\t\t!Items of this block size available\r\nif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\r\n\tfreelist[alloccode]:=ref wordp(int((freelist[alloccode])^))\r\n\r\n\treturn p\r\nfi\r\n\r\n!No items in freelists: allocate new space in this heap block\r\np:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\r\npcheapptr+:=allocbytes\t\t\t!Shrink remaining pool\r\n\r\nif pcheapptr>=pcheapend then\t\t!Overflows?\r\n\tp:=pcm_newblock(allocbytes)\t\t!Create new heap block, and allocate from start of that\r\n\treturn p\r\nfi\r\nif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\r\n\r\nreturn p\r\nend\r\n\r\nglobal proc pcm_freestr(ichar s) =\r\npcm_free(s,strlen(s)+1)\r\nend\r\n\r\nglobal proc pcm_free(ref void p,int n) =\t\t!PCM_FREE\r\n!n can be the actual size requested it does not need to be the allocated size\r\nint acode\r\n\r\nif n=0 then return fi\r\n\r\nif n>maxblocksize then\t\t!large block\r\n\tif mem_check then removefrommemalloc(p,n) fi\r\n\r\n\tfree(p)\r\n\treturn\r\nfi\r\n\r\nif p then\r\n\tacode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\r\n\r\n\tsmallmemtotal-:=allocupper[acode]\r\n\r\n\tif mem_check then removefrommemalloc(p,allocupper[acode]) fi\r\n\r\n!\t(ref wordp(p))^:=wordp(int(freelist[acode]))\r\n\tcast(p,ref wordp)^:=wordp(int(freelist[acode]))\r\n\tfreelist[acode]:=p\r\nfi\r\nend\r\n\r\nglobal proc pcm_freeac(ref void p,int alloc) =\t\t!PCM_FREEAC\r\npcm_free(p,allocupper[alloc])\r\nend\r\n\r\nglobal proc pcm_copymem4(ref void p,q,int n) =\t!PCM_COPYMEM4\r\n!copy n bytes of memory from q to p.\r\n!the memory spaces used are multiples of 16 bytes, but n itself could be anything\r\n!n can be zero, and need not be a multiple of 4 bytes\r\n\r\nmemcpy(p,q,n)\r\nend\r\n\r\nglobal proc pcm_clearmem(ref void p,int n) =\t\t!PCM_CLEARMEM\r\nmemset(p,0,n)\r\nend\r\n\r\nglobal proc pcm_init =\t\t!PCM_INIT\r\n!set up sizeindextable too\r\n!sizeindextable[0] = 0\r\nint j,k,k1,k2\r\nint64 size\r\nconst limit=1<<33\r\n\r\nif pcm_setup then\r\n\treturn\r\nfi\r\n\r\npcm_newblock(0)\r\n\r\nfor i to maxblocksize do\t!table converts eg. 78 to 4 (4th of 16,32,64,128)\r\n\tj:=1\r\n\tk:=16\r\n\twhile i>k do\r\n\t\tk:=k<<1\r\n\t\t++j\r\n\tod\r\n\tsizeindextable[i]:=j\r\nod\r\n\r\nallocupper[1]:=16\r\nsize:=16\r\n\r\nfor i:=2 to 27 do\r\n\tsize*:=2\r\n\tallocupper[i]:=size\r\n\tif size>=threshold then\r\n\t\t\tk:=i\r\n\t\texit\r\n\tfi\r\nod\r\n\r\nfor i:=k+1 to allocupper.upb do\r\n\tsize+:=alloc_step\r\n!\tif size>4 billion then\r\n!\t\tsize+:=alloc_step\r\n!\tfi\r\n\tif size<limit then\r\n\t\tallocupper[i]:=size\r\n\t\tmaxmemory:=size\r\n\telse\r\n\t\tmaxalloccode:=i-1\r\n\t\texit\r\n\tfi\r\n\t\t\r\nod\r\npcm_setup:=1\r\nend\r\n\r\nglobal function pcm_getac(int size)int =\t\t!PCM_GETAC\r\n! convert linear blocksize from 0..approx 2GB to 8-bit allocation code\r\n\r\n!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9\r\n\r\nif size<=maxblocksize then\r\n\treturn sizeindextable[size]\t\t!size 0 to 2KB\r\nfi\r\n\r\nsize:=(size+255)>>8\t\t\t\t\t!scale by 256\r\n\r\n!now same sizetable can be used for 2KB to 512KB (288 to 2KB)\r\n\r\nif size<=maxblocksize then\r\n\treturn sizeindextable[size]+8\r\nfi\r\n\r\n!sizetable now used for 512KB to 128MB (to 2KB)\r\nsize:=(size+63)>>6\t\t\t\t\t!scale by 256\r\n\r\nif size<=maxblocksize then\r\n\treturn sizeindextable[size]+14\r\nfi\r\n\r\n\r\n!size>2048, which means it had been over 128MB.\r\n\r\nsize:=(size-2048+2047)/2048+22\r\nreturn size\r\nend\r\n\r\nglobal function pcm_newblock(int itemsize)ref void=\r\n!create new heap block (can be first)\r\n!also optionally allocate small item at start\r\n!return pointer to this item (and to the heap block)\r\nstatic int totalheapsize\r\nref byte p\r\n\r\ntotalheapsize+:=pcheapsize\r\nalloccode:=0\r\np:=allocmem(pcheapsize)\t!can't free this block until appl terminates\r\nif p=nil then\r\n\tabortprogram(\"Can't alloc pc heap\")\r\nfi\r\n\r\npcheapptr:=p\r\npcheapend:=p+pcheapsize\r\n\r\nif pcheapstart=nil then\t\t!this is first block\r\n\tpcheapstart:=p\r\nfi\r\npcheapptr+:=itemsize\r\nreturn ref u32(p)\r\nend\r\n\r\nglobal function pcm_round(int n)int =\t\t!PCM_ROUND\r\n!for any size n, return actual number of bytes that would be allocated\r\nstatic [0:maxblockindex+1]int32 allocbytes=(0,16,32,64,128,256,512,1024,2048)\r\n\r\nif n>maxblocksize then\r\n\treturn n\r\nelse\r\n\treturn allocbytes[sizeindextable[n]]\r\nfi\r\nend\r\n\r\nglobal function pcm_array(int n)int =\t\t!PCM_ARRAY\r\n!n bytes are needed for an array return the number of bytes to be actually allocated\r\nint m\r\n\r\nif n<=maxblocksize then\t!automatic rounding up used for small heap\r\n\treturn pcm_round(n)\r\n! allocbytes[sizeindextable[n]]\r\nelse\t\t\t\t!devise some strategy probably doubling up.\r\n\tm:=2048\r\n\twhile n>m do\r\n\t\tm<<:=1\r\n\tod\r\n\treturn m\r\nfi\r\n\r\nend\r\n\r\nglobal proc pcm_printfreelist(int size,ref wordp p) =\t\t!PCM_PRINTFREELIST\r\nprintln \"Size: \",size\r\nwhile p do\r\n!\tprintf(\" %llX\",u64(p))\r\n\tprint \" \",,p:\"h\"\r\n\tp:=ref wordp(int(p^))\r\nod\r\nputs(\"\")\r\nend\r\n\r\nglobal proc pcm_diags(ref char caption) =\t\t!PCM_DIAGS\r\nint m\r\n\r\nprintln \"HEAP FREELISTS:\",caption\r\n\r\nm:=16\r\nfor i:=1 to 8 do\r\n\tpcm_printfreelist(m,freelist[i])\r\n\tm<<:=1\r\nod\r\nend\r\n\r\nglobal function pcm_allocz(int n)ref void =\t\t!PCM_ALLOCZ\r\nref void p\r\np:=pcm_alloc(n)\r\n\r\nmemset(p,0,n)\r\nreturn p\r\nend\r\n\r\nglobal function pcm_copyheapstring(ref char s)ref char =\r\n!allocate enough bytes for string s: copy s to the heap\r\n!return pointer to new string\r\nref char q\r\nint n\r\nif s=nil then return nil fi\r\n\r\nn:=strlen(s)+1\r\nq:=pcm_alloc(n)\r\nmemcpy(q,s,n)\r\nreturn q\r\nend\r\n\r\nglobal function pcm_copyheapstringn(ref char s,int n)ref char =\r\nref char q\r\nif s=nil then return nil fi\r\n\r\nq:=pcm_alloc(n+1)\r\nmemcpy(q,s,n)\r\n(q+n)^:=0\r\nreturn q\r\nend\r\n\r\nglobal function pcm_copyheapblock(ref char s, int length)ref char =\r\n!allocate enough bytes for string s: copy s to the heap\r\n!return pointer to new string\r\n\tref char q\r\n\tif length=0 then return nil fi\r\n\r\n\tq:=pcm_alloc(length)\r\n\tmemcpy(q,s,length)\r\n\treturn q\r\nend\r\n\r\nproc addtomemalloc(ref int32 ptr,int size)=\r\n!add ptr to allocated table\r\n\r\n!CPL \"***************ADD TO ALLOC:\",ptr,size\r\n\r\nfor i to maxmemalloc do\r\n\tif memalloctable[i]=ptr then\r\n\t\tCPL \"ALLOC ERROR:\",ptr,\"ALREADY ALLOCATED\\n\\n\\n\"\r\nCPL\r\nCPL\r\n\t\tstop 2\r\n\tfi\r\n\r\n\tif memalloctable[i]=nil then\t\t!unused entry\r\n\t\tmemalloctable[i]:=ptr\r\n\t\tmemallocsize[i]:=size\r\n\t\treturn\r\n\tfi\r\nod\r\nCPL \"MEMALLOCTABLE FULL\\n\\n\\n\\n\"; os_getch()\r\nstop 3\r\nend\r\n\r\nproc removefrommemalloc(ref int32 ptr,int size)=\r\n!remove ptr to allocated table\r\n\r\n!CPL \"------------------************REMOVE FROM ALLOC:\",ptr,size\r\n\r\nfor i to maxmemalloc do\r\n\tif memalloctable[i]=ptr then\r\n\r\nif memallocsize[i]<>size then\r\n\tCPL \"REMOVE:FOUND\",ptr,\"IN MEMALLOCTABLE, FREESIZE=\",size,\", BUT STORED AS BLOCK SIZE:\",memallocsize[i]\r\n!PCERROR(\"MEMERROR\")\r\nCPL\r\nCPL\r\n\tabortprogram(\"MEMSIZE\")\r\nfi\r\n\r\n\t\tmemalloctable[i]:=nil\r\n\t\treturn\r\n\tfi\r\nod\r\nCPL \"CAN'T FIND\",ptr,\"IN MEMALLOCTABLE\",size\r\nCPL\r\nCPL\r\nabortprogram(\"MEM\")\r\nstop 4\r\nend\r\n\r\nglobal function allocmem(int n)ref void =\t\t!ALLOCMEM\r\nref void p\r\n\r\np:=malloc(n)\r\nif (p) then\r\n\treturn p\r\nfi\r\nprintln n,memtotal\r\nabortprogram(\"Alloc mem failure\")\r\nreturn nil\r\nend\r\n\r\nglobal function reallocmem(ref void p,int n)ref void =\t\t!REALLOCMEM\r\np:=realloc(p,n)\r\nreturn p when p\r\nprintln n\r\nabortprogram(\"Realloc mem failure\")\r\nreturn nil\r\nend\r\n\r\nglobal proc abortprogram(ref char s) =\t\t!ABORTPROGRAM\r\nprintln s\r\nprint   \"ABORTING: Press key...\"\r\n!os_getch()\r\nstop 5\r\nend\r\n\r\nglobal function getfilesize(filehandle handlex)int=\t\t!GETFILESIZE\r\n\tword32 p,size\r\n\r\n\tp:=ftell(handlex)\t\t!current position\r\n\tfseek(handlex,0,2)\t\t!get to eof\r\n\tsize:=ftell(handlex)\t\t!size in bytes\r\n\tfseek(handlex,p,seek_set)\t!restore position\r\n\treturn size\r\nend\r\n\r\nglobal proc readrandom(filehandle handlex, ref byte mem, int offset, size) =\t\t!READRANDOM\r\n\tint a\r\n\tfseek(handlex,offset,seek_set)\r\n\ta:=fread(mem,1,size,handlex)\t\t\t!assign so as to remove gcc warning\r\nend\r\n\r\nglobal function writerandom(filehandle handlex, ref byte mem, int offset,size)int =\t\t!WRITERANDOM\r\n\tfseek(handlex,offset,seek_set)\r\n\treturn fwrite(mem,1,size,handlex)\r\nend\r\n\r\nglobal function setfilepos(filehandle file,int offset)int=\r\n\treturn fseek(file,offset,0)\r\nend\r\n\r\nglobal function getfilepos(filehandle file)int=\r\n\treturn ftell(file)\r\nend\r\n\r\nglobal function readfile(ref char filename)ref byte =\t\t!READFILE\r\nfilehandle f\r\nint size\r\nref byte m,p\r\n\r\nf:=fopen(filename,\"rb\")\r\nif f=nil then\r\n\treturn nil\r\nfi\r\nrfsize:=size:=getfilesize(f)\r\n\r\nm:=malloc(size+4)\t\t!allow space for etx/zeof etc\r\n\r\nif m=nil then\r\n\treturn nil\r\nfi\r\n\r\nreadrandom(f,m,0,size)\r\np:=m+size\t\t\t!point to following byte\r\np^:=0\r\n(p+1)^:=26\r\n(p+2)^:=0\t\t\t!allow use as string\r\n\r\nfclose(f)\r\nreturn m\r\nend\r\n\r\nglobal function writefile(ref char filename,ref byte data,int size)int =\r\nfilehandle f\r\nint n\r\n\r\nf:=fopen(filename,\"wb\")\r\nif f=nil then\r\n\treturn 0\r\nfi\r\n\r\nn:=writerandom(f,data,0,size)\r\nfclose(f)\r\nreturn n\r\nend\r\n\r\nglobal function checkfile(ref char file)int=\t\t!CHECKFILE\r\nfilehandle f\r\nif f:=fopen(file,\"rb\") then\r\n\tfclose(f)\r\n\treturn 1\r\nfi\r\nreturn 0\r\nend\r\n\r\nglobal proc readlinen(filehandle handlex,ref char buffer,int size) =\t\t!READLINEN\r\n!size>2\r\nint ch\r\nref char p\r\nint n\r\narray[0:100]char buff\r\nbyte crseen\r\n\r\nif handlex=nil then\r\n\thandlex:=filehandle(os_getstdin())\r\nfi\r\nif handlex=nil then\r\n\tn:=0\r\n\tp:=buffer\r\n\tdo\r\n\t\tch:=getchar()\r\n\t\tif ch=13 or ch=10 or ch=-1 then\r\n\t\t\tp^:=0\r\n\t\t\treturn\r\n\t\tfi\r\n\t\tp++^:=ch\r\n\t\t++n\r\n\t\tif n>=(size-2) then\r\n\t\t\tp^:=0\r\n\t\t\treturn\r\n\t\tfi\r\n\tod\r\nfi\r\n\r\nbuffer^:=0\r\nif fgets(buffer,size-2,handlex)=nil then\r\n\treturn\r\nfi\r\n\r\nn:=strlen(buffer)\r\nif n=0 then\r\n\treturn\r\nfi\r\n\r\np:=buffer+n-1\t\t!point to last char\r\ncrseen:=0\r\nwhile (p>=buffer and (p^=13 or p^=10)) do\r\n\tif p^=13 or p^=10 then crseen:=1 fi\r\n\tp--^ :=0\r\nod\r\n\r\n!NOTE: this check doesn't work when a line simply doesn't end with cr-lf\r\n\r\nif not crseen and (n+4>size) then\r\n\tcpl size,n\r\n\tabortprogram(\"line too long\")\r\nfi\r\nend\r\n\r\nglobal proc iconvlcn(ref char s,int n) =\t\t!ICONVLCN\r\nto n do\r\n\ts^:=tolower(s^)\r\n\t++s\r\nod\r\nend\r\n\r\nglobal proc iconvucn(ref char s,int n) =\t\t!ICONVUCN\r\nto n do\r\n\ts^:=toupper(s^)\r\n\t++s\r\nod\r\nend\r\n\r\nglobal proc convlcstring(ref char s)=\t\t!CONVLCSTRING\r\nwhile (s^) do\r\n\ts^:=tolower(s^)\r\n\t++s\r\nod\r\nend\r\n\r\nglobal proc convucstring(ref char s)=\t\t!CONVUCSTRING\r\nwhile (s^) do\r\n\ts^:=toupper(s^)\r\n\t++s\r\nod\r\nend\r\n\r\nglobal function changeext(ref char s,newext)ichar=\t\t!CHANGEEXT\r\n!whether filespec has an extension or not, change it to newext\r\n!newext should start with \".\"\r\n!return new string (locally stored static string, so must be used before calling again)\r\nstatic [260]char newfile\r\narray[32]char newext2\r\nref char sext\r\nint n\r\n\r\nstrcpy(&newfile[1],s)\r\n\r\ncase newext^\r\nwhen 0 then\r\n\tnewext2[1]:=0\r\n\tnewext2[2]:=0\r\nwhen '.' then\r\n\tstrcpy(&newext2[1],newext)\r\nelse\r\n\tstrcpy(&newext2[1],\".\")\r\n\tstrcat(&newext2[1],newext)\r\nesac\r\n\r\n\r\nsext:=extractext(s,1)\t\t\t!include \".\" when it is only extension\r\n\r\ncase sext^\r\nwhen 0 then\t\t\t\t\t\t!no extension not even \".\"\r\n\tstrcat(&newfile[1],&newext2[1])\r\nwhen '.' then\t\t\t\t\t\t!no extension not even \".\"\r\n\tstrcat(&newfile[1],&newext2[2])\r\nelse\t\t\t\t\t\t\t!has extension\r\n\tn:=sext-s-2\t\t\t!n is number of chars before the \".\"\r\n\tstrcpy(&newfile[1]+n+1,&newext2[1])\r\nesac\r\n\r\nreturn &newfile[1]\r\nend\r\n\r\nglobal function extractext(ref char s,int period=0)ichar=\t\t!EXTRACTEXT\r\n!if filespec s has an extension, then return pointer to it otherwise return \"\"\r\n!if s ends with \".\", then returns \".\"\r\nref char t,u\r\n\r\nt:=extractfile(s)\r\n\r\nif t^=0 then\t\t\t!s contains no filename\r\n\treturn \"\"\r\nfi\r\n\r\n!t contains filename+ext\r\nu:=t+strlen(t)-1\t\t!u points to last char of t\r\n\r\nwhile u>=t do\r\n\tif u^='.' then\t\t!start extension found\r\n\t\tif (u+1)^=0 then\t\t!null extension\r\n\t\t\treturn (period|\".\"|\"\")\r\n\t\tfi\r\n\t\treturn u+1\t\t\t!return last part of filename as extension exclude the dot\r\n\tfi\r\n\t--u\r\nod\r\nreturn \"\"\t\t\t!no extension seen\r\nend\r\n\r\nglobal function extractpath(ref char s)ichar=\t\t!EXTRACTPATH\r\nstatic [0:260]char str\r\nref char t\r\nint n\r\n\r\nt:=s+strlen(s)-1\t\t!t points to last char\r\n\r\nwhile (t>=s) do\r\n\tswitch t^\r\n\twhen '\\\\','/',':' then\t\t!path separator or drive letter terminator assume no extension\r\n\t\tn:=t-s+1\t\t\t!n is number of chars in path, which includes rightmost / or \\ or :\r\n\t\tmemcpy(&.str,s,n)\r\n\t\tstr[n]:=0\r\n\t\treturn &.str\r\n\tendswitch\r\n\t--t\r\nod\r\nreturn \"\"\t\t\t!no path found\r\nend\r\n\r\nglobal function extractfile(ref char s)ichar=\t\t!EXTRACTFILE\r\nref char t\r\n\r\nt:=extractpath(s)\r\n\r\nif t^=0 then\t\t\t!s contains no path\r\n\treturn s\r\nfi\r\n\r\nreturn s+strlen(t)\t\t!point to last part of s that contains the file\r\nend\r\n\r\nglobal function extractbasefile(ref char s)ichar=\t\t!EXTRACTBASEFILE\r\nstatic [0:100]char str\r\nref char f,e\r\nint n,flen\r\n\r\nf:=extractfile(s)\r\nflen:=strlen(f)\r\nif flen=0 then\t\t!s contains no path\r\n\treturn \"\"\r\nfi\r\ne:=extractext(f,0)\r\n\r\nif e^ then\t\t\t!not null extension\r\n\tn:=flen-strlen(e)-1\r\n\tmemcpy(&str,f,n)\r\n\tstr[n]:=0\r\n\treturn &.str\r\nfi\r\nif (f+flen-1)^='.' then\r\n\tmemcpy(&str,f,flen-1)\r\n\tstr[flen-1]:=0\r\n\treturn &.str\r\nfi\r\nreturn f\r\nend\r\n\r\nglobal function addext(ref char s,ref char newext)ichar=\t\t!ADDEXT\r\n!when filespec has no extension of its own, add newext\r\nref char sext\r\n\r\nsext:=extractext(s,1)\r\n\r\nif sext^=0 then\t\t\t\t\t\t!no extension not even \".\"\r\n\treturn changeext(s,newext)\r\nfi\r\n\r\nreturn s\t\t\t\t\t\t\t!has own extension; use that\r\nend\r\n\r\nglobal function alloctable(int n, size)ref void =\t\t!ALLOCTABLE\r\n!Allocate table space for n elements, each of size <size>\r\n!Allows for 1-based indexing, so allocates (n+1) elements\r\nref void p\r\n\r\np:=malloc((n+1)*size)\r\n\r\nif not p then\r\n\tabortprogram(\"Alloctable failure\")\r\nfi\r\nreturn p\r\nend\r\n\r\nglobal function zalloctable(int n, size)ref void =\t\t!ALLOCTABLE\r\n!Allocate table space for n elements, each of size <size>\r\n!Allows for 1-based indexing, so allocates (n+1) elements\r\nref int p\r\n\r\np:=alloctable(n,size)\r\n\r\npcm_clearmem(p,(n+1)*size)\r\nreturn p\r\nend\r\n\r\nglobal proc checkfreelists(ichar s)=\r\nref wordp p,q\r\nint64 aa\r\n\r\nfor i:=2 to 2 do\r\n\tp:=freelist[i]\r\n\r\n\twhile p do\r\n\t\taa:=int64(p)\r\n\t\tif aa>0xffff'FFFF or aa<100 then\r\n\t\t\tCPL s,\"FREE LIST ERROR\",i,p,q\r\n!\t\t\tos_getch(); stop 1\r\n\t\tfi\r\n\t\tq:=p\r\n\t\tp:=ref wordp(int(p^))\r\n\tod\r\n\r\nod\r\nend\r\n\r\nglobal function pcm_alloc32:ref void =\t\t!PCM_ALLOC\r\nref byte p\r\n\r\nallocbytes:=32\r\n!smallmemtotal+:=32\r\n\r\n!if p:=ref byte(freelist[2]) then\t\t!Items of this block size available\r\n!\tfreelist[2]:=ref wordp((freelist[2])^)\r\n!\tif mem_check then addtomemalloc(ref int32(p),32) fi\r\n!\treturn p\r\n!fi\r\n\r\n!No items in freelists: allocate new space in this heap block\r\n\r\nreturn pcm_alloc(32)\r\nend\r\n\r\nglobal proc pcm_free32(ref void p) =\r\n!n can be the actual size requested it does not need to be the allocated size\r\n\r\n!CPL \"PCMFREE32\"\r\nsmallmemtotal-:=32\r\nif mem_check then removefrommemalloc(p,32) fi\r\n!(ref wordp(p))^:=wordp(int(freelist[2]))\r\ncast(p,ref wordp)^:=wordp(int(freelist[2]))\r\nfreelist[2]:=p\r\nend\r\n\r\nglobal proc outbyte(filehandle f,int x)=\r\nfwrite(&x,1,1,f)\r\nend\r\n\r\nglobal proc outword16(filehandle f,word x)=\r\nfwrite(&x,2,1,f)\r\nend\r\n\r\nglobal proc outword(filehandle f,word x)=\r\nfwrite(&x,4,1,f)\r\nend\r\n\r\nglobal proc outword64(filehandle f,word64 x)=\r\nfwrite(&x,8,1,f)\r\nend\r\n\r\nglobal function myeof(filehandle f)int=\r\nint c\r\n\r\nc:=fgetc(f)\r\nif c=c_eof then return 1 fi\r\nungetc(c,f)\r\nreturn 0;\r\nend\r\n\r\nglobal function pcm_smallallocz(int n)ref void =\r\nref byte p\r\n\r\nif (alloccode:=sizeindextable[n])=0 then\r\n\talloccode:=1\r\nfi\r\nallocbytes:=allocupper[alloccode]\r\n\r\n!No items in freelists: allocate new space in this heap block\r\np:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\r\npcheapptr+:=allocbytes\t\t\t!Shrink remaining pool\r\n\r\nif pcheapptr>=pcheapend then\t\t!Overflows?\r\n\tp:=pcm_newblock(allocbytes)\t\t!Create new heap block, and allocate from start of that\r\n\tmemset(p,0,n)\r\n\treturn p\r\nfi\r\n\r\nmemset(p,0,n)\r\n\r\nreturn p\r\nend\r\n\r\n!global function pcm_fastalloc(int n)ref void =\r\nglobal function pcm_smallalloc(int n)ref void =\r\nref byte p\r\n\r\nif (alloccode:=sizeindextable[n])=0 then\r\n\talloccode:=1\r\nfi\r\nallocbytes:=allocupper[alloccode]\r\n\r\n!No items in freelists: allocate new space in this heap block\r\np:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\r\npcheapptr+:=allocbytes\t\t\t!Shrink remaining pool\r\n\r\nif pcheapptr>=pcheapend then\t\t!Overflows?\r\n\tp:=pcm_newblock(allocbytes)\t\t!Create new heap block, and allocate from start of that\r\n\treturn p\r\nfi\r\n\r\nreturn p\r\nend\r\n\r\nglobal proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)=\r\nint newlen,oldlen\r\nichar newptr\r\n\r\nIF N=0 THEN CPL \"N=0\" FI\r\n\r\nif n=-1 then\r\n\tn:=strlen(s)\r\nfi\r\n\r\noldlen:=dest^.length\r\n\r\nif oldlen=0 then\t\t\t\t!first string\r\n\tdest^.strptr:=pcm_alloc(n+1)\r\n\tdest^.allocated:=allocbytes\r\n\tdest^.length:=n\t\t\t\t!length always excludes terminator\r\n\tmemcpy(dest^.strptr,s,n)\r\n\t(dest^.strptr+n)^:=0\r\n\treturn\r\nfi\r\n\r\nnewlen:=oldlen+n\r\nif newlen+1>dest^.allocated then\r\n!CPL \"REALLOC\",NEWLEN\r\n\tnewptr:=pcm_alloc(newlen+1)\r\n\tmemcpy(newptr,dest^.strptr,oldlen)\r\n\tdest^.strptr:=newptr\r\n\tdest^.allocated:=allocbytes\r\nfi\r\n\r\nmemcpy(dest^.strptr+oldlen,s,n)\r\n(dest^.strptr+newlen)^:=0\r\n\r\ndest^.length:=newlen\r\nend\r\n\r\nglobal proc gs_init(ref strbuffer dest)=\t\t\t!INITGENSTR\r\npcm_clearmem(dest,strbuffer.bytes)\r\nend\r\n\r\nglobal proc gs_free(ref strbuffer dest)=\r\nif dest^.allocated then\r\n\tpcm_free(dest^.strptr,dest^.allocated)\r\nfi\r\nend\r\n\r\nglobal proc gs_str(ref strbuffer dest,ichar s)=\t\t\t!GENSTR\r\nstrbuffer_add(dest,s)\r\nend\r\n\r\nglobal proc gs_char(ref strbuffer dest,int c)=\r\narray[16]char s\r\n\r\ns[1]:=c\r\ns[2]:=0\r\n\r\nstrbuffer_add(dest,&.s,1)\r\nend\r\n\r\nglobal proc gs_strn(ref strbuffer dest,ichar s,int length)=\r\nstrbuffer_add(dest,s,length)\r\nend\r\n\r\nglobal proc gs_strvar(ref strbuffer dest,s)=\t\t\t!GENSTR\r\nstrbuffer_add(dest,s^.strptr)\r\nend\r\n\r\nglobal proc gs_strint(ref strbuffer dest,int64 a)=\r\nstrbuffer_add(dest,strint(a))\r\nend\r\n\r\nglobal proc gs_strln(ref strbuffer dest,ichar s)=\t\t!GENSTRLN\r\ngs_str(dest,s)\r\ngs_line(dest)\r\nend\r\n\r\nglobal proc gs_strsp(ref strbuffer dest,ichar s)=\r\ngs_str(dest,s)\r\ngs_str(dest,\" \")\r\nend\r\n\r\nglobal proc gs_line(ref strbuffer dest)=\r\nstrbuffer_add(dest,\"\\w\")\r\nend\r\n\r\nglobal function gs_getcol(ref strbuffer dest)int=\r\nreturn dest^.length\r\nend\r\n\r\nglobal proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')=\r\nint col,i,n,slen\r\narray[2560]char str\r\ncol:=dest^.length\r\nstrcpy(&.str,s)\r\nslen:=strlen(s)\r\nn:=w-slen\r\n!CPL =slen,=w,=n\r\nif n>0 then\r\n\tfor i:=1 to n do\r\n\t\tstr[slen+i]:=padch\r\n\tod\r\n\tstr[slen+n+1]:=0\r\nfi\r\ngs_str(dest,&.str)\r\nend\r\n\r\nglobal proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')=\r\ngs_leftstr(dest,strint(a),w,padch)\r\nend\r\n\r\nglobal proc gs_padto(ref strbuffer dest,int col, ch=' ')=\r\nint n\r\narray[2560]char str\r\n\r\nn:=col-dest^.length\r\nif n<=0 then return fi\r\nfor i:=1 to n do\r\n\tstr[i]:=ch\r\nod\r\nstr[n+1]:=0\r\ngs_str(dest,&.str)\r\nend\r\n\r\nglobal proc gs_println(ref strbuffer dest,filehandle f)=\r\n(dest.strptr+dest.length)^:=0\r\n\r\nif f=nil then\r\n\tprintln dest.strptr,,\"\\c\"\r\nelse\r\n\tprintln @f,dest.strptr,,\"\\c\"\r\nfi\r\nend\r\n\r\nglobal function nextcmdparam(int &paramno, ichar &name, &value, ichar defext=nil)int=\r\nstatic int infile=0\r\nstatic ichar filestart=nil\r\nstatic ichar fileptr=nil\r\nstatic byte colonseen=0\r\nref char q\r\nichar item,fileext\r\nichar rest\r\nint length\r\nstatic [300]char str\r\n\r\n!CPL \"NEXTCMD\",NSYSPARAMS\r\n\r\nreenter::\r\nvalue:=nil\r\nname:=nil\r\n\r\nif infile then\r\n\tif readnextfileitem(fileptr,item)=0 then\t\t!eof\r\n\t\tfree(filestart)\t\t\t\t\t\t\t\t!file allocated via malloc\r\n\t\tinfile:=0\r\n\t\tgoto reenter\r\n\tfi\r\nelse\r\n\tif paramno>nsysparams then\r\n\t\treturn pm_end\r\n\tfi\r\n\titem:=sysparams[paramno]\r\n\t++paramno\r\n\r\n\tlength:=strlen(item)\r\n\r\n\tif item^='@' then\t\t!@ file\r\n\t\tfilestart:=fileptr:=cast(readfile(item+1))\r\n\t\tif filestart=nil then\r\n\t\t\tprintln \"Can't open\",item\r\n\t\t\tstop 7\r\n\t\tfi\r\n\t\tinfile:=1\r\n\t\tgoto reenter\r\n\tfi\r\n\r\n\tif item^=':' then\r\n\t\tcolonseen:=1\r\n\t\treturn pm_colon\r\n\tfi\r\nfi\r\n\r\nvalue:=nil\r\nif item^='-' then\r\n\tname:=item+(colonseen|0|1)\r\n\tq:=strchr(item,':')\r\n\tif not q then\r\n\t\tq:=strchr(item,'=')\r\n\tfi\r\n\tif q then\r\n\t\tvalue:=q+1\r\n\t\tq^:=0\r\n\tfi\r\n\treturn (colonseen|pm_extra|pm_option)\r\nfi\r\n\r\nfileext:=extractext(item,0)\r\nname:=item\r\n\r\nif fileext^=0 then\t\t\t\t\t\t\t!no extension\r\n\tstrcpy(&.str,name)\r\n\tif defext and not colonseen then\r\n\t\tname:=addext(&.str,defext)\t\t\t\t!try .c\r\n\tfi\r\nelsif eqstring(fileext,\"dll\") then\r\n\treturn (colonseen|pm_extra|pm_libfile)\r\nfi\r\nreturn (colonseen|pm_extra|pm_sourcefile)\r\nend\r\n\r\nfunction readnextfileitem(ichar &fileptr,&item)int=\r\nref char p,pstart,pend\r\nint n\r\nstatic [256]char str\r\n\r\np:=fileptr\r\n\r\nreenter::\r\ndo\r\n\tcase p^\r\n\twhen ' ','\\t',13,10 then\t!skip white space\r\n\t\t++p\r\n\twhen 26,0 then\t\t\t\t!eof\r\n\t\treturn 0\r\n\telse\r\n\t\texit\r\n\tesac\r\nod\r\n\r\ncase p^\r\nwhen '!', '#' then\t\t\t!comment\r\n\t++p\r\n\tdocase p++^\r\n\twhen 10 then\r\n\t\tgoto reenter\r\n\twhen 26,0 then\r\n\t\tfileptr:=p-1\r\n\t\treturn 0\r\n\telse\r\n\r\n\tenddocase\r\nesac\r\n\r\n\r\ncase p^\r\nwhen '\"' then\t\t\t\t!read until closing \"\r\n\tpstart:=++p\r\n\tdo\r\n\t\tcase p^\r\n\t\twhen 0,26 then\r\n\t\t\tprintln \"Unexpected EOF in @file\"\r\n\t\t\tstop 8\r\n\t\twhen '\"' then\r\n\t\t\tpend:=p++\r\n\t\t\tif p^=',' then ++p fi\r\n\t\t\texit\r\n\t\tesac\r\n\t\t++p\r\n\tod\r\nelse\r\n\tpstart:=p\r\n\tdo\r\n\t\tcase p^\r\n\t\twhen 0,26 then\r\n\t\t\tpend:=p\r\n\t\t\texit\r\n\t\twhen ' ','\\t',',',13,10 then\r\n\t\t\tpend:=p++\r\n\t\t\texit\r\n\t\tesac\r\n\t\t++p\r\n\tod\r\nesac\r\n\r\nn:=pend-pstart\r\nif n>=str.len then\r\n\tprintln \"@file item too long\"\r\n\tstop 9\r\nfi\r\nmemcpy(&.str,pstart,n)\r\nstr[n+1]:=0\r\nitem:=&.str\r\nfileptr:=p\r\n\r\nreturn 1\r\nend\r\n\r\nglobal proc ipadstr(ref char s,int width,ref char padchar=\" \")=\r\nint n\r\n\r\nn:=strlen(s)\r\nto width-n do\r\n\tstrcat(s,padchar)\r\nod\r\nend\r\n\r\nglobal function padstr(ref char s,int width,ref char padchar=\" \")ichar=\r\nstatic [256]char str\r\n\r\nstrcpy(&.str,s)\r\nipadstr(&.str,width,padchar)\r\nreturn &.str\r\nend\r\n\r\nglobal function chr(int c)ichar=\r\nstatic [8]char str\r\n\r\nstr[1]:=c\r\nstr[2]:=0\r\nreturn &.str\r\nend\r\n\r\nglobal function cmpstring(ichar s,t)int=\r\n\tint res\r\n\tif (res:=strcmp(s,t))<0 then\r\n\t\treturn -1\r\n\telsif res>0 then\r\n\t\treturn 1\r\n\telse\r\n\t\treturn 0\r\n\tfi\r\nend\r\n\r\nglobal function cmpstringn(ichar s,t,int n)int=\r\n\tint res\r\n\tif (res:=strncmp(s,t,n))<0 then\r\n\t\treturn -1\r\n\telsif res>0 then\r\n\t\treturn 1\r\n\telse\r\n\t\treturn 0\r\n\tfi\r\nend\r\n\r\nglobal function eqstring(ichar s,t)int=\r\n\treturn strcmp(s,t)=0\r\nend\r\n\r\nglobal function cmpbytes(ref void p,q,int n)int=\r\n\tint res\r\n\tif (res:=memcmp(p,q,n))<0 then\r\n\t\treturn -1\r\n\telsif res>0 then\r\n\t\treturn 1\r\n\telse\r\n\t\treturn 0\r\n\tfi\r\nend\r\n\r\nglobal function eqbytes(ref void p,q,int n)int=\r\n\treturn memcmp(p,q,n)=0\r\nend\r\n\r\n\r\nglobal proc mseed(word64 a,b=0)=\r\nseed[1]:=a\r\nif b then\r\n\tseed[2]:=b\r\nelse\r\n\tseed[2] ixor:=a\r\nfi\r\nend\r\n\r\nglobal function mrandom:word =\r\n!return pure 64-bit word value, 0 to 2**64-1\r\n!(cast result for signed value)\r\n\tword64 x,y\r\n\tx:=seed[1]\r\n\ty:=seed[2]\r\n\tseed[1]:=y\r\n\tx ixor:=(x<<23)\r\n\tseed[2]:= x ixor y ixor (x>>17) ixor (y>>26)\r\n\treturn seed[2]+y\r\nend\r\n\r\nglobal function mrandomp:int =\r\n!pure 64-bit int value, positive only, 0 to 2**63-1\r\n\treturn mrandom() iand 0x7FFF'FFFF'FFFF'FFFF\r\nend\r\n\r\nglobal function mrandomint(int n)int=\r\n!positive random int value from 0 to n-1\r\n\treturn mrandomp() rem n\r\nend\r\n\r\nglobal function mrandomrange(int a,b)int=\r\n!random int value from a to b inclusive\r\n!span extent must be 1 to 2**63-1\r\n\tint span\r\n\tspan:=b-a+1\r\n\tif span<=0 then\r\n\t\treturn 0\r\n\tfi\r\n\treturn (mrandomp() rem span)+a\r\nend\r\n\r\n!global function mrandomreal:real =\r\n!!positive random real value from 0 to 0.999999999999999999891579782751449556599254719913005828857421875\r\n!!upper limit is (2**63-1)/(2**63)\r\n!\treturn real(mrandomp())/9223372036854775808.0\r\n!end\r\n\r\nglobal function mrandomreal:real x=\r\n!positive random real value from 0 to just under (but not including) 1.0\r\n\trepeat x:=mrandomp()/9223372036854775808.0 until x<>1.0\r\n\treturn x\r\nend\r\n\r\nglobal function mrandomreal1:real=\r\n!positive random real value from 0 to 1.0 inclusive\r\n\treturn mrandomp()/9223372036854775807\r\nend\r\n\r\nglobal function checkpackfile:ref byte=\r\n!find out if this executable contains extra packed files\r\n!return 1 or 0\r\n\r\nint a,offset,i,size\r\narray[100]char name\r\narray[300]char exefile\r\nref byte packexeptr\t\t\t!for embedded pack files, contains pointer to in-memory version of this .exe file plus extras; else nil\r\nint packexesize\t\t\t\t!byte size\r\nref char packfilename\r\nint packfilesize\r\nref byte packfileptr\r\n\r\n!macro getfileint(data,offset)=(ref int32(data+offset))^\r\nmacro getfileint(data,offset)=cast(data+offset,ref int32)^\r\n\r\nstrcpy(&exefile[1],os_gethostname())\r\nprintln \"Attempting to open\",&exefile\r\npackexeptr:=readfile(&exefile[1])\r\n\r\nif not packexeptr then\r\n\tcpl \"Can't open\",&exefile,&packexeptr\r\n\tstop\r\nfi\r\n\r\npackexesize:=rfsize\r\ncpl \"File read OK. Size\",packexesize\r\n!STOP\r\n\r\na:=getfileint(packexeptr,packexesize-int32.bytes)\r\nif a<>'PCAK' then\r\n\tfree(packexeptr)\r\n\tpackfileptr:=nil\r\n\treturn nil\r\nfi\r\n\r\noffset:=getfileint(packexeptr,packexesize-int32.bytes*2)\r\n\r\npackfilename:=cast(packexeptr+offset)\r\noffset+:=strlen(packfilename)+1\r\npackfilesize:=getfileint(packexeptr,offset)\r\npackfileptr:=packexeptr+offset+int32.bytes\r\n\r\nreturn packfileptr\r\nend\r\n",\
(uint8_t*)"global type filehandle=ref void\r\n\r\nimportlib $cstd=\r\n!\tclang function malloc\t(wordm)ref void\r\n\tclang function malloc\t(word64)ref void\r\n\tclang function realloc\t(ref void, wordm)ref void\r\n\tclang proc     free\t\t(ref void)\r\n\tclang proc     memset\t(ref void, int32, wordm)\r\n\tclang proc     memcpy\t(ref void, ref void, wordm)\r\n\tclang function clock\t:int32\r\n\tclang function ftell\t(filehandle)int32\r\n\tclang function fseek\t(filehandle, int32, int32)int32\r\n\tclang function fread\t(ref void, wordm, wordm, filehandle)wordm\r\n\tclang function fwrite\t(ref void, wordm, wordm, filehandle)wordm\r\n\tclang function getc\t\t(filehandle)int32\r\n\tclang function ungetc\t(int32, filehandle)int32\r\n\tclang function fopen\t(ichar,ichar=\"rb\")filehandle\r\n\tclang function fclose\t(filehandle)int32\r\n\tclang function fgets\t(ichar, int, filehandle)ichar\r\n\tclang function remove\t(ichar)int32\r\n\tclang function rename\t(ichar, ichar)int32\r\n\tclang function getchar\t:int32\r\n\tclang proc     putchar\t(int32)\r\n\tclang proc     setbuf\t(filehandle, ref byte)\r\n\r\n\tclang function strlen\t(ichar)wordm\r\n\tclang function strcpy\t(ichar, ichar)ichar\r\n\tclang function strcmp\t(ichar, ichar)int32\r\n\tclang function strncmp\t(ichar, ichar, wordm)int32\r\n\tclang function strncpy\t(ichar, ichar, wordm)wordm\r\n\tclang function memcmp\t(ref void, ref void, wordm)int32\r\n\tclang function strcat\t(ichar, ichar)ichar\r\n\tclang function tolower\t(int32)int32\r\n\tclang function toupper\t(int32)int32\r\n\tclang function isalpha\t(int32)int32\r\n\tclang function isupper\t(int32)int32\r\n\tclang function islower\t(int32)int32\r\n\tclang function isalnum\t(int32)int32\r\n\tclang function isspace\t(int32)int32\r\n\tclang function strstr\t(ichar, ichar)ichar\r\n\tclang function atol\t\t(ichar)intm\r\n\tclang function atoi\t\t(ichar)int32\r\n\tclang function strtod\t(ichar,ref ref char)real64\r\n\r\n\tclang function puts\t\t(ichar)int32\r\n\tclang function printf\t(ichar, ...)int32\r\n\r\n\tclang function sprintf\t(ichar, ichar, ...)int32\r\n!\tclang function __mingw_sprintf\t(ichar, ...)int32\r\n\r\n\tclang function sscanf\t(ichar, ichar, ...)int32\r\n\tclang function scanf\t(ichar, ...)int32\r\n\r\n\tclang function rand\t\t:int32\r\n\tclang proc     srand\t(word32)\r\n\tclang function system\t(ichar)int32\r\n\r\n\tclang function fgetc\t(filehandle)int32\r\n\tclang function fputc\t(int32,  filehandle)int32\r\n\tclang function fprintf\t(filehandle, ichar, ...)int32\r\n\tclang function fputs\t(ichar,  filehandle)int32\r\n\tclang function feof\t\t(filehandle)int32\r\n\tclang function getch\t:int32\r\n\tclang function kbhit\t:int32\r\n\tclang function _mkdir\t(ichar)int32\r\n\tclang function mkdir\t(ichar)int32\r\n\tclang function dummy\t(real)real\r\n\tclang function strchr\t(ichar,int32)ichar\r\n\r\n\tclang proc     _exit\t(int32)\r\n\tclang proc     \"exit\"\t(int32)\r\n!\tclang proc     `exit\t(int32)\r\n\tclang function\tpow\t\t(real,real)real\r\n\r\n\tclang function\t`sin\t(real)real\r\n\tclang function\t`cos\t(real)real\r\n\tclang function\t`tan\t(real)real\r\n\tclang function\t`asin\t(real)real\r\n\tclang function\t`acos\t(real)real\r\n\tclang function\t`atan\t(real)real\r\n\tclang function\t`log\t(real)real\r\n\tclang function\t`log10\t(real)real\r\n\tclang function\t`exp\t(real)real\r\n\tclang function\t`floor\t(real)real\r\n\tclang function\t`ceil\t(real)real\r\n\r\n\tclang proc      qsort   (ref void, word64, word64, ref proc)\r\n\r\nend\r\n\r\nimportlib $cstdextra=\r\n\tclang function __getmainargs(ref int32, ref void, ref void, int, ref void)int32\r\nend\r\n\r\nglobal const c_eof\t\t=-1\r\nglobal const seek_set\t= 0\r\nglobal const seek_curr\t= 1\r\nglobal const seek_end\t= 2\r\n",\
(uint8_t*)"import clib\r\nimport mlib\r\n\r\nconst wm_destroy=2\r\n\r\ntype wt_word\t= word16\r\ntype wt_wordpm\t= word32\r\ntype wt_bool\t= word32\r\ntype wt_dword\t= word32\r\ntype wt_wchar\t= word16\r\ntype wt_wcharpm\t= word32\r\ntype wt_char\t= byte\r\ntype wt_ichar\t= ref char\r\ntype wt_ptr\t\t= ref void\r\ntype wt_wndproc\t= ref proc\r\ntype wt_handle\t= ref void\r\ntype wt_int\t\t= int32\r\ntype wt_uint\t= word32\r\ntype wt_long\t= int32\r\ntype wt_wparam\t= wordm\r\ntype wt_lparam\t= wordm\r\ntype wt_point\t= rpoint\r\n\r\nglobal record rsystemtime =\r\n\twt_word year\r\n\twt_word month\r\n\twt_word dayofweek\r\n\twt_word day\r\n\twt_word hour\r\n\twt_word minute\r\n\twt_word second\r\n\twt_word milliseconds\r\nend\r\n\r\nimportdll $windowsdlls=\r\n!\twindows function \"VirtualAlloc\"(wt_ptr, dint,wt_dword,wt_dword)wt_ptr\r\n\twindows function \"GetStdHandle\"(wt_dword)wt_handle\r\n\twindows function \"GetConsoleScreenBufferInfo\"(wt_handle,wt_ptr)wt_bool\r\n\twindows function \"SetConsoleCtrlHandler\"(wt_wndproc,wt_bool)wt_bool\r\n\twindows function \"SetConsoleMode\"(wt_handle,wt_dword)wt_bool\r\n\twindows function \"CreateProcessA\"(wt_ichar,wt_ichar,wt_ptr,wt_ptr, wt_bool,\r\n\t\t\t\t\t\twt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)wt_bool\r\n\twindows function \"GetLastError\":wt_dword\r\n\twindows function \"WaitForSingleObject\"(wt_handle,wt_dword)wt_dword\r\n\twindows function \"GetExitCodeProcess\"(wt_handle,wt_ptr)wt_bool\r\n\twindows function \"CloseHandle\"(wt_handle)wt_bool\r\n\twindows function \"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)wt_bool\r\n\twindows function \"FlushConsoleInputBuffer\"(wt_handle)wt_bool\r\n\twindows function \"LoadLibraryA\"(wt_ichar)wt_handle\r\n!\twindows function \"GetProcAddress\"(wt_handle,wt_ichar)wt_wndproc\r\n\twindows function \"GetProcAddress\"(wt_handle,wt_ichar)ref void\r\n\twindows function \"LoadCursorA\"(wt_handle,wt_ichar)wt_handle\r\n\twindows function \"RegisterClassExA\"(wt_ptr)wt_wordpm\r\n\twindows function \"DefWindowProcA\"(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_bool\r\n\twindows function \"ReadConsoleInputA\"(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\r\n\twindows proc     \"Sleep\"(wt_dword)\r\n\twindows function \"GetModuleFileNameA\"(wt_handle,wt_ichar,wt_dword)wt_dword\r\n\r\n\twindows proc     \"ExitProcess\"(wt_uint)\r\n\twindows proc\t \"PostQuitMessage\"(wt_int)\r\n\r\n!\twindows proc\t \"MessageBoxA\"(wt_int,wt_ichar,wt_ichar,wt_int)\r\n\r\n\twindows proc\t \"MessageBoxA\"(wt_int x=0,wt_ichar message, caption=\"Caption\",wt_int y=0)\r\n\r\n\twindows function \"QueryPerformanceCounter\"(ref int64)wt_bool\r\n\twindows function \"QueryPerformanceFrequency\"(ref int64)wt_bool\r\n\r\n\twindows function \"CreateFileA\"(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle\r\n\twindows function \"GetFileTime\"(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool\r\n\r\n\twindows proc     \"GetSystemTime\"(ref rsystemtime)\r\n\twindows proc     \"GetLocalTime\"(ref rsystemtime)\r\n\r\n\twindows function \"GetTickCount\":wt_dword\r\n\twindows function \"PeekMessageA\"\t\t(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool\r\n\r\nend\r\n\r\nrecord input_record =\r\n\twt_word\teventtype\r\n\tword16\tpadding\r\n\t\twt_bool\tkeydown\t\t\t!key event record (was inside 'Event' union in win32)\r\n\t\twt_word\trepeatcount\r\n\t\twt_word\tvirtualkeycode\r\n\t\twt_word\tvirtualscancode\r\n\t\tunion\r\n\t\t\twt_word unicodechar\r\n\t\t\twt_char asciichar\r\n\t\tend\r\n\t\twt_dword controlkeystate\r\nend\r\n\r\nrecord rspoint=(int16 x,y)\r\n\r\nrecord rsrect=\r\n\tint16 leftx,top,rightx,bottom\r\nend\r\n\r\nglobal record rpoint =\r\n\twt_long x,y\r\nend\r\n\r\nrecord rconsole=\r\n\trspoint size,pos\r\n\tword16 attributes\r\n\trsrect window\r\n\trspoint maxwindowsize\r\nend\r\n\r\nrecord rstartupinfo =\r\n\twt_dword\tsize\r\n!.if $64bit\r\n\tword32 dummy1\r\n!.endif\r\n\twt_ichar\treserved\r\n\twt_ichar\tdesktop\r\n\twt_ichar\ttitle\r\n\twt_dword\tx\r\n\twt_dword\ty\r\n\twt_dword\txsize\r\n\twt_dword\tysize\r\n\twt_dword\txcountchars\r\n\twt_dword\tycountchars\r\n\twt_dword\tfillattribute\r\n\twt_dword\tflags\r\n\twt_word\t\tshowwindow\r\n\twt_word\t\treserved2\r\n!.if $64bit\r\n\tword32 dummy2\r\n!.endif\r\n\twt_ptr\t\treserved4\r\n\twt_handle\tstdinput\r\n\twt_handle\tstdoutput\r\n\twt_handle\tstderror\r\nend\r\n\r\nrecord rprocess_information =\r\n\twt_handle process\r\n\twt_handle thread\r\n\twt_dword processid\r\n\twt_dword threadid\r\nend\r\n\r\nrecord rwndclassex =\r\n\twt_uint\t\tsize\r\n\twt_uint\t\tstyle\r\n\twt_wndproc\twndproc\r\n\twt_int\t\tclsextra\r\n\twt_int\t\twndextra\r\n\twt_handle\tinstance\r\n\twt_handle\ticon\r\n\twt_handle\tcursor\r\n!\twt_handle\tbackground\r\n\twt_handle\tbackground\r\n\twt_ichar\tmenuname\r\n\twt_ichar\tclassname\r\n\twt_handle\ticonsm\r\nend\r\n\r\nglobal record rmsg =\r\n\twt_handle\thwnd\r\n\twt_uint\t\tmessage\r\n!.if $64bit\r\n\tword32\t\tdummy1\r\n!.endif\r\n\twt_wparam\twParam\r\n\twt_lparam\tlParam\r\n\twt_dword\ttime\r\n!.if $64bit\r\n\tword32\t\tdummy2\r\n!.endif\r\n\twt_point\tpt\r\nend\r\n\r\n!wt_word x\r\nconst NORMAL_PRIORITY_CLASS=32\r\nconst CREATE_NEW_CONSOLE=16\r\nconst DETACHED_PROCESS=16\r\n\r\nwt_handle hconsole, hconsolein\r\n\r\ninput_record lastkey, pendkey\r\nint keypending\t\t\t!whether pendkey contains a new key event detected by flushkbd\r\n\r\nref function(ref void)int wndproc_callbackfn=nil\t!windows call-back: address of handler\r\n\r\nint init_flag=0\r\n\r\nglobal proc os_init=\r\nint i,count\r\nrconsole info\r\n\r\n!general initialisation\r\nhconsole:=GetStdHandle(u32(-11))\r\nhconsolein:=GetStdHandle(u32(-10))\r\n\r\nlastkey.repeatcount:=0\r\nkeypending:=0\r\n\r\n!CPL \"OSINIT\"\r\nSetConsoleCtrlHandler(nil,1)\r\n\r\nSetConsoleMode(hconsole,1 ior 2)\r\n!SetConsoleMode(hconsole,1 )\r\n\r\ninit_flag:=1\r\n\r\nend\r\n\r\nglobal function os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\r\nwt_dword exitcode\r\nint status\r\nint cflags:=0\r\n\r\nrstartupinfo si\r\nrprocess_information xpi\r\n\r\nmemset(&si,0,si.bytes)\r\nmemset(&xpi,0,xpi.bytes)\r\n\r\nswitch newconsole\r\nwhen 0 then cflags := NORMAL_PRIORITY_CLASS\r\nwhen 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE\r\nwhen 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS\r\nendswitch\r\n\r\nsi.size := rstartupinfo.bytes\r\n\r\nstatus:=CreateProcessA( nil,\r\n\tcmdline,\r\n\tnil,\r\n\r\n\tnil,\r\n\t1,\r\n\tcflags,\r\n\r\n\tnil,\r\n\tnil,\r\n\t&si,\r\n\t&xpi )\r\n\r\nif status=0 then\t\t!fails\r\n\tstatus:=GetLastError()\r\n\tprintln \"Winexec error:\",status\r\n\treturn -1\r\nend\r\n\r\nWaitForSingleObject(xpi.process, 0xFFFF'FFFF)\r\nGetExitCodeProcess(xpi.process,&exitcode)\r\n\r\nCloseHandle(xpi.process)\r\nCloseHandle(xpi.thread)\r\n\r\nreturn exitcode\r\nend\r\n\r\nglobal function os_execcmd(ichar cmdline, int newconsole=0)int =\r\nwt_dword exitcode\r\nint i,j,k\r\n\r\nrstartupinfo si\r\nrprocess_information xpi\r\n\r\nmemset(&si,0,si.bytes)\r\nmemset(&xpi,0,xpi.bytes)\r\n\r\nsi.size := rstartupinfo.bytes\r\n\r\nCreateProcessA( nil,\r\n\tcmdline,\r\n\tnil,\r\n\tnil,\r\n\t1,\r\n\tNORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),\r\n\tnil,\r\n\tnil,\r\n\t&si,\r\n\t&xpi )\r\n\r\nCloseHandle(xpi.process)\r\nCloseHandle(xpi.thread)\r\n\r\nreturn 1\r\nend\r\n\r\nglobal function os_getch:int=\r\nint k\r\n\r\nk:=os_getchx() iand 255\r\n\r\nreturn k\r\nend\r\n\r\nglobal function os_kbhit:int=\r\nwt_dword count\r\n!os_init() unless init_flag\r\n\r\nunless init_flag then os_init() end\r\n!unless initflag then: os_init()\r\n\r\nGetNumberOfConsoleInputEvents(hconsolein,&count)\r\nreturn count>1\r\nend\r\n\r\nglobal proc os_flushkeys=\r\nFlushConsoleInputBuffer(hconsolein)\r\nend\r\n\r\nglobal function os_getconsolein:ref void=\r\nreturn ref void(hconsolein)\r\nend\r\n\r\nglobal function os_getconsoleout:ref void=\r\nreturn ref void(hconsole)\r\nend\r\n\r\nglobal function os_proginstance:ref void=\r\nabortprogram(\"PROGINST\")\r\nreturn nil\r\nend\r\n\r\nglobal function os_getdllinst(ichar name)u64=\r\nwt_handle hinst\r\n\r\nhinst:=LoadLibraryA(name)\r\nreturn cast(hinst)\r\nend\r\n\r\nglobal function os_getdllprocaddr(intm hinst,ichar name)ref void=\r\nreturn GetProcAddress(cast(int(hinst)),name)\r\nend\r\n\r\nglobal proc os_initwindows=\r\nos_init()\r\nos_gxregisterclass(\"pcc001\")\r\nend\r\n\r\nglobal proc os_gxregisterclass(ichar classname)=\r\nconst idcarrow=32512\r\nrwndclassex r\r\nstatic byte registered\r\n\r\nif registered then\r\n\treturn\r\nfi\r\n\r\n!CPL \"REG CLASS\"\r\n\r\nmemset(&r,0,r.bytes)\r\nr.size:=r.bytes\r\nr.style:=8 ior 32\t\t!CS_DBLCLKS | CS_OWNDC\r\nr.wndproc:=cast(&mainwndproc)\r\n!r.wndproc:=&xmainwndproc\r\n!r.wndproc:=&cmainwndproc\r\nr.instance:=nil\r\n\r\nr.icon:=nil\t\t!loadicon(proginstance,\"SCW32\")\r\nr.cursor:=LoadCursorA(nil,ref void(idcarrow))\t\t!IDC_ARROW)\r\nr.background:=cast(15+1)\t\t\t\t\t!COLOR_BTNFACE+1\r\nr.menuname:=nil\r\nr.classname:=classname\r\nr.iconsm:=nil\t!loadicon(proginstance,\"SCW32\")\r\n\r\nif RegisterClassExA(&r)=0 then\r\n\tprintln classname,GetLastError\r\n\tabortprogram(\"Registerclass error\")\r\nend\r\nregistered:=1\r\nend\r\n\r\nglobal callback function mainwndproc (\\\r\n\t\twt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)intm=\r\nrmsg m\r\nint i,result\r\nintm l\r\nstatic int count=0\r\n\r\n!CPL \"MAINWND/MX\",=HWND, =MESSAGE, =WPARAM, =LPARAM:\"H\",WT_LPARAM.BYTES\r\n\r\nm.hwnd:=hwnd\r\nm.message:=message\r\nm.wParam:=wParam\r\nm.lParam:=lParam\r\nm.pt.x:=0\r\nm.pt.y:=0\r\n\r\nif (wndproc_callbackfn) then\r\n\tresult:=(wndproc_callbackfn^)(&m)\r\nelse\r\n\tresult:=0\r\nfi\r\n!CPL \"\t\",=RESULT\r\n\r\nif m.message=wm_destroy then\r\n\treturn 0\r\nfi\r\n\r\nif not result then\r\n\treturn DefWindowProcA(hwnd,message,wParam,lParam)\r\nelse\r\n\treturn 0\r\nfi\r\nend\r\n\r\n!callback proc timerproc(wt_handle hwnd, int msg, id, time)=\r\nproc timerproc(wt_handle hwnd, int msg, id, time)=\r\nprintln \"TIMERPROC\"\r\nend\r\n\r\nglobal proc os_setmesshandler(ref void addr)=\r\nwndproc_callbackfn:=addr\r\nend\r\n\r\nglobal function os_getchx:int=\r\n!Q! function os_getchx_c:int\r\n!return a 32-bit value containing:\r\n! 15..B0:\tchar code\r\n! 23..16\tvirtual keycode\r\n! 31..24\tshift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)\r\nconst rightaltmask\t= 1\r\nconst leftaltmask\t= 2\r\nconst leftctrlmask\t= 8\r\nconst rightctrlmask\t= 4\r\nconst shiftmask\t\t= 16\r\nconst capsmask\t\t= 128\r\nconst scrollmask\t= 64\r\nint count\r\nint charcode,keyshift,keycode\r\nint altdown,ctrldown,shiftdown,capslock\r\n\r\n!os_init() unless init_flag\r\nunless init_flag then os_init() end\r\n\r\nif keypending then\r\n\tlastkey:=pendkey\r\n\tkeypending:=0\r\nelse\r\n\tif lastkey.repeatcount=0 then\r\n\t\trepeat\r\n\t\t\tcount:=0\r\n\t\t\tReadConsoleInputA(hconsolein,&lastkey,1,&count)\r\n\t\tuntil (lastkey.eventtype=1 and lastkey.keydown=1)\r\n\tfi\r\nfi\r\n\r\n!set shift flags\r\n\r\naltdown\t\t:= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)\r\nctrldown\t:= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)\r\nshiftdown\t:= ((lastkey.controlkeystate iand shiftmask)|1|0)\r\ncapslock\t:= ((lastkey.controlkeystate iand capsmask)|1|0)\r\n\r\n--lastkey.repeatcount\t\t!count this key out\r\n\r\ncharcode:=lastkey.asciichar\r\nkeycode:=lastkey.virtualkeycode iand 255\r\n\r\nif charcode<0 then\r\n\tif charcode<-128 then\r\n\t\tcharcode:=0\r\n\telse\r\n\t\tcharcode+:=256\r\n\tfi\r\nfi\r\n\r\n!CPL \"CHARCODE2=%d %X\\n\",charcode,charcode\r\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\r\n!wish to set charcode to the appropriate printed char code (currently charcode will be\r\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\r\n!....\r\n\r\nif altdown and ctrldown and charcode=166 then\r\n\taltdown:=ctrldown:=0\r\nelse\r\n\tif altdown or ctrldown then\r\n\t\tcharcode:=0\r\n\t\tif keycode>='A' and keycode<= 'Z' then\r\n\t\t\tcharcode:=keycode-'@'\r\n\t\tfi\r\n\tfi\r\nfi\r\n\r\nkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\r\n\r\nreturn keyshift<<24 ior keycode<<16 ior charcode\r\nend\r\n\r\nglobal function os_getos=>ichar=\r\nif $targetbits=32 then\r\n\treturn \"W32\"\r\nelse\r\n\treturn \"W64\"\r\nfi\r\nend\r\n\r\nglobal function os_gethostsize=>int=\r\nreturn $targetbits\r\nend\r\n\r\nglobal function os_shellexec(ichar opc, file)int=\r\nreturn system(file)\r\nend\r\n\r\nglobal proc  os_sleep(int a)=\r\nSleep(a)\r\nend\r\n\r\nglobal function os_getstdin:filehandle =\r\nreturn fopen(\"con\",\"rb\")\r\nend\r\n\r\nglobal function os_getstdout:filehandle =\r\nreturn fopen(\"con\",\"wb\")\r\nend\r\n\r\nglobal function os_gethostname:ichar=\r\nstatic [300]char name\r\nstatic int n\r\n\r\nGetModuleFileNameA(nil,&.name,name.bytes)\r\nstrcat(&.name,\"/\")\r\nreturn &.name\r\nend\r\n\r\nglobal function os_getmpath:ichar=\r\nreturn F\"C:\\m\\\"\r\nend\r\n\r\nglobal proc os_exitprocess(int x)=\r\nstop x\r\n!ExitProcess(x)\r\nend\r\n\r\nglobal function os_clock:int64=\r\nreturn clock()\r\nend\r\n\r\nglobal function os_getclockspersec:int64=\r\nreturn 1000\r\nend\r\n\r\nglobal function os_iswindows:int=\r\nreturn 1\r\nend\r\n\r\nglobal function os_filelastwritetime(ichar filename)int64=\r\nwt_handle f;\r\nint64 ctime,atime,wtime;\r\n\r\nif filename=nil then\t\t\t\t!used to test whether supported\r\n\treturn 1\r\nfi\r\n\r\nf:=CreateFileA(filename,0x80000000,1,nil, 3,3,nil);\r\nif int64(f)=-1 then\r\n\treturn 0\r\nfi\r\n\r\nGetFileTime(f,&ctime,&atime,&wtime);\r\nCloseHandle(f);\r\n\r\nreturn wtime;\r\nend\r\n\r\nglobal proc os_getsystime(ref rsystemtime tm)=\r\nGetLocalTime(tm)\r\nend\r\n\r\nglobal proc os_messagebox(ichar s,t)=\r\nmessageboxa(0,s,t,0)\r\nend\r\n\r\nglobal function os_hpcounter:int64=\r\nint64 a\r\n\r\nqueryperformancecounter(&a)\r\nreturn a\r\n\r\nend\r\n\r\nglobal function os_hpfrequency:int64=\r\nint64 a\r\n\r\nqueryperformancefrequency(&a)\r\nreturn a\r\n\r\nend\r\n\r\nglobal proc os_peek=\r\nint ticks\r\nstatic int lastticks\r\n[100]byte m\r\n\tticks:=GetTickCount()\r\n\tif ticks-lastticks>=1000 then\r\n\t\tlastticks:=ticks\r\n\t\tPeekMessageA(&m,nil,0,0,0)\r\n\tfi\r\nend\r\n",\
(uint8_t*)"import clib\r\nimport mlib\r\n\r\n!IMPORT OSWINDLLC\r\n\r\nglobal function os_calldllfunction(ref proc fnaddr,\r\n\t\tint retcode, nargs, ref[]i64 args, ref[]byte argcodes)word64 =\r\n\tword64 a\r\n\treal64 x\r\n\tint oddstack, nextra, pushedbytes\r\n\r\n!\treturn os_calldllfunctionc(fnaddr,retcode,nargs,args,argcodes)\r\n\r\n\toddstack:=nextra:=0\r\n\r\n\tassem\r\n\t\ttest astack,8\r\n\t\tjz L100\r\n\t\tmov byte [oddstack],1\r\nL100:\r\n\tend\r\n\r\n\tif oddstack then\r\n\t\tif nargs<5 then\r\n\t\t\tnextra:=5-nargs\r\n\t\telsif nargs.even then\r\n\t\t\tnextra:=1\r\n\t\tfi\r\n\r\n\telse\r\n\t\tif nargs<4 then\r\n\t\t\tnextra:=4-nargs\r\n\t\telsif nargs.odd then\r\n\t\t\tnextra:=1\r\n\t\tfi\r\n\tfi\r\n\r\n\tpushedbytes:=(nextra+nargs)*8\r\n\r\n!RETURN 0\r\n\r\n!CPL \"D4\"\r\n\tto nextra do\r\n\t\tassem\r\n\t\t\tpush 0\r\n\t\tend\r\n\tod\r\n!CPL \"D5\"\r\n\r\n\tfor i:=nargs downto 1 do\r\n\t\ta:=args^[i]\t\t\t\t\t!get generic 64-bit value to push\r\n\t\tassem\r\n\t\t\tpush word64 [a]\r\n\t\tend\r\n\tod\r\n\r\n!CPL =NEXTRA+NARGS,=pushedbytes,=oddstack\r\n\r\n!load first 4 args to registers; this first version will blindly load 4 args\r\n!(even if there are less) to both integer and xmm registers. Should be int/pointer\r\n!types to integer regs; float types to xmm; and variadic to both\r\n\tassem\r\n\t\tmov D10,[Dstack]\r\n\t\tmovq XMM0,[Dstack]\r\n\t\tmov D11,[Dstack+8]\r\n\t\tmovq XMM1,[Dstack+8]\r\n\t\tmov D12,[Dstack+16]\r\n\t\tmovq XMM2,[Dstack+16]\r\n\t\tmov D13,[Dstack+24]\r\n\t\tmovq XMM3,[Dstack+24]\r\n\tend\r\n\r\n\tif retcode='I' then\r\n\t\ta:=((ref function:int64(fnaddr))^())\r\n\t\tasm add Dstack,[pushedbytes]\r\n\t\treturn a\r\n\telse\r\n\t\tx:=((ref function:real64(fnaddr))^())\r\n\t\tasm add Dstack,[pushedbytes]\r\n\t\treturn word64@(x)\r\n\tfi\r\nend\t\r\n\r\nglobal function os_pushargs(ref[]word64 args, int nargs, nextra,\r\n\t\t\t\t\tref proc fnaddr, int isfloat)word64=\r\n!\ta:=os_pushargs(&wordargs, na, nextra, fnaddr, retttype=tp_r64)\r\n!implements central part of 'callapplproc' which needs to be in asm\r\n\tword64 a\r\n\treal64 x\r\n\r\n!CPL \"PUSH ARGS\",NARGS, NEXTRA\r\n\r\n\tto nextra do\r\n\t\tasm\tpush 0\r\n\tend\r\n\r\n!CPL \"PUSH ARGS2\"\r\n\tfor i to nargs do\r\n\t\ta:=args[i]\r\n\t\tasm push word64 [a]\r\n\tod\r\n!CPL \"PUSH ARGS3\"\r\n\r\n\tif isfloat then\r\n\t\tx:=((ref function:real64(fnaddr))^())\r\n\t\ta:=int64@(x)\r\n\telse\r\n\t\ta:=((ref function:int64(fnaddr))^())\r\n\tfi\r\n\r\n\treturn a\r\nend\r\n"};
static int64_t mm_genwx64_nsearchlibs;
static uint8_t *  mm_genwx64_searchlibs[100];
int64_t mm_libpcl_retindex;
int64_t mm_libpcl_initstaticsindex;
uint8_t *  mm_libpcl_pclnames[230] = {
    (uint8_t*)"k_comment",
    (uint8_t*)"k_blank",
    (uint8_t*)"k_label",
    (uint8_t*)"k_labelname",
    (uint8_t*)"k_procentry",
    (uint8_t*)"k_procexit",
    (uint8_t*)"k_stackall",
    (uint8_t*)"k_startmult",
    (uint8_t*)"k_resetmult",
    (uint8_t*)"k_endmult",
    (uint8_t*)"k_istatic",
    (uint8_t*)"k_zstatic",
    (uint8_t*)"k_equiv",
    (uint8_t*)"k_pushmem",
    (uint8_t*)"k_dpushmem",
    (uint8_t*)"k_pushaddr",
    (uint8_t*)"k_pushptr",
    (uint8_t*)"k_pushretslot",
    (uint8_t*)"k_pushffretval",
    (uint8_t*)"k_pushretval",
    (uint8_t*)"k_stackargs",
    (uint8_t*)"k_pushint",
    (uint8_t*)"k_pushreal",
    (uint8_t*)"k_pushint128",
    (uint8_t*)"k_pushstr",
    (uint8_t*)"k_dpushint",
    (uint8_t*)"k_dpushreal",
    (uint8_t*)"k_makeint",
    (uint8_t*)"k_makereal",
    (uint8_t*)"k_makestr",
    (uint8_t*)"k_makedec",
    (uint8_t*)"k_popmem",
    (uint8_t*)"k_popmemz",
    (uint8_t*)"k_popptr",
    (uint8_t*)"k_storemem",
    (uint8_t*)"k_storeptr",
    (uint8_t*)"k_unstack",
    (uint8_t*)"k_popretval",
    (uint8_t*)"k_moveretval",
    (uint8_t*)"k_copyblock",
    (uint8_t*)"k_initmemz",
    (uint8_t*)"k_freemem",
    (uint8_t*)"k_dupl",
    (uint8_t*)"k_free",
    (uint8_t*)"k_add",
    (uint8_t*)"k_sub",
    (uint8_t*)"k_mul",
    (uint8_t*)"k_div",
    (uint8_t*)"k_idiv",
    (uint8_t*)"k_irem",
    (uint8_t*)"k_muli",
    (uint8_t*)"k_neg",
    (uint8_t*)"k_abs",
    (uint8_t*)"k_inot",
    (uint8_t*)"k_notl",
    (uint8_t*)"k_istruel",
    (uint8_t*)"k_call",
    (uint8_t*)"k_return",
    (uint8_t*)"k_callptr",
    (uint8_t*)"k_callff",
    (uint8_t*)"k_callptrff",
    (uint8_t*)"k_syscall",
    (uint8_t*)"k_jump",
    (uint8_t*)"k_jumpcc",
    (uint8_t*)"k_jumpccimm",
    (uint8_t*)"k_jumptrue",
    (uint8_t*)"k_jumpfalse",
    (uint8_t*)"k_jumpinyz",
    (uint8_t*)"k_jumpnotinyz",
    (uint8_t*)"k_casejumpeq",
    (uint8_t*)"k_casejumpne",
    (uint8_t*)"k_setjumpeq",
    (uint8_t*)"k_setjumpeqx",
    (uint8_t*)"k_setjumpne",
    (uint8_t*)"k_switch",
    (uint8_t*)"k_switchlab",
    (uint8_t*)"k_info",
    (uint8_t*)"k_endswitch",
    (uint8_t*)"k_setcc",
    (uint8_t*)"k_compare",
    (uint8_t*)"k_isequal",
    (uint8_t*)"k_iand",
    (uint8_t*)"k_iandc",
    (uint8_t*)"k_ior",
    (uint8_t*)"k_ixor",
    (uint8_t*)"k_shl",
    (uint8_t*)"k_shr",
    (uint8_t*)"k_shlc",
    (uint8_t*)"k_shrc",
    (uint8_t*)"k_in",
    (uint8_t*)"k_min",
    (uint8_t*)"k_max",
    (uint8_t*)"k_subref",
    (uint8_t*)"k_addoffset",
    (uint8_t*)"k_suboffset",
    (uint8_t*)"k_concat",
    (uint8_t*)"k_append",
    (uint8_t*)"k_andl",
    (uint8_t*)"k_orl",
    (uint8_t*)"k_index",
    (uint8_t*)"k_indexc",
    (uint8_t*)"k_indexmem",
    (uint8_t*)"k_indexmemc",
    (uint8_t*)"k_popindex",
    (uint8_t*)"k_popindexmem",
    (uint8_t*)"k_popindexmemc",
    (uint8_t*)"k_storeindex",
    (uint8_t*)"k_dotindex",
    (uint8_t*)"k_anddotindex",
    (uint8_t*)"k_dotslice",
    (uint8_t*)"k_dot",
    (uint8_t*)"k_popdot",
    (uint8_t*)"k_storedot",
    (uint8_t*)"k_keyindex",
    (uint8_t*)"k_storekeyindex",
    (uint8_t*)"k_popkeyindex",
    (uint8_t*)"k_storeslice",
    (uint8_t*)"k_popslice",
    (uint8_t*)"k_indexref",
    (uint8_t*)"k_indexmemref",
    (uint8_t*)"k_indexmemcref",
    (uint8_t*)"k_keyindexref",
    (uint8_t*)"k_popdotindex",
    (uint8_t*)"k_popdotslice",
    (uint8_t*)"k_dotref",
    (uint8_t*)"k_slice",
    (uint8_t*)"k_lwb",
    (uint8_t*)"k_upb",
    (uint8_t*)"k_len",
    (uint8_t*)"k_bounds",
    (uint8_t*)"k_lenstr",
    (uint8_t*)"k_sqrt",
    (uint8_t*)"k_sqr",
    (uint8_t*)"k_sign",
    (uint8_t*)"k_sin",
    (uint8_t*)"k_cos",
    (uint8_t*)"k_tan",
    (uint8_t*)"k_asin",
    (uint8_t*)"k_acos",
    (uint8_t*)"k_atan",
    (uint8_t*)"k_atan2",
    (uint8_t*)"k_ln",
    (uint8_t*)"k_lg",
    (uint8_t*)"k_log",
    (uint8_t*)"k_exp",
    (uint8_t*)"k_round",
    (uint8_t*)"k_floor",
    (uint8_t*)"k_ceil",
    (uint8_t*)"k_fract",
    (uint8_t*)"k_fmod",
    (uint8_t*)"k_power",
    (uint8_t*)"k_asc",
    (uint8_t*)"k_chr",
    (uint8_t*)"k_addto",
    (uint8_t*)"k_subto",
    (uint8_t*)"k_multo",
    (uint8_t*)"k_divto",
    (uint8_t*)"k_idivto",
    (uint8_t*)"k_iremto",
    (uint8_t*)"k_iandto",
    (uint8_t*)"k_iorto",
    (uint8_t*)"k_ixorto",
    (uint8_t*)"k_shlto",
    (uint8_t*)"k_shrto",
    (uint8_t*)"k_shlcto",
    (uint8_t*)"k_shrcto",
    (uint8_t*)"k_minto",
    (uint8_t*)"k_maxto",
    (uint8_t*)"k_addoffsetto",
    (uint8_t*)"k_suboffsetto",
    (uint8_t*)"k_appendto",
    (uint8_t*)"k_concatto",
    (uint8_t*)"k_andlto",
    (uint8_t*)"k_orlto",
    (uint8_t*)"k_addmemto",
    (uint8_t*)"k_submemto",
    (uint8_t*)"k_iandmemto",
    (uint8_t*)"k_iormemto",
    (uint8_t*)"k_ixormemto",
    (uint8_t*)"k_shlcmemto",
    (uint8_t*)"k_shrcmemto",
    (uint8_t*)"k_negto",
    (uint8_t*)"k_absto",
    (uint8_t*)"k_inotto",
    (uint8_t*)"k_notlto",
    (uint8_t*)"k_incrtomem",
    (uint8_t*)"k_decrtomem",
    (uint8_t*)"k_incrto",
    (uint8_t*)"k_decrto",
    (uint8_t*)"k_preincrtox",
    (uint8_t*)"k_predecrtox",
    (uint8_t*)"k_postincrtox",
    (uint8_t*)"k_postdecrtox",
    (uint8_t*)"k_convert",
    (uint8_t*)"k_iwiden",
    (uint8_t*)"k_uwiden",
    (uint8_t*)"k_ifloat",
    (uint8_t*)"k_ufloat",
    (uint8_t*)"k_ifix",
    (uint8_t*)"k_ufix",
    (uint8_t*)"k_narrow",
    (uint8_t*)"k_softtruncate",
    (uint8_t*)"k_truncate",
    (uint8_t*)"k_fnarrow",
    (uint8_t*)"k_fwiden",
    (uint8_t*)"k_unbox",
    (uint8_t*)"k_box",
    (uint8_t*)"k_typepun",
    (uint8_t*)"k_ichartostring",
    (uint8_t*)"k_swap",
    (uint8_t*)"k_makerange",
    (uint8_t*)"k_makelist",
    (uint8_t*)"k_makeslice",
    (uint8_t*)"k_makeset",
    (uint8_t*)"k_slicelen",
    (uint8_t*)"k_sliceupb",
    (uint8_t*)"k_sliceptr",
    (uint8_t*)"k_assem",
    (uint8_t*)"k_csegment",
    (uint8_t*)"k_isegment",
    (uint8_t*)"k_zsegment",
    (uint8_t*)"k_db",
    (uint8_t*)"k_dw",
    (uint8_t*)"k_dd",
    (uint8_t*)"k_dq",
    (uint8_t*)"k_resb",
    (uint8_t*)"k_resw",
    (uint8_t*)"k_resd",
    (uint8_t*)"k_resq",
    (uint8_t*)"k_dummy"
};
uint8_t *  mm_libpcl_opndnames[16] = {
    (uint8_t*)"no_opnd",
    (uint8_t*)"mem_opnd",
    (uint8_t*)"memaddr_opnd",
    (uint8_t*)"intimm_opnd",
    (uint8_t*)"int128imm_opnd",
    (uint8_t*)"realimm_opnd",
    (uint8_t*)"strimm_opnd",
    (uint8_t*)"proc_opnd",
    (uint8_t*)"dllproc_opnd",
    (uint8_t*)"field_opnd",
    (uint8_t*)"genfield_opnd",
    (uint8_t*)"label_opnd",
    (uint8_t*)"type_opnd",
    (uint8_t*)"operator_opnd",
    (uint8_t*)"syscall_opnd",
    (uint8_t*)"assem_opnd"
};
struct mm_libpcl_pclrec *  mm_libpcl_pccode;
struct mm_libpcl_pclrec *  mm_libpcl_pccodex;
struct mm_libpcl_pclrec *  mm_libpcl_allpclcode;
static struct mm_libpcl_pclopndrec mm_libpcl_pclbuffers[4];
static int64_t mm_libpcl_nextpclindex = (int64_t)1;
int64_t mm_libpcl_framebytes;
int64_t mm_libpcl_parambytes;
int64_t mm_libpcl_frameoffset;
int64_t mm_libpcl_isthreadedproc;
int64_t mm_libpcl_iscallbackproc;
static struct mm_libpcl_pclopndrec mm_libpcl_Dzero_opnd;
struct mm_libpcl_pclopndrec *  mm_libpcl_zero_opnd;
static int64_t mm_blockpcl_loopstack[50][4];
static int64_t mm_blockpcl_loopindex;
static struct mm_decls_unitrec *  mm_blockpcl_casestmt[20];
static int64_t mm_blockpcl_caseelse[20];
static int64_t mm_blockpcl_casedepth;
static int64_t (*mm_blockpcl_sw_labeltable)[];
static int64_t (*mm_blockpcl_sw_valuetable)[];
static int64_t mm_blockpcl_sw_lower;
static int64_t mm_blockpcl_sw_ncases;
static byte mm_blockpcl_sw_defaultseen;
static int64_t mm_blockpcl_sw_defaultlabel;
static int64_t mm_blockpcl_sw_breaklabel;
static int64_t mm_blockpcl_maxreg = (int64_t)0;
static void (*mm_genmcl_handlertable[230][34])(struct mm_libpcl_pclrec *);
static struct mm_libpcl_pclrec *  mm_genmcl_currpclrec;
static struct mm_libpcl_pclopndrec *  mm_genmcl_aa;
static struct mm_libpcl_pclopndrec *  mm_genmcl_bb;
static int64_t mm_genmcl_swmin;
static int64_t mm_genmcl_swmax;
int64_t mm_libmcl_ptrsize;
int64_t mm_libmcl_fshowmsource = (int64_t)0;
int64_t mm_libmcl_lababs32;
int64_t mm_libmcl_lababs64;
int64_t mm_libmcl_labneg32;
int64_t mm_libmcl_labneg64;
int64_t mm_libmcl_labzero;
int64_t mm_libmcl_kk0used = (int64_t)0;
int64_t mm_libmcl_retindex;
int64_t mm_libmcl_stackaligned;
uint8_t *  mm_libmcl_xregnames[17] = {
    (uint8_t*)"xnone",
    (uint8_t*)"xr0",
    (uint8_t*)"xr1",
    (uint8_t*)"xr2",
    (uint8_t*)"xr3",
    (uint8_t*)"xr4",
    (uint8_t*)"xr5",
    (uint8_t*)"xr6",
    (uint8_t*)"xr7",
    (uint8_t*)"xr8",
    (uint8_t*)"xr9",
    (uint8_t*)"xr10",
    (uint8_t*)"xr11",
    (uint8_t*)"xr12",
    (uint8_t*)"xr13",
    (uint8_t*)"xr14",
    (uint8_t*)"xr15"
};
struct mm_mcldecls_mclrec *  mm_libmcl_mccode;
struct mm_mcldecls_mclrec *  mm_libmcl_mccodex;
int64_t mm_libmcl_currsegment = (int64_t)0;
int64_t mm_libmcl_currzdataalign = (int64_t)0;
int64_t mm_libmcl_curridataalign = (int64_t)0;
int64_t mm_libmcl_frameoffset;
int64_t mm_libmcl_isthreadedproc;
int64_t mm_libmcl_iscallbackproc;
int64_t mm_libmcl_structretoffset;
struct mm_mcldecls_mclrec *  mm_libmcl_stacksetinstr;
int64_t mm_libmcl_currblocksize;
struct mm_mcldecls_mclrec *  mm_libmcl_allmclcode;
uint8_t *  mm_libmcl_allasmstr;
int64_t mm_libmcl_allasmstrlen;
struct mm_mcldecls_opndrec *  mm_libmcl_dstackopnd;
struct mm_mcldecls_opndrec *  mm_libmcl_dframeopnd;
struct mm_mcldecls_opndrec *  mm_libmcl_zero_opnd = 0;
struct mm_decls_unitrec *  mm_libmcl_zero_unit;
struct mm_mcldecls_opndrec *  mm_libmcl_regtable[16][16];
uint8_t * (*mm_libmcl_stringtable)[];
int32_t (*mm_libmcl_stringlentable)[];
int32_t (*mm_libmcl_stringlabtable)[];
double (*mm_libmcl_realtable)[];
int32_t (*mm_libmcl_reallabtable)[];
static int64_t mm_libmcl_stringtablesize;
static int64_t mm_libmcl_realtablesize;
int64_t mm_libmcl_nstrings = (int64_t)0;
int64_t mm_libmcl_nreals = (int64_t)0;
byte mm_libmcl_opndstack[100];
byte mm_libmcl_opndreg2[100];
byte mm_libmcl_opndsize[100];
byte mm_libmcl_opndkind[100];
int64_t mm_libmcl_noperands;
byte mm_libmcl_regset[16];
byte mm_libmcl_xregset[16];
uint8_t *  var_tables_vartypenames[19] = {
    (uint8_t*)"vt_void",
    (uint8_t*)"vt_int",
    (uint8_t*)"vt_word",
    (uint8_t*)"vt_real",
    (uint8_t*)"vt_range",
    (uint8_t*)"vt_decimal",
    (uint8_t*)"vt_string",
    (uint8_t*)"vt_wstring",
    (uint8_t*)"vt_list",
    (uint8_t*)"vt_record",
    (uint8_t*)"vt_dict",
    (uint8_t*)"vt_recordlink",
    (uint8_t*)"vt_set",
    (uint8_t*)"vt_array",
    (uint8_t*)"vt_bits",
    (uint8_t*)"vt_struct",
    (uint8_t*)"vt_type",
    (uint8_t*)"vt_refproc",
    (uint8_t*)"vt_refdllproc"
};
uint8_t *  var_tables_packtypenames[17] = {
    (uint8_t*)"pt_void",
    (uint8_t*)"pt_u1",
    (uint8_t*)"pt_u2",
    (uint8_t*)"pt_u4",
    (uint8_t*)"pt_u8",
    (uint8_t*)"pt_u16",
    (uint8_t*)"pt_u32",
    (uint8_t*)"pt_u64",
    (uint8_t*)"pt_u128",
    (uint8_t*)"pt_i8",
    (uint8_t*)"pt_i16",
    (uint8_t*)"pt_i32",
    (uint8_t*)"pt_i64",
    (uint8_t*)"pt_i128",
    (uint8_t*)"pt_r32",
    (uint8_t*)"pt_r64",
    (uint8_t*)"pt_ref"
};
byte var_tables_packtypewidths[17] = {
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)4u,
    (uint8_t)8u,
    (uint8_t)16u,
    (uint8_t)32u,
    (uint8_t)64u,
    (uint8_t)128u,
    (uint8_t)8u,
    (uint8_t)16u,
    (uint8_t)32u,
    (uint8_t)64u,
    (uint8_t)128u,
    (uint8_t)32u,
    (uint8_t)64u,
    (uint8_t)64u
};
byte var_tables_packtypesizes[17] = {
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)4u,
    (uint8_t)8u,
    (uint8_t)16u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)4u,
    (uint8_t)8u,
    (uint8_t)16u,
    (uint8_t)4u,
    (uint8_t)8u,
    (uint8_t)8u
};
uint8_t *  var_tables_binopnames[23] = {
    (uint8_t*)"v_add",
    (uint8_t*)"v_sub",
    (uint8_t*)"v_mul",
    (uint8_t*)"v_div",
    (uint8_t*)"v_idiv",
    (uint8_t*)"v_irem",
    (uint8_t*)"v_power",
    (uint8_t*)"v_equal",
    (uint8_t*)"v_compare",
    (uint8_t*)"v_same",
    (uint8_t*)"v_iand",
    (uint8_t*)"v_ior",
    (uint8_t*)"v_ixor",
    (uint8_t*)"v_shl",
    (uint8_t*)"v_shr",
    (uint8_t*)"v_andl",
    (uint8_t*)"v_orl",
    (uint8_t*)"v_append",
    (uint8_t*)"v_concat",
    (uint8_t*)"v_min",
    (uint8_t*)"v_max",
    (uint8_t*)"v_atan2",
    (uint8_t*)"v_in"
};
byte var_tables_intbinop[23] = {
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u
};
uint8_t *  var_tables_monopnames[29] = {
    (uint8_t*)"v_neg",
    (uint8_t*)"v_abs",
    (uint8_t*)"v_inot",
    (uint8_t*)"v_notl",
    (uint8_t*)"v_istruel",
    (uint8_t*)"v_sqrt",
    (uint8_t*)"v_sin",
    (uint8_t*)"v_cos",
    (uint8_t*)"v_tan",
    (uint8_t*)"v_asin",
    (uint8_t*)"v_acos",
    (uint8_t*)"v_atan",
    (uint8_t*)"v_exp",
    (uint8_t*)"v_ln",
    (uint8_t*)"v_log",
    (uint8_t*)"v_round",
    (uint8_t*)"v_floor",
    (uint8_t*)"v_ceil",
    (uint8_t*)"v_fract",
    (uint8_t*)"v_asc",
    (uint8_t*)"v_chr",
    (uint8_t*)"v_lwb",
    (uint8_t*)"v_upb",
    (uint8_t*)"v_len",
    (uint8_t*)"v_bounds",
    (uint8_t*)"v_share",
    (uint8_t*)"v_unshare",
    (uint8_t*)"v_free",
    (uint8_t*)"v_dupl"
};
byte var_tables_intmonop[29] = {
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u
};
uint8_t *  var_tables_ibinopnames[17] = {
    (uint8_t*)"v_addto",
    (uint8_t*)"v_subto",
    (uint8_t*)"v_multo",
    (uint8_t*)"v_divto",
    (uint8_t*)"v_idivto",
    (uint8_t*)"v_iremto",
    (uint8_t*)"v_iandto",
    (uint8_t*)"v_iorto",
    (uint8_t*)"v_ixorto",
    (uint8_t*)"v_shlto",
    (uint8_t*)"v_shrto",
    (uint8_t*)"v_andto",
    (uint8_t*)"v_orto",
    (uint8_t*)"v_appendto",
    (uint8_t*)"v_concatto",
    (uint8_t*)"v_minto",
    (uint8_t*)"v_maxto"
};
uint8_t *  var_tables_imonopnames[6] = {(uint8_t*)"v_negto",(uint8_t*)"v_absto",(uint8_t*)"v_inotto",(uint8_t*)"v_notlto",(uint8_t*)"v_incrto",(uint8_t*)"v_decrto"};
uint8_t *  var_tables_miscopnames[19] = {
    (uint8_t*)"v_new",
    (uint8_t*)"v_make",
    (uint8_t*)"v_print",
    (uint8_t*)"v_tostr",
    (uint8_t*)"v_getdot",
    (uint8_t*)"v_putdot",
    (uint8_t*)"v_getindex",
    (uint8_t*)"v_putindex",
    (uint8_t*)"v_getdotindex",
    (uint8_t*)"v_putdotindex",
    (uint8_t*)"v_getslice",
    (uint8_t*)"v_putslice",
    (uint8_t*)"v_getdotslice",
    (uint8_t*)"v_putdotslice",
    (uint8_t*)"v_getkeyindex",
    (uint8_t*)"v_putkeyindex",
    (uint8_t*)"v_insert",
    (uint8_t*)"v_delete",
    (uint8_t*)"v_resize"
};
static int64_t ma_genss_deb;
static uint64_t *  ma_genss_ppp;
static int64_t ma_genss_rex;
static int64_t ma_genss_sizeoverride;
static int64_t ma_genss_addroverride;
static int64_t ma_genss_f2override;
static int64_t ma_genss_f3override;
static struct mm_mcldecls_opndrec *  ma_genss_extraparam;
static int64_t ma_genss_currseg = (int64_t)0;
static struct ma_decls_dbuffer *  ma_genss_currdata;
static struct ma_decls_relocrec *  ma_genss_currrelocs;
static int64_t ma_genss_nrelocs;
static int64_t ma_genss_instrno = (int64_t)2;
static struct mm_mcldecls_mclrec *  ma_genss_currmcl;
uint8_t *  ma_decls_searchlibs[30];
int64_t ma_decls_nmodules;
int64_t ma_decls_nsearchlibs;
int64_t ma_decls_linecount = (int64_t)0;
int64_t ma_decls_nundefined = (int64_t)0;
int64_t ma_decls_ss_zdatalen;
struct ma_decls_dbuffer *  ma_decls_ss_zdata;
struct ma_decls_dbuffer *  ma_decls_ss_idata;
struct ma_decls_dbuffer *  ma_decls_ss_code;
struct ma_decls_relocrec *  ma_decls_ss_idatarelocs;
struct ma_decls_relocrec *  ma_decls_ss_coderelocs;
int64_t ma_decls_ss_nidatarelocs;
int64_t ma_decls_ss_ncoderelocs;
struct mm_decls_strec * (*ma_decls_ss_symboltable)[];
int64_t ma_decls_ss_nsymbols;
int64_t ma_decls_ss_symboltablesize;
struct mm_decls_strec * (*ma_decls_labeldeftable)[];
int64_t ma_decls_currmoduleno;
int64_t ma_decls_nmclasm;
int64_t ma_decls_nmclopndsasm;
int64_t ma_lib_currsegment = (int64_t)0;
static struct mlib_strbuffer ma_lib_destv;
struct mlib_strbuffer *  ma_lib_dest = &ma_lib_destv;
uint8_t *  ma_objdecls_relocnames[7] = {(uint8_t*)"abs_rel",(uint8_t*)"addr64_rel",(uint8_t*)"addr32_rel",(uint8_t*)"addr32nb_rel",(uint8_t*)"rel32_rel",(uint8_t*)"rel321_rel",(uint8_t*)"rel8_rel"};
uint8_t *  ma_objdecls_coffscopenames[3] = {(uint8_t*)"cofflocal_scope",(uint8_t*)"export_scope",(uint8_t*)"import_scope"};
static struct mm_decls_fwdrec ma_writeobj_dummy1;
static int64_t ma_writeobj_symtaboffset;
static byte *  ma_writeobj_datastart;
static byte *  ma_writeobj_dataptr;
static struct ma_objdecls_imagesymbol ma_writeobj_symboltable[10001];
static int64_t ma_writeobj_nsymbols;
static int64_t ma_writeobj_stoffset = (int64_t)0;
static uint8_t *  ma_writeobj_stringtable[5000];
static int64_t ma_writeobj_stringlengths[5000];
static int64_t ma_writeobj_nextstringoffset = (int64_t)0;
static int64_t ma_writeobj_nstrings = (int64_t)0;
static int64_t ma_writeexe_libinsttable[30];
static uint8_t *  ma_writeexe_libinstnames[30];
static int64_t ma_writeexe_libnotable[30];
static int64_t ma_writeexe_imagesize;
static int64_t ma_writeexe_filesize;
static int64_t (*ma_writeexe_thunktable)[];
static int64_t ma_writeexe_fileiatoffset;
static int64_t ma_writeexe_fileiatsize;
static struct mm_decls_strec *  ma_writeexe_stentrypoint;
static struct mm_decls_strec *  ma_writeexe_stentrypoint2;
static struct mm_decls_strec *  ma_writeexe_stentrypoint3;
static struct ma_writeexe_sectionrec ma_writeexe_sectiontable[10];
static int64_t ma_writeexe_nsections;
static byte *  ma_writeexe_importdir;
static struct ma_writeexe_importrec ma_writeexe_importtable[3000];
static int64_t ma_writeexe_nimports;
static struct ma_writeexe_dllrec ma_writeexe_dlltable[50];
static int64_t ma_writeexe_ndlls;
static byte *  ma_writeexe_datastart;
static byte *  ma_writeexe_dataptr;
static uint8_t *  ma_writeexe_userentrypoint;
static int64_t ma_disasm_abc;
static double ma_disasm_xyz;
static int64_t ma_disasm_res2;
static int64_t ma_disasm_lx;
static int64_t ma_disasm_nmodules;
static int64_t ma_disasm_xfchsmask_pd;
static uint8_t *  ma_disasm_opnames[8] = {(uint8_t*)"add",(uint8_t*)"or",(uint8_t*)"adc",(uint8_t*)"sbb",(uint8_t*)"and",(uint8_t*)"sub",(uint8_t*)"xor",(uint8_t*)"cmp"};
static uint8_t *  ma_disasm_condnames[16] = {
    (uint8_t*)"o",
    (uint8_t*)"no",
    (uint8_t*)"b",
    (uint8_t*)"ae",
    (uint8_t*)"z",
    (uint8_t*)"nz",
    (uint8_t*)"be",
    (uint8_t*)"a",
    (uint8_t*)"s",
    (uint8_t*)"ns",
    (uint8_t*)"p",
    (uint8_t*)"np",
    (uint8_t*)"l",
    (uint8_t*)"ge",
    (uint8_t*)"le",
    (uint8_t*)"g"
};
static uint8_t *  ma_disasm_addrmodenames[3] = {(uint8_t*)"amreg",(uint8_t*)"ammem",(uint8_t*)"amrel"};
static int64_t ma_disasm_rex;
static int64_t ma_disasm_addrmode;
static int64_t ma_disasm_rmreg;
static int64_t ma_disasm_rmopc;
static int64_t ma_disasm_basereg;
static int64_t ma_disasm_indexreg;
static int64_t ma_disasm_scale;
static int64_t ma_disasm_opsize;
static int64_t ma_disasm_offset;
static int64_t ma_disasm_offsetsize;
static int64_t ma_disasm_sizeoverride;
static int64_t ma_disasm_addroverride;
static int64_t ma_disasm_f2override;
static int64_t ma_disasm_f3override;
static uint8_t ma_disasm_deststr[256];
static uint8_t *  ma_disasm_destptr;
static byte *  ma_disasm_codeptr;
static int64_t mm_parse_intabledata = (int64_t)0;
static int64_t mm_parse_inreadprint = (int64_t)0;
static int64_t mm_parse_inparamlist = (int64_t)0;
static int64_t mm_parse_inrecordbody = (int64_t)0;
static int64_t mm_parse_inimportmodule = (int64_t)0;
static int64_t mm_parse_labelseen = (int64_t)0;
static uint8_t *  mm_parse_tabledataname = 0;
static struct mm_decls_strec *  mm_parse_procstack[10];
static int64_t mm_parse_nprocstack = (int64_t)0;
static struct mm_decls_uflagsrec mm_parse_unionstring;
static struct mm_decls_uflagsrec mm_parse_unionpend;
static struct mm_decls_strec *  mm_parse_unionlastvar = 0;
static struct mm_decls_strec *  mm_parse_dretvar;
static int64_t mm_parse_try_level = (int64_t)0;
static int64_t mm_parse_varattribs = (int64_t)0;
static struct mm_decls_unitrec *  mm_parse_dollarstack[10];
static int64_t mm_parse_ndollar = (int64_t)0;
static int64_t mm_parse_inmultexpr = (int64_t)0;
static int64_t mm_parse_insiderecord = (int64_t)0;
static int64_t mm_parse_insidedllimport = (int64_t)0;
static struct mm_decls_strec *  mm_name_currstproc;
static int64_t mm_name_allowmodname = (int64_t)0;
static int64_t mm_name_noexpand;
static int64_t mm_name_noassem;
static int64_t mm_name_macrolevels;
static struct mm_decls_strec *  mm_name_macroparams[50];
static struct mm_decls_strec *  mm_name_macroparamsgen[50];
static struct mm_decls_unitrec *  mm_name_macroargs[50];
static int64_t mm_name_nmacroparams;
static int64_t mm_name_nmacroargs;
static uint8_t *  mm_type_lvnames[5] = {(uint8_t*)"no_lv",(uint8_t*)"need_lv",(uint8_t*)"addrof_lv",(uint8_t*)"index_lv",(uint8_t*)"indexlv_lv"};
static int64_t mm_type_countedfields;
static int64_t mm_type_inassem;

/* PROCDEFS */
// START
void start(void) {
    mm_start_addmodulemapping((uint8_t*)"msys",(uint8_t*)"msysnew",(uint8_t *)(0),(uint8_t *)(0));
    mm_start_addmodulemapping((uint8_t*)"clib",(uint8_t*)"clibnew",(uint8_t *)(0),(uint8_t *)(0));
    mm_start_addmodulemapping((uint8_t*)"oslib",(uint8_t*)"oswindows",(uint8_t *)(0),(uint8_t *)(0));
    mm_start_addmodulemapping((uint8_t*)"osdll",(uint8_t*)"oswindll",(uint8_t *)(0),(uint8_t *)(0));
    mm_start_start_common((int64_t)1);
}

int main(int nargs, char** args) {
int i;
	msysnewc_nsysparams=nargs;
	if (msysnewc_nsysparams>nargs) {puts("Too many params"); exit(1);}
	for (i=1; i<=nargs; ++i) msysnewc_sysparams[i-1]=(byte*)args[i-1];


	start();
	return 0;
}

void mm_start_start_common(int64_t itarget) {
    int64_t t;
    int64_t i;
    t = (mm_start_startclock = oslinux_os_clock());
    mm_decls_target = itarget;
    mm_decls_ctarget = (int64_t)(mm_decls_tg_ctarget[(mm_decls_target)-1]);
    mm_decls_islinux = (int64_t)(mm_decls_tg_islinux[(mm_decls_target)-1]);
    mm_decls_targetbits = (int64_t)(mm_decls_tg_targetbits[(mm_decls_target)-1]);
    mm_decls_targetsize = (mm_decls_targetbits / (int64_t)8);
    mm_start_addoptionvar((uint8_t*)"target",mm_decls_targetnames[(mm_decls_target)-1]);
    mm_start_addoptionvar((uint8_t*)"os",mm_decls_targetosnames[(mm_decls_target)-1]);
    mm_start_addoptionvar((uint8_t*)"targetlang",mm_decls_targetlangnames[(mm_decls_target)-1]);
    mm_start_addoptionvar((uint8_t*)"ctarget",(!!(mm_decls_ctarget)?(uint8_t*)"1":(uint8_t*)"0"));
    mm_start_initdata();
    mm_start_getinputoptions();
    if (!!((uint64_t)(mm_decls_fdebugcompiler))) {
        mm_start_debugcompiler();
        exit(0);
    };
    if ((mm_decls_fverbose >= (int64_t)1)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Compiling",NULL);
        msysnewc_m_print_str(mm_decls_inputfiles[((int64_t)1)],NULL);
        msysnewc_m_print_str((uint8_t*)"to",NULL);
        msysnewc_m_print_str(mm_decls_outfile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    mm_start_initsearchdirs();
    mm_start_starttimer();
    mm_start_do_loadmodules();
    mm_start_stoptimer((uint8_t*)"LOAD");
    mm_start_do_parse();
    mm_start_stoptimer((uint8_t*)"PARSE");
    mm_start_do_writema();
    mm_start_do_name();
    mm_start_stoptimer((uint8_t*)"NAME");
    mm_start_do_type();
    mm_start_stoptimer((uint8_t*)"TYPE");
    mm_genwx64_do_codegen();
    mm_start_endclock = oslinux_os_clock();
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Time",NULL);
    msysnewc_m_print_i64((mm_start_endclock - mm_start_startclock),NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    if ((mm_decls_cc_mode == (int64_t)3)) {
        mm_start_do_runprog();
    };
    if ((mm_decls_fverbose >= (int64_t)2)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Finished.",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if (!!(mm_decls_fshowrecs)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Record sizes",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        L1 :;
        for (i=(int64_t)37;i<=mm_decls_ntypes;i+=(int64_t)1) {
L2 :;
            if (((int64_t)(mm_decls_ttbasetype[(i)]) == (int64_t)25)) {
                if (((mm_decls_ttsize[(i)] == (int64_t)1) || (mm_decls_ttsize[(i)] == (int64_t)2) || (mm_decls_ttsize[(i)] == (int64_t)4) || (mm_decls_ttsize[(i)] == (int64_t)8))) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str((uint8_t*)"S",NULL);
                    msysnewc_m_print_end();
                    ;
                } else {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str((uint8_t*)" ",NULL);
                    msysnewc_m_print_end();
                    ;
                };
                msysnewc_m_print_startcon();
                msysnewc_m_print_i64(mm_decls_ttsize[(i)],(uint8_t*)"4");
                msysnewc_m_print_str(mm_lib_typename(i),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
L3 :;
        }L4 :;
        ;
    };
    exit((int64_t)0);
}

static void mm_start_debugcompiler(void) {
    uint8_t str[200];
    int64_t t;
    void *  logdev;
    mm_decls_fshowmcl1 = (mm_decls_passlevel >= (int64_t)5);
    mm_decls_fshowpcl1 = (mm_decls_passlevel >= (int64_t)4);
    mm_decls_fshowast3 = (mm_decls_passlevel >= (int64_t)3);
    mm_decls_cc_mode = (int64_t)0;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"*************DEBUG:Compiling",NULL);
    msysnewc_m_print_str(mm_decls_inputfiles[((int64_t)1)],NULL);
    msysnewc_m_print_str((uint8_t*)"to",NULL);
    msysnewc_m_print_str(mm_decls_outfile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_start_initsearchdirs();
    remove((int8_t *)((uint8_t*)"qx.log"));
    t = (int64_t)(clock());
    mm_start_do_loadmodules();
    if ((mm_decls_passlevel >= (int64_t)1)) {
        mm_start_do_parse();
        if (!!(mm_decls_fshowast1)) {
            mm_start_showast((uint8_t*)"AST1");
        };
        mm_start_do_writema();
    };
    t = (int64_t)(clock());
    if ((mm_decls_passlevel >= (int64_t)2)) {
        mm_start_do_name();
        if (!!(mm_decls_fshowast2)) {
            mm_start_showast((uint8_t*)"AST2");
        };
    };
    if ((mm_decls_passlevel >= (int64_t)3)) {
        mm_start_do_type();
        if (!!(mm_decls_fshowast3)) {
            mm_start_showast((uint8_t*)"AST3");
        };
    };
    if ((mm_decls_passlevel >= (int64_t)4)) {
        mm_genwx64_do_codegen_debug();
    };
    mm_start_endclock = oslinux_os_clock();
    if (!!(mm_decls_fshowtiming)) {
        mm_start_showtiming();
    };
    if ((mm_decls_fverbose >= (int64_t)2)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Finished.",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if (((((((((((!!(mm_decls_fshowpcl1) || !!(mm_decls_fshowpcl2)) || !!(mm_decls_fshowast1)) || !!(mm_decls_fshowast2)) || !!(mm_decls_fshowast3)) || !!(mm_decls_fshowst)) || !!(mm_decls_fshowstflat)) || !!(mm_decls_fshowtypes)) || !!(mm_decls_fshowmcl1)) || !!(mm_decls_fshowss)) || !!(mm_decls_fshowasm))) {
        logdev = fopen((int8_t *)((uint8_t*)"qx.log"),(int8_t *)((uint8_t*)"w"));
        if (!!(mm_decls_fshowasm)) {
            mm_start_addtolog(mm_decls_outfilesource,logdev);
        };
        if (!!(mm_decls_fshowss)) {
            mm_start_addtolog((uint8_t*)"SS",logdev);
        };
        if (!!(mm_decls_fshowmcl1)) {
            mm_start_addtolog(mm_decls_outfilesource,logdev);
        };
        if (!!(mm_decls_fshowpcl1)) {
            mm_start_addtolog((uint8_t*)"PCL",logdev);
        };
        if (!!(mm_decls_fshowast3)) {
            mm_start_addtolog((uint8_t*)"AST3",logdev);
        };
        if (!!(mm_decls_fshowast2)) {
            mm_start_addtolog((uint8_t*)"AST2",logdev);
        };
        if (!!(mm_decls_fshowast1)) {
            mm_start_addtolog((uint8_t*)"AST1",logdev);
        };
        if (!!(mm_decls_fshowst)) {
            mm_start_showsttree((uint8_t*)"SYMBOL TABLE",logdev);
        };
        if (!!(mm_decls_fshowstflat)) {
            mm_start_showstflat((uint8_t*)"FLAT SYMBOL TABLE",logdev);
        };
        if (!!(mm_decls_fshowtypes)) {
            mm_diags_printmodelist(logdev);
        };
        fclose(logdev);
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"\\m\\ed.bat -w ",NULL);
        msysnewc_m_print_str((uint8_t*)"qx.log",NULL);
        msysnewc_m_print_end();
        ;
        if (!!(mlib_checkfile((uint8_t*)"mc.m"))) {
            oslinux_os_execwait(str,(int64_t)1,(uint8_t *)(0));
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"Diagnostic outputs written to",NULL);
            msysnewc_m_print_str((uint8_t*)"qx.log",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
    };
    exit((int64_t)0);
}

static void mm_start_do_loadmodules(void) {
    if (!!(mm_decls_fbundled)) {
        mm_support_loadmafile();
    };
    mm_start_loadmainmodule(mm_decls_inputfiles[((int64_t)1)]);
}

static void mm_start_do_parse(void) {
    int64_t i;
    L5 :;
    for (i=(int64_t)2;i<=mm_decls_nmodules;i+=(int64_t)1) {
L6 :;
        mm_parse_parsemodule(i);
L7 :;
    }L8 :;
    ;
    mm_parse_parsemodule((int64_t)1);
    mm_name_fixusertypes();
}

static void mm_start_do_name(void) {
    int64_t i;
    mm_name_rx_typetable();
    L9 :;
    for (i=(int64_t)2;i<=mm_decls_nmodules;i+=(int64_t)1) {
L10 :;
        mm_name_rx_module(i);
L11 :;
    }L12 :;
    ;
    mm_name_rx_module((int64_t)1);
}

static void mm_start_do_type(void) {
    int64_t i;
    mm_type_tx_typetable();
    L13 :;
    for (i=(int64_t)1;i<=mm_decls_nmodules;i+=(int64_t)1) {
L14 :;
        mm_type_tx_module(i);
L15 :;
    }L16 :;
    ;
    mm_type_tx_allprocs();
}

static void mm_start_do_runprog(void) {
    uint8_t str[300];
    int64_t i;
    if (!!(mm_decls_islinux)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"./",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mm_decls_outfilebin,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        strcpy((int8_t *)(str),(int8_t *)(mm_decls_outfilebin));
    };
    L17 :;
    for (i=(int64_t)1;i<=mm_start_nextraparams;i+=(int64_t)1) {
L18 :;
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" "));
        strcat((int8_t *)(str),(int8_t *)(mm_start_extraparams[(i)-1]));
        if (!!(mm_start_extravalues[(i)-1])) {
            strcat((int8_t *)(str),(int8_t *)((uint8_t*)":"));
            strcat((int8_t *)(str),(int8_t *)(mm_start_extravalues[(i)-1]));
        };
L19 :;
    }L20 :;
    ;
    oslinux_os_execwait(str,(int64_t)0,(uint8_t *)(0));
}

static int64_t mm_start_loadmainmodule(uint8_t * filespec) {
    uint8_t modulename[100];
    uint8_t path[300];
    int64_t flag;
    int64_t fileno;
    mlib_pcm_clearmem((void *)(&mm_decls_moduletable[((int64_t)0)]),(int64_t)98);
    mm_decls_sourcefilenames[((int64_t)0)] = (uint8_t*)"<dummy file>";
    mm_decls_sourcefilepaths[((int64_t)0)] = (uint8_t*)"<dummy path>";
    mm_decls_sourcefiletext[((int64_t)0)] = (uint8_t*)"<sourcefile0>";
    mm_decls_sourcefilesizes[((int64_t)0)] = (int64_t)(strlen((int8_t *)(mm_decls_sourcefiletext[((int64_t)0)])));
    mm_decls_moduletable[((int64_t)0)].name = (uint8_t*)"PROGRAM";
    mm_decls_moduletable[((int64_t)0)].fileno = (int64_t)0;
    mm_decls_stprogram = mm_lib_createdupldef((struct mm_decls_strec *)(0),mm_lex_addnamestr((uint8_t*)"$prog"),(int64_t)1);
    mm_decls_moduletable[((int64_t)0)].stmodule = mm_decls_stprogram;
    fileno = mm_support_getmainfile(filespec);
    mm_decls_infotext = (uint8_t *)(0);
    if (!!(mm_decls_ctarget)) {
        mm_decls_infotext = (uint8_t *)(mlib_readfile(mlib_changeext(filespec,(uint8_t*)"txt")));
    };
    strcpy((int8_t *)(modulename),(int8_t *)(mlib_extractbasefile(filespec)));
    strcpy((int8_t *)(path),(int8_t *)(mlib_extractpath(filespec)));
    if (!!((uint64_t)(path[((int64_t)1)-1]))) {
        mm_start_addsearchdir(path);
    };
    mm_start_addmodule(modulename,fileno,&flag);
    mm_support_addspecialtypes();
    return (int64_t)1;
}

static int64_t mm_start_addmodule(uint8_t * modulename,int64_t fileno,int64_t * exportflag) {
    struct mm_decls_modulerec m;
    uint8_t *  importnames[50];
    byte importflags[51];
    int64_t importmoduleno[50];
    int64_t nimports;
    int64_t i;
    int64_t k;
    int64_t flag;
    int64_t j;
    int64_t newmodno;
    struct mm_decls_modulerec *  pmodule;
    mlib_convlcstring(modulename);
    mlib_pcm_clearmem((void *)(&m),(int64_t)98);
    m.name = mlib_pcm_copyheapstring(modulename);
    m.fileno = fileno;
    mm_decls_stmodule = mm_lib_createnewmoduledef(mm_decls_stprogram,mm_lex_addnamestr(m.name));
    m.stmodule = mm_decls_stmodule;
    if ((mm_decls_nmodules >= (int64_t)50)) {
        mm_support_loaderror((uint8_t*)"Too many modules",modulename,(uint8_t*)"");
    };
    pmodule = &mm_decls_moduletable[((newmodno = ++mm_decls_nmodules))];
    (*pmodule) = m;
    (*pmodule).importmap[(newmodno)-1] = (uint64_t)((int64_t)1);
    (*m.stmodule).moduleno = (uint64_t)(newmodno);
    memset((void *)(&importflags),(int64_t)0,(uint64_t)((int64_t)51));
    nimports = mm_start_readimportlist(&m,&importnames,&importflags,(int64_t)50);
    L21 :;
    for (i=(int64_t)1;i<=nimports;i+=(int64_t)1) {
L22 :;
        flag = (int64_t)0;
        if ((mm_decls_fverbose >= (int64_t)3)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"Load import for",NULL);
            msysnewc_m_print_str(modulename,NULL);
            msysnewc_m_print_str((uint8_t*)":",NULL);
            msysnewc_m_print_str(importnames[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        k = mm_start_loadimport(importnames[(i)-1],&flag,modulename);
        if (!!(flag)) {
            importflags[(i)] = (uint64_t)((int64_t)1);
        };
        (*pmodule).importmap[(k)-1] = (uint64_t)((int64_t)1);
        importmoduleno[(i)-1] = k;
L23 :;
    }L24 :;
    ;
    L25 :;
    for (i=(int64_t)1;i<=nimports;i+=(int64_t)1) {
L26 :;
        if (!!((uint64_t)(importflags[(i)]))) {
            k = importmoduleno[(i)-1];
            L29 :;
            for (j=(int64_t)1;j<=mm_decls_nmodules;j+=(int64_t)1) {
L30 :;
                if (!!((uint64_t)(mm_decls_moduletable[(k)].importmap[(j)-1]))) {
                    (*pmodule).importmap[(j)-1] = (uint64_t)((int64_t)1);
                };
L31 :;
            }L32 :;
            ;
        };
L27 :;
    }L28 :;
    ;
    (*exportflag) = (int64_t)(importflags[((int64_t)0)]);
    return newmodno;
}

static int64_t mm_start_loadimport(uint8_t * modulename,int64_t * exportflag,uint8_t * ownername) {
    int64_t i;
    int64_t fileno;
    uint8_t *  newname;
    newname = modulename;
    L33 :;
    for (i=(int64_t)1;i<=mm_decls_nmodules;i+=(int64_t)1) {
L34 :;
        if (!!(mlib_eqstring(mm_decls_moduletable[(i)].name,newname))) {
            return i;
        };
L35 :;
    }L36 :;
    ;
    fileno = mm_support_getmodulefile(modulename,ownername);
    return mm_start_addmodule(newname,fileno,exportflag);
}

static int64_t mm_start_readimportlist(struct mm_decls_modulerec * m,uint8_t * (*importnames)[],byte (*importflags)[],int64_t maximports) {
    int64_t n;
    int64_t flag;
    int64_t exportflag;
    int64_t i;
    uint8_t *  iname;
    int64_t needmsys;
    uint8_t *  msysname;
    mm_lex_startlex((uint8_t*)"IMPORTS",(*m).fileno);
    exportflag = (int64_t)0;
    n = (int64_t)0;
    L37 :;
    while (1) {
        mm_lex_lexreadtoken();
        if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)36)) {
            goto L38 ;
        }else if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)6) || ((int64_t)(mm_decls_nextlx.symbol)==(int64_t)35)) {
        }else if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)37)) {
            flag = (int64_t)0;
            if (!!(mm_lex_checkname((uint8_t*)"import",(int64_t)0))) {
                mm_start_pslex();
                if ((((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_nextlx.subcode)) == (int64_t)45))) {
                    flag = (int64_t)1;
                    mm_start_pslex();
                };
                if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)37)) {
                    mlib_abortprogram((uint8_t*)"import: modulename expected");
                };
                if ((++n >= maximports)) {
                    mlib_abortprogram((uint8_t*)"too many imports");
                };
                iname = mm_start_mapimport(mm_decls_nextlx.svalue);
                (*importnames)[(n)-1] = mlib_pcm_copyheapstring(iname);
                (*importflags)[(n)] = (uint64_t)(flag);
            } else if (!!(mm_lex_checkname((uint8_t*)"importpath",(int64_t)0))) {
                mm_start_pslex();
                if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)46)) {
                    mm_start_addsearchdir(mm_decls_nextlx.svalue);
                    mm_start_pslex();
                } else {
                    mlib_abortprogram((uint8_t*)"string path expected");
                };
            } else if (!!(mm_lex_checkname((uint8_t*)"mapmodule",(int64_t)0))) {
                mm_start_domapmodule();
            } else if (!!(mm_lex_checkname((uint8_t*)"as",(int64_t)0))) {
                mm_start_pslex();
                mm_start_pslex();
            } else {
                goto L38 ;
            };
        } else {
            goto L38 ;
        };
    }L38 :;
    ;
    msysname = (!!(mm_decls_ctarget)?(uint8_t*)"msysnewc":(uint8_t*)"msysnew");
    if ((mm_decls_nmodules == (int64_t)1)) {
        needmsys = (int64_t)1;
        L39 :;
        for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L40 :;
            if (!!(mlib_eqstring((*importnames)[(i)-1],msysname))) {
                needmsys = (int64_t)0;
                goto L42 ;
            };
L41 :;
        }L42 :;
        ;
        if (!!((uint64_t)(mm_decls_fnomsys))) {
            needmsys = (int64_t)0;
        };
        if (!!(needmsys)) {
            ++n;
            (*importnames)[(n)-1] = mlib_pcm_copyheapstring(msysname);
            (*importflags)[(n)] = (uint64_t)((int64_t)0);
        };
    };
    (*importflags)[((int64_t)0)] = (uint64_t)(exportflag);
    return n;
}

static void mm_start_pslex(void) {
    static uint8_t psname[256];
    mm_decls_prescanmode = (int64_t)1;
    mm_lex_lexreadtoken();
    mm_decls_prescanmode = (int64_t)0;
    if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)37)) {
        strcpy((int8_t *)(psname),(int8_t *)(mm_lex_convertzstring(mm_decls_nextlx.svalue,(int64_t)(mm_decls_nextlx.length))));
        mm_decls_nextlx.svalue = psname;
    };
}

static void mm_start_initdata(void) {
    mlib_pcm_init();
    mm_lex_lexsetup();
    mm_genwx64_initassemsymbols();
    mm_support_inittypetables();
    mm_lib_initqclib();
}

static void mm_start_initsearchdirs(void) {
    mm_decls_nsearchdirs = (int64_t)0;
    mm_start_addsearchdir((uint8_t*)"c:/oldmx/");
    mm_start_addsearchdir((uint8_t*)"c:/ax/");
    mm_start_addsearchdir(oslinux_os_getmpath());
    mm_start_addsearchdir(oslinux_os_gethostname());
    mm_start_addsearchdir((uint8_t*)"./");
}

static void mm_start_addsearchdir(uint8_t * path) {
    int64_t i;
    L43 :;
    for (i=(int64_t)1;i<=mm_decls_nsearchdirs;i+=(int64_t)1) {
L44 :;
        if (!!(mlib_eqstring(mm_decls_searchdirs[(i)-1],path))) {
            return;
        };
L45 :;
    }L46 :;
    ;
    if ((mm_decls_nsearchdirs > (int64_t)10)) {
        mm_support_loaderror((uint8_t*)"Too many search paths",(uint8_t*)"",(uint8_t*)"");
    };
    mm_decls_searchdirs[(++mm_decls_nsearchdirs)-1] = mlib_pcm_copyheapstring(path);
}

static void mm_start_showsearchdirs(void) {
    int64_t i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Import search paths:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L47 :;
    for (i=(int64_t)1;i<=mm_decls_nsearchdirs;i+=(int64_t)1) {
L48 :;
        if (!!((uint64_t)((*mm_decls_searchdirs[(i)-1])))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)":",NULL);
            msysnewc_m_print_str(mm_decls_searchdirs[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)": .",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
L49 :;
    }L50 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void mm_start_showast(uint8_t * filename) {
    void *  f;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"w"));
    if (!(!!(f))) {
        return;
    };
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"PROC",NULL);
    msysnewc_m_print_str(filename,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_diags_printcode(f,(uint8_t*)"");
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    fclose(f);
}

static void mm_start_showstflat(uint8_t * caption,void * f) {
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"PROC",NULL);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_diags_printstflat(f);
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void mm_start_showsttree(uint8_t * caption,void * f) {
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"PROC",NULL);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_diags_printst(f,mm_decls_stprogram,(int64_t)0);
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void mm_start_showtiming(void) {
    double t;
    t = (double)((mm_start_endclock - mm_start_startclock));
    if (!!(mm_decls_nalllines)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Time:",NULL);
        msysnewc_m_print_r64(t,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Time:",NULL);
        msysnewc_m_print_r64(t,NULL);
        msysnewc_m_print_i64(mm_decls_nalllines,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void mm_start_getinputoptions(void) {
    int64_t paramno;
    int64_t pmtype;
    int64_t sw;
    int64_t ncolons;
    uint8_t *  name;
    uint8_t *  value;
    uint8_t *  filename;
    uint8_t *  ext;
    int64_t av_1;
    paramno = (int64_t)2;
    ncolons = (int64_t)0;
    L51 :;
    while (!!((pmtype = mlib_nextcmdparam(&paramno,&name,&value,(uint8_t*)"m")))) {
        if ((pmtype==(int64_t)1)) {
            mlib_convlcstring(name);
            L54 :;
            for (sw=(int64_t)1;sw<=(int64_t)33;sw+=(int64_t)1) {
L55 :;
                if (!!(mlib_eqstring(name,mm_start_optionnames[(sw)-1]))) {
                    mm_start_do_option(sw,value);
                    goto L57 ;
                };
L56 :;
            }
            {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"Unknown option:",NULL);
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((int64_t)99);
            }L57 :;
            ;
        }else if ((pmtype==(int64_t)2)) {
            if ((mm_decls_ninputfiles >= (int64_t)50)) {
                mm_support_loaderror((uint8_t*)"Too many input files",(uint8_t*)"",(uint8_t*)"");
            };
            mlib_convlcstring(name);
            mm_decls_inputfiles[(++mm_decls_ninputfiles)] = mlib_pcm_copyheapstring(name);
        }else if ((pmtype==(int64_t)3)) {
            if ((mm_decls_nlibfiles >= (int64_t)50)) {
                mm_support_loaderror((uint8_t*)"Too many lib files",(uint8_t*)"",(uint8_t*)"");
            };
            mm_decls_libfiles[(++mm_decls_nlibfiles)] = mlib_pcm_copyheapstring(name);
        }else if ((pmtype==(int64_t)4)) {
            if ((++ncolons > (int64_t)1)) {
                name = (uint8_t*)":";
                value = (uint8_t *)(0);
                goto L58 ;
;
            };
        }else if ((pmtype==(int64_t)5)) {
            //doextra:
L58 :;
;
            mm_start_extraparams[(++mm_start_nextraparams)-1] = mlib_pcm_copyheapstring(name);
            mm_start_extravalues[(mm_start_nextraparams)-1] = mlib_pcm_copyheapstring(value);
        };
L52 :;
    }L53 :;
    ;
    if ((mm_decls_cc_mode == (int64_t)0)) {
        mm_decls_cc_mode = (int64_t)2;
    };
    if ((mm_decls_linkoption == 0)) {
        mm_decls_linkoption = (uint8_t*)"exe";
    };
    if (((mm_decls_ninputfiles == (int64_t)0) && !(!!(mm_decls_fwritelibs)))) {
        mm_start_showcaption();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Usage:",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((int64_t)1)-1],NULL);
        msysnewc_m_print_str((uint8_t*)"filename[.m]     # Compile project to executable",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((int64_t)1)-1],NULL);
        msysnewc_m_print_str((uint8_t*)"-help            # Other options",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    } else if ((mm_decls_ninputfiles == (int64_t)1)) {
        filename = mm_decls_inputfiles[((int64_t)1)];
        ext = mlib_extractext(filename,(int64_t)0);
        if (!!(mlib_eqstring(ext,(uint8_t*)"ma"))) {
            mm_decls_fbundled = (int64_t)1;
            mm_decls_mafilename = mlib_pcm_copyheapstring(filename);
            mm_decls_inputfiles[((int64_t)1)] = mlib_pcm_copyheapstring(mlib_changeext(filename,(uint8_t*)"m"));
        };
        mm_decls_outfilesource = mlib_pcm_copyheapstring(mlib_changeext(filename,mm_decls_targetexts[(mm_decls_target)-1]));
        if ((!!(mm_decls_islinux) && !!(mlib_eqstring(mm_decls_linkoption,(uint8_t*)"exe")))) {
            mm_decls_linkoption = (uint8_t*)"";
        };
        mm_decls_outfilebin = mlib_pcm_copyheapstring(mlib_changeext(filename,mm_decls_linkoption));
        if ((mm_decls_cc_mode == (int64_t)1)) {
            if (!!(mm_decls_destfilename)) {
                mm_decls_outfilesource = mm_decls_destfilename;
            };
            mm_decls_outfile = mm_decls_outfilesource;
        } else {
            if (!!(mm_decls_destfilename)) {
                mm_decls_outfilebin = mm_decls_destfilename;
            };
            mm_decls_outfile = mm_decls_outfilebin;
        };
    } else {
        mm_support_loaderror((uint8_t*)"Specify one lead module only",(uint8_t*)"",(uint8_t*)"");
    };
}

static void mm_start_do_option(int64_t sw,uint8_t * value) {
    if ((sw==(int64_t)7)) {
        mm_decls_cc_mode = (int64_t)1;
    }else if ((sw==(int64_t)8)) {
        mm_decls_cc_mode = (int64_t)2;
    }else if ((sw==(int64_t)9)) {
        mm_decls_cc_mode = (int64_t)3;
    }else if ((sw==(int64_t)3)) {
        mm_decls_ccompiler = (int64_t)1;
    }else if ((sw==(int64_t)4)) {
        mm_decls_ccompiler = (int64_t)2;
    }else if ((sw==(int64_t)5)) {
        mm_decls_ccompiler = (int64_t)3;
    }else if ((sw==(int64_t)6)) {
        mm_decls_foptimise = (int64_t)1;
    }else if ((sw==(int64_t)1)) {
        mm_decls_linkoption = (uint8_t*)"exe";
    }else if ((sw==(int64_t)2)) {
        mm_decls_linkoption = (uint8_t*)"obj";
    }else if ((sw==(int64_t)19)) {
        mm_decls_fshowtiming = (int64_t)1;
    }else if ((sw==(int64_t)20)) {
        mm_decls_fverbose = (int64_t)2;
    }else if ((sw==(int64_t)21)) {
        mm_decls_fverbose = (int64_t)3;
    }else if ((sw==(int64_t)22)) {
        mm_decls_fverbose = (int64_t)0;
    }else if ((sw==(int64_t)23) || (sw==(int64_t)24)) {
        mm_genwx64_showhelp();
        exit(0);
    }else if ((sw==(int64_t)25)) {
        mm_decls_dointlibs = (int64_t)0;
    }else if ((sw==(int64_t)32)) {
        mm_decls_fwritelibs = (int64_t)1;
    }else if ((sw==(int64_t)26)) {
        mm_decls_destfilename = mlib_pcm_copyheapstring(value);
    }else if ((sw==(int64_t)28)) {
        mm_decls_fcheckunusedlocals = (int64_t)1;
    }else if ((sw==(int64_t)27)) {
        mm_decls_fnomsys = (uint64_t)((int64_t)1);
    }else if ((sw==(int64_t)29)) {
        mm_decls_fdebugcompiler = (uint64_t)((int64_t)1);
    }else if ((sw==(int64_t)10)) {
        mm_decls_passlevel = (int64_t)0;
    }else if ((sw==(int64_t)11)) {
        mm_decls_passlevel = (int64_t)1;
    }else if ((sw==(int64_t)13)) {
        mm_decls_passlevel = (int64_t)2;
    }else if ((sw==(int64_t)14)) {
        mm_decls_passlevel = (int64_t)3;
    }else if ((sw==(int64_t)15)) {
        mm_decls_passlevel = (int64_t)4;
    }else if ((sw==(int64_t)16)) {
        mm_decls_passlevel = (int64_t)5;
    }else if ((sw==(int64_t)17)) {
        mm_decls_passlevel = (int64_t)6;
    }else if ((sw==(int64_t)18)) {
        mm_decls_passlevel = (int64_t)7;
    }else if ((sw==(int64_t)30)) {
        mm_start_dosetoptionvar(value);
    }else if ((sw==(int64_t)31)) {
        mm_decls_fshowrecs = (int64_t)1;
    }else if ((sw==(int64_t)12)) {
        mm_decls_fwritema = (int64_t)1;
    }else if ((sw==(int64_t)33)) {
        mm_decls_fuseax = (int64_t)1;
    };
}

static void mm_start_showcaption(void) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Mosaic Compiler",NULL);
    msysnewc_m_print_str((uint8_t*)"11-Nov-2021",NULL);
    msysnewc_m_print_str((uint8_t*)"23:12:34",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void mm_start_addtolog(uint8_t * filename,void * logdest) {
    void *  f;
    int64_t c;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"rb"));
    if ((f == 0)) {
        return;
    };
    L59 :;
    while (1) {
        c = (int64_t)(fgetc(f));
        if ((c == (int64_t)-1)) {
            goto L60 ;
        };
        fputc((int64_t)((int32_t)(c)),logdest);
    }L60 :;
    ;
    fclose(f);
}

static void mm_start_addoptionvar(uint8_t * name,uint8_t * value) {
    int64_t i;
    if ((mm_start_noptionvars >= (int64_t)25)) {
        mlib_abortprogram((uint8_t*)"Too many option vars");
    };
    L61 :;
    for (i=(int64_t)1;i<=mm_start_noptionvars;i+=(int64_t)1) {
L62 :;
        if (!!(mlib_eqstring(name,mm_start_optionvars[(i)-1]))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mlib_abortprogram((uint8_t*)"Dupl optionvar");
        };
L63 :;
    }L64 :;
    ;
    mm_start_optionvars[(++mm_start_noptionvars)-1] = mlib_pcm_copyheapstring(name);
    if ((value == 0)) {
        mm_start_optionvalues[(mm_start_noptionvars)-1] = (uint8_t*)"1";
    } else {
        mm_start_optionvalues[(mm_start_noptionvars)-1] = mlib_pcm_copyheapstring(value);
    };
}

void mm_start_addmodulemapping(uint8_t * old,uint8_t * newx,uint8_t * optionname,uint8_t * valuename) {
    int64_t option;
    int64_t i;
    if (!!(optionname)) {
        option = mm_start_findoptionvar(optionname);
        if (!!(option)) {
            if (!!(mlib_eqstring(optionname,mm_start_optionvars[(option)-1]))) {
                if (!(!!(mlib_eqstring(mm_start_optionvalues[(option)-1],valuename)))) {
                    return;
                };
            };
        } else {
            return;
        };
    };
    if ((mm_decls_nmodulemap >= (int64_t)25)) {
        mlib_abortprogram((uint8_t*)"Too many module mappings");
    };
    L65 :;
    for (i=(int64_t)1;i<=mm_decls_nmodulemap;i+=(int64_t)1) {
L66 :;
        if (!!(mlib_eqstring(old,mm_decls_genericmodules[(i)-1]))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(old,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mlib_abortprogram((uint8_t*)"Dupl module mapping");
        };
L67 :;
    }L68 :;
    ;
    mm_decls_genericmodules[(++mm_decls_nmodulemap)-1] = mlib_pcm_copyheapstring(old);
    mm_decls_actualmodules[(mm_decls_nmodulemap)-1] = mlib_pcm_copyheapstring(newx);
}

static void mm_start_dosetoptionvar(uint8_t * s) {
    uint8_t *  t;
    uint8_t name[256];
    uint8_t value[256];
    if (((s == 0) || ((int64_t)((*s)) == (int64_t)0))) {
        mlib_abortprogram((uint8_t*)"set:no option");
    };
    t = name;
    strcpy((int8_t *)(t),(int8_t *)(s));
    value[((int64_t)1)-1] = (uint64_t)0u;
    L69 :;
    while (!!((uint64_t)((*t)))) {
        if (((uint64_t)((*t)) == '=')) {
            (*t) = (uint64_t)0u;
            strcpy((int8_t *)(value),(int8_t *)((t + (int64_t)1)));
            goto L71 ;
        };
        ++t;
L70 :;
    }L71 :;
    ;
    if (((int64_t)(value[((int64_t)1)-1]) == (int64_t)0)) {
        strcpy((int8_t *)(value),(int8_t *)((uint8_t*)"1"));
    };
    mm_start_addoptionvar(name,value);
}

static int64_t mm_start_findoptionvar(uint8_t * name) {
    int64_t i;
    L72 :;
    for (i=(int64_t)1;i<=mm_start_noptionvars;i+=(int64_t)1) {
L73 :;
        if (!!(mlib_eqstring(name,mm_start_optionvars[(i)-1]))) {
            return i;
        };
L74 :;
    }L75 :;
    ;
    return (int64_t)0;
}

static void mm_start_getpsname(uint8_t * dest) {
    mm_start_pslex();
    if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)37)) {
    }else if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)46)) {
    }else if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)41)) {
        mm_decls_nextlx.svalue = msysnewc_strint((int64_t)(mm_decls_nextlx.svalue),(uint8_t *)(0));
    } else {
        mlib_abortprogram((uint8_t*)"map1");
    };
    strcpy((int8_t *)(dest),(int8_t *)(mm_decls_nextlx.svalue));
    mm_start_pslex();
}

static void mm_start_domapmodule(void) {
    uint8_t genname[256];
    uint8_t actualname[256];
    uint8_t optionname[256];
    uint8_t valuename[256];
    int64_t cond;
    mm_start_getpsname(genname);
    if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)11)) {
        mlib_abortprogram((uint8_t*)"=> expected");
    };
    mm_start_getpsname(actualname);
    cond = (int64_t)0;
    if ((((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)37) && !!(mm_lex_checkname((uint8_t*)"when",(int64_t)0)))) {
        mm_start_getpsname(optionname);
        if ((((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_nextlx.subcode)) == (int64_t)36))) {
            mm_start_getpsname(valuename);
        } else {
            strcpy((int8_t *)(valuename),(int8_t *)((uint8_t*)"1"));
        };
        cond = (int64_t)1;
    };
    L76 :;
    while (!(((mm_decls_nextlx.symbol == (int64_t)35) || (mm_decls_nextlx.symbol == (int64_t)36)))) {
        mm_start_pslex();
L77 :;
    }L78 :;
    ;
    if (!!(cond)) {
        mm_start_addmodulemapping(genname,actualname,optionname,valuename);
    } else {
        mm_start_addmodulemapping(genname,actualname,(uint8_t *)(0),(uint8_t *)(0));
    };
}

uint8_t * mm_start_mapimport(uint8_t * name) {
    int64_t i;
    L79 :;
    for (i=(int64_t)1;i<=mm_decls_nmodulemap;i+=(int64_t)1) {
L80 :;
        if (!!(mlib_eqstring(name,mm_decls_genericmodules[(i)-1]))) {
            return mm_decls_actualmodules[(i)-1];
        };
L81 :;
    }L82 :;
    ;
    return name;
}

static void mm_start_do_writema(void) {
    if (!!(mm_decls_fwritema)) {
        if (!!(mm_decls_fbundled)) {
            mm_support_loaderror((uint8_t*)"-ma used with .ma input",(uint8_t*)"",(uint8_t*)"");
        };
        mm_support_writemafile(mm_decls_inputfiles[((int64_t)1)],mm_decls_destfilename);
        exit(0);
    };
}

static void mm_start_starttimer(void) {
    static int64_t tt;
    tt = (int64_t)(clock());
}

static void mm_start_stoptimer(uint8_t * mess) {
    int64_t newtt;
    newtt = (int64_t)(clock());
}

int64_t msysnewc_m_getdotindex(uint64_t a,int64_t i) {
    return (((int64_t)(a) & ((int64_t)1 << i)) >> i);
}

void msysnewc_m_setdotindex(uint64_t * a,int64_t i,int64_t x) {
    uint32_t *  a32;
    if ((i >= (int64_t)32)) {
        (*a) = (uint64_t)((((int64_t)((*a)) & ~(((int64_t)1 << i))) | (int64_t)(((uint64_t)(x) << i))));
    } else {
        a32 = (uint32_t *)(a);
        (*a32) = (uint64_t)((((int64_t)((uint64_t)((*a32))) & ~(((int64_t)1 << i))) | (int64_t)(((uint64_t)(x) << i))));
    };
}

int64_t msysnewc_m_getdotslice(uint64_t a,int64_t i,int64_t j) {
    if ((i >= j)) {
        return (int64_t)(((a >> j) & ~(((uint64_t)18446744073709551615u << ((i - j) + (int64_t)1)))));
    } else {
        return (int64_t)(((a >> i) & ~(((uint64_t)18446744073709551615u << ((j - i) + (int64_t)1)))));
    };
}

void msysnewc_m_setdotslice(uint64_t * a,int64_t i,int64_t j,uint64_t x) {
    uint64_t mask64;
    uint64_t mask;
    uint32_t *  a32;
    if ((i > j)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"SETDOTSLICE?",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((int64_t)52);
    };
    if ((j >= (int64_t)32)) {
        mask64 = (~(((uint64_t)18446744073709551615u << ((j - i) + (int64_t)1))) << i);
        (*a) = (((*a) & ~(mask64)) | (x << i));
    } else {
        a32 = (uint32_t *)(a);
        mask = (~(((uint64_t)18446744073709551615u << ((j - i) + (int64_t)1))) << i);
        (*a32) = (((uint64_t)((*a32)) & ~(mask)) | (x << i));
    };
}

int64_t msysnewc_m_get_nprocs(void) {
    return msysnewc__fnnprocs;
}

int64_t msysnewc_m_get_nexports(void) {
    return msysnewc__fnnexports;
}

void * msysnewc_m_get_procname(int64_t n) {
    return (void *)(msysnewc__fnnames[(n)-1]);
}

uint8_t * msysnewc_m_get_procaddr(int64_t n) {
    return (uint8_t *)(msysnewc__fnaddresses[(n)-1]);
}

void * msysnewc_m_get_procexport(int64_t n) {
    return (void *)(&msysnewc__fnexports[(n)-1]);
}

static void msysnewc_pushio(void) {
    if ((msysnewc_niostack >= (int64_t)10)) {
        printf((int8_t *)((uint8_t*)"Too many io levels\n"));
        exit((int64_t)53);
    };
    ++msysnewc_niostack;
    msysnewc_outchan_stack[(msysnewc_niostack)-1] = msysnewc_outchan;
    msysnewc_outdev_stack[(msysnewc_niostack)-1] = msysnewc_outdev;
    msysnewc_fmtstr_stack[(msysnewc_niostack)-1] = msysnewc_fmtstr;
    msysnewc_needgap_stack[(msysnewc_niostack)-1] = (uint64_t)(msysnewc_needgap);
    msysnewc_needgap = (int64_t)0;
    msysnewc_fmtstr = (uint8_t *)(0);
    msysnewc_outchan = 0;
}

void msysnewc_m_print_startfile(void * dev) {
    msysnewc_pushio();
    msysnewc_outchan = dev;
    if (!!(dev)) {
        msysnewc_outdev = (int64_t)2;
    } else {
        msysnewc_outdev = (int64_t)1;
    };
}

void msysnewc_m_print_startstr(uint8_t * s) {
    uint8_t * *  p;
    msysnewc_pushio();
    msysnewc_ptr_stack[(msysnewc_niostack)-1] = s;
    p = &msysnewc_ptr_stack[(msysnewc_niostack)-1];
    msysnewc_outchan = (void *)(p);
    msysnewc_outdev = (int64_t)3;
}

void msysnewc_m_print_startptr(uint8_t * * p) {
    msysnewc_pushio();
    msysnewc_outchan = (void *)(p);
    msysnewc_outdev = (int64_t)3;
}

void msysnewc_m_print_startcon(void) {
    msysnewc_pushio();
    msysnewc_outdev = (int64_t)1;
}

void msysnewc_m_print_setfmt(uint8_t * format) {
    msysnewc_fmtstr = format;
}

void msysnewc_m_print_end(void) {
    msysnewc_needgap = (int64_t)0;
    msysnewc_nextfmtchars((int64_t)1);
    if ((msysnewc_niostack == (int64_t)0)) {
        return;
    };
    msysnewc_outchan = msysnewc_outchan_stack[(msysnewc_niostack)-1];
    msysnewc_outdev = msysnewc_outdev_stack[(msysnewc_niostack)-1];
    msysnewc_fmtstr = msysnewc_fmtstr_stack[(msysnewc_niostack)-1];
    msysnewc_needgap = (int64_t)(msysnewc_needgap_stack[(msysnewc_niostack)-1]);
    --msysnewc_niostack;
}

void msysnewc_m_print_ptr(void * a,uint8_t * fmtstyle) {
    msysnewc_nextfmtchars((int64_t)0);
    msysnewc_printstr(msysnewc_strword((uint64_t)(a),(uint8_t*)"z8h"));
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_i64(int64_t a,uint8_t * fmtstyle) {
    uint8_t s[40];
    struct msysnewc_fmtrec fmt;
    int64_t n;
    msysnewc_nextfmtchars((int64_t)0);
    if ((fmtstyle == 0)) {
        if ((a >= (int64_t)0)) {
            n = msysnewc_u64tostr((uint64_t)(a),s,(uint64_t)((int64_t)10),(int64_t)0);
        } else {
            s[((int64_t)1)-1] = '-';
            n = (msysnewc_u64tostr((uint64_t)(-(a)),&s[((int64_t)2)-1],(uint64_t)((int64_t)10),(int64_t)0) + (int64_t)1);
        };
        msysnewc_printstr_n(s,n);
    } else {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        if (((uint64_t)(fmt.param) == 'V')) {
            msysnewc_fmtparam = a;
            msysnewc_needgap = (int64_t)0;
        } else {
            msysnewc_tostr_i64(a,&fmt);
        };
    };
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_u64(uint64_t a,uint8_t * fmtstyle) {
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((int64_t)0);
    if ((fmtstyle == 0)) {
        msysnewc_printstr(msysnewc_strword(a,(uint8_t *)(0)));
    } else {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        msysnewc_tostr_u64(a,&fmt);
    };
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_r64(double x,uint8_t * fmtstyle) {
    uint8_t s[360];
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((int64_t)0);
    if ((fmtstyle == 0)) {
        sprintf((int8_t *)(s),(int8_t *)((uint8_t*)"%f"),x);
        msysnewc_printstr(s);
    } else {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        msysnewc_tostr_r64(x,&fmt);
    };
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_r32(float x,uint8_t * fmtstyle) {
    msysnewc_m_print_r64((double)(x),fmtstyle);
}

void msysnewc_m_print_c8(int64_t a,uint8_t * fmtstyle) {
    uint8_t s[40];
    msysnewc_nextfmtchars((int64_t)0);
    s[((int64_t)1)-1] = (uint64_t)(a);
    s[((int64_t)2)-1] = (uint64_t)0u;
    msysnewc_printstr(s);
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_str(uint8_t * s,uint8_t * fmtstyle) {
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((int64_t)0);
    if ((fmtstyle == 0)) {
        msysnewc_printstr(s);
    } else {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        msysnewc_tostr_str(s,&fmt);
    };
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_newline(void) {
    msysnewc_needgap = (int64_t)0;
    msysnewc_nextfmtchars((int64_t)1);
    msysnewc_printstr((uint8_t*)"\r\n");
}

void msysnewc_m_print_nogap(void) {
    msysnewc_needgap = (int64_t)0;
}

void msysnewc_printstr(uint8_t * s) {
    uint8_t * *  p;
    if ((msysnewc_outdev==(int64_t)1)) {
        printf((int8_t *)((uint8_t*)"%s"),s);
    }else if ((msysnewc_outdev==(int64_t)2)) {
        fprintf(msysnewc_outchan,(int8_t *)((uint8_t*)"%s"),s);
    }else if ((msysnewc_outdev==(int64_t)3)) {
        p = (uint8_t * *)(msysnewc_outchan);
        strcpy((int8_t *)((*p)),(int8_t *)(s));
        (*p) += (int64_t)(strlen((int8_t *)(s)));
    };
}

void msysnewc_printstr_n(uint8_t * s,int64_t n) {
    uint8_t str[256];
    uint8_t * *  p;
    if ((n==(int64_t)-1)) {
        n = (int64_t)(strlen((int8_t *)(s)));
    }else if ((n==(int64_t)0)) {
        return;
    };
    if ((msysnewc_outdev==(int64_t)3)) {
        p = (uint8_t * *)(msysnewc_outchan);
        memcpy((void *)((*p)),(void *)(s),(uint64_t)(n));
        (*p) += n;
        (*(*p)) = (uint64_t)0u;
    }else if ((msysnewc_outdev==(int64_t)2)) {
        s = msysnewc_makezstring(s,n,str);
        fprintf(msysnewc_outchan,(int8_t *)((uint8_t*)"%s"),s);
        msysnewc_freezstring(s,n);
    }else if ((msysnewc_outdev==(int64_t)1)) {
        s = msysnewc_makezstring(s,n,str);
        printf((int8_t *)((uint8_t*)"%s"),s);
        msysnewc_freezstring(s,n);
    };
}

void msysnewc_printstrn_app(uint8_t * s,int64_t length,void * f) {
    if (!!(length)) {
        if ((f == 0)) {
            printf("%.*s",(i32)length,s);;
        } else {
            fprintf(f,"%.*s",(i32)length,s);;
        };
    };
}

static uint8_t * msysnewc_makezstring(uint8_t * s,int64_t n,uint8_t * local) {
    uint8_t *  t;
    if ((n < (int64_t)256)) {
        memcpy((void *)(local),(void *)(s),(uint64_t)(n));
        (*(local + n)) = (uint64_t)0u;
        return local;
    } else {
        t = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
        memcpy((void *)(t),(void *)(s),(uint64_t)(n));
        (*(t + n)) = (uint64_t)0u;
        return t;
    };
}

static void msysnewc_freezstring(uint8_t * t,int64_t n) {
    if ((n >= (int64_t)256)) {
        mlib_pcm_free((void *)(t),(n + (int64_t)1));
    };
}

static void msysnewc_printchar(int64_t ch) {
    uint8_t * *  p;
    if ((msysnewc_outdev==(int64_t)1)) {
        printf("%c",(int)ch);
    }else if ((msysnewc_outdev==(int64_t)2)) {
        fprintf(msysnewc_outchan,"%c",(int)ch);
    }else if ((msysnewc_outdev==(int64_t)3)) {
        p = (uint8_t * *)(msysnewc_outchan);
        (*(*p)) = (uint64_t)(ch);
        (*p) += (int64_t)1;
        (*(*p)) = (uint64_t)0u;
    };
}

void msysnewc_nextfmtchars(int64_t lastx) {
    uint8_t c;
    uint8_t *  pstart;
    int64_t n;
    if (!(!!(msysnewc_fmtstr))) {
        if (!!(msysnewc_needgap)) {
            msysnewc_printchar((int64_t)32);
        };
        msysnewc_needgap = (int64_t)0;
        return;
    };
    pstart = msysnewc_fmtstr;
    n = (int64_t)0;
    L83 :;
    while (!!((int64_t)1)) {
        c = (uint64_t)((*msysnewc_fmtstr));
        switch ((int64_t)(c)) {
        case 35:;
        {
            if (!!(lastx)) {
                goto L86 ;
;
            };
            ++msysnewc_fmtstr;
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
            };
            return;
        }break;
        case 0:;
        {
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
            } else if (!(!!(lastx))) {
                msysnewc_printstr_n((uint8_t*)"|",(int64_t)1);
            };
            return;
        }break;
        case 126:;
        {
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
                n = (int64_t)0;
            };
            ++msysnewc_fmtstr;
            c = (uint64_t)((*msysnewc_fmtstr));
            if (!!((uint64_t)(c))) {
                ++msysnewc_fmtstr;
                msysnewc_printchar((int64_t)(c));
            };
            pstart = msysnewc_fmtstr;
        }break;
        default: {
            //skip:
L86 :;
;
            ++n;
            ++msysnewc_fmtstr;
        }
        } //SW
;
L84 :;
    }L85 :;
    ;
}

void msysnewc_strtofmt(uint8_t * s,int64_t slen,struct msysnewc_fmtrec * fmt) {
    uint8_t c;
    byte wset;
    int64_t n;
    uint8_t str[100];
    (*fmt) = msysnewc_defaultfmt;
    if ((s == 0)) {
        return;
    };
    if ((slen == (int64_t)-1)) {
        slen = (int64_t)(strlen((int8_t *)(s)));
    };
    memcpy((void *)(str),(void *)(s),(uint64_t)(slen));
    str[(slen)] = (uint64_t)0u;
    s = str;
    wset = (uint64_t)((int64_t)0);
    L87 :;
    while (!!((uint64_t)((*s)))) {
        c = (uint64_t)((*s));
        ++s;
        switch ((int64_t)(c)) {
        case 66:;
        case 98:;
        {
            (*fmt).base = (uint64_t)((int64_t)2);
        }break;
        case 72:;
        case 104:;
        {
            (*fmt).base = (uint64_t)((int64_t)16);
        }break;
        case 79:;
        case 111:;
        {
            (*fmt).base = (uint64_t)((int64_t)8);
        }break;
        case 88:;
        case 120:;
        {
            c = (uint64_t)((*s));
            if (!!((uint64_t)(c))) {
                switch ((int64_t)(c)) {
                case 48:;
                case 49:;
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                case 56:;
                case 57:;
                {
                    c = ((uint64_t)(c) - '0');
                }break;
                case 65:;
                case 66:;
                case 67:;
                case 68:;
                case 69:;
                case 70:;
                {
                    c = (uint64_t)((((uint64_t)(c) - 'A') + (int64_t)10));
                }break;
                case 97:;
                case 98:;
                case 99:;
                case 100:;
                case 101:;
                case 102:;
                {
                    c = (uint64_t)((((uint64_t)(c) - 'a') + (int64_t)10));
                }break;
                default: {
                    c = (uint64_t)10u;
                }
                } //SW
;
                (*fmt).base = (uint64_t)(c);
                ++s;
            };
        }break;
        case 81:;
        case 113:;
        {
            (*fmt).quotechar = '"';
        }break;
        case 126:;
        {
            (*fmt).quotechar = '~';
        }break;
        case 74:;
        case 106:;
        {
            (*fmt).justify = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 65:;
        {
            (*fmt).lettercase = 'A';
        }break;
        case 97:;
        {
            (*fmt).lettercase = 'a';
        }break;
        case 90:;
        case 122:;
        {
            (*fmt).padchar = '0';
        }break;
        case 83:;
        case 115:;
        {
            (*fmt).sepchar = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 80:;
        case 112:;
        {
            (*fmt).padchar = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 84:;
        case 116:;
        {
            (*fmt).suffix = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 87:;
        case 119:;
        {
            (*fmt).usigned = 'W';
        }break;
        case 69:;
        case 101:;
        {
            (*fmt).realfmt = 'e';
        }break;
        case 70:;
        case 102:;
        {
            (*fmt).realfmt = 'f';
        }break;
        case 71:;
        case 103:;
        {
            (*fmt).realfmt = 'g';
        }break;
        case 46:;
        {
            wset = (uint64_t)((int64_t)1);
        }break;
        case 44:;
        case 95:;
        {
            (*fmt).sepchar = (uint64_t)(c);
        }break;
        case 43:;
        {
            (*fmt).plus = '+';
        }break;
        case 68:;
        case 100:;
        {
            (*fmt).charmode = 'D';
        }break;
        case 67:;
        case 99:;
        {
            (*fmt).charmode = 'C';
        }break;
        case 77:;
        case 109:;
        {
            (*fmt).heapmode = 'M';
        }break;
        case 86:;
        case 118:;
        {
            (*fmt).param = 'V';
        }break;
        case 42:;
        {
            n = msysnewc_fmtparam;
            goto L90 ;
;
        }break;
        default: {
            if ((((uint64_t)(c) >= '0') && ((uint64_t)(c) <= '9'))) {
                n = ((uint64_t)(c) - '0');
                L91 :;
                while (1) {
                    c = (uint64_t)((*s));
                    if (((int64_t)((*s)) == (int64_t)0)) {
                        goto L92 ;
                    };
                    if ((((uint64_t)(c) >= '0') && ((uint64_t)(c) <= '9'))) {
                        ++s;
                        n = (((n * (int64_t)10) + (int64_t)(c)) - (int64_t)48);
                    } else {
                        goto L92 ;
                    };
                }L92 :;
                ;
                //gotwidth:
L90 :;
;
                if (!(!!((uint64_t)(wset)))) {
                    (*fmt).minwidth = (uint64_t)(n);
                    wset = (uint64_t)((int64_t)1);
                } else {
                    (*fmt).precision = n;
                };
            };
        }
        } //SW
;
L88 :;
    }L89 :;
    ;
}

static int64_t msysnewc_domultichar(uint8_t * p,int64_t n,uint8_t * dest,struct msysnewc_fmtrec * fmt) {
    uint8_t str[20];
    uint8_t *  q;
    int64_t nchars;
    int64_t av_1;
    q = str;
    nchars = n;
    av_1 = n;
    while (av_1-- > 0) {
L93 :;
        if (((int64_t)((*p)) == (int64_t)0)) {
            goto L95 ;
        };
        (*q) = (uint64_t)((*p));
        ++q;
        ++p;
L94 :;
    }L95 :;
    ;
    (*q) = (uint64_t)0u;
    return msysnewc_expandstr(str,dest,(int64_t)(strlen((int8_t *)(str))),fmt);
}

static int64_t msysnewc_expandstr(uint8_t * s,uint8_t * t,int64_t n,struct msysnewc_fmtrec * fmt) {
    int64_t i;
    int64_t w;
    int64_t m;
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    int64_t av_4;
    int64_t av_5;
    w = (int64_t)((*fmt).minwidth);
    if (((w == (int64_t)0) || (w <= n))) {
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        (*(t + n)) = (uint64_t)0u;
        return n;
    };
    if (((uint64_t)((*fmt).justify) == 'L')) {
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        t += n;
        L96 :;
        for (i=(int64_t)1;i<=(w - n);i+=(int64_t)1) {
L97 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L98 :;
        }L99 :;
        ;
        (*t) = (uint64_t)0u;
    } else if (((uint64_t)((*fmt).justify) == 'R')) {
        if (((((uint64_t)((*fmt).padchar) == '0') && !!((uint64_t)((*fmt).base))) && (((uint64_t)((*s)) == '-') || ((uint64_t)((*s)) == '+')))) {
            (*t) = (uint64_t)((*s));
            ++t;
            av_2 = (w - n);
            while (av_2-- > 0) {
L100 :;
                (*t) = (uint64_t)((*fmt).padchar);
                ++t;
L101 :;
            }L102 :;
            ;
            strncpy((int8_t *)(t),(int8_t *)((s + (int64_t)1)),(uint64_t)((n - (int64_t)1)));
            (*((t + n) - (int64_t)1)) = (uint64_t)0u;
        } else {
            av_3 = (w - n);
            while (av_3-- > 0) {
L103 :;
                (*t) = (uint64_t)((*fmt).padchar);
                ++t;
L104 :;
            }L105 :;
            ;
            strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
            (*(t + n)) = (uint64_t)0u;
        };
    } else {
        m = (((w - n) + (int64_t)1) / (int64_t)2);
        av_4 = m;
        while (av_4-- > 0) {
L106 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L107 :;
        }L108 :;
        ;
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        t += n;
        av_5 = ((w - n) - m);
        while (av_5-- > 0) {
L109 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L110 :;
        }L111 :;
        ;
        (*t) = (uint64_t)0u;
    };
    return w;
}

static uint64_t msysnewc_xdivrem(uint64_t a,uint64_t b,uint64_t * remainder) {
    uint64_t q;
    mlib_abortprogram((uint8_t*)"XDIVREM");
    return q;
}

static int64_t msysnewc_u64tostr(uint64_t aa,uint8_t * s,uint64_t base,int64_t sep) {
    uint8_t t[360];
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t g;
    uint8_t *  s0;
    i = (int64_t)0;
    k = (int64_t)0;
    g = (((int64_t)(base) == (int64_t)10)?(int64_t)3:(int64_t)4);
    L112 :;
    do {
        t[(++i)] = (uint64_t)(msysnewc_digits[((int64_t)((aa % base)))]);
        aa = (aa / base);
        ++k;
        if (((!!(sep) && ((int64_t)(aa) != (int64_t)0)) && (k == g))) {
            t[(++i)] = (uint64_t)(sep);
            k = (int64_t)0;
        };
L113 :;
    } while (!((int64_t)(aa) == (int64_t)0));L114 :;
    ;
    j = i;
    s0 = s;
    L115 :;
    while (!!(i)) {
        (*s) = (uint64_t)(t[(i--)]);
        ++s;
L116 :;
    }L117 :;
    ;
    (*s) = (uint64_t)0u;
    return j;
}

static int64_t msysnewc_i64tostrfmt(int64_t aa,uint8_t * s,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    int64_t n;
    int64_t usigned;
    static uint64_t mindint = (uint64_t)9223372036854775808u;
    usigned = (int64_t)0;
    if (!!((uint64_t)((*fmt).usigned))) {
        usigned = (int64_t)1;
    };
    if (((aa == (int64_t)(mindint)) && !(!!(usigned)))) {
        str[((int64_t)0)] = '-';
        n = (msysnewc_i64mintostr(&str[((int64_t)1)],(int64_t)((*fmt).base),(int64_t)((*fmt).sepchar)) + (int64_t)1);
    } else {
        if (((!(!!(usigned)) && (aa < (int64_t)0)) || !!((uint64_t)((*fmt).plus)))) {
            if ((aa < (int64_t)0)) {
                aa = -(aa);
                str[((int64_t)0)] = '-';
            } else {
                str[((int64_t)0)] = '+';
            };
            n = (msysnewc_u64tostr((uint64_t)(aa),&str[((int64_t)1)],(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar)) + (int64_t)1);
        } else {
            n = msysnewc_u64tostr((uint64_t)(aa),str,(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar));
        };
    };
    if (!!((uint64_t)((*fmt).suffix))) {
        str[(n)] = (uint64_t)((*fmt).suffix);
        str[(++n)] = (uint64_t)0u;
    };
    if (((((int64_t)((uint64_t)((*fmt).base)) > (int64_t)10) || !!((uint64_t)((*fmt).suffix))) && ((uint64_t)((*fmt).lettercase) == 'a'))) {
        msysnewc_convlcstring(str);
    };
    return msysnewc_expandstr(str,s,n,fmt);
}

static int64_t msysnewc_u64tostrfmt(int64_t aa,uint8_t * s,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    int64_t n;
    n = msysnewc_u64tostr((uint64_t)(aa),str,(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar));
    if (!!((uint64_t)((*fmt).suffix))) {
        str[(n)] = (uint64_t)((*fmt).suffix);
        str[(++n)] = (uint64_t)0u;
    };
    if ((((int64_t)((uint64_t)((*fmt).base)) > (int64_t)10) || (!!((uint64_t)((*fmt).suffix)) && ((uint64_t)((*fmt).lettercase) == 'a')))) {
        msysnewc_convlcstring(str);
    };
    return msysnewc_expandstr(str,s,n,fmt);
}

static int64_t msysnewc_i64mintostr(uint8_t * s,int64_t base,int64_t sep) {
    uint8_t t[360];
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t g;
    switch (base) {
    case 10:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"9223372036854775808"));
        j = (int64_t)3;
    }break;
    case 16:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"8000000000000000"));
        j = (int64_t)1;
    }break;
    case 2:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"1000000000000000000000000000000000000000000000000000000000000000"));
        j = (int64_t)7;
    }break;
    default: {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"<mindint>"));
    }
    } //SW
;
    i = (int64_t)(strlen((int8_t *)(&t[((int64_t)0)])));
    s += i;
    if (!!(sep)) {
        s += j;
    };
    (*s) = (uint64_t)0u;
    k = (int64_t)0;
    g = ((base == (int64_t)10)?(int64_t)3:(int64_t)4);
    L118 :;
    while (!!(i)) {
        --s;
        (*s) = (uint64_t)(t[((i-- - (int64_t)1))]);
        if (((!!(sep) && !!(i)) && (++k == g))) {
            --s;
            (*s) = (uint64_t)(sep);
            k = (int64_t)0;
        };
L119 :;
    }L120 :;
    ;
    return (int64_t)(strlen((int8_t *)(s)));
}

static int64_t msysnewc_strtostrfmt(uint8_t * s,uint8_t * t,int64_t n,struct msysnewc_fmtrec * fmt) {
    uint8_t *  u;
    uint8_t *  v;
    uint8_t str[256];
    int64_t w;
    int64_t nheap;
    nheap = (int64_t)0;
    if ((!!((uint64_t)((*fmt).quotechar)) || !!((uint64_t)((*fmt).lettercase)))) {
        if ((n < (int64_t)256)) {
            u = str;
        } else {
            nheap = (n + (int64_t)3);
            u = (uint8_t *)(mlib_pcm_alloc(nheap));
        };
        if (!!((uint64_t)((*fmt).quotechar))) {
            v = u;
            (*v) = (uint64_t)((*fmt).quotechar);
            ++v;
            if (!!(n)) {
                strcpy((int8_t *)(v),(int8_t *)(s));
                v += n;
            };
            (*v) = (uint64_t)((*fmt).quotechar);
            ++v;
            (*v) = (uint64_t)0u;
            n += (int64_t)2;
        } else {
            memcpy((void *)(u),(void *)(s),(uint64_t)(n));
        };
        switch ((int64_t)((*fmt).lettercase)) {
        case 97:;
        {
            msysnewc_convlcstring(u);
        }break;
        case 65:;
        {
            msysnewc_convucstring(u);
        }break;
        default: {
        }
        } //SW
;
        s = u;
    };
    w = (int64_t)((*fmt).minwidth);
    if ((w > n)) {
        n = msysnewc_expandstr(s,t,n,fmt);
    } else {
        memcpy((void *)(t),(void *)(s),(uint64_t)(n));
    };
    if (!!(nheap)) {
        mlib_pcm_free((void *)(u),nheap);
    };
    return n;
}

static void msysnewc_tostr_i64(int64_t a,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    int64_t n;
    if (((int64_t)((*fmt).charmode)==(int64_t)0)) {
        n = msysnewc_i64tostrfmt(a,str,fmt);
    }else if (((int64_t)((*fmt).charmode)==(int64_t)68) || ((int64_t)((*fmt).charmode)==(int64_t)100)) {
        n = msysnewc_domultichar((uint8_t *)(&a),(int64_t)8,str,fmt);
    } else {
        msysnewc_printchar(a);
        return;
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_u64(uint64_t a,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    int64_t n;
    if (((int64_t)((*fmt).charmode)==(int64_t)68) || ((int64_t)((*fmt).charmode)==(int64_t)100)) {
        n = msysnewc_domultichar((uint8_t *)(&a),(int64_t)8,str,fmt);
    }else if (((int64_t)((*fmt).charmode)==(int64_t)67) || ((int64_t)((*fmt).charmode)==(int64_t)99)) {
        msysnewc_printchar((int64_t)(a));
        return;
    } else {
        n = msysnewc_u64tostrfmt((int64_t)(a),str,fmt);
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_r64(double x,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    uint8_t str2[360];
    uint8_t cfmt[10];
    int64_t n;
    cfmt[((int64_t)0)] = '%';
    if (!!((int64_t)((*fmt).precision))) {
        cfmt[((int64_t)1)] = '.';
        cfmt[((int64_t)2)] = '*';
        cfmt[((int64_t)3)] = (uint64_t)((*fmt).realfmt);
        cfmt[((int64_t)4)] = (uint64_t)0u;
        sprintf((int8_t *)(str),(int8_t *)(cfmt),(int64_t)((*fmt).precision),x);
    } else {
        cfmt[((int64_t)1)] = (uint64_t)((*fmt).realfmt);
        cfmt[((int64_t)2)] = (uint64_t)0u;
        sprintf((int8_t *)(str),(int8_t *)(cfmt),x);
    };
    n = (int64_t)(strlen((int8_t *)(str)));
    if ((n < (int64_t)((uint64_t)((*fmt).minwidth)))) {
        n = msysnewc_expandstr(str,str2,n,fmt);
        strcpy((int8_t *)(str),(int8_t *)(str2));
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_str(uint8_t * s,struct msysnewc_fmtrec * fmt) {
    int64_t oldlen;
    int64_t newlen;
    int64_t n;
    uint8_t *  t;
    oldlen = (int64_t)(strlen((int8_t *)(s)));
    newlen = oldlen;
    if (((!!((uint64_t)((*fmt).quotechar)) || ((int64_t)((uint64_t)((*fmt).minwidth)) > newlen)) || !!((uint64_t)((*fmt).lettercase)))) {
        if (!!((uint64_t)((*fmt).quotechar))) {
            newlen += (int64_t)2;
        };
        if (((int64_t)((uint64_t)((*fmt).minwidth)) > newlen)) {
            newlen = (int64_t)((*fmt).minwidth);
        };
        t = (uint8_t *)(mlib_pcm_alloc((newlen + (int64_t)1)));
        n = msysnewc_strtostrfmt(s,t,oldlen,fmt);
        msysnewc_printstr_n(t,n);
        mlib_pcm_free((void *)(t),(newlen + (int64_t)1));
    } else {
        msysnewc_printstr_n(s,oldlen);
    };
}

static struct msysnewc_fmtrec * msysnewc_getfmt(uint8_t * fmtstyle) {
    static struct msysnewc_fmtrec fmt;
    if (!!(fmtstyle)) {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        return &fmt;
    } else {
        return &msysnewc_defaultfmt;
    };
}

uint8_t * msysnewc_strint(int64_t a,uint8_t * fmtstyle) {
    static uint8_t str[100];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_i64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

void msysnewc_getstrint(int64_t a,uint8_t * dest) {
    msysnewc_m_print_startstr(dest);
    msysnewc_tostr_i64(a,msysnewc_getfmt((uint8_t *)(0)));
    msysnewc_m_print_end();
}

uint8_t * msysnewc_strword(uint64_t a,uint8_t * fmtstyle) {
    static uint8_t str[100];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_u64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

uint8_t * msysnewc_strreal(double a,uint8_t * fmtstyle) {
    static uint8_t str[320];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_r64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

static uint8_t * msysnewc_getstr(uint8_t * s,struct msysnewc_fmtrec * fmt) {
    if (!!((uint64_t)((*fmt).heapmode))) {
        return mlib_pcm_copyheapstring(s);
    } else {
        return s;
    };
}

static void msysnewc_initreadbuffer(void) {
    if (!!(msysnewc_rd_buffer)) {
        return;
    };
    msysnewc_rd_buffer = (uint8_t *)(mlib_pcm_alloc((int64_t)16384));
    (*msysnewc_rd_buffer) = (uint64_t)0u;
    msysnewc_rd_pos = (msysnewc_rd_lastpos = msysnewc_rd_buffer);
}

void msysnewc_m_read_conline(void) {
    msysnewc_initreadbuffer();
    mlib_readlinen(0,msysnewc_rd_buffer,(int64_t)16384);
    msysnewc_rd_length = (int64_t)(strlen((int8_t *)(msysnewc_rd_buffer)));
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (uint8_t *)(0);
}

void msysnewc_m_read_fileline(void * f) {
    msysnewc_initreadbuffer();
    mlib_readlinen(f,msysnewc_rd_buffer,(int64_t)16384);
    msysnewc_rd_length = (int64_t)(strlen((int8_t *)(msysnewc_rd_buffer)));
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (uint8_t *)(0);
}

void msysnewc_m_read_strline(uint8_t * s) {
    int64_t n;
    msysnewc_initreadbuffer();
    n = (int64_t)(strlen((int8_t *)(s)));
    if ((n < (int64_t)16384)) {
        strcpy((int8_t *)(msysnewc_rd_buffer),(int8_t *)(s));
    } else {
        memcpy((void *)(msysnewc_rd_buffer),(void *)(s),(uint64_t)((int64_t)16383));
        (*((msysnewc_rd_buffer + (int64_t)16384) - (int64_t)1)) = (uint64_t)0u;
    };
    msysnewc_rd_length = n;
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (uint8_t *)(0);
}

static uint8_t * msysnewc_readitem(int64_t * itemlength) {
    uint8_t *  p;
    uint8_t *  s;
    uint8_t *  itemstr;
    uint8_t quotechar;
    uint8_t c;
    if (!(!!(msysnewc_rd_buffer))) {
        msysnewc_initreadbuffer();
    };
    s = msysnewc_rd_pos;
    L121 :;
    while ((((uint64_t)((*s)) == ' ') || ((int64_t)((*s)) == (int64_t)9))) {
        ++s;
L122 :;
    }L123 :;
    ;
    itemstr = s;
    msysnewc_rd_lastpos = (msysnewc_rd_pos = s);
    if (((int64_t)((*s)) == (int64_t)0)) {
        msysnewc_termchar = (int64_t)0;
        (*itemlength) = (int64_t)0;
        return s;
    };
    quotechar = (uint64_t)0u;
    if (((uint64_t)((*s)) == '"')) {
        quotechar = '"';
        ++s;
    } else if (((uint64_t)((*s)) == (uint64_t)39u)) {
        quotechar = (uint64_t)39u;
        ++s;
    };
    p = (itemstr = s);
    L124 :;
    while (!!((uint64_t)((*s)))) {
        c = (uint64_t)((*s++));
        switch ((int64_t)(c)) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
        {
            if ((!!((uint64_t)(quotechar)) || (p == s))) {
                goto L127 ;
;
            };
            msysnewc_termchar = (int64_t)(c);
            goto L126 ;
        }break;
        default: {
            //normalchar:
L127 :;
;
            if (((uint64_t)(c) == (uint64_t)(quotechar))) {
                if (((uint64_t)((*s)) == (uint64_t)(quotechar))) {
                    (*p) = (uint64_t)(c);
                    ++s;
                    ++p;
                } else {
                    msysnewc_termchar = (int64_t)((*s));
                    if (((msysnewc_termchar == (int64_t)44) || (msysnewc_termchar == (int64_t)61))) {
                        ++s;
                        msysnewc_termchar = (int64_t)((*s));
                    };
                    goto L126 ;
                };
            } else {
                (*p) = (uint64_t)(c);
                ++p;
            };
        }
        } //SW
;
L125 :;
    }L126 :;
    ;
    if (((int64_t)((*s)) == (int64_t)0)) {
        msysnewc_termchar = (int64_t)0;
    };
    (*itemlength) = (p - itemstr);
    msysnewc_rd_pos = s;
    return itemstr;
}

int64_t msysnewc_strtoint(uint8_t * s,int64_t length,int64_t base) {
    byte signd;
    uint64_t aa;
    uint8_t c;
    uint8_t d;
    msysnewc_itemerror = (int64_t)0;
    if ((length == (int64_t)-1)) {
        length = (int64_t)(strlen((int8_t *)(s)));
    };
    signd = (uint64_t)((int64_t)0);
    if ((!!(length) && ((uint64_t)((*s)) == '-'))) {
        signd = (uint64_t)((int64_t)1);
        ++s;
        --length;
    } else if ((!!(length) && ((uint64_t)((*s)) == '+'))) {
        ++s;
        --length;
    };
    aa = (uint64_t)((int64_t)0);
    L128 :;
    while (!!(length)) {
        c = (uint64_t)((*s++));
        --length;
        switch ((int64_t)(c)) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        {
            d = (uint64_t)((((uint64_t)(c) - 'A') + (int64_t)10));
        }break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        {
            d = (uint64_t)((((uint64_t)(c) - 'a') + (int64_t)10));
        }break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            d = ((uint64_t)(c) - '0');
        }break;
        case 95:;
        case 39:;
        {
            goto L129 ;
        }break;
        default: {
            msysnewc_itemerror = (int64_t)1;
            goto L130 ;
        }
        } //SW
;
        if (((int64_t)(d) >= base)) {
            msysnewc_itemerror = (int64_t)1;
            goto L130 ;
        };
        aa = (uint64_t)((((int64_t)(aa) * base) + (int64_t)(d)));
L129 :;
    }L130 :;
    ;
    if (!!((uint64_t)(signd))) {
        return (int64_t)(-(aa));
    } else {
        return (int64_t)(aa);
    };
}

int64_t msysnewc_m_read_i64(int64_t fmt) {
    uint8_t *  s;
    int64_t length;
    if ((fmt==(int64_t)67) || (fmt==(int64_t)99)) {
        msysnewc_rd_lastpos = msysnewc_rd_pos;
        if (!!((uint64_t)((*msysnewc_rd_pos)))) {
            return (int64_t)((*msysnewc_rd_pos++));
        } else {
            return (int64_t)0;
        };
    }else if ((fmt==(int64_t)84) || (fmt==(int64_t)116)) {
        return msysnewc_termchar;
    }else if ((fmt==(int64_t)69) || (fmt==(int64_t)101)) {
        return msysnewc_itemerror;
    };
    s = msysnewc_readitem(&length);
    if ((fmt==(int64_t)0) || (fmt==(int64_t)73) || (fmt==(int64_t)105)) {
        return msysnewc_strtoint(s,length,(int64_t)10);
    }else if ((fmt==(int64_t)66) || (fmt==(int64_t)98)) {
        return msysnewc_strtoint(s,length,(int64_t)2);
    }else if ((fmt==(int64_t)72) || (fmt==(int64_t)104)) {
        return msysnewc_strtoint(s,length,(int64_t)16);
    };
    return (int64_t)0;
}

double msysnewc_m_read_r64(int64_t fmt) {
    uint8_t str[512];
    uint8_t *  s;
    int64_t length;
    int32_t numlength;
    double x;
    s = msysnewc_readitem(&length);
    if (((length == (int64_t)0) || (length >= (int64_t)512))) {
        return (double)0.;
    };
    memcpy((void *)(str),(void *)(s),(uint64_t)(length));
    str[((length + (int64_t)1))-1] = (uint64_t)0u;
    msysnewc_itemerror = (int64_t)0;
    if ((((int64_t)(sscanf((int8_t *)(str),(int8_t *)((uint8_t*)"%lf%n"),&x,&numlength)) == (int64_t)0) || ((int64_t)(numlength) != length))) {
        x = (double)0.;
        msysnewc_itemerror = (int64_t)1;
    };
    return x;
}

void msysnewc_m_read_str(uint8_t * dest,int64_t destlen,int64_t fmt) {
    uint8_t *  s;
    int64_t length;
    msysnewc_itemerror = (int64_t)0;
    if (((fmt == (int64_t)76) || (fmt == (int64_t)108))) {
        s = msysnewc_rd_pos;
        length = ((msysnewc_rd_buffer + msysnewc_rd_length) - msysnewc_rd_pos);
    } else {
        s = msysnewc_readitem(&length);
        if (((fmt == (int64_t)78) || (fmt == (int64_t)110))) {
            msysnewc_iconvlcn(s,length);
        };
    };
    if ((destlen > (int64_t)0)) {
        if ((length >= destlen)) {
            length = (destlen - (int64_t)1);
            msysnewc_itemerror = (int64_t)1;
        };
    };
    memcpy((void *)(dest),(void *)(s),(uint64_t)(length));
    (*(dest + length)) = (uint64_t)0u;
}

void msysnewc_readstr(uint8_t * dest,int64_t fmt,int64_t destlen) {
    msysnewc_m_read_str(dest,destlen,fmt);
}

void msysnewc_rereadln(void) {
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = msysnewc_rd_pos;
}

void msysnewc_reread(void) {
    msysnewc_rd_pos = msysnewc_rd_lastpos;
}

int64_t msysnewc_valint(uint8_t * s,int64_t fmt) {
    uint8_t *  old_pos;
    uint8_t *  old_lastpos;
    int64_t aa;
    msysnewc_initreadbuffer();
    old_pos = msysnewc_rd_pos;
    old_lastpos = msysnewc_rd_lastpos;
    msysnewc_rd_pos = s;
    aa = msysnewc_m_read_i64(fmt);
    msysnewc_rd_pos = old_pos;
    msysnewc_rd_lastpos = old_lastpos;
    return aa;
}

double msysnewc_valreal(uint8_t * s) {
    uint8_t *  old_pos;
    uint8_t *  old_lastpos;
    double x;
    msysnewc_initreadbuffer();
    old_pos = msysnewc_rd_pos;
    old_lastpos = msysnewc_rd_lastpos;
    msysnewc_rd_pos = s;
    x = msysnewc_m_read_r64((int64_t)0);
    msysnewc_rd_pos = old_pos;
    msysnewc_rd_lastpos = old_lastpos;
    return x;
}

static void msysnewc_iconvlcn(uint8_t * s,int64_t n) {
    int64_t av_1;
    av_1 = n;
    while (av_1-- > 0) {
L131 :;
        (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
        ++s;
L132 :;
    }L133 :;
    ;
}

static void msysnewc_iconvucn(uint8_t * s,int64_t n) {
    int64_t av_1;
    av_1 = n;
    while (av_1-- > 0) {
L134 :;
        (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
        ++s;
L135 :;
    }L136 :;
    ;
}

static void msysnewc_convlcstring(uint8_t * s) {
    L137 :;
    while (!!((uint64_t)((*s)))) {
        (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
        ++s;
L138 :;
    }L139 :;
    ;
}

static void msysnewc_convucstring(uint8_t * s) {
    L140 :;
    while (!!((uint64_t)((*s)))) {
        (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
        ++s;
L141 :;
    }L142 :;
    ;
}

int64_t msysnewc_m_power_i64(int64_t n,int64_t a) {
    if ((n < (int64_t)0)) {
        return (int64_t)0;
    } else if ((n == (int64_t)0)) {
        return (int64_t)1;
    } else if ((n == (int64_t)1)) {
        return a;
    } else if (((n & (int64_t)1) == (int64_t)0)) {
        return msysnewc_m_power_i64((n / (int64_t)2),(a * a));
    } else {
        return (msysnewc_m_power_i64(((n - (int64_t)1) / (int64_t)2),(a * a)) * a);
    };
}

void msysnewc_m_intoverflow(void) {
    mlib_abortprogram((uint8_t*)"Integer overflow detected");
}

void msysnewc_m_dotindex(uint64_t i,uint64_t a) {
    mlib_abortprogram((uint8_t*)"DOT INDEX");
}

void msysnewc_m_dotslice(uint64_t j,uint64_t i,uint64_t a) {
    mlib_abortprogram((uint8_t*)"DOT SLICE");
}

void msysnewc_m_popdotindex(uint64_t i,uint64_t * p,uint64_t x) {
    mlib_abortprogram((uint8_t*)"POP DOT INDEX");
}

void msysnewc_m_popdotslice(uint64_t j,uint64_t i,uint64_t * p,uint64_t x) {
    mlib_abortprogram((uint8_t*)"POP DOT SLICE");
}

int64_t msysnewc_m_imin(int64_t a,int64_t b) {
    return (a<b?a:b);
}

int64_t msysnewc_m_imax(int64_t a,int64_t b) {
    return (a>b?a:b);
}

double msysnewc_m_sign(double x) {
    if ((x > (double)0.)) {
        return (double)1.;
    } else if ((x < (double)0.)) {
        return (double)-1.;
    } else {
        return (double)0.;
    };
}

void * mlib_pcm_alloc(int64_t n) {
    byte *  p;
    if (!(!!((uint64_t)(mlib_pcm_setup)))) {
        mlib_pcm_init();
    };
    if ((n > (int64_t)2048)) {
        mlib_alloccode = mlib_pcm_getac(n);
        mlib_allocbytes = (int64_t)(mlib_allocupper[(mlib_alloccode)]);
        p = (byte *)(mlib_allocmem(mlib_allocbytes));
        if (!(!!(p))) {
            mlib_abortprogram((uint8_t*)"pcm_alloc failure");
        };
        if (!!((int64_t)0)) {
            mlib_addtomemalloc((int32_t *)(p),mlib_allocbytes);
        };
        return (void *)(p);
    };
    mlib_alloccode = (int64_t)(mlib_sizeindextable[(n)]);
    if ((mlib_alloccode == (int64_t)0)) {
        mlib_alloccode = (int64_t)1;
    };
    mlib_allocbytes = (int64_t)(mlib_allocupper[(mlib_alloccode)]);
    mlib_smallmemtotal += mlib_allocbytes;
    if (!!((p = (byte *)(mlib_freelist[(mlib_alloccode)])))) {
        if (!!((int64_t)0)) {
            mlib_addtomemalloc((int32_t *)(p),mlib_allocbytes);
        };
        mlib_freelist[(mlib_alloccode)] = (uint64_t *)((int64_t)((*mlib_freelist[(mlib_alloccode)])));
        return (void *)(p);
    };
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    };
    if (!!((int64_t)0)) {
        mlib_addtomemalloc((int32_t *)(p),mlib_allocbytes);
    };
    return (void *)(p);
}

void mlib_pcm_freestr(uint8_t * s) {
    mlib_pcm_free((void *)(s),((int64_t)(strlen((int8_t *)(s))) + (int64_t)1));
}

void mlib_pcm_free(void * p,int64_t n) {
    int64_t acode;
    if ((n == (int64_t)0)) {
        return;
    };
    if ((n > (int64_t)2048)) {
        if (!!((int64_t)0)) {
            mlib_removefrommemalloc((int32_t *)(p),n);
        };
        free(p);
        return;
    };
    if (!!(p)) {
        acode = (int64_t)(mlib_sizeindextable[(n)]);
        mlib_smallmemtotal -= (int64_t)(mlib_allocupper[(acode)]);
        if (!!((int64_t)0)) {
            mlib_removefrommemalloc((int32_t *)(p),(int64_t)(mlib_allocupper[(acode)]));
        };
        (*(uint64_t *)(p)) = (uint64_t)((int64_t)(mlib_freelist[(acode)]));
        mlib_freelist[(acode)] = (uint64_t *)(p);
    };
}

void mlib_pcm_freeac(void * p,int64_t alloc) {
    mlib_pcm_free(p,(int64_t)(mlib_allocupper[(alloc)]));
}

void mlib_pcm_copymem4(void * p,void * q,int64_t n) {
    memcpy(p,q,(uint64_t)(n));
}

void mlib_pcm_clearmem(void * p,int64_t n) {
    memset(p,(int64_t)0,(uint64_t)(n));
}

void mlib_pcm_init(void) {
    int64_t j;
    int64_t k;
    int64_t size;
    int64_t av_1;
    int64_t i;
    if (!!((uint64_t)(mlib_pcm_setup))) {
        return;
    };
    mlib_pcm_newblock((int64_t)0);
    L143 :;
    for (i=(int64_t)1;i<=(int64_t)2048;i+=(int64_t)1) {
L144 :;
        j = (int64_t)1;
        k = (int64_t)16;
        L147 :;
        while ((i > k)) {
            k = (k << (int64_t)1);
            ++j;
L148 :;
        }L149 :;
        ;
        mlib_sizeindextable[(i)] = (uint64_t)(j);
L145 :;
    }L146 :;
    ;
    mlib_allocupper[((int64_t)1)] = (uint64_t)((int64_t)16);
    size = (int64_t)16;
    L150 :;
    for (i=(int64_t)2;i<=(int64_t)27;i+=(int64_t)1) {
L151 :;
        size *= (int64_t)2;
        mlib_allocupper[(i)] = (uint64_t)(size);
        if ((size >= (int64_t)33554432)) {
            k = i;
            goto L153 ;
        };
L152 :;
    }L153 :;
    ;
    L154 :;
    for (i=(k + (int64_t)1);i<=(int64_t)300;i+=(int64_t)1) {
L155 :;
        size += (int64_t)33554432;
        if ((size < (int64_t)8589934592)) {
            mlib_allocupper[(i)] = (uint64_t)(size);
            mlib_maxmemory = (uint64_t)(size);
        } else {
            mlib_maxalloccode = (i - (int64_t)1);
            goto L157 ;
        };
L156 :;
    }L157 :;
    ;
    mlib_pcm_setup = (uint64_t)((int64_t)1);
}

int64_t mlib_pcm_getac(int64_t size) {
    if ((size <= (int64_t)2048)) {
        return (int64_t)(mlib_sizeindextable[(size)]);
    };
    size = ((size + (int64_t)255) >> (int64_t)8);
    if ((size <= (int64_t)2048)) {
        return ((int64_t)((uint64_t)(mlib_sizeindextable[(size)])) + (int64_t)8);
    };
    size = ((size + (int64_t)63) >> (int64_t)6);
    if ((size <= (int64_t)2048)) {
        return ((int64_t)((uint64_t)(mlib_sizeindextable[(size)])) + (int64_t)14);
    };
    size = ((((size - (int64_t)2048) + (int64_t)2047) / (int64_t)2048) + (int64_t)22);
    return size;
}

void * mlib_pcm_newblock(int64_t itemsize) {
    static int64_t totalheapsize;
    byte *  p;
    totalheapsize += (int64_t)2097152;
    mlib_alloccode = (int64_t)0;
    p = (byte *)(mlib_allocmem((int64_t)2097152));
    if ((p == 0)) {
        mlib_abortprogram((uint8_t*)"Can't alloc pc heap");
    };
    mlib_pcheapptr = p;
    mlib_pcheapend = (p + (int64_t)2097152);
    if ((mlib_pcheapstart == 0)) {
        mlib_pcheapstart = p;
    };
    mlib_pcheapptr += itemsize;
    return (void *)((uint32_t *)(p));
}

int64_t mlib_pcm_round(int64_t n) {
    static int32_t allocbytes[9] = {(int32_t)0,(int32_t)16,(int32_t)32,(int32_t)64,(int32_t)128,(int32_t)256,(int32_t)512,(int32_t)1024,(int32_t)2048};
    if ((n > (int64_t)2048)) {
        return n;
    } else {
        return (int64_t)(allocbytes[((int64_t)(mlib_sizeindextable[(n)]))]);
    };
}

int64_t mlib_pcm_array(int64_t n) {
    int64_t m;
    if ((n <= (int64_t)2048)) {
        return mlib_pcm_round(n);
    } else {
        m = (int64_t)2048;
        L158 :;
        while ((n > m)) {
            m <<= (int64_t)1;
L159 :;
        }L160 :;
        ;
        return m;
    };
}

void mlib_pcm_printfreelist(int64_t size,uint64_t * p) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Size: ",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L161 :;
    while (!!(p)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_ptr(p,(uint8_t*)"h");
        msysnewc_m_print_end();
        ;
        p = (uint64_t *)((int64_t)((*p)));
L162 :;
    }L163 :;
    ;
    puts((int8_t *)((uint8_t*)""));
}

void mlib_pcm_diags(uint8_t * caption) {
    int64_t m;
    int64_t i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"HEAP FREELISTS:",NULL);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    m = (int64_t)16;
    L164 :;
    for (i=(int64_t)1;i<=(int64_t)8;i+=(int64_t)1) {
L165 :;
        mlib_pcm_printfreelist(m,mlib_freelist[(i)]);
        m <<= (int64_t)1;
L166 :;
    }L167 :;
    ;
}

void * mlib_pcm_allocz(int64_t n) {
    void *  p;
    p = mlib_pcm_alloc(n);
    memset(p,(int64_t)0,(uint64_t)(n));
    return p;
}

uint8_t * mlib_pcm_copyheapstring(uint8_t * s) {
    uint8_t *  q;
    int64_t n;
    if ((s == 0)) {
        return (uint8_t *)(0);
    };
    n = ((int64_t)(strlen((int8_t *)(s))) + (int64_t)1);
    q = (uint8_t *)(mlib_pcm_alloc(n));
    memcpy((void *)(q),(void *)(s),(uint64_t)(n));
    return q;
}

uint8_t * mlib_pcm_copyheapstringn(uint8_t * s,int64_t n) {
    uint8_t *  q;
    if ((s == 0)) {
        return (uint8_t *)(0);
    };
    q = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
    memcpy((void *)(q),(void *)(s),(uint64_t)(n));
    (*(q + n)) = (uint64_t)0u;
    return q;
}

uint8_t * mlib_pcm_copyheapblock(uint8_t * s,int64_t length) {
    uint8_t *  q;
    if ((length == (int64_t)0)) {
        return (uint8_t *)(0);
    };
    q = (uint8_t *)(mlib_pcm_alloc(length));
    memcpy((void *)(q),(void *)(s),(uint64_t)(length));
    return q;
}

static void mlib_addtomemalloc(int32_t * ptr,int64_t size) {
    int64_t i;
    L168 :;
    for (i=(int64_t)1;i<=(int64_t)500000;i+=(int64_t)1) {
L169 :;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"ALLOC ERROR:",NULL);
            msysnewc_m_print_ptr(ptr,NULL);
            msysnewc_m_print_str((uint8_t*)"ALREADY ALLOCATED\n\n\n",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            exit((int64_t)2);
        };
        if ((mlib_memalloctable[(i)-1] == 0)) {
            mlib_memalloctable[(i)-1] = ptr;
            mlib_memallocsize[(i)-1] = size;
            return;
        };
L170 :;
    }L171 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"MEMALLOCTABLE FULL\n\n\n\n",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    oslinux_os_getch();
    exit((int64_t)3);
}

static void mlib_removefrommemalloc(int32_t * ptr,int64_t size) {
    int64_t i;
    L172 :;
    for (i=(int64_t)1;i<=(int64_t)500000;i+=(int64_t)1) {
L173 :;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            if (((int64_t)(mlib_memallocsize[(i)-1]) != size)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"REMOVE:FOUND",NULL);
                msysnewc_m_print_ptr(ptr,NULL);
                msysnewc_m_print_str((uint8_t*)"IN MEMALLOCTABLE, FREESIZE=",NULL);
                msysnewc_m_print_i64(size,NULL);
                msysnewc_m_print_str((uint8_t*)", BUT STORED AS BLOCK SIZE:",NULL);
                msysnewc_m_print_i64(mlib_memallocsize[(i)-1],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                mlib_abortprogram((uint8_t*)"MEMSIZE");
            };
            mlib_memalloctable[(i)-1] = (int32_t *)(0);
            return;
        };
L174 :;
    }L175 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"CAN'T FIND",NULL);
    msysnewc_m_print_ptr(ptr,NULL);
    msysnewc_m_print_str((uint8_t*)"IN MEMALLOCTABLE",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"MEM");
    exit((int64_t)4);
}

void * mlib_allocmem(int64_t n) {
    void *  p;
    p = malloc((uint64_t)(n));
    if (!!(p)) {
        return p;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_i64(mlib_memtotal,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"Alloc mem failure");
    return 0;
}

void * mlib_reallocmem(void * p,int64_t n) {
    p = realloc(p,(uint64_t)(n));
    if (!!(p)) {
        return p;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"Realloc mem failure");
    return 0;
}

void mlib_abortprogram(uint8_t * s) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(s,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"ABORTING: Press key...",NULL);
    msysnewc_m_print_end();
    ;
    exit((int64_t)5);
}

int64_t mlib_getfilesize(void * handlex) {
    uint32_t p;
    uint32_t size;
    p = (uint64_t)(ftell(handlex));
    fseek(handlex,(int64_t)0,(int64_t)2);
    size = (uint64_t)(ftell(handlex));
    fseek(handlex,(int64_t)((int32_t)(p)),(int64_t)0);
    return (int64_t)(size);
}

void mlib_readrandom(void * handlex,byte * mem,int64_t offset,int64_t size) {
    int64_t a;
    fseek(handlex,(int64_t)((int32_t)(offset)),(int64_t)0);
    a = (int64_t)(fread((void *)(mem),(uint64_t)((int64_t)1),(uint64_t)(size),handlex));
}

int64_t mlib_writerandom(void * handlex,byte * mem,int64_t offset,int64_t size) {
    fseek(handlex,(int64_t)((int32_t)(offset)),(int64_t)0);
    return (int64_t)(fwrite((void *)(mem),(uint64_t)((int64_t)1),(uint64_t)(size),handlex));
}

int64_t mlib_setfilepos(void * file,int64_t offset) {
    return (int64_t)(fseek(file,(int64_t)((int32_t)(offset)),(int64_t)0));
}

int64_t mlib_getfilepos(void * file) {
    return (int64_t)(ftell(file));
}

byte * mlib_readfile(uint8_t * filename) {
    void *  f;
    int64_t size;
    byte *  m;
    byte *  p;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"rb"));
    if ((f == 0)) {
        return (byte *)(0);
    };
    mlib_rfsize = (size = mlib_getfilesize(f));
    m = (byte *)(malloc((uint64_t)((size + (int64_t)4))));
    if ((m == 0)) {
        return (byte *)(0);
    };
    mlib_readrandom(f,m,(int64_t)0,size);
    p = (m + size);
    (*p) = (uint64_t)((int64_t)0);
    (*(p + (int64_t)1)) = (uint64_t)((int64_t)26);
    (*(p + (int64_t)2)) = (uint64_t)((int64_t)0);
    fclose(f);
    return m;
}

int64_t mlib_writefile(uint8_t * filename,byte * data,int64_t size) {
    void *  f;
    int64_t n;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"wb"));
    if ((f == 0)) {
        return (int64_t)0;
    };
    n = mlib_writerandom(f,data,(int64_t)0,size);
    fclose(f);
    return n;
}

int64_t mlib_checkfile(uint8_t * file) {
    void *  f;
    if (!!((f = fopen((int8_t *)(file),(int8_t *)((uint8_t*)"rb"))))) {
        fclose(f);
        return (int64_t)1;
    };
    return (int64_t)0;
}

void mlib_readlinen(void * handlex,uint8_t * buffer,int64_t size) {
    int64_t ch;
    uint8_t *  p;
    int64_t n;
    byte crseen;
    if ((handlex == 0)) {
        handlex = oslinux_os_getstdin();
    };
    if ((handlex == 0)) {
        n = (int64_t)0;
        p = buffer;
        L176 :;
        while (1) {
            ch = (int64_t)(getchar());
            if ((((ch == (int64_t)13) || (ch == (int64_t)10)) || (ch == (int64_t)-1))) {
                (*p) = (uint64_t)0u;
                return;
            };
            (*p++) = (uint64_t)(ch);
            ++n;
            if ((n >= (size - (int64_t)2))) {
                (*p) = (uint64_t)0u;
                return;
            };
        }L177 :;
        ;
    };
    (*buffer) = (uint64_t)0u;
    if ((fgets((int8_t *)(buffer),(size - (int64_t)2),handlex) == 0)) {
        return;
    };
    n = (int64_t)(strlen((int8_t *)(buffer)));
    if ((n == (int64_t)0)) {
        return;
    };
    p = ((buffer + n) - (int64_t)1);
    crseen = (uint64_t)((int64_t)0);
    L178 :;
    while (((p >= buffer) && (((int64_t)((*p)) == (int64_t)13) || ((int64_t)((*p)) == (int64_t)10)))) {
        if ((((int64_t)((*p)) == (int64_t)13) || ((int64_t)((*p)) == (int64_t)10))) {
            crseen = (uint64_t)((int64_t)1);
        };
        (*p--) = (uint64_t)0u;
L179 :;
    }L180 :;
    ;
    if ((!(!!((uint64_t)(crseen))) && ((n + (int64_t)4) > size))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(size,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mlib_abortprogram((uint8_t*)"line too long");
    };
}

void mlib_iconvlcn(uint8_t * s,int64_t n) {
    int64_t av_1;
    av_1 = n;
    while (av_1-- > 0) {
L181 :;
        (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
        ++s;
L182 :;
    }L183 :;
    ;
}

void mlib_iconvucn(uint8_t * s,int64_t n) {
    int64_t av_1;
    av_1 = n;
    while (av_1-- > 0) {
L184 :;
        (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
        ++s;
L185 :;
    }L186 :;
    ;
}

void mlib_convlcstring(uint8_t * s) {
    L187 :;
    while (!!((uint64_t)((*s)))) {
        (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
        ++s;
L188 :;
    }L189 :;
    ;
}

void mlib_convucstring(uint8_t * s) {
    L190 :;
    while (!!((uint64_t)((*s)))) {
        (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
        ++s;
L191 :;
    }L192 :;
    ;
}

uint8_t * mlib_changeext(uint8_t * s,uint8_t * newext) {
    static uint8_t newfile[260];
    uint8_t newext2[32];
    uint8_t *  sext;
    int64_t n;
    strcpy((int8_t *)(&newfile[((int64_t)1)-1]),(int8_t *)(s));
    if (((int64_t)((*newext))==(int64_t)0)) {
        newext2[((int64_t)1)-1] = (uint64_t)0u;
        newext2[((int64_t)2)-1] = (uint64_t)0u;
    }else if (((int64_t)((*newext))==(int64_t)46)) {
        strcpy((int8_t *)(&newext2[((int64_t)1)-1]),(int8_t *)(newext));
    } else {
        strcpy((int8_t *)(&newext2[((int64_t)1)-1]),(int8_t *)((uint8_t*)"."));
        strcat((int8_t *)(&newext2[((int64_t)1)-1]),(int8_t *)(newext));
    };
    sext = mlib_extractext(s,(int64_t)1);
    if (((int64_t)((*sext))==(int64_t)0)) {
        strcat((int8_t *)(&newfile[((int64_t)1)-1]),(int8_t *)(&newext2[((int64_t)1)-1]));
    }else if (((int64_t)((*sext))==(int64_t)46)) {
        strcat((int8_t *)(&newfile[((int64_t)1)-1]),(int8_t *)(&newext2[((int64_t)2)-1]));
    } else {
        n = ((sext - s) - (int64_t)2);
        strcpy((int8_t *)(((&newfile[((int64_t)1)-1] + n) + (int64_t)1)),(int8_t *)(&newext2[((int64_t)1)-1]));
    };
    return &newfile[((int64_t)1)-1];
}

uint8_t * mlib_extractext(uint8_t * s,int64_t period) {
    uint8_t *  t;
    uint8_t *  u;
    t = mlib_extractfile(s);
    if (((int64_t)((*t)) == (int64_t)0)) {
        return (uint8_t*)"";
    };
    u = ((t + (int64_t)(strlen((int8_t *)(t)))) - (int64_t)1);
    L193 :;
    while ((u >= t)) {
        if (((uint64_t)((*u)) == '.')) {
            if (((int64_t)((*(u + (int64_t)1))) == (int64_t)0)) {
                return (!!(period)?(uint8_t*)".":(uint8_t*)"");
            };
            return (u + (int64_t)1);
        };
        --u;
L194 :;
    }L195 :;
    ;
    return (uint8_t*)"";
}

uint8_t * mlib_extractpath(uint8_t * s) {
    static uint8_t str[260];
    uint8_t *  t;
    int64_t n;
    t = ((s + (int64_t)(strlen((int8_t *)(s)))) - (int64_t)1);
    L196 :;
    while ((t >= s)) {
        switch ((int64_t)((*t))) {
        case 92:;
        case 47:;
        case 58:;
        {
            n = ((t - s) + (int64_t)1);
            memcpy((void *)(str),(void *)(s),(uint64_t)(n));
            str[(n)] = (uint64_t)0u;
            return str;
        }break;
        default: {
        }
        } //SW
;
        --t;
L197 :;
    }L198 :;
    ;
    return (uint8_t*)"";
}

uint8_t * mlib_extractfile(uint8_t * s) {
    uint8_t *  t;
    t = mlib_extractpath(s);
    if (((int64_t)((*t)) == (int64_t)0)) {
        return s;
    };
    return (s + (int64_t)(strlen((int8_t *)(t))));
}

uint8_t * mlib_extractbasefile(uint8_t * s) {
    static uint8_t str[100];
    uint8_t *  f;
    uint8_t *  e;
    int64_t n;
    int64_t flen;
    f = mlib_extractfile(s);
    flen = (int64_t)(strlen((int8_t *)(f)));
    if ((flen == (int64_t)0)) {
        return (uint8_t*)"";
    };
    e = mlib_extractext(f,(int64_t)0);
    if (!!((uint64_t)((*e)))) {
        n = ((flen - (int64_t)(strlen((int8_t *)(e)))) - (int64_t)1);
        memcpy((void *)(&str),(void *)(f),(uint64_t)(n));
        str[(n)] = (uint64_t)0u;
        return str;
    };
    if (((uint64_t)((*((f + flen) - (int64_t)1))) == '.')) {
        memcpy((void *)(&str),(void *)(f),(uint64_t)((flen - (int64_t)1)));
        str[((flen - (int64_t)1))] = (uint64_t)0u;
        return str;
    };
    return f;
}

uint8_t * mlib_addext(uint8_t * s,uint8_t * newext) {
    uint8_t *  sext;
    sext = mlib_extractext(s,(int64_t)1);
    if (((int64_t)((*sext)) == (int64_t)0)) {
        return mlib_changeext(s,newext);
    };
    return s;
}

void * mlib_alloctable(int64_t n,int64_t size) {
    void *  p;
    p = malloc((uint64_t)(((n + (int64_t)1) * size)));
    if (!(!!(p))) {
        mlib_abortprogram((uint8_t*)"Alloctable failure");
    };
    return p;
}

void * mlib_zalloctable(int64_t n,int64_t size) {
    int64_t *  p;
    p = (int64_t *)(mlib_alloctable(n,size));
    mlib_pcm_clearmem((void *)(p),((n + (int64_t)1) * size));
    return (void *)(p);
}

void mlib_checkfreelists(uint8_t * s) {
    uint64_t *  p;
    uint64_t *  q;
    int64_t aa;
    int64_t i;
    L199 :;
    for (i=(int64_t)2;i<=(int64_t)2;i+=(int64_t)1) {
L200 :;
        p = mlib_freelist[(i)];
        L203 :;
        while (!!(p)) {
            aa = (int64_t)(p);
            if (((aa > (int64_t)4294967295) || (aa < (int64_t)100))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(s,NULL);
                msysnewc_m_print_str((uint8_t*)"FREE LIST ERROR",NULL);
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_ptr(p,NULL);
                msysnewc_m_print_ptr(q,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            q = p;
            p = (uint64_t *)((int64_t)((*p)));
L204 :;
        }L205 :;
        ;
L201 :;
    }L202 :;
    ;
}

void * mlib_pcm_alloc32(void) {
    mlib_allocbytes = (int64_t)32;
    return mlib_pcm_alloc((int64_t)32);
}

void mlib_pcm_free32(void * p) {
    mlib_smallmemtotal -= (int64_t)32;
    if (!!((int64_t)0)) {
        mlib_removefrommemalloc((int32_t *)(p),(int64_t)32);
    };
    (*(uint64_t *)(p)) = (uint64_t)((int64_t)(mlib_freelist[((int64_t)2)]));
    mlib_freelist[((int64_t)2)] = (uint64_t *)(p);
}

void mlib_outbyte(void * f,int64_t x) {
    fwrite((void *)(&x),(uint64_t)((int64_t)1),(uint64_t)((int64_t)1),f);
}

void mlib_outword16(void * f,uint64_t x) {
    fwrite((void *)(&x),(uint64_t)((int64_t)2),(uint64_t)((int64_t)1),f);
}

void mlib_outword(void * f,uint64_t x) {
    fwrite((void *)(&x),(uint64_t)((int64_t)4),(uint64_t)((int64_t)1),f);
}

void mlib_outword64(void * f,uint64_t x) {
    fwrite((void *)(&x),(uint64_t)((int64_t)8),(uint64_t)((int64_t)1),f);
}

int64_t mlib_myeof(void * f) {
    int64_t c;
    c = (int64_t)(fgetc(f));
    if ((c == (int64_t)-1)) {
        return (int64_t)1;
    };
    ungetc((int64_t)((int32_t)(c)),f);
    return (int64_t)0;
}

void * mlib_pcm_smallallocz(int64_t n) {
    byte *  p;
    if (((mlib_alloccode = (int64_t)(mlib_sizeindextable[(n)])) == (int64_t)0)) {
        mlib_alloccode = (int64_t)1;
    };
    mlib_allocbytes = (int64_t)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        memset((void *)(p),(int64_t)0,(uint64_t)(n));
        return (void *)(p);
    };
    memset((void *)(p),(int64_t)0,(uint64_t)(n));
    return (void *)(p);
}

void * mlib_pcm_smallalloc(int64_t n) {
    byte *  p;
    if (((mlib_alloccode = (int64_t)(mlib_sizeindextable[(n)])) == (int64_t)0)) {
        mlib_alloccode = (int64_t)1;
    };
    mlib_allocbytes = (int64_t)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    };
    return (void *)(p);
}

void mlib_strbuffer_add(struct mlib_strbuffer * dest,uint8_t * s,int64_t n) {
    int64_t newlen;
    int64_t oldlen;
    uint8_t *  newptr;
    if ((n == (int64_t)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"N=0",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if ((n == (int64_t)-1)) {
        n = (int64_t)(strlen((int8_t *)(s)));
    };
    oldlen = (int64_t)((*dest).length);
    if ((oldlen == (int64_t)0)) {
        (*dest).strptr = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
        (*dest).allocated = mlib_allocbytes;
        (*dest).length = n;
        memcpy((void *)((*dest).strptr),(void *)(s),(uint64_t)(n));
        (*((*dest).strptr + n)) = (uint64_t)0u;
        return;
    };
    newlen = (oldlen + n);
    if (((newlen + (int64_t)1) > (int64_t)((*dest).allocated))) {
        newptr = (uint8_t *)(mlib_pcm_alloc((newlen + (int64_t)1)));
        memcpy((void *)(newptr),(void *)((*dest).strptr),(uint64_t)(oldlen));
        (*dest).strptr = newptr;
        (*dest).allocated = mlib_allocbytes;
    };
    memcpy((void *)(((*dest).strptr + oldlen)),(void *)(s),(uint64_t)(n));
    (*((*dest).strptr + newlen)) = (uint64_t)0u;
    (*dest).length = newlen;
}

void mlib_gs_init(struct mlib_strbuffer * dest) {
    mlib_pcm_clearmem((void *)(dest),(int64_t)16);
}

void mlib_gs_free(struct mlib_strbuffer * dest) {
    if (!!((int64_t)((*dest).allocated))) {
        mlib_pcm_free((void *)((*dest).strptr),(int64_t)((*dest).allocated));
    };
}

void mlib_gs_str(struct mlib_strbuffer * dest,uint8_t * s) {
    mlib_strbuffer_add(dest,s,(int64_t)-1);
}

void mlib_gs_char(struct mlib_strbuffer * dest,int64_t c) {
    uint8_t s[16];
    s[((int64_t)1)-1] = (uint64_t)(c);
    s[((int64_t)2)-1] = (uint64_t)0u;
    mlib_strbuffer_add(dest,s,(int64_t)1);
}

void mlib_gs_strn(struct mlib_strbuffer * dest,uint8_t * s,int64_t length) {
    mlib_strbuffer_add(dest,s,length);
}

void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s) {
    mlib_strbuffer_add(dest,(*s).strptr,(int64_t)-1);
}

void mlib_gs_strint(struct mlib_strbuffer * dest,int64_t a) {
    mlib_strbuffer_add(dest,msysnewc_strint(a,(uint8_t *)(0)),(int64_t)-1);
}

void mlib_gs_strln(struct mlib_strbuffer * dest,uint8_t * s) {
    mlib_gs_str(dest,s);
    mlib_gs_line(dest);
}

void mlib_gs_strsp(struct mlib_strbuffer * dest,uint8_t * s) {
    mlib_gs_str(dest,s);
    mlib_gs_str(dest,(uint8_t*)" ");
}

void mlib_gs_line(struct mlib_strbuffer * dest) {
    mlib_strbuffer_add(dest,(uint8_t*)"\r\n",(int64_t)-1);
}

int64_t mlib_gs_getcol(struct mlib_strbuffer * dest) {
    return (int64_t)((*dest).length);
}

void mlib_gs_leftstr(struct mlib_strbuffer * dest,uint8_t * s,int64_t w,int64_t padch) {
    int64_t col;
    int64_t i;
    int64_t n;
    int64_t slen;
    uint8_t str[2560];
    col = (int64_t)((*dest).length);
    strcpy((int8_t *)(str),(int8_t *)(s));
    slen = (int64_t)(strlen((int8_t *)(s)));
    n = (w - slen);
    if ((n > (int64_t)0)) {
        L206 :;
        for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L207 :;
            str[((slen + i))-1] = (uint64_t)(padch);
L208 :;
        }L209 :;
        ;
        str[(((slen + n) + (int64_t)1))-1] = (uint64_t)0u;
    };
    mlib_gs_str(dest,str);
}

void mlib_gs_leftint(struct mlib_strbuffer * dest,int64_t a,int64_t w,int64_t padch) {
    mlib_gs_leftstr(dest,msysnewc_strint(a,(uint8_t *)(0)),w,padch);
}

void mlib_gs_padto(struct mlib_strbuffer * dest,int64_t col,int64_t ch) {
    int64_t n;
    uint8_t str[2560];
    int64_t i;
    n = (col - (int64_t)((*dest).length));
    if ((n <= (int64_t)0)) {
        return;
    };
    L210 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L211 :;
        str[(i)-1] = (uint64_t)(ch);
L212 :;
    }L213 :;
    ;
    str[((n + (int64_t)1))-1] = (uint64_t)0u;
    mlib_gs_str(dest,str);
}

void mlib_gs_println(struct mlib_strbuffer * dest,void * f) {
    (*((*dest).strptr + (int64_t)((*dest).length))) = (uint64_t)0u;
    if ((f == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*dest).strptr,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)"\r",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((*dest).strptr,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)"\r",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

int64_t mlib_nextcmdparam(int64_t * paramno,uint8_t * * name,uint8_t * * value,uint8_t * defext) {
    static int64_t infile = (int64_t)0;
    static uint8_t *  filestart = 0;
    static uint8_t *  fileptr = 0;
    static byte colonseen = (uint8_t)0u;
    uint8_t *  q;
    uint8_t *  item;
    uint8_t *  fileext;
    int64_t length;
    static uint8_t str[300];
    //reenter:
L214 :;
;
    (*value) = (uint8_t *)(0);
    (*name) = (uint8_t *)(0);
    if (!!(infile)) {
        if ((mlib_readnextfileitem(&fileptr,&item) == (int64_t)0)) {
            free((void *)(filestart));
            infile = (int64_t)0;
            goto L214 ;
;
        };
    } else {
        if (((*paramno) > msysnewc_nsysparams)) {
            return (int64_t)0;
        };
        item = msysnewc_sysparams[((*paramno))-1];
        ++(*paramno);
        length = (int64_t)(strlen((int8_t *)(item)));
        if (((uint64_t)((*item)) == '@')) {
            filestart = (fileptr = (uint8_t *)(mlib_readfile((item + (int64_t)1))));
            if ((filestart == 0)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"Can't open",NULL);
                msysnewc_m_print_str(item,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((int64_t)7);
            };
            infile = (int64_t)1;
            goto L214 ;
;
        };
        if (((uint64_t)((*item)) == ':')) {
            colonseen = (uint64_t)((int64_t)1);
            return (int64_t)4;
        };
    };
    (*value) = (uint8_t *)(0);
    if (((uint64_t)((*item)) == '-')) {
        (*name) = (item + (!!((uint64_t)(colonseen))?(int64_t)0:(int64_t)1));
        q = (uint8_t *)(strchr((int8_t *)(item),(int64_t)58));
        if (!(!!(q))) {
            q = (uint8_t *)(strchr((int8_t *)(item),(int64_t)61));
        };
        if (!!(q)) {
            (*value) = (q + (int64_t)1);
            (*q) = (uint64_t)0u;
        };
        return (!!((uint64_t)(colonseen))?(int64_t)5:(int64_t)1);
    };
    fileext = mlib_extractext(item,(int64_t)0);
    (*name) = item;
    if (((int64_t)((*fileext)) == (int64_t)0)) {
        strcpy((int8_t *)(str),(int8_t *)((*name)));
        if ((!!(defext) && !(!!((uint64_t)(colonseen))))) {
            (*name) = mlib_addext(str,defext);
        };
    } else if (!!(mlib_eqstring(fileext,(uint8_t*)"dll"))) {
        return (!!((uint64_t)(colonseen))?(int64_t)5:(int64_t)3);
    };
    return (!!((uint64_t)(colonseen))?(int64_t)5:(int64_t)2);
}

static int64_t mlib_readnextfileitem(uint8_t * * fileptr,uint8_t * * item) {
    uint8_t *  p;
    uint8_t *  pstart;
    uint8_t *  pend;
    int64_t n;
    static uint8_t str[256];
    p = (*fileptr);
    //reenter:
L215 :;
;
    L216 :;
    while (1) {
        if (((int64_t)((*p))==(int64_t)32) || ((int64_t)((*p))==(int64_t)9) || ((int64_t)((*p))==(int64_t)13) || ((int64_t)((*p))==(int64_t)10)) {
            ++p;
        }else if (((int64_t)((*p))==(int64_t)26) || ((int64_t)((*p))==(int64_t)0)) {
            return (int64_t)0;
        } else {
            goto L217 ;
        };
    }L217 :;
    ;
    if (((int64_t)((*p))==(int64_t)33) || ((int64_t)((*p))==(int64_t)35)) {
        ++p;
        L218 :;
        if (((int64_t)((*p++))==(int64_t)10)) {
            goto L215 ;
;
        }else if (((int64_t)((*p++))==(int64_t)26) || ((int64_t)((*p++))==(int64_t)0)) {
            (*fileptr) = (p - (int64_t)1);
            return (int64_t)0;
        } else {
        }goto L218 ;
L219 :;
        ;
    };
    if (((int64_t)((*p))==(int64_t)34)) {
        pstart = ++p;
        L220 :;
        while (1) {
            if (((int64_t)((*p))==(int64_t)0) || ((int64_t)((*p))==(int64_t)26)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"Unexpected EOF in @file",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((int64_t)8);
            }else if (((int64_t)((*p))==(int64_t)34)) {
                pend = p++;
                if (((uint64_t)((*p)) == ',')) {
                    ++p;
                };
                goto L221 ;
            };
            ++p;
        }L221 :;
        ;
    } else {
        pstart = p;
        L222 :;
        while (1) {
            if (((int64_t)((*p))==(int64_t)0) || ((int64_t)((*p))==(int64_t)26)) {
                pend = p;
                goto L223 ;
            }else if (((int64_t)((*p))==(int64_t)32) || ((int64_t)((*p))==(int64_t)9) || ((int64_t)((*p))==(int64_t)44) || ((int64_t)((*p))==(int64_t)13) || ((int64_t)((*p))==(int64_t)10)) {
                pend = p++;
                goto L223 ;
            };
            ++p;
        }L223 :;
        ;
    };
    n = (pend - pstart);
    if ((n >= (int64_t)256)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"@file item too long",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((int64_t)9);
    };
    memcpy((void *)(str),(void *)(pstart),(uint64_t)(n));
    str[((n + (int64_t)1))-1] = (uint64_t)0u;
    (*item) = str;
    (*fileptr) = p;
    return (int64_t)1;
}

void mlib_ipadstr(uint8_t * s,int64_t width,uint8_t * padchar) {
    int64_t n;
    int64_t av_1;
    n = (int64_t)(strlen((int8_t *)(s)));
    av_1 = (width - n);
    while (av_1-- > 0) {
L224 :;
        strcat((int8_t *)(s),(int8_t *)(padchar));
L225 :;
    }L226 :;
    ;
}

uint8_t * mlib_padstr(uint8_t * s,int64_t width,uint8_t * padchar) {
    static uint8_t str[256];
    strcpy((int8_t *)(str),(int8_t *)(s));
    mlib_ipadstr(str,width,padchar);
    return str;
}

uint8_t * mlib_chr(int64_t c) {
    static uint8_t str[8];
    str[((int64_t)1)-1] = (uint64_t)(c);
    str[((int64_t)2)-1] = (uint64_t)0u;
    return str;
}

int64_t mlib_cmpstring(uint8_t * s,uint8_t * t) {
    int64_t res;
    if (((res = (int64_t)(strcmp((int8_t *)(s),(int8_t *)(t)))) < (int64_t)0)) {
        return (int64_t)-1;
    } else if ((res > (int64_t)0)) {
        return (int64_t)1;
    } else {
        return (int64_t)0;
    };
}

int64_t mlib_cmpstringn(uint8_t * s,uint8_t * t,int64_t n) {
    int64_t res;
    if (((res = (int64_t)(strncmp((int8_t *)(s),(int8_t *)(t),(uint64_t)(n)))) < (int64_t)0)) {
        return (int64_t)-1;
    } else if ((res > (int64_t)0)) {
        return (int64_t)1;
    } else {
        return (int64_t)0;
    };
}

int64_t mlib_eqstring(uint8_t * s,uint8_t * t) {
    return ((int64_t)(strcmp((int8_t *)(s),(int8_t *)(t))) == (int64_t)0);
}

int64_t mlib_cmpbytes(void * p,void * q,int64_t n) {
    int64_t res;
    if (((res = (int64_t)(memcmp(p,q,(uint64_t)(n)))) < (int64_t)0)) {
        return (int64_t)-1;
    } else if ((res > (int64_t)0)) {
        return (int64_t)1;
    } else {
        return (int64_t)0;
    };
}

int64_t mlib_eqbytes(void * p,void * q,int64_t n) {
    return ((int64_t)(memcmp(p,q,(uint64_t)(n))) == (int64_t)0);
}

void mlib_mseed(uint64_t a,uint64_t b) {
    mlib_seed[((int64_t)1)-1] = (int64_t)(a);
    if (!!(b)) {
        mlib_seed[((int64_t)2)-1] = (int64_t)(b);
    } else {
        mlib_seed[((int64_t)2)-1] ^= (int64_t)(a);
    };
}

uint64_t mlib_mrandom(void) {
    uint64_t x;
    uint64_t y;
    x = (uint64_t)(mlib_seed[((int64_t)1)-1]);
    y = (uint64_t)(mlib_seed[((int64_t)2)-1]);
    mlib_seed[((int64_t)1)-1] = (int64_t)(y);
    x ^= (x << (int64_t)23);
    mlib_seed[((int64_t)2)-1] = (int64_t)((((x ^ y) ^ (x >> (int64_t)17)) ^ (y >> (int64_t)26)));
    return (uint64_t)((mlib_seed[((int64_t)2)-1] + (int64_t)(y)));
}

int64_t mlib_mrandomp(void) {
    return (int64_t)((mlib_mrandom() & (uint64_t)9223372036854775807u));
}

int64_t mlib_mrandomint(int64_t n) {
    return (mlib_mrandomp() % n);
}

int64_t mlib_mrandomrange(int64_t a,int64_t b) {
    int64_t span;
    span = ((b - a) + (int64_t)1);
    if ((span <= (int64_t)0)) {
        return (int64_t)0;
    };
    return ((mlib_mrandomp() % span) + a);
}

double mlib_mrandomreal(void) {
    double x;
    L227 :;
    do {
        x = ((double)(mlib_mrandomp()) / (double)9223372036854775800.);
L228 :;
    } while (!(x != (double)1.));L229 :;
    ;
    return x;
}

double mlib_mrandomreal1(void) {
    return (double)((mlib_mrandomp() / (int64_t)((uint64_t)9223372036854775807u)));
}

byte * mlib_checkpackfile(void) {
    int64_t a;
    int64_t offset;
    uint8_t exefile[300];
    byte *  packexeptr;
    int64_t packexesize;
    uint8_t *  packfilename;
    int64_t packfilesize;
    byte *  packfileptr;
    strcpy((int8_t *)(&exefile[((int64_t)1)-1]),(int8_t *)(oslinux_os_gethostname()));
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Attempting to open",NULL);
    msysnewc_m_print_ptr(&exefile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    packexeptr = mlib_readfile(&exefile[((int64_t)1)-1]);
    if (!(!!(packexeptr))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Can't open",NULL);
        msysnewc_m_print_ptr(&exefile,NULL);
        msysnewc_m_print_ptr(&packexeptr,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    };
    packexesize = mlib_rfsize;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"File read OK. Size",NULL);
    msysnewc_m_print_i64(packexesize,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    a = (int64_t)((*(int32_t *)((packexeptr + (packexesize - (int64_t)4)))));
    if ((a != (int64_t)1262568272)) {
        free((void *)(packexeptr));
        packfileptr = (byte *)(0);
        return (byte *)(0);
    };
    offset = (int64_t)((*(int32_t *)((packexeptr + (packexesize - (int64_t)8)))));
    packfilename = (uint8_t *)((packexeptr + offset));
    offset += ((int64_t)(strlen((int8_t *)(packfilename))) + (int64_t)1);
    packfilesize = (int64_t)((*(int32_t *)((packexeptr + offset))));
    packfileptr = ((packexeptr + offset) + (int64_t)4);
    return packfileptr;
}

void oslinux_os_init(void) {
    oslinux_init_flag = (int64_t)1;
}

int64_t oslinux_os_execwait(uint8_t * cmdline,int64_t newconsole,uint8_t * workdir) {
    return (int64_t)(system((int8_t *)(cmdline)));
}

int64_t oslinux_os_execcmd(uint8_t * cmdline,int64_t newconsole) {
    return (int64_t)(system((int8_t *)(cmdline)));
}

int64_t oslinux_os_getch(void) {
    struct oslinux_termios old;
    struct oslinux_termios new;
    uint8_t ch;
    tcgetattr((int64_t)0,&old);
    new = old;
    new.c_lflag &= (int32_t)-3;
    new.c_lflag &= (int32_t)-9;
    tcsetattr((int64_t)0,(int64_t)0,&new);
    ch = (uint64_t)(getchar());
    tcsetattr((int64_t)0,(int64_t)0,&old);
    return (int64_t)(ch);
}

int64_t oslinux_os_kbhit(void) {
    mlib_abortprogram((uint8_t*)"kbhit");
    return (int64_t)0;
}

void oslinux_os_flushkeys(void) {
    mlib_abortprogram((uint8_t*)"flushkeys");
}

void * oslinux_os_getconsolein(void) {
    return 0;
}

void * oslinux_os_getconsoleout(void) {
    return 0;
}

void * oslinux_os_proginstance(void) {
    mlib_abortprogram((uint8_t*)"PROGINST");
    return 0;
}

uint64_t oslinux_os_getdllinst(uint8_t * name) {
    void *  h;
    h = dlopen(name,(int64_t)1);
    if ((h == 0)) {
        if (((int64_t)(strcmp((int8_t *)(name),(int8_t *)((uint8_t*)"msvcrt"))) == (int64_t)0)) {
            h = dlopen((uint8_t*)"libc.so.6",(int64_t)1);
        };
    };
    return (uint64_t)(h);
}

void * oslinux_os_getdllprocaddr(int64_t hlib,uint8_t * name) {
    void *  fnaddr;
    if ((hlib == (int64_t)0)) {
        return 0;
    };
    fnaddr = dlsym((void *)(hlib),name);
    return fnaddr;
}

void oslinux_os_initwindows(void) {
}

int64_t oslinux_os_getchx(void) {
    mlib_abortprogram((uint8_t*)"getchx");
    return (int64_t)0;
}

uint8_t * oslinux_os_getos(void) {
    if (((int64_t)64 == (int64_t)32)) {
        return (uint8_t*)"L32";
    } else {
        return (uint8_t*)"L64";
    };
}

int64_t oslinux_os_gethostsize(void) {
    return (int64_t)64;
}

int64_t oslinux_os_iswindows(void) {
    return (int64_t)0;
}

int64_t oslinux_os_shellexec(uint8_t * opc,uint8_t * file) {
    mlib_abortprogram((uint8_t*)"SHELL EXEC");
    return (int64_t)0;
}

void oslinux_os_sleep(int64_t a) {
    sleep((uint64_t)((uint32_t)(a)));
}

void * oslinux_os_getstdin(void) {
    return 0;
}

void * oslinux_os_getstdout(void) {
    return 0;
}

uint8_t * oslinux_os_gethostname(void) {
    return (uint8_t*)"";
}

uint8_t * oslinux_os_getmpath(void) {
    return (uint8_t*)"";
}

void oslinux_os_exitprocess(int64_t x) {
    exit(0);
}

int64_t oslinux_os_clock(void) {
    if (!!(oslinux_os_iswindows())) {
        return (int64_t)(clock());
    } else {
        return ((int64_t)(clock()) / (int64_t)1000);
    };
}

int64_t oslinux_os_getclockspersec(void) {
    return (!!(oslinux_os_iswindows())?(int64_t)1000:(int64_t)1000000);
}

void oslinux_os_setmesshandler(void * addr) {
    mlib_abortprogram((uint8_t*)"SETMESSHANDLER");
}

int64_t oslinux_os_hpcounter(void) {
    return (int64_t)1;
}

int64_t oslinux_os_hpfrequency(void) {
    return (int64_t)1;
}

int64_t oslinux_os_filelastwritetime(uint8_t * filename) {
    return (int64_t)0;
}

void oslinux_os_getsystime(struct oslinux_rsystemtime * tm) {
    memset((void *)(tm),(int64_t)0,(uint64_t)((int64_t)36));
    (*tm).month = (int64_t)1;
}

void oslinux_os_peek(void) {
}

int64_t mm_support_loadsourcefile(uint8_t * filespec) {
    uint8_t *  s;
    uint8_t *  shortfile;
    if ((mm_decls_nsourcefiles > (int64_t)250)) {
        mm_support_loaderror((uint8_t*)"Too many source files",(uint8_t*)"",(uint8_t*)"");
    };
    shortfile = mlib_extractfile(filespec);
    ++mm_decls_nsourcefiles;
    mm_decls_sourcefilepaths[(mm_decls_nsourcefiles)] = mlib_pcm_copyheapstring(filespec);
    mm_decls_sourcefilenames[(mm_decls_nsourcefiles)] = mlib_pcm_copyheapstring(shortfile);
    s = (uint8_t *)(mlib_readfile(filespec));
    if (!(!!(s))) {
        mm_support_loaderror((uint8_t*)"LSF can't load ",filespec,(uint8_t*)"");
    };
    mm_decls_sourcefiletext[(mm_decls_nsourcefiles)] = s;
    if (!!(mm_decls_fwritema)) {
        mm_decls_mafiletext[(mm_decls_nsourcefiles)] = mlib_pcm_copyheapstring(s);
    };
    mm_decls_sourcefilesizes[(mm_decls_nsourcefiles)] = mlib_rfsize;
    (*(s + mlib_rfsize)) = (uint64_t)0u;
    return mm_decls_nsourcefiles;
}

int64_t mm_support_loadbuiltin(uint8_t * shortfile,uint8_t * text) {
    uint8_t str[128];
    if ((mm_decls_nsourcefiles > (int64_t)250)) {
        mm_support_loaderror((uint8_t*)"Too many source files",(uint8_t*)"",(uint8_t*)"");
    };
    ++mm_decls_nsourcefiles;
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"<Built-in: #>");
    msysnewc_m_print_str(shortfile,NULL);
    msysnewc_m_print_end();
    ;
    mm_decls_sourcefilepaths[(mm_decls_nsourcefiles)] = mlib_pcm_copyheapstring(str);
    mm_decls_sourcefilenames[(mm_decls_nsourcefiles)] = mlib_pcm_copyheapstring(shortfile);
    mm_decls_sourcefiletext[(mm_decls_nsourcefiles)] = mlib_pcm_copyheapstring(text);
    if (!!(mm_decls_fwritema)) {
        mm_decls_mafiletext[(mm_decls_nsourcefiles)] = mlib_pcm_copyheapstring(text);
    };
    mm_decls_sourcefilesizes[(mm_decls_nsourcefiles)] = (int64_t)(strlen((int8_t *)(text)));
    return mm_decls_nsourcefiles;
}

int64_t mm_support_loadbundledfile(uint8_t * filespec,int64_t support) {
    int64_t fileno;
    uint8_t *  file;
    int64_t i;
    file = mlib_extractfile(filespec);
    L230 :;
    for (i=(int64_t)1;i<=mm_decls_nmafiles;i+=(int64_t)1) {
L231 :;
        if ((!!(mlib_eqstring(file,mm_decls_mafilenames[(i)])) && (support == (int64_t)((uint64_t)(mm_decls_mafilesupport[(i)]))))) {
            fileno = (int64_t)(mm_decls_mafilefileno[(i)]);
            if (!(!!(fileno))) {
                fileno = ++mm_decls_nsourcefiles;
                mm_decls_mafilefileno[(i)] = (uint64_t)(fileno);
                mm_decls_sourcefilepaths[(mm_decls_nsourcefiles)] = mm_decls_mafilenames[(i)];
                mm_decls_sourcefilenames[(mm_decls_nsourcefiles)] = mm_decls_mafilenames[(i)];
                mm_decls_sourcefiletext[(mm_decls_nsourcefiles)] = mm_decls_mafiletext[(i)];
                mm_decls_sourcefilesizes[(mm_decls_nsourcefiles)] = mm_decls_mafilesizes[(i)];
                mm_decls_sourcefiletext[(mm_decls_nsourcefiles)] = mlib_pcm_copyheapstring(mm_decls_mafiletext[(i)]);
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"FOUND BUNDLED FILE SUBSEQ TIME",NULL);
                msysnewc_m_print_str(file,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            return fileno;
        };
L232 :;
    }L233 :;
    ;
    mm_support_loaderror((uint8_t*)"Can't find bundled file: # #",filespec,(uint8_t*)"");
    return (int64_t)0;
}

void mm_support_mcerror(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"MC Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((int64_t)1);
}

void mm_support_serror_gen(uint8_t * mess) {
    if ((!!(mm_decls_currproc) && ((int64_t)((uint64_t)((*mm_decls_currproc).nameid)) == (int64_t)5))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"In function",NULL);
        msysnewc_m_print_str((*mm_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"On line",NULL);
    msysnewc_m_print_i64(((int64_t)(mm_decls_lx.lineno) & (int64_t)16777215),NULL);
    msysnewc_m_print_str((uint8_t*)"in file",NULL);
    msysnewc_m_print_str(mm_decls_sourcefilepaths[((int64_t)(mm_decls_lx.fileno))],NULL);
    msysnewc_m_print_str(mm_decls_sourcefilenames[((int64_t)(mm_decls_lx.fileno))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"**** Syntax Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((uint8_t*)"****",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_support_stopcompiler(mm_decls_sourcefilepaths[((int64_t)(mm_decls_lx.fileno))],((int64_t)(mm_decls_lx.lineno) & (int64_t)16777215));
}

static void mm_support_stopcompiler(uint8_t * filename,int64_t lineno) {
    void *  f;
    f = fopen((int8_t *)((uint8_t*)"$error.tmp"),(int8_t *)((uint8_t*)"w"));
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str(filename,NULL);
    msysnewc_m_print_i64(lineno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    fclose(f);
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((int64_t)1);
}

void mm_support_serror(uint8_t * mess) {
    mm_support_serror_gen(mess);
}

void mm_support_serror_s(uint8_t * mess,uint8_t * a) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(a,NULL);
    msysnewc_m_print_end();
    ;
    mm_support_serror_gen(str);
}

void mm_support_error_gen(int64_t pass,uint8_t * mess,struct mm_decls_unitrec * p) {
    int64_t lineno;
    int64_t fileno;
    if (!!(p)) {
        fileno = ((int64_t)((*p).lineno) >> (int64_t)24);
        lineno = ((int64_t)((*p).lineno) & (int64_t)16777215);
    } else {
        fileno = (mm_decls_mlineno >> (int64_t)24);
        lineno = (mm_decls_mlineno & (int64_t)16777215);
    };
    if ((!!(mm_decls_currproc) && ((int64_t)((uint64_t)((*mm_decls_currproc).nameid)) == (int64_t)5))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"In function",NULL);
        msysnewc_m_print_str((*mm_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"On line",NULL);
    msysnewc_m_print_i64((lineno & (int64_t)16777215),NULL);
    msysnewc_m_print_str((uint8_t*)"in file",NULL);
    msysnewc_m_print_str(mm_decls_sourcefilepaths[(fileno)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    if ((pass==(int64_t)78)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"**** RX Name Error: ",NULL);
        msysnewc_m_print_end();
        ;
    }else if ((pass==(int64_t)84)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"**** TX Type Error: ",NULL);
        msysnewc_m_print_end();
        ;
    }else if ((pass==(int64_t)71)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"**** GX Code Gen Error: ",NULL);
        msysnewc_m_print_end();
        ;
    }else if ((pass==(int64_t)65)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"**** 'AX Code Gen Error: ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    oslinux_os_getch();
    mm_support_stopcompiler(mm_decls_sourcefilepaths[(fileno)],(lineno & (int64_t)16777215));
}

void mm_support_rxerror(uint8_t * mess,struct mm_decls_unitrec * p) {
    mm_support_error_gen((int64_t)78,mess,p);
}

void mm_support_gerror(uint8_t * mess,struct mm_decls_unitrec * p) {
    mm_support_error_gen((int64_t)71,mess,p);
}

void mm_support_axerror(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"AX error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((int64_t)1);
}

void mm_support_txerror(uint8_t * mess,struct mm_decls_unitrec * p) {
    mm_support_error_gen((int64_t)84,mess,p);
}

void mm_support_txerror_s(uint8_t * mess,uint8_t * a,struct mm_decls_unitrec * p) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(a,NULL);
    msysnewc_m_print_end();
    ;
    mm_support_error_gen((int64_t)84,str,p);
}

void mm_support_txerror_ss(uint8_t * mess,uint8_t * a,uint8_t * b) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(a,NULL);
    msysnewc_m_print_str(b,NULL);
    msysnewc_m_print_end();
    ;
    mm_support_error_gen((int64_t)84,str,(struct mm_decls_unitrec *)(0));
}

void mm_support_rxerror_s(uint8_t * mess,uint8_t * a,struct mm_decls_unitrec * p) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(a,NULL);
    msysnewc_m_print_end();
    ;
    mm_support_error_gen((int64_t)78,str,p);
}

void mm_support_gerror_s(uint8_t * mess,uint8_t * s,struct mm_decls_unitrec * p) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(s,NULL);
    msysnewc_m_print_end();
    ;
    mm_support_error_gen((int64_t)71,str,p);
}

void mm_support_lxerror_gen(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"On line",NULL);
    msysnewc_m_print_i64(mm_decls_nextlx.lineno,NULL);
    msysnewc_m_print_str((uint8_t*)"in file",NULL);
    msysnewc_m_print_str(mm_decls_sourcefilepaths[((int64_t)(mm_decls_nextlx.fileno))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"**** Lex Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((uint8_t*)"****",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_support_stopcompiler(mm_decls_sourcefilepaths[((int64_t)(mm_decls_nextlx.fileno))],(int64_t)(mm_decls_nextlx.lineno));
}

void mm_support_lxerror_s(uint8_t * mess,uint8_t * a) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(a,NULL);
    msysnewc_m_print_end();
    ;
    mm_support_lxerror_gen(str);
}

void mm_support_lxerror(uint8_t * mess) {
    mm_support_lxerror_gen(mess);
}

int64_t mm_support_testelem(byte (*p)[],int64_t n) {
    return (!!(((uint64_t)((*p)[((n >> (int64_t)3))]) & (uint64_t)(mm_support_bytemasks[((n & (int64_t)7))])))?(int64_t)1:(int64_t)0);
}

void mm_support_setelem(byte (*p)[],int64_t n) {
    (*p)[((n >> (int64_t)3))] |= mm_support_bytemasks[((n & (int64_t)7))];
}

int64_t mm_support_nextpoweroftwo(int64_t x) {
    int64_t a;
    if ((x == (int64_t)0)) {
        return (int64_t)0;
    };
    a = (int64_t)1;
    L234 :;
    while ((a < x)) {
        a <<= (int64_t)1;
L235 :;
    }L236 :;
    ;
    return a;
}

void mm_support_loaderror(uint8_t * mess,uint8_t * mess2,uint8_t * mess3) {
    uint8_t str[512];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(mess2,NULL);
    msysnewc_m_print_str(mess3,NULL);
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Load Error:",NULL);
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Stopping",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((int64_t)1);
}

void mm_support_gs_additem(struct mlib_strbuffer * dest,uint8_t * s) {
    uint8_t *  d;
    int64_t lastchar;
    int64_t nextchar;
    d = (*dest).strptr;
    if (!!((int64_t)((*dest).length))) {
        lastchar = (int64_t)((*((d + (int64_t)((*dest).length)) - (int64_t)1)));
        nextchar = (int64_t)((*s));
        if ((!!(mm_support_isalphanum(lastchar)) && !!(mm_support_isalphanum(nextchar)))) {
            mlib_strbuffer_add(dest,(uint8_t*)" ",(int64_t)-1);
        };
    };
    mlib_strbuffer_add(dest,s,(int64_t)-1);
}

void mm_support_gs_copytostr(struct mlib_strbuffer * source,uint8_t * s) {
    if (!!((int64_t)((*source).length))) {
        memcpy((void *)(s),(void *)((*source).strptr),(uint64_t)((*source).length));
        (*(s + (int64_t)((*source).length))) = (uint64_t)0u;
    } else {
        (*s) = (uint64_t)0u;
    };
}

int64_t mm_support_isalphanum(int64_t c) {
    if (((((c >= (int64_t)65) && (c <= (int64_t)90)) || ((c >= (int64_t)97) && (c <= (int64_t)122))) || ((c >= (int64_t)48) && (c <= (int64_t)57)))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

void mm_support_inittypetables(void) {
    int64_t i;
    int64_t size;
    int64_t bitsize;
    int64_t s;
    int64_t t;
    int64_t u;
    int64_t v;
    int64_t av_1;
    int64_t av_2;
    L237 :;
    for (i=(int64_t)0;i<=(int64_t)36;i+=(int64_t)1) {
L238 :;
        mm_decls_ttname[(i)] = mm_tables_stdtypenames[(i)];
        mm_decls_ttbasetype[(i)] = i;
        bitsize = (int64_t)(mm_tables_stdtypebits[(i)]);
        switch (bitsize) {
        case 0:;
        {
            size = (int64_t)0;
        }break;
        case 1:;
        case 2:;
        case 4:;
        {
            size = (int64_t)1;
        }break;
        default: {
            size = (bitsize / (int64_t)8);
        }
        } //SW
;
        mm_decls_ttsize[(i)] = size;
        mm_decls_ttbitwidth[(i)] = (uint64_t)(bitsize);
        mm_decls_ttisint[(i)] = (uint64_t)(((uint64_t)(mm_tables_stdtypecode[(i)]) == (uint64_t)73u));
        mm_decls_ttisword[(i)] = (uint64_t)(((uint64_t)(mm_tables_stdtypecode[(i)]) == (uint64_t)85u));
        if ((i==(int64_t)13) || (i==(int64_t)14) || (i==(int64_t)14)) {
            mm_decls_ttischar[(i)] = (uint64_t)((int64_t)1);
        };
        mm_decls_ttiswordchar[(i)] = ((uint64_t)(mm_decls_ttisword[(i)]) | (uint64_t)(mm_decls_ttischar[(i)]));
        if (((uint64_t)(mm_tables_stdtypecode[(i)]) == (uint64_t)82u)) {
            mm_decls_ttisreal[(i)] = (uint64_t)((int64_t)1);
        };
        mm_decls_ttisinteger[(i)] = ((uint64_t)(mm_decls_ttisint[(i)]) | (uint64_t)(mm_decls_ttiswordchar[(i)]));
        mm_decls_ttisnumeric[(i)] = ((uint64_t)(mm_decls_ttisinteger[(i)]) | (uint64_t)(mm_decls_ttisreal[(i)]));
        mm_decls_ttisshortint[(i)] = (uint64_t)((!!(mm_decls_ttisinteger[(i)]) && ((int64_t)(mm_decls_ttsize[(i)]) < (int64_t)8)));
        if ((i==(int64_t)16) || (i==(int64_t)17) || (i==(int64_t)18)) {
            mm_decls_ttisbit[(i)] = (uint64_t)((int64_t)1);
        };
        if (((i == (int64_t)19) || (i == mm_tables_trefproc))) {
            mm_decls_ttisref[(i)] = (uint64_t)((int64_t)1);
        };
        mm_decls_ttisvar[(i)] = (uint64_t)(((int64_t)((uint64_t)(mm_tables_stdtypecat[(i)])) == (int64_t)33));
        mm_decls_ttlower[(i)] = (int64_t)1;
L239 :;
    }L240 :;
    ;
    mm_decls_ttsize[((int64_t)19)] = mm_decls_targetsize;
    mm_decls_ttbitwidth[((int64_t)19)] = (uint64_t)(mm_decls_targetbits);
    mm_decls_ntypes = (int64_t)36;
    L241 :;
    for (i=(int64_t)1;i<=(int64_t)56;i+=(int64_t)1) {
L242 :;
        s = (int64_t)(mm_tables_typesetuptable[(i)-1][((int64_t)1)-1]);
        t = (int64_t)(mm_tables_typesetuptable[(i)-1][((int64_t)2)-1]);
        u = (int64_t)(mm_tables_typesetuptable[(i)-1][((int64_t)3)-1]);
        v = (int64_t)(mm_tables_typesetuptable[(i)-1][((int64_t)4)-1]);
        mm_tables_dominantmode[(s)][(t)] = (uint64_t)(u);
        mm_tables_conversionops[(s)][(t)] = (uint64_t)(v);
        if ((((v == (int64_t)4) || (v == (int64_t)5)) && ((int64_t)(mm_decls_ttsize[(s)]) == (int64_t)(mm_decls_ttsize[(t)])))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"******* WIDEN SAME SIZE??",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
L243 :;
    }L244 :;
    ;
}

void mm_support_addspecialtypes(void) {
    mm_tables_trefproc = mm_lib_createrefmode((struct mm_decls_strec *)(0),(int64_t)26,(int64_t)0);
    mm_tables_treflabel = mm_lib_createrefmode((struct mm_decls_strec *)(0),(int64_t)35,(int64_t)0);
    mm_tables_trefchar = mm_lib_createrefmode((struct mm_decls_strec *)(0),(int64_t)13,(int64_t)0);
}

static uint8_t * mm_support_findfile(uint8_t * filename) {
    static uint8_t filespec[300];
    int64_t i;
    if ((mm_decls_fverbose == (int64_t)3)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Finding",NULL);
        msysnewc_m_print_str(filename,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    L245 :;
    for (i=mm_decls_nsearchdirs;i>=(int64_t)1;i-=(int64_t)1) {
L246 :;
        strcpy((int8_t *)(filespec),(int8_t *)(mm_decls_searchdirs[(i)-1]));
        strcat((int8_t *)(filespec),(int8_t *)(filename));
        if ((mm_decls_fverbose == (int64_t)3)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"\tChecking:",NULL);
            msysnewc_m_print_str(filespec,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        if (!!(mlib_checkfile(filespec))) {
            if ((mm_decls_fverbose == (int64_t)3)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"\tFound:",NULL);
                msysnewc_m_print_str(filespec,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            return filespec;
        };
L247 :;
    }L248 :;
    ;
    return (uint8_t *)(0);
}

uint8_t * mm_support_findstdlib(uint8_t * name) {
    int64_t av_1;
    int64_t i;
    L249 :;
    for (i=(int64_t)1;i<=(int64_t)5;i+=(int64_t)1) {
L250 :;
        if (!!(mlib_eqstring(name,mm_genwx64_stdlibnames[(i)-1]))) {
            return mm_genwx64_stdlibtext[(i)-1];
        };
L251 :;
    }L252 :;
    ;
    return (uint8_t *)(0);
}

int64_t mm_support_getmainfile(uint8_t * filename) {
    if (!!(mm_decls_fbundled)) {
        return mm_support_loadbundledfile(filename,(int64_t)0);
    };
    if (!(!!(mlib_checkfile(filename)))) {
        mm_support_loaderror((uint8_t*)"Can't find main module: ##",filename,(uint8_t*)"");
    };
    return mm_support_loadsourcefile(filename);
}

int64_t mm_support_getmodulefile(uint8_t * modulename,uint8_t * ownername) {
    uint8_t filename[300];
    uint8_t *  file;
    uint8_t *  libtext;
    strcpy((int8_t *)(filename),(int8_t *)(mlib_addext(modulename,(uint8_t*)"m")));
    if (!!(mm_decls_fbundled)) {
        return mm_support_loadbundledfile(filename,(int64_t)0);
    };
    if (!!(mm_decls_dointlibs)) {
        libtext = mm_support_findstdlib(filename);
        if (!!(libtext)) {
            return mm_support_loadbuiltin(filename,libtext);
        };
    };
    file = mm_support_findfile(filename);
    if ((file == 0)) {
        mm_support_loaderror((uint8_t*)"Can't find import module: # imported in: #",modulename,ownername);
    };
    return mm_support_loadsourcefile(file);
}

int64_t mm_support_getsupportfile(uint8_t * filename) {
    uint8_t *  path;
    uint8_t *  file;
    int64_t fileno;
    if (!!(mm_decls_fbundled)) {
        return mm_support_loadbundledfile(filename,(int64_t)1);
    };
    path = mlib_extractpath(filename);
    if (((((*path) == (int64_t)92) || ((*path) == (int64_t)47)) || (((int64_t)((*path)) != (int64_t)0) && ((uint64_t)((*(path + (int64_t)1))) == ':')))) {
        file = filename;
    } else {
        file = mm_support_findfile(filename);
    };
    if (((file == 0) || !(!!(mlib_checkfile(file))))) {
        mm_support_loaderror((uint8_t*)"Can't find include file: # #",filename,(uint8_t*)"");
    };
    fileno = mm_support_loadsourcefile(file);
    mm_decls_issupportfile[(fileno)] = (uint64_t)((int64_t)1);
    return fileno;
}

void mm_support_writemafile(uint8_t * leadmodule,uint8_t * destfile) {
    uint8_t filename[256];
    void *  f;
    int64_t fileoffsets[250];
    int64_t headeroffsets[250];
    int64_t offset;
    int64_t nn;
    int64_t i;
    strcpy((int8_t *)(filename),(int8_t *)(mlib_changeext(leadmodule,(uint8_t*)"ma")));
    if (!!(destfile)) {
        strcpy((int8_t *)(filename),(int8_t *)(destfile));
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Writing MA File",NULL);
    msysnewc_m_print_str(filename,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"wb"));
    if (!(!!(f))) {
        mm_support_loaderror((uint8_t*)"Can't create ma file #",filename,(uint8_t*)"");
    };
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"mafile",NULL);
    msysnewc_m_print_i64(mm_decls_nsourcefiles,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L253 :;
    for (i=(int64_t)1;i<=mm_decls_nsourcefiles;i+=(int64_t)1) {
L254 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_i64(i,(uint8_t*)"3");
        msysnewc_m_print_str(mm_decls_sourcefilenames[(i)],(uint8_t*)"16jl");
        msysnewc_m_print_i64(mm_decls_sourcefilesizes[(i)],(uint8_t*)"7");
        msysnewc_m_print_end();
        ;
        headeroffsets[(i)-1] = (mlib_getfilepos(f) + (int64_t)1);
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((uint8_t*)"           ",NULL);
        msysnewc_m_print_u64(mm_decls_issupportfile[(i)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L255 :;
    }L256 :;
    ;
    L257 :;
    for (i=(int64_t)1;i<=mm_decls_nsourcefiles;i+=(int64_t)1) {
L258 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_setfmt((uint8_t*)"=== # #/# ===");
        msysnewc_m_print_str(mm_decls_sourcefilenames[(i)],NULL);
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_i64(mm_decls_nsourcefiles,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        offset = mlib_getfilepos(f);
        fileoffsets[(i)-1] = offset;
        nn = mlib_writerandom(f,(byte *)(mm_decls_mafiletext[(i)]),offset,mm_decls_sourcefilesizes[(i)]);
L259 :;
    }L260 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"=== end ===",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L261 :;
    for (i=(int64_t)1;i<=mm_decls_nsourcefiles;i+=(int64_t)1) {
L262 :;
        mlib_setfilepos(f,headeroffsets[(i)-1]);
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_i64(fileoffsets[(i)-1],(uint8_t*)"8");
        msysnewc_m_print_end();
        ;
L263 :;
    }L264 :;
    ;
    fclose(f);
}

void mm_support_loadmafile(void) {
    void *  f;
    uint8_t kwd[16];
    uint8_t filename[256];
    int64_t index;
    int64_t size;
    int64_t offset;
    int64_t issupport;
    int64_t i;
    f = fopen((int8_t *)(mm_decls_mafilename),(int8_t *)((uint8_t*)"rb"));
    if (!(!!(f))) {
        mm_support_loaderror((uint8_t*)"Can't open ##",mm_decls_mafilename,(uint8_t*)"");
    };
        msysnewc_m_read_fileline(f);
    ;
;
    msysnewc_readstr(kwd,(int64_t)110,(int64_t)16);
    if (!(!!(mlib_eqstring(kwd,(uint8_t*)"mafile")))) {
        mm_support_loaderror((uint8_t*)"Bad sig in ma file: # '#'",mm_decls_mafilename,kwd);
    };
        mm_decls_nmafiles = msysnewc_m_read_i64(0);
    ;
;
    L265 :;
    for (i=(int64_t)1;i<=mm_decls_nmafiles;i+=(int64_t)1) {
L266 :;
                msysnewc_m_read_fileline(f);
        ;
        index = msysnewc_m_read_i64(0);
        ;
;
        msysnewc_readstr(filename,(int64_t)110,(int64_t)256);
                size = msysnewc_m_read_i64(0);
        ;
        offset = msysnewc_m_read_i64(0);
        ;
        issupport = msysnewc_m_read_i64(0);
        ;
;
        mm_decls_mafilenames[(i)] = mlib_pcm_copyheapstring(filename);
        mm_decls_mafilesizes[(i)] = size;
        mm_decls_mafileoffsets[(i)] = offset;
        mm_decls_mafilefileno[(i)] = (uint64_t)((int64_t)0);
        mm_decls_mafilesupport[(i)] = (uint64_t)(issupport);
L267 :;
    }L268 :;
    ;
    fclose(f);
    mm_decls_mafilesource = (uint8_t *)(mlib_readfile(mm_decls_mafilename));
    if (!(!!(mm_decls_mafilesource))) {
        mm_support_loaderror((uint8_t*)"MA load?",(uint8_t*)"",(uint8_t*)"");
    };
    L269 :;
    for (i=(int64_t)1;i<=mm_decls_nmafiles;i+=(int64_t)1) {
L270 :;
        size = mm_decls_mafilesizes[(i)];
        offset = mm_decls_mafileoffsets[(i)];
        mm_decls_mafiletext[(i)] = (mm_decls_mafilesource + offset);
        (*((mm_decls_mafilesource + offset) + size)) = (uint64_t)0u;
L271 :;
    }L272 :;
    ;
}

struct mm_decls_strec * mm_lib_newstrec(void) {
    struct mm_decls_strec *  p;
    p = (struct mm_decls_strec *)(mlib_pcm_alloc((int64_t)173));
    memset((void *)(p),(int64_t)0,(uint64_t)((int64_t)173));
    (*p).lineno = (int64_t)(mm_decls_lx.lineno);
    (*p).moduleno = (uint64_t)(mm_decls_currmoduleno);
    return p;
}

void mm_lib_initqclib(void) {
    int64_t i;
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    int64_t av_4;
    int64_t av_5;
    int64_t av_6;
    int64_t av_7;
    L273 :;
    for (i=(int64_t)1;i<=(int64_t)39;i+=(int64_t)1) {
L274 :;
        mm_tables_jtagpriotable[(mm_tables_oplist[(i)-1])] = (uint64_t)(mm_tables_oppriolist[(i)-1]);
L275 :;
    }L276 :;
    ;
    L277 :;
    for (i=(int64_t)1;i<=(int64_t)31;i+=(int64_t)1) {
L278 :;
        mm_decls_exprstarterset[(mm_tables_d_exprstarterset[(i)-1])] = (uint64_t)((int64_t)1);
L279 :;
    }L280 :;
    ;
    L281 :;
    for (i=(int64_t)1;i<=(int64_t)9;i+=(int64_t)1) {
L282 :;
        mm_decls_typestarterset[(mm_tables_d_typestarterset[(i)-1])] = (uint64_t)((int64_t)1);
L283 :;
    }L284 :;
    ;
    L285 :;
    for (i=(int64_t)1;i<=(int64_t)15;i+=(int64_t)1) {
L286 :;
        mm_tables_boolunitset[((int64_t)(mm_tables_d_boolunitset[(i)-1]))] = (uint64_t)((int64_t)1);
L287 :;
    }L288 :;
    ;
    L289 :;
    for (i=(int64_t)1;i<=(int64_t)14;i+=(int64_t)1) {
L290 :;
        mm_tables_refunitset[((int64_t)(mm_tables_d_refunitset[(i)-1]))] = (uint64_t)((int64_t)1);
L291 :;
    }L292 :;
    ;
    L293 :;
    for (i=(int64_t)1;i<=(int64_t)32;i+=(int64_t)1) {
L294 :;
        mm_tables_binopset[((int64_t)(mm_tables_d_binopset[(i)-1]))] = (uint64_t)((int64_t)1);
L295 :;
    }L296 :;
    ;
    L297 :;
    for (i=(int64_t)1;i<=(int64_t)31;i+=(int64_t)1) {
L298 :;
        mm_tables_monopset[((int64_t)(mm_tables_d_monopset[(i)-1]))] = (uint64_t)((int64_t)1);
L299 :;
    }L300 :;
    ;
    mm_tables_condopset[((int64_t)36)] = (uint64_t)((int64_t)1);
    mm_tables_condopset[((int64_t)37)] = (uint64_t)((int64_t)1);
    mm_tables_condopset[((int64_t)38)] = (uint64_t)((int64_t)1);
    mm_tables_condopset[((int64_t)39)] = (uint64_t)((int64_t)1);
    mm_tables_condopset[((int64_t)41)] = (uint64_t)((int64_t)1);
    mm_tables_condopset[((int64_t)40)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)32)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)21)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)12)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)18)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)14)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)16)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)2)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)7)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)40)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)4)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)9)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)24)] = (uint64_t)((int64_t)1);
    mm_tables_exprtermset[((int64_t)29)] = (uint64_t)((int64_t)1);
}

struct mm_decls_strec * mm_lib_getduplnameptr(struct mm_decls_strec * owner,struct mm_decls_strec * symptr,int64_t id) {
    struct mm_decls_strec *  p;
    p = mm_lib_newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (uint64_t)((*symptr).namelen);
    (*p).symbol = (uint64_t)((int64_t)50);
    (*p).owner = owner;
    (*p).nameid = (uint64_t)(id);
    (*p).namecat = (uint64_t)(mm_tables_defaultnamecat[(id)]);
    if (((id == (int64_t)10) || (id == (int64_t)11))) {
    };
    (*p).nextdupl = (*symptr).nextdupl;
    (*p).firstdupl = symptr;
    (*symptr).nextdupl = p;
    return p;
}

void mm_lib_adddef(struct mm_decls_strec * owner,struct mm_decls_strec * p) {
    struct mm_decls_strec *  q;
    if (!!((q = (*p).nextdupl))) {
        if (((*q).owner == owner)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*q).name,NULL);
            msysnewc_m_print_str((uint8_t*)"in",NULL);
            msysnewc_m_print_str((*owner).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_serror((uint8_t*)"Duplicate name");
        };
    };
    if (((*owner).deflist == 0)) {
        (*owner).deflist = p;
    } else {
        (*(*owner).deflistx).nextdef = p;
    };
    (*owner).deflistx = p;
}

void mm_lib_adddef_nodupl(struct mm_decls_strec * owner,struct mm_decls_strec * p) {
    if (((*owner).deflist == 0)) {
        (*owner).deflist = p;
    } else {
        (*(*owner).deflistx).nextdef = p;
    };
    (*owner).deflistx = p;
}

struct mm_decls_unitrec * mm_lib_createname(struct mm_decls_strec * p) {
    struct mm_decls_unitrec *  u;
    u = mm_lib_allocunitrec();
    (*u).tag = (int64_t)3;
    (*u).def = p;
    return u;
}

struct mm_decls_unitrec * mm_lib_createunit0(int64_t tag) {
    struct mm_decls_unitrec *  u;
    u = mm_lib_allocunitrec();
    (*u).tag = tag;
    return u;
}

struct mm_decls_unitrec * mm_lib_createunit1(int64_t tag,struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  u;
    u = mm_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    return u;
}

struct mm_decls_unitrec * mm_lib_createunit2(int64_t tag,struct mm_decls_unitrec * p,struct mm_decls_unitrec * q) {
    struct mm_decls_unitrec *  u;
    u = mm_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    return u;
}

struct mm_decls_unitrec * mm_lib_createunit3(int64_t tag,struct mm_decls_unitrec * p,struct mm_decls_unitrec * q,struct mm_decls_unitrec * r) {
    struct mm_decls_unitrec *  u;
    u = mm_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    (*u).c = r;
    return u;
}

void mm_lib_insertunit(struct mm_decls_unitrec * p,int64_t tag) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  nextunit;
    int64_t mode;
    q = mm_lib_allocunitrec();
    (*q) = (*p);
    mode = (int64_t)((*q).mode);
    nextunit = (*q).nextunit;
    (*q).nextunit = (struct mm_decls_unitrec *)(0);
    memset((void *)(p),(int64_t)0,(uint64_t)((int64_t)104));
    (*p).tag = tag;
    (*p).lineno = (int64_t)((*q).lineno);
    (*p).a = q;
    (*p).mode = mode;
    (*p).nextunit = nextunit;
}

void mm_lib_deleteunit(struct mm_decls_unitrec * p,struct mm_decls_unitrec * q) {
    struct mm_decls_unitrec *  r;
    r = (*p).nextunit;
    (*p) = (*q);
    (*p).nextunit = r;
}

struct mm_decls_unitrec * mm_lib_createconstunit(uint64_t a,int64_t t) {
    struct mm_decls_unitrec *  u;
    u = mm_lib_allocunitrec();
    (*u).tag = (int64_t)1;
    (*u).value = (int64_t)(a);
    (*u).mode = t;
    (*u).isconst = (int64_t)1;
    return u;
}

struct mm_decls_unitrec * mm_lib_createstringconstunit(uint8_t * s,int64_t length) {
    struct mm_decls_unitrec *  u;
    u = mm_lib_allocunitrec();
    (*u).tag = (int64_t)1;
    (*u).svalue = s;
    (*u).mode = mm_tables_trefchar;
    (*u).isastring = (int64_t)1;
    if ((length == (int64_t)-1)) {
        (*u).slength = (int64_t)(strlen((int8_t *)(s)));
    } else {
        (*u).slength = length;
    };
    return u;
}

int64_t mm_lib_getoptocode(int64_t opc) {
    static int16_t opctotable[253];
    int64_t opcto;
    int64_t i;
    uint8_t str[20];
    int64_t av_1;
    opcto = (int64_t)(opctotable[(opc)]);
    if (!!(opcto)) {
        return opcto;
    };
    strcpy((int8_t *)(str),(int8_t *)(mm_tables_jtagnames[(opc)]));
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)"to"));
    L301 :;
    for (i=(int64_t)0;i<=(int64_t)252;i+=(int64_t)1) {
L302 :;
        if (!!(mlib_eqstring(mm_tables_jtagnames[(i)],str))) {
            opctotable[(opc)] = i;
            return i;
        };
L303 :;
    }L304 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(mm_tables_jtagnames[(opc)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_support_serror((uint8_t*)"Can't find -to version");
    return (int64_t)0;
}

int64_t mm_lib_createtype(struct mm_decls_strec * d) {
    if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)4)) {
        return (int64_t)((*d).mode);
    };
    return mm_lib_createusertype(d);
}

int64_t mm_lib_createusertype(struct mm_decls_strec * stname) {
    if ((mm_decls_ntypes >= (int64_t)40000)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(mm_decls_ntypes,NULL);
        msysnewc_m_print_str((*stname).name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_serror((uint8_t*)"Too many types");
    };
    ++mm_decls_ntypes;
    mm_decls_ttname[(mm_decls_ntypes)] = (*stname).name;
    mm_decls_ttnamedef[(mm_decls_ntypes)] = stname;
    mm_decls_ttbasetype[(mm_decls_ntypes)] = (int64_t)0;
    mm_decls_ttlineno[(mm_decls_ntypes)] = (int64_t)(mm_decls_lx.lineno);
    (*stname).mode = mm_decls_ntypes;
    return mm_decls_ntypes;
}

int64_t mm_lib_createusertypefromstr(uint8_t * name) {
    struct mm_decls_strec *  stname;
    stname = mm_lib_getduplnameptr(mm_decls_stmodule,mm_lex_addnamestr(name),(int64_t)4);
    mm_lib_adddef((!!(mm_decls_stmodule)?mm_decls_stmodule:mm_decls_stprogram),stname);
    return mm_lib_createusertype(stname);
}

int64_t mm_lib_getconstvalue(struct mm_decls_unitrec * p,int64_t id) {
    if ((!!(p) && ((int64_t)((*p).tag) == (int64_t)1))) {
        return (*p).value;
    };
    mm_support_serror((uint8_t*)"GCV Not constant");
    return (int64_t)0;
}

struct mm_decls_unitrec * mm_lib_getrangelwbunit(struct mm_decls_unitrec * p) {
    if (((int64_t)((*p).tag) == (int64_t)20)) {
        return (*p).a;
    } else {
        return mm_lib_createunit1((int64_t)133,p);
    };
}

struct mm_decls_unitrec * mm_lib_getrangeupbunit(struct mm_decls_unitrec * p) {
    if (((int64_t)((*p).tag) == (int64_t)20)) {
        return (*p).b;
    } else {
        return mm_lib_createunit1((int64_t)134,p);
    };
}

int64_t mm_lib_createarraymode(struct mm_decls_strec * owner,int64_t target,struct mm_decls_unitrec * dimexpr,int64_t typedefx) {
    int64_t atype;
    int64_t m;
    atype = (int64_t)24;
    if ((typedefx == (int64_t)0)) {
        m = mm_lib_createusertypefromstr(mm_lib_nextautotype());
    } else {
        m = typedefx;
    };
    mm_decls_ttbasetype[(m)] = atype;
    mm_decls_ttlower[(m)] = (int64_t)1;
    mm_decls_ttdimexpr[(m)] = dimexpr;
    mm_lib_storemode((int64_t)101,owner,target,&mm_decls_tttarget[(m)]);
    mm_decls_ttowner[(m)] = owner;
    return m;
}

int64_t mm_lib_createarraymodek(struct mm_decls_strec * owner,int64_t target,int64_t lower,int64_t length,int64_t typedefx) {
    int64_t atype;
    int64_t m;
    atype = (int64_t)24;
    if ((typedefx == (int64_t)0)) {
        m = mm_lib_createusertypefromstr(mm_lib_nextautotype());
    } else {
        m = typedefx;
    };
    mm_decls_ttbasetype[(m)] = atype;
    mm_decls_ttlower[(m)] = lower;
    mm_decls_ttlength[(m)] = length;
    if ((target < (int64_t)0)) {
        mm_support_serror((uint8_t*)"CREATEARRAYMODEK/TARGET NOT RESOLVED");
    };
    mm_decls_ttsize[(m)] = (length * (int64_t)(mm_decls_ttsize[(target)]));
    mm_lib_storemode((int64_t)101,owner,target,&mm_decls_tttarget[(m)]);
    mm_decls_ttowner[(m)] = owner;
    return m;
}

uint8_t * mm_lib_nextautotype(void) {
    static uint8_t str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((!!(mm_decls_ctarget)?(uint8_t*)"_T$":(uint8_t*)"$T"),NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(++mm_lib_autotypeno,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

void mm_lib_converttoslice(int64_t t,int64_t sltype) {
    mm_decls_ttbasetype[(t)] = sltype;
    mm_decls_ttsize[(t)] = (int64_t)(mm_decls_ttsize[((int64_t)23)]);
}

int64_t mm_lib_createslicemode(struct mm_decls_strec * owner,int64_t target,struct mm_decls_unitrec * dimexpr,int64_t typedefx) {
    int64_t m;
    if ((typedefx == (int64_t)0)) {
        m = mm_lib_createusertypefromstr(mm_lib_nextautotype());
    } else {
        m = typedefx;
    };
    mm_decls_ttbasetype[(m)] = (int64_t)23;
    if (!!(dimexpr)) {
        mm_decls_ttdimexpr[(m)] = dimexpr;
    } else {
        mm_decls_ttlower[(m)] = (int64_t)1;
    };
    mm_lib_storemode((int64_t)178,owner,target,&mm_decls_tttarget[(m)]);
    mm_decls_ttowner[(m)] = owner;
    return m;
}

int64_t mm_lib_createslicemodek(struct mm_decls_strec * owner,int64_t target,int64_t lower,int64_t typedefx) {
    int64_t m;
    if ((typedefx == (int64_t)0)) {
        m = mm_lib_createusertypefromstr(mm_lib_nextautotype());
    } else {
        m = typedefx;
    };
    mm_decls_ttbasetype[(m)] = (int64_t)23;
    mm_decls_ttlower[(m)] = lower;
    mm_decls_tttarget[(m)] = target;
    mm_decls_ttowner[(m)] = owner;
    return m;
}

int64_t mm_lib_createstringmode(int64_t t,int64_t length,int64_t typedefx) {
    int64_t k;
    int64_t m;
    if ((typedefx == (int64_t)0)) {
        L305 :;
        for (k=(int64_t)37;k<=mm_decls_ntypes;k+=(int64_t)1) {
L306 :;
            if (((((int64_t)((uint64_t)(mm_decls_ttusercat[(k)])) == (int64_t)0) && ((int64_t)(mm_decls_ttbasetype[(k)]) == t)) && ((int64_t)(mm_decls_ttlength[(k)]) == length))) {
                return k;
            };
L307 :;
        }L308 :;
        ;
        m = mm_lib_createusertypefromstr(mm_lib_nextautotype());
    } else {
        m = typedefx;
    };
    mm_decls_ttbasetype[(m)] = t;
    mm_decls_ttlower[(m)] = ((t == mm_tables_trefchar)?(int64_t)1:(int64_t)0);
    mm_decls_ttsize[(m)] = length;
    mm_decls_ttlength[(m)] = length;
    return m;
}

int64_t mm_lib_createrefmode(struct mm_decls_strec * owner,int64_t target,int64_t typedefx) {
    int64_t k;
    int64_t m;
    if ((typedefx == (int64_t)0)) {
        L309 :;
        for (k=(int64_t)37;k<=mm_decls_ntypes;k+=(int64_t)1) {
L310 :;
            if (((((int64_t)((uint64_t)(mm_decls_ttusercat[(k)])) == (int64_t)0) && ((int64_t)(mm_decls_ttbasetype[(k)]) == (int64_t)19)) && ((int64_t)(mm_decls_tttarget[(k)]) == target))) {
                return k;
            };
L311 :;
        }L312 :;
        ;
        m = mm_lib_createusertypefromstr(mm_lib_nextautotype());
    } else {
        m = typedefx;
    };
    mm_lib_storemode((int64_t)102,owner,target,&mm_decls_tttarget[(m)]);
    mm_decls_ttbasetype[(m)] = (int64_t)19;
    mm_decls_ttsize[(m)] = (int64_t)(mm_decls_ttsize[((int64_t)19)]);
    mm_decls_ttisref[(m)] = (uint64_t)((int64_t)1);
    return m;
}

int64_t mm_lib_createrefprocmode(struct mm_decls_strec * owner,struct mm_decls_strec * stproc,struct mm_decls_strec * paramlist,int64_t kwd,int64_t prettype,int64_t typedefx) {
    int64_t m;
    int64_t mproc;
    mproc = mm_lib_createusertype(stproc);
    (*stproc).paramlist = paramlist;
    (*stproc).mode = prettype;
    mm_decls_ttbasetype[(mproc)] = (int64_t)26;
    if ((typedefx == (int64_t)0)) {
        m = mm_lib_createusertypefromstr(mm_lib_nextautotype());
    } else {
        m = typedefx;
    };
    mm_lib_storemode((int64_t)103,owner,mproc,&mm_decls_tttarget[(m)]);
    mm_decls_ttbasetype[(m)] = (int64_t)19;
    mm_decls_ttsize[(m)] = (int64_t)(mm_decls_ttsize[((int64_t)19)]);
    mm_decls_ttisref[(m)] = (uint64_t)((int64_t)1);
    return m;
}

void mm_lib_setnameptr(struct mm_decls_unitrec * p) {
    (*(*p).def).code = p;
}

uint8_t * mm_lib_getdottedname(struct mm_decls_strec * p) {
    static uint8_t str[256];
    uint8_t str2[256];
    struct mm_decls_strec *  owner;
    strcpy((int8_t *)(str),(int8_t *)((*p).name));
    owner = (*p).owner;
    L313 :;
    while ((!!(owner) && ((int64_t)((uint64_t)((*owner).nameid)) != (int64_t)1))) {
        strcpy((int8_t *)(str2),(int8_t *)(str));
        strcpy((int8_t *)(str),(int8_t *)((*owner).name));
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)"."));
        strcat((int8_t *)(str),(int8_t *)(str2));
        owner = (*owner).owner;
L314 :;
    }L315 :;
    ;
    return str;
}

struct mm_decls_strec * mm_lib_getavname(struct mm_decls_strec * owner,int64_t id) {
    struct mm_decls_strec *  p;
    uint8_t str[32];
    uint8_t *  name;
    if (((id == (int64_t)10) && ((int64_t)((uint64_t)((*owner).nameid)) != (int64_t)5))) {
        mm_support_serror((uint8_t*)"Auto frame not in proc");
    };
    if ((id == (int64_t)10)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((!!(mm_decls_ctarget)?(uint8_t*)"av_":(uint8_t*)"av$"),NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(++mm_lib_nextavindex,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((!!(mm_decls_ctarget)?(uint8_t*)"sv_":(uint8_t*)"sv$"),NULL);
        msysnewc_m_print_i64(++mm_lib_nextsvindex,NULL);
        msysnewc_m_print_end();
        ;
    };
    name = mlib_pcm_copyheapstring(str);
    mm_lex_addnamestr(name);
    p = mm_lib_getduplnameptr(owner,mm_lex_addnamestr(name),id);
    (*p).namecat = (uint64_t)((int64_t)7);
    (*p).used = (uint64_t)((int64_t)1);
    (*p).mode = (int64_t)4;
    mm_lib_adddef(owner,p);
    return p;
}

void mm_lib_unionstr_clear(struct mm_decls_uflagsrec * u) {
    (*(uint64_t *)(u)) = (uint64_t)((int64_t)0);
}

void mm_lib_unionstr_append(struct mm_decls_uflagsrec * u,int64_t c) {
    if (((int64_t)((uint64_t)((*u).ulength)) == (int64_t)6)) {
        mm_support_serror((uint8_t*)"Uflags overflow/a");
    };
    ++(*u).ulength;
    (*u).codes[((int64_t)((*u).ulength))-1] = (uint64_t)(c);
}

void mm_lib_unionstr_concat(struct mm_decls_uflagsrec * u,struct mm_decls_uflagsrec * v) {
    int64_t ulen;
    int64_t vlen;
    int64_t i;
    ulen = (int64_t)((*u).ulength);
    vlen = (int64_t)((*v).ulength);
    if (((ulen + vlen) > (int64_t)7)) {
        mm_support_serror((uint8_t*)"Uflags overflow/c");
    };
    L316 :;
    for (i=(int64_t)1;i<=vlen;i+=(int64_t)1) {
L317 :;
        (*u).codes[((i + ulen))-1] = (uint64_t)((*v).codes[(i)-1]);
L318 :;
    }L319 :;
    ;
    (*u).ulength = (uint64_t)((ulen + vlen));
}

int64_t mm_lib_unionstr_last(struct mm_decls_uflagsrec * u) {
    if (!!((uint64_t)((*u).ulength))) {
        return (int64_t)((*u).codes[((int64_t)((*u).ulength))-1]);
    };
    return (int64_t)0;
}

void mm_lib_unionstr_copy(struct mm_decls_uflagsrec * u,struct mm_decls_uflagsrec * v) {
    memcpy((void *)(u),(void *)(v),(uint64_t)((int64_t)8));
}

void mm_lib_unionstr_print(struct mm_decls_uflagsrec * u) {
    mm_lex_printstrn((uint8_t *)(&(*u).codes),(int64_t)((*u).ulength));
}

int64_t mm_lib_createrecordmode(struct mm_decls_strec * owner,int64_t typedefx) {
    int64_t m;
    if ((typedefx == (int64_t)0)) {
        m = mm_lib_createusertype(owner);
    } else {
        m = typedefx;
    };
    mm_decls_ttbasetype[(m)] = (int64_t)25;
    mm_decls_ttusercat[(m)] = (uint64_t)((int64_t)1);
    return m;
}

void mm_lib_convertstring(uint8_t * s,uint8_t * t) {
    int64_t c;
    L320 :;
    while (!!((c = (int64_t)((*s++))))) {
        switch (c) {
        case 34:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = '"';
        }break;
        case 10:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = 'n';
        }break;
        case 13:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = 'c';
        }break;
        case 9:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = 't';
        }break;
        case 92:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = (uint64_t)92u;
        }break;
        case 7:;
        case 8:;
        case 26:;
        case 27:;
        {
            (*t++) = '<';
            (*t++) = (uint64_t)(((c / (int64_t)10) + (int64_t)48));
            (*t++) = (uint64_t)(((c % (int64_t)10) + (int64_t)48));
            (*t++) = '>';
        }break;
        default: {
            (*t++) = (uint64_t)(c);
        }
        } //SW
;
L321 :;
    }L322 :;
    ;
    (*t) = (uint64_t)0u;
}

struct mlib_strbuffer * mm_lib_strexpr(struct mm_decls_unitrec * p) {
    mlib_gs_init(mm_lib_exprstr);
    mm_lib_jeval(mm_lib_exprstr,p);
    return mm_lib_exprstr;
}

static void mm_lib_jeval(struct mlib_strbuffer * dest,struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    uint8_t str[500];
    if ((p == 0)) {
        return;
    };
    a = (*p).a;
    b = (*p).b;
    switch ((int64_t)((*p).tag)) {
    case 1:;
    {
        if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)3) || ((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)4) || ((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)1) || ((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)2)) {
            msysnewc_getstrint((*p).value,str);
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)8) || ((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)9) || ((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)6) || ((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)7)) {
            strcpy((int8_t *)(str),(int8_t *)(msysnewc_strword((*p).uvalue,(uint8_t *)(0))));
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)13) || ((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)14) || ((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)15)) {
            str[((int64_t)1)-1] = (uint64_t)((*p).uvalue);
            str[((int64_t)0)-1] = (uint64_t)0u;
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)5)) {
//            msysnewc_m_print_startstr(str);
//            msysnewc_m_print_i128((*(*p).pvalue128),NULL);
//            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)10)) {
//            msysnewc_m_print_startstr(str);
//            msysnewc_m_print_u128((*(*p).puvalue128),NULL);
//            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)12)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_r64((*p).xvalue,NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)19)) {
            if ((((int64_t)((*p).mode) == mm_tables_trefchar) && !!((int64_t)((*p).isastring)))) {
                if (((int64_t)((*p).slength) > (int64_t)250)) {
                    strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"LONGSTR)"));
                } else {
                    mm_lib_convertstring((*p).svalue,str);
                };
                mm_support_gs_additem(dest,(uint8_t*)"\"");
                mm_support_gs_additem(dest,str);
                mm_support_gs_additem(dest,(uint8_t*)"\"");
                return;
            } else {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_ptr((void *)((*p).value),NULL);
                msysnewc_m_print_end();
                ;
            };
        } else {
            sprintf((int8_t *)(str),(int8_t *)((uint8_t*)"<EVAL/CONST PROBABLY VOID>"));
        };
        mm_support_gs_additem(dest,str);
    }break;
    case 3:;
    {
        mm_support_gs_additem(dest,(*(*p).def).name);
    }break;
    case 12:;
    case 13:;
    case 35:;
    case 36:;
    case 37:;
    case 38:;
    case 39:;
    case 40:;
    case 41:;
    case 43:;
    case 44:;
    case 45:;
    case 46:;
    case 47:;
    case 48:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    case 60:;
    case 61:;
    case 62:;
    case 63:;
    case 64:;
    case 65:;
    case 97:;
    case 98:;
    case 14:;
    case 42:;
    case 49:;
    case 66:;
    {
        strcpy((int8_t *)(str),(int8_t *)(mm_lib_getopcjname((int64_t)((*p).tag))));
        mm_support_gs_additem(dest,(uint8_t*)"(");
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,str);
        mm_lib_jeval(dest,b);
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 109:;
    case 110:;
    case 111:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    case 125:;
    case 126:;
    case 127:;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    case 132:;
    case 133:;
    case 134:;
    case 135:;
    case 138:;
    case 139:;
    case 143:;
    case 144:;
    case 113:;
    case 112:;
    case 136:;
    case 15:;
    case 16:;
    {
        strcpy((int8_t *)(str),(int8_t *)(mm_lib_getopcjname((int64_t)((*p).tag))));
        mm_support_gs_additem(dest,str);
        mm_support_gs_additem(dest,(uint8_t*)"(");
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 31:;
    case 201:;
    case 32:;
    {
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)"(");
        q = b;
        L323 :;
        while (!!(q)) {
            mm_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                mm_support_gs_additem(dest,(uint8_t*)",");
            };
L324 :;
        }L325 :;
        ;
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 88:;
    case 90:;
    case 89:;
    case 91:;
    {
        mm_lib_jeval(dest,a);
        if ((((int64_t)((*p).tag) == (int64_t)90) || ((int64_t)((*p).tag) == (int64_t)91))) {
            mm_support_gs_additem(dest,(uint8_t*)".");
        };
        mm_support_gs_additem(dest,(uint8_t*)"[");
        mm_lib_jeval(dest,b);
        mm_support_gs_additem(dest,(uint8_t*)"]");
    }break;
    case 95:;
    {
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)".");
        mm_lib_jeval(dest,b);
    }break;
    case 19:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"(");
        q = a;
        L326 :;
        while (!!(q)) {
            mm_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                mm_support_gs_additem(dest,(uint8_t*)",");
            };
L327 :;
        }L328 :;
        ;
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 20:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"(");
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)"..");
        mm_lib_jeval(dest,b);
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 29:;
    {
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)":=");
        mm_lib_jeval(dest,b);
    }break;
    case 209:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"(");
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)"|");
        mm_lib_jeval(dest,b);
        mm_support_gs_additem(dest,(uint8_t*)"|");
        mm_lib_jeval(dest,(*p).c);
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 106:;
    {
        mm_support_gs_additem(dest,mm_lib_strmode((int64_t)((*p).mode),(int64_t)1));
    }break;
    case 102:;
    {
        mm_support_gs_additem(dest,mm_lib_strmode((int64_t)((*p).newmode),(int64_t)1));
        mm_support_gs_additem(dest,(uint8_t*)"(");
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 104:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"cast(");
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 28:;
    {
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)":");
        if (!!(b)) {
            mm_lib_jeval(dest,(*p).b);
        } else {
            mlib_gs_str(dest,(uint8_t*)"-");
        };
    }break;
    case 99:;
    {
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)"^");
    }break;
    case 67:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"(");
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)",");
        mm_lib_jeval(dest,b);
        mm_support_gs_additem(dest,(uint8_t*)",");
        mm_lib_jeval(dest,(*p).c);
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 4:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"<JBLOCK>");
    }break;
    case 2:;
    {
        mlib_gs_str(dest,(uint8_t*)"<nullunit>");
    }break;
    case 100:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"&");
        mm_lib_jeval(dest,a);
    }break;
    case 101:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"&.");
        mm_lib_jeval(dest,a);
    }break;
    case 103:;
    {
        mlib_gs_str(dest,(uint8_t*)"CONVERTREF<>");
    }break;
    case 141:;
    {
        mm_support_gs_additem(dest,(uint8_t*)"TYPESTR(");
        mm_lib_jeval(dest,a);
        mm_support_gs_additem(dest,(uint8_t*)")");
    }break;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 78:;
    case 68:;
    case 69:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    {
        mlib_gs_str(dest,(mm_tables_jtagnames[((int64_t)((*p).tag))] + (int64_t)2));
        mlib_gs_str(dest,(uint8_t*)"(");
        mm_lib_jeval(dest,a);
        if (((int64_t)((*p).tag)==(int64_t)74) || ((int64_t)((*p).tag)==(int64_t)75) || ((int64_t)((*p).tag)==(int64_t)84) || ((int64_t)((*p).tag)==(int64_t)83) || ((int64_t)((*p).tag)==(int64_t)68) || ((int64_t)((*p).tag)==(int64_t)69)) {
            mlib_gs_str(dest,(uint8_t*)",");
            mm_lib_jeval(dest,b);
        };
        mlib_gs_str(dest,(uint8_t*)")");
    }break;
    case 185:;
    case 188:;
    case 187:;
    {
        mlib_gs_str(dest,(uint8_t*)"$");
        mlib_gs_str(dest,(mm_tables_jtagnames[((int64_t)((*p).tag))] + (int64_t)2));
    }break;
    case 142:;
    {
        mm_lib_jeval(dest,a);
        mlib_gs_str(dest,(uint8_t*)".");
        mlib_gs_str(dest,mm_tables_bitfieldnames[((int64_t)((*p).opcode))-1]);
    }break;
    case 199:;
    {
        mm_lib_jeval(dest,a);
        mlib_gs_str(dest,(uint8_t*)":");
        mm_lib_jeval(dest,b);
    }break;
    case 140:;
    {
        mlib_gs_str(dest,(uint8_t*)"typeof(");
        mm_lib_jeval(dest,a);
        mlib_gs_str(dest,(uint8_t*)")");
    }break;
    case 204:;
    {
        mlib_gs_str(dest,(mm_tables_sysfnnames[((int64_t)((*p).opcode))-1] + (int64_t)6));
        mlib_gs_str(dest,(uint8_t*)"(");
        if (!!(a)) {
            mm_lib_jeval(dest,a);
        };
        mlib_gs_str(dest,(uint8_t*)")");
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"CAN'T DO JEVAL",p);
    }
    } //SW
;
}

uint8_t * mm_lib_getopcjname(int64_t opc) {
    int64_t i;
    int64_t av_1;
    L329 :;
    for (i=(int64_t)1;i<=(int64_t)46;i+=(int64_t)1) {
L330 :;
        if ((opc == mm_lib_opc_codes[(i)-1])) {
            return mm_lib_opc_names[(i)-1];
        };
L331 :;
    }L332 :;
    ;
    return (mm_tables_jtagnames[(opc)] + (int64_t)2);
}

uint8_t * mm_lib_strmode(int64_t m,int64_t expand) {
    static uint8_t str[4096];
    mm_lib_istrmode(m,expand,str);
    return str;
}

uint8_t * mm_lib_strmode2(int64_t m,int64_t expand) {
    static uint8_t str[4096];
    mm_lib_istrmode(m,expand,str);
    return str;
}

void mm_lib_istrmode(int64_t m,int64_t expand,uint8_t * dest) {
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  q;
    int64_t needcomma;
    int64_t target;
    int64_t mbase;
    struct mlib_strbuffer sxx;
    struct mlib_strbuffer *  xx;
    uint8_t strdim[100];
    uint8_t *  prefix;
    xx = &sxx;
    if ((m < (int64_t)0)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"*"));
        strcat((int8_t *)(dest),(int8_t *)((*mm_decls_ttnamedefx[(-(m))]).name));
        if (!!(mm_decls_ttnamedefx2[(-(m))])) {
            strcat((int8_t *)(dest),(int8_t *)((uint8_t*)"."));
            strcat((int8_t *)(dest),(int8_t *)((*mm_decls_ttnamedefx2[(-(m))]).name));
        };
        return;
    };
    if (((m < (int64_t)37) && (m != (int64_t)19))) {
        strcpy((int8_t *)(dest),(int8_t *)(mm_lib_typename(m)));
        return;
    };
    if (((mbase = (int64_t)(mm_decls_ttbasetype[(m)]))==(int64_t)19)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"ref "));
        target = (int64_t)(mm_decls_tttarget[(m)]);
        if (((target >= (int64_t)0) && ((int64_t)(mm_decls_ttbasetype[(target)]) == (int64_t)25))) {
            strcat((int8_t *)(dest),(int8_t *)(mm_lib_typename(target)));
        } else {
            mm_lib_istrmode((int64_t)(mm_decls_tttarget[(m)]),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
        };
    }else if (((mbase = (int64_t)(mm_decls_ttbasetype[(m)]))==(int64_t)24)) {
        if (!!(mm_decls_ttdimexpr[(m)])) {
            mm_support_gs_copytostr(mm_lib_strexpr(mm_decls_ttdimexpr[(m)]),strdim);
            msysnewc_m_print_startstr(dest);
            msysnewc_m_print_setfmt((uint8_t*)"@[#]");
            msysnewc_m_print_str(strdim,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            if (((int64_t)(mm_decls_ttlower[(m)]) == (int64_t)1)) {
                msysnewc_m_print_startstr(dest);
                msysnewc_m_print_setfmt((uint8_t*)"[#]");
                msysnewc_m_print_i64((((int64_t)(mm_decls_ttlength[(m)]) + (int64_t)(mm_decls_ttlower[(m)])) - (int64_t)1),NULL);
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startstr(dest);
                msysnewc_m_print_setfmt((uint8_t*)"[#..#]");
                msysnewc_m_print_i64(mm_decls_ttlower[(m)],NULL);
                msysnewc_m_print_i64((((int64_t)(mm_decls_ttlength[(m)]) + (int64_t)(mm_decls_ttlower[(m)])) - (int64_t)1),NULL);
                msysnewc_m_print_end();
                ;
            };
        };
        mm_lib_istrmode((int64_t)(mm_decls_tttarget[(m)]),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
    }else if (((mbase = (int64_t)(mm_decls_ttbasetype[(m)]))==(int64_t)23)) {
        prefix = ((mbase != (int64_t)23)?(uint8_t*)"":mm_tables_stdtypenames[(mbase)]);
        if (!!(mm_decls_ttdimexpr[(m)])) {
            mm_support_gs_copytostr(mm_lib_strexpr(mm_decls_ttdimexpr[(m)]),strdim);
            msysnewc_m_print_startstr(dest);
            msysnewc_m_print_setfmt((uint8_t*)"@slice[#:]");
            msysnewc_m_print_str(strdim,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            if (((int64_t)(mm_decls_ttlower[(m)]) == (int64_t)1)) {
                strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"slice[]"));
            } else {
                msysnewc_m_print_startstr(dest);
                msysnewc_m_print_setfmt((uint8_t*)"slice[#:]");
                msysnewc_m_print_i64(mm_decls_ttlower[(m)],NULL);
                msysnewc_m_print_end();
                ;
            };
        };
        mm_lib_istrmode((int64_t)(mm_decls_tttarget[(m)]),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
    }else if (((mbase = (int64_t)(mm_decls_ttbasetype[(m)]))==(int64_t)25)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)""));
        if (!(!!(expand))) {
            strcpy((int8_t *)(dest),(int8_t *)(mm_lib_typename(m)));
            return;
        };
        strcat((int8_t *)(dest),(int8_t *)(mm_lib_typename((int64_t)(mm_decls_ttbasetype[(m)]))));
        strcat((int8_t *)(dest),(int8_t *)((uint8_t*)"("));
        d = mm_decls_ttnamedef[(m)];
        needcomma = (int64_t)0;
        q = (*d).deflist;
        L333 :;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat((int8_t *)(dest),(int8_t *)((uint8_t*)","));
            };
            needcomma = (int64_t)1;
            mm_lib_istrmode((int64_t)((*q).mode),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
            strcat((int8_t *)(dest),(int8_t *)((uint8_t*)" "));
            strcat((int8_t *)(dest),(int8_t *)((*q).name));
            q = (*q).nextdef;
L334 :;
        }L335 :;
        ;
        strcat((int8_t *)(dest),(int8_t *)((uint8_t*)")"));
    }else if (((mbase = (int64_t)(mm_decls_ttbasetype[(m)]))==(int64_t)0)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"void"));
    }else if (((mbase = (int64_t)(mm_decls_ttbasetype[(m)]))==(int64_t)37)) {
        strcpy((int8_t *)(dest),(int8_t *)(mm_lib_typename(m)));
    }else if (((mbase = (int64_t)(mm_decls_ttbasetype[(m)]))==(int64_t)26)) {
        d = mm_decls_ttnamedef[(m)];
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"proc("));
        q = (*d).paramlist;
        needcomma = (int64_t)0;
        L336 :;
        while ((q != 0)) {
            if (!!(needcomma)) {
                strcat((int8_t *)(dest),(int8_t *)((uint8_t*)","));
            };
            needcomma = (int64_t)1;
            mm_lib_istrmode((int64_t)((*q).mode),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
            strcat((int8_t *)(dest),(int8_t *)((uint8_t*)" "));
            strcat((int8_t *)(dest),(int8_t *)((*q).name));
            q = (*q).nextdef;
L337 :;
        }L338 :;
        ;
        strcat((int8_t *)(dest),(int8_t *)((uint8_t*)")"));
        if (((int64_t)((*d).mode) != (int64_t)0)) {
            mm_lib_istrmode((int64_t)((*d).mode),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
        };
    }else if (((mbase = (int64_t)(mm_decls_ttbasetype[(m)]))==(int64_t)21)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"bitfield"));
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_lib_typename(m),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_mcerror((uint8_t*)"NEWSTRMODE");
    };
}

int64_t mm_lib_countunits(struct mm_decls_unitrec * p) {
    int64_t n;
    n = (int64_t)0;
    L339 :;
    while (!!(p)) {
        ++n;
        p = (*p).nextunit;
L340 :;
    }L341 :;
    ;
    return n;
}

struct mm_decls_strec * mm_lib_finddefstr(struct mm_decls_strec * owner,uint8_t * name) {
    struct mm_decls_strec *  d;
    d = (*owner).deflist;
    L342 :;
    while (!!(d)) {
        if (!!(mlib_eqstring((*d).name,name))) {
            return d;
        };
        d = (*d).nextdef;
L343 :;
    }L344 :;
    ;
    return (struct mm_decls_strec *)(0);
}

void mm_lib_addtoproclist(struct mm_decls_strec * d) {
    struct mm_decls_procrec *  pp;
    ++mm_decls_nproclist;
    pp = (struct mm_decls_procrec *)(mlib_pcm_alloc((int64_t)16));
    (*pp).nextproc = mm_decls_proclist;
    mm_decls_proclist = pp;
    (*pp).def = d;
}

void mm_lib_addstatic(struct mm_decls_strec * d) {
    struct mm_decls_procrec *  pp;
    ++mm_decls_nstaticlist;
    pp = (struct mm_decls_procrec *)(mlib_pcm_alloc((int64_t)16));
    (*pp).nextproc = mm_decls_staticlist;
    mm_decls_staticlist = pp;
    (*pp).def = d;
}

int64_t mm_lib_newusertypex(struct mm_decls_strec * d,struct mm_decls_strec * e) {
    if ((mm_decls_nuserxtypes >= (int64_t)4000)) {
        mm_support_serror((uint8_t*)"Too many external user types");
    };
    ++mm_decls_nuserxtypes;
    mm_decls_ttnamedefx[(mm_decls_nuserxtypes)] = d;
    mm_decls_ttnamedefx2[(mm_decls_nuserxtypes)] = e;
    mm_decls_ttxmoduleno[(mm_decls_nuserxtypes)] = (uint64_t)(mm_decls_currmoduleno);
    mm_decls_ttlinenox[(mm_decls_nuserxtypes)] = ((int64_t)(mm_decls_lx.lineno) & (int64_t)16777215);
    return -(mm_decls_nuserxtypes);
}

uint8_t * mm_lib_typename(int64_t m) {
    if ((m >= (int64_t)0)) {
        return mm_decls_ttname[(m)];
    };
    return (*mm_decls_ttnamedefx[(-(m))]).name;
}

struct mm_decls_unitrec * mm_lib_allocunitrec(void) {
    struct mm_decls_unitrec *  p;
    ++mm_decls_nunits;
    if (!!(mm_lib_remainingunits--)) {
        p = mm_lib_unitheapptr;
        ++mm_lib_unitheapptr;
        (*p).lineno = (int64_t)(mm_decls_lx.lineno);
        (*p).moduleno = mm_decls_currmoduleno;
        return p;
    };
    p = (mm_lib_unitheapptr = (struct mm_decls_unitrec *)(mlib_pcm_alloc((int64_t)5200000)));
    memset((void *)(p),(int64_t)0,(uint64_t)((int64_t)5200000));
    mm_lib_remainingunits = (int64_t)49999;
    ++mm_lib_unitheapptr;
    (*p).lineno = (int64_t)(mm_decls_lx.lineno);
    (*p).moduleno = mm_decls_currmoduleno;
    return p;
}

struct mm_decls_strec * mm_lib_createdupldef(struct mm_decls_strec * owner,struct mm_decls_strec * symptr,int64_t id) {
    struct mm_decls_strec *  p;
    p = mm_lib_newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (uint64_t)((*symptr).namelen);
    (*p).symbol = (uint64_t)((int64_t)50);
    (*p).owner = owner;
    (*p).nameid = (uint64_t)(id);
    (*p).nextdupl = (*symptr).nextdupl;
    (*symptr).nextdupl = p;
    if (!!(owner)) {
        if (((*owner).deflist == 0)) {
            (*owner).deflist = ((*owner).deflistx = p);
        } else {
            (*(*owner).deflistx).nextdef = p;
            (*owner).deflistx = p;
        };
    };
    return p;
}

struct mm_decls_strec * mm_lib_createnewmoduledef(struct mm_decls_strec * owner,struct mm_decls_strec * symptr) {
    struct mm_decls_strec *  p;
    p = mm_lib_createdupldef(owner,symptr,(int64_t)2);
    return p;
}

void mm_lib_storemode(int64_t id,struct mm_decls_strec * owner,int64_t m,int32_t * p) {
    struct mm_decls_userxrec *  q;
    (*p) = m;
    if ((m >= (int64_t)0)) {
        return;
    };
    q = (struct mm_decls_userxrec *)(mlib_pcm_alloc((int64_t)24));
    (*q).owner = owner;
    if ((owner == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"ID=",NULL);
        msysnewc_m_print_i64(id,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_serror((uint8_t*)"STOREMODE/OWNER=0");
    };
    (*q).pmode = p;
    (*q).nextmode = mm_decls_userxmodelist;
    mm_decls_userxmodelist = q;
}

struct mm_decls_unitrec * mm_lib_duplunit(struct mm_decls_unitrec * p,int64_t lineno) {
    struct mm_decls_unitrec *  q;
    if ((p == 0)) {
        return (struct mm_decls_unitrec *)(0);
    };
    q = mm_lib_createunit0((int64_t)((*p).tag));
    (*q).a = mm_lib_duplunit((*p).a,lineno);
    (*q).b = mm_lib_duplunit((*p).b,lineno);
    (*q).c = mm_lib_duplunit((*p).c,lineno);
    (*q).lineno = (!!(lineno)?lineno:(int64_t)((*p).lineno));
    (*q).value = (*p).value;
    (*q).opcode = (int64_t)((*p).opcode);
    (*q).mode = (int64_t)((*p).mode);
    (*q).moduleno = (int64_t)((*p).moduleno);
    (*q).isastring = (int64_t)((*p).isastring);
    return q;
}

int64_t mm_lib_iscallbackfn(struct mm_decls_strec * p) {
    return ((int64_t)((uint64_t)((*p).fflang)) == (int64_t)4);
}

int64_t mm_lib_isstringconst(struct mm_decls_unitrec * p) {
    int64_t m;
    int64_t target;
    m = (int64_t)((*p).mode);
    if ((((int64_t)((*p).tag) == (int64_t)1) && ((int64_t)(mm_decls_ttbasetype[(m)]) == (int64_t)19))) {
        target = (int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[(m)]))]);
        if (((target == (int64_t)13) || !!((int64_t)((*p).slength)))) {
            return (int64_t)1;
        };
    };
    return (int64_t)0;
}

int64_t mm_lib_checkblockreturn(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  e;
    struct mm_decls_unitrec *  wt;
    int64_t m;
    if ((p == 0)) {
        return (int64_t)0;
    };
    m = (int64_t)((*p).mode);
    if (((int64_t)((*p).tag)==(int64_t)203)) {
        return (int64_t)1;
    }else if (((int64_t)((*p).tag)==(int64_t)243)) {
        return (int64_t)1;
    }else if (((int64_t)((*p).tag)==(int64_t)209)) {
        (*p).ifretflag = (int64_t)1;
        return (!!(mm_lib_checkblockreturn((*p).b)) && !!(mm_lib_checkblockreturn((*p).c)));
    }else if (((int64_t)((*p).tag)==(int64_t)210)) {
        e = (*p).a;
        (*p).ifretflag = (int64_t)1;
        L345 :;
        while (!!(e)) {
            if (!(!!(mm_lib_checkblockreturn((*e).b)))) {
                return (int64_t)0;
            };
            e = (*e).nextunit;
L346 :;
        }L347 :;
        ;
        return mm_lib_checkblockreturn((*p).b);
    }else if (((int64_t)((*p).tag)==(int64_t)4)) {
        e = (*p).a;
        if (!!(e)) {
            L348 :;
            while ((!!(e) && !!((*e).nextunit))) {
                e = (*e).nextunit;
L349 :;
            }L350 :;
            ;
            return mm_lib_checkblockreturn(e);
        };
    }else if (((int64_t)((*p).tag)==(int64_t)224) || ((int64_t)((*p).tag)==(int64_t)226) || ((int64_t)((*p).tag)==(int64_t)225) || ((int64_t)((*p).tag)==(int64_t)227)) {
        (*p).ifretflag = (int64_t)1;
        wt = (*p).b;
        L351 :;
        while (!!(wt)) {
            if (!(!!(mm_lib_checkblockreturn((*wt).b)))) {
                return (int64_t)0;
            };
            wt = (*wt).nextunit;
L352 :;
        }L353 :;
        ;
        return mm_lib_checkblockreturn((*p).c);
    }else if (((int64_t)((*p).tag)==(int64_t)7)) {
        return (int64_t)1;
    };
    if ((!!((uint64_t)(mm_tables_jisexpr[((int64_t)((*p).tag))])) && (m != (int64_t)0))) {
        if (!!(mm_decls_ctarget)) {
            mm_lib_insertunit(p,(int64_t)203);
            (*p).mode = m;
        };
        return (int64_t)1;
    } else {
        return (int64_t)0;
    };
}

int64_t mm_lib_isconstint(struct mm_decls_unitrec * a) {
    if ((!!((int64_t)((*a).isconst)) && !!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

int64_t mm_lib_isconstunit(struct mm_decls_unitrec * a) {
    return (int64_t)((*a).isconst);
}

uint8_t * mm_lib_faststrint(int64_t a) {
    static uint8_t smallints[1999][8];
    if ((((int64_t)-999 <= a) && (a <= (int64_t)999))) {
        if (((int64_t)(smallints[(a)+999][((int64_t)1)-1]) == (int64_t)0)) {
            msysnewc_getstrint(a,smallints[(a)+999]);
        };
        return smallints[(a)+999];
    };
    return msysnewc_strint(a,(uint8_t *)(0));
}

uint8_t * mm_lib_getfullname(struct mm_decls_strec * d,int64_t fromassem) {
    static uint8_t str[256];
    if ((!(!!(fromassem)) && (mm_decls_fvarnames != (int64_t)2))) {
        if (((int64_t)((*d).nameid)==(int64_t)10) || ((int64_t)((*d).nameid)==(int64_t)11)) {
            if (!!(mm_decls_fvarnames)) {
                mm_lib_framevarname = (*d).name;
            };
            return mm_lib_faststrint((int64_t)((*d).offset));
        };
    };
    if (!!((uint64_t)(mm_tables_qualifiedname[((int64_t)((*d).namecat))]))) {
        str[((int64_t)1)-1] = (uint64_t)0u;
        mm_lib_getownername(d,str);
        strcat((int8_t *)(str),(int8_t *)((*d).name));
        return str;
    } else if (((int64_t)((uint64_t)((*d).namecat)) == (int64_t)3)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"`",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((!!((*d).truename)?(*d).truename:(*d).name),NULL);
        msysnewc_m_print_end();
        ;
        return str;
    } else {
        return (*d).name;
    };
}

void mm_lib_getownername(struct mm_decls_strec * d,uint8_t * dest) {
    struct mm_decls_strec *  owner;
    owner = (*d).owner;
    if (((owner == 0) || ((int64_t)((uint64_t)((*owner).nameid)) == (int64_t)1))) {
        return;
    };
    mm_lib_getownername(owner,dest);
    strcat((int8_t *)(dest),(int8_t *)((*owner).name));
    strcat((int8_t *)(dest),(int8_t *)((uint8_t*)"."));
}

int64_t mm_lib_isnumericmode(int64_t m) {
    return (int64_t)(mm_decls_ttisnumeric[(m)]);
}

int64_t mm_lib_isrefmode(int64_t m) {
    return (int64_t)(mm_decls_ttisref[(m)]);
}

uint8_t * mm_lib_strconstopnd(struct mm_decls_unitrec * p) {
    static uint8_t str[256];
    int64_t a;
    int64_t t;
    float x32;
    t = (int64_t)((*p).mode);
    a = (*p).value;
    if ((t == mm_tables_trefchar)) {
        if (((int64_t)((*p).slength) >= (int64_t)256)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"\"",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)"(LONGSTR)",NULL);
            msysnewc_m_print_str((uint8_t*)"\" *",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*p).slength,NULL);
            msysnewc_m_print_end();
            ;
        } else if (!!((int64_t)((*p).slength))) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"\"",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((*p).svalue,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)"\" *",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*p).slength,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"\"\"",NULL);
            msysnewc_m_print_end();
            ;
        };
    } else {
        if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)1)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_i64((int8_t)(a),NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)2)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_i64((int16_t)(a),NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)3)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_i64((int32_t)(a),NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)4)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_i64(a,NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)6)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_u64((byte)(a),NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)7)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_u64((uint16_t)(a),NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)8)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_u64((uint32_t)(a),NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)9)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_u64((uint64_t)(a),NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)13) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)14) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)15)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"C64",NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)11)) {
            x32 = (float)((*p).xvalue);
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_r64((double)(x32),NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)12)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_r64((*p).xvalue,NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)5)) {
//            msysnewc_m_print_startstr(str);
//            msysnewc_m_print_i128((*(*p).pvalue128),NULL);
//            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)10)) {
//            msysnewc_m_print_startstr(str);
//            msysnewc_m_print_u128((*(*p).puvalue128),NULL);
//            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)19)) {
            if (!!((*p).value)) {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_str((uint8_t*)"#",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).value,NULL);
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_str((uint8_t*)"NIL",NULL);
                msysnewc_m_print_end();
                ;
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_lib_typename(t),NULL);
            msysnewc_m_print_str(mm_lib_typename((int64_t)(mm_decls_ttbasetype[(t)])),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_gerror((uint8_t*)"STROPND CONST?",(struct mm_decls_unitrec *)(0));
        };
    };
    return str;
}

int64_t mm_lib_gettypecat_t(int64_t m) {
    return (int64_t)(mm_tables_stdtypecat[((int64_t)(mm_decls_ttbasetype[(m)]))]);
}

int64_t mm_lib_getalignment(int64_t m) {
    int64_t a;
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)24)) {
        return mm_lib_getalignment((int64_t)(mm_decls_tttarget[(m)]));
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)25)) {
        return (int64_t)16;
    };
    a = (int64_t)(mm_decls_ttsize[(m)]);
    if ((a==(int64_t)1) || (a==(int64_t)2) || (a==(int64_t)4) || (a==(int64_t)8) || (a==(int64_t)16)) {
        return a;
    }else if ((a==(int64_t)0)) {
        return (int64_t)8;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(mm_lib_strmode(m,(int64_t)1),NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_support_gerror((uint8_t*)"GETALIGN SIZE NOT 1248",(struct mm_decls_unitrec *)(0));
    return (int64_t)0;
}

int64_t mm_lib_ispoweroftwo(int64_t x) {
    int64_t a;
    int64_t n;
    int64_t av_1;
    a = (int64_t)1;
    n = (int64_t)0;
    av_1 = (int64_t)30;
    while (av_1-- > 0) {
L354 :;
        ++n;
        a = (a << (int64_t)1);
        if ((a == x)) {
            return n;
        };
L355 :;
    }L356 :;
    ;
    return (int64_t)0;
}

void mm_lib_addlistunit(struct mm_decls_unitrec * * ulist,struct mm_decls_unitrec * * ulistx,struct mm_decls_unitrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextunit = p;
    };
    (*ulistx) = p;
}

int64_t mm_lib_issimpletype(int64_t m) {
    if (!!((uint64_t)(mm_decls_ttisvar[(m)]))) {
        return (int64_t)0;
    };
    return (int64_t)1;
}

int64_t mm_lib_getpacktype(int64_t m) {
    int64_t target;
    int64_t mbase;
    struct mm_decls_strec *  d;
    if ((m == mm_tables_trefchar)) {
        return (int64_t)18;
    };
    target = (int64_t)(mm_decls_tttarget[(m)]);
    mbase = (int64_t)(mm_decls_ttbasetype[(m)]);
    if ((mbase <= (int64_t)12)) {
        if ((mbase==(int64_t)4)) {
            return (int64_t)1;
        }else if ((mbase==(int64_t)9)) {
            return (int64_t)2;
        }else if ((mbase==(int64_t)12)) {
            return (int64_t)3;
        }else if ((mbase==(int64_t)0)) {
            return (int64_t)0;
        } else {
            mm_support_gerror((uint8_t*)"getpacktype1",(struct mm_decls_unitrec *)(0));
        };
    } else if (!!((uint64_t)(mm_decls_ttisref[(m)]))) {
        if ((target>=(int64_t)0 && target<=(int64_t)12)) {
            return ((int64_t)4 + (target - (int64_t)0));
        };
        d = mm_decls_ttnamedef[(target)];
        if ((!!(d) && !!(mlib_eqstring((*d).name,(uint8_t*)"varrec")))) {
            return (int64_t)19;
        };
    };
    return (int64_t)0;
}

uint64_t mm_lib_getlow128(i128 * a) {
    return (*(uint64_t *)(a));
}

uint64_t mm_lib_gethigh128(i128 * a) {
    return (*((uint64_t *)(a) + (int64_t)1));
}

void mm_lib_putlow128(i128 * a,uint64_t x) {
    (*(uint64_t *)(a)) = x;
}

void mm_lib_puthigh128(i128 * a,uint64_t x) {
    (*((uint64_t *)(a) + (int64_t)1)) = x;
}

void mm_lex_lexreadtoken(void) {
    int64_t c;
    int64_t hsum;
    int64_t commentseen;
    mm_decls_nextlx.subcode = (uint64_t)((int64_t)0);
    L357 :;
    switch ((int64_t)((*mm_lex_lxsptr++))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
    {
        mm_decls_nextlx.svalue = (mm_lex_lxsptr - (int64_t)1);
        //doname:
L359 :;
;
        hsum = (int64_t)((*mm_decls_nextlx.svalue));
        mm_decls_nextlx.hashvalue = (int64_t)0;
        L360 :;
        switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        {
            (*(mm_lex_lxsptr - (int64_t)1)) = (uint64_t)((c + (int64_t)32));
            hsum = ((((hsum << (int64_t)4) - hsum) + c) + (int64_t)32);
        }break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 95:;
        case 36:;
        {
            hsum = (((hsum << (int64_t)4) - hsum) + c);
        }break;
        case 34:;
        {
            --mm_lex_lxsptr;
            if (((mm_decls_nextlx.svalue + (int64_t)1) == mm_lex_lxsptr)) {
                if (((int64_t)((*mm_decls_nextlx.svalue))==(int64_t)70) || ((int64_t)((*mm_decls_nextlx.svalue))==(int64_t)102) || ((int64_t)((*mm_decls_nextlx.svalue))==(int64_t)82) || ((int64_t)((*mm_decls_nextlx.svalue))==(int64_t)114)) {
                    mm_lex_readrawstring();
                    return;
                }else if (((int64_t)((*mm_decls_nextlx.svalue))==(int64_t)65) || ((int64_t)((*mm_decls_nextlx.svalue))==(int64_t)97) || ((int64_t)((*mm_decls_nextlx.svalue))==(int64_t)90) || ((int64_t)((*mm_decls_nextlx.svalue))==(int64_t)122)) {
                    mm_lex_readarraystring((int64_t)((*mm_decls_nextlx.svalue)));
                    return;
                };
            };
            goto L361 ;
        }break;
        default: {
            --mm_lex_lxsptr;
            goto L361 ;
        }
        } //SW
goto L360 ;
L361 :;
        ;
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)37);
        mm_decls_nextlx.length = (mm_lex_lxsptr - mm_decls_nextlx.svalue);
        mm_decls_nextlx.hashvalue = ((hsum << (int64_t)5) - hsum);
        return;
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    {
        mm_decls_nextlx.svalue = (mm_lex_lxsptr - (int64_t)1);
        (*mm_decls_nextlx.svalue) += ' ';
        goto L359 ;
;
    }break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        c = (int64_t)((*(mm_lex_lxsptr - (int64_t)1)));
        if (((int64_t)((*mm_lex_lxsptr))==(int64_t)32) || ((int64_t)((*mm_lex_lxsptr))==(int64_t)41) || ((int64_t)((*mm_lex_lxsptr))==(int64_t)13) || ((int64_t)((*mm_lex_lxsptr))==(int64_t)44) || ((int64_t)((*mm_lex_lxsptr))==(int64_t)124)) {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)41);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)4);
            mm_decls_nextlx.value = (c - (int64_t)48);
        }else if (((int64_t)((*mm_lex_lxsptr))==(int64_t)120) || ((int64_t)((*mm_lex_lxsptr))==(int64_t)88)) {
            if ((c==(int64_t)48)) {
                ++mm_lex_lxsptr;
                mm_lex_readnumber((int64_t)16);
            }else if ((c==(int64_t)49)) {
                mm_support_lxerror((uint8_t*)"Bad base");
            } else {
                ++mm_lex_lxsptr;
                mm_lex_readnumber((c - (int64_t)48));
            };
        } else {
            --mm_lex_lxsptr;
            mm_lex_readdecimalnumber();
        };
        return;
    }break;
    case 33:;
    {
        //docomment:
L362 :;
;
        L363 :;
        switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
        case 13:;
        {
            ++mm_lex_lxsptr;
            goto L364 ;
        }break;
        case 10:;
        {
            goto L364 ;
        }break;
        case 26:;
        case 0:;
        {
            --mm_lex_lxsptr;
            goto L364 ;
        }break;
        default: {
        }
        } //SW
goto L363 ;
L364 :;
        ;
        ++mm_decls_nextlx.lineno;
        ++mm_decls_nalllines;
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)35);
        return;
    }break;
    case 35:;
    {
        mm_decls_nextlx.svalue = mm_lex_lxsptr;
        L365 :;
        switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
        case 13:;
        case 10:;
        case 26:;
        case 0:;
        {
            --mm_lex_lxsptr;
            goto L366 ;
        }break;
        default: {
        }
        } //SW
goto L365 ;
L366 :;
        ;
        mm_decls_nextlx.length = (mm_lex_lxsptr - mm_decls_nextlx.svalue);
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)39);
        return;
    }break;
    case 92:;
    {
        commentseen = (int64_t)0;
        L367 :;
        switch ((int64_t)((*mm_lex_lxsptr++))) {
        case 13:;
        {
            ++mm_decls_nalllines;
            ++mm_decls_nextlx.lineno;
            ++mm_lex_lxsptr;
            goto L368 ;
        }break;
        case 10:;
        {
            ++mm_decls_nalllines;
            ++mm_decls_nextlx.lineno;
            goto L368 ;
        }break;
        case 26:;
        case 0:;
        {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)36);
            --mm_lex_lxsptr;
            return;
        }break;
        case 32:;
        case 9:;
        {
        }break;
        case 33:;
        {
            commentseen = (int64_t)1;
        }break;
        default: {
            if (!(!!(commentseen))) {
                mm_support_lxerror((uint8_t*)"\\ not followed by eol");
            };
        }
        } //SW
goto L367 ;
L368 :;
        ;
        L369 :;
        switch ((int64_t)((*mm_lex_lxsptr++))) {
        case 13:;
        {
            ++mm_decls_nextlx.lineno;
            ++mm_decls_nalllines;
            ++mm_lex_lxsptr;
        }break;
        case 10:;
        {
            ++mm_decls_nalllines;
            ++mm_decls_nextlx.lineno;
        }break;
        case 32:;
        case 9:;
        {
        }break;
        default: {
            --mm_lex_lxsptr;
            goto L370 ;
        }
        } //SW
goto L369 ;
L370 :;
        ;
    }break;
    case 123:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)16);
        return;
    }break;
    case 125:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)17);
        return;
    }break;
    case 46:;
    {
        switch ((int64_t)((*mm_lex_lxsptr))) {
        case 46:;
        {
            ++mm_lex_lxsptr;
            if (((uint64_t)((*mm_lex_lxsptr)) == '.')) {
                ++mm_lex_lxsptr;
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)30);
            } else {
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)29);
                mm_decls_nextlx.subcode = (uint64_t)((int64_t)20);
            };
            return;
        }break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            --mm_lex_lxsptr;
            mm_lex_readrealnumber((uint8_t *)(0),(int64_t)0,(int64_t)10);
            return;
        }break;
        default: {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)2);
            return;
        }
        } //SW
;
    }break;
    case 44:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)5);
        return;
    }break;
    case 59:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)6);
        return;
    }break;
    case 58:;
    {
        switch ((int64_t)((*mm_lex_lxsptr))) {
        case 61:;
        {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)9);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)29);
        }break;
        case 58:;
        {
            ++mm_lex_lxsptr;
            if (((int64_t)((*mm_lex_lxsptr))==(int64_t)61)) {
                ++mm_lex_lxsptr;
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)10);
                mm_decls_nextlx.subcode = (uint64_t)((int64_t)30);
            } else {
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)8);
            };
        }break;
        default: {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)7);
        }
        } //SW
;
        return;
    }break;
    case 40:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)12);
        return;
    }break;
    case 41:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)13);
        return;
    }break;
    case 91:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)14);
        return;
    }break;
    case 93:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)15);
        return;
    }break;
    case 124:;
    {
        if (((uint64_t)((*mm_lex_lxsptr)) == '|')) {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)20);
        } else {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)19);
        };
        return;
    }break;
    case 94:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)18);
        return;
    }break;
    case 64:;
    {
        if (((uint64_t)((*mm_lex_lxsptr)) == '@')) {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)22);
        } else {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)21);
        };
        return;
    }break;
    case 63:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)23);
        return;
    }break;
    case 126:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)27);
        return;
    }break;
    case 43:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
        if (((uint64_t)((*mm_lex_lxsptr)) == '+')) {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)40);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)145);
            return;
        } else {
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)43);
        };
        return;
    }break;
    case 45:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
        if (((uint64_t)((*mm_lex_lxsptr)) == '-')) {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)40);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)146);
            return;
        } else {
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)44);
        };
        return;
    }break;
    case 42:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
        if (((uint64_t)((*mm_lex_lxsptr)) == '*')) {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)98);
        } else {
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)45);
        };
        return;
    }break;
    case 47:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
        mm_decls_nextlx.subcode = (uint64_t)((int64_t)46);
        return;
    }break;
    case 37:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
        mm_decls_nextlx.subcode = (uint64_t)((int64_t)47);
        return;
    }break;
    case 61:;
    {
        if (((int64_t)((*mm_lex_lxsptr))==(int64_t)62)) {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)11);
            ++mm_lex_lxsptr;
        }else if (((int64_t)((*mm_lex_lxsptr))==(int64_t)61)) {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)42);
            ++mm_lex_lxsptr;
        } else {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)36);
        };
        return;
    }break;
    case 60:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
        switch ((int64_t)((*mm_lex_lxsptr))) {
        case 61:;
        {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)39);
        }break;
        case 62:;
        {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)37);
        }break;
        case 60:;
        {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)53);
        }break;
        default: {
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)38);
        }
        } //SW
;
        return;
    }break;
    case 62:;
    {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
        switch ((int64_t)((*mm_lex_lxsptr))) {
        case 61:;
        {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)41);
        }break;
        case 62:;
        {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)54);
        }break;
        default: {
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)40);
        }
        } //SW
;
        return;
    }break;
    case 38:;
    {
        if (((int64_t)((*mm_lex_lxsptr))==(int64_t)38)) {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)35);
        }else if (((int64_t)((*mm_lex_lxsptr))==(int64_t)46)) {
            ++mm_lex_lxsptr;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)4);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)0);
        } else {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)24);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)100);
        };
        return;
    }break;
    case 39:;
    {
        mm_lex_lxreadstring((int64_t)39);
        return;
    }break;
    case 34:;
    {
        mm_lex_lxreadstring((int64_t)34);
        return;
    }break;
    case 96:;
    {
        mm_lex_readrawxname();
        return;
    }break;
    case 32:;
    case 9:;
    {
    }break;
    case 13:;
    {
        ++mm_lex_lxsptr;
        ++mm_decls_nextlx.lineno;
        ++mm_decls_nalllines;
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)35);
        return;
    }break;
    case 10:;
    {
        ++mm_decls_nextlx.lineno;
        ++mm_decls_nalllines;
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)35);
        return;
    }break;
    case 26:;
    case 0:;
    {
        if (!!(mm_lex_sourcelevel)) {
            mm_lex_unstacksource();
        } else {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)36);
            --mm_lex_lxsptr;
            return;
        };
    }break;
    case 195:;
    {
        switch ((int64_t)((*mm_lex_lxsptr++))) {
        case 151:;
        {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"MUL SYMBOL",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)32);
            mm_decls_nextlx.subcode = (uint64_t)((int64_t)45);
            return;
        }break;
        default: {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)1);
        }
        } //SW
;
    }break;
    case 239:;
    {
        mm_lex_lxsptr += (int64_t)2;
    }break;
    default: {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)1);
        return;
    }
    } //SW
goto L357 ;
L358 :;
    ;
}

static void mm_lex_lxreadstring(int64_t termchar) {
    static uint8_t psname[256];
    uint8_t *  dest;
    int64_t c;
    int64_t d;
    uint8_t str[8];
    int64_t av_1;
    if ((termchar == (int64_t)34)) {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)46);
    } else {
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)44);
        mm_decls_nextlx.subcode = (uint64_t)((int64_t)4);
    };
    if (!(!!(mm_decls_prescanmode))) {
        dest = mm_lex_lxsptr;
    } else {
        dest = psname;
    };
    mm_decls_nextlx.svalue = dest;
    L371 :;
    while (1) {
        switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
        case 92:;
        {
            c = (int64_t)((*mm_lex_lxsptr));
            if (((c >= (int64_t)65) && (c <= (int64_t)90))) {
                c += (int64_t)32;
            };
            ++mm_lex_lxsptr;
            switch (c) {
            case 97:;
            {
                c = (int64_t)7;
            }break;
            case 98:;
            {
                c = (int64_t)8;
            }break;
            case 99:;
            case 114:;
            {
                c = (int64_t)13;
            }break;
            case 101:;
            {
                c = (int64_t)26;
            }break;
            case 102:;
            {
                c = (int64_t)12;
            }break;
            case 108:;
            case 110:;
            {
                c = (int64_t)10;
            }break;
            case 115:;
            {
                c = (int64_t)27;
            }break;
            case 116:;
            {
                c = (int64_t)9;
            }break;
            case 118:;
            {
                c = (int64_t)11;
            }break;
            case 119:;
            {
                (*dest++) = (uint64_t)13u;
                c = (int64_t)10;
            }break;
            case 120:;
            {
                c = (int64_t)0;
                av_1 = (int64_t)2;
                while (av_1-- > 0) {
L373 :;
                    if (((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)65) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)66) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)67) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)68) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)69) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)70)) {
                        c = ((((c * (int64_t)16) + d) - (int64_t)65) + (int64_t)10);
                    }else if (((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)97) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)98) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)99) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)100) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)101) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)102)) {
                        c = ((((c * (int64_t)16) + d) - (int64_t)97) + (int64_t)10);
                    }else if (((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)48) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)49) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)50) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)51) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)52) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)53) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)54) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)55) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)56) || ((d = (int64_t)((*mm_lex_lxsptr++)))==(int64_t)57)) {
                        c = (((c * (int64_t)16) + d) - (int64_t)48);
                    } else {
                        mm_support_lxerror((uint8_t*)"Bad \\x code");
                    };
L374 :;
                }L375 :;
                ;
            }break;
            case 121:;
            {
                c = (int64_t)16;
            }break;
            case 122:;
            case 48:;
            {
                c = (int64_t)0;
            }break;
            case 34:;
            case 81:;
            {
                c = (int64_t)34;
            }break;
            case 92:;
            {
                c = (int64_t)92;
            }break;
            case 39:;
            {
                c = (int64_t)39;
            }break;
            default: {
                str[((int64_t)1)-1] = (uint64_t)(c);
                str[((int64_t)2)-1] = (uint64_t)0u;
                mm_support_lxerror_s((uint8_t*)"Unknown string escape: \\%s",str);
            }
            } //SW
;
        }break;
        case 34:;
        case 39:;
        {
            if ((c == termchar)) {
                if (((int64_t)((*mm_lex_lxsptr)) == c)) {
                    ++mm_lex_lxsptr;
                } else {
                    goto L372 ;
                };
            };
        }break;
        case 13:;
        case 10:;
        case 26:;
        case 0:;
        {
            mm_support_lxerror((uint8_t*)"String not terminated");
        }break;
        default: {
        }
        } //SW
;
        if (!(!!(mm_decls_prescanmode))) {
            (*dest++) = (uint64_t)(c);
        } else {
            if (((dest - mm_decls_nextlx.svalue) < (int64_t)251)) {
                (*dest++) = (uint64_t)(c);
            };
        };
    }L372 :;
    ;
    mm_decls_nextlx.length = (dest - mm_decls_nextlx.svalue);
    (*(mm_decls_nextlx.svalue + (int64_t)(mm_decls_nextlx.length))) = (uint64_t)0u;
}

static void mm_lex_readnumber(int64_t base) {
    uint8_t *  pstart;
    uint8_t *  dest;
    int64_t c;
    dest = (pstart = mm_lex_lxsptr);
    if ((base == (int64_t)10)) {
        L376 :;
        switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            (*dest++) = (uint64_t)(c);
        }break;
        case 95:;
        case 39:;
        case 96:;
        {
        }break;
        default: {
            --mm_lex_lxsptr;
            goto L377 ;
        }
        } //SW
goto L376 ;
L377 :;
        ;
    } else {
        dest = mm_lex_scannumber(base);
        c = (int64_t)((*mm_lex_lxsptr));
    };
    switch (c) {
    case 46:;
    {
        if (((uint64_t)((*(mm_lex_lxsptr + (int64_t)1))) != '.')) {
            mm_lex_readrealnumber(pstart,(dest - pstart),base);
            return;
        };
    }break;
    case 101:;
    case 69:;
    {
        if ((base < (int64_t)15)) {
            mm_lex_readrealnumber(pstart,(dest - pstart),base);
            return;
        };
    }break;
    case 112:;
    case 80:;
    {
        if ((base >= (int64_t)15)) {
            mm_lex_readrealnumber(pstart,(dest - pstart),base);
            return;
        };
    }break;
    default: {
    }
    } //SW
;
    mm_lex_stringtonumber(pstart,(dest - pstart),base);
}

static void mm_lex_readdecimalnumber(void) {
    uint8_t *  pstart;
    uint8_t *  dest;
    int64_t c;
    int64_t n;
    int64_t base;
    int64_t suffix;
    uint8_t *  p;
    int64_t av_1;
    dest = (pstart = mm_lex_lxsptr);
    suffix = (int64_t)0;
    L378 :;
    switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        (*dest++) = (uint64_t)(c);
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    default: {
        --mm_lex_lxsptr;
        goto L379 ;
    }
    } //SW
goto L378 ;
L379 :;
    ;
    switch (c) {
    case 46:;
    {
        if (((uint64_t)((*(mm_lex_lxsptr + (int64_t)1))) != '.')) {
            mm_lex_readrealnumber(pstart,(dest - pstart),(int64_t)10);
            return;
        };
    }break;
    case 101:;
    case 69:;
    {
        mm_lex_readrealnumber(pstart,(dest - pstart),(int64_t)10);
        return;
    }break;
    case 98:;
    case 66:;
    {
        ++mm_lex_lxsptr;
        n = (dest - pstart);
        p = pstart;
        av_1 = n;
        while (av_1-- > 0) {
L380 :;
            if ((((uint64_t)((*p)) < '0') || ((uint64_t)((*p)) > '1'))) {
                mm_support_lxerror((uint8_t*)"1101B: bad digit");
            };
            ++p;
L381 :;
        }L382 :;
        ;
        mm_lex_stringtonumber(pstart,n,(int64_t)2);
        return;
    }break;
    case 120:;
    case 88:;
    {
        ++mm_lex_lxsptr;
        mm_lex_stringtodecimalnumber(pstart,(dest - pstart),(int64_t)0);
        base = mm_decls_nextlx.value;
        if ((base > (int64_t)16)) {
            mm_support_lxerror((uint8_t*)"Number base over 16");
        };
        mm_lex_readnumber(base);
        return;
    }break;
    case 108:;
    case 76:;
    {
        suffix = c;
        ++mm_lex_lxsptr;
    }break;
    case 119:;
    case 87:;
    {
        suffix = c;
        ++mm_lex_lxsptr;
    }break;
    default: {
    }
    } //SW
;
    mm_lex_stringtodecimalnumber(pstart,(dest - pstart),suffix);
}

static void mm_lex_readrealnumber(uint8_t * intstart,int64_t intlen,int64_t base) {
    uint8_t *  fractstart;
    uint8_t *  ss;
    int64_t fractlen;
    int64_t expon;
    int64_t i;
    int64_t c;
    double basex;
    double x;
    uint8_t realstr[500];
    uint8_t str[32];
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    fractstart = (uint8_t *)(0);
    fractlen = (int64_t)0;
    expon = (int64_t)0;
    mm_lex_longsuffix = (int64_t)0;
    if (((uint64_t)((*mm_lex_lxsptr)) == '.')) {
        fractstart = ++mm_lex_lxsptr;
        fractlen = (mm_lex_scannumber(base) - fractstart);
    };
    if (((int64_t)((*mm_lex_lxsptr))==(int64_t)101) || ((int64_t)((*mm_lex_lxsptr))==(int64_t)69)) {
        if ((base < (int64_t)15)) {
            ++mm_lex_lxsptr;
            expon = mm_lex_readexponent(base);
        };
    }else if (((int64_t)((*mm_lex_lxsptr))==(int64_t)112) || ((int64_t)((*mm_lex_lxsptr))==(int64_t)80)) {
        if ((base >= (int64_t)15)) {
            ++mm_lex_lxsptr;
            expon = mm_lex_readexponent(base);
        };
    }else if (((int64_t)((*mm_lex_lxsptr))==(int64_t)108) || ((int64_t)((*mm_lex_lxsptr))==(int64_t)76)) {
        if (!!(mm_lex_longsuffix)) {
            mm_support_lxerror((uint8_t*)"LL?");
        };
        mm_lex_longsuffix = (int64_t)76;
        ++mm_lex_lxsptr;
    };
    if ((mm_lex_longsuffix == (int64_t)76)) {
        ss = (uint8_t *)(mlib_pcm_alloc(((intlen + fractlen) + (int64_t)16)));
        memcpy((void *)(ss),(void *)(intstart),(uint64_t)(intlen));
        memcpy((void *)((ss + intlen)),(void *)((uint8_t*)"."),(uint64_t)((int64_t)1));
        memcpy((void *)(((ss + intlen) + (int64_t)1)),(void *)(fractstart),(uint64_t)(fractlen));
        memcpy((void *)((((ss + intlen) + fractlen) + (int64_t)1)),(void *)((uint8_t*)"e"),(uint64_t)((int64_t)1));
        msysnewc_getstrint(expon,str);
        memcpy((void *)((((ss + intlen) + fractlen) + (int64_t)2)),(void *)(str),(uint64_t)(((int64_t)(strlen((int8_t *)(str))) + (int64_t)1)));
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)42);
        mm_decls_nextlx.svalue = ss;
        mm_decls_nextlx.length = (int64_t)(strlen((int8_t *)(ss)));
        return;
    };
    if (((intlen + fractlen) > (int64_t)500)) {
        mm_support_lxerror((uint8_t*)"Real too long");
    };
    if (!!(intlen)) {
        memcpy((void *)(&realstr),(void *)(intstart),(uint64_t)(intlen));
    };
    if (!!(fractlen)) {
        memcpy((void *)((&realstr[((int64_t)1)-1] + intlen)),(void *)(fractstart),(uint64_t)(fractlen));
    };
    if ((base == (int64_t)10)) {
        x = mm_lex_readrealbest(intlen,fractlen,expon,realstr);
    } else {
        basex = (double)(base);
        expon -= fractlen;
        x = (double)0.;
        L383 :;
        for (i=(int64_t)1;i<=(intlen + fractlen);i+=(int64_t)1) {
L384 :;
            c = (int64_t)(realstr[(i)-1]);
            if (((c >= (int64_t)48) && (c <= (int64_t)57))) {
                x = (((x * basex) + (double)(c)) - (double)48.);
            } else if ((c > (int64_t)97)) {
                x = ((((x * basex) + (double)(c)) - (double)97.) + (double)10.);
            } else {
                x = ((((x * basex) + (double)(c)) - (double)65.) + (double)10.);
            };
L385 :;
        }L386 :;
        ;
        if ((expon >= (int64_t)0)) {
            av_2 = expon;
            while (av_2-- > 0) {
L387 :;
                x *= basex;
L388 :;
            }L389 :;
            ;
        } else {
            av_3 = -(expon);
            while (av_3-- > 0) {
L390 :;
                x /= basex;
L391 :;
            }L392 :;
            ;
        };
    };
    mm_decls_nextlx.symbol = (uint64_t)((int64_t)43);
    mm_decls_nextlx.subcode = (uint64_t)((int64_t)12);
    mm_decls_nextlx.xvalue = x;
}

static double mm_lex_readrealbest(int64_t intlen,int64_t fractlen,int64_t expon,uint8_t * realstr) {
    uint8_t expstr[32];
    (*((realstr + intlen) + fractlen)) = (uint64_t)0u;
    expon -= fractlen;
    msysnewc_m_print_startstr(expstr);
    msysnewc_m_print_str((uint8_t*)"e",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(expon,NULL);
    msysnewc_m_print_end();
    ;
    strcat((int8_t *)(realstr),(int8_t *)(expstr));
    return strtod((int8_t *)(realstr),0);
}

static int64_t mm_lex_readexponent(int64_t base) {
    uint8_t *  numstart;
    int64_t length;
    int64_t neg;
    neg = (int64_t)0;
    if (((int64_t)((*mm_lex_lxsptr))==(int64_t)43)) {
        ++mm_lex_lxsptr;
    }else if (((int64_t)((*mm_lex_lxsptr))==(int64_t)45)) {
        ++mm_lex_lxsptr;
        neg = (int64_t)1;
    };
    numstart = mm_lex_lxsptr;
    length = (mm_lex_scannumber(base) - numstart);
    if ((length == (int64_t)0)) {
        mm_support_lxerror((uint8_t*)"Bad expon");
    };
    mm_lex_stringtonumber(numstart,length,base);
    return (!!(neg)?-(mm_decls_nextlx.value):mm_decls_nextlx.value);
}

void mm_lex_printsymbol(struct mm_decls_lexrec * lp) {
    struct mm_decls_lexrec l;
    l = (*lp);
    printf((int8_t *)((uint8_t*)"%-18s"),mm_tables_symbolnames[((int64_t)(l.symbol))-1]);
    if (((int64_t)(l.symbol)==(int64_t)37)) {
        mm_lex_printstrn(l.svalue,(int64_t)(l.length));
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)" (",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(l.hashvalue,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)")",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)50)) {
        mm_lex_printstrn((*l.symptr).name,(int64_t)((*l.symptr).namelen));
    }else if (((int64_t)(l.symbol)==(int64_t)41)) {
        if (((int64_t)(l.subcode)==(int64_t)4)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(l.value,NULL);
            msysnewc_m_print_str((uint8_t*)"int",NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(l.subcode)==(int64_t)9)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_u64(l.uvalue,NULL);
            msysnewc_m_print_str((uint8_t*)"word",NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(l.value,NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((int64_t)(l.symbol)==(int64_t)43)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_r64(l.xvalue,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)46)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\"",NULL);
        msysnewc_m_print_end();
        ;
        mm_lex_printstrn(l.svalue,(int64_t)(l.length));
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\"",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)44)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"'",NULL);
        msysnewc_m_print_end();
        ;
        mm_lex_printstrn(l.svalue,(int64_t)(l.length));
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"'",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)42)) {
        mm_lex_printstrn(l.svalue,(int64_t)(l.length));
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"L",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)32) || ((int64_t)(l.symbol)==(int64_t)9) || ((int64_t)(l.symbol)==(int64_t)24) || ((int64_t)(l.symbol)==(int64_t)18) || ((int64_t)(l.symbol)==(int64_t)10) || ((int64_t)(l.symbol)==(int64_t)29)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)(l.subcode))],NULL);
        msysnewc_m_print_end();
        ;
    } else {
        if (!!((uint64_t)(l.subcode))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"#",NULL);
            msysnewc_m_print_u64(l.subcode,NULL);
            msysnewc_m_print_end();
            ;
        };
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void mm_lex_stringtonumber(uint8_t * s,int64_t length,int64_t base) {
    int64_t a;
    int64_t c;
    int64_t av_1;
    int64_t av_2;
    L393 :;
    while (((length >= (int64_t)2) && ((uint64_t)((*s)) == '0'))) {
        ++s;
        --length;
L394 :;
    }L395 :;
    ;
    mm_decls_nextlx.symbol = (uint64_t)((int64_t)41);
    if (((length > mm_lex_maxnumlen[(base)-1]) || ((length == mm_lex_maxnumlen[(base)-1]) && ((int64_t)(strncmp((int8_t *)(s),(int8_t *)(mm_lex_maxnumlist[(base)-1]),(uint64_t)(length))) > (int64_t)0)))) {
        if ((base != (int64_t)16)) {
            mm_support_lxerror((uint8_t*)"longint const");
        } else {
            if (((length > (int64_t)32) || ((length == (int64_t)32) && ((int64_t)(strncmp((int8_t *)(s),(int8_t *)((uint8_t*)"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),(uint64_t)((int64_t)32))) > (int64_t)0)))) {
                mm_support_lxerror((uint8_t*)"longint const");
            } else {
                if (((length == (int64_t)32) && ((int64_t)(strncmp((int8_t *)(s),(int8_t *)((uint8_t*)"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),(uint64_t)((int64_t)32))) > (int64_t)0))) {
                    mm_decls_nextlx.subcode = (uint64_t)((int64_t)10);
                } else {
                    mm_decls_nextlx.subcode = (uint64_t)((int64_t)5);
                };
                mm_decls_nextlx.pvalue128 = mm_lex_stringtonumber128(s,length,(int64_t)16);
            };
        };
        return;
    };
    a = (int64_t)0;
    if ((base <= (int64_t)10)) {
        av_1 = length;
        while (av_1-- > 0) {
L396 :;
            a = (((a * base) + (int64_t)((*s++))) - (int64_t)48);
L397 :;
        }L398 :;
        ;
    } else {
        av_2 = length;
        while (av_2-- > 0) {
L399 :;
            c = (int64_t)((*s++));
            if ((c >= (int64_t)97)) {
                a = ((((a * base) + c) - (int64_t)97) + (int64_t)10);
            } else if ((c >= (int64_t)65)) {
                a = ((((a * base) + c) - (int64_t)65) + (int64_t)10);
            } else {
                a = (((a * base) + c) - (int64_t)48);
            };
L400 :;
        }L401 :;
        ;
    };
    mm_decls_nextlx.value = a;
    mm_decls_nextlx.subcode = (uint64_t)(mm_lex_setinttype((uint64_t)(a)));
}

static void mm_lex_stringtodecimalnumber(uint8_t * s,int64_t length,int64_t suffix) {
    int64_t a;
    int64_t av_1;
    L402 :;
    while (((length >= (int64_t)2) && ((uint64_t)((*s)) == '0'))) {
        ++s;
        --length;
L403 :;
    }L404 :;
    ;
    mm_decls_nextlx.symbol = (uint64_t)((int64_t)41);
    if ((((length > (int64_t)20) || ((length == (int64_t)20) && ((int64_t)(strncmp((int8_t *)(s),(int8_t *)((uint8_t*)"18446744073709551615"),(uint64_t)((int64_t)20))) > (int64_t)0))) || !!(suffix))) {
        if (((length > (int64_t)39) || ((length == (int64_t)39) && ((int64_t)(strncmp((int8_t *)(s),(int8_t *)((uint8_t*)"340282366920938463463374607431768211455"),(uint64_t)((int64_t)39))) > (int64_t)0)))) {
            if ((suffix == (int64_t)87)) {
                mm_support_lxerror((uint8_t*)"-W overflows 128 bits");
            };
            //dolongint:
L405 :;
;
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)42);
            mm_decls_nextlx.svalue = mlib_pcm_copyheapstring(s);
            mm_decls_nextlx.length = length;
        } else {
            if ((suffix == (int64_t)76)) {
                goto L405 ;
;
            };
            if (((length == (int64_t)39) && ((int64_t)(strncmp((int8_t *)(s),(int8_t *)((uint8_t*)"170141183460469231731687303715884105727"),(uint64_t)((int64_t)39))) > (int64_t)0))) {
                mm_decls_nextlx.subcode = (uint64_t)((int64_t)10);
            } else {
                mm_decls_nextlx.subcode = (uint64_t)((int64_t)5);
            };
            mm_decls_nextlx.pvalue128 = mm_lex_stringtonumber128(s,length,(int64_t)10);
        };
        return;
    };
    a = (int64_t)0;
    av_1 = length;
    while (av_1-- > 0) {
L406 :;
        a = (((a * (int64_t)10) + (int64_t)((*s++))) - (int64_t)48);
L407 :;
    }L408 :;
    ;
    mm_decls_nextlx.value = a;
    mm_decls_nextlx.subcode = (uint64_t)(mm_lex_setinttype((uint64_t)(a)));
}

void mm_lex_lexsetup(void) {
    int64_t i;
    int64_t av_1;
    L409 :;
    for (i=(int64_t)1;i<=(int64_t)16;i+=(int64_t)1) {
L410 :;
        mm_lex_maxnumlen[(i)-1] = (int64_t)(strlen((int8_t *)(mm_lex_maxnumlist[(i)-1])));
L411 :;
    }L412 :;
    ;
    mm_lex_inithashtable();
}

void mm_lex_printstrn(uint8_t * s,int64_t length) {
    if (!!(length)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(length,(uint8_t*)"v");
        msysnewc_m_print_str(s,(uint8_t*)".*");
        msysnewc_m_print_end();
        ;
    };
}

static uint8_t * mm_lex_scannumber(int64_t base) {
    uint8_t *  dest;
    int64_t c;
    dest = mm_lex_lxsptr;
    L413 :;
    switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        (*dest++) = (uint64_t)(c);
        if ((c >= ((int64_t)48 + base))) {
            mm_support_lxerror((uint8_t*)"Digit out of range");
        };
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    {
        if ((((int64_t)11 <= base) && (base <= (int64_t)16))) {
            (*dest++) = (uint64_t)(c);
        } else {
            --mm_lex_lxsptr;
            goto L414 ;
        };
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    case 108:;
    case 76:;
    {
        mm_lex_longsuffix = (int64_t)76;
        goto L414 ;
    }break;
    default: {
        --mm_lex_lxsptr;
        goto L414 ;
    }
    } //SW
goto L413 ;
L414 :;
    ;
    return dest;
}

static void mm_lex_readrawstring(void) {
    uint8_t *  dest;
    int64_t c;
    mm_decls_nextlx.symbol = (uint64_t)((int64_t)46);
    mm_decls_nextlx.svalue = ++mm_lex_lxsptr;
    dest = mm_lex_lxsptr;
    L415 :;
    switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
    case 34:;
    {
        if (((uint64_t)((*mm_lex_lxsptr)) == '"')) {
            (*dest++) = '"';
            ++mm_lex_lxsptr;
        } else {
            (*(mm_lex_lxsptr - (int64_t)1)) = (uint64_t)0u;
            goto L416 ;
        };
    }break;
    case 13:;
    case 10:;
    case 26:;
    case 0:;
    {
        mm_support_lxerror((uint8_t*)"Raw string not terminated");
        --mm_lex_lxsptr;
        goto L416 ;
    }break;
    default: {
        (*dest++) = (uint64_t)(c);
    }
    } //SW
goto L415 ;
L416 :;
    ;
    mm_decls_nextlx.length = (dest - mm_decls_nextlx.svalue);
}

static int64_t mm_lex_lookup(void) {
    int64_t j;
    int64_t wrapped;
    j = ((int64_t)(mm_decls_nextlx.hashvalue) & (int64_t)32767);
    mm_decls_nextlx.symptr = &mm_lex_hashtable[(j)];
    wrapped = (int64_t)0;
    ++mm_lex_nlookups;
    L417 :;
    while (1) {
        if (((int64_t)((*mm_decls_nextlx.symptr).namelen)==(int64_t)0)) {
            goto L418 ;
        }else if (((int64_t)((*mm_decls_nextlx.symptr).namelen)==(int64_t)(mm_decls_nextlx.length))) {
            if (((int64_t)(memcmp((void *)((*mm_decls_nextlx.symptr).name),(void *)(mm_decls_nextlx.svalue),(uint64_t)(mm_decls_nextlx.length))) == (int64_t)0)) {
                return (int64_t)1;
            };
        };
        ++mm_lex_nclashes;
        ++mm_decls_nextlx.symptr;
        if ((++j >= (int64_t)32768)) {
            if (!!(wrapped)) {
                mlib_abortprogram((uint8_t*)"HASHTABLE FULL");
            };
            wrapped = (int64_t)1;
            mm_decls_nextlx.symptr = &mm_lex_hashtable[((int64_t)0)];
            j = (int64_t)0;
        };
    }L418 :;
    ;
    (*mm_decls_nextlx.symptr).name = mm_decls_nextlx.svalue;
    (*mm_decls_nextlx.symptr).namelen = (uint64_t)(mm_decls_nextlx.length);
    (*mm_decls_nextlx.symptr).symbol = (uint64_t)((int64_t)37);
    return (int64_t)0;
}

int64_t mm_lex_gethashvaluez(uint8_t * s) {
    int64_t c;
    int64_t hsum;
    if (((int64_t)((*s)) == (int64_t)0)) {
        return (int64_t)0;
    };
    hsum = (int64_t)((*s++));
    L419 :;
    while (1) {
        c = (int64_t)((*s++));
        if ((c == (int64_t)0)) {
            goto L420 ;
        };
        hsum = (((hsum << (int64_t)4) - hsum) + c);
    }L420 :;
    ;
    return ((hsum << (int64_t)5) - hsum);
}

static void mm_lex_inithashtable(void) {
    int64_t i;
    int64_t av_1;
    memset((void *)(&mm_lex_hashtable),(int64_t)0,(uint64_t)((int64_t)5668864));
    L421 :;
    for (i=(int64_t)1;i<=(int64_t)275;i+=(int64_t)1) {
L422 :;
        mm_decls_nextlx.svalue = mlib_pcm_copyheapstring(mm_tables_stnames[(i)-1]);
        mm_decls_nextlx.length = (int64_t)(strlen((int8_t *)(mm_decls_nextlx.svalue)));
        mm_decls_nextlx.hashvalue = mm_lex_gethashvaluez(mm_decls_nextlx.svalue);
        if (!!(mm_lex_lookup())) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_tables_stnames[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mlib_abortprogram((uint8_t*)"Duplicate symbol table entry");
        };
        (*mm_decls_nextlx.symptr).symbol = (uint64_t)(mm_tables_stsymbols[(i)-1]);
        if ((mm_tables_stsymbols[(i)-1]==(int64_t)49)) {
            (*mm_decls_nextlx.symptr).index = mm_tables_stsubcodes[(i)-1];
            (*mm_decls_nextlx.symptr).subcode = (int64_t)49;
            (*mm_decls_nextlx.symptr).symbol = (uint64_t)((int64_t)37);
        } else {
            (*mm_decls_nextlx.symptr).subcode = mm_tables_stsubcodes[(i)-1];
        };
L423 :;
    }L424 :;
    ;
}

void mm_lex_addreservedword(uint8_t * name,int64_t symbol,int64_t subcode,int64_t regsize) {
    mm_decls_nextlx.svalue = mlib_pcm_copyheapstring(name);
    mm_decls_nextlx.length = (int64_t)(strlen((int8_t *)(name)));
    mm_decls_nextlx.hashvalue = mm_lex_gethashvaluez(name);
    if (!!(mm_lex_lookup())) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"NAME=",NULL);
        msysnewc_m_print_str(name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mlib_abortprogram((uint8_t*)"Dupl ASM symbol");
    };
    (*mm_decls_nextlx.symptr).symbol = (uint64_t)((int64_t)37);
    (*mm_decls_nextlx.symptr).subcode = symbol;
    (*mm_decls_nextlx.symptr).index = subcode;
    (*mm_decls_nextlx.symptr).regsize = regsize;
}

static int64_t mm_lex_dolexdirective(int64_t index) {
    uint8_t *  file;
    int64_t fileno;
    if ((index==(int64_t)11) || (index==(int64_t)12)) {
        mm_lex_lexreadtoken();
        if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)46)) {
            if ((((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)37) && !!(mlib_eqbytes((void *)(mm_decls_nextlx.svalue),(void *)((uint8_t*)"$filename"),(int64_t)9)))) {
                file = mm_decls_sourcefilepaths[((int64_t)(mm_decls_nextlx.fileno))];
            } else {
                mm_support_lxerror((uint8_t*)"strincl: string expected");
            };
        } else {
            file = mm_decls_nextlx.svalue;
        };
        fileno = mm_support_getsupportfile(file);
        mm_decls_nextlx.svalue = mm_decls_sourcefiletext[(fileno)];
        mm_decls_nextlx.length = mm_decls_sourcefilesizes[(fileno)];
        mm_decls_nextlx.symbol = ((index == (int64_t)11)?(uint64_t)((int64_t)46):(uint64_t)((int64_t)47));
        mm_decls_nextlx.subcode = (uint64_t)65u;
        (*(mm_decls_nextlx.svalue + (int64_t)(mm_decls_nextlx.length))) = (uint64_t)0u;
        return (int64_t)1;
    }else if ((index==(int64_t)7)) {
        mm_lex_lexreadtoken();
        if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)46)) {
            mm_support_lxerror((uint8_t*)"include: string expected");
        };
        file = mm_decls_nextlx.svalue;
        mlib_convlcstring(file);
        file = mlib_addext(file,(uint8_t*)".m");
        if ((mm_decls_fverbose >= (int64_t)2)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"  Include:",NULL);
            msysnewc_m_print_str(file,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        mm_lex_stacksourcefile(file,(int64_t)0);
        return (int64_t)0;
    }else if ((index==(int64_t)1)) {
        mm_lex_lexreadtoken();
        if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)46)) {
            mm_support_lxerror((uint8_t*)"emitc/not str");
        };
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)152);
        return (int64_t)1;
    }else if ((index==(int64_t)13)) {
        L425 :;
        while (1) {
            if ((mm_decls_ncclibs >= (int64_t)10)) {
                mm_support_lxerror((uint8_t*)"Too many cc libs");
            };
            mm_lex_lexreadtoken();
            if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)46)) {
                mm_decls_cclibtable[(++mm_decls_ncclibs)-1] = mlib_pcm_copyheapstring(mm_decls_nextlx.svalue);
            }else if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)37)) {
                mm_decls_cclibtable[(++mm_decls_ncclibs)-1] = mlib_pcm_copyheapstringn(mm_decls_nextlx.svalue,(int64_t)(mm_decls_nextlx.length));
            } else {
                mm_support_lxerror((uint8_t*)"cclib/not str/name");
            };
            mm_lex_lexreadtoken();
            if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)5)) {
                goto L426 ;
            };
        }L426 :;
        ;
        return (int64_t)0;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_tables_sourcedirnames[(index)-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_lxerror((uint8_t*)"Directive not implemented");
    };
    return (int64_t)0;
}

static void mm_lex_lexreadline(void) {
    L427 :;
    switch ((int64_t)((*mm_lex_lxsptr))) {
    case 13:;
    case 10:;
    {
        return;
    }break;
    case 26:;
    case 0:;
    {
        --mm_lex_lxsptr;
        return;
    }break;
    default: {
        ++mm_lex_lxsptr;
    }
    } //SW
goto L427 ;
L428 :;
    ;
}

void mm_lex_startlex(uint8_t * caption,int64_t fileno) {
    mm_lex_lxsptr = mm_decls_sourcefiletext[(fileno)];
    mm_decls_nextlx.fileno = (uint64_t)(fileno);
    mm_decls_nextlx.lineno = (int64_t)1;
    mm_decls_nextlx.symbol = (uint64_t)((int64_t)6);
    mm_decls_nextlx.subcode = (uint64_t)((int64_t)0);
}

uint8_t * mm_lex_convertzstring(uint8_t * s,int64_t length) {
    static uint8_t str[300];
    if ((length > (int64_t)300)) {
        mlib_abortprogram((uint8_t*)"convertzstr");
    };
    memcpy((void *)(str),(void *)(s),(uint64_t)(length));
    str[((length + (int64_t)1))-1] = (uint64_t)0u;
    return str;
}

struct mm_decls_strec * mm_lex_addnamestr(uint8_t * name) {
    struct mm_decls_lexrec oldlx;
    struct mm_decls_strec *  symptr;
    oldlx = mm_decls_nextlx;
    mm_decls_nextlx.hashvalue = mm_lex_gethashvaluez(name);
    mm_decls_nextlx.length = (int64_t)(strlen((int8_t *)(name)));
    mm_decls_nextlx.svalue = (uint8_t *)(mlib_pcm_alloc(((int64_t)(mm_decls_nextlx.length) + (int64_t)1)));
    memcpy((void *)(mm_decls_nextlx.svalue),(void *)(name),(uint64_t)(((int64_t)(mm_decls_nextlx.length) + (int64_t)1)));
    mm_lex_lookup();
    symptr = mm_decls_nextlx.symptr;
    mm_decls_nextlx = oldlx;
    return symptr;
}

struct mm_decls_strec * mm_lex_findname(uint8_t * name) {
    mm_decls_nextlx.hashvalue = mm_lex_gethashvaluez(name);
    mm_decls_nextlx.length = (int64_t)(strlen((int8_t *)(name)));
    mm_decls_nextlx.svalue = name;
    if (!!(mm_lex_lookup())) {
        return mm_decls_nextlx.symptr;
    } else {
        return (struct mm_decls_strec *)(0);
    };
}

void mm_lex_ps1(uint8_t * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)":::",NULL);
    msysnewc_m_print_end();
    ;
    mm_lex_printsymbol(&mm_decls_lx);
}

void mm_lex_ps2(uint8_t * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\t",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)":##",NULL);
    msysnewc_m_print_end();
    ;
    mm_lex_printsymbol(&mm_decls_nextlx);
}

void mm_lex_ps(uint8_t * caption) {
    mm_lex_ps1(caption);
}

void mm_lex_lex(void) {
    int64_t n;
    uint8_t *  p;
    mm_decls_lx = mm_decls_nextlx;
    mm_decls_lx.lineno = (((int64_t)(mm_decls_lx.fileno) << (int64_t)24) + (int64_t)(mm_decls_lx.lineno));
    //reenter:
L429 :;
;
    mm_lex_lexreadtoken();
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
        (*((*mm_decls_lx.symptr).name + (int64_t)(mm_decls_lx.length))) = (uint64_t)0u;
    };
    switch ((int64_t)(mm_decls_nextlx.symbol)) {
    case 37:;
    {
        if (!(!!(mm_lex_lookup()))) {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)50);
            return;
        };
        //found:
L430 :;
;
        mm_decls_nextlx.symbol = (uint64_t)((*mm_decls_nextlx.symptr).symbol);
        mm_decls_nextlx.subcode = (uint64_t)((*mm_decls_nextlx.symptr).subcode);
        switch ((int64_t)(mm_decls_nextlx.symbol)) {
        case 51:;
        {
            if (!(!!(mm_lex_dolexdirective((int64_t)(mm_decls_nextlx.subcode))))) {
                goto L429 ;
;
            };
        }break;
        case 37:;
        {
            if ((((int64_t)((uint64_t)(mm_decls_nextlx.subcode)) == (int64_t)49) && (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)41) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)43)))) {
                if (((int64_t)(mm_decls_lx.symbol)==(int64_t)41)) {
                    if ((((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)5) || ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)10))) {
                        mm_support_lxerror((uint8_t*)"No suffix on i128/u128");
                    };
                    if (((int64_t)((*mm_decls_nextlx.symptr).index)==(int64_t)2)) {
                        mm_decls_lx.value *= (int64_t)1000000;
                    }else if (((int64_t)((*mm_decls_nextlx.symptr).index)==(int64_t)3)) {
                        mm_decls_lx.value *= (int64_t)1000000000;
                    }else if (((int64_t)((*mm_decls_nextlx.symptr).index)==(int64_t)1)) {
                        mm_decls_lx.value *= (int64_t)1000;
                    }else if (((int64_t)((*mm_decls_nextlx.symptr).index)==(int64_t)4)) {
                        mm_decls_lx.value *= (int64_t)1024;
                    }else if (((int64_t)((*mm_decls_nextlx.symptr).index)==(int64_t)5)) {
                        mm_decls_lx.value *= (int64_t)1048576;
                    }else if (((int64_t)((*mm_decls_nextlx.symptr).index)==(int64_t)6)) {
                        mm_decls_lx.value *= (int64_t)1073741824;
                    } else {
                        mm_support_lxerror((uint8_t*)"Can't do this unit index");
                    };
                    mm_decls_lx.subcode = (uint64_t)(mm_lex_setinttype((uint64_t)(mm_decls_lx.value)));
                } else {
                    mm_support_lxerror((uint8_t*)"Unit suffix after float not implem");
                };
                goto L429 ;
;
            } else {
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)50);
                mm_decls_nextlx.svalue = (*mm_decls_nextlx.symptr).name;
            };
        }break;
        case 50:;
        {
            mm_support_lxerror((uint8_t*)"NEXT NAME!!!");
        }break;
        case 76:;
        case 93:;
        case 77:;
        case 94:;
        case 80:;
        case 81:;
        case 85:;
        case 83:;
        case 100:;
        case 101:;
        case 107:;
        case 75:;
        case 103:;
        case 104:;
        case 105:;
        case 111:;
        case 86:;
        case 125:;
        case 132:;
        case 143:;
        case 151:;
        case 67:;
        {
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)74)) {
                mm_decls_lx.subcode = (uint64_t)(mm_decls_nextlx.symbol);
                goto L429 ;
;
            };
        }break;
        case 32:;
        {
            goto L431 ;
;
        }break;
        case 150:;
        {
            if (((int64_t)(mm_decls_nextlx.subcode)==(int64_t)4)) {
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)41);
                mm_decls_nextlx.value = (int64_t)0;
                mm_decls_nextlx.subcode = (uint64_t)((int64_t)4);
            }else if (((int64_t)(mm_decls_nextlx.subcode)==(int64_t)1)) {
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)41);
                mm_decls_nextlx.value = (int64_t)0;
                mm_decls_nextlx.subcode = (uint64_t)((int64_t)19);
            }else if (((int64_t)(mm_decls_nextlx.subcode)==(int64_t)2)) {
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)43);
                mm_decls_nextlx.xvalue = (atan((double)1.) * (double)4.);
                mm_decls_nextlx.subcode = (uint64_t)((int64_t)12);
            }else if (((int64_t)(mm_decls_nextlx.subcode)==(int64_t)3)) {
                mm_decls_nextlx.symbol = (uint64_t)((int64_t)46);
                mm_decls_nextlx.svalue = (uint8_t*)"\t";
                mm_decls_nextlx.length = (int64_t)1;
            } else {
                mm_support_lxerror((uint8_t*)"sysconst?");
            };
        }break;
        case 62:;
        {
            if (((int64_t)(mm_decls_nextlx.subcode)==(int64_t)73) || ((int64_t)(mm_decls_nextlx.subcode)==(int64_t)105)) {
                mm_decls_nextlx.subcode = ((mm_decls_targetbits == (int64_t)32)?(uint64_t)((int64_t)3):(uint64_t)((int64_t)4));
            }else if (((int64_t)(mm_decls_nextlx.subcode)==(int64_t)87) || ((int64_t)(mm_decls_nextlx.subcode)==(int64_t)119)) {
                mm_decls_nextlx.subcode = ((mm_decls_targetbits == (int64_t)32)?(uint64_t)((int64_t)8):(uint64_t)((int64_t)9));
            };
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)61);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 38:;
    {
        mm_lex_lookup();
        mm_decls_nextlx.symbol = (uint64_t)((int64_t)50);
        return;
    }break;
    case 35:;
    {
        switch ((int64_t)(mm_decls_lx.symbol)) {
        case 5:;
        case 14:;
        case 12:;
        case 9:;
        case 6:;
        {
            goto L429 ;
;
        }break;
        case 32:;
        {
            if (!(!!(mm_decls_assemmode))) {
                goto L429 ;
;
            };
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)6);
        }break;
        default: {
            mm_decls_nextlx.symbol = (uint64_t)((int64_t)6);
        }
        } //SW
;
    }break;
    case 46:;
    {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)46)) {
            n = ((int64_t)(mm_decls_nextlx.length) + (int64_t)(mm_decls_lx.length));
            p = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
            memcpy((void *)(p),(void *)(mm_decls_lx.svalue),(uint64_t)(mm_decls_lx.length));
            memcpy((void *)((p + (int64_t)(mm_decls_lx.length))),(void *)(mm_decls_nextlx.svalue),(uint64_t)(mm_decls_nextlx.length));
            (*(p + n)) = (uint64_t)0u;
            mm_decls_lx.svalue = p;
            mm_decls_lx.length = n;
            goto L429 ;
;
        };
    }break;
    case 32:;
    {
        //doopsym:
L431 :;
;
        if (((((int64_t)((uint64_t)(mm_decls_nextlx.subcode)) == (int64_t)55) && ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32)) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)15))) {
            mm_decls_lx.subcode = (uint64_t)((int64_t)56);
            goto L429 ;
;
        };
    }break;
    case 36:;
    {
    }break;
    default: {
    }
    } //SW
;
}

void mm_lex_showhashtablesize(void) {
    int64_t i;
    int64_t n;
    n = (int64_t)0;
    L432 :;
    for (i=(int64_t)0;i<=(int64_t)32767;i+=(int64_t)1) {
L433 :;
        if (!!(mm_lex_hashtable[(i)].name)) {
            ++n;
        };
L434 :;
    }L435 :;
    ;
}

int64_t mm_lex_checkname(uint8_t * name,int64_t length) {
    if ((length == (int64_t)0)) {
        length = (int64_t)(strlen((int8_t *)(name)));
    };
    if ((((int64_t)(mm_decls_nextlx.length) == length) && ((int64_t)(memcmp((void *)(mm_decls_nextlx.svalue),(void *)(name),(uint64_t)(length))) == (int64_t)0))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

static uint8_t * mm_lex_getstrfile(uint8_t * filename,int32_t * length) {
    uint8_t *  file;
    static uint8_t filespec[300];
    int64_t i;
    L436 :;
    for (i=mm_decls_nsearchdirs;i>=(int64_t)1;i-=(int64_t)1) {
L437 :;
        strcpy((int8_t *)(filespec),(int8_t *)(mm_decls_searchdirs[(i)-1]));
        strcat((int8_t *)(filespec),(int8_t *)(filename));
        if (!!(mlib_checkfile(filespec))) {
            file = (uint8_t *)(mlib_readfile(filespec));
            (*length) = mlib_rfsize;
            return file;
        };
L438 :;
    }L439 :;
    ;
    return (uint8_t *)(0);
}

static void mm_lex_stacksourcefile(uint8_t * file,int64_t ismainmodule) {
    int64_t fileno;
    fileno = mm_support_getsupportfile(file);
    mm_lex_stacksource(mm_decls_sourcefiletext[(fileno)],fileno,(int64_t)1);
}

static void mm_lex_stacksource(uint8_t * sptr,int64_t fileno,int64_t isfile) {
    if ((mm_lex_sourcelevel >= (int64_t)20)) {
        mm_support_lxerror((uint8_t*)"Include file/macro overflow");
    };
    ++mm_lex_sourcelevel;
    mm_lex_lxstart_stack[(mm_lex_sourcelevel)-1] = mm_lex_lxstart;
    mm_lex_lxsptr_stack[(mm_lex_sourcelevel)-1] = mm_lex_lxsptr;
    mm_lex_lxfileno_stack[(mm_lex_sourcelevel)-1] = (int64_t)(mm_decls_nextlx.fileno);
    mm_lex_lxlineno_stack[(mm_lex_sourcelevel)-1] = (int64_t)(mm_decls_nextlx.lineno);
    mm_lex_isfile_stack[(mm_lex_sourcelevel)-1] = (uint64_t)(isfile);
    mm_lex_lxstart = (mm_lex_lxsptr = sptr);
    mm_decls_nextlx.lineno = (int64_t)1;
    mm_decls_nextlx.fileno = (uint64_t)(fileno);
}

static void mm_lex_unstacksource(void) {
    if ((mm_lex_sourcelevel > (int64_t)0)) {
        mm_lex_lxstart = mm_lex_lxstart_stack[(mm_lex_sourcelevel)-1];
        mm_lex_lxsptr = mm_lex_lxsptr_stack[(mm_lex_sourcelevel)-1];
        mm_decls_nextlx.lineno = mm_lex_lxlineno_stack[(mm_lex_sourcelevel)-1];
        mm_decls_nextlx.fileno = (uint64_t)(mm_lex_lxfileno_stack[(mm_lex_sourcelevel)-1]);
        --mm_lex_sourcelevel;
    };
}

static void mm_lex_readarraystring(int64_t prefix) {
    ++mm_lex_lxsptr;
    mm_lex_lxreadstring((int64_t)34);
    mm_decls_nextlx.symbol = (uint64_t)((int64_t)47);
    mm_decls_nextlx.subcode = (uint64_t)(toupper((int64_t)((int32_t)(prefix))));
}

static i128 * mm_lex_stringtonumber128(uint8_t * s,int64_t length,int64_t base) {
    i128 *  aa;
    return aa;
}

static int64_t mm_lex_setinttype(uint64_t a) {
    if ((a < (uint64_t)9223372036854775807u)) {
        return (int64_t)4;
    } else {
        return (int64_t)9;
    };
}

static void mm_lex_readrawxname(void) {
    int64_t c;
    int64_t hsum;
    mm_decls_nextlx.svalue = mm_lex_lxsptr;
    hsum = (int64_t)0;
    L443 :;
    switch ((c = (int64_t)((*mm_lex_lxsptr++)))) {
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    case 95:;
    case 36:;
    {
        hsum = (((hsum << (int64_t)4) - hsum) + c);
    }break;
    default: {
        --mm_lex_lxsptr;
        goto L444 ;
    }
    } //SW
goto L443 ;
L444 :;
    ;
    mm_decls_nextlx.symbol = (uint64_t)((int64_t)38);
    mm_decls_nextlx.length = (mm_lex_lxsptr - mm_decls_nextlx.svalue);
    mm_decls_nextlx.hashvalue = ((hsum << (int64_t)5) - hsum);
    if (((int64_t)(mm_decls_nextlx.length) == (int64_t)0)) {
        mm_support_lxerror((uint8_t*)"Bad ` name");
    };
    return;
}

void mm_diags_printmodelist(void * f) {
    uint8_t str[256];
    uint8_t *  mstr;
    struct mlib_strbuffer destv;
    struct mlib_strbuffer *  dest;
    int64_t m;
    dest = &destv;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"MODELIST",NULL);
    msysnewc_m_print_i64(mm_decls_ntypes,NULL);
    msysnewc_m_print_i64(mm_decls_nuserxtypes,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_gs_init(dest);
    mlib_gs_leftstr(dest,(uint8_t*)"#",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Name",(int64_t)13,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Base",(int64_t)13,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Bit",(int64_t)3,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Target",(int64_t)12,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Def",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Lwb",(int64_t)5,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Upb",(int64_t)5,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Len",(int64_t)6,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Size",(int64_t)6,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Cat",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Usd ",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Mode",(int64_t)24,(int64_t)32);
    mlib_gs_println(dest,f);
    L445 :;
    for (m=(int64_t)0;m<=mm_decls_ntypes;m+=(int64_t)1) {
L446 :;
        mlib_gs_init(dest);
        mlib_gs_leftint(dest,m,(int64_t)4,(int64_t)32);
        mlib_gs_leftstr(dest,mm_lib_typename(m),(int64_t)13,(int64_t)32);
        mlib_gs_leftstr(dest,mm_lib_typename((int64_t)(mm_decls_ttbasetype[(m)])),(int64_t)13,(int64_t)32);
        mlib_gs_leftint(dest,(int64_t)(mm_decls_ttbitwidth[(m)]),(int64_t)3,(int64_t)32);
        if (!!((int64_t)(mm_decls_tttarget[(m)]))) {
            mlib_gs_leftstr(dest,mm_lib_typename((int64_t)(mm_decls_tttarget[(m)])),(int64_t)12,(int64_t)32);
        } else {
            mlib_gs_leftstr(dest,(uint8_t*)"-",(int64_t)12,(int64_t)32);
        };
        if (!!(mm_decls_ttnamedef[(m)])) {
            mlib_gs_leftstr(dest,(uint8_t*)"+",(int64_t)4,(int64_t)32);
        } else {
            mlib_gs_leftstr(dest,(uint8_t*)"-",(int64_t)4,(int64_t)32);
        };
        if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)24) || ((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)25)) {
            mlib_gs_leftint(dest,(int64_t)(mm_decls_ttlower[(m)]),(int64_t)5,(int64_t)32);
            mlib_gs_leftint(dest,(((int64_t)(mm_decls_ttlower[(m)]) + (int64_t)(mm_decls_ttlength[(m)])) - (int64_t)1),(int64_t)5,(int64_t)32);
            mlib_gs_leftint(dest,(int64_t)(mm_decls_ttlength[(m)]),(int64_t)6,(int64_t)32);
        } else {
            mlib_gs_leftstr(dest,(uint8_t*)"",(int64_t)5,(int64_t)32);
            mlib_gs_leftstr(dest,(uint8_t*)"",(int64_t)5,(int64_t)32);
            mlib_gs_leftstr(dest,(uint8_t*)"",(int64_t)6,(int64_t)32);
        };
        mlib_gs_leftint(dest,(int64_t)(mm_decls_ttsize[(m)]),(int64_t)6,(int64_t)32);
        mlib_gs_leftint(dest,(int64_t)(mm_decls_ttusercat[(m)]),(int64_t)4,(int64_t)32);
        mstr = mm_lib_strmode(m,(int64_t)1);
        if (((int64_t)(strlen((int8_t *)(mstr))) < (int64_t)24)) {
            strcpy((int8_t *)(str),(int8_t *)(mstr));
        } else {
            memcpy((void *)(str),(void *)(mstr),(uint64_t)((int64_t)24));
            str[((int64_t)24)-1] = (uint64_t)0u;
        };
        mlib_gs_leftstr(dest,str,(int64_t)24,(int64_t)32);
        mlib_gs_println(dest,f);
L447 :;
    }L448 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"USERXTYPES:",NULL);
    msysnewc_m_print_i64(mm_decls_nuserxtypes,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L449 :;
    for (m=(int64_t)1;m<=mm_decls_nuserxtypes;m+=(int64_t)1) {
L450 :;
        mlib_gs_init(dest);
        mlib_gs_strint(dest,m);
        mlib_gs_str(dest,(uint8_t*)": ");
        mlib_gs_str(dest,(*mm_decls_ttnamedefx[(m)]).name);
        if (!!(mm_decls_ttnamedefx2[(m)])) {
            mlib_gs_str(dest,(uint8_t*)".");
            mlib_gs_str(dest,(*mm_decls_ttnamedefx2[(m)]).name);
        };
        mlib_gs_str(dest,(uint8_t*)" ");
        mlib_gs_strint(dest,mm_decls_ttxmap[(m)]);
        mlib_gs_println(dest,f);
L451 :;
    }L452 :;
    ;
}

void mm_diags_printst(void * f,struct mm_decls_strec * p,int64_t level) {
    struct mm_decls_strec *  q;
    if (((int64_t)((uint64_t)((*p).symbol)) != (int64_t)50)) {
        mm_support_mcerror((uint8_t*)"PRINTST not name");
    };
    mm_diags_printstrec(f,p,level);
    q = (*p).deflist;
    L453 :;
    while ((q != 0)) {
        mm_diags_printst(f,q,(level + (int64_t)1));
        q = (*q).nextdef;
L454 :;
    }L455 :;
    ;
}

static void mm_diags_printstrec(void * f,struct mm_decls_strec * p,int64_t level) {
    struct mm_decls_strec dd;
    struct mlib_strbuffer v;
    struct mlib_strbuffer *  d;
    int64_t col;
    int64_t offset;
    int64_t n;
    uint8_t str[256];
    int64_t av_1;
    int64_t i;
    d = &v;
    mlib_gs_init(d);
    offset = (int64_t)0;
    av_1 = level;
    while (av_1-- > 0) {
L456 :;
        mlib_gs_str(d,(uint8_t*)"    ");
        offset += (int64_t)4;
L457 :;
    }L458 :;
    ;
    mlib_gs_str(d,(uint8_t*)":");
    mlib_gs_leftstr(d,(*p).name,((int64_t)28 - offset),(int64_t)45);
    mlib_gs_leftstr(d,mm_tables_namenames[((int64_t)((*p).nameid))],(int64_t)12,(int64_t)46);
    col = mlib_gs_getcol(d);
    dd = (*p);
    mlib_gs_str(d,(uint8_t*)"[");
    if (!!((uint64_t)((*p).imported))) {
        mlib_gs_str(d,(((int64_t)((uint64_t)((*p).imported)) == (int64_t)2)?(uint8_t*)"Imp/CLIB ":(uint8_t*)"Imp "));
    } else {
        mlib_gs_str(d,((int64_t)((*p).isglobal)==1?(uint8_t*)"Glob ":((int64_t)((*p).isglobal)==2?(uint8_t*)"Exp ":(uint8_t*)"Loc ")));
    };
    if (!!((uint64_t)(dd.isstatic))) {
        mlib_gs_str(d,(uint8_t*)"Stat");
    };
    if (!!((uint64_t)(dd.fflang))) {
        mlib_gs_strsp(d,mm_tables_fflangnames[((int64_t)(dd.fflang))]);
    };
    if (!!((uint64_t)(dd.parammode))) {
        mlib_gs_str(d,mm_tables_parammodenames[((int64_t)(dd.parammode))]);
    };
    if (!!((uint64_t)(dd.align))) {
        mlib_gs_str(d,(uint8_t*)"@@");
        mlib_gs_strint(d,(int64_t)(dd.align));
        mlib_gs_str(d,(uint8_t*)" maxalign:");
        mlib_gs_strint(d,(int64_t)(dd.maxalign));
    };
    if (!!((uint64_t)(dd.optional))) {
        mlib_gs_str(d,(uint8_t*)"Opt ");
    };
    if (!!((uint64_t)(dd.varparams))) {
        mlib_gs_str(d,(uint8_t*)"Var ");
    };
    if (!!((uint64_t)(dd.moduleno))) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"Modno#",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_u64(dd.moduleno,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,str);
    };
    if (!!((uint64_t)(dd.equals))) {
        mlib_gs_str(d,(uint8_t*)":= ");
    };
    if (!!((uint64_t)(dd.used))) {
        mlib_gs_str(d,(uint8_t*)"U ");
    };
    mlib_gs_str(d,(uint8_t*)"]");
    mlib_gs_padto(d,(col + (int64_t)10),(int64_t)61);
    if (!!((*p).owner)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"(#)");
        msysnewc_m_print_str((*(*p).owner).name,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_leftstr(d,str,(int64_t)18,(int64_t)45);
    } else {
        mlib_gs_leftstr(d,(uint8_t*)"()",(int64_t)18,(int64_t)45);
    };
    if (((int64_t)((*p).mode)==(int64_t)0)) {
        mlib_gs_str(d,(uint8_t*)"Void ");
    } else {
        mlib_gs_strint(d,(int64_t)((*p).mode));
        mlib_gs_str(d,(uint8_t*)":");
        n = (int64_t)((*p).nretvalues);
        if ((n == (int64_t)0)) {
            n = (int64_t)1;
        };
        if ((n > (int64_t)1)) {
            mlib_gs_str(d,(uint8_t*)"(");
        };
        L459 :;
        for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L460 :;
            mlib_gs_str(d,mm_lib_strmode((int64_t)((*p).modelist[(i)-1]),(int64_t)1));
            if ((i < n)) {
                mlib_gs_str(d,(uint8_t*)",");
            };
L461 :;
        }L462 :;
        ;
        if ((n > (int64_t)1)) {
            mlib_gs_str(d,(uint8_t*)")");
        };
        mlib_gs_str(d,(uint8_t*)" ");
    };
    if (((int64_t)((*p).nameid)==(int64_t)12) || ((int64_t)((*p).nameid)==(int64_t)11)) {
        mlib_gs_str(d,(uint8_t*)" Offset:");
        mlib_gs_strint(d,(int64_t)((*p).offset));
        if (((int64_t)((*p).mode) == (int64_t)21)) {
            mlib_gs_str(d,(uint8_t*)" Bitoffset:");
            mlib_gs_strint(d,(int64_t)((*p).bitoffset));
            mlib_gs_str(d,(uint8_t*)":");
            mlib_gs_strint(d,(int64_t)((*p).bitfieldwidth));
        };
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_u64((*p).uflags.ulength,(uint8_t*)"v");
        msysnewc_m_print_str((uint8_t *)(&(*p).uflags.codes),(uint8_t*)".*");
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,(uint8_t*)" UFLAGS:");
        mlib_gs_str(d,str);
        mlib_gs_str(d,(uint8_t*)"-");
        mlib_gs_strint(d,(int64_t)((*p).uflags.ulength));
        if (!!((*p).code)) {
            mlib_gs_str(d,(uint8_t*)":=");
            mlib_gs_strvar(d,mm_lib_strexpr((*p).code));
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)13)) {
        mlib_gs_str(d,(uint8_t*)"Index:");
        mlib_gs_strint(d,(int64_t)((*p).offset));
    }else if (((int64_t)((*p).nameid)==(int64_t)5)) {
        mlib_gs_str(d,(uint8_t*)"Index:");
        mlib_gs_strint(d,(int64_t)((*p).index));
        mlib_gs_str(d,(uint8_t*)" Nret:");
        mlib_gs_strint(d,(int64_t)((*p).nretvalues));
        mlib_gs_str(d,(uint8_t*)" Simple:");
        mlib_gs_strint(d,(int64_t)((*p).simplefunc));
    }else if (((int64_t)((*p).nameid)==(int64_t)6)) {
        mlib_gs_str(d,(uint8_t*)"Index/PCaddr:");
        mlib_gs_strint(d,(int64_t)((*p).index));
        if (!!((*p).truename)) {
            mlib_gs_str(d,(uint8_t*)" Truename:");
            mlib_gs_str(d,(*p).truename);
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)9)) {
        if (!!((*p).code)) {
            mlib_gs_str(d,(uint8_t*)"=");
            mlib_gs_strvar(d,mm_lib_strexpr((*p).code));
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)10)) {
        if (!!((*p).code)) {
            mlib_gs_str(d,(uint8_t*)":=");
            mlib_gs_strvar(d,mm_lib_strexpr((*p).code));
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)8)) {
        mlib_gs_str(d,(uint8_t*)"Const:");
        mlib_gs_strvar(d,mm_lib_strexpr((*p).code));
    }else if (((int64_t)((*p).nameid)==(int64_t)4)) {
        if (!!((int64_t)((*p).baseclass))) {
            mlib_gs_str(d,(uint8_t*)"Baseclass:");
            mlib_gs_strint(d,(int64_t)((*p).baseclass));
            mlib_gs_str(d,(uint8_t*)":");
            mlib_gs_str(d,mm_lib_typename((int64_t)((*p).baseclass)));
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)14)) {
        mlib_gs_str(d,(uint8_t*)"Enum:");
        mlib_gs_strint(d,(int64_t)((*p).index));
    }else if (((int64_t)((*p).nameid)==(int64_t)3)) {
        mlib_gs_str(d,(uint8_t*)"DLL#:");
        mlib_gs_strint(d,(int64_t)((*p).dllindex));
    };
    if (((int64_t)((*p).at)==(int64_t)2)) {
        mlib_gs_str(d,(uint8_t*)" @");
        mlib_gs_str(d,(*(*p).equivfield).name);
    }else if (((int64_t)((*p).at)==(int64_t)1)) {
        mlib_gs_str(d,(uint8_t*)" @");
        mlib_gs_strvar(d,mm_lib_strexpr((*p).equivvar));
    };
    mlib_gs_str(d,(uint8_t*)" Module# ");
    mlib_gs_strint(d,(int64_t)((*p).moduleno));
    mlib_gs_str(d,(uint8_t*)" Lineno:");
    mlib_gs_strint(d,((int64_t)((*p).lineno) & (int64_t)16777215));
    mlib_gs_println(d,f);
    if (((int64_t)((*p).nameid)==(int64_t)8) || ((int64_t)((*p).nameid)==(int64_t)10) || ((int64_t)((*p).nameid)==(int64_t)9) || ((int64_t)((*p).nameid)==(int64_t)18)) {
        if (!!((*p).code)) {
            mm_diags_printunit((*p).code,(int64_t)0,(uint8_t*)"*",f);
        };
    };
}

void mm_diags_printstflat(void * f) {
    int64_t i;
    struct mm_decls_strec *  p;
    int64_t av_1;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"GLOBAL SYMBOL TABLE:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L463 :;
    for (i=(int64_t)0;i<=(int64_t)32766;i+=(int64_t)1) {
L464 :;
        p = &mm_lex_hashtable[(i)];
        if (!!((*p).name)) {
            if (((int64_t)((*p).symbol)==(int64_t)37)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_ptr(p,NULL);
                msysnewc_m_print_str((uint8_t*)":",NULL);
                msysnewc_m_print_str((*p).name,NULL);
                msysnewc_m_print_str(mm_tables_symbolnames[((int64_t)((*p).symbol))-1],NULL);
                msysnewc_m_print_str(mm_tables_namenames[((int64_t)((*p).nameid))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                p = (*p).nextdupl;
                L467 :;
                while (!!(p)) {
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((uint8_t*)"\t",NULL);
                    msysnewc_m_print_ptr(p,NULL);
                    msysnewc_m_print_str((*p).name,NULL);
                    msysnewc_m_print_str(mm_tables_symbolnames[((int64_t)((*p).symbol))-1],NULL);
                    msysnewc_m_print_str(mm_tables_namenames[((int64_t)((*p).nameid))],NULL);
                    msysnewc_m_print_str((uint8_t*)"(From",NULL);
                    msysnewc_m_print_str((!!((*p).owner)?(*(*p).owner).name:(uint8_t*)"-"),NULL);
                    msysnewc_m_print_nogap();
                    msysnewc_m_print_str((uint8_t*)")",NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    p = (*p).nextdupl;
L468 :;
                }L469 :;
                ;
            };
        };
L465 :;
    }L466 :;
    ;
}

void mm_diags_printcode(void * f,uint8_t * caption) {
    struct mm_decls_strec *  p;
    struct mm_decls_procrec *  pp;
    pp = mm_decls_proclist;
    L470 :;
    while (!!(pp)) {
        p = (*pp).def;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((*p).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)"=",NULL);
        msysnewc_m_print_str(((int64_t)((*p).isglobal)==1?(uint8_t*)"Global":((int64_t)((*p).isglobal)==2?(uint8_t*)"Export":(uint8_t*)"Local")),NULL);
        msysnewc_m_print_end();
        ;
        if (((int64_t)((uint64_t)((*(*p).owner).nameid)) == (int64_t)4)) {
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((uint8_t*)" in record",NULL);
            msysnewc_m_print_str((*(*p).owner).name,NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_diags_printunit((*p).code,(int64_t)0,(uint8_t*)"1",f);
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pp = (*pp).nextproc;
L471 :;
    }L472 :;
    ;
}

void mm_diags_printunit(struct mm_decls_unitrec * p,int64_t level,uint8_t * prefix,void * dev) {
    struct mm_decls_strec *  d;
    int64_t t;
    uint8_t *  idname;
    int64_t a;
    float x32;
    uint8_t *  plus;
    if ((p == 0)) {
        return;
    };
    if (!!((int64_t)((*p).lineno))) {
        mm_diags_currlineno = ((int64_t)((*p).lineno) & (int64_t)16777215);
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_ptr(p,NULL);
    msysnewc_m_print_str((uint8_t*)":",NULL);
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(mm_diags_getprefix(level,prefix,p),NULL);
    msysnewc_m_print_end();
    ;
    idname = (mm_tables_jtagnames[((int64_t)((*p).tag))] + (int64_t)2);
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(idname,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)": ",NULL);
    msysnewc_m_print_end();
    ;
    if (((int64_t)((*p).tag)==(int64_t)3)) {
        d = (*p).def;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(mm_tables_namenames[((int64_t)((*d).nameid))],NULL);
        msysnewc_m_print_end();
        ;
        if (!!((*d).code)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" {",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*(*d).code).tag))],NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)"}",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mm_lib_getdottedname(d),NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((!!((uint64_t)((*p).dottedname))?(uint8_t*)" {Dotted}":(uint8_t*)""),NULL);
        msysnewc_m_print_end();
        ;
        if (!!((*p).c)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" Lastcall:",NULL);
            msysnewc_m_print_ptr((*p).c,NULL);
            msysnewc_m_print_end();
            ;
        };
        if (!!((int64_t)((*p).addroffirst))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" Addroffirst.",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)" Moduleno:",NULL);
        msysnewc_m_print_i64((*p).moduleno,NULL);
        msysnewc_m_print_end();
        ;
        if (!!((uint64_t)((*p).avcode))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" AV:",NULL);
            msysnewc_m_print_c8((uint8_t)((*p).avcode),NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((int64_t)((*p).tag)==(int64_t)218)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*(*p).def).name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)1) || ((int64_t)((*p).tag)==(int64_t)250)) {
        t = (int64_t)((*p).mode);
        a = (*p).value;
        if ((t == mm_tables_trefchar)) {
            if (((int64_t)((*p).slength) > (int64_t)256)) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((uint8_t*)"\"",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((uint8_t*)"(LONGSTR)",NULL);
                msysnewc_m_print_str((uint8_t*)"\" *",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            } else if (!!((int64_t)((*p).slength))) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((uint8_t*)"\"",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((*p).svalue,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((uint8_t*)"\" *",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((uint8_t*)"\"\"",NULL);
                msysnewc_m_print_end();
                ;
            };
        } else {
            if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)4) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)3) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)2) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)1)) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_i64(a,NULL);
                msysnewc_m_print_end();
                ;
            }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)9) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)8) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)7) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)6)) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_u64((uint64_t)(a),NULL);
                msysnewc_m_print_end();
                ;
            }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)15) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)13) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)14)) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str(mlib_chr(a),NULL);
                msysnewc_m_print_end();
                ;
            }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)11)) {
                x32 = (float)((*p).xvalue);
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_r64((double)(x32),NULL);
                msysnewc_m_print_end();
                ;
            }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)12)) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_r64((*p).xvalue,NULL);
                msysnewc_m_print_end();
                ;
            }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)19)) {
                if (!!((*p).value)) {
                    msysnewc_m_print_startfile(dev);
                    msysnewc_m_print_str((uint8_t*)"#",NULL);
                    msysnewc_m_print_nogap();
                    msysnewc_m_print_i64((*p).value,NULL);
                    msysnewc_m_print_i64((*p).slength,NULL);
                    msysnewc_m_print_end();
                    ;
                } else {
                    msysnewc_m_print_startfile(dev);
                    msysnewc_m_print_str((uint8_t*)"NIL",NULL);
                    msysnewc_m_print_end();
                    ;
                };
            }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)5)) {
//                msysnewc_m_print_startfile(dev);
//                msysnewc_m_print_i128((*(*p).pvalue128),NULL);
//                msysnewc_m_print_end();
                ;
            }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)10)) {
//                msysnewc_m_print_startfile(dev);
//                msysnewc_m_print_u128((*(*p).puvalue128),NULL);
//                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"TYPENAME(T)=",NULL);
                msysnewc_m_print_str(mm_lib_typename(t),NULL);
                msysnewc_m_print_str(mm_lib_typename((int64_t)(mm_decls_ttbasetype[(t)])),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((uint8_t*)"<PRINTUNIT BAD CONST PROBABLY VOID",NULL);
                msysnewc_m_print_end();
                ;
            };
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mm_lib_typename(t),NULL);
        msysnewc_m_print_end();
        ;
        if (!!((int64_t)((*p).isastring))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" <isstr>",NULL);
            msysnewc_m_print_end();
            ;
        };
        if (!!((int64_t)((*p).whenlabel))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" *L",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*p).whenlabel,NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((int64_t)((*p).tag)==(int64_t)6)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*p).svalue,NULL);
        msysnewc_m_print_str((uint8_t*)"Len:",NULL);
        msysnewc_m_print_i64((*p).slength,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)106)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(mm_lib_typename((int64_t)((*p).mode)),NULL);
        msysnewc_m_print_str(mm_lib_typename((*p).value),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)107)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((mm_tables_jtagnames[((int64_t)((*p).opcode))] + (int64_t)2),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)142)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((mm_tables_bitfieldnames[((int64_t)((*p).opcode))-1] + (int64_t)3),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)102) || ((int64_t)((*p).tag)==(int64_t)105)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(mm_tables_convnames[((int64_t)((*p).opcode))],NULL);
        msysnewc_m_print_str((uint8_t*)" to:",NULL);
        msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).newmode),(int64_t)1),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)19) || ((int64_t)((*p).tag)==(int64_t)25)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)"Len:",NULL);
        msysnewc_m_print_i64((*p).length,NULL);
        msysnewc_m_print_str((uint8_t*)" Makeax:",NULL);
        msysnewc_m_print_i64((*p).makearray,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)95)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)"Offset:",NULL);
        msysnewc_m_print_i64((*p).offset,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)88) || ((int64_t)((*p).tag)==(int64_t)99)) {
    }else if (((int64_t)((*p).tag)==(int64_t)222) || ((int64_t)((*p).tag)==(int64_t)220) || ((int64_t)((*p).tag)==(int64_t)219) || ((int64_t)((*p).tag)==(int64_t)221)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)"#",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64((*p).index,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)204)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((mm_tables_sysfnnames[((int64_t)((*p).opcode))-1] + (int64_t)6),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)7)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((mm_mcldecls_mclnames[((int64_t)((*p).index))-1] + (int64_t)2),NULL);
        msysnewc_m_print_end();
        ;
        if ((((*p).index == (int64_t)22) || ((*p).index == (int64_t)54) || ((*p).index == (int64_t)12))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" ",NULL);
            msysnewc_m_print_str(mm_mcldecls_condnames[((int64_t)((*p).cond))],NULL);
            msysnewc_m_print_str((uint8_t*)"P.COND=",NULL);
            msysnewc_m_print_u64((*p).cond,NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((int64_t)((*p).tag)==(int64_t)9)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(mm_mcldecls_regnames[((int64_t)((*p).reg))],NULL);
        msysnewc_m_print_str((uint8_t*)"size:",NULL);
        msysnewc_m_print_u64((*p).regsize,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)10)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(mm_mcldecls_xmmregnames[((int64_t)((*p).reg))-1],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)11)) {
        plus = (uint8_t*)"";
        if (!!((uint64_t)((*p).prefixmode))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).prefixmode),(int64_t)1),NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)"[",NULL);
        msysnewc_m_print_end();
        ;
        if (!!((uint64_t)((*p).reg))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str(mm_mcldecls_regnames[((int64_t)((*p).reg))],NULL);
            msysnewc_m_print_end();
            ;
            plus = (uint8_t*)"+";
        };
        if (!!((uint64_t)((*p).regix))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str(plus,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(mm_mcldecls_regnames[((int64_t)((*p).regix))],NULL);
            msysnewc_m_print_end();
            ;
        };
        if (((int64_t)((uint64_t)((*p).scale)) > (int64_t)1)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)"*",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_u64((*p).scale,NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)"]",NULL);
        msysnewc_m_print_end();
        ;
    };
    if (!!((int64_t)((*p).isconst))) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)" Is const",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_diags_printunitlist(dev,(*p).a,(level + (int64_t)1),(uint8_t*)"1");
    mm_diags_printunitlist(dev,(*p).b,(level + (int64_t)1),(uint8_t*)"2");
    if (((int64_t)((*p).tag) != (int64_t)1)) {
        mm_diags_printunitlist(dev,(*p).c,(level + (int64_t)1),(uint8_t*)"3");
    };
}

static void mm_diags_printunitlist(void * dev,struct mm_decls_unitrec * p,int64_t level,uint8_t * prefix) {
    if ((p == 0)) {
        return;
    };
    L473 :;
    while (!!(p)) {
        mm_diags_printunit(p,level,prefix,dev);
        p = (*p).nextunit;
L474 :;
    }L475 :;
    ;
}

static uint8_t * mm_diags_getprefix(int64_t level,uint8_t * prefix,struct mm_decls_unitrec * p) {
    static uint8_t str[1024];
    uint8_t indentstr[1024];
    uint8_t modestr[16384];
    uint8_t *  isexpr;
    int64_t av_1;
    indentstr[((int64_t)1)-1] = (uint64_t)0u;
    if ((level > (int64_t)10)) {
        level = (int64_t)10;
    };
    av_1 = level;
    while (av_1-- > 0) {
L476 :;
        strcat((int8_t *)(indentstr),(int8_t *)((uint8_t*)"- "));
L477 :;
    }L478 :;
    ;
    isexpr = (uint8_t*)"S";
    if (!!((uint64_t)(mm_tables_jisexpr[((int64_t)((*p).tag))]))) {
        isexpr = (uint8_t*)"E";
    };
    if (((int64_t)((*p).tag)==(int64_t)209) || ((int64_t)((*p).tag)==(int64_t)226) || ((int64_t)((*p).tag)==(int64_t)224) || ((int64_t)((*p).tag)==(int64_t)229)) {
        if (((int64_t)((*p).mode) == (int64_t)0)) {
            isexpr = (uint8_t*)"S";
        };
    };
    msysnewc_m_print_startstr(modestr);
    msysnewc_m_print_setfmt((uint8_t*)"# #:#");
    msysnewc_m_print_str(isexpr,NULL);
    msysnewc_m_print_str((!!((int64_t)((*p).popflag))?(uint8_t*)"POP":(uint8_t*)"---"),NULL);
    msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).mode),(int64_t)1),NULL);
    msysnewc_m_print_end();
    ;
    modestr[((int64_t)256)-1] = (uint64_t)0u;
    strcat((int8_t *)(modestr),(int8_t *)((uint8_t*)"-----------------------------"));
    modestr[((int64_t)17)-1] = ' ';
    modestr[((int64_t)18)-1] = (uint64_t)0u;
    strcpy((int8_t *)(str),(int8_t *)(mm_diags_getlineinfok()));
    strcat((int8_t *)(str),(int8_t *)(modestr));
    strcat((int8_t *)(str),(int8_t *)(indentstr));
    strcat((int8_t *)(str),(int8_t *)(prefix));
    if (!!((uint64_t)((*prefix)))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" "));
    };
    return str;
}

static uint8_t * mm_diags_getlineinfok(void) {
    static uint8_t str[40];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_i64(mm_diags_currlineno,(uint8_t*)"z4");
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)" ",NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

void mm_genwx64_do_codegen_debug(void) {
    if ((mm_decls_passlevel >= (int64_t)4)) {
        mm_genpcl_codegen_pcl();
        if (!!(mm_decls_fshowpcl1)) {
            mm_genwx64_showpcl((uint8_t*)"PCL");
        };
    };
    if ((mm_decls_passlevel >= (int64_t)5)) {
        mm_genmcl_codegen_mcl();
        if (!!(mm_decls_fshowmcl1)) {
            mm_genwx64_showmcl(mm_decls_outfilesource);
        };
    };
    if ((mm_decls_passlevel >= (int64_t)6)) {
        ma_genss_genss();
        ma_writeexe_initsectiontable();
        if (!!(mm_decls_fshowss)) {
            mm_genwx64_showss((uint8_t*)"SS",(int64_t)0);
        };
        if (!!(mlib_eqstring(mm_decls_linkoption,(uint8_t*)"obj"))) {
            if (!!(mm_decls_fshowss)) {
                mm_genwx64_showss((uint8_t*)"SS",(int64_t)0);
            };
            ma_writeobj_writess(mm_decls_outfilebin);
        } else {
            ma_writeexe_genexe((uint8_t *)(0));
            if (!!(mm_decls_fshowss)) {
                mm_genwx64_showss((uint8_t*)"SS",(int64_t)1);
            };
            ma_writeexe_writeexe(mm_decls_outfilebin);
        };
    };
}

void mm_genwx64_do_codegen(void) {
    mm_genpcl_codegen_pcl();
    mm_start_stoptimer((uint8_t*)"PCL");
    mm_genmcl_codegen_mcl();
    mm_start_stoptimer((uint8_t*)"MCL");
    if ((mm_decls_cc_mode >= (int64_t)2)) {
        ma_genss_genss();
        mm_start_stoptimer((uint8_t*)"GENSS");
        ma_writeexe_initsectiontable();
        if (!!(mlib_eqstring(mm_decls_linkoption,(uint8_t*)"obj"))) {
            ma_writeobj_writess(mm_decls_outfilebin);
        } else {
            ma_writeexe_genexe((uint8_t *)(0));
            mm_start_stoptimer((uint8_t*)"GENEXE");
            ma_writeexe_writeexe(mm_decls_outfilebin);
            mm_start_stoptimer((uint8_t*)"WRITEEXE");
        };
    } else {
        mm_genwx64_showmcl(mm_decls_outfilesource);
    };
}

void mm_genwx64_showpcl(uint8_t * filename) {
    struct mlib_strbuffer *  pclstr;
    mlib_gs_init(mm_lib_dest);
    pclstr = mm_libpcl_writepclcode(filename);
    mm_genwx64_writegsfile(filename,pclstr);
}

void mm_genwx64_showmcl(uint8_t * filename) {
    struct mlib_strbuffer *  mclstr;
    mlib_gs_init(mm_lib_dest);
    mclstr = mm_libmcl_writemclcode(filename);
    mm_genwx64_writegsfile(filename,mclstr);
}

void mm_genwx64_showss(uint8_t * filename,int64_t fexe) {
    struct mlib_strbuffer *  ssstr;
    mlib_gs_init(mm_lib_dest);
    ssstr = ma_writeexe_writessdata(fexe);
    mm_genwx64_writegsfile(filename,ssstr);
}

static void mm_genwx64_writegsfile(uint8_t * filename,struct mlib_strbuffer * d) {
    void *  f;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"w"));
    mlib_gs_println(d,f);
    fclose(f);
}

void mm_genwx64_showhelp(void) {
    static uint8_t *  helptext = (uint8_t*)"'MM' Mosaic Compiler Generating x64 native code - Windows Version\r\n\r\nWhole-program compiler builds entire program from the lead module\r\ninto a executable file.\r\n\r\n    mm main              # Create main.exe from lead module main.m\r\n    mm main.m            # Same (.m extension is default)\r\n    mm -c main           # Create single-file main.asm intermediate ASM\r\n\r\nOptions:\r\n\r\n    -c                    # Generate only intermediate ASM file only\r\n    -exe                  # Generate .exe executable file\r\n    -obj                  # Generate single .obj object file\r\n\r\n    -out:file             # Name of output file \r\n\r\n    -run                  # For -exe mode only: run resulting executable\r\n\r\n    @file                 # Read options from file\r\n\r\nExample:\r\n\r\n     mm -run prog : abc def\r\n\r\nAny parameters for the new program must follow \" : \" (spaces needed).\r\n";
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(helptext,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void mm_genwx64_initassemsymbols(void) {
    uint8_t str[32];
    int64_t i;
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    int64_t av_4;
    int64_t av_5;
    int64_t av_6;
    int64_t av_7;
    int64_t av_8;
    int64_t av_9;
    L479 :;
    for (i=(int64_t)1;i<=(int64_t)143;i+=(int64_t)1) {
L480 :;
        mm_lex_addreservedword((mm_mcldecls_mclnames[(i)-1] + (int64_t)2),(int64_t)60,i,(int64_t)0);
L481 :;
    }L482 :;
    ;
    L483 :;
    for (i=(int64_t)1;i<=(int64_t)136;i+=(int64_t)1) {
L484 :;
        mm_lex_addreservedword(mm_mcldecls_dregnames[(i)-1],(int64_t)52,(int64_t)(mm_mcldecls_regindices[(i)-1]),(int64_t)(mm_mcldecls_regsizes[(i)-1]));
L485 :;
    }L486 :;
    ;
    L487 :;
    for (i=(int64_t)1;i<=(int64_t)16;i+=(int64_t)1) {
L488 :;
        mm_lex_addreservedword(mm_mcldecls_xmmregnames[(i)-1],(int64_t)53,i,(int64_t)0);
L489 :;
    }L490 :;
    ;
    L491 :;
    for (i=(int64_t)1;i<=(int64_t)8;i+=(int64_t)1) {
L492 :;
        mm_lex_addreservedword(mm_mcldecls_fregnames[(i)-1],(int64_t)54,i,(int64_t)0);
L493 :;
    }L494 :;
    ;
    L495 :;
    for (i=(int64_t)1;i<=(int64_t)8;i+=(int64_t)1) {
L496 :;
        mm_lex_addreservedword(mm_mcldecls_mregnames[(i)-1],(int64_t)55,i,(int64_t)0);
L497 :;
    }L498 :;
    ;
    L499 :;
    for (i=(int64_t)1;i<=(int64_t)18;i+=(int64_t)1) {
L500 :;
        mm_lex_addreservedword(mm_mcldecls_jmpccnames[(i)-1],(int64_t)56,(int64_t)(mm_mcldecls_jmpcccodes[(i)-1]),(int64_t)0);
L501 :;
    }L502 :;
    ;
    L503 :;
    for (i=(int64_t)1;i<=(int64_t)18;i+=(int64_t)1) {
L504 :;
        mm_lex_addreservedword(mm_mcldecls_setccnames[(i)-1],(int64_t)57,(int64_t)(mm_mcldecls_setcccodes[(i)-1]),(int64_t)0);
L505 :;
    }L506 :;
    ;
    L507 :;
    for (i=(int64_t)1;i<=(int64_t)18;i+=(int64_t)1) {
L508 :;
        mm_lex_addreservedword(mm_mcldecls_cmovccnames[(i)-1],(int64_t)58,(int64_t)(mm_mcldecls_cmovcccodes[(i)-1]),(int64_t)0);
L509 :;
    }L510 :;
    ;
    L511 :;
    for (i=(int64_t)1;i<=(int64_t)5;i+=(int64_t)1) {
L512 :;
        strcpy((int8_t *)(str),(int8_t *)(mm_mcldecls_segmentnames[(i)]));
        str[(((int64_t)(strlen((int8_t *)(str))) - (int64_t)3))-1] = (uint64_t)0u;
        mm_lex_addreservedword(mlib_pcm_copyheapstring(str),(int64_t)59,i,(int64_t)0);
L513 :;
    }L514 :;
    ;
    mm_lex_addreservedword((uint8_t*)"aframe",(int64_t)52,(int64_t)15,(int64_t)4);
    mm_lex_addreservedword((uint8_t*)"dframe",(int64_t)52,(int64_t)15,(int64_t)8);
    mm_lex_addreservedword((uint8_t*)"astack",(int64_t)52,(int64_t)16,(int64_t)4);
    mm_lex_addreservedword((uint8_t*)"dstack",(int64_t)52,(int64_t)16,(int64_t)8);
    mm_lex_addreservedword((uint8_t*)"dprog",(int64_t)52,(int64_t)9,(int64_t)8);
    mm_lex_addreservedword((uint8_t*)"dsptr",(int64_t)52,(int64_t)10,(int64_t)8);
}

static void mm_genwx64_addsearchlib(uint8_t * name) {
    int64_t i;
    L515 :;
    for (i=(int64_t)1;i<=mm_genwx64_nsearchlibs;i+=(int64_t)1) {
L516 :;
        if (!!(mlib_eqstring(mm_genwx64_searchlibs[(i)-1],name))) {
            return;
        };
L517 :;
    }L518 :;
    ;
    if ((mm_genwx64_nsearchlibs >= (int64_t)100)) {
        mm_support_loaderror((uint8_t*)"Too many LIB files",(uint8_t*)"",(uint8_t*)"");
    };
    mm_genwx64_searchlibs[(++mm_genwx64_nsearchlibs)-1] = mlib_pcm_copyheapstring(mlib_changeext(name,(uint8_t*)""));
}

int64_t mm_genpcl_codegen_pcl(void) {
    struct mm_decls_strec *  d;
    struct mm_decls_procrec *  pp;
    mm_libpcl_pclinit();
    pp = mm_decls_staticlist;
    L519 :;
    while (!!(pp)) {
        d = (*pp).def;
        mm_genpcl_dostaticvar(d);
        pp = (*pp).nextproc;
L520 :;
    }L521 :;
    ;
    mm_libpcl_genpc((int64_t)2,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_genpc((int64_t)219,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_genpcl_geninitproc();
    pp = mm_decls_proclist;
    L522 :;
    while (!!(pp)) {
        mm_genpcl_genprocdef((mm_decls_currproc = (*pp).def));
        pp = (*pp).nextproc;
L523 :;
    }L524 :;
    ;
    mm_libpcl_allpclcode = mm_libpcl_pccode;
    return (int64_t)1;
}

static void mm_genpcl_genprocdef(struct mm_decls_strec * p) {
    uint8_t str[256];
    uint8_t name[256];
    int64_t paramoffset;
    int64_t nparams;
    int64_t retaddrbytes;
    struct mm_decls_strec *  d;
    int64_t n;
    int64_t lab;
    int64_t isstart;
    int64_t isfloat;
    int64_t hasparams;
    int64_t hasequiv;
    strcpy((int8_t *)(name),(int8_t *)((*p).name));
    mlib_convucstring(name);
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"PROC # #");
    msysnewc_m_print_str(name,NULL);
    msysnewc_m_print_str((uint8_t*)"=",(uint8_t*)"60P=");
    msysnewc_m_print_end();
    ;
    mm_libpcl_gencomment(str);
    mm_decls_currproc = p;
    mm_libpcl_frameoffset = (int64_t)0;
    hasparams = (int64_t)0;
    hasequiv = (int64_t)0;
    d = (*p).deflist;
    L525 :;
    while (!!(d)) {
        if (((int64_t)((*d).nameid)==(int64_t)10)) {
            if (!!((uint64_t)((*d).at))) {
                hasequiv = (int64_t)1;
            } else {
                mm_libpcl_frameoffset -= mm_libpcl_roundsizetg((int64_t)(mm_decls_ttsize[((int64_t)((*d).mode))]));
                (*d).offset = mm_libpcl_frameoffset;
            };
        }else if (((int64_t)((*d).nameid)==(int64_t)11)) {
            hasparams = (int64_t)1;
        };
        d = (*d).nextdef;
L526 :;
    }L527 :;
    ;
    if (!!(hasequiv)) {
        d = (*p).deflist;
        L528 :;
        while (!!(d)) {
            if (((int64_t)((*d).nameid)==(int64_t)10)) {
                if (!!((uint64_t)((*d).at))) {
                    (*d).offset = mm_genpcl_getconstframeoffset((*d).equivvar);
                };
            };
            d = (*d).nextdef;
L529 :;
        }L530 :;
        ;
    };
    nparams = (int64_t)0;
    d = (*p).deflist;
    retaddrbytes = ((!!(mm_libpcl_frameoffset) || !!(hasparams))?(int64_t)16:(int64_t)8);
    paramoffset = (int64_t)0;
    L531 :;
    while (!!(d)) {
        if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)11)) {
            (*d).offset = (paramoffset + retaddrbytes);
            if (((int64_t)(mm_decls_ttsize[((int64_t)((*d).mode))]) == (int64_t)16)) {
                paramoffset += (int64_t)16;
            } else {
                paramoffset += (int64_t)8;
            };
            ++nparams;
        };
        d = (*d).nextdef;
L532 :;
    }L533 :;
    ;
    mm_libpcl_framebytes = -(mm_libpcl_frameoffset);
    mm_libpcl_parambytes = paramoffset;
    mm_libpcl_iscallbackproc = mm_lib_iscallbackfn(p);
    n = (mm_decls_targetsize - (int64_t)1);
    L534 :;
    while (!!((mm_libpcl_framebytes & n))) {
        ++mm_libpcl_framebytes;
        --mm_libpcl_frameoffset;
L535 :;
    }L536 :;
    ;
    L537 :;
    while (!!((mm_libpcl_parambytes & n))) {
        ++mm_libpcl_parambytes;
L538 :;
    }L539 :;
    ;
    isstart = (int64_t)0;
    if ((!!((uint64_t)((*p).isglobal)) && (!!(mlib_eqstring((*p).name,(uint8_t*)"start")) || !!(mlib_eqstring((*p).name,(uint8_t*)"main"))))) {
        isstart = (int64_t)1;
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((*p).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)"::",NULL);
        msysnewc_m_print_end();
        ;
        mm_libpcl_genpc((int64_t)4,mm_libpcl_genstrimm(str,(int64_t)-1),(struct mm_libpcl_pclopndrec *)(0));
        (*p).index = mm_decls_labelno;
    };
    mm_genpcl_genprocentry(mm_libpcl_framebytes,mm_libpcl_parambytes,isstart);
    if (!!((uint64_t)((*p).asmused))) {
        d = (*p).deflist;
        L540 :;
        while (!!(d)) {
            if (((int64_t)((*d).nameid)==(int64_t)10) || ((int64_t)((*d).nameid)==(int64_t)11)) {
                mm_genpcl_genframedef(d);
            };
            d = (*d).nextdef;
L541 :;
        }L542 :;
        ;
    };
    if (!!(isstart)) {
        mm_libpcl_do_syscallproc((int64_t)21,(int64_t)0,(int64_t)0);
        mm_libpcl_genpc((int64_t)57,mm_libpcl_genlabel(mm_libpcl_initstaticsindex,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    };
    d = (*p).deflist;
    L543 :;
    while (!!(d)) {
        if ((((int64_t)((uint64_t)((*d).nameid)) == (int64_t)10) && !!((uint64_t)(mm_decls_ttisvar[((int64_t)((*d).mode))])))) {
            mm_genpcl_initframedef(d);
        };
        d = (*d).nextdef;
L544 :;
    }L545 :;
    ;
    mm_libpcl_retindex = (lab = mm_libpcl_createfwdlabel());
    mm_libpcl_gencomment((uint8_t*)"-------------------------------------------------");
    mm_blockpcl_evalunit((*p).code);
    if ((((int64_t)((*p).mode) != (int64_t)0) && ((int64_t)((uint64_t)((*p).nretvalues)) < (int64_t)2))) {
        isfloat = (int64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]);
        if (!!(isfloat)) {
            mm_libpcl_makefloatopnds();
        };
        if (!!((uint64_t)((*mm_decls_currproc).simplefunc))) {
            mm_libpcl_genpc((int64_t)39,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        } else {
            mm_libpcl_genpc((int64_t)38,mm_libpcl_genint(mm_libpcl_parambytes,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        };
        mm_libpcl_setpclcat_u((*p).code);
        if (!!(isfloat)) {
            mm_libpcl_makefloatopnds();
        };
    };
    mm_libpcl_definefwdlabel(mm_libpcl_retindex);
    mm_libpcl_gencomment((uint8_t*)"-------------------------------------------------");
    d = (*p).deflist;
    L546 :;
    while (!!(d)) {
        if (((((*d).nameid == (int64_t)10) || ((*d).nameid == (int64_t)11)) && (mm_lib_gettypecat_t((int64_t)((*d).mode)) == (int64_t)33))) {
            mm_genpcl_freeframevar(d);
        };
        d = (*d).nextdef;
L547 :;
    }L548 :;
    ;
    if (!!(isstart)) {
        mm_libpcl_pushstack((int64_t)32);
        mm_libpcl_genpc((int64_t)22,mm_libpcl_zero_opnd,(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_do_syscallproc((int64_t)22,(int64_t)1,(int64_t)0);
    } else {
        mm_libpcl_genreturn(mm_libpcl_framebytes,mm_libpcl_parambytes);
    };
    if (((int64_t)((*p).mode) != (int64_t)0)) {
        if (!(!!(mm_lib_checkblockreturn((*p).code)))) {
            mm_support_gerror_s((uint8_t*)"Function needs explicit return: ",(*p).name,(struct mm_decls_unitrec *)(0));
        };
    };
    mm_libpcl_gencomment((uint8_t*)"");
}

static void mm_genpcl_genprocentry(int64_t fbytes,int64_t pbytes,int64_t isstart) {
    mm_libpcl_genpc((int64_t)5,mm_libpcl_genmemaddr_d(mm_decls_currproc),mm_libpcl_genint(pbytes,(int64_t)8));
    (*mm_libpcl_pccodex).b.fbytes = fbytes;
    (*mm_libpcl_pccodex).isglobal = (uint64_t)(isstart);
}

static void mm_genpcl_genframedef(struct mm_decls_strec * d) {
    mm_libpcl_gencomment((uint8_t*)"GENFRAMEDEF");
}

static void mm_genpcl_dostaticvar(struct mm_decls_strec * d) {
    struct mm_decls_unitrec *  p;
    if (!!((uint64_t)((*d).imported))) {
        return;
    };
    if (((int64_t)((uint64_t)((*d).at)) == (int64_t)1)) {
        p = (*d).equivvar;
        if (((int64_t)((*p).tag)==(int64_t)100)) {
            mm_libpcl_genpc((int64_t)13,mm_libpcl_genmem_d(d,(int64_t)0),mm_libpcl_genmem_u((*p).a,(int64_t)0));
        }else if (((int64_t)((*p).tag)==(int64_t)1)) {
            mm_libpcl_genpc((int64_t)13,mm_libpcl_genmem_d(d,(int64_t)0),mm_libpcl_genint((*p).value,(int64_t)8));
        } else {
            mm_diags_printunit(p,(int64_t)0,(uint8_t*)"*",0);
            mm_support_gerror((uint8_t*)"equiv/not simple",(struct mm_decls_unitrec *)(0));
        };
    } else if (!!((*d).code)) {
        if (((int64_t)((uint64_t)(mm_tables_stdtypecat[((int64_t)(mm_decls_ttbasetype[((int64_t)((*d).mode))]))])) != (int64_t)33)) {
            mm_libpcl_genpc((int64_t)11,mm_libpcl_genmem_d(d,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
            (*mm_libpcl_pccodex).align = mm_lib_getalignment((int64_t)((*d).mode));
            mm_genpcl_genidata((*d).code,(int64_t)1,(int64_t)65);
        } else {
            goto L549 ;
;
        };
    } else {
        //dozstatic:
L549 :;
;
        mm_libpcl_genpc((int64_t)12,mm_libpcl_genmem_d(d,(int64_t)0),mm_libpcl_genint((int64_t)(mm_decls_ttsize[((int64_t)((*d).mode))]),(int64_t)8));
        (*mm_libpcl_pccodex).align = mm_lib_getalignment((int64_t)((*d).mode));
    };
}

static void mm_genpcl_dostaticvariant(struct mm_decls_strec * d) {
    if ((!!((uint64_t)((*d).imported)) || ((int64_t)((uint64_t)((*d).at)) == (int64_t)1))) {
        return;
    };
    if (!(!!((uint64_t)(mm_decls_ttisvar[((int64_t)((*d).mode))])))) {
        return;
    };
    if (!!((*d).code)) {
        mm_blockpcl_evalunit((*d).code);
        mm_libpcl_genpc((int64_t)32,mm_libpcl_genmem_d(d,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)29);
    } else {
        mm_libpcl_genpc((int64_t)41,mm_libpcl_genmemaddr_d(d),(struct mm_libpcl_pclopndrec *)(0));
        (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)33);
    };
}

static void mm_genpcl_genidata(struct mm_decls_unitrec * p,int64_t doterm,int64_t am) {
    int64_t t;
    int64_t tbase;
    struct mm_decls_unitrec *  q;
    struct mm_decls_strec *  d;
    struct mm_libpcl_pclopndrec *  ax;
    t = (int64_t)((*p).mode);
    mm_decls_mlineno = (int64_t)((*p).lineno);
    tbase = (int64_t)(mm_decls_ttbasetype[(t)]);
    if (((int64_t)((*p).tag)==(int64_t)1)) {
        if (!!((uint64_t)(mm_decls_ttisref[((int64_t)((*p).mode))]))) {
            if (((int64_t)((*p).mode) == mm_tables_trefchar)) {
                if (!!((*p).svalue)) {
                    mm_libpcl_genpc((int64_t)225,mm_libpcl_genstrimm((*p).svalue,(int64_t)((*p).slength)),(struct mm_libpcl_pclopndrec *)(0));
                } else {
                    mm_libpcl_genpc((int64_t)225,mm_libpcl_genint((int64_t)0,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
                };
            } else {
                mm_libpcl_genpc((int64_t)225,mm_libpcl_genint((*p).value,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
            };
        } else if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
            if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])==(int64_t)4)) {
                mm_libpcl_genpc((int64_t)224,mm_libpcl_genreal((*p).xvalue,(int64_t)4),(struct mm_libpcl_pclopndrec *)(0));
            }else if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])==(int64_t)8)) {
                mm_libpcl_genpc((int64_t)225,mm_libpcl_genreal((*p).xvalue,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
            } else {
                mm_support_gerror_s((uint8_t*)"IDATA/REAL:%s",mm_lib_strmode((int64_t)((*p).mode),(int64_t)1),p);
            };
        } else {
            ax = mm_libpcl_genint((*p).value,(int64_t)8);
            if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])==(int64_t)1)) {
                mm_libpcl_genpc((int64_t)222,ax,(struct mm_libpcl_pclopndrec *)(0));
            }else if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])==(int64_t)2)) {
                mm_libpcl_genpc((int64_t)223,ax,(struct mm_libpcl_pclopndrec *)(0));
            }else if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])==(int64_t)4)) {
                mm_libpcl_genpc((int64_t)224,ax,(struct mm_libpcl_pclopndrec *)(0));
            }else if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])==(int64_t)8)) {
                mm_libpcl_genpc((int64_t)225,ax,(struct mm_libpcl_pclopndrec *)(0));
            }else if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])==(int64_t)16)) {
                mm_libpcl_genpc((int64_t)225,mm_libpcl_genint((int64_t)(mm_lib_getlow128((*p).pvalue128)),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
                mm_libpcl_genpc((int64_t)225,mm_libpcl_genint((int64_t)(mm_lib_gethigh128((*p).pvalue128)),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
            } else {
                mm_support_gerror_s((uint8_t*)"IDATA/INT:%s",mm_lib_strmode((int64_t)((*p).mode),(int64_t)1),p);
            };
        };
    }else if (((int64_t)((*p).tag)==(int64_t)19)) {
        q = (*p).a;
        L550 :;
        while (!!(q)) {
            mm_genpcl_genidata(q,(int64_t)1,(int64_t)65);
            q = (*q).nextunit;
L551 :;
        }L552 :;
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)3)) {
        d = (*p).def;
        if (((int64_t)((*d).nameid)==(int64_t)9) || ((int64_t)((*d).nameid)==(int64_t)5) || ((int64_t)((*d).nameid)==(int64_t)6)) {
            mm_libpcl_genpc((((am == (int64_t)80) || ((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) == (int64_t)8))?(int64_t)225:(int64_t)224),mm_libpcl_genmemaddr_d(d),(struct mm_libpcl_pclopndrec *)(0));
        } else {
            mm_support_gerror((uint8_t*)"Idata &frameXXX",(struct mm_decls_unitrec *)(0));
        };
        return;
    }else if (((int64_t)((*p).tag)==(int64_t)102)) {
        mm_genpcl_genidata((*p).a,(int64_t)1,(int64_t)65);
    }else if (((int64_t)((*p).tag)==(int64_t)100)) {
        mm_genpcl_genidata((*p).a,(int64_t)1,(int64_t)80);
    } else {
        mm_support_gerror_s((uint8_t*)"IDATA: %s",mm_tables_jtagnames[((int64_t)((*p).tag))],p);
    };
}

static void mm_genpcl_geninitproc(void) {
    struct mm_decls_procrec *  pp;
    struct mm_decls_strec *  d;
    int64_t i;
    mm_libpcl_gencomment((uint8_t*)"proc ---------------- m$initstatics");
    mm_libpcl_initstaticsindex = mm_libpcl_definelabel();
    (*mm_libpcl_pccodex).b.fbytes = (int64_t)0;
    (*mm_libpcl_pccodex).isglobal = (uint64_t)((int64_t)1);
    mm_libpcl_gencomment((uint8_t*)"INIT CODE GOES HERE");
    pp = mm_decls_staticlist;
    L553 :;
    while (!!(pp)) {
        d = (*pp).def;
        mm_genpcl_dostaticvariant(d);
        pp = (*pp).nextproc;
L554 :;
    }L555 :;
    ;
    mm_libpcl_gencomment((uint8_t*)"-------------------------------------------------");
    L556 :;
    for (i=mm_decls_nmodules;i>=(int64_t)1;i-=(int64_t)1) {
L557 :;
        d = mm_decls_moduletable[(i)].stinitproc;
        if (!!(d)) {
            mm_libpcl_genpc((int64_t)57,mm_libpcl_genmemaddr_d(d),mm_libpcl_genint((int64_t)0,(int64_t)8));
        };
L558 :;
    }L559 :;
    ;
    mm_libpcl_genpc((int64_t)58,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_gencomment((uint8_t*)"");
}

static void mm_genpcl_initframedef(struct mm_decls_strec * d) {
    mm_libpcl_genpc((int64_t)41,mm_libpcl_genmem_d(d,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_t((int64_t)33);
}

static void mm_genpcl_freeframevar(struct mm_decls_strec * d) {
    mm_libpcl_genpc((int64_t)42,mm_libpcl_genmem_d(d,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_t((int64_t)33);
}

static int64_t mm_genpcl_getconstframeoffset(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  a;
    struct mm_decls_strec *  d;
    int64_t offset;
    a = (*p).a;
    d = (struct mm_decls_strec *)(0);
    offset = (int64_t)0;
    if (((int64_t)((*p).tag)==(int64_t)100) || ((int64_t)((*p).tag)==(int64_t)101)) {
        if (((int64_t)((*a).tag) == (int64_t)3)) {
            d = (*a).def;
        };
    }else if (((int64_t)((*p).tag)==(int64_t)43)) {
        if (((((int64_t)((*a).tag) == (int64_t)101) && ((int64_t)((*(*a).a).tag) == (int64_t)3)) && ((int64_t)((*(*p).b).tag) == (int64_t)1))) {
            d = (*(*a).a).def;
            offset = (*(*p).b).value;
        };
    };
    if ((d == 0)) {
        mm_diags_printunit(p,(int64_t)0,(uint8_t*)"*",0);
        mm_support_gerror((uint8_t*)"Can't do @Frame var",(struct mm_decls_unitrec *)(0));
    };
    if (!((((*d).nameid == (int64_t)10) || ((*d).nameid == (int64_t)11)))) {
        mm_support_gerror((uint8_t*)"@ local static",(struct mm_decls_unitrec *)(0));
    };
    return ((int64_t)((*d).offset) + offset);
}

void mm_libpcl_pclinit(void) {
    mm_libpcl_Dzero_opnd = (*mm_libpcl_genint((int64_t)0,(int64_t)8));
    mm_libpcl_zero_opnd = &mm_libpcl_Dzero_opnd;
    mm_libpcl_initpcdest();
}

void mm_libpcl_initpcdest(void) {
    mm_libpcl_pccode = (mm_libpcl_pccodex = (struct mm_libpcl_pclrec *)(0));
}

void mm_libpcl_genpc(int64_t opcode,struct mm_libpcl_pclopndrec * a,struct mm_libpcl_pclopndrec * b) {
    struct mm_libpcl_pclrec *  p;
    p = (struct mm_libpcl_pclrec *)(mlib_pcm_allocz((int64_t)64));
    ++mm_decls_npcl;
    (*p).lineno = mm_decls_mlineno;
    (*p).opcode = opcode;
    if (!!(a)) {
        (*p).a = (*a);
        if (!!(b)) {
            (*p).b = (*b);
        };
    };
    mm_libpcl_addpcl(p);
}

static void mm_libpcl_addpcl(struct mm_libpcl_pclrec * p) {
    if (!!(mm_libpcl_pccode)) {
        (*mm_libpcl_pccodex).nextpcl = p;
        mm_libpcl_pccodex = p;
    } else {
        mm_libpcl_pccode = (mm_libpcl_pccodex = p);
    };
}

void mm_libpcl_genpc_condlab(int64_t opcode,int64_t cond,int64_t lab) {
    mm_libpcl_genpc(opcode,mm_libpcl_genlabel(lab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    (*mm_libpcl_pccodex).cond = cond;
}

struct mm_libpcl_pclrec * mm_libpcl_lastpc(void) {
    return mm_libpcl_pccodex;
}

void mm_libpcl_genpcstr(int64_t opcode,uint8_t * s) {
    mm_libpcl_genpc(opcode,mm_libpcl_genstrimm(s,(int64_t)-1),(struct mm_libpcl_pclopndrec *)(0));
}

static struct mm_libpcl_pclopndrec * mm_libpcl_newpclopnd(void) {
    struct mm_libpcl_pclopndrec *  a;
    a = &mm_libpcl_pclbuffers[(mm_libpcl_nextpclindex++)-1];
    if ((mm_libpcl_nextpclindex > (int64_t)4)) {
        mm_libpcl_nextpclindex = (int64_t)1;
    };
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_duplopnd(struct mm_libpcl_pclopndrec * a) {
    struct mm_libpcl_pclopndrec *  b;
    b = mm_libpcl_newpclopnd();
    if ((a == b)) {
        mm_support_gerror((uint8_t*)"DUPLOPND/CLASH",(struct mm_decls_unitrec *)(0));
    };
    (*b) = (*a);
    return b;
}

static void mm_libpcl_writepclblock(struct mm_libpcl_pclrec * m) {
    int64_t i;
    i = (int64_t)1;
    L560 :;
    while (!!(m)) {
        mm_libpcl_writepcl(i,m);
        ++i;
        m = (*m).nextpcl;
L561 :;
    }L562 :;
    ;
}

struct mlib_strbuffer * mm_libpcl_writepclcode(uint8_t * caption) {
    mlib_gs_str(mm_lib_dest,(uint8_t*)"PROC ");
    mlib_gs_strln(mm_lib_dest,caption);
    mlib_gs_strln(mm_lib_dest,(uint8_t*)"---------------------------------------------");
    mm_libpcl_writepclblock(mm_libpcl_allpclcode);
    mlib_gs_strln(mm_lib_dest,(uint8_t*)"---------------------------------------------");
    return mm_lib_dest;
}

void mm_libpcl_gencomment(uint8_t * s) {
    if (((s == 0) || ((int64_t)((*s)) == (int64_t)0))) {
        mm_libpcl_genpc((int64_t)2,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_libpcl_genpcstr((int64_t)1,s);
    };
}

struct mm_libpcl_pclopndrec * mm_libpcl_genstrimm(uint8_t * s,int64_t length) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)6;
    if ((length < (int64_t)0)) {
        length = (int64_t)(strlen((int8_t *)(s)));
    };
    (*a).svalue = (uint8_t *)(mlib_pcm_alloc((length + (int64_t)1)));
    memcpy((void *)((*a).svalue),(void *)(s),(uint64_t)((length + (int64_t)1)));
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_genname(uint8_t * s) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)6;
    (*a).svalue = mlib_pcm_copyheapstring(s);
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_gensys(int64_t fnindex) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)14;
    (*a).value = fnindex;
    return a;
}

static void mm_libpcl_writepcl(int64_t index,struct mm_libpcl_pclrec * pcl) {
    mlib_gs_leftint(mm_lib_dest,((int64_t)((*pcl).lineno) & (int64_t)16777215),(int64_t)4,(int64_t)32);
    mlib_gs_str(mm_lib_dest,(uint8_t*)"  ");
    mlib_gs_strln(mm_lib_dest,mm_libpcl_strpcl(pcl));
}

uint8_t * mm_libpcl_strpcl(struct mm_libpcl_pclrec * pcl) {
    static uint8_t str[1512];
    uint8_t opnds[1512];
    uint8_t opnd2[1256];
    uint8_t opcname[1128];
    struct mm_libpcl_pclopndrec a;
    struct mm_libpcl_pclopndrec b;
    int64_t opcode;
    int64_t cond;
    opcode = (int64_t)((*pcl).opcode);
    cond = (int64_t)((*pcl).cond);
    a = (*pcl).a;
    b = (*pcl).b;
    if ((opcode==(int64_t)2)) {
        return (uint8_t*)"";
    }else if ((opcode==(int64_t)1)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)";",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(a.svalue,NULL);
        msysnewc_m_print_end();
        ;
        return str;
    }else if ((opcode==(int64_t)4)) {
        return a.svalue;
    }else if ((opcode==(int64_t)3)) {
        if (!!((int64_t)(b.optype))) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((uint8_t*)"L#:\t<#>");
            msysnewc_m_print_i64(a.value,NULL);
            msysnewc_m_print_str((*b.def).name,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((uint8_t*)"L#:");
            msysnewc_m_print_i64(a.value,NULL);
            msysnewc_m_print_end();
            ;
        };
        return str;
    }else if ((opcode==(int64_t)11)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"istatic #:");
        msysnewc_m_print_str((*a.def).name,NULL);
        msysnewc_m_print_end();
        ;
        return str;
    }else if ((opcode==(int64_t)12)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"zstatic #: #");
        msysnewc_m_print_str((*a.def).name,NULL);
        msysnewc_m_print_i64(b.value,NULL);
        msysnewc_m_print_end();
        ;
        return str;
    };
    if ((opcode==(int64_t)64)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((uint8_t*)"jump.",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((mm_tables_jtagnames[(cond)] + (int64_t)2),NULL);
        msysnewc_m_print_end();
        ;
    }else if ((opcode==(int64_t)79)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((uint8_t*)"set.",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((mm_tables_jtagnames[(cond)] + (int64_t)2),NULL);
        msysnewc_m_print_end();
        ;
    } else {
        strcpy((int8_t *)(opcname),(int8_t *)((mm_libpcl_pclnames[(opcode)-1] + (int64_t)2)));
    };
    if (!!((uint64_t)((*pcl).catmode))) {
        strcat((int8_t *)(opcname),(int8_t *)((uint8_t*)"."));
        strcat((int8_t *)(opcname),(int8_t *)(mm_tables_stdtypenames[((int64_t)((*pcl).catmode))]));
    };
    mlib_ipadstr(opcname,(int64_t)16,(uint8_t*)" ");
    strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"  "));
    mlib_ipadstr(str,(int64_t)8,(uint8_t*)" ");
    strcat((int8_t *)(str),(int8_t *)(opcname));
    if ((!!((int64_t)(a.optype)) && !!((int64_t)(b.optype)))) {
        strcpy((int8_t *)(opnd2),(int8_t *)(mm_libpcl_stropnd(&b)));
        msysnewc_m_print_startstr(opnds);
        msysnewc_m_print_setfmt((uint8_t*)"#,   #");
        msysnewc_m_print_str(mm_libpcl_stropnd(&a),NULL);
        msysnewc_m_print_str(opnd2,NULL);
        msysnewc_m_print_end();
        ;
    } else if (!!((int64_t)(a.optype))) {
        strcpy((int8_t *)(opnds),(int8_t *)(mm_libpcl_stropnd(&a)));
    } else {
        opnds[((int64_t)1)-1] = (uint64_t)0u;
    };
    if (!!((uint64_t)(opnds[((int64_t)1)-1]))) {
        strcat((int8_t *)(str),(int8_t *)(opnds));
    };
    if ((opcode == (int64_t)5)) {
        msysnewc_m_print_startstr(opnds);
        msysnewc_m_print_str((uint8_t*)", Framesize:",NULL);
        msysnewc_m_print_i64((*pcl).b.fbytes,NULL);
        msysnewc_m_print_end();
        ;
        strcat((int8_t *)(str),(int8_t *)(opnds));
    };
    if ((!!((int64_t)((*pcl).mode)) && ((int64_t)((*pcl).mode) != (int64_t)((uint64_t)((*pcl).catmode))))) {
        msysnewc_m_print_startstr(opnds);
        msysnewc_m_print_setfmt((uint8_t*)" (#)");
        msysnewc_m_print_str(mm_lib_strmode((int64_t)((*pcl).mode),(int64_t)1),NULL);
        msysnewc_m_print_end();
        ;
        strcat((int8_t *)(str),(int8_t *)(opnds));
    };
    if (!!((int64_t)((*pcl).align))) {
        if ((opcode==(int64_t)62) || (opcode==(int64_t)64) || (opcode==(int64_t)65)) {
        } else {
            msysnewc_m_print_startstr(opnds);
            msysnewc_m_print_str((uint8_t*)" Align:",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*pcl).align,NULL);
            msysnewc_m_print_end();
            ;
            strcat((int8_t *)(str),(int8_t *)(opnds));
        };
    };
    if (((opcode == (int64_t)60) || (opcode == (int64_t)61))) {
        msysnewc_m_print_startstr(opnds);
        msysnewc_m_print_str((uint8_t*)" Nargs:",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64((*pcl).a.nargs,NULL);
        msysnewc_m_print_end();
        ;
        strcat((int8_t *)(str),(int8_t *)(opnds));
    };
    mlib_ipadstr(str,(int64_t)54,(uint8_t*)"-");
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)" C:"));
    strcat((int8_t *)(str),(int8_t *)(mm_libpcl_strmodev((int64_t)((*pcl).catmode))));
    mlib_ipadstr(str,(int64_t)63,(uint8_t*)" ");
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)" M:"));
    strcat((int8_t *)(str),(int8_t *)(mm_libpcl_strmodev((int64_t)((*pcl).mode))));
    mlib_ipadstr(str,(int64_t)80,(uint8_t*)"-");
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)" ||C2:"));
    strcat((int8_t *)(str),(int8_t *)(mm_libpcl_strmodev((int64_t)((*pcl).catmode2))));
    mlib_ipadstr(str,(int64_t)88,(uint8_t*)" ");
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)" M2:"));
    strcat((int8_t *)(str),(int8_t *)(mm_libpcl_strmodev((int64_t)((*pcl).mode2))));
    mlib_ipadstr(str,(int64_t)96,(uint8_t*)" ");
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)"cai:"));
    strcat((int8_t *)(str),(int8_t *)(msysnewc_strint((int64_t)((*pcl).cond),(uint8_t *)(0))));
    return str;
}

static uint8_t * mm_libpcl_strmodev(int64_t m) {
    if ((m == (int64_t)0)) {
        return (uint8_t*)"-";
    };
    return mm_lib_strmode(m,(int64_t)1);
}

uint8_t * mm_libpcl_stropnd(struct mm_libpcl_pclopndrec * a) {
    static uint8_t str[512];
    if (((int64_t)((*a).optype)==(int64_t)0)) {
        return (uint8_t*)"";
    }else if (((int64_t)((*a).optype)==(int64_t)1)) {
        return mm_libpcl_strmemopnd((*a).def);
    }else if (((int64_t)((*a).optype)==(int64_t)2)) {
        return mm_libpcl_strmemaddropnd((*a).def);
    }else if (((int64_t)((*a).optype)==(int64_t)3)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_i64((*a).value,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*a).optype)==(int64_t)5)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_r64((*a).xvalue,NULL);
        msysnewc_m_print_str((((int64_t)((*a).size) == (int64_t)4)?(uint8_t*)"*4":(uint8_t*)""),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*a).optype)==(int64_t)6)) {
        if (((int64_t)(strlen((int8_t *)((*a).svalue))) >= (int64_t)512)) {
            return (uint8_t*)"<LONGSTR>";
        } else {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((uint8_t*)"\"#\"");
            msysnewc_m_print_str((*a).svalue,NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((int64_t)((*a).optype)==(int64_t)14)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"<#: #>");
        msysnewc_m_print_str(mm_tables_sysfnnames[((*a).value)-1],NULL);
        msysnewc_m_print_i64(mm_decls_sysfnlabels[((*a).value)-1],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*a).optype)==(int64_t)4)) {
//        msysnewc_m_print_startstr(str);
//        msysnewc_m_print_i128((*(*a).pvalue128),NULL);
//        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*a).optype)==(int64_t)15)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"<ASSEM>");
        msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*(*a).code).tag))],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*a).optype)==(int64_t)11)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"L#");
        msysnewc_m_print_i64((*a).labelno,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"BAD OPND",NULL);
        msysnewc_m_print_i64((*a).optype,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        return (uint8_t*)"<UNIMPL OPND>";
    };
    return str;
}

uint8_t * mm_libpcl_getprocname(struct mm_decls_strec * d) {
    return mm_lib_getdottedname(d);
    return (uint8_t*)"";
}

uint8_t * mm_libpcl_strlabel(int64_t n) {
    static uint8_t str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((uint8_t*)"L",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

int64_t mm_libpcl_isframe(struct mm_decls_strec * d) {
    if (((int64_t)((*d).nameid)==(int64_t)10) || ((int64_t)((*d).nameid)==(int64_t)11)) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

void mm_libpcl_genreturn(int64_t fbytes,int64_t pbytes) {
    int64_t iscallback;
    iscallback = mm_lib_iscallbackfn(mm_decls_currproc);
    mm_libpcl_genpc((int64_t)6,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
}

struct mm_libpcl_pclopndrec * mm_libpcl_genint(int64_t x,int64_t size) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)3;
    (*a).value = x;
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_genint128(i128 * pa) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)4;
    (*a).pvalue128 = pa;
    return a;
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_genreal(double x,int64_t size) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)5;
    (*a).xvalue = x;
    (*a).size = size;
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_genassem_u(struct mm_decls_unitrec * p) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)15;
    (*a).code = p;
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_genlabel(int64_t x,int64_t isglobal) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)11;
    (*a).labelno = x;
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_genmem_u(struct mm_decls_unitrec * p,int64_t size) {
    return mm_libpcl_genmem_d((*p).def,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]));
}

struct mm_libpcl_pclopndrec * mm_libpcl_genmem_d(struct mm_decls_strec * d,int64_t size) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)1;
    (*a).def = d;
    return a;
}

struct mm_libpcl_pclopndrec * mm_libpcl_genmemaddr_u(struct mm_decls_unitrec * p) {
    return mm_libpcl_genmemaddr_d((*p).def);
}

struct mm_libpcl_pclopndrec * mm_libpcl_genmemaddr_d(struct mm_decls_strec * d) {
    struct mm_libpcl_pclopndrec *  a;
    a = mm_libpcl_newpclopnd();
    (*a).optype = (int64_t)2;
    (*a).def = d;
    return a;
}

int64_t mm_libpcl_getopndsize_u(struct mm_decls_unitrec * p) {
    return (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
}

int64_t mm_libpcl_getopndsize_d(struct mm_decls_strec * d) {
    return (int64_t)(mm_decls_ttsize[((int64_t)((*d).mode))]);
}

int64_t mm_libpcl_isint32const(struct mm_decls_unitrec * p) {
    int64_t a;
    if ((!!(mm_lib_isconstint(p)) && ((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) <= (int64_t)8))) {
        a = (*p).value;
        if (((a <= (int64_t)2147483647) && (a >= (int64_t)-2147483648))) {
            return (int64_t)1;
        };
    };
    return (int64_t)0;
}

int64_t mm_libpcl_roundto(int64_t a,int64_t n) {
    --n;
    L563 :;
    while (!!((a & n))) {
        ++a;
L564 :;
    }L565 :;
    ;
    return a;
}

void mm_libpcl_pushstack(int64_t n) {
}

void mm_libpcl_popstack(int64_t n) {
}

int64_t mm_libpcl_definelabel(void) {
    mm_libpcl_genpc((int64_t)3,mm_libpcl_genlabel(++mm_decls_labelno,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    return mm_decls_labelno;
}

int64_t mm_libpcl_createfwdlabel(void) {
    return ++mm_decls_labelno;
}

void mm_libpcl_definefwdlabel(int64_t lab) {
    mm_libpcl_genpc((int64_t)3,mm_libpcl_genlabel(lab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
}

void mm_libpcl_genjumpl(int64_t lab) {
    mm_libpcl_genpc((int64_t)63,mm_libpcl_genlabel(lab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
}

void mm_libpcl_do_syscallproc(int64_t fnindex,int64_t nparams,int64_t retmode) {
    if (!!(nparams)) {
        mm_libpcl_genpc((int64_t)21,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_genpc((int64_t)62,mm_libpcl_gensys(fnindex),mm_libpcl_genint(nparams,(int64_t)8));
    if (!!(retmode)) {
        mm_libpcl_genpc((int64_t)20,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_t(retmode);
        if (!!((uint64_t)(mm_decls_ttisreal[(retmode)]))) {
            mm_libpcl_makefloatopnds();
        };
        (*mm_libpcl_pccodex).mode = retmode;
    };
}

static uint8_t * mm_libpcl_strmemopnd(struct mm_decls_strec * d) {
    static uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"[#]");
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

static uint8_t * mm_libpcl_strmemaddropnd(struct mm_decls_strec * d) {
    static uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"&#");
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

int64_t mm_libpcl_roundsizetg(int64_t size) {
    L566 :;
    while (!!((size & (mm_decls_targetsize - (int64_t)1)))) {
        ++size;
L567 :;
    }L568 :;
    ;
    return size;
}

int64_t mm_libpcl_getpclop(int64_t tag) {
    static int16_t maptable[44][2] = {
    {(int16_t)43,(int16_t)45},
    {(int16_t)44,(int16_t)46},
    {(int16_t)45,(int16_t)47},
    {(int16_t)46,(int16_t)48},
    {(int16_t)47,(int16_t)49},
    {(int16_t)48,(int16_t)50},
    {(int16_t)109,(int16_t)52},
    {(int16_t)110,(int16_t)53},
    {(int16_t)111,(int16_t)54},
    {(int16_t)50,(int16_t)82},
    {(int16_t)51,(int16_t)84},
    {(int16_t)52,(int16_t)85},
    {(int16_t)53,(int16_t)86},
    {(int16_t)54,(int16_t)87},
    {(int16_t)55,(int16_t)90},
    {(int16_t)60,(int16_t)91},
    {(int16_t)61,(int16_t)92},
    {(int16_t)65,(int16_t)96},
    {(int16_t)66,(int16_t)97},
    {(int16_t)133,(int16_t)127},
    {(int16_t)134,(int16_t)128},
    {(int16_t)135,(int16_t)129},
    {(int16_t)136,(int16_t)130},
    {(int16_t)114,(int16_t)132},
    {(int16_t)115,(int16_t)133},
    {(int16_t)117,(int16_t)134},
    {(int16_t)118,(int16_t)135},
    {(int16_t)119,(int16_t)136},
    {(int16_t)120,(int16_t)137},
    {(int16_t)121,(int16_t)138},
    {(int16_t)122,(int16_t)139},
    {(int16_t)123,(int16_t)140},
    {(int16_t)124,(int16_t)142},
    {(int16_t)125,(int16_t)143},
    {(int16_t)126,(int16_t)144},
    {(int16_t)127,(int16_t)145},
    {(int16_t)128,(int16_t)146},
    {(int16_t)129,(int16_t)147},
    {(int16_t)130,(int16_t)148},
    {(int16_t)131,(int16_t)149},
    {(int16_t)132,(int16_t)150},
    {(int16_t)151,(int16_t)154},
    {(int16_t)152,(int16_t)155},
    {(int16_t)0,(int16_t)0}
};
    static int16_t convtable[253];
    int64_t opc;
    int64_t av_1;
    int64_t i;
    if (!!((opc = (int64_t)(convtable[(tag)])))) {
        return opc;
    };
    L569 :;
    for (i=(int64_t)1;i<=(int64_t)44;i+=(int64_t)1) {
L570 :;
        if (((int64_t)(maptable[(i)-1][((int64_t)1)-1]) == tag)) {
            convtable[(i)] = (opc = (int64_t)(maptable[(i)-1][((int64_t)2)-1]));
            return opc;
        };
L571 :;
    }L572 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"JTAGNAMES[TAG]=",NULL);
    msysnewc_m_print_str(mm_tables_jtagnames[(tag)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_support_gerror((uint8_t*)"Can't find pcl op",(struct mm_decls_unitrec *)(0));
    return (int64_t)0;
}

static uint8_t * mm_libpcl_strshortmode(int64_t m) {
    return mm_tables_stdtypenames[((int64_t)(mm_decls_ttbasetype[(m)]))];
}

int64_t mm_libpcl_islogical(struct mm_decls_unitrec * p) {
    if (((int64_t)((*p).tag)==(int64_t)16) || ((int64_t)((*p).tag)==(int64_t)15) || ((int64_t)((*p).tag)==(int64_t)12) || ((int64_t)((*p).tag)==(int64_t)13) || ((int64_t)((*p).tag)==(int64_t)14)) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

void mm_libpcl_makefloatopnds(void) {
    if (((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)100) || ((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)111) || ((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)119) || ((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)125) || ((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)104) || ((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)107) || ((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)113) || ((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)112) || ((int64_t)((*mm_libpcl_pccodex).opcode)==(int64_t)102)) {
        if (((int64_t)((*mm_libpcl_pccodex).catmode2)==(int64_t)27)) {
            (*mm_libpcl_pccodex).catmode2 = (uint64_t)((int64_t)28);
        }else if (((int64_t)((*mm_libpcl_pccodex).catmode2)==(int64_t)29)) {
            (*mm_libpcl_pccodex).catmode2 = (uint64_t)((int64_t)30);
        }else if (((int64_t)((*mm_libpcl_pccodex).catmode2)==(int64_t)31)) {
            mm_support_gerror((uint8_t*)"widefloat?",(struct mm_decls_unitrec *)(0));
        };
    } else {
        if (((int64_t)((*mm_libpcl_pccodex).catmode)==(int64_t)27)) {
            (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)28);
        }else if (((int64_t)((*mm_libpcl_pccodex).catmode)==(int64_t)29)) {
            (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)30);
        }else if (((int64_t)((*mm_libpcl_pccodex).catmode)==(int64_t)31)) {
            mm_support_gerror((uint8_t*)"widefloat2?",(struct mm_decls_unitrec *)(0));
        }else if (((int64_t)((*mm_libpcl_pccodex).catmode)==(int64_t)12)) {
            if (((int64_t)((*mm_libpcl_pccodex).opcode) == (int64_t)23)) {
                (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)30);
            };
        }else if (((int64_t)((*mm_libpcl_pccodex).catmode)==(int64_t)11)) {
            if (((int64_t)((*mm_libpcl_pccodex).opcode) == (int64_t)23)) {
                (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)28);
            };
        };
    };
}

void mm_libpcl_setpclcat_u(struct mm_decls_unitrec * p) {
    mm_libpcl_setpclcat_t((int64_t)((*p).mode));
}

void mm_libpcl_setpclcat_t(int64_t m) {
    (*mm_libpcl_pccodex).catmode = (uint64_t)(mm_tables_stdtypecat[((int64_t)(mm_decls_ttbasetype[(m)]))]);
    (*mm_libpcl_pccodex).mode = m;
    if (((int64_t)((uint64_t)((*mm_libpcl_pccodex).catmode)) == (int64_t)32)) {
        if (((int64_t)(mm_decls_ttsize[(m)])==(int64_t)8)) {
            (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)29);
        }else if (((int64_t)(mm_decls_ttsize[(m)])==(int64_t)1) || ((int64_t)(mm_decls_ttsize[(m)])==(int64_t)2) || ((int64_t)(mm_decls_ttsize[(m)])==(int64_t)4)) {
            (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)27);
        };
    };
}

void mm_libpcl_setpclmode_u(struct mm_decls_unitrec * p) {
    mm_libpcl_setpclmode_t((int64_t)((*p).mode));
}

void mm_libpcl_setpclmode_t(int64_t m) {
    (*mm_libpcl_pccodex).catmode = (uint64_t)(mm_decls_ttbasetype[(m)]);
    if (((int64_t)((uint64_t)((*mm_libpcl_pccodex).catmode)) == (int64_t)32)) {
        if (((int64_t)(mm_decls_ttsize[(m)])==(int64_t)8)) {
            (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)29);
        }else if (((int64_t)(mm_decls_ttsize[(m)])==(int64_t)1) || ((int64_t)(mm_decls_ttsize[(m)])==(int64_t)2) || ((int64_t)(mm_decls_ttsize[(m)])==(int64_t)4)) {
            (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)27);
        };
    };
    (*mm_libpcl_pccodex).mode = m;
}

void mm_blockpcl_evalunit(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    struct mm_decls_strec *  d;
    int64_t av_1;
    int64_t i;
    mm_decls_mlineno = (int64_t)((*p).lineno);
    a = (*p).a;
    b = (*p).b;
    switch ((int64_t)((*p).tag)) {
    case 1:;
    {
        mm_blockpcl_do_const(p);
    }break;
    case 2:;
    {
        mm_blockpcl_do_null(p,a,b);
    }break;
    case 3:;
    {
        mm_blockpcl_do_name(p);
    }break;
    case 4:;
    case 5:;
    {
        mm_blockpcl_do_block(p,a);
    }break;
    case 6:;
    {
        mm_blockpcl_do_decimal(p,a,b);
    }break;
    case 201:;
    {
        mm_blockpcl_do_callproc(p,a,b,(int64_t)0);
    }break;
    case 202:;
    {
        mm_blockpcl_do_callproc(p,a,b,(int64_t)0);
    }break;
    case 203:;
    {
        mm_blockpcl_do_return(p,a,b);
    }break;
    case 26:;
    {
        mm_blockpcl_do_returnmult(p,a,b);
    }break;
    case 205:;
    {
        mm_blockpcl_do_assign(p,a,b,(int64_t)0);
    }break;
    case 207:;
    {
        mm_blockpcl_do_assign(p,a,b,(int64_t)0);
    }break;
    case 208:;
    {
        mm_blockpcl_do_to(p,a,b);
    }break;
    case 209:;
    {
        mm_blockpcl_do_if(p,a,b,(*p).c,(int64_t)0);
    }break;
    case 210:;
    {
        mm_blockpcl_do_longif(p,a,b,(int64_t)0);
    }break;
    case 211:;
    {
        mm_blockpcl_do_for(p,a,b,(*p).c,(int64_t)0);
    }break;
    case 212:;
    {
        mm_blockpcl_do_for(p,a,b,(*p).c,(int64_t)1);
    }break;
    case 213:;
    {
        mm_blockpcl_do_cfor(p,a,b);
    }break;
    case 214:;
    {
        mm_blockpcl_do_while(p,a,b);
    }break;
    case 215:;
    {
        mm_blockpcl_do_repeat(p,a,b);
    }break;
    case 216:;
    {
        mm_blockpcl_do_goto(p,a,b);
    }break;
    case 217:;
    {
        mm_blockpcl_do_gotoblock(p,a,b);
    }break;
    case 218:;
    {
        mm_blockpcl_do_labeldef(p);
    }break;
    case 219:;
    {
        mm_blockpcl_do_exit(p,(int64_t)1);
    }break;
    case 220:;
    {
        mm_blockpcl_do_exit(p,(int64_t)2);
    }break;
    case 221:;
    {
        mm_blockpcl_do_exit(p,(int64_t)3);
    }break;
    case 222:;
    {
        mm_blockpcl_do_exit(p,(int64_t)4);
    }break;
    case 223:;
    {
        mm_blockpcl_do_do(p,a,b);
    }break;
    case 224:;
    {
        mm_blockpcl_do_case(p,a,b,(*p).c,(int64_t)0,(int64_t)0);
    }break;
    case 225:;
    {
        mm_blockpcl_do_case(p,a,b,(*p).c,(int64_t)1,(int64_t)0);
    }break;
    case 226:;
    {
        mm_blockpcl_do_switch(p,a,b,(*p).c,(int64_t)0,(int64_t)0);
    }break;
    case 227:;
    {
        mm_blockpcl_do_switch(p,a,b,(*p).c,(int64_t)1,(int64_t)0);
    }break;
    case 228:;
    {
        mm_blockpcl_do_swap(p,a,b);
    }break;
    case 229:;
    {
        mm_blockpcl_do_select(p,a,b,(*p).c,(int64_t)0);
    }break;
    case 231:;
    {
        mm_blockpcl_do_print(p,a,b);
    }break;
    case 232:;
    {
        mm_blockpcl_do_print(p,a,b);
    }break;
    case 233:;
    {
        mm_blockpcl_do_print(p,a,b);
    }break;
    case 234:;
    {
        mm_blockpcl_do_print(p,a,b);
    }break;
    case 235:;
    {
        mm_blockpcl_do_cprint(p,a,b);
    }break;
    case 236:;
    {
        mm_blockpcl_do_cprintln(p,a,b);
    }break;
    case 237:;
    {
        mm_blockpcl_do_sprint(p,a,b);
    }break;
    case 238:;
    {
        mm_blockpcl_do_sfprint(p,a,b);
    }break;
    case 239:;
    {
        mm_blockpcl_do_read(p,a);
    }break;
    case 240:;
    {
        mm_blockpcl_do_readln(a);
    }break;
    case 241:;
    {
        mm_blockpcl_do_sread(p,a,b);
    }break;
    case 242:;
    {
        mm_blockpcl_do_sreadln(p,a,b);
    }break;
    case 243:;
    {
        mm_blockpcl_do_stop(p,a);
    }break;
    case 244:;
    {
        mm_blockpcl_do_try(p,a,b);
    }break;
    case 245:;
    {
        mm_blockpcl_do_except(p,a,b);
    }break;
    case 246:;
    {
        mm_blockpcl_do_yield(p,a,b);
    }break;
    case 247:;
    {
        mm_blockpcl_do_raise(p,a,b);
    }break;
    case 248:;
    {
        mm_blockpcl_do_eval(p,a,b);
    }break;
    case 249:;
    {
        mm_blockpcl_do_lambda(p,a,b);
    }break;
    case 12:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)82);
    }break;
    case 13:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)84);
    }break;
    case 14:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)85);
    }break;
    case 17:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)82);
    }break;
    case 18:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)84);
    }break;
    case 15:;
    {
        mm_blockpcl_do_notl(p,a);
    }break;
    case 16:;
    {
        mm_blockpcl_do_istruel(p,a);
    }break;
    case 19:;
    {
        mm_blockpcl_do_makelist(p,a,b);
    }break;
    case 20:;
    {
        mm_blockpcl_do_makerange(p,a,b);
    }break;
    case 21:;
    {
        mm_blockpcl_do_makeset(p,a,b);
    }break;
    case 22:;
    {
        mm_blockpcl_do_makedict(p,a,b);
    }break;
    case 24:;
    {
        mm_blockpcl_do_exprlist(p,a,b);
    }break;
    case 25:;
    {
        mm_blockpcl_do_multexpr(p,a,b);
    }break;
    case 27:;
    {
        mm_blockpcl_do_keyword(p,a,b);
    }break;
    case 28:;
    {
        mm_blockpcl_do_keyvalue(p,a,b);
    }break;
    case 29:;
    {
        mm_blockpcl_do_assign(p,a,b,(int64_t)1);
    }break;
    case 30:;
    {
        mm_blockpcl_do_assign(p,a,b,(int64_t)1);
    }break;
    case 31:;
    {
        mm_blockpcl_do_callproc(p,a,b,(int64_t)1);
    }break;
    case 32:;
    {
        mm_blockpcl_do_callproc(p,a,b,(int64_t)1);
    }break;
    case 33:;
    {
        mm_blockpcl_do_applyop(p,a,b);
    }break;
    case 34:;
    {
        mm_blockpcl_do_applyopx(p,a,b);
    }break;
    case 35:;
    {
        mm_blockpcl_do_andand(p,a,b);
    }break;
    case 36:;
    {
        mm_blockpcl_do_setcc(p,a,b);
    }break;
    case 37:;
    {
        mm_blockpcl_do_setcc(p,a,b);
    }break;
    case 38:;
    {
        mm_blockpcl_do_setccx(p,a,b);
    }break;
    case 39:;
    {
        mm_blockpcl_do_setccx(p,a,b);
    }break;
    case 41:;
    {
        mm_blockpcl_do_setccx(p,a,b);
    }break;
    case 40:;
    {
        mm_blockpcl_do_setccx(p,a,b);
    }break;
    case 42:;
    {
        mm_blockpcl_do_isequal(p,a,b);
    }break;
    case 43:;
    {
        ++mm_decls_nalladds;
        if ((((int64_t)((*a).tag) == (int64_t)43) || ((int64_t)((*b).tag) == (int64_t)43))) {
            ++mm_decls_nalladd3s;
        };
        mm_blockpcl_do_bin(p,a,b,(int64_t)45);
    }break;
    case 44:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)46);
    }break;
    case 45:;
    {
        mm_blockpcl_do_muldiv(p,a,b,(int64_t)47);
    }break;
    case 46:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)48);
    }break;
    case 47:;
    {
        mm_blockpcl_do_muldiv(p,a,b,(int64_t)49);
    }break;
    case 48:;
    {
        mm_blockpcl_do_muldiv(p,a,b,(int64_t)50);
    }break;
    case 50:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)82);
    }break;
    case 51:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)84);
    }break;
    case 52:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)85);
    }break;
    case 53:;
    {
        mm_blockpcl_do_shl(p,a,b,(int64_t)86,(int64_t)88);
    }break;
    case 54:;
    {
        mm_blockpcl_do_shl(p,a,b,(int64_t)87,(int64_t)89);
    }break;
    case 55:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)90);
    }break;
    case 60:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)91);
    }break;
    case 61:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)92);
    }break;
    case 63:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)94);
    }break;
    case 64:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)95);
    }break;
    case 62:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)93);
    }break;
    case 65:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)96);
    }break;
    case 66:;
    {
        mm_blockpcl_do_bin(p,a,b,(int64_t)97);
    }break;
    case 67:;
    {
        mm_blockpcl_do_clamp(p,a,b);
    }break;
    case 88:;
    {
        mm_blockpcl_do_index(p,(int64_t)0);
    }break;
    case 89:;
    {
        mm_blockpcl_do_slice(p,a,b,(int64_t)0);
    }break;
    case 23:;
    {
        mm_blockpcl_do_makeslice(p,a,b);
    }break;
    case 90:;
    {
        mm_blockpcl_do_dotindex(p,a,b);
    }break;
    case 91:;
    {
        mm_blockpcl_do_dotslice(p,a,b);
    }break;
    case 92:;
    {
        mm_blockpcl_do_anddotindex(p,a,b);
    }break;
    case 93:;
    {
        mm_blockpcl_do_anddotslice(p,a,b);
    }break;
    case 94:;
    {
        mm_blockpcl_do_keyindex(p,a,b,(int64_t)0);
    }break;
    case 95:;
    {
        mm_blockpcl_do_dot(p,(int64_t)0);
    }break;
    case 96:;
    {
        mm_blockpcl_do_dotattr(p,a,b);
    }break;
    case 97:;
    {
        mm_blockpcl_do_atan2(p,a,b);
    }break;
    case 98:;
    {
        mm_blockpcl_do_power(p,a,b);
    }break;
    case 99:;
    {
        mm_blockpcl_do_ptr(p,a,b);
    }break;
    case 100:;
    {
        mm_blockpcl_do_addrof(p,a);
    }break;
    case 101:;
    {
        mm_blockpcl_do_addrof(p,a);
    }break;
    case 102:;
    {
        mm_blockpcl_do_convert(p,a,b);
    }break;
    case 103:;
    {
        mm_blockpcl_do_convertref(p,a,b);
    }break;
    case 104:;
    {
        mm_blockpcl_do_autocast(p,a,b);
    }break;
    case 105:;
    {
        mm_blockpcl_do_typepun(p,a,b);
    }break;
    case 106:;
    {
        mm_blockpcl_do_typeconst(p);
    }break;
    case 107:;
    {
        mm_blockpcl_do_operator(p,a,b);
    }break;
    case 108:;
    {
        mm_blockpcl_do_upper(p,a,b);
    }break;
    case 109:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)52);
    }break;
    case 110:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)53);
    }break;
    case 111:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)54);
    }break;
    case 114:;
    {
        mm_blockpcl_evalunit(a);
        mm_libpcl_genpc((int64_t)132,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclmode_u(a);
    }break;
    case 115:;
    {
        mm_blockpcl_do_sqr(p,a,b);
    }break;
    case 117:;
    {
        mm_blockpcl_do_sign(p,a,b);
    }break;
    case 118:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)56,(int64_t)135);
    }break;
    case 119:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)57,(int64_t)136);
    }break;
    case 120:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)58,(int64_t)137);
    }break;
    case 121:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)59,(int64_t)138);
    }break;
    case 122:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)60,(int64_t)139);
    }break;
    case 123:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)61,(int64_t)140);
    }break;
    case 124:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)62,(int64_t)142);
    }break;
    case 126:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)64,(int64_t)144);
    }break;
    case 127:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)65,(int64_t)145);
    }break;
    case 128:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)69,(int64_t)146);
    }break;
    case 129:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)66,(int64_t)147);
    }break;
    case 130:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)67,(int64_t)148);
    }break;
    case 131:;
    {
        mm_blockpcl_do_maths(p,a,(int64_t)68,(int64_t)149);
    }break;
    case 132:;
    {
        mm_blockpcl_do_fmod(p,a,b);
    }break;
    case 133:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)127);
    }break;
    case 134:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)128);
    }break;
    case 135:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)129);
    }break;
    case 137:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)131);
    }break;
    case 136:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)130);
    }break;
    case 113:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)152);
    }break;
    case 112:;
    {
        mm_blockpcl_do_unary(p,a,(int64_t)153);
    }break;
    case 138:;
    {
        mm_blockpcl_do_bitwidth(p,a);
    }break;
    case 139:;
    {
        mm_blockpcl_do_bytesize(p,a);
    }break;
    case 140:;
    {
        mm_blockpcl_do_typeof(p,a,b);
    }break;
    case 141:;
    {
        mm_blockpcl_do_typestr(p,a,b);
    }break;
    case 87:;
    {
        mm_blockpcl_do_sliceptr(p,a);
    }break;
    case 143:;
    {
        mm_blockpcl_do_minvalue(p,a,b);
    }break;
    case 144:;
    {
        mm_blockpcl_do_maxvalue(p,a,b);
    }break;
    case 149:;
    case 150:;
    {
        mm_blockpcl_do_incr(p,a);
    }break;
    case 145:;
    {
        mm_blockpcl_do_incrx(p,a,(int64_t)190);
    }break;
    case 146:;
    {
        mm_blockpcl_do_incrx(p,a,(int64_t)191);
    }break;
    case 147:;
    {
        mm_blockpcl_do_incrx(p,a,(int64_t)192);
    }break;
    case 148:;
    {
        mm_blockpcl_do_incrx(p,a,(int64_t)193);
    }break;
    case 151:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)154);
    }break;
    case 152:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)155);
    }break;
    case 153:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)156);
    }break;
    case 154:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)157);
    }break;
    case 155:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)158);
    }break;
    case 156:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)159);
    }break;
    case 157:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)160);
    }break;
    case 158:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)161);
    }break;
    case 159:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)162);
    }break;
    case 160:;
    {
        mm_blockpcl_do_shlto(p,a,b,(int64_t)163,(int64_t)165);
    }break;
    case 161:;
    {
        mm_blockpcl_do_shlto(p,a,b,(int64_t)164,(int64_t)166);
    }break;
    case 166:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)167);
    }break;
    case 167:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)168);
    }break;
    case 168:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)169);
    }break;
    case 169:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)170);
    }break;
    case 162:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)173);
    }break;
    case 163:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)174);
    }break;
    case 164:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)171);
    }break;
    case 165:;
    {
        mm_blockpcl_do_binto(p,a,b,(int64_t)172);
    }break;
    case 170:;
    {
        mm_blockpcl_do_unaryto(p,a,(int64_t)182);
    }break;
    case 171:;
    {
        mm_blockpcl_do_unaryto(p,a,(int64_t)183);
    }break;
    case 172:;
    {
        mm_blockpcl_do_unaryto(p,a,(int64_t)184);
    }break;
    case 173:;
    {
        mm_blockpcl_do_unaryto(p,a,(int64_t)185);
    }break;
    case 230:;
    {
        mm_blockpcl_do_recase(p,a);
    }break;
    case 185:;
    {
        mm_blockpcl_do_cvlineno(p,a,b);
    }break;
    case 187:;
    {
        mm_blockpcl_do_cvmodulename(p,a,b);
    }break;
    case 188:;
    {
        mm_blockpcl_do_cvfilename(p,a,b);
    }break;
    case 204:;
    {
        if (!!(a)) {
            mm_blockpcl_evalunit(a);
            mm_libpcl_do_syscallproc((int64_t)((*p).opcode),(int64_t)1,(int64_t)((*p).mode));
        } else {
            mm_libpcl_do_syscallproc((int64_t)((*p).opcode),(int64_t)0,(int64_t)((*p).mode));
        };
    }break;
    case 7:;
    {
        mm_blockpcl_do_assem(p,a);
    }break;
    default: {
        mm_support_gerror_s((uint8_t*)"UNSUPPORTED TAG: #",mm_tables_jtagnames[((int64_t)((*p).tag))],(struct mm_decls_unitrec *)(0));
    }
    } //SW
;
    if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
        mm_libpcl_makefloatopnds();
    };
    if (!!((int64_t)((*p).popflag))) {
        if (((int64_t)((*p).tag)==(int64_t)36) || ((int64_t)((*p).tag)==(int64_t)43)) {
            mm_support_gerror((uint8_t*)"use EVAL to evaluate this expression (or \"=\" used in place of \":=\"?)",(struct mm_decls_unitrec *)(0));
        };
        if (((int64_t)((*p).mode) == (int64_t)36)) {
            if ((((int64_t)((*p).tag) == (int64_t)31) && ((int64_t)((*(*p).a).tag) == (int64_t)3))) {
                d = (*(*p).a).def;
                L573 :;
                for (i=(int64_t)1;i<=(int64_t)((*d).nretvalues);i+=(int64_t)1) {
L574 :;
                    mm_libpcl_genpc((int64_t)44,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
                    mm_libpcl_setpclcat_t((int64_t)((*d).modelist[(i)-1]));
                    if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*d).modelist[(i)-1]))]))) {
                        mm_libpcl_makefloatopnds();
                    };
L575 :;
                }L576 :;
                ;
            } else {
                mm_support_gerror((uint8_t*)"Can't free mult/ret values",(struct mm_decls_unitrec *)(0));
            };
        } else {
            mm_libpcl_genpc((int64_t)44,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclcat_t((int64_t)((*p).mode));
            if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
                mm_libpcl_makefloatopnds();
            };
        };
        (*p).popflag = (int64_t)0;
    };
}

static void mm_blockpcl_evalref(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    struct mm_decls_unitrec *  c;
    a = (*p).a;
    b = (*p).b;
    c = (*p).c;
    switch ((int64_t)((*p).tag)) {
    case 3:;
    {
        mm_libpcl_genpc((int64_t)16,mm_libpcl_genmem_d((*p).def,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    }break;
    case 88:;
    {
        mm_blockpcl_do_index(p,(int64_t)1);
    }break;
    case 94:;
    {
        mm_blockpcl_do_keyindex(p,a,b,(int64_t)1);
    }break;
    case 89:;
    {
        mm_blockpcl_do_slice(p,a,b,(int64_t)1);
    }break;
    case 95:;
    {
        mm_blockpcl_do_dot(p,(int64_t)1);
    }break;
    case 99:;
    {
        mm_blockpcl_evalunit((*p).a);
    }break;
    default: {
        if (((int64_t)((*p).tag)==(int64_t)209)) {
            mm_blockpcl_do_if(p,a,b,c,(int64_t)1);
        }else if (((int64_t)((*p).tag)==(int64_t)210)) {
            mm_blockpcl_do_longif(p,a,b,(int64_t)1);
        }else if (((int64_t)((*p).tag)==(int64_t)229)) {
            mm_blockpcl_do_select(p,a,b,c,(int64_t)1);
        }else if (((int64_t)((*p).tag)==(int64_t)226)) {
            mm_blockpcl_do_switch(p,a,b,c,(int64_t)0,(int64_t)1);
        }else if (((int64_t)((*p).tag)==(int64_t)224)) {
            mm_blockpcl_do_case(p,a,b,c,(int64_t)0,(int64_t)1);
        } else {
            mm_diags_printunit(p,(int64_t)0,(uint8_t*)"*",0);
            mm_support_gerror((uint8_t*)"evalref",(struct mm_decls_unitrec *)(0));
        };
    }
    } //SW
;
}

static void mm_blockpcl_genjumpcond(int64_t opc,struct mm_decls_unitrec * p,int64_t lab) {
    struct mm_libpcl_pclopndrec lx;
    struct mm_libpcl_pclopndrec mx;
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  r;
    struct mm_decls_unitrec *  s;
    int64_t lab2;
    q = (*p).a;
    r = (*p).b;
    switch ((int64_t)((*p).tag)) {
    case 12:;
    {
        if ((opc==(int64_t)0)) {
            mm_blockpcl_genjumpcond((int64_t)0,q,lab);
            mm_blockpcl_genjumpcond((int64_t)0,r,lab);
        }else if ((opc==(int64_t)1)) {
            lab2 = mm_libpcl_createfwdlabel();
            mm_blockpcl_genjumpcond((int64_t)0,q,lab2);
            mm_blockpcl_genjumpcond((int64_t)1,r,lab);
            mm_libpcl_definefwdlabel(lab2);
        };
    }break;
    case 13:;
    {
        if ((opc==(int64_t)0)) {
            lab2 = mm_libpcl_createfwdlabel();
            mm_blockpcl_genjumpcond((int64_t)1,q,lab2);
            mm_blockpcl_genjumpcond((int64_t)0,r,lab);
            mm_libpcl_definefwdlabel(lab2);
        }else if ((opc==(int64_t)1)) {
            mm_blockpcl_genjumpcond((int64_t)1,q,lab);
            mm_blockpcl_genjumpcond((int64_t)1,r,lab);
        };
    }break;
    case 15:;
    {
        if ((opc==(int64_t)0)) {
            mm_blockpcl_genjumpcond((int64_t)1,q,lab);
        }else if ((opc==(int64_t)1)) {
            mm_blockpcl_genjumpcond((int64_t)0,q,lab);
        };
    }break;
    case 16:;
    {
        mm_blockpcl_genjumpcond(opc,q,lab);
    }break;
    case 4:;
    {
        L577 :;
        while ((!!(q) && !!((*q).nextunit))) {
            mm_blockpcl_evalunit(q);
            q = (*q).nextunit;
L578 :;
        }L579 :;
        ;
        mm_blockpcl_genjumpcond(opc,q,lab);
    }break;
    case 36:;
    case 37:;
    case 38:;
    case 39:;
    case 41:;
    case 40:;
    {
        mm_blockpcl_gcomparejump(opc,p,q,r,lab);
    }break;
    case 58:;
    {
        mm_blockpcl_evalunit(q);
        mm_blockpcl_evalunit((*r).a);
        mm_blockpcl_evalunit((*r).b);
        mm_libpcl_genpc(((opc == (int64_t)0)?(int64_t)69:(int64_t)68),mm_libpcl_genlabel(lab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclmode_u(q);
    }break;
    case 59:;
    {
        s = (*r).a;
        if ((s == 0)) {
            mm_support_gerror((uint8_t*)"empty set",(struct mm_decls_unitrec *)(0));
        };
        if (((*s).nextunit == 0)) {
            (*p).tag = (int64_t)36;
            mm_blockpcl_gcomparejump(opc,p,q,s,lab);
            return;
        };
        if ((opc == (int64_t)0)) {
            lx = (*mm_libpcl_genlabel(lab,(int64_t)0));
            lab2 = mm_libpcl_createfwdlabel();
            mx = (*mm_libpcl_genlabel(lab2,(int64_t)0));
            mm_blockpcl_evalunit(q);
            L580 :;
            while (!!(s)) {
                mm_blockpcl_evalunit(s);
                s = (*s).nextunit;
                if (!!(s)) {
                    mm_libpcl_genpc((int64_t)72,&mx,(struct mm_libpcl_pclopndrec *)(0));
                } else {
                    mm_libpcl_genpc((int64_t)74,&lx,(struct mm_libpcl_pclopndrec *)(0));
                };
                mm_libpcl_setpclcat_u(q);
L581 :;
            }L582 :;
            ;
            mm_libpcl_definefwdlabel(lab2);
        } else {
            lx = (*mm_libpcl_genlabel(lab,(int64_t)0));
            mm_blockpcl_evalunit(q);
            L583 :;
            while (!!(s)) {
                mm_blockpcl_evalunit(s);
                s = (*s).nextunit;
                mm_libpcl_genpc((!!(s)?(int64_t)72:(int64_t)73),&lx,(struct mm_libpcl_pclopndrec *)(0));
                mm_libpcl_setpclcat_u(q);
L584 :;
            }L585 :;
            ;
        };
    }break;
    default: {
        if (!!((uint64_t)(mm_decls_ttisvar[((int64_t)((*p).mode))]))) {
            mm_blockpcl_evalunit(p);
            mm_libpcl_genpc((int64_t)56,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclcat_u(p);
            mm_libpcl_genpc(((opc == (int64_t)1)?(int64_t)66:(int64_t)67),mm_libpcl_genlabel(lab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclmode_t((int64_t)4);
        } else {
            mm_blockpcl_evalunit(p);
            mm_libpcl_genpc(((opc == (int64_t)1)?(int64_t)66:(int64_t)67),mm_libpcl_genlabel(lab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclmode_u(p);
        };
    }
    } //SW
;
}

static void mm_blockpcl_gcomparejump(int64_t jumpopc,struct mm_decls_unitrec * p,struct mm_decls_unitrec * lhs,struct mm_decls_unitrec * rhs,int64_t lab) {
    int64_t cond;
    cond = (int64_t)((*p).tag);
    if ((jumpopc == (int64_t)0)) {
        cond = mm_blockpcl_reversecond(cond);
    };
    mm_blockpcl_evalunit(lhs);
    mm_blockpcl_evalunit(rhs);
    mm_libpcl_genpc_condlab((int64_t)64,cond,lab);
    mm_libpcl_setpclmode_u(lhs);
}

static void mm_blockpcl_genjumpl(int64_t lab) {
    mm_libpcl_genpc((int64_t)63,mm_libpcl_genlabel(lab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
}

static int64_t mm_blockpcl_reversecond(int64_t op) {
    if ((op==(int64_t)36)) {
        return (int64_t)37;
    }else if ((op==(int64_t)37)) {
        return (int64_t)36;
    }else if ((op==(int64_t)38)) {
        return (int64_t)41;
    }else if ((op==(int64_t)39)) {
        return (int64_t)40;
    }else if ((op==(int64_t)41)) {
        return (int64_t)38;
    }else if ((op==(int64_t)40)) {
        return (int64_t)39;
    };
    return (int64_t)0;
}

static void mm_blockpcl_stacklooplabels(int64_t a,int64_t b,int64_t c,int64_t d) {
    ++mm_blockpcl_loopindex;
    if ((mm_blockpcl_loopindex > (int64_t)50)) {
        mm_support_gerror((uint8_t*)"Too many nested loops",(struct mm_decls_unitrec *)(0));
    };
    mm_blockpcl_loopstack[(mm_blockpcl_loopindex)-1][((int64_t)1)-1] = a;
    mm_blockpcl_loopstack[(mm_blockpcl_loopindex)-1][((int64_t)2)-1] = b;
    mm_blockpcl_loopstack[(mm_blockpcl_loopindex)-1][((int64_t)3)-1] = c;
    mm_blockpcl_loopstack[(mm_blockpcl_loopindex)-1][((int64_t)4)-1] = d;
}

static int64_t mm_blockpcl_findlooplabel(int64_t k,int64_t n) {
    int64_t i;
    i = (mm_blockpcl_loopindex - (n - (int64_t)1));
    if (((i < (int64_t)1) || (i > mm_blockpcl_loopindex))) {
        mm_support_gerror((uint8_t*)"Bad loop index",(struct mm_decls_unitrec *)(0));
    };
    return mm_blockpcl_loopstack[(i)-1][(k)-1];
}

static void mm_blockpcl_unimpl(uint8_t * mess) {
    mm_support_gerror_s((uint8_t*)"Unimplemented: #",mess,(struct mm_decls_unitrec *)(0));
}

static void mm_blockpcl_do_const(struct mm_decls_unitrec * p) {
    int64_t mode;
    mode = (int64_t)((*p).mode);
    if (!!((uint64_t)(mm_decls_ttisinteger[(mode)]))) {
        if (((int64_t)(mm_decls_ttsize[(mode)]) < (int64_t)16)) {
            mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((*p).value,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        } else {
            mm_libpcl_genpc((int64_t)24,mm_libpcl_genint128((*p).pvalue128),(struct mm_libpcl_pclopndrec *)(0));
        };
    } else if (!!((uint64_t)(mm_decls_ttisreal[(mode)]))) {
        mm_libpcl_genpc((int64_t)23,mm_libpcl_genreal((*p).xvalue,(int64_t)(mm_decls_ttsize[(mode)])),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclmode_t((int64_t)(mm_decls_ttbasetype[(mode)]));
    } else if (!!((uint64_t)(mm_decls_ttisref[(mode)]))) {
        if (!!((int64_t)((*p).isastring))) {
            mm_libpcl_genpc((int64_t)25,mm_libpcl_genstrimm((*p).svalue,(int64_t)((*p).length)),(struct mm_libpcl_pclopndrec *)(0));
        } else {
            mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((*p).value,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        };
    } else {
        mm_support_gerror((uint8_t*)"do_const",(struct mm_decls_unitrec *)(0));
    };
}

static void mm_blockpcl_do_null(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_null");
}

static void mm_blockpcl_do_name(struct mm_decls_unitrec * p) {
    struct mm_decls_strec *  d;
    d = (*p).def;
    if (((int64_t)((*d).nameid)==(int64_t)5) || ((int64_t)((*d).nameid)==(int64_t)6)) {
        mm_libpcl_genpc((int64_t)16,mm_libpcl_genmem_u(p,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    }else if (((int64_t)((*d).nameid)==(int64_t)15)) {
        if (((int64_t)((*d).index) == (int64_t)0)) {
            (*d).index = ++mm_decls_labelno;
        };
        mm_libpcl_genpc((int64_t)63,mm_libpcl_genlabel((int64_t)((*d).index),(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        (*p).popflag = (int64_t)0;
    } else {
        mm_libpcl_genpc((int64_t)14,mm_libpcl_genmem_u(p,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(p);
    };
}

static void mm_blockpcl_do_block(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    L586 :;
    while ((!!(a) && !!((*a).nextunit))) {
        mm_blockpcl_evalunit(a);
        a = (*a).nextunit;
L587 :;
    }L588 :;
    ;
    if (!!(a)) {
        mm_blockpcl_evalunit(a);
    };
}

static void mm_blockpcl_do_decimal(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"DECIMAL",NULL);
    msysnewc_m_print_str((*p).svalue,NULL);
    msysnewc_m_print_i64((*p).length,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_libpcl_genpc((int64_t)31,mm_libpcl_genstrimm((*p).svalue,(int64_t)((*p).length)),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_callproc(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t fncall) {
    struct mm_decls_unitrec *  params[100];
    int64_t nparams;
    int64_t m;
    int64_t simplefunc;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    struct mm_decls_unitrec *  q;
    int64_t i;
    if (((int64_t)((*a).tag)==(int64_t)3)) {
        d = (*a).def;
        simplefunc = (int64_t)((*d).simplefunc);
    }else if (((int64_t)((*a).tag)==(int64_t)99)) {
        d = mm_decls_ttnamedef[((int64_t)((*a).mode))];
        simplefunc = (int64_t)1;
        e = (*d).paramlist;
        L589 :;
        while ((e != 0)) {
            if (!(!!(mm_lib_issimpletype((int64_t)((*d).mode))))) {
                simplefunc = (int64_t)0;
            };
            e = (*e).nextdef;
L590 :;
        }L591 :;
        ;
    } else {
        mm_support_gerror((uint8_t*)"call/not ptr",(struct mm_decls_unitrec *)(0));
    };
    if ((((*d).fflang == (int64_t)2) || ((*d).fflang == (int64_t)1))) {
        mm_blockpcl_do_callff(p,a,b,d,fncall);
        return;
    };
    if (!!(fncall)) {
        if (((int64_t)((*p).mode) == (int64_t)36)) {
            L592 :;
            for (i=(int64_t)((*d).nretvalues);i>=(int64_t)1;i-=(int64_t)1) {
L593 :;
                mm_libpcl_genpc((int64_t)18,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
                m = (int64_t)((*d).modelist[(i)-1]);
                mm_libpcl_setpclcat_t(m);
                if (!!((uint64_t)(mm_decls_ttisreal[(m)]))) {
                    mm_libpcl_makefloatopnds();
                };
                (*mm_libpcl_pccodex).mode = m;
L594 :;
            }L595 :;
            ;
        } else if (!!(simplefunc)) {
        } else {
            mm_libpcl_genpc((int64_t)18,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclcat_u(p);
            if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
                mm_libpcl_makefloatopnds();
            };
            (*mm_libpcl_pccodex).mode = (int64_t)((*p).mode);
        };
    };
    nparams = (int64_t)0;
    L596 :;
    while (!!(b)) {
        params[(++nparams)-1] = b;
        b = (*b).nextunit;
L597 :;
    }L598 :;
    ;
    L599 :;
    for (i=nparams;i>=(int64_t)1;i-=(int64_t)1) {
L600 :;
        q = params[(i)-1];
        if (!!(mm_blockpcl_isshortmem(q))) {
            mm_libpcl_genpc((int64_t)15,mm_libpcl_genmem_u(q,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclcat_u(q);
        } else {
            mm_blockpcl_evalunit(q);
        };
L601 :;
    }L602 :;
    ;
    mm_libpcl_genpc((int64_t)21,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    if (((int64_t)((*a).tag)==(int64_t)3)) {
        mm_libpcl_genpc((int64_t)57,mm_libpcl_genmemaddr_u(a),mm_libpcl_genint(nparams,(int64_t)8));
    } else {
        mm_blockpcl_evalunit((*a).a);
        mm_libpcl_genpc((int64_t)59,mm_libpcl_genint(nparams,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    };
    if ((!!(fncall) && !!(simplefunc))) {
        mm_libpcl_genpc((int64_t)20,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(p);
        if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
            mm_libpcl_makefloatopnds();
        };
        (*mm_libpcl_pccodex).mode = (int64_t)((*p).mode);
    };
}

static void mm_blockpcl_do_return(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    if (!!(a)) {
        mm_blockpcl_evalunit(a);
        if (!!((uint64_t)((*mm_decls_currproc).simplefunc))) {
            mm_libpcl_genpc((int64_t)39,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        } else {
            mm_libpcl_genpc((int64_t)38,mm_libpcl_genint(mm_libpcl_parambytes,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        };
        mm_libpcl_setpclcat_u(a);
        if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*a).mode))]))) {
            mm_libpcl_makefloatopnds();
        };
    };
    if (!!((uint64_t)((*mm_decls_currproc).simplefunc))) {
        mm_libpcl_genpc((int64_t)6,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_genjumpl(mm_libpcl_retindex);
    };
}

static void mm_blockpcl_do_returnmult(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t offset;
    offset = (int64_t)0;
    L603 :;
    while (!!(a)) {
        mm_blockpcl_evalunit(a);
        mm_libpcl_genpc((int64_t)38,mm_libpcl_genint((mm_libpcl_parambytes + offset),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(a);
        if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*a).mode))]))) {
            mm_libpcl_makefloatopnds();
        };
        offset += (int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))]);
        a = (*a).nextunit;
L604 :;
    }L605 :;
    ;
    if (((int64_t)((*p).mode) == (int64_t)0)) {
        mm_blockpcl_genjumpl(mm_libpcl_retindex);
    };
}

static void mm_blockpcl_do_assign(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t fstore) {
    struct mm_decls_unitrec *  c;
    struct mm_decls_strec *  d;
    int64_t offset;
    int64_t av_1;
    int64_t i;
    if ((((int64_t)((uint64_t)(mm_tables_stdtypecat[((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]))])) == (int64_t)32) && (fstore == (int64_t)0))) {
        if (((int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))])==(int64_t)1) || ((int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))])==(int64_t)2) || ((int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))])==(int64_t)4) || ((int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))])==(int64_t)8)) {
            if (((int64_t)((*b).tag) == (int64_t)19)) {
                mm_blockpcl_do_assignblock(p,a,b);
                return;
            };
        } else {
            mm_blockpcl_do_assignblock(p,a,b);
            return;
        };
    };
    if (((int64_t)((*a).tag)==(int64_t)19)) {
        if (!!(fstore)) {
            mm_support_gerror((uint8_t*)"multassign/store?",(struct mm_decls_unitrec *)(0));
        };
        mm_blockpcl_do_multassign(a,b);
        return;
    }else if (((int64_t)((*a).tag)==(int64_t)88)) {
        mm_blockpcl_do_popindex(p,(*a).a,(*a).b,b,(!!(fstore)?(int64_t)107:(int64_t)104));
        return;
    }else if (((int64_t)((*a).tag)==(int64_t)89)) {
        mm_blockpcl_do_popslice(p,(*a).a,(*a).b,b,(!!(fstore)?(int64_t)117:(int64_t)118));
        return;
    }else if (((int64_t)((*a).tag)==(int64_t)94)) {
        mm_blockpcl_do_popkeyindex(p,(*a).a,(*a).b,b,(!!(fstore)?(int64_t)115:(int64_t)116));
        return;
    }else if (((int64_t)((*a).tag)==(int64_t)95)) {
        mm_blockpcl_do_popdot(p,(*a).a,b,(int64_t)((*a).offset),(!!(fstore)?(int64_t)113:(int64_t)112));
        return;
    };
    mm_blockpcl_evalunit(b);
    switch ((int64_t)((*a).tag)) {
    case 3:;
    {
        mm_libpcl_genpc((!!(fstore)?(int64_t)35:(int64_t)32),mm_libpcl_genmem_u(a,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    }break;
    case 99:;
    {
        c = (*a).a;
        offset = (int64_t)0;
        if (((((*c).tag == (int64_t)43) || ((*c).tag == (int64_t)44)) && ((int64_t)((*(*c).b).tag) == (int64_t)1))) {
            offset = (((int64_t)((*c).tag) == (int64_t)43)?(*(*c).b).value:-((*(*c).b).value));
            mm_blockpcl_evalunit((*c).a);
        } else {
            mm_blockpcl_evalunit(c);
        };
        mm_libpcl_genpc((!!(fstore)?(int64_t)36:(int64_t)34),mm_libpcl_genint(offset,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    }break;
    case 209:;
    case 210:;
    case 224:;
    case 226:;
    case 229:;
    {
        mm_blockpcl_evalref(a);
        mm_libpcl_genpc((!!(fstore)?(int64_t)36:(int64_t)34),mm_libpcl_genint((int64_t)0,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    }break;
    case 90:;
    {
        mm_blockpcl_evalref((*a).a);
        mm_blockpcl_evalunit((*a).b);
        if (!!(fstore)) {
            mm_support_gerror((uint8_t*)"storedotix?",(struct mm_decls_unitrec *)(0));
        } else {
            mm_libpcl_genpc((int64_t)123,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
        mm_libpcl_setpclcat_u(a);
        return;
    }break;
    case 91:;
    {
        mm_blockpcl_evalref((*a).a);
        mm_blockpcl_evalunit((*(*a).b).a);
        mm_blockpcl_evalunit((*(*a).b).b);
        if (!!(fstore)) {
            mm_support_gerror((uint8_t*)"storedotsl?",(struct mm_decls_unitrec *)(0));
        } else {
            mm_libpcl_genpc((int64_t)124,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
        mm_libpcl_setpclcat_u(a);
        return;
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*a).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"Can't assign",(struct mm_decls_unitrec *)(0));
    }
    } //SW
;
    mm_libpcl_setpclcat_u(a);
    if (((int64_t)((*b).mode) == (int64_t)36)) {
        if (!!(fstore)) {
            mm_support_gerror((uint8_t*)"chained assign not allowed",(struct mm_decls_unitrec *)(0));
        };
        if ((((int64_t)((*b).tag) != (int64_t)31) || ((int64_t)((*(*b).a).tag) != (int64_t)3))) {
            mm_support_gerror((uint8_t*)"assign/mult/call error",(struct mm_decls_unitrec *)(0));
        };
        d = (*(*b).a).def;
        L606 :;
        for (i=(int64_t)2;i<=(int64_t)((*d).nretvalues);i+=(int64_t)1) {
L607 :;
            mm_libpcl_genpc((int64_t)44,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclcat_t((int64_t)((*d).modelist[(i)-1]));
            if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*d).modelist[(i)-1]))]))) {
                mm_libpcl_makefloatopnds();
            };
L608 :;
        }L609 :;
        ;
    };
}

static void mm_blockpcl_do_shallowcopy(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_shallowcopy");
}

static void mm_blockpcl_do_to(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_unitrec *  avar;
    struct mm_libpcl_pclopndrec avaropnd;
    int64_t lab_a;
    int64_t lab_b;
    int64_t lab_c;
    int64_t lab_d;
    int64_t count;
    avar = (*p).c;
    avaropnd = (*mm_libpcl_genmem_u(avar,(int64_t)0));
    lab_a = mm_libpcl_definelabel();
    (*a).mode = (int64_t)4;
    mm_blockpcl_evalunit(a);
    mm_libpcl_genpc((int64_t)32,&avaropnd,(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_t((int64_t)4);
    lab_b = mm_libpcl_createfwdlabel();
    lab_c = mm_libpcl_createfwdlabel();
    lab_d = mm_libpcl_createfwdlabel();
    mm_blockpcl_stacklooplabels(lab_a,lab_b,lab_c,lab_d);
    if (((int64_t)((*a).tag) != (int64_t)1)) {
        mm_libpcl_genpc((int64_t)14,&avaropnd,(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_t((int64_t)4);
        mm_libpcl_genpc((int64_t)22,mm_libpcl_zero_opnd,(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_genpc_condlab((int64_t)64,(int64_t)39,lab_d);
        mm_libpcl_setpclmode_t((int64_t)4);
    } else {
        count = (*a).value;
        if ((count <= (int64_t)0)) {
            mm_blockpcl_genjumpl(lab_d);
        };
    };
    mm_libpcl_definefwdlabel(lab_b);
    mm_blockpcl_evalunit(b);
    mm_libpcl_definefwdlabel(lab_c);
    mm_libpcl_genpc((int64_t)187,&avaropnd,(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_t((int64_t)4);
    mm_libpcl_genpc((int64_t)14,&avaropnd,(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_t((int64_t)4);
    mm_libpcl_genpc((int64_t)66,mm_libpcl_genlabel(lab_b,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclmode_t((int64_t)4);
    mm_libpcl_definefwdlabel(lab_d);
    --mm_blockpcl_loopindex;
}

static void mm_blockpcl_do_if(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t isref) {
    int64_t lab1;
    int64_t lab2;
    int64_t ismult;
    ismult = ((int64_t)((*p).mode) != (int64_t)0);
    if (!!(ismult)) {
        mm_libpcl_genpc((int64_t)8,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    lab1 = mm_libpcl_createfwdlabel();
    mm_blockpcl_genjumpcond((int64_t)0,a,lab1);
    if (!!(isref)) {
        mm_blockpcl_evalref(b);
    } else {
        mm_blockpcl_evalunit(b);
    };
    if (!!(ismult)) {
        mm_libpcl_genpc((int64_t)9,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    if (!!(c)) {
        lab2 = mm_libpcl_createfwdlabel();
        mm_blockpcl_genjumpl(lab2);
        mm_libpcl_definefwdlabel(lab1);
        if (!!(isref)) {
            mm_blockpcl_evalref(c);
        } else {
            mm_blockpcl_evalunit(c);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)10,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
        mm_libpcl_definefwdlabel(lab2);
    } else {
        mm_libpcl_definefwdlabel(lab1);
    };
}

static void mm_blockpcl_do_longif(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t isref) {
    int64_t labend;
    int64_t i;
    int64_t lab2;
    int64_t ismult;
    struct mm_decls_unitrec *  pcond;
    labend = mm_libpcl_createfwdlabel();
    ismult = ((int64_t)((*p).mode) != (int64_t)0);
    pcond = a;
    i = (int64_t)0;
    if (!!(ismult)) {
        mm_libpcl_genpc((int64_t)8,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    L610 :;
    while (!!(pcond)) {
        ++i;
        lab2 = mm_libpcl_createfwdlabel();
        mm_blockpcl_genjumpcond((int64_t)0,(*pcond).a,lab2);
        if (!!(isref)) {
            mm_blockpcl_evalref((*pcond).b);
        } else {
            mm_blockpcl_evalunit((*pcond).b);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)9,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
        if ((!!((*pcond).nextunit) || !!(b))) {
            mm_blockpcl_genjumpl(labend);
        };
        mm_libpcl_definefwdlabel(lab2);
        pcond = (*pcond).nextunit;
L611 :;
    }L612 :;
    ;
    if (!!(b)) {
        if (!!(isref)) {
            mm_blockpcl_evalref(b);
        } else {
            mm_blockpcl_evalunit(b);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)10,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
    };
    mm_libpcl_definefwdlabel(labend);
}

static void mm_blockpcl_do_for(struct mm_decls_unitrec * p,struct mm_decls_unitrec * ivar,struct mm_decls_unitrec * pbody,struct mm_decls_unitrec * pautovar,int64_t down) {
    struct mm_decls_unitrec *  pfrom;
    struct mm_decls_unitrec *  pto;
    struct mm_decls_unitrec *  pstep;
    struct mm_decls_unitrec *  pelse;
    struct mm_decls_unitrec *  px;
    struct mm_decls_unitrec *  plimit;
    struct mm_libpcl_pclopndrec indexopnd;
    int64_t lab_a;
    int64_t lab_b;
    int64_t lab_c;
    int64_t lab_d;
    int64_t lab_e;
    int64_t a;
    int64_t b;
    struct mm_decls_strec *  d;
    if (((int64_t)((*ivar).tag) != (int64_t)3)) {
        mm_support_gerror((uint8_t*)"complex (non-i64) for-loop var?",(struct mm_decls_unitrec *)(0));
    };
    pfrom = (*ivar).nextunit;
    pto = (*pfrom).nextunit;
    if (((int64_t)((*pto).tag) == (int64_t)99)) {
        px = (*pto).a;
        if (((((int64_t)((*px).tag) == (int64_t)3) && ((int64_t)((uint64_t)((*(d = (*px).def)).nameid)) == (int64_t)11)) && ((int64_t)((uint64_t)((*d).parammode)) == (int64_t)2))) {
            mm_support_gerror((uint8_t*)"Possibly using &param as for-loop limit",(struct mm_decls_unitrec *)(0));
        };
    };
    pstep = (*pto).nextunit;
    pelse = (*pbody).nextunit;
    lab_a = mm_libpcl_definelabel();
    lab_b = mm_libpcl_createfwdlabel();
    lab_c = mm_libpcl_createfwdlabel();
    lab_d = mm_libpcl_createfwdlabel();
    if (!!(pelse)) {
        lab_e = mm_libpcl_createfwdlabel();
    } else {
        lab_e = lab_d;
    };
    mm_blockpcl_stacklooplabels(lab_a,lab_b,lab_c,lab_d);
    mm_blockpcl_evalunit(pfrom);
    indexopnd = (*mm_libpcl_genmem_u(ivar,(int64_t)0));
    mm_libpcl_genpc((int64_t)32,&indexopnd,(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(ivar);
    if (!!(pautovar)) {
        (*pautovar).mode = (int64_t)4;
        mm_blockpcl_evalunit(pto);
        mm_libpcl_genpc((int64_t)32,mm_libpcl_genmem_u(pautovar,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(pautovar);
        plimit = pautovar;
    } else {
        plimit = pto;
    };
    if ((((int64_t)((*pfrom).tag) == (int64_t)1) && ((int64_t)((*pto).tag) == (int64_t)1))) {
        a = (*pfrom).value;
        b = (*pto).value;
        if (((!!(down) && (a >= b)) || (!(!!(down)) && (a <= b)))) {
        } else {
            mm_libpcl_genpc((int64_t)63,mm_libpcl_genlabel(lab_e,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        };
    } else {
        if (((int64_t)((*pfrom).tag) == (int64_t)1)) {
            mm_blockpcl_evalunit(plimit);
            mm_libpcl_genpc_condlab((int64_t)65,(!!(down)?(int64_t)40:(int64_t)38),lab_e);
            (*mm_libpcl_pccodex).b = (*mm_libpcl_genint((*pfrom).value,(int64_t)8));
        } else {
            mm_libpcl_genpc((int64_t)14,&indexopnd,(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclcat_u(ivar);
            mm_blockpcl_evalunit(plimit);
            mm_libpcl_genpc_condlab((int64_t)64,(!!(down)?(int64_t)38:(int64_t)40),lab_e);
        };
        mm_libpcl_setpclmode_t((int64_t)4);
    };
    mm_libpcl_definefwdlabel(lab_b);
    mm_blockpcl_evalunit(pbody);
    mm_libpcl_definefwdlabel(lab_c);
    if (!!(pstep)) {
        mm_libpcl_genpc((int64_t)14,&indexopnd,(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(ivar);
        mm_blockpcl_evalunit(pstep);
        mm_libpcl_genpc((!!(down)?(int64_t)46:(int64_t)45),(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclmode_t((int64_t)4);
        mm_libpcl_genpc((int64_t)32,&indexopnd,(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(ivar);
    } else {
        mm_libpcl_genpc((!!(down)?(int64_t)187:(int64_t)186),&indexopnd,(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_t((int64_t)4);
    };
    mm_libpcl_genpc((int64_t)14,&indexopnd,(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(ivar);
    if (!!(mm_blockpcl_isshortconst(plimit))) {
        mm_libpcl_genpc_condlab((int64_t)65,(!!(down)?(int64_t)41:(int64_t)39),lab_b);
        (*mm_libpcl_pccodex).b = (*mm_libpcl_genint((*plimit).value,(int64_t)8));
    } else {
        mm_blockpcl_evalunit(plimit);
        mm_libpcl_genpc_condlab((int64_t)64,(!!(down)?(int64_t)41:(int64_t)39),lab_b);
    };
    mm_libpcl_setpclmode_t((int64_t)4);
    if (!!(pelse)) {
        mm_libpcl_definefwdlabel(lab_e);
        mm_blockpcl_evalunit(pelse);
    };
    mm_libpcl_definefwdlabel(lab_d);
    --mm_blockpcl_loopindex;
}

static void mm_blockpcl_do_cfor(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_cfor");
}

static void mm_blockpcl_do_while(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pcond,struct mm_decls_unitrec * pbody) {
    int64_t lab_b;
    int64_t lab_c;
    int64_t lab_d;
    lab_b = mm_libpcl_createfwdlabel();
    lab_c = mm_libpcl_createfwdlabel();
    lab_d = mm_libpcl_createfwdlabel();
    mm_blockpcl_stacklooplabels(lab_c,lab_b,lab_c,lab_d);
    mm_blockpcl_genjumpl(lab_c);
    mm_libpcl_definefwdlabel(lab_b);
    mm_blockpcl_evalunit(pbody);
    mm_libpcl_definefwdlabel(lab_c);
    mm_blockpcl_genjumpcond((int64_t)1,pcond,lab_b);
    mm_libpcl_definefwdlabel(lab_d);
    --mm_blockpcl_loopindex;
}

static void mm_blockpcl_do_repeat(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t lab_ab;
    int64_t lab_c;
    int64_t lab_d;
    lab_ab = mm_libpcl_definelabel();
    lab_c = mm_libpcl_createfwdlabel();
    lab_d = mm_libpcl_createfwdlabel();
    mm_blockpcl_stacklooplabels(lab_ab,lab_ab,lab_c,lab_d);
    mm_blockpcl_evalunit(a);
    mm_libpcl_definefwdlabel(lab_c);
    if (!((((int64_t)((*b).tag) == (int64_t)1) && ((*b).value == (int64_t)0)))) {
        mm_blockpcl_genjumpcond((int64_t)0,b,lab_ab);
    };
    mm_libpcl_definefwdlabel(lab_d);
    --mm_blockpcl_loopindex;
}

static void mm_blockpcl_do_goto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_strec *  d;
    if (((int64_t)((*a).tag)==(int64_t)3)) {
        d = (*a).def;
        if (((int64_t)((*d).index) == (int64_t)0)) {
            (*d).index = ++mm_decls_labelno;
        };
        mm_libpcl_genpc((int64_t)63,mm_libpcl_genlabel((int64_t)((*d).index),(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_support_gerror((uint8_t*)"GOTO PTR",(struct mm_decls_unitrec *)(0));
    };
}

static void mm_blockpcl_do_gotoblock(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_gotoblock");
}

static void mm_blockpcl_do_labeldef(struct mm_decls_unitrec * p) {
    struct mm_decls_strec *  d;
    d = (*p).def;
    if (((int64_t)((*d).index) == (int64_t)0)) {
        (*d).index = ++mm_decls_labelno;
    };
    mm_libpcl_gencomment((*d).name);
    mm_libpcl_genpc((int64_t)3,mm_libpcl_genlabel((int64_t)((*d).index),(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_exit(struct mm_decls_unitrec * p,int64_t k) {
    int64_t n;
    int64_t index;
    index = (int64_t)((*p).index);
    if ((index == (int64_t)0)) {
        index = mm_blockpcl_loopindex;
    };
    n = mm_blockpcl_findlooplabel(k,index);
    if ((n == (int64_t)0)) {
        mm_support_gerror((uint8_t*)"Bad exit/loop index",p);
    } else {
        mm_blockpcl_genjumpl(n);
    };
}

static void mm_blockpcl_do_do(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t lab_abc;
    int64_t lab_d;
    lab_abc = mm_libpcl_definelabel();
    lab_d = mm_libpcl_createfwdlabel();
    mm_blockpcl_stacklooplabels(lab_abc,lab_abc,lab_abc,lab_d);
    mm_blockpcl_evalunit(a);
    mm_blockpcl_genjumpl(lab_abc);
    mm_libpcl_definefwdlabel(lab_d);
    --mm_blockpcl_loopindex;
}

static void mm_blockpcl_do_case(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pindex,struct mm_decls_unitrec * pwhenthen,struct mm_decls_unitrec * pelse,int64_t loopsw,int64_t isref) {
    int64_t labtable[256];
    struct mm_decls_unitrec *  unittable[256];
    int64_t ncases;
    int64_t lab_abc;
    int64_t lab_d;
    int64_t ismult;
    int64_t labelse;
    struct mm_decls_unitrec *  w;
    struct mm_decls_unitrec *  wt;
    int64_t i;
    if ((pindex == 0)) {
        mm_support_gerror((uint8_t*)"EMPTY CASE NOT DONE",(struct mm_decls_unitrec *)(0));
    };
    ismult = (((int64_t)((*p).mode) != (int64_t)0) && !(loopsw));
    if (!!(loopsw)) {
        lab_abc = mm_libpcl_definelabel();
        lab_d = mm_libpcl_createfwdlabel();
        mm_blockpcl_stacklooplabels(lab_abc,lab_abc,lab_abc,lab_d);
    } else {
        lab_d = mm_libpcl_createfwdlabel();
    };
    if (!!(ismult)) {
        mm_libpcl_genpc((int64_t)8,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_blockpcl_evalunit(pindex);
    if ((mm_blockpcl_casedepth >= (int64_t)20)) {
        mm_support_gerror((uint8_t*)"case nested too deeply",(struct mm_decls_unitrec *)(0));
    };
    mm_blockpcl_casestmt[(++mm_blockpcl_casedepth)-1] = p;
    ncases = (int64_t)0;
    wt = pwhenthen;
    L613 :;
    while (!!(wt)) {
        w = (*wt).a;
        if ((ncases >= (int64_t)256)) {
            mm_support_gerror((uint8_t*)"too many cases",(struct mm_decls_unitrec *)(0));
        };
        labtable[(++ncases)-1] = mm_libpcl_createfwdlabel();
        unittable[(ncases)-1] = (*wt).b;
        L616 :;
        while (!!(w)) {
            mm_blockpcl_evalunit(w);
            mm_libpcl_genpc((int64_t)70,mm_libpcl_genlabel((int64_t)(((*w).whenlabel = labtable[(ncases)-1])),(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclmode_u(w);
            w = (*w).nextunit;
L617 :;
        }L618 :;
        ;
        wt = (*wt).nextunit;
L614 :;
    }L615 :;
    ;
    mm_libpcl_genpc((int64_t)44,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(pindex);
    labelse = mm_libpcl_createfwdlabel();
    mm_blockpcl_caseelse[(mm_blockpcl_casedepth)-1] = labelse;
    mm_blockpcl_genjumpl(labelse);
    L619 :;
    for (i=(int64_t)1;i<=ncases;i+=(int64_t)1) {
L620 :;
        mm_libpcl_definefwdlabel(labtable[(i)-1]);
        if (!!(isref)) {
            mm_blockpcl_evalref(unittable[(i)-1]);
        } else {
            mm_blockpcl_evalunit(unittable[(i)-1]);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)9,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
        if (!!(loopsw)) {
            mm_blockpcl_genjumpl(lab_abc);
        } else {
            mm_blockpcl_genjumpl(lab_d);
        };
L621 :;
    }L622 :;
    ;
    mm_libpcl_definefwdlabel(labelse);
    if (!!(pelse)) {
        if (!!(isref)) {
            mm_blockpcl_evalref(pelse);
        } else {
            mm_blockpcl_evalunit(pelse);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)10,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
    };
    if (!!(loopsw)) {
        mm_blockpcl_genjumpl(lab_abc);
        mm_libpcl_definefwdlabel(lab_d);
        --mm_blockpcl_loopindex;
    } else {
        mm_libpcl_definefwdlabel(lab_d);
    };
    --mm_blockpcl_casedepth;
}

static void mm_blockpcl_do_emptycase(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pindex,struct mm_decls_unitrec * pwhenthen,struct mm_decls_unitrec * pelse,int64_t loopsw,int64_t isref) {
    int64_t lab_abc;
    int64_t lab_d;
    int64_t fmult;
    int64_t labnextwhen;
    int64_t labstmtstart;
    int64_t ismult;
    struct mm_decls_unitrec *  w;
    struct mm_decls_unitrec *  wt;
    ismult = (((int64_t)((*p).mode) != (int64_t)0) && !(loopsw));
    if (!!(loopsw)) {
        lab_abc = mm_libpcl_definelabel();
        lab_d = mm_libpcl_createfwdlabel();
        mm_blockpcl_stacklooplabels(lab_abc,lab_abc,lab_abc,lab_d);
    } else {
        lab_d = mm_libpcl_createfwdlabel();
    };
    if (!!(ismult)) {
        mm_libpcl_genpc((int64_t)8,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    if (!!(pindex)) {
        mm_blockpcl_evalunit(pindex);
    };
    wt = pwhenthen;
    L623 :;
    while (!!(wt)) {
        w = (*wt).a;
        fmult = ((*w).nextunit != 0);
        labnextwhen = mm_libpcl_createfwdlabel();
        if (!!(fmult)) {
            labstmtstart = mm_libpcl_createfwdlabel();
        };
        L626 :;
        while (!!(w)) {
            if (!!(pindex)) {
                mm_blockpcl_evalunit(w);
                if (!!((*w).nextunit)) {
                    mm_libpcl_genpc((int64_t)70,mm_libpcl_genlabel(labstmtstart,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
                } else {
                    mm_libpcl_genpc((int64_t)71,mm_libpcl_genlabel(labnextwhen,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
                };
                mm_libpcl_setpclmode_u(w);
            } else {
                if (!!((*w).nextunit)) {
                    mm_blockpcl_genjumpcond((int64_t)1,w,labstmtstart);
                } else {
                    mm_blockpcl_genjumpcond((int64_t)0,w,labnextwhen);
                };
            };
            w = (*w).nextunit;
L627 :;
        }L628 :;
        ;
        if (!!(fmult)) {
            mm_libpcl_definefwdlabel(labstmtstart);
        };
        if (!!(pindex)) {
            mm_libpcl_genpc((int64_t)44,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
            mm_libpcl_setpclcat_u(pindex);
        };
        if (!!(isref)) {
            mm_blockpcl_evalref((*wt).b);
        } else {
            mm_blockpcl_evalunit((*wt).b);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)9,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
        if (!(!!(loopsw))) {
            if ((!!((*wt).nextunit) || !!(pelse))) {
                mm_blockpcl_genjumpl(lab_d);
            };
        } else {
            mm_blockpcl_genjumpl(lab_abc);
        };
        mm_libpcl_definefwdlabel(labnextwhen);
        wt = (*wt).nextunit;
L624 :;
    }L625 :;
    ;
    if (!!(pindex)) {
        mm_libpcl_genpc((int64_t)44,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(pindex);
    };
    if (!!(pelse)) {
        if (!!(isref)) {
            mm_blockpcl_evalref(pelse);
        } else {
            mm_blockpcl_evalunit(pelse);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)10,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
    };
    if (!!(loopsw)) {
        mm_blockpcl_genjumpl(lab_abc);
        mm_libpcl_definefwdlabel(lab_d);
        --mm_blockpcl_loopindex;
    } else {
        mm_libpcl_definefwdlabel(lab_d);
    };
}

static void mm_blockpcl_do_switch(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pindex,struct mm_decls_unitrec * pwhenthen,struct mm_decls_unitrec * pelse,int64_t loopsw,int64_t isref) {
    int64_t minlab;
    int64_t maxlab;
    int64_t n;
    int64_t iscomplex;
    int64_t i;
    int64_t lab_a;
    int64_t lab_d;
    int64_t labjump;
    int64_t elselab;
    int64_t labstmt;
    int64_t ax;
    int64_t bx;
    int64_t ismult;
    struct mm_libpcl_pclrec *  labels[1001];
    struct mm_decls_unitrec *  w;
    struct mm_decls_unitrec *  wt;
    ismult = (((int64_t)((*p).mode) != (int64_t)0) && !(loopsw));
    minlab = (int64_t)1000000;
    maxlab = (int64_t)-1000000;
    n = (int64_t)0;
    iscomplex = (int64_t)0;
    wt = pwhenthen;
    L629 :;
    while (!!(wt)) {
        w = (*wt).a;
        L632 :;
        while (!!(w)) {
            if (((int64_t)((*w).tag)==(int64_t)20)) {
                ax = (*(*w).a).value;
                bx = (*(*w).b).value;
                //dorange:
L635 :;
;
                L636 :;
                for (i=ax;i<=bx;i+=(int64_t)1) {
L637 :;
                    minlab = (i<minlab?i:minlab);
                    maxlab = (i>maxlab?i:maxlab);
L638 :;
                }L639 :;
                ;
            }else if (((int64_t)((*w).tag)==(int64_t)1)) {
                ax = (bx = (*w).value);
                goto L635 ;
;
            } else {
                mm_support_gerror_s((uint8_t*)"Switch when2: not const: #",(*mm_lib_strexpr(w)).strptr,(struct mm_decls_unitrec *)(0));
            };
            w = (*w).nextunit;
L633 :;
        }L634 :;
        ;
        wt = (*wt).nextunit;
L630 :;
    }L631 :;
    ;
    n = ((maxlab - minlab) + (int64_t)1);
    if ((n > (int64_t)1000)) {
        mm_support_gerror((uint8_t*)"Switch too big",(struct mm_decls_unitrec *)(0));
    };
    if (!!(loopsw)) {
        lab_a = mm_libpcl_definelabel();
        lab_d = mm_libpcl_createfwdlabel();
        mm_blockpcl_stacklooplabels(lab_a,lab_a,lab_a,lab_d);
    } else {
        lab_d = mm_libpcl_createfwdlabel();
    };
    if (!!(ismult)) {
        mm_libpcl_genpc((int64_t)8,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_blockpcl_evalunit(pindex);
    labjump = mm_libpcl_createfwdlabel();
    elselab = mm_libpcl_createfwdlabel();
    mm_libpcl_genpc((int64_t)77,mm_libpcl_genint(minlab,(int64_t)8),mm_libpcl_genint(maxlab,(int64_t)8));
    mm_libpcl_genpc((int64_t)75,mm_libpcl_genlabel(labjump,(int64_t)0),mm_libpcl_genlabel(elselab,(int64_t)0));
    mm_libpcl_definefwdlabel(labjump);
    L640 :;
    for (i=minlab;i<=maxlab;i+=(int64_t)1) {
L641 :;
        mm_libpcl_genpc((int64_t)76,mm_libpcl_genlabel(elselab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        labels[(i)] = mm_libpcl_pccodex;
L642 :;
    }L643 :;
    ;
    mm_libpcl_genpc((int64_t)78,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    wt = pwhenthen;
    L644 :;
    while (!!(wt)) {
        labstmt = mm_libpcl_definelabel();
        w = (*wt).a;
        L647 :;
        while (!!(w)) {
            if (((int64_t)((*w).tag)==(int64_t)20)) {
                ax = (*(*w).a).value;
                bx = (*(*w).b).value;
            }else if (((int64_t)((*w).tag)==(int64_t)1)) {
                ax = (bx = (*w).value);
            };
            L650 :;
            for (i=ax;i<=bx;i+=(int64_t)1) {
L651 :;
                (*labels[(i)]).a = (*mm_libpcl_genlabel(labstmt,(int64_t)0));
L652 :;
            }L653 :;
            ;
            w = (*w).nextunit;
L648 :;
        }L649 :;
        ;
        if (!!(isref)) {
            mm_blockpcl_evalref((*wt).b);
        } else {
            mm_blockpcl_evalunit((*wt).b);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)9,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
        mm_blockpcl_genjumpl((!!(loopsw)?lab_a:lab_d));
        wt = (*wt).nextunit;
L645 :;
    }L646 :;
    ;
    mm_libpcl_definefwdlabel(elselab);
    if (!!(pelse)) {
        if (!!(isref)) {
            mm_blockpcl_evalref(pelse);
        } else {
            mm_blockpcl_evalunit(pelse);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)10,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
    };
    if (!!(loopsw)) {
        mm_blockpcl_genjumpl(lab_a);
        mm_libpcl_definefwdlabel(lab_d);
        --mm_blockpcl_loopindex;
    } else {
        mm_libpcl_definefwdlabel(lab_d);
    };
}

static void mm_blockpcl_do_swap(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    if ((((int64_t)((*a).tag) == (int64_t)3) && ((int64_t)((*b).tag) == (int64_t)3))) {
        mm_blockpcl_evalunit(a);
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc((int64_t)32,mm_libpcl_genmem_u(a,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(b);
        mm_libpcl_genpc((int64_t)32,mm_libpcl_genmem_u(b,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(a);
    } else {
        mm_blockpcl_evalref(a);
        mm_blockpcl_evalref(b);
        mm_libpcl_genpc((int64_t)210,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(a);
    };
}

static void mm_blockpcl_do_select(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t isref) {
    struct mm_libpcl_pclrec *  labels[256];
    int64_t labend;
    int64_t labjump;
    int64_t n;
    int64_t i;
    int64_t elselab;
    int64_t labstmt;
    int64_t ismult;
    struct mm_decls_unitrec *  q;
    ismult = ((int64_t)((*p).mode) != (int64_t)0);
    q = b;
    n = (int64_t)0;
    L654 :;
    while (!!(q)) {
        if ((n >= (int64_t)256)) {
            mm_support_gerror((uint8_t*)"selectx: too many labels",(struct mm_decls_unitrec *)(0));
        };
        ++n;
        q = (*q).nextunit;
L655 :;
    }L656 :;
    ;
    labend = mm_libpcl_createfwdlabel();
    labjump = mm_libpcl_createfwdlabel();
    elselab = mm_libpcl_createfwdlabel();
    if (!!(ismult)) {
        mm_libpcl_genpc((int64_t)8,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_blockpcl_evalunit(a);
    mm_libpcl_genpc((int64_t)77,mm_libpcl_genint((int64_t)1,(int64_t)8),mm_libpcl_genint(n,(int64_t)8));
    mm_libpcl_genpc((int64_t)75,mm_libpcl_genlabel(labjump,(int64_t)0),mm_libpcl_genlabel(elselab,(int64_t)0));
    mm_libpcl_definefwdlabel(labjump);
    q = b;
    i = (int64_t)0;
    L657 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L658 :;
        mm_libpcl_genpc((int64_t)76,mm_libpcl_genlabel(elselab,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        labels[(i)-1] = mm_libpcl_pccodex;
L659 :;
    }L660 :;
    ;
    mm_libpcl_genpc((int64_t)78,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    q = b;
    i = (int64_t)0;
    L661 :;
    while (!!(q)) {
        labstmt = mm_libpcl_definelabel();
        ++i;
        (*labels[(i)-1]).a = (*mm_libpcl_genlabel(labstmt,(int64_t)0));
        if (!!(isref)) {
            mm_blockpcl_evalref(q);
        } else {
            mm_blockpcl_evalunit(q);
        };
        if (!!(ismult)) {
            mm_libpcl_genpc((int64_t)9,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        };
        mm_blockpcl_genjumpl(labend);
        q = (*q).nextunit;
L662 :;
    }L663 :;
    ;
    mm_libpcl_definefwdlabel(elselab);
    if (!!(isref)) {
        mm_blockpcl_evalref(c);
    } else {
        mm_blockpcl_evalunit(c);
    };
    if (!!(ismult)) {
        mm_libpcl_genpc((int64_t)10,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_definefwdlabel(labend);
}

static void mm_blockpcl_do_print(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  r;
    int64_t m;
    int64_t widenop;
    int64_t fn;
    if (!!(a)) {
        mm_blockpcl_evalunit(a);
        if (!(((mm_decls_ttbasetype[((int64_t)((*a).mode))] == (int64_t)19) || (mm_decls_ttbasetype[((int64_t)((*a).mode))] == (int64_t)33)))) {
            mm_support_gerror((uint8_t*)"@dev no ref",(struct mm_decls_unitrec *)(0));
        };
        if (((int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))])==(int64_t)0)) {
            mm_libpcl_do_syscallproc((int64_t)23,(int64_t)1,(int64_t)0);
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))])==(int64_t)13)) {
            mm_libpcl_do_syscallproc((int64_t)24,(int64_t)1,(int64_t)0);
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))])==(int64_t)19)) {
            mm_libpcl_do_syscallproc((int64_t)25,(int64_t)1,(int64_t)0);
        } else {
            mm_support_gerror((uint8_t*)"@dev?",(struct mm_decls_unitrec *)(0));
        };
    } else {
        mm_libpcl_do_syscallproc((int64_t)26,(int64_t)0,(int64_t)0);
    };
    q = b;
    if (((int64_t)((*p).tag)==(int64_t)233) || ((int64_t)((*p).tag)==(int64_t)234)) {
        if ((((int64_t)(mm_decls_ttbasetype[((int64_t)((*q).mode))]) != (int64_t)19) || ((int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[((int64_t)((*q).mode))]))]) != (int64_t)13))) {
            mm_support_gerror((uint8_t*)"string expected",(struct mm_decls_unitrec *)(0));
        };
        mm_blockpcl_evalunit(q);
        mm_libpcl_do_syscallproc((int64_t)27,(int64_t)1,(int64_t)0);
        q = (*p).c;
    };
    L664 :;
    while (!!(q)) {
        if (((int64_t)((*q).tag)==(int64_t)199)) {
            mm_blockpcl_evalunit((*q).b);
            mm_libpcl_genpc((int64_t)21,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
            r = (*q).a;
            m = (int64_t)((*r).mode);
        }else if (((int64_t)((*q).tag)==(int64_t)200)) {
            mm_libpcl_do_syscallproc((int64_t)28,(int64_t)0,(int64_t)0);
            q = (*q).nextunit;
            goto L665 ;
        } else {
            mm_libpcl_genpc((int64_t)22,mm_libpcl_zero_opnd,(struct mm_libpcl_pclopndrec *)(0));
            r = q;
            m = (int64_t)((*q).mode);
        };
        widenop = (int64_t)0;
        switch ((int64_t)(mm_decls_ttbasetype[(m)])) {
        case 4:;
        {
            fn = (int64_t)29;
        }break;
        case 1:;
        case 2:;
        case 3:;
        {
            fn = (int64_t)29;
            widenop = (int64_t)195;
        }break;
        case 9:;
        {
            fn = (int64_t)30;
        }break;
        case 6:;
        case 7:;
        case 8:;
        {
            fn = (int64_t)30;
            widenop = (int64_t)196;
        }break;
        case 11:;
        {
            fn = (int64_t)31;
            widenop = (int64_t)205;
        }break;
        case 12:;
        {
            fn = (int64_t)31;
        }break;
        case 5:;
        {
            fn = (int64_t)32;
        }break;
        case 10:;
        {
            fn = (int64_t)33;
        }break;
        case 19:;
        {
            if ((((int64_t)(mm_decls_tttarget[(m)]) == (int64_t)13) || (((int64_t)(mm_decls_tttarget[(m)]) == (int64_t)24) && ((int64_t)(mm_decls_tttarget[((int64_t)(mm_decls_tttarget[(m)]))]) == (int64_t)13)))) {
                fn = (int64_t)34;
            } else {
                fn = (int64_t)36;
            };
        }break;
        case 24:;
        {
            mm_support_gerror((uint8_t*)"PRINTARRAY",(struct mm_decls_unitrec *)(0));
            q = (*q).nextunit;
        }break;
        case 25:;
        {
            mm_support_gerror((uint8_t*)"PRINTRECORD",(struct mm_decls_unitrec *)(0));
        }break;
        case 23:;
        {
            if (((int64_t)(mm_decls_tttarget[(m)]) == (int64_t)13)) {
                fn = (int64_t)35;
            } else {
                mm_support_gerror((uint8_t*)"PRINTSLICE",(struct mm_decls_unitrec *)(0));
            };
        }break;
        case 13:;
        case 14:;
        case 15:;
        {
            fn = (int64_t)37;
        }break;
        case 33:;
        {
            fn = (int64_t)154;
        }break;
        default: {
            mm_support_gerror_s((uint8_t*)"PRINT/T=#",mm_lib_strmode(m,(int64_t)1),(struct mm_decls_unitrec *)(0));
        }
        } //SW
;
        mm_blockpcl_evalunit(r);
        if (!!(widenop)) {
            mm_libpcl_genpc(widenop,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
            (*mm_libpcl_pccodex).mode = m;
            if ((widenop==(int64_t)195)) {
                (*mm_libpcl_pccodex).mode2 = (int64_t)4;
            }else if ((widenop==(int64_t)196)) {
                (*mm_libpcl_pccodex).mode2 = (int64_t)9;
            }else if ((widenop==(int64_t)205)) {
                (*mm_libpcl_pccodex).mode2 = (int64_t)12;
            };
        };
        mm_libpcl_do_syscallproc(fn,(int64_t)2,(int64_t)0);
        q = (*q).nextunit;
L665 :;
    }L666 :;
    ;
    if (((int64_t)((*p).tag)==(int64_t)232) || ((int64_t)((*p).tag)==(int64_t)234)) {
        mm_libpcl_do_syscallproc((int64_t)38,(int64_t)0,(int64_t)0);
    };
    mm_libpcl_do_syscallproc((int64_t)39,(int64_t)0,(int64_t)0);
}

static void mm_blockpcl_do_read(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t m;
    if (!!(a)) {
        mm_blockpcl_evalunit(a);
    } else {
        mm_libpcl_genpc((int64_t)22,mm_libpcl_zero_opnd,(struct mm_libpcl_pclopndrec *)(0));
    };
    m = (int64_t)((*p).mode);
    if (!!((uint64_t)(mm_decls_ttisinteger[(m)]))) {
        mm_libpcl_do_syscallproc((int64_t)40,(int64_t)1,(int64_t)0);
    } else if (!!((uint64_t)(mm_decls_ttisreal[(m)]))) {
        mm_libpcl_do_syscallproc((int64_t)41,(int64_t)1,(int64_t)0);
    } else if ((m == mm_tables_trefchar)) {
        mm_libpcl_do_syscallproc((int64_t)42,(int64_t)1,(int64_t)0);
    } else {
        mm_support_gerror((uint8_t*)"CAN'T READ THIS ITEM",(struct mm_decls_unitrec *)(0));
    };
    mm_libpcl_genpc((int64_t)20,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(p);
    if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
        mm_libpcl_makefloatopnds();
    };
    (*mm_libpcl_pccodex).mode = (int64_t)((*p).mode);
}

static void mm_blockpcl_do_readln(struct mm_decls_unitrec * a) {
    if (!!(a)) {
        mm_blockpcl_evalunit(a);
        if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]) != (int64_t)19)) {
            mm_support_gerror((uint8_t*)"@dev no ref",(struct mm_decls_unitrec *)(0));
        };
        if (((int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))])==(int64_t)0)) {
            mm_libpcl_do_syscallproc((int64_t)43,(int64_t)1,(int64_t)0);
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))])==(int64_t)6)) {
            mm_libpcl_do_syscallproc((int64_t)44,(int64_t)1,(int64_t)0);
        } else {
            mm_support_gerror((uint8_t*)"rd@dev?",(struct mm_decls_unitrec *)(0));
        };
    } else {
        mm_libpcl_do_syscallproc((int64_t)45,(int64_t)0,(int64_t)0);
    };
}

static void mm_blockpcl_do_cprint(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_cprint");
}

static void mm_blockpcl_do_cprintln(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_cprintln");
}

static void mm_blockpcl_do_sprint(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_sprint");
}

static void mm_blockpcl_do_sfprint(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_sfprint");
}

static void mm_blockpcl_do_sread(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_sread");
}

static void mm_blockpcl_do_sreadln(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_sreadln");
}

static void mm_blockpcl_do_stop(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    if (!!(a)) {
        mm_blockpcl_evalunit(a);
    } else {
        mm_libpcl_genpc((int64_t)22,mm_libpcl_zero_opnd,(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_do_syscallproc((int64_t)22,(int64_t)1,(int64_t)0);
}

static void mm_blockpcl_do_try(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_try");
}

static void mm_blockpcl_do_except(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_except");
}

static void mm_blockpcl_do_yield(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_yield");
}

static void mm_blockpcl_do_raise(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_raise");
}

static void mm_blockpcl_do_eval(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
}

static void mm_blockpcl_do_lambda(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_lambda");
}

static void mm_blockpcl_do_andl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t labfalse;
    int64_t labend;
    mm_libpcl_genpc((int64_t)8,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    labfalse = mm_libpcl_createfwdlabel();
    labend = mm_libpcl_createfwdlabel();
    mm_blockpcl_genjumpcond((int64_t)0,a,labfalse);
    mm_blockpcl_genjumpcond((int64_t)0,b,labfalse);
    mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((int64_t)1,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_genpc((int64_t)9,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_blockpcl_genjumpl(labend);
    mm_libpcl_definefwdlabel(labfalse);
    mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((int64_t)0,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_genpc((int64_t)10,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_definefwdlabel(labend);
}

static void mm_blockpcl_do_orl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t labtrue;
    int64_t labfalse;
    int64_t labend;
    mm_libpcl_genpc((int64_t)8,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    labtrue = mm_libpcl_createfwdlabel();
    labfalse = mm_libpcl_createfwdlabel();
    labend = mm_libpcl_createfwdlabel();
    mm_blockpcl_genjumpcond((int64_t)1,a,labtrue);
    mm_blockpcl_genjumpcond((int64_t)0,b,labfalse);
    mm_libpcl_definefwdlabel(labtrue);
    mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((int64_t)1,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_genpc((int64_t)9,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_blockpcl_genjumpl(labend);
    mm_libpcl_definefwdlabel(labfalse);
    mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((int64_t)0,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_genpc((int64_t)10,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_definefwdlabel(labend);
}

static void mm_blockpcl_do_xorl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_xorl");
}

static void mm_blockpcl_do_notl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_blockpcl_evalunit(a);
    if ((!(!!((uint64_t)(mm_decls_ttisvar[((int64_t)((*a).mode))]))) && !(!!(mm_libpcl_islogical(a))))) {
        mm_libpcl_genpc((int64_t)56,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(a);
    };
    mm_libpcl_genpc((int64_t)55,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(a);
}

static void mm_blockpcl_do_istruel(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_blockpcl_evalunit(a);
    if (!(!!(mm_libpcl_islogical(a)))) {
        mm_libpcl_genpc((int64_t)56,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_setpclcat_u(a);
}

static void mm_blockpcl_do_makelist(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t lower;
    struct mm_decls_unitrec *  a0;
    a0 = a;
    if (!!(a)) {
        mm_blockpcl_evalrest(a);
    };
    if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]) == (int64_t)23)) {
        mm_libpcl_genpc((int64_t)213,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        lower = (int64_t)1;
        if (!!((*p).b)) {
            if (((int64_t)((*(*p).b).tag) == (int64_t)1)) {
                lower = (*(*p).b).value;
            } else {
                mm_support_gerror((uint8_t*)"lwb not const",(struct mm_decls_unitrec *)(0));
            };
        };
        mm_libpcl_genpc((int64_t)212,mm_libpcl_genint((int64_t)((*p).length),(int64_t)8),mm_libpcl_genint(lower,(int64_t)8));
        mm_libpcl_setpclcat_t((int64_t)33);
        if ((!!((int64_t)((*p).makearray)) && !!(a0))) {
            (*mm_libpcl_pccodex).mode = (int64_t)((*a0).mode);
        };
    };
}

static void mm_blockpcl_evalrest(struct mm_decls_unitrec * a) {
    if (!!((*a).nextunit)) {
        mm_blockpcl_evalrest((*a).nextunit);
    };
    mm_blockpcl_evalunit(a);
}

static void mm_blockpcl_do_makerange(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
    mm_blockpcl_evalunit(b);
    mm_libpcl_genpc((int64_t)211,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_makeset(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    L667 :;
    while (!!(a)) {
        mm_blockpcl_evalunit(a);
        a = (*a).nextunit;
L668 :;
    }L669 :;
    ;
    mm_libpcl_genpc((int64_t)214,mm_libpcl_genint((int64_t)((*p).length),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_t((int64_t)33);
}

static void mm_blockpcl_do_makedict(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_makedict");
}

static void mm_blockpcl_do_exprlist(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_exprlist");
}

static void mm_blockpcl_do_multexpr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_multexpr");
}

static void mm_blockpcl_do_keyword(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_keyword");
}

static void mm_blockpcl_do_keyvalue(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_keyvalue");
}

static void mm_blockpcl_do_applyop(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_applyop");
}

static void mm_blockpcl_do_applyopx(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_applyopx");
}

static void mm_blockpcl_do_andand(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_andand");
}

static void mm_blockpcl_do_eq(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_eq");
}

static void mm_blockpcl_do_ne(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_ne");
}

static void mm_blockpcl_do_lt(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_lt");
}

static void mm_blockpcl_do_le(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_le");
}

static void mm_blockpcl_do_gt(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_gt");
}

static void mm_blockpcl_do_ge(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_ge");
}

static void mm_blockpcl_do_isequal(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_isequal");
}

static void mm_blockpcl_do_muldiv(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc) {
    int64_t n;
    if (!!((uint64_t)(mm_decls_ttisvar[((int64_t)((*a).mode))]))) {
        if (((opc == (int64_t)47) && !!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*b).mode))])))) {
            opc = (int64_t)51;
        };
    };
    if (((opc == (int64_t)47) && !!((uint64_t)(mm_decls_ttisreal[((int64_t)((*a).mode))])))) {
        mm_blockpcl_evalunit(a);
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclmode_u(p);
        return;
    };
    mm_blockpcl_evalunit(a);
    if ((((int64_t)((*b).tag) == (int64_t)1) && !!((n = mm_lib_ispoweroftwo((*b).value))))) {
        if ((opc == (int64_t)50)) {
            goto L670 ;
;
        } else {
            mm_libpcl_genpc(((opc == (int64_t)47)?(int64_t)88:(int64_t)89),mm_libpcl_genint(n,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        };
    } else {
        //isrem:
L670 :;
;
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_setpclmode_u(p);
}

static void mm_blockpcl_do_bin(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc) {
    mm_blockpcl_evalunit(a);
    mm_blockpcl_evalunit(b);
    mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    if ((opc==(int64_t)94) || (opc==(int64_t)95) || (opc==(int64_t)90)) {
        mm_libpcl_setpclmode_u(a);
    } else {
        mm_libpcl_setpclmode_u(p);
    };
    if ((opc == (int64_t)93)) {
        (*mm_libpcl_pccodex).mode2 = (int64_t)((*a).mode);
    };
}

static void mm_blockpcl_do_shl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc,int64_t opcc) {
    mm_blockpcl_evalunit(a);
    if (((int64_t)((*b).tag) == (int64_t)1)) {
        mm_libpcl_genpc(opcc,mm_libpcl_genint((*b).value,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_setpclmode_u(p);
}

static void mm_blockpcl_do_shlto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc,int64_t opcc) {
    if (((int64_t)((*b).tag) == (int64_t)1)) {
        if (((!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])) && ((int64_t)((*a).tag) == (int64_t)3)) && ((int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))]) == (int64_t)8))) {
            if ((opcc==(int64_t)165)) {
                opcc = (int64_t)180;
            }else if ((opcc==(int64_t)166)) {
                opcc = (int64_t)181;
            };
            mm_libpcl_genpc(opcc,mm_libpcl_genmem_u(a,(int64_t)0),mm_libpcl_genint((*b).value,(int64_t)8));
        } else {
            mm_blockpcl_evalref(a);
            mm_libpcl_genpc(opcc,mm_libpcl_genint((*b).value,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        };
    } else {
        mm_blockpcl_evalref(a);
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_setpclmode_u(a);
}

static void mm_blockpcl_do_setcc(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
    mm_blockpcl_evalunit(b);
    mm_libpcl_genpc((int64_t)79,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    (*mm_libpcl_pccodex).cond = (int64_t)((*p).tag);
    mm_libpcl_setpclmode_u(a);
}

static void mm_blockpcl_do_setccx(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    if ((!((((*p).tag == (int64_t)36) || ((*p).tag == (int64_t)37))) && !!((uint64_t)(mm_decls_ttisreal[((int64_t)((*a).mode))])))) {
        mm_blockpcl_evalunit(a);
        mm_blockpcl_evalunit(b);
    } else {
        mm_blockpcl_evalunit(a);
        mm_blockpcl_evalunit(b);
    };
    mm_libpcl_genpc((int64_t)79,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    (*mm_libpcl_pccodex).cond = (int64_t)((*p).tag);
    mm_libpcl_setpclmode_u(a);
}

static void mm_blockpcl_do_clamp(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_clamp");
}

static void mm_blockpcl_do_index(struct mm_decls_unitrec * p,int64_t doref) {
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    int64_t abase;
    a = (*p).a;
    b = (*p).b;
    abase = (int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
    if ((((abase == (int64_t)33) || (abase == (int64_t)23)) && !(!!(doref)))) {
        mm_blockpcl_evalunit(a);
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc((int64_t)100,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    } else if ((((int64_t)((*a).tag) == (int64_t)3) && !(!!(doref)))) {
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc((int64_t)102,mm_libpcl_genmem_u(a,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_evalref(a);
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc((!!(doref)?(int64_t)119:(int64_t)100),(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_setpclcat_u(p);
    (*mm_libpcl_pccodex).catmode2 = (uint64_t)((*mm_libpcl_pccodex).catmode);
    (*mm_libpcl_pccodex).mode2 = (int64_t)((*mm_libpcl_pccodex).mode);
    (*mm_libpcl_pccodex).catmode = (uint64_t)(abase);
    (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
}

static void mm_blockpcl_do_slice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t doref) {
    int64_t amode;
    amode = (int64_t)((*a).mode);
    if ((b == 0)) {
        mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((int64_t)(mm_decls_ttlower[((int64_t)((*a).mode))]),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((((int64_t)(mm_decls_ttlength[((int64_t)((*a).mode))]) + (int64_t)(mm_decls_ttlower[((int64_t)((*a).mode))])) - (int64_t)1),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_evalunit((*b).a);
        mm_blockpcl_evalunit((*b).b);
    };
    if ((((mm_decls_ttbasetype[((int64_t)((*a).mode))] == (int64_t)33) || (mm_decls_ttbasetype[((int64_t)((*a).mode))] == (int64_t)23) || (mm_decls_ttbasetype[((int64_t)((*a).mode))] == (int64_t)19)) && !(!!(doref)))) {
        mm_blockpcl_evalunit(a);
    } else {
        mm_blockpcl_evalref(a);
    };
    mm_libpcl_genpc((int64_t)126,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclmode_u(a);
    (*mm_libpcl_pccodex).catmode = (uint64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
    (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
}

static void mm_blockpcl_do_keyindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t doref) {
    if (!(!!(doref))) {
        mm_blockpcl_evalunit(a);
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc((int64_t)114,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_evalref(a);
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc((!!(doref)?(int64_t)122:(int64_t)114),(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_setpclcat_t((int64_t)33);
}

static void mm_blockpcl_do_makeslice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
    mm_blockpcl_evalunit(b);
    mm_libpcl_genpc((int64_t)213,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_dotindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
    mm_blockpcl_evalunit(b);
    mm_libpcl_genpc((int64_t)108,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    if (!!((uint64_t)(mm_decls_ttisvar[((int64_t)((*a).mode))]))) {
        mm_libpcl_setpclmode_t((int64_t)33);
    } else {
        mm_libpcl_setpclmode_t((int64_t)4);
    };
}

static void mm_blockpcl_do_dotslice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_unitrec *  x;
    struct mm_decls_unitrec *  y;
    mm_blockpcl_evalunit(a);
    if (((int64_t)((*b).tag) != (int64_t)20)) {
        mm_diags_printunit(b,(int64_t)0,(uint8_t*)"*",0);
        mm_support_gerror((uint8_t*)"dotslice not range",(struct mm_decls_unitrec *)(0));
    };
    x = (*b).a;
    y = (*b).b;
    mm_blockpcl_evalunit((*b).a);
    mm_blockpcl_evalunit((*b).b);
    mm_libpcl_genpc((int64_t)110,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_anddotindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t bitno;
    mm_blockpcl_evalunit(a);
    if (((int64_t)((*b).tag) == (int64_t)1)) {
        bitno = (*b).value;
        mm_libpcl_genpc((int64_t)83,mm_libpcl_genint(((int64_t)1 << bitno),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclmode_t((int64_t)4);
    } else {
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc((int64_t)109,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
}

static void mm_blockpcl_do_anddotslice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_anddotslice");
}

static void mm_blockpcl_do_dot(struct mm_decls_unitrec * p,int64_t doref) {
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  pname;
    int64_t offset;
    a = (*p).a;
    if (!!((int64_t)1)) {
        pname = (struct mm_decls_unitrec *)(0);
        offset = mm_blockpcl_checkdotchain(a,&pname);
        if ((offset != (int64_t)-1)) {
            offset += (int64_t)((*p).offset);
            a = pname;
        };
    } else {
        offset = (int64_t)((*p).offset);
    };
    mm_blockpcl_evalref(a);
    //dorest:
L671 :;
;
    mm_libpcl_genpc((!!(doref)?(int64_t)125:(int64_t)111),mm_libpcl_genint(offset,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(p);
    (*mm_libpcl_pccodex).catmode2 = (uint64_t)((*mm_libpcl_pccodex).catmode);
    (*mm_libpcl_pccodex).mode2 = (int64_t)((*mm_libpcl_pccodex).mode);
    (*mm_libpcl_pccodex).mode2 = (int64_t)((*p).mode);
    (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)25);
    (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
}

static int64_t mm_blockpcl_checkdotchain(struct mm_decls_unitrec * p,struct mm_decls_unitrec * * pname) {
    int64_t offset;
    if (((int64_t)((*p).tag)==(int64_t)95)) {
        offset = mm_blockpcl_checkdotchain((*p).a,pname);
        if ((offset == (int64_t)-1)) {
            return (int64_t)-1;
        } else {
            return ((int64_t)((*p).offset) + offset);
        };
    } else {
        (*pname) = p;
        return (int64_t)0;
    };
    return (int64_t)0;
}

static void mm_blockpcl_do_dotattr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_dotattr");
}

static void mm_blockpcl_do_atan2(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
    mm_blockpcl_evalunit(b);
    mm_libpcl_genpc((int64_t)141,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(p);
}

static void mm_blockpcl_do_power(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*a).mode))]))) {
        mm_blockpcl_evalunit(b);
        mm_blockpcl_evalunit(a);
    } else {
        mm_blockpcl_evalunit(a);
        mm_blockpcl_evalunit(b);
    };
    mm_libpcl_genpc((int64_t)151,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclmode_u(a);
}

static void mm_blockpcl_do_ptr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    if (((((*a).tag == (int64_t)43) || ((*a).tag == (int64_t)44)) && ((int64_t)((*(*a).b).tag) == (int64_t)1))) {
        mm_blockpcl_evalunit((*a).a);
        mm_libpcl_genpc((int64_t)17,mm_libpcl_genint((((int64_t)((*a).tag) == (int64_t)43)?(*(*a).b).value:-((*(*a).b).value)),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_evalunit(a);
        mm_libpcl_genpc((int64_t)17,mm_libpcl_genint((int64_t)0,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_setpclcat_u(p);
}

static void mm_blockpcl_do_addrof(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_blockpcl_evalref(a);
}

static void mm_blockpcl_do_convert(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t opc;
    if (!!((int64_t)((*p).popflag))) {
        mm_blockpcl_evalunit(a);
        return;
    };
    if (((int64_t)((*p).tag)==(int64_t)19) || ((int64_t)((*p).tag)==(int64_t)21)) {
    } else {
        if (((int64_t)((*p).opcode)==(int64_t)28)) {
            mm_support_gerror((uint8_t*)"ichar to string",(struct mm_decls_unitrec *)(0));
            return;
        };
        if ((((((*p).opcode == (int64_t)5) || ((*p).opcode == (int64_t)4)) && (((*a).tag == (int64_t)88) || ((*a).tag == (int64_t)95) || ((*a).tag == (int64_t)99))) && ((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) == (int64_t)8))) {
            mm_blockpcl_evalunit(a);
            return;
        };
        switch ((int64_t)((*p).opcode)) {
        case 5:;
        {
            opc = (int64_t)196;
        }break;
        case 4:;
        {
            opc = (int64_t)195;
        }break;
        case 7:;
        {
            opc = (int64_t)198;
        }break;
        case 6:;
        {
            opc = (int64_t)197;
        }break;
        case 9:;
        {
            opc = (int64_t)200;
        }break;
        case 8:;
        {
            opc = (int64_t)199;
        }break;
        case 19:;
        {
            opc = (int64_t)202;
        }break;
        case 20:;
        {
            opc = (int64_t)203;
        }break;
        case 21:;
        {
            opc = (int64_t)204;
        }break;
        case 22:;
        {
            opc = (int64_t)205;
        }break;
        case 29:;
        {
            opc = (int64_t)206;
        }break;
        case 26:;
        {
            if ((((int64_t)((*a).tag) == (int64_t)1) && (((*a).mode == (int64_t)4) || ((*a).mode == (int64_t)15)))) {
                mm_libpcl_genpc((int64_t)28,mm_libpcl_genint((*a).value,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
                return;
            } else if ((((int64_t)((*a).tag) == (int64_t)1) && ((int64_t)((*a).mode) == (int64_t)12))) {
                mm_libpcl_genpc((int64_t)29,mm_libpcl_genreal((*a).xvalue,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
                return;
            } else if (((((int64_t)((*a).tag) == (int64_t)1) && ((int64_t)((*a).mode) == mm_tables_trefchar)) && !!((int64_t)((*a).isastring)))) {
                mm_libpcl_genpc((int64_t)30,mm_libpcl_genstrimm((*a).svalue,(int64_t)((*a).length)),(struct mm_libpcl_pclopndrec *)(0));
                return;
            } else if ((((int64_t)((*a).tag) == (int64_t)20) && ((int64_t)((*a).mode) == (int64_t)22))) {
                mm_blockpcl_evalunit((*a).a);
                mm_blockpcl_evalunit((*a).b);
                mm_libpcl_genpc((int64_t)211,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
                return;
            } else {
                mm_blockpcl_evalunit(a);
                mm_libpcl_genpc((int64_t)207,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
                (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
                (*mm_libpcl_pccodex).mode2 = (int64_t)33;
                return;
            };
        }break;
        case 1:;
        {
            mm_blockpcl_evalunit(a);
            return;
        }break;
        case 0:;
        {
            mm_support_gerror((uint8_t*)"BLOCKPCL/C_NONE",(struct mm_decls_unitrec *)(0));
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_tables_convnames[((int64_t)((*p).opcode))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_gerror((uint8_t*)"No PCL convert op",(struct mm_decls_unitrec *)(0));
        }
        } //SW
;
        mm_blockpcl_evalunit(a);
        mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
        (*mm_libpcl_pccodex).mode2 = (int64_t)((*p).mode);
        return;
    };
    mm_blockpcl_unimpl((uint8_t*)"CONVERT/MAKELIST/CONSTR");
}

static void mm_blockpcl_do_convertref(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_convertref");
}

static void mm_blockpcl_do_autocast(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_autocast");
}

static void mm_blockpcl_do_typepun(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
    mm_libpcl_genpc((int64_t)208,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
    (*mm_libpcl_pccodex).mode2 = (int64_t)((*p).mode);
}

static void mm_blockpcl_do_typeconst(struct mm_decls_unitrec * p) {
    mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((*p).value,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_operator(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_operator");
}

static void mm_blockpcl_do_upper(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_upper");
}

static void mm_blockpcl_do_unary(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t opc) {
    mm_blockpcl_evalunit(a);
    mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    if ((opc==(int64_t)129) || (opc==(int64_t)128) || (opc==(int64_t)127) || (opc==(int64_t)131) || (opc==(int64_t)130) || (opc==(int64_t)152)) {
        mm_libpcl_setpclmode_u(a);
        return;
    };
    mm_libpcl_setpclmode_u(p);
}

static void mm_blockpcl_do_maths(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t sysfn,int64_t pclopc) {
    mm_blockpcl_evalunit(a);
    if (!!((uint64_t)(mm_decls_ttisvar[((int64_t)((*a).mode))]))) {
        mm_libpcl_genpc(pclopc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_t((int64_t)33);
    } else {
        mm_libpcl_do_syscallproc(sysfn,(int64_t)1,(int64_t)0);
        mm_libpcl_genpc((int64_t)20,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(p);
        if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
            mm_libpcl_makefloatopnds();
        };
        (*mm_libpcl_pccodex).mode = (int64_t)((*p).mode);
    };
}

static void mm_blockpcl_do_sqr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
    mm_libpcl_genpc((int64_t)133,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclmode_u(a);
}

static void mm_blockpcl_do_sign(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_evalunit(a);
    mm_libpcl_genpc((int64_t)134,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclmode_u(a);
}

static void mm_blockpcl_do_fmod(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_fmod");
}

static void mm_blockpcl_do_bitwidth(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_blockpcl_unimpl((uint8_t*)"do_bitwidth");
}

static void mm_blockpcl_do_bytesize(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_blockpcl_unimpl((uint8_t*)"do_bytesize");
}

static void mm_blockpcl_do_typeof(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_typeof");
}

static void mm_blockpcl_do_typestr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_typestr");
}

static void mm_blockpcl_do_sliceptr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_blockpcl_evalunit(a);
    mm_libpcl_genpc((int64_t)217,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_minvalue(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_minvalue");
}

static void mm_blockpcl_do_maxvalue(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_blockpcl_unimpl((uint8_t*)"do_maxvalue");
}

static void mm_blockpcl_do_incr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    if (((int64_t)((*a).tag) == (int64_t)3)) {
        mm_libpcl_genpc((((int64_t)((*p).tag) == (int64_t)149)?(int64_t)186:(int64_t)187),mm_libpcl_genmem_u(a,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_evalref(a);
        mm_libpcl_genpc((((int64_t)((*p).tag) == (int64_t)149)?(int64_t)188:(int64_t)189),(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]) == (int64_t)19)) {
        mm_libpcl_setpclmode_u(a);
    } else {
        mm_libpcl_setpclcat_u(a);
    };
}

static void mm_blockpcl_do_incrx(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t opc) {
    mm_blockpcl_evalref(a);
    mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]) == (int64_t)19)) {
        mm_libpcl_setpclmode_u(a);
    } else {
        mm_libpcl_setpclcat_u(a);
    };
}

static void mm_blockpcl_do_binto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t opc) {
    if ((((((opc == (int64_t)154) || (opc == (int64_t)155) || (opc == (int64_t)160) || (opc == (int64_t)161) || (opc == (int64_t)162)) && !!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))]))) && ((int64_t)((*a).tag) == (int64_t)3)) && ((int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))]) == (int64_t)8))) {
        mm_blockpcl_evalunit(b);
        if ((opc==(int64_t)154)) {
            opc = (int64_t)175;
        }else if ((opc==(int64_t)155)) {
            opc = (int64_t)176;
        }else if ((opc==(int64_t)160)) {
            opc = (int64_t)177;
        }else if ((opc==(int64_t)161)) {
            opc = (int64_t)178;
        }else if ((opc==(int64_t)162)) {
            opc = (int64_t)179;
        };
        mm_libpcl_genpc(opc,mm_libpcl_genmem_u(a,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_evalref(a);
        mm_blockpcl_evalunit(b);
        mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    };
    mm_libpcl_setpclmode_u(a);
}

static void mm_blockpcl_do_unaryto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t opc) {
    mm_blockpcl_evalref(a);
    mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclmode_u(a);
}

static void mm_blockpcl_do_cvlineno(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_libpcl_genpc((int64_t)22,mm_libpcl_genint(((int64_t)((*p).lineno) & (int64_t)16777215),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_cvmodulename(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_libpcl_genpc((int64_t)25,mm_libpcl_genstrimm(mm_decls_moduletable[((int64_t)((*p).moduleno))].name,(int64_t)-1),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_cvfilename(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_libpcl_genpc((int64_t)25,mm_libpcl_genstrimm(mm_decls_sourcefilenames[(((int64_t)((*p).lineno) >> (int64_t)24))],(int64_t)-1),(struct mm_libpcl_pclopndrec *)(0));
}

static void mm_blockpcl_do_assignblock(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    if (((int64_t)((*b).tag) == (int64_t)19)) {
        if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]) == (int64_t)24)) {
            mm_blockpcl_do_assignarray(a,b);
        } else {
            mm_blockpcl_do_assignrecord(a,b);
        };
    } else {
        mm_blockpcl_evalref(a);
        mm_blockpcl_evalref(b);
        mm_libpcl_genpc((int64_t)40,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
    };
}

static void mm_blockpcl_do_callff(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_strec * d,int64_t fncall) {
    int64_t nparams;
    int64_t retmode;
    int64_t i;
    int64_t floatmap;
    int64_t mask;
    struct mm_decls_unitrec *  params[100];
    byte widenfloat[100];
    retmode = (int64_t)((*p).mode);
    nparams = (int64_t)0;
    floatmap = (int64_t)0;
    mask = (int64_t)1;
    L672 :;
    while (!!(b)) {
        params[(++nparams)-1] = b;
        widenfloat[(nparams)-1] = (uint64_t)((int64_t)0);
        if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*b).mode))]))) {
            floatmap |= mask;
            if ((((int64_t)(mm_decls_ttsize[((int64_t)((*b).mode))]) == (int64_t)4) && !!((uint64_t)((*d).varparams)))) {
                widenfloat[(nparams)-1] = (uint64_t)((int64_t)1);
            };
        };
        mask <<= (int64_t)1;
        b = (*b).nextunit;
L673 :;
    }L674 :;
    ;
    L675 :;
    for (i=nparams;i>=(int64_t)1;i-=(int64_t)1) {
L676 :;
        mm_blockpcl_evalunit(params[(i)-1]);
        if (!!((uint64_t)(widenfloat[(i)-1]))) {
            mm_libpcl_genpc((int64_t)205,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
            (*mm_libpcl_pccodex).mode2 = (int64_t)12;
            (*mm_libpcl_pccodex).mode = (int64_t)11;
        };
L677 :;
    }L678 :;
    ;
    mm_libpcl_genpc((int64_t)21,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    if (((int64_t)((*a).tag)==(int64_t)3)) {
        mm_libpcl_genpc((int64_t)60,mm_libpcl_genint(floatmap,(int64_t)8),mm_libpcl_genmemaddr_u(a));
    } else {
        mm_blockpcl_evalunit((*a).a);
        mm_libpcl_genpc((int64_t)61,mm_libpcl_genint(floatmap,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    };
    (*mm_libpcl_pccodex).a.nargs = nparams;
    (*mm_libpcl_pccodex).isfunction = (uint64_t)(fncall);
    (*mm_libpcl_pccodex).isvariadic = (uint64_t)((*d).varparams);
    if (!!(fncall)) {
        mm_libpcl_genpc((int64_t)19,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_u(p);
        if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
            mm_libpcl_makefloatopnds();
        };
        (*mm_libpcl_pccodex).mode = (int64_t)((*p).mode);
    };
}

static void mm_blockpcl_do_recase(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  wt;
    struct mm_decls_unitrec *  w;
    int64_t destlab;
    if ((mm_blockpcl_casedepth == (int64_t)0)) {
        mm_support_gerror((uint8_t*)"recase outside case stmt",(struct mm_decls_unitrec *)(0));
    };
    q = mm_blockpcl_casestmt[(mm_blockpcl_casedepth)-1];
    destlab = (int64_t)0;
    wt = (*q).b;
    L679 :;
    while (!!(wt)) {
        w = (*wt).a;
        L682 :;
        while (!!(w)) {
            if (((((int64_t)((*w).tag) == (int64_t)1) && !!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*w).mode))]))) && ((*w).value == (*a).value))) {
                destlab = (int64_t)((*w).whenlabel);
                goto L681 ;
            };
            w = (*w).nextunit;
L683 :;
        }L684 :;
        ;
        wt = (*wt).nextunit;
L680 :;
    }L681 :;
    ;
    if ((destlab == (int64_t)0)) {
        mm_blockpcl_genjumpl(mm_blockpcl_caseelse[(mm_blockpcl_casedepth)-1]);
    } else {
        mm_blockpcl_genjumpl(destlab);
    };
}

static void mm_blockpcl_do_assem(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_libpcl_genpc((int64_t)218,mm_libpcl_genassem_u(p),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(p);
}

static void mm_blockpcl_pushrhs(struct mm_decls_unitrec * a) {
    if ((a == 0)) {
        return;
    };
    mm_blockpcl_pushrhs((*a).nextunit);
    mm_blockpcl_evalunit(a);
}

static void mm_blockpcl_do_multassign(struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t nlhs;
    int64_t nrhs;
    struct mm_decls_strec *  d;
    int64_t i;
    nlhs = (int64_t)((*a).length);
    if (((int64_t)((*b).tag) == (int64_t)31)) {
        mm_blockpcl_evalunit(b);
        if (((int64_t)((*(*b).a).tag) != (int64_t)3)) {
            mm_support_gerror((uint8_t*)"multassign from fn: not simple fn",(struct mm_decls_unitrec *)(0));
        };
        d = (*(*b).a).def;
        nrhs = (int64_t)((*d).nretvalues);
    } else {
        nrhs = (int64_t)((*b).length);
        mm_blockpcl_pushrhs((*b).a);
    };
    a = (*a).a;
    L685 :;
    do {
        switch ((int64_t)((*a).tag)) {
        case 3:;
        {
            mm_libpcl_genpc((int64_t)32,mm_libpcl_genmem_u(a,(int64_t)0),(struct mm_libpcl_pclopndrec *)(0));
        }break;
        case 88:;
        case 89:;
        case 95:;
        {
            mm_blockpcl_evalref(a);
            mm_libpcl_genpc((int64_t)34,mm_libpcl_genint((int64_t)0,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        }break;
        case 99:;
        {
            mm_blockpcl_evalunit((*a).a);
            mm_libpcl_genpc((int64_t)34,mm_libpcl_genint((int64_t)0,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        }break;
        case 209:;
        case 210:;
        case 224:;
        case 226:;
        case 229:;
        {
            mm_blockpcl_evalref(a);
            mm_libpcl_genpc((int64_t)34,mm_libpcl_genint((int64_t)0,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        }break;
        case 90:;
        {
            mm_blockpcl_evalref((*a).a);
            mm_blockpcl_evalunit((*a).b);
            mm_libpcl_genpc((int64_t)123,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*a).tag))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_gerror((uint8_t*)"Bad mult assign element",(struct mm_decls_unitrec *)(0));
        }
        } //SW
;
        mm_libpcl_setpclcat_u(a);
        a = (*a).nextunit;
L686 :;
    } while (!(a == 0));L687 :;
    ;
    L688 :;
    for (i=(nlhs + (int64_t)1);i<=nrhs;i+=(int64_t)1) {
L689 :;
        mm_libpcl_genpc((int64_t)44,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_setpclcat_t((int64_t)((*d).modelist[(i)-1]));
        if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*d).modelist[(i)-1]))]))) {
            mm_libpcl_makefloatopnds();
        };
L690 :;
    }L691 :;
    ;
}

static int64_t mm_blockpcl_isshortconst(struct mm_decls_unitrec * p) {
    if ((((((int64_t)((*p).tag) == (int64_t)1) && !!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*p).mode))]))) && ((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) <= (int64_t)8)) && ((*p).value>=(int64_t)-2147483648 && (*p).value<=(int64_t)2147483647))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

static int64_t mm_blockpcl_isshortmem(struct mm_decls_unitrec * p) {
    if ((((((int64_t)((*p).tag) == (int64_t)3) && !!((uint64_t)(mm_decls_ttisnumeric[((int64_t)((*p).mode))]))) && ((int64_t)(mm_decls_ttsize[((int64_t)((*(*p).def).mode))]) == (int64_t)8)) && (((*(*p).def).nameid == (int64_t)10) || ((*(*p).def).nameid == (int64_t)11) || ((*(*p).def).nameid == (int64_t)9)))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

static void mm_blockpcl_do_popindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t opc) {
    int64_t abase;
    mm_blockpcl_evalunit(c);
    abase = (int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
    if (((abase == (int64_t)23))) {
        mm_blockpcl_evalunit(a);
    } else {
        mm_blockpcl_evalref(a);
    };
    mm_blockpcl_evalunit(b);
    mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(p);
    (*mm_libpcl_pccodex).catmode2 = (uint64_t)((*mm_libpcl_pccodex).catmode);
    (*mm_libpcl_pccodex).mode2 = (int64_t)((*mm_libpcl_pccodex).mode);
    (*mm_libpcl_pccodex).catmode = (uint64_t)(abase);
    (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
}

static void mm_blockpcl_do_popslice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t opc) {
    int64_t abase;
    mm_blockpcl_evalunit(c);
    if ((b == 0)) {
        mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((int64_t)(mm_decls_ttlower[((int64_t)((*a).mode))]),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
        mm_libpcl_genpc((int64_t)22,mm_libpcl_genint((((int64_t)(mm_decls_ttlength[((int64_t)((*a).mode))]) + (int64_t)(mm_decls_ttlower[((int64_t)((*a).mode))])) - (int64_t)1),(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    } else {
        mm_blockpcl_evalunit((*b).a);
        mm_blockpcl_evalunit((*b).b);
    };
    abase = (int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
    if (((abase == (int64_t)33) || (abase == (int64_t)23))) {
        mm_blockpcl_evalunit(a);
    } else {
        mm_blockpcl_evalref(a);
    };
    mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(p);
    (*mm_libpcl_pccodex).catmode2 = (uint64_t)((*mm_libpcl_pccodex).catmode);
    (*mm_libpcl_pccodex).mode2 = (int64_t)((*mm_libpcl_pccodex).mode);
    (*mm_libpcl_pccodex).catmode = (uint64_t)(abase);
    (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
}

static void mm_blockpcl_do_popkeyindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t opc) {
    mm_blockpcl_evalunit(c);
    mm_blockpcl_evalunit(a);
    mm_blockpcl_evalunit(b);
    mm_libpcl_genpc(opc,(struct mm_libpcl_pclopndrec *)(0),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(p);
    mm_libpcl_setpclcat_t((int64_t)33);
}

static void mm_blockpcl_do_popdot(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * c,int64_t offset,int64_t opc) {
    struct mm_decls_unitrec *  pname;
    int64_t newoffset;
    mm_blockpcl_evalunit(c);
    if (!!((int64_t)1)) {
        pname = (struct mm_decls_unitrec *)(0);
        newoffset = mm_blockpcl_checkdotchain(a,&pname);
        if ((newoffset != (int64_t)-1)) {
            offset += newoffset;
            a = pname;
        };
    } else {
    };
    mm_blockpcl_evalref(a);
    //dorest:
L692 :;
;
    mm_libpcl_genpc(opc,mm_libpcl_genint(offset,(int64_t)8),(struct mm_libpcl_pclopndrec *)(0));
    mm_libpcl_setpclcat_u(p);
    (*mm_libpcl_pccodex).catmode2 = (uint64_t)((*mm_libpcl_pccodex).catmode);
    (*mm_libpcl_pccodex).mode2 = (int64_t)((*mm_libpcl_pccodex).mode);
    (*mm_libpcl_pccodex).catmode = (uint64_t)((int64_t)25);
    (*mm_libpcl_pccodex).mode = (int64_t)((*a).mode);
}

static void mm_blockpcl_do_assignarray(struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_unitrec *  passign;
    struct mm_decls_unitrec *  pindex;
    struct mm_decls_unitrec *  pconst;
    struct mm_decls_unitrec *  q;
    int64_t index;
    if (((int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))]) == (int64_t)13)) {
        mm_support_gerror((uint8_t*)"Assignment not suitable for []char type",(struct mm_decls_unitrec *)(0));
    };
    pconst = mm_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)4);
    pindex = mm_lib_createunit2((int64_t)88,a,pconst);
    passign = mm_lib_createunit2((int64_t)205,pindex,(*b).a);
    (*passign).mode = (int64_t)(((*pindex).mode = (int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))])));
    index = (int64_t)(mm_decls_ttlower[((int64_t)((*a).mode))]);
    q = (*b).a;
    L693 :;
    while (!!(q)) {
        (*pconst).value = index;
        (*passign).b = q;
        mm_blockpcl_evalunit(passign);
        ++index;
        q = (*q).nextunit;
L694 :;
    }L695 :;
    ;
}

static void mm_blockpcl_do_assignrecord(struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_unitrec *  passign;
    struct mm_decls_unitrec *  pdot;
    struct mm_decls_unitrec *  pfield;
    struct mm_decls_unitrec *  q;
    int64_t m;
    int64_t fieldtype;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    pfield = mm_lib_createunit0((int64_t)3);
    pdot = mm_lib_createunit2((int64_t)95,a,pfield);
    passign = mm_lib_createunit2((int64_t)205,pdot,(*b).a);
    (*passign).mode = (int64_t)(((*pdot).mode = (int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))])));
    m = (int64_t)((*a).mode);
    d = mm_decls_ttnamedef[(m)];
    e = (*d).deflist;
    q = (*b).a;
    L696 :;
    while (!!(e)) {
        if ((((int64_t)((uint64_t)((*e).nameid)) == (int64_t)12) && ((int64_t)((*e).mode) != (int64_t)21))) {
            fieldtype = (int64_t)((*e).mode);
            (*pfield).def = e;
            (*passign).mode = (int64_t)(((*pfield).mode = (int64_t)(((*pdot).mode = fieldtype))));
            (*passign).b = q;
            (*pdot).offset = (int64_t)((*e).offset);
            mm_blockpcl_evalunit(passign);
            q = (*q).nextunit;
        };
        e = (*e).nextdef;
L697 :;
    }L698 :;
    ;
}

void mm_genmcl_codegen_mcl(void) {
    struct mm_libpcl_pclrec *  p;
    mm_genmcl_inithandlers();
    mm_libmcl_mclinit();
    p = mm_libpcl_allpclcode;
    mm_libmcl_gencomment_mc((uint8_t*)"Starting PCL->MCL:");
    L699 :;
    while (!!(p)) {
        mm_genmcl_convertpcl(p);
        p = (*p).nextpcl;
L700 :;
    }L701 :;
    ;
    mm_libmcl_gencomment_mc((uint8_t*)"Finished PCL->MCL:");
    if (!!(mm_libmcl_noperands)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"OPERAND STACK -",NULL);
        msysnewc_m_print_i64(mm_libmcl_noperands,NULL);
        msysnewc_m_print_str((uint8_t*)"LEFT ON STACK",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    mm_genmcl_genabsneg();
    mm_genmcl_genstringtable();
    mm_genmcl_genrealtable();
    mm_genmcl_genfunctiondata();
    mm_genmcl_gensysfntable();
    mm_libmcl_allmclcode = mm_libmcl_mccode;
}

static void mm_genmcl_convertpcl(struct mm_libpcl_pclrec * p) {
    uint8_t str[1256];
    uint8_t *  ss;
    if ((!!((int64_t)0) && !!((uint64_t)(mm_decls_fdebugcompiler)))) {
        ss = mm_libpcl_strpcl(p);
        if (((int64_t)(strlen((int8_t *)(ss))) < (int64_t)1256)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"- - - - - - - - - - - -",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(ss,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"- - - - - - - - - - - -TOO LONG:",NULL);
            msysnewc_m_print_str(mm_libpcl_pclnames[((int64_t)((*p).opcode))-1],NULL);
            msysnewc_m_print_end();
            ;
        };
        mm_libmcl_gencomment_mc(str);
    };
    mm_genmcl_currpclrec = p;
    mm_decls_mlineno = (int64_t)((*p).lineno);
    mm_genmcl_aa = &(*p).a;
    mm_genmcl_bb = &(*p).b;
    ((*mm_genmcl_handlertable[((int64_t)((*p).opcode))-1][((int64_t)((*p).catmode))]))(p);
    if (((int64_t)((*p).opcode)==(int64_t)1) || ((int64_t)((*p).opcode)==(int64_t)2) || ((int64_t)((*p).opcode)==(int64_t)3) || ((int64_t)((*p).opcode)==(int64_t)4)) {
    } else {
        if ((!!((int64_t)0) && !!((uint64_t)(mm_decls_fdebugcompiler)))) {
            mm_genmcl_showopndstack();
        };
    };
}

static void mm_genmcl_inithandlers(void) {
    uint8_t *  name;
    int64_t n;
    int64_t av_1;
    int64_t i;
    int64_t t;
    n = msysnewc_m_get_nprocs();
    L702 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L703 :;
        name = msysnewc_m_get_procname(i);
        if (!!(mlib_eqbytes((void *)(name),(void *)((uint8_t*)"pc_"),(int64_t)3))) {
            mm_genmcl_dohandler(name,(void (*)(void))(msysnewc_m_get_procaddr(i)));
        };
L704 :;
    }L705 :;
    ;
    L706 :;
    for (i=(int64_t)1;i<=(int64_t)230;i+=(int64_t)1) {
L707 :;
        L710 :;
        for (t=(int64_t)0;t<=(int64_t)33;t+=(int64_t)1) {
L711 :;
            if (!(!!(mm_genmcl_handlertable[(i)-1][(t)]))) {
                mm_genmcl_handlertable[(i)-1][(t)] = (void (*)(struct mm_libpcl_pclrec *))(&mm_genmcl_pc_dummy);
            };
L712 :;
        }L713 :;
        ;
L708 :;
    }L709 :;
    ;
}

static void mm_genmcl_unimpl(uint8_t * mess) {
    uint8_t str[256];
    strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"Unimpl: "));
    strcat((int8_t *)(str),(int8_t *)(mess));
    mm_libmcl_gencomment_mc(str);
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void mm_genmcl_pc_dummy(struct mm_libpcl_pclrec * p) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"#_#");
    msysnewc_m_print_str(mm_libpcl_pclnames[((int64_t)((*p).opcode))-1],NULL);
    msysnewc_m_print_str(mm_tables_stdtypenames[((int64_t)((*p).catmode))],NULL);
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"UNIMPL:",NULL);
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_i64(((int64_t)((*p).lineno) & (int64_t)16777215),NULL);
    msysnewc_m_print_str(mm_decls_sourcefilenames[(((int64_t)((*p).lineno) >> (int64_t)24))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_genmcl_unimpl(str);
}

static void mm_genmcl_pc_comment(struct mm_libpcl_pclrec * p) {
    mm_libmcl_gencomment_mc((*p).a.svalue);
}

static void mm_genmcl_pc_blank(struct mm_libpcl_pclrec * p) {
    mm_libmcl_gencomment_mc((uint8_t *)(0));
}

static void mm_genmcl_pc_label(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_labelname(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genstrimm_mc((*mm_genmcl_aa).svalue,(int64_t)-1),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_startmult(struct mm_libpcl_pclrec * p) {
    mm_libmcl_pushalloperands();
}

static void mm_genmcl_pc_resetmult(struct mm_libpcl_pclrec * p) {
    int64_t reg;
    if (((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) == (uint64_t)73u)) {
        reg = (int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
        if ((reg == (int64_t)0)) {
            mm_support_gerror((uint8_t*)"RESETMULT/I/TOS?",(struct mm_decls_unitrec *)(0));
        };
        if (((mm_libmcl_noperands > (int64_t)1) && ((int64_t)((uint64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1])) != (int64_t)0))) {
            mm_support_gerror((uint8_t*)"RESETMULT/I/STACK ERROR",(struct mm_decls_unitrec *)(0));
        };
        if ((reg != (int64_t)1)) {
            mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genreg(reg,(int64_t)8));
            mm_libmcl_freereg(reg);
            mm_libmcl_regset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
            mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)1);
        };
    } else {
        mm_libmcl_pushalloperands();
    };
    if (((int64_t)((*p).opcode) == (int64_t)9)) {
        --mm_libmcl_noperands;
        if (!!((uint64_t)(mm_libmcl_regset[((int64_t)1)-1]))) {
            mm_libmcl_freereg((int64_t)1);
        };
    };
}

static void mm_genmcl_pc_endmult(struct mm_libpcl_pclrec * p) {
    mm_genmcl_pc_resetmult(p);
}

static void mm_genmcl_pc_stackall(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_stackall");
}

static void mm_genmcl_pc_procentry(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    int64_t iscallback;
    int64_t nparams;
    int64_t np;
    int64_t offset;
    int64_t reg;
    int64_t i;
    mm_libpcl_framebytes = (int64_t)((*mm_genmcl_bb).fbytes);
    mm_libpcl_parambytes = (*mm_genmcl_bb).pbytes;
    if (((int64_t)((*mm_genmcl_aa).optype) == (int64_t)6)) {
        mm_libmcl_genmc((int64_t)3,mm_libmcl_genstrimm_mc((*mm_genmcl_aa).svalue,(int64_t)-1),(struct mm_mcldecls_opndrec *)(0));
        return;
    };
    mm_decls_currproc = (*mm_genmcl_aa).def;
    iscallback = mm_lib_iscallbackfn(mm_decls_currproc);
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genmemaddr_d_mc(mm_decls_currproc),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(++mm_decls_labelno),(struct mm_mcldecls_opndrec *)(0));
    (*mm_decls_currproc).index = mm_decls_labelno;
    if (!!((uint64_t)((*p).isglobal))) {
        (*mm_libmcl_mccodex).isglobal = (uint64_t)((*p).isglobal);
    };
    if ((!!(mm_libpcl_framebytes) || !!(mm_libpcl_parambytes))) {
        mm_libmcl_genmc((int64_t)9,mm_libmcl_dframeopnd,(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_genmc((int64_t)8,mm_libmcl_dframeopnd,mm_libmcl_dstackopnd);
        if (!!(mm_libpcl_framebytes)) {
            mm_libmcl_pushstack_mc(mm_libpcl_framebytes);
        };
    };
    if (!!(iscallback)) {
        nparams = (mm_libpcl_parambytes / (int64_t)8);
        np = ((int64_t)4<nparams?(int64_t)4:nparams);
        offset = (int64_t)16;
        reg = (int64_t)11;
        L714 :;
        for (i=(int64_t)1;i<=np;i+=(int64_t)1) {
L715 :;
            ax = mm_libmcl_genindex((int64_t)15,(int64_t)0,(int64_t)1,offset,(int64_t)8,(int64_t)0,(struct mm_decls_strec *)(0));
            mm_libmcl_genmc((int64_t)8,ax,mm_libmcl_genreg(reg,(int64_t)8));
            offset += (int64_t)8;
            ++reg;
L716 :;
        }L717 :;
        ;
        mm_libmcl_genmc_sys((int64_t)1);
    };
}

static void mm_genmcl_pc_procexit(struct mm_libpcl_pclrec * p) {
    int64_t iscallback;
    iscallback = mm_lib_iscallbackfn(mm_decls_currproc);
    if ((!!(mm_libpcl_framebytes) || !!(mm_libpcl_parambytes))) {
        if (!!(mm_libpcl_framebytes)) {
            mm_libmcl_popstack_mc(mm_libpcl_framebytes);
        };
        mm_libmcl_genmc((int64_t)10,mm_libmcl_dframeopnd,(struct mm_mcldecls_opndrec *)(0));
        if (!!(iscallback)) {
            mm_libmcl_genmc_sys((int64_t)2);
        };
        if ((!!(mm_libpcl_parambytes) && !(!!(iscallback)))) {
            mm_libmcl_genmc((int64_t)20,mm_libmcl_genint_mc(mm_libpcl_parambytes,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
        } else {
            mm_libmcl_genmc((int64_t)19,(struct mm_mcldecls_opndrec *)(0),(struct mm_mcldecls_opndrec *)(0));
        };
    } else {
        if (!!(iscallback)) {
            mm_libmcl_genmc_sys((int64_t)2);
        };
        mm_libmcl_genmc((int64_t)19,(struct mm_mcldecls_opndrec *)(0),(struct mm_mcldecls_opndrec *)(0));
    };
}

static void mm_genmcl_pc_zstatic(struct mm_libpcl_pclrec * p) {
    int64_t m;
    struct mm_decls_strec *  d;
    d = (*p).a.def;
    m = (int64_t)((*d).mode);
    mm_libmcl_setsegment((int64_t)90,(int64_t)((*p).align));
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genmemaddr_d_mc(d),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)119,mm_libmcl_genint_mc((int64_t)(mm_decls_ttsize[(m)]),(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_istatic(struct mm_libpcl_pclrec * p) {
    mm_libmcl_setsegment((int64_t)73,(int64_t)((*p).align));
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genmemaddr_d_mc((*p).a.def),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_equiv(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    ax = mm_libmcl_genmemaddr_d_mc((*p).a.def);
    if (((int64_t)((*mm_genmcl_bb).optype)==(int64_t)3)) {
        mm_libmcl_genmc((int64_t)4,ax,mm_libmcl_genint_mc((*mm_genmcl_bb).value,(int64_t)8));
    }else if (((int64_t)((*mm_genmcl_bb).optype)==(int64_t)1)) {
        mm_libmcl_genmc((int64_t)4,ax,mm_libmcl_genmemaddr_d_mc((*p).b.def));
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_libpcl_opndnames[((int64_t)((*mm_genmcl_bb).optype))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"PC_EQUIV",(struct mm_decls_unitrec *)(0));
        mm_libmcl_genmc((int64_t)4,ax,mm_libmcl_genint_mc((*mm_genmcl_bb).value,(int64_t)8));
    };
}

static void mm_genmcl_pc_initmemz_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmemaddr((*mm_genmcl_aa).def);
    mm_libmcl_pushalloperands();
    mm_libmcl_genmc_sys((int64_t)71);
    mm_libmcl_poparg();
}

static void mm_genmcl_pc_pushmem_d8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmem_d8((*mm_genmcl_aa).def);
}

static void mm_genmcl_pc_dpushmem_d8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_pushalloperands();
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc((int64_t)9,mm_libmcl_genmem_d_mc((*mm_genmcl_aa).def,(int64_t)0),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_freereg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]));
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)0);
}

static void mm_genmcl_pc_pushmem_x8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_x8();
    mm_libmcl_genmc_loadmem_x8((*mm_genmcl_aa).def);
}

static void mm_genmcl_pc_pushmem_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmem_d124((*mm_genmcl_aa).def,(int64_t)((*p).mode));
}

static void mm_genmcl_pc_pushmem_d16(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d16();
    mm_libmcl_genmc_loadmem_d16((*mm_genmcl_aa).def);
}

static void mm_genmcl_pc_pushmem_x4(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_x8();
    mm_libmcl_genmc_loadmem_x4((*mm_genmcl_aa).def);
}

static void mm_genmcl_pc_pushmem_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmem_d8((*mm_genmcl_aa).def);
    mm_libmcl_genmc((int64_t)48,mm_libmcl_changeopndsize(mm_libmcl_genopndind((int64_t)0,(int64_t)8),(int64_t)4),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_pushmem_blk(struct mm_libpcl_pclrec * p) {
    mm_support_gerror((uint8_t*)"block push not supported",(struct mm_decls_unitrec *)(0));
}

static void mm_genmcl_pc_pushint(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadint_d8((*mm_genmcl_aa).value);
}

static void mm_genmcl_pc_pushint128(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d16();
    mm_libmcl_genmc_loadint_d16(mm_lib_getlow128((*mm_genmcl_aa).pvalue128),mm_lib_gethigh128((*mm_genmcl_aa).pvalue128));
}

static void mm_genmcl_pc_pushreal_r64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadreal_d8((*mm_genmcl_aa).xvalue);
}

static void mm_genmcl_pc_pushreal_x8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_x8();
    mm_libmcl_genmc_loadreal_x8((*mm_genmcl_aa).xvalue);
}

static void mm_genmcl_pc_pushreal_x4(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_x8();
    mm_libmcl_genmc_loadreal_x4((*mm_genmcl_aa).xvalue);
}

static void mm_genmcl_pc_pushstr(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadstr((*mm_genmcl_aa).svalue,(int64_t)(strlen((int8_t *)((*mm_genmcl_aa).svalue))));
}

static void mm_genmcl_pc_makeint(struct mm_libpcl_pclrec * p) {
    mm_libmcl_pushalloperands();
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc((int64_t)9,mm_libmcl_genint_mc((*mm_genmcl_aa).value,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_freereg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]));
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)0);
    mm_genmcl_call64handler_f((int64_t)171,(int64_t)1);
}

static void mm_genmcl_pc_makereal(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_x8();
    mm_libmcl_genmc_loadreal_x8((*mm_genmcl_aa).xvalue);
    mm_libmcl_pushalloperands();
    mm_genmcl_call64handler_f((int64_t)172,(int64_t)1);
}

static void mm_genmcl_pc_makestr(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadstr((*mm_genmcl_aa).svalue,(int64_t)(strlen((int8_t *)((*mm_genmcl_aa).svalue))));
    mm_libmcl_pushalloperands();
    mm_genmcl_call64handler_f((int64_t)173,(int64_t)1);
}

static void mm_genmcl_pc_makedec(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadstr((*mm_genmcl_aa).svalue,(int64_t)(strlen((int8_t *)((*mm_genmcl_aa).svalue))));
    mm_libmcl_pushalloperands();
    mm_genmcl_call64handler_f((int64_t)174,(int64_t)1);
}

static void mm_genmcl_pc_stackargs(struct mm_libpcl_pclrec * p) {
    mm_libmcl_pushalloperands();
}

static void mm_genmcl_pc_pushaddr(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmemaddr((*mm_genmcl_aa).def);
}

static void mm_genmcl_pc_pushptr_d8_proc(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_loadptr_d8((*mm_genmcl_aa).value);
}

static void mm_genmcl_pc_pushptr_d16(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_loadptr_d16((*mm_genmcl_aa).value);
}

static void mm_genmcl_pc_pushptr_x8(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  fx;
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    mm_libmcl_newopnd_x8();
    fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)14,fx,px);
    mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_pushptr_x4(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  fx;
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    px = mm_libmcl_changeopndsize(px,(int64_t)4);
    mm_libmcl_newopnd_x8();
    fx = mm_libmcl_genopnd((int64_t)0,(int64_t)4);
    mm_libmcl_genmc((int64_t)13,fx,px);
    mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_pushptr_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_loadptr_d124((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]),(*mm_genmcl_aa).value);
}

static void mm_genmcl_pc_pushptr_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_loadptr_d8((*mm_genmcl_aa).value);
    mm_libmcl_genmc((int64_t)48,mm_libmcl_changeopndsize(mm_libmcl_genopndind((int64_t)0,(int64_t)8),(int64_t)4),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_pushretslot_d8_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newstackopnd_d8();
}

static void mm_genmcl_pc_pushretslot_d16(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newstackopnd_d16();
}

static void mm_genmcl_pc_pushretslot_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newstackopnd_var();
}

static void mm_genmcl_pc_pushretslot_x8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newstackopnd_x8();
}

static void mm_genmcl_pc_pushffretval_pushretval_d8_d124_var(struct mm_libpcl_pclrec * p) {
    if ((!!(mm_libmcl_noperands) && ((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) != (int64_t)0))) {
        mm_libmcl_gencomment_mc((uint8_t*)"1:pushffret: regs in use");
    };
    mm_libmcl_newretvalopnd_d8();
}

static void mm_genmcl_pc_pushffretval_pushretval_x8_x4(struct mm_libpcl_pclrec * p) {
    if ((!!(mm_libmcl_noperands) && ((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) != (int64_t)0))) {
        mm_support_gerror((uint8_t*)"2:pushffret: regs in use",(struct mm_decls_unitrec *)(0));
    };
    mm_libmcl_newretvalopnd_x8();
}

static void mm_genmcl_pc_pushretval_d16(struct mm_libpcl_pclrec * p) {
    if ((!!(mm_libmcl_noperands) && ((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) != (int64_t)0))) {
        mm_libmcl_gencomment_mc((uint8_t*)"3:pushret: regs in use");
    };
    mm_libmcl_newretvalopnd_d16();
}

static void mm_genmcl_pc_moveretval_d8_d124_var(struct mm_libpcl_pclrec * p) {
    int64_t reg;
    if (((mm_libmcl_noperands > (int64_t)1) && ((int64_t)((uint64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1])) != (int64_t)0))) {
        mm_support_gerror((uint8_t*)"moveretval: other regs not empty",(struct mm_decls_unitrec *)(0));
    };
    mm_libmcl_getopnds((int64_t)1);
    reg = (int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    if ((reg != (int64_t)1)) {
        mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
        mm_libmcl_freereg(reg);
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_moveretval_d16(struct mm_libpcl_pclrec * p) {
    int64_t reg1;
    int64_t reg2;
    if (((mm_libmcl_noperands > (int64_t)1) && ((int64_t)((uint64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1])) != (int64_t)0))) {
        mm_support_gerror((uint8_t*)"moveretval_d16: other regs not empty",(struct mm_decls_unitrec *)(0));
    };
    mm_libmcl_getopnds((int64_t)1);
    reg1 = (int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    reg2 = (int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]);
    if (((reg1 != (int64_t)1) && (reg2 != (int64_t)2))) {
        mm_support_gerror((uint8_t*)"MOVERETVAL/D16 - NOT IN D1:D0",(struct mm_decls_unitrec *)(0));
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_moveretval_x8_x4(struct mm_libpcl_pclrec * p) {
    int64_t reg;
    if (((mm_libmcl_noperands > (int64_t)1) && ((int64_t)((uint64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1])) != (int64_t)0))) {
        mm_libmcl_gencomment_mc((uint8_t*)"MOVERETVALX: OTHER REGS NOT EMPTY");
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"moveretvalx: other regs not empty",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    mm_libmcl_getopnds((int64_t)1);
    reg = (int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    if ((reg != (int64_t)1)) {
        mm_libmcl_genmc((int64_t)8,mm_libmcl_genxreg((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
        mm_libmcl_freexreg(reg);
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popmem_popmemz_d8(struct mm_libpcl_pclrec * p) {
    if ((((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) != (int64_t)0) && ((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) == (uint64_t)70u))) {
        mm_libmcl_genmc_storemem_x8((*p).a.def);
        mm_libmcl_popopnd();
    } else {
        mm_libmcl_getopnds((int64_t)1);
        mm_libmcl_genmc_storemem_d8((*p).a.def);
        mm_libmcl_popopnd();
    };
}

static void mm_genmcl_pc_popmem_d16(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_storemem_d16((*p).a.def);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popmem_x8(struct mm_libpcl_pclrec * p) {
    if (((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) == (int64_t)0)) {
        mm_libmcl_getopnds((int64_t)1);
        mm_libmcl_genmc_storemem_d8((*p).a.def);
        mm_libmcl_popopnd();
    } else if (((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) == (uint64_t)70u)) {
        mm_libmcl_genmc_storemem_x8((*p).a.def);
        mm_libmcl_popopnd();
    } else {
        mm_libmcl_gerrorc((uint8_t*)"popmem/x8 not in xreg");
    };
}

static void mm_genmcl_pc_popmem_x4(struct mm_libpcl_pclrec * p) {
    if (((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) == (int64_t)0)) {
        mm_libmcl_getopnds((int64_t)1);
        mm_libmcl_genmc_storemem_d124((*p).a.def,(int64_t)8);
        mm_libmcl_popopnd();
    } else if (((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) == (uint64_t)70u)) {
        mm_libmcl_genmc_storemem_x4((*p).a.def);
        mm_libmcl_popopnd();
    } else {
        mm_libmcl_gerrorc((uint8_t*)"popmem/x4 not in xreg");
    };
}

static void mm_genmcl_pc_popmem_popmemz_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_storemem_d124((*p).a.def,(int64_t)((*p).mode));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popmem_blk(struct mm_libpcl_pclrec * p) {
    mm_support_gerror((uint8_t*)"block pop not supported",(struct mm_decls_unitrec *)(0));
}

static void mm_genmcl_pc_popmem_storemem_var(struct mm_libpcl_pclrec * p) {
    int64_t isstore;
    isstore = ((int64_t)((*p).opcode) == (int64_t)35);
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmemaddr((*mm_genmcl_aa).def);
    if (!!(isstore)) {
        mm_genmcl_call64handler_f((int64_t)78,(int64_t)2);
    } else {
        mm_genmcl_call64handler_p((int64_t)77,(int64_t)2);
    };
}

static void mm_genmcl_pc_popptr_d8_x8(struct mm_libpcl_pclrec * p) {
    if ((((int64_t)((uint64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1])) != (int64_t)0) && ((uint64_t)(mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1]) == (uint64_t)70u))) {
        mm_libmcl_genmc_storeptr_x8((*mm_genmcl_aa).value);
    } else {
        mm_libmcl_getopnds((int64_t)2);
        mm_libmcl_genmc_storeptr_d8((*mm_genmcl_aa).value);
    };
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popptr_d16(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc_storeptr_d16((*mm_genmcl_aa).value);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popptr_x4(struct mm_libpcl_pclrec * p) {
    if ((((int64_t)((uint64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1])) != (int64_t)0) && ((uint64_t)(mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1]) == (uint64_t)70u))) {
        mm_libmcl_genmc_storeptr_x4((*mm_genmcl_aa).value);
    } else {
        mm_libmcl_getopnds((int64_t)2);
        mm_libmcl_genmc_storeptr_x4((*mm_genmcl_aa).value);
    };
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popptr_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc_storeptr_d124((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]),(*mm_genmcl_aa).value);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popptr_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_genmcl_call64handler_p((int64_t)77,(int64_t)2);
}

static void mm_genmcl_pc_storeptr_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_genmcl_call64handler_f((int64_t)78,(int64_t)2);
}

static void mm_genmcl_pc_storeptr_d8(struct mm_libpcl_pclrec * p) {
    if ((((int64_t)((uint64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1])) != (int64_t)0) && ((uint64_t)(mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1]) == (uint64_t)70u))) {
        mm_libmcl_genmc_storeptr_x8((*mm_genmcl_aa).value);
    } else {
        mm_libmcl_getopnds((int64_t)2);
        mm_libmcl_genmc_storeptr_d8((*mm_genmcl_aa).value);
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_storeptr_d124(struct mm_libpcl_pclrec * p) {
    if ((((int64_t)((uint64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1])) != (int64_t)0) && ((uint64_t)(mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1]) == (uint64_t)70u))) {
        mm_support_gerror((uint8_t*)"STOREPTR/D124/F",(struct mm_decls_unitrec *)(0));
    } else {
        mm_libmcl_getopnds((int64_t)2);
        mm_libmcl_genmc_storeptr_d124((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]),(*mm_genmcl_aa).value);
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_storemem_d8(struct mm_libpcl_pclrec * p) {
    if ((((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) != (int64_t)0) && ((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) == (uint64_t)70u))) {
        mm_libmcl_genmc_storemem_x8((*p).a.def);
    } else {
        mm_libmcl_getopnds((int64_t)1);
        mm_libmcl_genmc_storemem_d8((*p).a.def);
    };
}

static void mm_genmcl_pc_storemem_d16(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_storemem_d16((*p).a.def);
}

static void mm_genmcl_pc_storemem_x8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_storemem_x8((*p).a.def);
}

static void mm_genmcl_pc_storemem_x4(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_storemem_x4((*p).a.def);
}

static void mm_genmcl_pc_storemem_d124(struct mm_libpcl_pclrec * p) {
    if ((((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) != (int64_t)0) && ((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) == (uint64_t)70u))) {
        mm_support_gerror((uint8_t*)"STOREMEM/D124/X",(struct mm_decls_unitrec *)(0));
    } else {
        mm_libmcl_getopnds((int64_t)1);
        mm_libmcl_genmc_storemem_d124((*p).a.def,(int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]));
    };
}

static void mm_genmcl_pc_storeptr(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_storeptr");
}

static void mm_genmcl_pc_unstack(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_unstack");
}

static void mm_genmcl_pc_popretval_d16(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_storeretval_d16_var((*p).a.value);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popretval_d8_d124_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_storeretval_d8((*p).a.value);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_popretval_x8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc_storeretval_x8((*p).a.value);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_free_d8_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_free_d16(struct mm_libpcl_pclrec * p) {
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_free_x4_x8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_free_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)75,(int64_t)1);
}

static void mm_genmcl_pc_freemem_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmem_d8((*mm_genmcl_aa).def);
    mm_libmcl_pushalloperands();
    mm_libmcl_genmc_sys((int64_t)72);
    mm_libmcl_poparg();
}

static void mm_genmcl_pc_add_sub_i64_u64_c64_ref(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)45)?(int64_t)24:(int64_t)25),mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_add_i128_u128(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((int64_t)24,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_genmc((int64_t)26,mm_libmcl_genopndh((int64_t)1),mm_libmcl_genopndh((int64_t)0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_sub_i128_u128(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((int64_t)25,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_genmc((int64_t)27,mm_libmcl_genopndh((int64_t)1),mm_libmcl_genopndh((int64_t)0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_add_sub_mul_div_r32_r64(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    opc = (int64_t)0;
    mm_libmcl_getopnds((int64_t)2);
    if (((int64_t)((*p).mode) == (int64_t)11)) {
        if (((int64_t)((*p).opcode)==(int64_t)45)) {
            opc = (int64_t)59;
        }else if (((int64_t)((*p).opcode)==(int64_t)46)) {
            opc = (int64_t)60;
        }else if (((int64_t)((*p).opcode)==(int64_t)47)) {
            opc = (int64_t)61;
        }else if (((int64_t)((*p).opcode)==(int64_t)48)) {
            opc = (int64_t)62;
        };
    } else {
        if (((int64_t)((*p).opcode)==(int64_t)45)) {
            opc = (int64_t)63;
        }else if (((int64_t)((*p).opcode)==(int64_t)46)) {
            opc = (int64_t)64;
        }else if (((int64_t)((*p).opcode)==(int64_t)47)) {
            opc = (int64_t)65;
        }else if (((int64_t)((*p).opcode)==(int64_t)48)) {
            opc = (int64_t)66;
        };
    };
    mm_libmcl_genmc(opc,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_add_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)79,(int64_t)2);
}

static void mm_genmcl_pc_sub_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)80,(int64_t)2);
}

static void mm_genmcl_pc_mul_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)81,(int64_t)2);
}

static void mm_genmcl_pc_div_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)82,(int64_t)2);
}

static void mm_genmcl_pc_idiv_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)83,(int64_t)2);
}

static void mm_genmcl_pc_irem_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)84,(int64_t)2);
}

static void mm_genmcl_pc_iand_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)93,(int64_t)2);
}

static void mm_genmcl_pc_ior_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)94,(int64_t)2);
}

static void mm_genmcl_pc_ixor_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)95,(int64_t)2);
}

static void mm_genmcl_pc_shl_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)96,(int64_t)2);
}

static void mm_genmcl_pc_shr_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)97,(int64_t)2);
}

static void mm_genmcl_pc_min_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)102,(int64_t)2);
}

static void mm_genmcl_pc_max_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)103,(int64_t)2);
}

static void mm_genmcl_pc_power_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)85,(int64_t)2);
}

static void mm_genmcl_pc_append_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)100,(int64_t)2);
}

static void mm_genmcl_pc_appendto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)143,(int64_t)2);
}

static void mm_genmcl_pc_concat_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)101,(int64_t)2);
}

static void mm_genmcl_pc_concatto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)144,(int64_t)2);
}

static void mm_genmcl_pc_slice_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)162,(int64_t)3);
}

static void mm_genmcl_pc_in_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)104,(int64_t)2);
}

static void mm_genmcl_pc_neg_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)105,(int64_t)1);
}

static void mm_genmcl_pc_abs_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)106,(int64_t)1);
}

static void mm_genmcl_pc_inot_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)107,(int64_t)1);
}

static void mm_genmcl_pc_notl_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)108,(int64_t)1);
}

static void mm_genmcl_pc_istruel_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)109,(int64_t)1);
}

static void mm_genmcl_pc_sqrt_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)110,(int64_t)1);
}

static void mm_genmcl_pc_sin_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)111,(int64_t)1);
}

static void mm_genmcl_pc_cos_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)112,(int64_t)1);
}

static void mm_genmcl_pc_tan_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)113,(int64_t)1);
}

static void mm_genmcl_pc_asin_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)114,(int64_t)1);
}

static void mm_genmcl_pc_acos_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)115,(int64_t)1);
}

static void mm_genmcl_pc_atan_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)116,(int64_t)1);
}

static void mm_genmcl_pc_exp_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)117,(int64_t)1);
}

static void mm_genmcl_pc_ln_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)118,(int64_t)1);
}

static void mm_genmcl_pc_log_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)119,(int64_t)1);
}

static void mm_genmcl_pc_round_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)120,(int64_t)1);
}

static void mm_genmcl_pc_floor_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)121,(int64_t)1);
}

static void mm_genmcl_pc_ceil_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)122,(int64_t)1);
}

static void mm_genmcl_pc_fract_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)123,(int64_t)1);
}

static void mm_genmcl_pc_asc_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)124,(int64_t)1);
}

static void mm_genmcl_pc_chr_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)125,(int64_t)1);
}

static void mm_genmcl_pc_lwb_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)126,(int64_t)1);
}

static void mm_genmcl_pc_upb_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)127,(int64_t)1);
}

static void mm_genmcl_pc_len_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)128,(int64_t)1);
}

static void mm_genmcl_pc_bounds_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)129,(int64_t)1);
}

static void mm_genmcl_pc_addto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)130,(int64_t)2);
}

static void mm_genmcl_pc_subto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)131,(int64_t)2);
}

static void mm_genmcl_pc_multo_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)132,(int64_t)2);
}

static void mm_genmcl_pc_divto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)133,(int64_t)2);
}

static void mm_genmcl_pc_idivto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)134,(int64_t)2);
}

static void mm_genmcl_pc_iremto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)135,(int64_t)2);
}

static void mm_genmcl_pc_iandto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)136,(int64_t)2);
}

static void mm_genmcl_pc_iorto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)137,(int64_t)2);
}

static void mm_genmcl_pc_ixorto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)138,(int64_t)2);
}

static void mm_genmcl_pc_shlto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)139,(int64_t)2);
}

static void mm_genmcl_pc_shrto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)140,(int64_t)2);
}

static void mm_genmcl_pc_minto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)145,(int64_t)2);
}

static void mm_genmcl_pc_maxto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)146,(int64_t)2);
}

static void mm_genmcl_pc_negto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)147,(int64_t)1);
}

static void mm_genmcl_pc_absto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)148,(int64_t)1);
}

static void mm_genmcl_pc_inotto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)149,(int64_t)1);
}

static void mm_genmcl_pc_notlto_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)150,(int64_t)1);
}

static void mm_genmcl_pc_mul_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((int64_t)30,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_mul_i128_u128(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call128handler_f((int64_t)3,(int64_t)2);
}

static void mm_genmcl_pc_idiv_i128_u128(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call128handler_f((int64_t)4,(int64_t)2);
}

static void mm_genmcl_pc_idiv_irem_i64_u64(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    mm_libmcl_getopnds((int64_t)2);
    mm_genmcl_fixdivopnds_d8();
    opc = (int64_t)32;
    if (((int64_t)((*p).catmode)==(int64_t)4)) {
        mm_libmcl_genmc((int64_t)53,(struct mm_mcldecls_opndrec *)(0),(struct mm_mcldecls_opndrec *)(0));
    } else {
        mm_libmcl_genmc((int64_t)36,mm_libmcl_genreg((int64_t)12,(int64_t)8),mm_libmcl_genreg((int64_t)12,(int64_t)8));
        opc = (int64_t)33;
    };
    mm_libmcl_genmc(opc,mm_libmcl_genopnd((int64_t)0,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])),(struct mm_mcldecls_opndrec *)(0));
    if (((int64_t)((*p).opcode) == (int64_t)50)) {
        mm_libmcl_genmc((int64_t)23,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genreg((int64_t)12,(int64_t)8));
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_neg_i64_u64_c64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)46,mm_libmcl_genopnd((int64_t)0,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_neg_i128_u128(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax1;
    struct mm_mcldecls_opndrec *  ax2;
    struct mm_mcldecls_opndrec *  bx1;
    struct mm_mcldecls_opndrec *  bx2;
    mm_libmcl_getopnds((int64_t)1);
    ax1 = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    ax2 = mm_libmcl_genopndh((int64_t)0);
    bx1 = mm_libmcl_gettempopnd_d8();
    bx2 = mm_libmcl_gettempopnd_d8();
    mm_libmcl_genmc((int64_t)36,bx1,bx1);
    mm_libmcl_genmc((int64_t)36,bx2,bx2);
    mm_libmcl_genmc((int64_t)25,bx1,ax1);
    mm_libmcl_genmc((int64_t)27,bx2,ax2);
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((*bx1).reg);
    mm_libmcl_opndreg2[(mm_libmcl_noperands)-1] = (uint64_t)((*bx2).reg);
    mm_libmcl_freetempopnd_d8(ax1);
    mm_libmcl_freetempopnd_d8(ax2);
}

static void mm_genmcl_pc_neg_r64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    if (!(!!(mm_libmcl_labneg64))) {
        mm_libmcl_labneg64 = mm_libpcl_createfwdlabel();
    };
    mm_libmcl_genmc((int64_t)69,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genlabel_mem(mm_libmcl_labneg64));
}

static void mm_genmcl_pc_neg_r32(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    if (!(!!(mm_libmcl_labneg32))) {
        mm_libmcl_labneg32 = mm_libpcl_createfwdlabel();
    };
    mm_libmcl_genmc((int64_t)70,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genlabel_mem(mm_libmcl_labneg32));
}

static void mm_genmcl_pc_neg(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_neg");
}

static void mm_genmcl_pc_abs_i64_u64_c64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  lx;
    int64_t lab;
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)38,(ax = mm_libmcl_genopnd((int64_t)0,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]))),mm_libmcl_genint_mc((int64_t)0,(int64_t)8));
    lab = ++mm_decls_labelno;
    mm_libmcl_genmc_cond((int64_t)22,(int64_t)13,(lx = mm_libmcl_genlabel_mc(lab)),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)46,ax,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,lx,(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_abs_r32(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    if (!(!!(mm_libmcl_lababs32))) {
        mm_libmcl_lababs32 = mm_libpcl_createfwdlabel();
    };
    mm_libmcl_genmc((int64_t)72,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genlabel_mem(mm_libmcl_lababs32));
}

static void mm_genmcl_pc_abs_r64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    if (!(!!(mm_libmcl_lababs64))) {
        mm_libmcl_lababs64 = mm_libpcl_createfwdlabel();
    };
    mm_libmcl_genmc((int64_t)71,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genlabel_mem(mm_libmcl_lababs64));
}

static void mm_genmcl_pc_inot_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)47,mm_libmcl_genopnd((int64_t)0,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_notl_d8_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)36,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((int64_t)1,(int64_t)8));
}

static void mm_genmcl_pc_istruel_d8_d124(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)37,ax,ax);
    mm_libmcl_genmc_cond((int64_t)54,(int64_t)5,(bx = mm_libmcl_changeopndsize(ax,(int64_t)1)),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)16,mm_libmcl_changeopndsize(ax,(int64_t)4),bx);
}

static void mm_genmcl_pc_call(struct mm_libpcl_pclrec * p) {
    int64_t av_1;
    if (((int64_t)((*mm_genmcl_aa).optype)==(int64_t)2)) {
        mm_libmcl_genmc((int64_t)18,mm_libmcl_genmemaddr_d_mc((*mm_genmcl_aa).def),(struct mm_mcldecls_opndrec *)(0));
    }else if (((int64_t)((*mm_genmcl_aa).optype)==(int64_t)11)) {
        mm_libmcl_genmc((int64_t)18,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
    } else {
        mm_support_gerror((uint8_t*)"pc/call",(struct mm_decls_unitrec *)(0));
    };
    av_1 = (*mm_genmcl_bb).value;
    while (av_1-- > 0) {
L718 :;
        mm_libmcl_poparg();
L719 :;
    }L720 :;
    ;
}

static void mm_genmcl_pc_return(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)19,(struct mm_mcldecls_opndrec *)(0),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_callptr(struct mm_libpcl_pclrec * p) {
    int64_t av_1;
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)18,mm_libmcl_genopnd((int64_t)0,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
    av_1 = (*mm_genmcl_aa).value;
    while (av_1-- > 0) {
L721 :;
        mm_libmcl_poparg();
L722 :;
    }L723 :;
    ;
}

static void mm_genmcl_pc_syscall(struct mm_libpcl_pclrec * p) {
    int64_t fn;
    int64_t av_1;
    fn = (*mm_genmcl_aa).value;
    mm_libmcl_genmc_sys(fn);
    av_1 = (*mm_genmcl_bb).value;
    while (av_1-- > 0) {
L724 :;
        mm_libmcl_poparg();
L725 :;
    }L726 :;
    ;
}

static void mm_genmcl_pc_callff(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genmemaddr_d_mc((*mm_genmcl_bb).def));
    mm_genmcl_docallff((int64_t)((*mm_genmcl_aa).nargs),(*p).a.floatmap,(int64_t)((*p).isfunction),(int64_t)((*p).isvariadic));
}

static void mm_genmcl_pc_callptrff(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    if (((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) != (int64_t)1)) {
        mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    };
    mm_libmcl_popopnd();
    mm_genmcl_docallff((int64_t)((*mm_genmcl_aa).nargs),(*p).a.floatmap,(int64_t)((*p).isfunction),(int64_t)((*p).isvariadic));
}

static void mm_genmcl_pc_jump(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)21,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_jumpcc_i64_u64_ref_c64(struct mm_libpcl_pclrec * p) {
    int64_t cond;
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((int64_t)38,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    if (!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).catmode))]))) {
        cond = mm_libmcl_getmclcond_i((int64_t)((*p).cond));
    } else {
        cond = mm_libmcl_getmclcond_u((int64_t)((*p).cond));
    };
    mm_libmcl_genmc_cond((int64_t)22,cond,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_jumpccimm_i64_u64_c64(struct mm_libpcl_pclrec * p) {
    int64_t cond;
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)38,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((*mm_genmcl_bb).value,(int64_t)8));
    if (!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).catmode))]))) {
        cond = mm_libmcl_getmclcond_i((int64_t)((*p).cond));
    } else {
        cond = mm_libmcl_getmclcond_u((int64_t)((*p).cond));
    };
    mm_libmcl_genmc_cond((int64_t)22,cond,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_jumpcc_i128(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  lxtrue;
    struct mm_mcldecls_opndrec *  lxfalse;
    struct mm_mcldecls_opndrec *  ax1;
    struct mm_mcldecls_opndrec *  ax2;
    struct mm_mcldecls_opndrec *  bx1;
    struct mm_mcldecls_opndrec *  bx2;
    lxtrue = mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno);
    lxfalse = mm_libmcl_genlabel_mc(++mm_decls_labelno);
    mm_libmcl_getopnds((int64_t)2);
    ax1 = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    ax2 = mm_libmcl_genopndh((int64_t)1);
    bx1 = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    bx2 = mm_libmcl_genopndh((int64_t)0);
    if (((int64_t)((*p).cond)==(int64_t)36)) {
        mm_libmcl_genmc((int64_t)38,ax1,bx1);
        mm_libmcl_genmc_cond((int64_t)22,(int64_t)5,lxfalse,(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_genmc((int64_t)38,ax2,bx2);
        mm_libmcl_genmc_cond((int64_t)22,(int64_t)4,lxtrue,(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_genmc((int64_t)5,lxfalse,(struct mm_mcldecls_opndrec *)(0));
    }else if (((int64_t)((*p).cond)==(int64_t)37)) {
        mm_libmcl_genmc((int64_t)38,ax1,bx1);
        mm_libmcl_genmc_cond((int64_t)22,(int64_t)5,lxtrue,(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_genmc((int64_t)38,ax2,bx2);
        mm_libmcl_genmc_cond((int64_t)22,(int64_t)5,lxtrue,(struct mm_mcldecls_opndrec *)(0));
    } else {
        mm_libmcl_genmc((int64_t)25,ax1,bx1);
        mm_libmcl_genmc((int64_t)27,ax2,bx2);
        mm_libmcl_genmc((int64_t)38,ax2,mm_libmcl_zero_opnd);
        if (((int64_t)((*p).cond)==(int64_t)38)) {
            mm_libmcl_genmc_cond((int64_t)22,(int64_t)12,lxtrue,(struct mm_mcldecls_opndrec *)(0));
        }else if (((int64_t)((*p).cond)==(int64_t)39)) {
            mm_libmcl_genmc_cond((int64_t)22,(int64_t)12,lxtrue,(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_genmc((int64_t)35,ax1,ax2);
            mm_libmcl_genmc_cond((int64_t)22,(int64_t)4,lxtrue,(struct mm_mcldecls_opndrec *)(0));
        }else if (((int64_t)((*p).cond)==(int64_t)40)) {
            mm_libmcl_genmc_cond((int64_t)22,(int64_t)12,lxfalse,(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_genmc((int64_t)35,ax1,ax2);
            mm_libmcl_genmc_cond((int64_t)22,(int64_t)5,lxtrue,(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_genmc((int64_t)5,lxfalse,(struct mm_mcldecls_opndrec *)(0));
        }else if (((int64_t)((*p).cond)==(int64_t)41)) {
            mm_libmcl_genmc_cond((int64_t)22,(int64_t)13,lxtrue,(struct mm_mcldecls_opndrec *)(0));
        };
    };
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_jumpcc_u128(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  lxtrue;
    struct mm_mcldecls_opndrec *  lxfalse;
    struct mm_mcldecls_opndrec *  ax1;
    struct mm_mcldecls_opndrec *  bx1;
    struct mm_mcldecls_opndrec *  ax2;
    struct mm_mcldecls_opndrec *  bx2;
    int64_t cond1;
    int64_t cond2;
    int64_t cond3;
    if ((((*p).cond == (int64_t)36) || ((*p).cond == (int64_t)37))) {
        mm_genmcl_pc_jumpcc_i128(p);
        return;
    };
    if (((int64_t)((*p).cond)==(int64_t)40)) {
        cond1 = (int64_t)7;
        cond2 = (int64_t)2;
        cond3 = (int64_t)7;
    }else if (((int64_t)((*p).cond)==(int64_t)41)) {
        cond1 = (int64_t)7;
        cond2 = (int64_t)2;
        cond3 = (int64_t)3;
    }else if (((int64_t)((*p).cond)==(int64_t)38)) {
        cond1 = (int64_t)2;
        cond2 = (int64_t)7;
        cond3 = (int64_t)2;
    }else if (((int64_t)((*p).cond)==(int64_t)39)) {
        cond1 = (int64_t)2;
        cond2 = (int64_t)7;
        cond3 = (int64_t)6;
    };
    lxtrue = mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno);
    lxfalse = mm_libmcl_genlabel_mc(++mm_decls_labelno);
    mm_libmcl_getopnds((int64_t)2);
    ax1 = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    ax2 = mm_libmcl_genopndh((int64_t)1);
    bx1 = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    bx2 = mm_libmcl_genopndh((int64_t)0);
    mm_libmcl_genmc((int64_t)38,ax2,bx2);
    mm_libmcl_genmc_cond((int64_t)22,cond1,lxtrue,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc_cond((int64_t)22,cond2,lxfalse,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)38,ax1,bx1);
    mm_libmcl_genmc_cond((int64_t)22,cond3,lxtrue,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,lxfalse,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_jumpcc_r32_r64(struct mm_libpcl_pclrec * p) {
    int64_t cond;
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) == (int64_t)4)?(int64_t)67:(int64_t)68),mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    cond = mm_libmcl_getmclcond_u((int64_t)((*p).cond));
    mm_libmcl_genmc_cond((int64_t)22,cond,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_jumpcc_var(struct mm_libpcl_pclrec * p) {
    int64_t fn;
    struct mm_mcldecls_opndrec *  lxtrue;
    struct mm_mcldecls_opndrec *  ax;
    lxtrue = mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno);
    if (((int64_t)((*p).cond)==(int64_t)36)) {
        fn = (int64_t)87;
    }else if (((int64_t)((*p).cond)==(int64_t)37)) {
        fn = (int64_t)86;
    }else if (((int64_t)((*p).cond)==(int64_t)38)) {
        fn = (int64_t)90;
    }else if (((int64_t)((*p).cond)==(int64_t)39)) {
        fn = (int64_t)91;
    }else if (((int64_t)((*p).cond)==(int64_t)41)) {
        fn = (int64_t)88;
    }else if (((int64_t)((*p).cond)==(int64_t)40)) {
        fn = (int64_t)89;
    };
    mm_genmcl_call64handler_f(fn,(int64_t)2);
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)34,ax,ax);
    mm_libmcl_genmc_cond((int64_t)22,(int64_t)4,lxtrue,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_jumpfalse_jumptrue_i64_u64_r64_ref_c64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)38,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((int64_t)0,(int64_t)8));
    mm_libmcl_genmc_cond((int64_t)22,(((int64_t)((*p).opcode) == (int64_t)66)?(int64_t)5:(int64_t)4),mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_jumpinyz_jumpnotinyz_i64_u64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  cx;
    struct mm_mcldecls_opndrec *  lx;
    struct mm_mcldecls_opndrec *  nolx;
    int64_t m;
    int64_t nolab;
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_getopndn_d8((int64_t)1);
    mm_libmcl_getopndn_d8((int64_t)2);
    cx = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1]),(int64_t)8);
    ax = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)2))-1]),(int64_t)8);
    lx = mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno);
    m = (int64_t)((*p).catmode);
    mm_libmcl_genmc((int64_t)38,ax,bx);
    if (((int64_t)((*p).opcode) == (int64_t)68)) {
        nolx = mm_libmcl_genlabel_mc((nolab = mm_libmcl_createfwdlabel_mc()));
        mm_libmcl_genmc_cond((int64_t)22,((m == (int64_t)4)?(int64_t)12:(int64_t)2),nolx,(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_genmc((int64_t)38,ax,cx);
        mm_libmcl_genmc_cond((int64_t)22,((m == (int64_t)4)?(int64_t)14:(int64_t)6),lx,(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_definefwdlabel_mc(nolab);
    } else {
        mm_libmcl_genmc_cond((int64_t)22,((m == (int64_t)4)?(int64_t)12:(int64_t)2),lx,(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_genmc((int64_t)38,ax,cx);
        mm_libmcl_genmc_cond((int64_t)22,((m == (int64_t)4)?(int64_t)15:(int64_t)7),lx,(struct mm_mcldecls_opndrec *)(0));
    };
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_casejumpeq_i64_u64_r64_ref_c64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((int64_t)38,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_genmc_cond((int64_t)22,(int64_t)4,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_setjumpeq_setjumpeqx_d8_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((int64_t)38,mm_libmcl_genopnd((int64_t)1,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])),mm_libmcl_genopnd((int64_t)0,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])));
    mm_libmcl_genmc_cond((int64_t)22,(int64_t)4,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
    if (((int64_t)((*p).opcode) == (int64_t)73)) {
        mm_libmcl_popopnd();
    };
}

static void mm_genmcl_pc_setjumpne_d8_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((int64_t)38,mm_libmcl_genopnd((int64_t)1,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])),mm_libmcl_genopnd((int64_t)0,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))])));
    mm_libmcl_genmc_cond((int64_t)22,(int64_t)5,mm_libmcl_genlabel_mc((*mm_genmcl_aa).labelno),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_switch(struct mm_libpcl_pclrec * p) {
    int64_t lab1;
    int64_t lab2;
    struct mm_mcldecls_opndrec *  ax;
    lab1 = (*p).a.labelno;
    lab2 = (*p).b.labelno;
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    if ((mm_genmcl_swmin != (int64_t)0)) {
        mm_libmcl_genmc((int64_t)25,ax,mm_libmcl_genint_mc(mm_genmcl_swmin,(int64_t)8));
    };
    mm_libmcl_genmc((int64_t)38,ax,mm_libmcl_genint_mc(((mm_genmcl_swmax - mm_genmcl_swmin) + (int64_t)1),(int64_t)8));
    mm_libmcl_genmc_cond((int64_t)22,(int64_t)3,mm_libmcl_genlabel_mc(lab2),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)21,mm_libmcl_genindex((int64_t)0,(int64_t)((*ax).reg),(int64_t)8,(int64_t)0,(int64_t)0,lab1,(struct mm_decls_strec *)(0)),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
    mm_libmcl_setsegment((int64_t)73,(int64_t)1);
}

static void mm_genmcl_pc_switchlab(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)112,mm_libmcl_genlabel_mc((*p).a.labelno),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_endswitch(struct mm_libpcl_pclrec * p) {
    mm_libmcl_setsegment((int64_t)67,(int64_t)1);
}

static void mm_genmcl_pc_info(struct mm_libpcl_pclrec * p) {
    mm_genmcl_swmin = (*p).a.value;
    mm_genmcl_swmax = (*p).b.value;
}

static void mm_genmcl_pc_setcc_i64_u64_ref_c64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    int64_t cond;
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_genmc((int64_t)38,(ax = mm_libmcl_genopnd((int64_t)1,(int64_t)8)),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    if (!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).catmode))]))) {
        cond = mm_libmcl_getmclcond_i((int64_t)((*p).cond));
    } else {
        cond = mm_libmcl_getmclcond_u((int64_t)((*p).cond));
    };
    mm_libmcl_genmc_cond((int64_t)54,cond,(bx = mm_libmcl_changeopndsize(ax,(int64_t)1)),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)16,mm_libmcl_changeopndsize(ax,(int64_t)4),bx);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_setcc(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_setcc");
}

static void mm_genmcl_pc_setcc_var(struct mm_libpcl_pclrec * p) {
    int64_t fn;
    mm_libmcl_getopnds((int64_t)2);
    if (((int64_t)((*p).cond)==(int64_t)36)) {
        fn = (int64_t)86;
    }else if (((int64_t)((*p).cond)==(int64_t)37)) {
        fn = (int64_t)87;
    }else if (((int64_t)((*p).cond)==(int64_t)38)) {
        fn = (int64_t)88;
    }else if (((int64_t)((*p).cond)==(int64_t)39)) {
        fn = (int64_t)89;
    }else if (((int64_t)((*p).cond)==(int64_t)41)) {
        fn = (int64_t)90;
    }else if (((int64_t)((*p).cond)==(int64_t)40)) {
        fn = (int64_t)91;
    };
    mm_genmcl_call64handler_f(fn,(int64_t)2);
}

static void mm_genmcl_pc_compare(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_compare");
}

static void mm_genmcl_pc_isequal(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_isequal");
}

static void mm_genmcl_pc_iand_ior_ixor_i64_u64_c64(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    mm_libmcl_getopnds((int64_t)2);
    if (((int64_t)((*p).opcode)==(int64_t)82)) {
        opc = (int64_t)34;
    }else if (((int64_t)((*p).opcode)==(int64_t)84)) {
        opc = (int64_t)35;
    }else if (((int64_t)((*p).opcode)==(int64_t)85)) {
        opc = (int64_t)36;
    };
    mm_libmcl_genmc(opc,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_iand_ior_ixor_i128_u128(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    mm_libmcl_getopnds((int64_t)2);
    if (((int64_t)((*p).opcode)==(int64_t)82)) {
        opc = (int64_t)34;
    }else if (((int64_t)((*p).opcode)==(int64_t)84)) {
        opc = (int64_t)35;
    }else if (((int64_t)((*p).opcode)==(int64_t)85)) {
        opc = (int64_t)36;
    };
    mm_libmcl_genmc(opc,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_genmc(opc,mm_libmcl_genopndh((int64_t)1),mm_libmcl_genopndh((int64_t)0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_iandc_i64_u64_c64(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    mm_libmcl_getopnds((int64_t)1);
    if (((int64_t)((*p).opcode)==(int64_t)83)) {
        opc = (int64_t)34;
    };
    mm_libmcl_genmc(opc,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((*mm_genmcl_aa).value,(int64_t)8));
}

static void mm_genmcl_pc_shl_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_genmcl_doshiftn(p,(int64_t)39);
}

static void mm_genmcl_pc_shr_i64(struct mm_libpcl_pclrec * p) {
    mm_genmcl_doshiftn(p,(int64_t)40);
}

static void mm_genmcl_pc_shr_u64(struct mm_libpcl_pclrec * p) {
    mm_genmcl_doshiftn(p,(int64_t)41);
}

static void mm_genmcl_pc_shlc_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)39,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((*mm_genmcl_aa).value,(int64_t)8));
}

static void mm_genmcl_pc_shrc_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).catmode))]))?(int64_t)40:(int64_t)41),mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((*mm_genmcl_aa).value,(int64_t)8));
}

static void mm_genmcl_pc_shr(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_shr");
}

static void mm_genmcl_pc_in(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_in");
}

static void mm_genmcl_pc_min_max_i64_u64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    int64_t cond;
    mm_libmcl_getopnds((int64_t)2);
    ax = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    bx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    if (((int64_t)((*p).opcode) == (int64_t)91)) {
        cond = (((int64_t)((uint64_t)((*p).catmode)) == (int64_t)4)?(int64_t)15:(int64_t)7);
    } else {
        cond = (((int64_t)((uint64_t)((*p).catmode)) == (int64_t)4)?(int64_t)12:(int64_t)2);
    };
    mm_libmcl_genmc((int64_t)38,ax,bx);
    mm_libmcl_genmc_cond((int64_t)12,cond,ax,bx);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_min_max_r64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    mm_libmcl_getopnds((int64_t)2);
    ax = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    bx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)91)?(int64_t)107:(int64_t)108),ax,bx);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_addoffset_ref(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  ix;
    int64_t size;
    int64_t n;
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    size = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*p).mode))]))]);
    if ((size==(int64_t)1) || (size==(int64_t)2) || (size==(int64_t)4) || (size==(int64_t)8)) {
        ix = mm_libmcl_genindex((int64_t)((*px).reg),(int64_t)((*ax).reg),size,(int64_t)0,(int64_t)0,(int64_t)0,(struct mm_decls_strec *)(0));
        mm_libmcl_genmc((int64_t)11,px,ix);
    } else {
        if (!!((n = mm_lib_ispoweroftwo(size)))) {
            mm_libmcl_genmc((int64_t)39,ax,mm_libmcl_genint_mc(n,(int64_t)8));
            mm_libmcl_genmc((int64_t)24,px,ax);
        } else {
            mm_libmcl_genmc((int64_t)30,ax,mm_libmcl_genint_mc(size,(int64_t)8));
            mm_libmcl_genmc((int64_t)24,px,ax);
        };
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_subref_i64_u64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  qx;
    int64_t size;
    int64_t n;
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    qx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    size = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*p).mode2))]))]);
    mm_libmcl_genmc((int64_t)25,px,qx);
    if ((size != (int64_t)1)) {
        if (!!((n = mm_lib_ispoweroftwo(size)))) {
            mm_libmcl_genmc((int64_t)41,px,mm_libmcl_genint_mc(mm_lib_ispoweroftwo(size),(int64_t)8));
        } else {
            mm_support_gerror((uint8_t*)"SUBPTR/NOT 2**N",(struct mm_decls_unitrec *)(0));
        };
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_suboffset_ref(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  qx;
    int64_t size;
    int64_t n;
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    qx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    size = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*p).mode))]))]);
    if ((size == (int64_t)1)) {
    } else if (!!((n = mm_lib_ispoweroftwo(size)))) {
        mm_libmcl_genmc((int64_t)39,qx,mm_libmcl_genint_mc(n,(int64_t)8));
    } else if (((int64_t)((uint64_t)((*px).reg)) == (int64_t)1)) {
        mm_libmcl_genmc((int64_t)30,qx,mm_libmcl_genint_mc(size,(int64_t)8));
    };
    mm_libmcl_genmc((int64_t)25,px,qx);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_concat(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_concat");
}

static void mm_genmcl_pc_append(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_append");
}

static void mm_genmcl_pc_andl(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_andl");
}

static void mm_genmcl_pc_orl(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_orl");
}

static void mm_genmcl_pc_index_indexref_ax_sx(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  ax2;
    struct mm_mcldecls_opndrec *  ix;
    struct mm_mcldecls_opndrec *  fx;
    int64_t rega;
    int64_t regi;
    int64_t elemsize;
    int64_t offset;
    int64_t elemmode;
    int64_t lower;
    int64_t amode;
    int64_t scale;
    int64_t opc;
    int64_t reg2;
    int64_t n;
    if (((int64_t)((uint64_t)((*p).catmode)) == (int64_t)23)) {
        mm_libmcl_getopnds((int64_t)2);
        mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)73u;
        mm_libmcl_freereg((int64_t)(mm_libmcl_opndreg2[((mm_libmcl_noperands - (int64_t)1))-1]));
        amode = (int64_t)((*p).mode);
    } else {
        mm_libmcl_getopnds((int64_t)2);
        amode = (int64_t)((*p).mode);
    };
    ax = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    ix = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    rega = (int64_t)((*ax).reg);
    regi = (int64_t)((*ix).reg);
    elemmode = (int64_t)(mm_decls_tttarget[(amode)]);
    scale = (elemsize = (int64_t)(mm_decls_ttsize[(elemmode)]));
    lower = (int64_t)(mm_decls_ttlower[(amode)]);
    offset = (-(lower) * elemsize);
    if (!(((scale == (int64_t)1) || (scale == (int64_t)2) || (scale == (int64_t)4) || (scale == (int64_t)8)))) {
        if (!!((n = mm_lib_ispoweroftwo(scale)))) {
            mm_libmcl_genmc((int64_t)39,ix,mm_libmcl_genint_mc(n,(int64_t)8));
        } else {
            mm_libmcl_genmc((int64_t)30,ix,mm_libmcl_genint_mc(elemsize,(int64_t)8));
        };
        scale = (int64_t)1;
    };
    if (((int64_t)((*p).opcode) == (int64_t)100)) {
        if (((int64_t)((*p).catmode2)==(int64_t)29)) {
            mm_libmcl_genmc((int64_t)8,ax,mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)8,(int64_t)0,(struct mm_decls_strec *)(0)));
        }else if (((int64_t)((*p).catmode2)==(int64_t)27)) {
            if (!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).mode2))]))) {
                opc = (int64_t)15;
            } else if (!!((uint64_t)(mm_decls_ttisword[((int64_t)((*p).mode2))]))) {
                opc = (int64_t)16;
            } else if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode2))]))) {
                mm_support_gerror((uint8_t*)"INDEX/REF/SHORTFLOAT",(struct mm_decls_unitrec *)(0));
            } else {
                opc = (int64_t)15;
            };
            mm_libmcl_genmc(opc,ax,mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]),(int64_t)0,(struct mm_decls_strec *)(0)));
        }else if (((int64_t)((*p).catmode2)==(int64_t)30)) {
            mm_libmcl_newopnd_x8();
            fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
            mm_libmcl_genmc((int64_t)14,fx,mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)8,(int64_t)0,(struct mm_decls_strec *)(0)));
            mm_libmcl_swapopnds((int64_t)1,(int64_t)3);
            mm_libmcl_popopnd();
        }else if (((int64_t)((*p).catmode2)==(int64_t)31)) {
            ix = mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)16,(int64_t)0,(struct mm_decls_strec *)(0));
            reg2 = mm_libmcl_getnextreg();
            mm_libmcl_opndreg2[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)(reg2);
            mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)87u;
            ax2 = mm_libmcl_genreg(reg2,(int64_t)8);
            mm_libmcl_genmc((int64_t)8,ax2,mm_libmcl_applyoffset(ix,(int64_t)8,(int64_t)0));
            mm_libmcl_genmc((int64_t)8,ax,ix);
        }else if (((int64_t)((*p).catmode2)==(int64_t)28)) {
            mm_libmcl_newopnd_x8();
            fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
            mm_libmcl_genmc((int64_t)13,fx,mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)4,(int64_t)0,(struct mm_decls_strec *)(0)));
            mm_libmcl_swapopnds((int64_t)1,(int64_t)3);
            mm_libmcl_popopnd();
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).catmode2),(int64_t)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_gerror((uint8_t*)"ref/index/catmode2",(struct mm_decls_unitrec *)(0));
        };
    } else {
        mm_libmcl_genmc((int64_t)11,ax,mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]),(int64_t)0,(struct mm_decls_strec *)(0)));
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_indexmem_ax(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ix;
    struct mm_mcldecls_opndrec *  fx;
    int64_t regi;
    int64_t elemsize;
    int64_t offset;
    int64_t elemmode;
    int64_t lower;
    int64_t amode;
    int64_t scale;
    int64_t opc;
    int64_t n;
    struct mm_decls_strec *  d;
    mm_libmcl_getopnds((int64_t)1);
    amode = (int64_t)((*p).mode);
    ix = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    d = (*mm_genmcl_aa).def;
    regi = (int64_t)((*ix).reg);
    elemmode = (int64_t)(mm_decls_tttarget[(amode)]);
    scale = (elemsize = (int64_t)(mm_decls_ttsize[(elemmode)]));
    lower = (int64_t)(mm_decls_ttlower[(amode)]);
    offset = (-(lower) * elemsize);
    if (!(((scale == (int64_t)1) || (scale == (int64_t)2) || (scale == (int64_t)4) || (scale == (int64_t)8)))) {
        if (!!((n = mm_lib_ispoweroftwo(scale)))) {
            mm_libmcl_genmc((int64_t)39,ix,mm_libmcl_genint_mc(n,(int64_t)8));
        } else {
            mm_libmcl_genmc((int64_t)30,ix,mm_libmcl_genint_mc(elemsize,(int64_t)8));
        };
        scale = (int64_t)1;
    };
    if (((int64_t)((*p).catmode2)==(int64_t)29)) {
        mm_libmcl_genmc((int64_t)8,ix,mm_libmcl_genindex((int64_t)0,regi,scale,offset,(int64_t)8,(int64_t)0,d));
    }else if (((int64_t)((*p).catmode2)==(int64_t)27)) {
        if (!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).mode2))]))) {
            opc = (int64_t)15;
        } else if (!!((uint64_t)(mm_decls_ttisword[((int64_t)((*p).mode2))]))) {
            opc = (int64_t)16;
        } else if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode2))]))) {
            mm_support_gerror((uint8_t*)"INDEX/REF/SHORTFLOAT",(struct mm_decls_unitrec *)(0));
        } else {
            opc = (int64_t)16;
        };
        mm_libmcl_genmc(opc,ix,mm_libmcl_genindex((int64_t)0,regi,scale,offset,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]),(int64_t)0,d));
    }else if (((int64_t)((*p).catmode2)==(int64_t)30)) {
        mm_libmcl_newopnd_x8();
        fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
        mm_libmcl_genmc((int64_t)14,fx,mm_libmcl_genindex((int64_t)0,regi,scale,offset,(int64_t)8,(int64_t)0,d));
        mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
        mm_libmcl_popopnd();
    }else if (((int64_t)((*p).catmode2)==(int64_t)31)) {
        mm_libmcl_genmc_loadptr_d16(offset);
    }else if (((int64_t)((*p).catmode2)==(int64_t)28)) {
        mm_libmcl_newopnd_x8();
        fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
        mm_libmcl_genmc((int64_t)13,fx,mm_libmcl_genindex((int64_t)0,regi,scale,offset,(int64_t)4,(int64_t)0,d));
        mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
        mm_libmcl_popopnd();
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).catmode2),(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"2:index/catmode2",(struct mm_decls_unitrec *)(0));
    };
}

static void mm_genmcl_pc_indexref_var(struct mm_libpcl_pclrec * p) {
    mm_support_gerror((uint8_t*)"PC/INDEXREF/VAR",(struct mm_decls_unitrec *)(0));
}

static void mm_genmcl_pc_index_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)158,(int64_t)2);
}

static void mm_genmcl_pc_popindex_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)159,(int64_t)3);
}

static void mm_genmcl_pc_dotindex_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)160,(int64_t)2);
}

static void mm_genmcl_pc_popdotindex_var(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_p((int64_t)161,(int64_t)3);
}

static void mm_genmcl_pc_popindex_storeindex_ax_sx(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  ix;
    struct mm_mcldecls_opndrec *  fx;
    int64_t rega;
    int64_t regi;
    int64_t elemsize;
    int64_t offset;
    int64_t elemmode;
    int64_t lower;
    int64_t amode;
    int64_t scale;
    int64_t n;
    mm_libmcl_getopnds((int64_t)3);
    if (((int64_t)((uint64_t)((*p).catmode)) == (int64_t)23)) {
        mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)73u;
        mm_libmcl_freereg((int64_t)(mm_libmcl_opndreg2[((mm_libmcl_noperands - (int64_t)1))-1]));
        amode = (int64_t)((*p).mode);
    } else {
        amode = (int64_t)((*p).mode);
    };
    ax = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    ix = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    rega = (int64_t)((*ax).reg);
    regi = (int64_t)((*ix).reg);
    elemmode = (int64_t)(mm_decls_tttarget[(amode)]);
    scale = (elemsize = (int64_t)(mm_decls_ttsize[(elemmode)]));
    lower = (int64_t)(mm_decls_ttlower[(amode)]);
    offset = (-(lower) * elemsize);
    if (!(((scale == (int64_t)1) || (scale == (int64_t)2) || (scale == (int64_t)4) || (scale == (int64_t)8)))) {
        if (!!((n = mm_lib_ispoweroftwo(scale)))) {
            mm_libmcl_genmc((int64_t)39,ix,mm_libmcl_genint_mc(n,(int64_t)8));
        } else {
            mm_libmcl_genmc((int64_t)30,ix,mm_libmcl_genint_mc(elemsize,(int64_t)8));
        };
        scale = (int64_t)1;
    };
    if (((int64_t)((*p).catmode2)==(int64_t)29)) {
        ix = mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)8,(int64_t)0,(struct mm_decls_strec *)(0));
        mm_libmcl_genmc((int64_t)8,ix,mm_libmcl_genopnd((int64_t)2,(int64_t)8));
    }else if (((int64_t)((*p).catmode2)==(int64_t)27)) {
        ix = mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]),(int64_t)0,(struct mm_decls_strec *)(0));
        mm_libmcl_genmc((int64_t)8,ix,mm_libmcl_genopnd((int64_t)2,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))])));
    }else if (((int64_t)((*p).catmode2)==(int64_t)30)) {
        ix = mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)8,(int64_t)0,(struct mm_decls_strec *)(0));
        fx = mm_libmcl_genopnd((int64_t)2,(int64_t)8);
        mm_libmcl_genmc((int64_t)14,ix,fx);
    }else if (((int64_t)((*p).catmode2)==(int64_t)31)) {
        ix = mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)16,(int64_t)0,(struct mm_decls_strec *)(0));
        ix = mm_libmcl_changeopndsize(ix,(int64_t)8);
        mm_libmcl_genmc((int64_t)8,ix,mm_libmcl_genopnd((int64_t)2,(int64_t)8));
        mm_libmcl_genmc((int64_t)8,mm_libmcl_applyoffset(ix,(int64_t)8,(int64_t)0),mm_libmcl_genopndh((int64_t)2));
    }else if (((int64_t)((*p).catmode2)==(int64_t)28)) {
        ix = mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)4,(int64_t)0,(struct mm_decls_strec *)(0));
        fx = mm_libmcl_genopnd((int64_t)2,(int64_t)8);
        mm_libmcl_genmc((int64_t)13,ix,fx);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).catmode2),(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"popindex/catmode2",(struct mm_decls_unitrec *)(0));
    };
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
    if (((int64_t)((*p).opcode) == (int64_t)104)) {
        mm_libmcl_popopnd();
    };
}

static void mm_genmcl_pc_dotindex_i64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_pushalloperands();
    mm_genmcl_calldothandler((int64_t)5,(int64_t)2);
}

static void mm_genmcl_pc_dotslice(struct mm_libpcl_pclrec * p) {
    mm_libmcl_pushalloperands();
    mm_genmcl_calldothandler((int64_t)6,(int64_t)3);
}

static void mm_genmcl_pc_popdotindex_d8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_pushalloperands();
    mm_genmcl_callpopdothandler((int64_t)7,(int64_t)3);
}

static void mm_genmcl_pc_popdotslice_d8(struct mm_libpcl_pclrec * p) {
    mm_libmcl_pushalloperands();
    mm_genmcl_callpopdothandler((int64_t)8,(int64_t)4);
}

static void mm_genmcl_pc_dot_dotref_rec(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  fx;
    int64_t regp;
    int64_t offset;
    int64_t opc;
    offset = (*p).a.value;
    if ((((int64_t)((*p).opcode) == (int64_t)111) && ((int64_t)((uint64_t)((*p).catmode2)) == (int64_t)31))) {
        mm_libmcl_genmc_loadptr_d16(offset);
        return;
    };
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    ax = px;
    regp = (int64_t)((*px).reg);
    if (((int64_t)((*p).opcode) == (int64_t)111)) {
        if (((int64_t)((*p).catmode2)==(int64_t)29)) {
            mm_libmcl_genmc((int64_t)8,ax,mm_libmcl_genireg(regp,(int64_t)8,offset));
        }else if (((int64_t)((*p).catmode2)==(int64_t)27)) {
            px = mm_libmcl_genireg(regp,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]),offset);
            if (!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).mode2))]))) {
                opc = (int64_t)15;
            } else if (!!((uint64_t)(mm_decls_ttisword[((int64_t)((*p).mode2))]))) {
                opc = (int64_t)16;
            } else if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode2))]))) {
                fx = mm_libmcl_genxreg((int64_t)16,(int64_t)8);
                fx = mm_libmcl_genxreg((int64_t)16,(int64_t)8);
                mm_libmcl_genmc((int64_t)13,fx,px);
                mm_libmcl_genmc((int64_t)14,ax,fx);
                return;
            } else {
                opc = (int64_t)16;
            };
            mm_libmcl_genmc(opc,ax,px);
        }else if (((int64_t)((*p).catmode2)==(int64_t)30)) {
            mm_libmcl_newopnd_x8();
            fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
            mm_libmcl_genmc((int64_t)14,fx,mm_libmcl_genireg(regp,(int64_t)8,offset));
            mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
            mm_libmcl_popopnd();
        }else if (((int64_t)((*p).catmode2)==(int64_t)28)) {
            mm_libmcl_newopnd_x8();
            fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
            mm_libmcl_genmc((int64_t)13,fx,mm_libmcl_genireg(regp,(int64_t)4,offset));
            mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
            mm_libmcl_popopnd();
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).catmode2),(int64_t)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_gerror((uint8_t*)"dot/catmode2",(struct mm_decls_unitrec *)(0));
        };
    } else {
        mm_libmcl_genmc((int64_t)11,ax,mm_libmcl_genireg(regp,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]),offset));
    };
}

static void mm_genmcl_pc_popdot_storedot_rec(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  ax;
    int64_t regp;
    int64_t offset;
    mm_libmcl_getopnds((int64_t)2);
    offset = (*p).a.value;
    if (((int64_t)((uint64_t)((*p).catmode2)) == (int64_t)31)) {
        mm_libmcl_genmc_storeptr_d16(offset);
        mm_libmcl_popopnd();
        if (((int64_t)((*p).opcode) == (int64_t)112)) {
            mm_libmcl_popopnd();
        };
        return;
    };
    px = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    ax = px;
    regp = (int64_t)((*px).reg);
    if (((int64_t)((*p).catmode2)==(int64_t)29)) {
        px = mm_libmcl_genireg(regp,(int64_t)8,offset);
        mm_libmcl_genmc((int64_t)8,px,mm_libmcl_genopnd((int64_t)1,(int64_t)8));
    }else if (((int64_t)((*p).catmode2)==(int64_t)27)) {
        px = mm_libmcl_genireg(regp,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]),offset);
        mm_libmcl_genmc((int64_t)8,px,mm_libmcl_changeopndsize(mm_libmcl_genopnd((int64_t)1,(int64_t)8),(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))])));
    }else if (((int64_t)((*p).catmode2)==(int64_t)30)) {
        px = mm_libmcl_genireg(regp,(int64_t)8,offset);
        mm_libmcl_genmc((int64_t)14,px,mm_libmcl_genopnd((int64_t)1,(int64_t)8));
    }else if (((int64_t)((*p).catmode2)==(int64_t)28)) {
        px = mm_libmcl_genireg(regp,(int64_t)4,offset);
        mm_libmcl_genmc((int64_t)13,px,mm_libmcl_genopnd((int64_t)1,(int64_t)8));
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).catmode2),(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"popdot/catmode2",(struct mm_decls_unitrec *)(0));
    };
    mm_libmcl_popopnd();
    if (((int64_t)((*p).opcode) == (int64_t)112)) {
        mm_libmcl_popopnd();
    };
}

static void mm_genmcl_pc_lwb(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_lwb");
}

static void mm_genmcl_pc_upb(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_upb");
}

static void mm_genmcl_pc_upb_sx(struct mm_libpcl_pclrec * p) {
    int64_t lower;
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_freereg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]));
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
    lower = (int64_t)(mm_decls_ttlower[((int64_t)((*p).mode))]);
    if ((lower != (int64_t)1)) {
        mm_libmcl_genmc((int64_t)24,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((lower - (int64_t)1),(int64_t)8));
    };
}

static void mm_genmcl_pc_len_sx(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_freereg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]));
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
}

static void mm_genmcl_pc_lenstr_ref(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)70,(int64_t)1);
}

static void mm_genmcl_pc_bounds(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_bounds");
}

static void mm_genmcl_pc_sqrt_r64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)57,ax,ax);
}

static void mm_genmcl_pc_sqr_i64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)30,ax,ax);
}

static void mm_genmcl_pc_sqr_r64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)65,ax,ax);
}

static void mm_genmcl_pc_power_i64(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)9,(int64_t)2);
}

static void mm_genmcl_pc_power_r64(struct mm_libpcl_pclrec * p) {
    mm_genmcl_docmaths2((uint8_t*)"pow*");
}

static void mm_genmcl_pc_sign_i64_u64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  ax8;
    struct mm_mcldecls_opndrec *  bx;
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    bx = mm_libmcl_changeopndsize(mm_libmcl_gettempopnd_d8(),(int64_t)1);
    mm_libmcl_genmc((int64_t)38,ax,mm_libmcl_genint_mc((int64_t)0,(int64_t)8));
    ax8 = mm_libmcl_changeopndsize(ax,(int64_t)1);
    mm_libmcl_genmc_cond((int64_t)54,(int64_t)15,ax8,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc_cond((int64_t)54,(int64_t)12,bx,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)25,ax8,bx);
    mm_libmcl_genmc((int64_t)15,ax,ax8);
    mm_libmcl_freetempopnd_d8(bx);
}

static void mm_genmcl_pc_sign_r64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  fx;
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  ax64;
    mm_libmcl_getopnds((int64_t)1);
    fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    ax = mm_libmcl_changeopndsize((ax64 = mm_libmcl_gettempopnd_d8()),(int64_t)1);
    bx = mm_libmcl_changeopndsize(mm_libmcl_gettempopnd_d8(),(int64_t)1);
    if (!(!!(mm_libmcl_labzero))) {
        mm_libmcl_labzero = mm_libpcl_createfwdlabel();
    };
    mm_libmcl_genmc((int64_t)68,fx,mm_libmcl_genlabel_mem(mm_libmcl_labzero));
    mm_libmcl_genmc_cond((int64_t)54,(int64_t)7,ax,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc_cond((int64_t)54,(int64_t)2,bx,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)25,ax,bx);
    mm_libmcl_genmc((int64_t)15,ax64,ax);
    mm_libmcl_genmc((int64_t)80,fx,ax64);
    mm_libmcl_freetempopnd_d8(ax);
    mm_libmcl_freetempopnd_d8(bx);
}

static void mm_genmcl_pc_sin_cos_tan_asin_acos_atan_ln_log_exp_floor_ceil_r64(struct mm_libpcl_pclrec * p) {
    uint8_t str[32];
    uint8_t *  name;
    if (((int64_t)((*p).opcode)==(int64_t)142) || ((int64_t)((*p).opcode)==(int64_t)144)) {
        name = (uint8_t*)"log*";
    } else {
        name = str;
        strcpy((int8_t *)(name),(int8_t *)((mm_libpcl_pclnames[((int64_t)((*p).opcode))-1] + (int64_t)2)));
        strcat((int8_t *)(name),(int8_t *)((uint8_t*)"*"));
    };
    mm_genmcl_docmaths1(name);
}

static void mm_genmcl_pc_round(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_round");
}

static void mm_genmcl_pc_fract(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_fract");
}

static void mm_genmcl_pc_fmod(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_fmod");
}

static void mm_genmcl_pc_addto_subto_iandto_iorto_ixorto_i64_u64_ref(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    mm_libmcl_getopnds((int64_t)2);
    if (((int64_t)((*p).opcode)==(int64_t)154)) {
        opc = (int64_t)24;
    }else if (((int64_t)((*p).opcode)==(int64_t)155)) {
        opc = (int64_t)25;
    }else if (((int64_t)((*p).opcode)==(int64_t)160)) {
        opc = (int64_t)34;
    }else if (((int64_t)((*p).opcode)==(int64_t)161)) {
        opc = (int64_t)35;
    }else if (((int64_t)((*p).opcode)==(int64_t)162)) {
        opc = (int64_t)36;
    };
    mm_libmcl_genmc(opc,mm_libmcl_genopndind((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_addmemto_submemto_iandmemto_iormemto_ixormemto_i64_u64_ref(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    mm_libmcl_getopnds((int64_t)1);
    if (((int64_t)((*p).opcode)==(int64_t)175)) {
        opc = (int64_t)24;
    }else if (((int64_t)((*p).opcode)==(int64_t)176)) {
        opc = (int64_t)25;
    }else if (((int64_t)((*p).opcode)==(int64_t)177)) {
        opc = (int64_t)34;
    }else if (((int64_t)((*p).opcode)==(int64_t)178)) {
        opc = (int64_t)35;
    }else if (((int64_t)((*p).opcode)==(int64_t)179)) {
        opc = (int64_t)36;
    };
    mm_libmcl_genmc(opc,mm_libmcl_genmem_d_mc((*mm_genmcl_aa).def,(int64_t)0),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_addto_subto_iandto_iorto_ixorto_i32_i16_i8_u32_u16_u8_c16_c8(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    int64_t size;
    struct mm_mcldecls_opndrec *  px;
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_genopndind((int64_t)1,(int64_t)8);
    size = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    (*px).size = (uint64_t)(size);
    if (((int64_t)((*p).opcode)==(int64_t)154)) {
        opc = (int64_t)24;
    }else if (((int64_t)((*p).opcode)==(int64_t)155)) {
        opc = (int64_t)25;
    }else if (((int64_t)((*p).opcode)==(int64_t)160)) {
        opc = (int64_t)34;
    }else if (((int64_t)((*p).opcode)==(int64_t)161)) {
        opc = (int64_t)35;
    }else if (((int64_t)((*p).opcode)==(int64_t)162)) {
        opc = (int64_t)36;
    };
    mm_libmcl_genmc(opc,mm_libmcl_genopndind((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,size));
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_addto_multo_r64_r32(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    int64_t movopc;
    int64_t size;
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  ax;
    mm_libmcl_getopnds((int64_t)1);
    --mm_libmcl_noperands;
    mm_libmcl_getopnds((int64_t)1);
    ++mm_libmcl_noperands;
    if (((int64_t)((*p).mode) == (int64_t)12)) {
        movopc = (int64_t)14;
        size = (int64_t)8;
        if (((int64_t)((*p).opcode)==(int64_t)154)) {
            opc = (int64_t)63;
        }else if (((int64_t)((*p).opcode)==(int64_t)156)) {
            opc = (int64_t)65;
        };
    } else {
        movopc = (int64_t)13;
        size = (int64_t)4;
        if (((int64_t)((*p).opcode)==(int64_t)154)) {
            opc = (int64_t)59;
        }else if (((int64_t)((*p).opcode)==(int64_t)156)) {
            opc = (int64_t)61;
        };
    };
    px = mm_libmcl_genopndind((int64_t)1,size);
    ax = mm_libmcl_genopnd((int64_t)0,size);
    mm_libmcl_genmc(opc,ax,px);
    mm_libmcl_genmc(movopc,px,ax);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_subto_divto_r64_r32(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    int64_t movopc;
    int64_t size;
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    mm_libmcl_getopnds((int64_t)1);
    --mm_libmcl_noperands;
    mm_libmcl_getopnds((int64_t)1);
    ++mm_libmcl_noperands;
    if (((int64_t)((*p).mode) == (int64_t)12)) {
        movopc = (int64_t)14;
        size = (int64_t)8;
        if (((int64_t)((*p).opcode)==(int64_t)155)) {
            opc = (int64_t)64;
        }else if (((int64_t)((*p).opcode)==(int64_t)157)) {
            opc = (int64_t)66;
        };
    } else {
        movopc = (int64_t)13;
        size = (int64_t)4;
        if (((int64_t)((*p).opcode)==(int64_t)155)) {
            opc = (int64_t)60;
        }else if (((int64_t)((*p).opcode)==(int64_t)157)) {
            opc = (int64_t)62;
        };
    };
    px = mm_libmcl_genopndind((int64_t)1,size);
    bx = mm_libmcl_genopnd((int64_t)0,size);
    ax = mm_libmcl_gettempopnd_x8();
    mm_libmcl_genmc(movopc,ax,px);
    mm_libmcl_genmc(opc,ax,bx);
    mm_libmcl_genmc(movopc,px,ax);
    mm_libmcl_freetempopnd_x8(ax);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_multo_i64_u64_i32_u32_i16_u16_i8_u8(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  ax;
    int64_t size;
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_genopndind((int64_t)1,(int64_t)8);
    size = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    (*px).size = (uint64_t)(size);
    ax = mm_libmcl_genopnd((int64_t)0,size);
    mm_libmcl_genmc((int64_t)30,ax,px);
    mm_libmcl_genmc((int64_t)8,px,ax);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_idivto_iremto_i64_u64(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  dx;
    mm_libmcl_getopnds((int64_t)2);
    mm_genmcl_fixdivopnds_d8();
    ax = mm_libmcl_genreg((int64_t)1,(int64_t)8);
    bx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)23,ax,mm_libmcl_genreg((int64_t)14,(int64_t)8));
    px = mm_libmcl_genireg((int64_t)14,(int64_t)8,(int64_t)0);
    dx = mm_libmcl_genreg((int64_t)12,(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,px);
    if (((int64_t)((uint64_t)((*p).catmode)) == (int64_t)4)) {
        mm_libmcl_genmc((int64_t)53,(struct mm_mcldecls_opndrec *)(0),(struct mm_mcldecls_opndrec *)(0));
        opc = (int64_t)32;
    } else {
        mm_libmcl_genmc((int64_t)36,dx,dx);
        opc = (int64_t)33;
    };
    mm_libmcl_genmc(opc,bx,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)8,px,(((int64_t)((*p).opcode) == (int64_t)158)?ax:dx));
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_shlto_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_genmcl_doshiftnto(p,(int64_t)39);
}

static void mm_genmcl_pc_shlcto_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)39,mm_libmcl_genopndind((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((*mm_genmcl_aa).value,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_shrcto_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((((int64_t)((uint64_t)((*p).catmode)) == (int64_t)4)?(int64_t)40:(int64_t)41),mm_libmcl_genopndind((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((*mm_genmcl_aa).value,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_shlcmemto_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)39,mm_libmcl_genmem_d_mc((*mm_genmcl_aa).def,(int64_t)0),mm_libmcl_genint_mc((*mm_genmcl_bb).value,(int64_t)8));
}

static void mm_genmcl_pc_shrcmemto_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((((int64_t)((uint64_t)((*p).catmode)) == (int64_t)4)?(int64_t)40:(int64_t)41),mm_libmcl_genmem_d_mc((*mm_genmcl_aa).def,(int64_t)0),mm_libmcl_genint_mc((*mm_genmcl_bb).value,(int64_t)8));
}

static void mm_genmcl_pc_shrto_i64(struct mm_libpcl_pclrec * p) {
    mm_genmcl_doshiftnto(p,(int64_t)40);
}

static void mm_genmcl_pc_shrto_u64(struct mm_libpcl_pclrec * p) {
    mm_genmcl_doshiftnto(p,(int64_t)41);
}

static void mm_genmcl_pc_minto(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_minto");
}

static void mm_genmcl_pc_minto_maxto_i64_u64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  lx;
    int64_t cond;
    int64_t lab;
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_genopndind((int64_t)1,(int64_t)8);
    bx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    if (((int64_t)((*p).opcode) == (int64_t)167)) {
        cond = (((int64_t)((uint64_t)((*p).catmode)) == (int64_t)4)?(int64_t)14:(int64_t)6);
    } else {
        cond = (((int64_t)((uint64_t)((*p).catmode)) == (int64_t)4)?(int64_t)13:(int64_t)3);
    };
    mm_libmcl_genmc((int64_t)38,px,bx);
    lab = ++mm_decls_labelno;
    mm_libmcl_genmc_cond((int64_t)22,cond,(lx = mm_libmcl_genlabel_mc(lab)),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)8,px,bx);
    mm_libmcl_genmc((int64_t)5,lx,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_minto_maxto_r64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  fx;
    struct mm_mcldecls_opndrec *  gx;
    mm_libmcl_getopnds((int64_t)1);
    --mm_libmcl_noperands;
    mm_libmcl_getopnds((int64_t)1);
    ++mm_libmcl_noperands;
    px = mm_libmcl_genopndind((int64_t)1,(int64_t)8);
    gx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    fx = mm_libmcl_gettempopnd_x8();
    mm_libmcl_genmc((int64_t)14,fx,px);
    mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)167)?(int64_t)107:(int64_t)108),fx,gx);
    mm_libmcl_genmc((int64_t)14,px,fx);
    mm_libmcl_freetempopnd_x8(fx);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_maxto(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_maxto");
}

static void mm_genmcl_pc_addoffsetto_suboffsetto_ref(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  ax;
    int64_t size;
    int64_t n;
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_genopndind((int64_t)1,(int64_t)8);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    size = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*p).mode))]))]);
    if ((size == (int64_t)1)) {
    } else if (!!((n = mm_lib_ispoweroftwo(size)))) {
        mm_libmcl_genmc((int64_t)39,ax,mm_libmcl_genint_mc(n,(int64_t)8));
    } else {
        mm_libmcl_genmc((int64_t)30,ax,mm_libmcl_genint_mc(size,(int64_t)8));
    };
    mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)169)?(int64_t)24:(int64_t)25),px,ax);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_concatto(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_concatto");
}

static void mm_genmcl_pc_appendto(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_appendto");
}

static void mm_genmcl_pc_negto_inotto_i64_u64(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)182)?(int64_t)46:(int64_t)47),mm_libmcl_genopndind((int64_t)0,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_negto_r64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    (*px).offset += (int32_t)7;
    mm_libmcl_genmc((int64_t)36,px,mm_libmcl_genint_mc((int64_t)128,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_absto_i64_u64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  lx;
    int64_t lab;
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_genmc((int64_t)38,(px = mm_libmcl_genopndind((int64_t)0,(int64_t)8)),mm_libmcl_genint_mc((int64_t)0,(int64_t)8));
    lab = ++mm_decls_labelno;
    mm_libmcl_genmc_cond((int64_t)22,(int64_t)13,(lx = mm_libmcl_genlabel_mc(lab)),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)46,px,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,lx,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_absto_r32_r64(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    (*px).offset += (int32_t)(((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) - (int64_t)1));
    mm_libmcl_genmc((int64_t)34,px,mm_libmcl_genint_mc((int64_t)127,(int64_t)8));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_incrtomem_d8_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)48,mm_libmcl_genmem_d_mc((*mm_genmcl_aa).def,(int64_t)0),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_decrtomem_d8_d124(struct mm_libpcl_pclrec * p) {
    mm_libmcl_genmc((int64_t)49,mm_libmcl_genmem_d_mc((*mm_genmcl_aa).def,(int64_t)0),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_incrtomem_decrtomem_ref(struct mm_libpcl_pclrec * p) {
    int64_t size;
    if (((size = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*p).mode))]))])) == (int64_t)1)) {
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)186)?(int64_t)48:(int64_t)49),mm_libmcl_genmem_d_mc((*mm_genmcl_aa).def,(int64_t)0),(struct mm_mcldecls_opndrec *)(0));
    } else {
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)186)?(int64_t)24:(int64_t)25),mm_libmcl_genmem_d_mc((*mm_genmcl_aa).def,(int64_t)0),mm_libmcl_genint_mc(size,(int64_t)8));
    };
}

static void mm_genmcl_pc_incrtomem_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmemaddr((*mm_genmcl_aa).def);
    mm_genmcl_call64handler_p((int64_t)151,(int64_t)1);
}

static void mm_genmcl_pc_decrtomem_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadmemaddr((*mm_genmcl_aa).def);
    mm_genmcl_call64handler_p((int64_t)152,(int64_t)1);
}

static void mm_genmcl_pc_incrto_decrto_d8_d124(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    (*px).size = (uint64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)188)?(int64_t)48:(int64_t)49),px,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_incrto_decrto_ref(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    int64_t size;
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    size = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*p).mode))]))]);
    if ((size == (int64_t)1)) {
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)188)?(int64_t)48:(int64_t)49),px,(struct mm_mcldecls_opndrec *)(0));
    } else {
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)188)?(int64_t)24:(int64_t)25),px,mm_libmcl_genint_mc(size,(int64_t)8));
    };
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_incrto_decrto_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_genmcl_call64handler_p((((int64_t)((*p).opcode) == (int64_t)188)?(int64_t)151:(int64_t)152),(int64_t)1);
}

static void mm_genmcl_pc_preincrtox_predecrtox_d8_d124(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  px;
    int64_t size;
    size = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    (*px).size = (uint64_t)(size);
    mm_libmcl_newopnd_d8();
    bx = mm_libmcl_genopnd((int64_t)0,size);
    mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)190)?(int64_t)48:(int64_t)49),px,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)8,bx,px);
    mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_postincrtox_postdecrtox_d8_d124(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  px;
    int64_t size;
    size = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    (*px).size = (uint64_t)(size);
    mm_libmcl_newopnd_d8();
    ax = mm_libmcl_genopnd((int64_t)0,size);
    mm_libmcl_genmc((int64_t)8,ax,px);
    mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)192)?(int64_t)48:(int64_t)49),px,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_preincrtox_predecrtox_ref(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  px;
    int64_t size;
    size = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*p).mode))]))]);
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    if ((size == (int64_t)1)) {
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)190)?(int64_t)48:(int64_t)49),px,(struct mm_mcldecls_opndrec *)(0));
    } else {
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)190)?(int64_t)24:(int64_t)25),px,mm_libmcl_genint_mc(size,(int64_t)8));
    };
    mm_libmcl_genmc((int64_t)8,ax,mm_libmcl_changeopndsize(px,(int64_t)8));
}

static void mm_genmcl_pc_postincrtox_postdecrtox_ref(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  px;
    int64_t size;
    size = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*p).mode))]))]);
    mm_libmcl_getopnds((int64_t)1);
    px = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    mm_libmcl_newopnd_d8();
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,mm_libmcl_changeopndsize(px,(int64_t)8));
    if ((size == (int64_t)1)) {
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)192)?(int64_t)48:(int64_t)49),px,(struct mm_mcldecls_opndrec *)(0));
    } else {
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)192)?(int64_t)24:(int64_t)25),px,mm_libmcl_genint_mc(size,(int64_t)8));
    };
    mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_preincrtox_predecrtox_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_dupltop();
    mm_genmcl_call64handler_p((((int64_t)((*p).opcode) == (int64_t)190)?(int64_t)151:(int64_t)152),(int64_t)1);
    (*mm_genmcl_aa).value = (int64_t)0;
    mm_genmcl_pc_pushptr_var(p);
}

static void mm_genmcl_pc_postincrtox_postdecrtox_var(struct mm_libpcl_pclrec * p) {
    mm_libmcl_dupltop();
    (*mm_genmcl_aa).value = (int64_t)0;
    mm_genmcl_pc_pushptr_var(p);
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
    mm_genmcl_call64handler_p((((int64_t)((*p).opcode) == (int64_t)192)?(int64_t)151:(int64_t)152),(int64_t)1);
}

static void mm_genmcl_pc_uwiden_iwiden(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  ax2;
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  lx;
    int64_t oldsize;
    int64_t newsize;
    int64_t reg2;
    int64_t lab;
    mm_libmcl_getopnds((int64_t)1);
    oldsize = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    newsize = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    if ((oldsize < (int64_t)8)) {
        bx = mm_libmcl_changeopndsize(ax,oldsize);
        mm_libmcl_genmc((((int64_t)((*p).opcode) == (int64_t)196)?(int64_t)16:(int64_t)15),ax,bx);
    };
    if ((newsize == (int64_t)16)) {
        reg2 = mm_libmcl_getnextreg();
        ax2 = mm_libmcl_genreg(reg2,(int64_t)8);
        mm_libmcl_genmc((int64_t)36,ax2,ax2);
        if (!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).mode2))]))) {
            lab = ++mm_decls_labelno;
            mm_libmcl_genmc((int64_t)38,ax,mm_libmcl_genint_mc((int64_t)0,(int64_t)8));
            mm_libmcl_genmc_cond((int64_t)22,(int64_t)13,(lx = mm_libmcl_genlabel_mc(lab)),(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_genmc((int64_t)47,ax2,(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_genmc((int64_t)5,lx,(struct mm_mcldecls_opndrec *)(0));
        };
        mm_libmcl_opndreg2[(mm_libmcl_noperands)-1] = (uint64_t)(reg2);
        mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)87u;
    };
}

static void mm_genmcl_pc_ifix(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  fx;
    mm_libmcl_getopnds((int64_t)1);
    fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_newopnd_d8();
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) == (int64_t)4)?(int64_t)77:(int64_t)78),ax,fx);
    mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_ifloat(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  fx;
    int64_t isize;
    isize = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    if ((isize != (int64_t)8)) {
        mm_libmcl_genmc((int64_t)15,ax,mm_libmcl_changeopndsize(ax,isize));
    };
    mm_libmcl_newopnd_x8();
    fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))]) == (int64_t)4)?(int64_t)79:(int64_t)80),fx,ax);
    mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_fwiden(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  fx;
    mm_libmcl_getopnds((int64_t)1);
    fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)82,fx,fx);
}

static void mm_genmcl_pc_fnarrow(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  fx;
    mm_libmcl_getopnds((int64_t)1);
    fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)81,fx,fx);
}

static void mm_genmcl_pc_softtruncate(struct mm_libpcl_pclrec * p) {
    if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) == (int64_t)16)) {
        mm_libmcl_getopnds((int64_t)1);
        mm_libmcl_freereg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]));
        mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
    };
}

static void mm_genmcl_pc_truncate(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    mm_libmcl_getopnds((int64_t)1);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))])==(int64_t)1)) {
        mm_libmcl_genmc((int64_t)34,ax,mm_libmcl_genint_mc((int64_t)255,(int64_t)8));
    }else if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))])==(int64_t)2)) {
        mm_libmcl_genmc((int64_t)34,ax,mm_libmcl_genint_mc((int64_t)65535,(int64_t)8));
    }else if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode2))])==(int64_t)4)) {
        mm_libmcl_genmc((int64_t)8,ax,ax);
    };
}

static void mm_genmcl_pc_typepun(struct mm_libpcl_pclrec * p) {
    int64_t s;
    int64_t t;
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  fx;
    s = (int64_t)((*p).mode);
    t = (int64_t)((*p).mode2);
    if ((((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) == (uint64_t)87u) && ((int64_t)(mm_decls_ttsize[(t)]) <= (int64_t)8))) {
        mm_libmcl_getopnds((int64_t)1);
        mm_libmcl_freereg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]));
        mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
        s = (int64_t)4;
    };
    if ((!!((uint64_t)(mm_decls_ttisreal[(s)])) && !!((uint64_t)(mm_decls_ttisinteger[(t)])))) {
        mm_libmcl_getopnds((int64_t)1);
        fx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
        ax = mm_libmcl_gettempopnd_d8();
        mm_libmcl_genmc((int64_t)14,ax,fx);
        mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((*ax).reg);
        mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
        mm_libmcl_freetempopnd_x8(fx);
    } else if ((!!((uint64_t)(mm_decls_ttisinteger[(s)])) && !!((uint64_t)(mm_decls_ttisreal[(t)])))) {
        mm_libmcl_getopnds((int64_t)1);
        ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
        fx = mm_libmcl_gettempopnd_x8();
        mm_libmcl_genmc((int64_t)14,fx,ax);
        mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((*fx).reg);
        mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)70u;
        mm_libmcl_freetempopnd_d8(ax);
    } else if (((!!((uint64_t)(mm_decls_ttisinteger[(s)])) || !!((uint64_t)(mm_decls_ttisref[(s)]))) && (!!((uint64_t)(mm_decls_ttisinteger[(t)])) || !!((uint64_t)(mm_decls_ttisref[(t)]))))) {
    } else if ((!!((uint64_t)(mm_decls_ttisvar[(s)])) && !!((uint64_t)(mm_decls_ttisref[(t)])))) {
    } else if ((!!((uint64_t)(mm_decls_ttisref[(s)])) && !!((uint64_t)(mm_decls_ttisvar[(t)])))) {
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"STRMODE(S)=",NULL);
        msysnewc_m_print_str(mm_lib_strmode(s,(int64_t)1),NULL);
        msysnewc_m_print_str((uint8_t*)"STRMODE(T)=",NULL);
        msysnewc_m_print_str(mm_lib_strmode(t,(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"TTISREF[S]=",NULL);
        msysnewc_m_print_u64(mm_decls_ttisref[(s)],NULL);
        msysnewc_m_print_str((uint8_t*)"TTISVAR[T]=",NULL);
        msysnewc_m_print_u64(mm_decls_ttisvar[(t)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"TYPEPUN",(struct mm_decls_unitrec *)(0));
        mm_genmcl_unimpl((uint8_t*)"typepun");
    };
}

static void mm_genmcl_pc_box(struct mm_libpcl_pclrec * p) {
    int64_t m;
    m = (int64_t)((*p).mode);
    if (((int64_t)((*p).mode)==(int64_t)4)) {
        mm_genmcl_call64handler_f((int64_t)171,(int64_t)1);
    }else if (((int64_t)((*p).mode)==mm_tables_trefchar)) {
        mm_genmcl_call64handler_f((int64_t)173,(int64_t)1);
    }else if (((int64_t)((*p).mode)==(int64_t)12)) {
        mm_genmcl_call64handler_f((int64_t)172,(int64_t)1);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"SOURCE MODE",NULL);
        msysnewc_m_print_str(mm_lib_strmode(m,(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"BOX",(struct mm_decls_unitrec *)(0));
    };
}

static void mm_genmcl_pc_unbox(struct mm_libpcl_pclrec * p) {
    int64_t fn;
    if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode2))])==(int64_t)4)) {
        fn = (int64_t)179;
    }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode2))])==(int64_t)12)) {
        fn = (int64_t)180;
    } else {
        if (((int64_t)((*p).mode2) == mm_tables_trefchar)) {
            fn = (int64_t)181;
        } else {
            mm_support_gerror((uint8_t*)"PC/UNBOX",(struct mm_decls_unitrec *)(0));
        };
    };
    mm_genmcl_call64handler_f(fn,(int64_t)1);
    if ((fn == (int64_t)180)) {
        if (((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) == (int64_t)0)) {
            mm_support_gerror((uint8_t*)"unbox/??",(struct mm_decls_unitrec *)(0));
        };
        mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)1);
        mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)70u;
        mm_libmcl_regset[((int64_t)1)-1] = (uint64_t)((int64_t)0);
        mm_libmcl_xregset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
    };
}

static void mm_genmcl_pc_swap_d8(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  cx;
    struct mm_mcldecls_opndrec *  dx;
    mm_libmcl_getopnds((int64_t)2);
    ax = mm_libmcl_genopndind((int64_t)1,(int64_t)8);
    bx = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    cx = mm_libmcl_gettempopnd_d8();
    dx = mm_libmcl_gettempopnd_d8();
    mm_libmcl_genmc((int64_t)8,cx,ax);
    mm_libmcl_genmc((int64_t)8,dx,bx);
    mm_libmcl_genmc((int64_t)8,ax,dx);
    mm_libmcl_genmc((int64_t)8,bx,cx);
    mm_libmcl_freetempopnd_d8(cx);
    mm_libmcl_freetempopnd_d8(dx);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_swap_d124(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  qx;
    struct mm_mcldecls_opndrec *  cx;
    struct mm_mcldecls_opndrec *  dx;
    int64_t size;
    size = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_changeopndsize(mm_libmcl_genopndind((int64_t)1,(int64_t)8),size);
    qx = mm_libmcl_changeopndsize(mm_libmcl_genopndind((int64_t)0,(int64_t)8),size);
    cx = mm_libmcl_changeopndsize(mm_libmcl_gettempopnd_d8(),size);
    dx = mm_libmcl_changeopndsize(mm_libmcl_gettempopnd_d8(),size);
    mm_libmcl_genmc((int64_t)8,cx,px);
    mm_libmcl_genmc((int64_t)8,dx,qx);
    mm_libmcl_genmc((int64_t)8,px,dx);
    mm_libmcl_genmc((int64_t)8,qx,cx);
    mm_libmcl_freetempopnd_d8(cx);
    mm_libmcl_freetempopnd_d8(dx);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_makerange(struct mm_libpcl_pclrec * p) {
    mm_genmcl_call64handler_f((int64_t)178,(int64_t)2);
}

static void mm_genmcl_pc_makelist_var(struct mm_libpcl_pclrec * p) {
    int64_t n;
    n = (*mm_genmcl_aa).value;
    if ((n == (int64_t)0)) {
        mm_libmcl_newopnd_d8();
        mm_libmcl_genmc_loadint_d8((*mm_genmcl_bb).value);
        mm_genmcl_call64handler_f((int64_t)176,(int64_t)1);
        return;
    };
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadint_d8((*mm_genmcl_bb).value);
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc_loadint_d8((*mm_genmcl_aa).value);
    mm_libmcl_pushalloperands();
    mm_genmcl_call64handler_f((int64_t)175,(n + (int64_t)2));
}

static void mm_genmcl_pc_makeslice(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)2);
    mm_libmcl_opndreg2[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)87u;
    --mm_libmcl_noperands;
}

static void mm_genmcl_pc_slicelen_sliceupb(struct mm_libpcl_pclrec * p) {
    int64_t lower;
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_freereg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]));
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
    lower = (int64_t)(mm_decls_ttlower[((int64_t)((*p).mode))]);
    if ((lower != (int64_t)1)) {
        mm_libmcl_genmc((int64_t)24,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genint_mc((lower - (int64_t)1),(int64_t)8));
    };
}

static void mm_genmcl_pc_sliceptr(struct mm_libpcl_pclrec * p) {
    mm_libmcl_getopnds((int64_t)1);
    mm_libmcl_freereg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]));
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
}

static void mm_genmcl_pc_slice_ax(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ix;
    struct mm_mcldecls_opndrec *  jx;
    struct mm_mcldecls_opndrec *  ax;
    int64_t amode;
    int64_t rega;
    int64_t regi;
    int64_t scale;
    int64_t elemmode;
    int64_t lower;
    int64_t offset;
    int64_t elemsize;
    int64_t n;
    mm_libmcl_getopnds((int64_t)3);
    ix = mm_libmcl_genopnd((int64_t)2,(int64_t)8);
    jx = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    ax = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)25,jx,ix);
    mm_libmcl_genmc((int64_t)48,jx,(struct mm_mcldecls_opndrec *)(0));
    rega = (int64_t)((*ax).reg);
    regi = (int64_t)((*ix).reg);
    amode = (int64_t)((*p).mode);
    elemmode = (int64_t)(mm_decls_tttarget[(amode)]);
    scale = (elemsize = (int64_t)(mm_decls_ttsize[(elemmode)]));
    lower = (int64_t)(mm_decls_ttlower[(amode)]);
    offset = (-(lower) * elemsize);
    if (!(((scale == (int64_t)1) || (scale == (int64_t)2) || (scale == (int64_t)4) || (scale == (int64_t)8)))) {
        if (!!((n = mm_lib_ispoweroftwo(scale)))) {
            mm_libmcl_genmc((int64_t)39,ix,mm_libmcl_genint_mc(n,(int64_t)8));
        } else {
            mm_libmcl_genmc((int64_t)30,ix,mm_libmcl_genint_mc(elemsize,(int64_t)8));
        };
        scale = (int64_t)1;
    };
    mm_libmcl_genmc((int64_t)11,ix,mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)0,(int64_t)0,(struct mm_decls_strec *)(0)));
    mm_libmcl_popopnd();
    mm_libmcl_opndreg2[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)87u;
    --mm_libmcl_noperands;
}

static void mm_genmcl_pc_slice_ref(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ix;
    struct mm_mcldecls_opndrec *  jx;
    struct mm_mcldecls_opndrec *  sx;
    int64_t rega;
    int64_t regi;
    mm_libmcl_getopnds((int64_t)3);
    ix = mm_libmcl_genopnd((int64_t)2,(int64_t)8);
    jx = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    sx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    mm_libmcl_genmc((int64_t)25,jx,ix);
    mm_libmcl_genmc((int64_t)48,jx,(struct mm_mcldecls_opndrec *)(0));
    rega = (int64_t)((*sx).reg);
    regi = (int64_t)((*ix).reg);
    mm_libmcl_genmc((int64_t)11,ix,mm_libmcl_genindex(rega,regi,(int64_t)1,(int64_t)-1,(int64_t)0,(int64_t)0,(struct mm_decls_strec *)(0)));
    mm_libmcl_popopnd();
    mm_libmcl_opndreg2[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    mm_libmcl_opndkind[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)87u;
    --mm_libmcl_noperands;
}

static void mm_genmcl_pc_slice_sx(struct mm_libpcl_pclrec * p) {
    struct mm_mcldecls_opndrec *  ix;
    struct mm_mcldecls_opndrec *  jx;
    struct mm_mcldecls_opndrec *  sx;
    struct mm_mcldecls_opndrec *  sxh;
    int64_t amode;
    int64_t rega;
    int64_t regi;
    int64_t scale;
    int64_t elemmode;
    int64_t lower;
    int64_t offset;
    int64_t elemsize;
    int64_t n;
    mm_libmcl_getopnds((int64_t)3);
    ix = mm_libmcl_genopnd((int64_t)2,(int64_t)8);
    jx = mm_libmcl_genopnd((int64_t)1,(int64_t)8);
    sx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    sxh = mm_libmcl_genopndh((int64_t)0);
    mm_libmcl_genmc((int64_t)25,jx,ix);
    mm_libmcl_genmc((int64_t)48,jx,(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)8,sxh,jx);
    rega = (int64_t)((*sx).reg);
    regi = (int64_t)((*ix).reg);
    amode = (int64_t)((*p).mode);
    elemmode = (int64_t)(mm_decls_tttarget[(amode)]);
    scale = (elemsize = (int64_t)(mm_decls_ttsize[(elemmode)]));
    lower = (int64_t)(mm_decls_ttlower[(amode)]);
    offset = (-(lower) * elemsize);
    if (!(((scale == (int64_t)1) || (scale == (int64_t)2) || (scale == (int64_t)4) || (scale == (int64_t)8)))) {
        if (!!((n = mm_lib_ispoweroftwo(scale)))) {
            mm_libmcl_genmc((int64_t)39,ix,mm_libmcl_genint_mc(n,(int64_t)8));
        } else {
            mm_libmcl_genmc((int64_t)30,ix,mm_libmcl_genint_mc(elemsize,(int64_t)8));
        };
        scale = (int64_t)1;
    };
    mm_libmcl_genmc((int64_t)11,sx,mm_libmcl_genindex(rega,regi,scale,offset,(int64_t)0,(int64_t)0,(struct mm_decls_strec *)(0)));
    mm_libmcl_swapopnds((int64_t)1,(int64_t)3);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_assem(struct mm_libpcl_pclrec * p) {
    struct mm_decls_unitrec *  pcode;
    pcode = (*p).a.code;
    mm_libmcl_genmc((int64_t)((*pcode).opcode),mm_genmcl_genasmopnd((*pcode).a),mm_genmcl_genasmopnd((*pcode).b));
    (*mm_libmcl_mccodex).cond = (uint64_t)((*pcode).cond);
    if (((int64_t)((*pcode).opcode)==(int64_t)85) || ((int64_t)((*pcode).opcode)==(int64_t)86)) {
        if ((((*pcode).c == 0) || ((int64_t)((*(*pcode).c).tag) != (int64_t)1))) {
            mm_support_gerror((uint8_t*)"pcmpistr/no imm",(struct mm_decls_unitrec *)(0));
        };
        (*mm_libmcl_mccodex).c = (uint64_t)((*(*pcode).c).value);
    };
    (*mm_libmcl_mccodex).cond = (uint64_t)((*pcode).cond);
}

static void mm_genmcl_pc_assem_d8(struct mm_libpcl_pclrec * p) {
    struct mm_decls_unitrec *  pcode;
    mm_libmcl_newopnd_d8();
    pcode = (*p).a.code;
    mm_libmcl_genmc((int64_t)((*pcode).opcode),mm_genmcl_genasmopnd((*pcode).a),mm_genmcl_genasmopnd((*pcode).b));
    (*mm_libmcl_mccodex).cond = (uint64_t)((*pcode).cond);
}

static struct mm_mcldecls_opndrec * mm_genmcl_genasmopnd(struct mm_decls_unitrec * p) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_decls_strec *  d;
    int64_t offset;
    int64_t labno;
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  x;
    struct mm_decls_unitrec *  y;
    if ((p == 0)) {
        return (struct mm_mcldecls_opndrec *)(0);
    };
    if (((int64_t)((*p).tag)==(int64_t)9)) {
        ax = mm_libmcl_genreg((int64_t)((*p).reg),(int64_t)((*p).regsize));
    }else if (((int64_t)((*p).tag)==(int64_t)1)) {
        ax = mm_libmcl_genint_mc((*p).value,(int64_t)8);
    }else if (((int64_t)((*p).tag)==(int64_t)11)) {
        a = (*p).a;
        d = (struct mm_decls_strec *)(0);
        offset = (labno = (int64_t)0);
        if (!!(a)) {
            if (((int64_t)((*a).tag)==(int64_t)1)) {
                offset = (*a).value;
            }else if (((int64_t)((*a).tag)==(int64_t)3)) {
                d = (*a).def;
                if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)15)) {
                    if (((int64_t)((*d).index) == (int64_t)0)) {
                        (*d).index = ++mm_decls_labelno;
                    };
                    labno = (int64_t)((*d).index);
                    d = (struct mm_decls_strec *)(0);
                };
            }else if (((int64_t)((*a).tag)==(int64_t)43) || ((int64_t)((*a).tag)==(int64_t)44)) {
                x = (*a).a;
                y = (*a).b;
                if ((((int64_t)((*x).tag) == (int64_t)3) && ((int64_t)((*y).tag) == (int64_t)1))) {
                    d = (*x).def;
                    if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)15)) {
                        if (((int64_t)((*d).index) == (int64_t)0)) {
                            (*d).index = ++mm_decls_labelno;
                        };
                        labno = (int64_t)((*d).index);
                        d = (struct mm_decls_strec *)(0);
                    };
                } else {
                    goto L727 ;
;
                };
                offset = (((int64_t)((*a).tag) == (int64_t)43)?(*y).value:-((*y).value));
            }else if (((int64_t)((*a).tag)==(int64_t)109)) {
                if (!(((int64_t)((*(*a).a).tag) == (int64_t)1))) {
                    mm_support_gerror((uint8_t*)"-name",(struct mm_decls_unitrec *)(0));
                };
                offset = -((*(*a).a).value);
            }else if (((int64_t)((*a).tag)==(int64_t)204)) {
                labno = mm_libmcl_getsysfnlabel((int64_t)((*a).opcode));
            } else {
                //error:
L727 :;
;
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*a).tag))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                mm_support_gerror((uint8_t*)"Can't do memexpr",(struct mm_decls_unitrec *)(0));
            };
        };
        ax = mm_libmcl_genindex((int64_t)((*p).reg),(int64_t)((*p).regix),(int64_t)((*p).scale),offset,(int64_t)(mm_decls_ttsize[((int64_t)((*p).prefixmode))]),labno,d);
    }else if (((int64_t)((*p).tag)==(int64_t)3)) {
        d = (*p).def;
        if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)15)) {
            if (((int64_t)((*d).index) == (int64_t)0)) {
                (*d).index = ++mm_decls_labelno;
            };
            ax = mm_libmcl_genlabel_mc((int64_t)((*d).index));
        } else {
            ax = mm_libmcl_genmemaddr_u_mc(p);
        };
    }else if (((int64_t)((*p).tag)==(int64_t)10)) {
        ax = mm_libmcl_genxreg((int64_t)((*p).reg),(int64_t)8);
    }else if (((int64_t)((*p).tag)==(int64_t)43) || ((int64_t)((*p).tag)==(int64_t)44)) {
        x = (*p).a;
        y = (*p).b;
        if ((((int64_t)((*x).tag) == (int64_t)3) && ((int64_t)((*y).tag) == (int64_t)1))) {
            d = (*x).def;
            offset = (((int64_t)((*p).tag) == (int64_t)43)?(*y).value:-((*y).value));
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)15)) {
                if (((int64_t)((*d).index) == (int64_t)0)) {
                    (*d).index = ++mm_decls_labelno;
                };
                ax = mm_libmcl_genlabel_mc((int64_t)((*d).index));
            } else {
                ax = mm_libmcl_genmemaddr_d_mc(d);
            };
            (*ax).offset = offset;
        } else {
            mm_support_gerror((uint8_t*)"ax:imm/add",(struct mm_decls_unitrec *)(0));
        };
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"genasmopnd?",(struct mm_decls_unitrec *)(0));
    };
    return ax;
}

static void mm_genmcl_pc_db_dw_dd_dq(struct mm_libpcl_pclrec * p) {
    int64_t opc;
    struct mm_mcldecls_opndrec *  ax;
    if (((int64_t)((*p).opcode)==(int64_t)222)) {
        opc = (int64_t)109;
    }else if (((int64_t)((*p).opcode)==(int64_t)223)) {
        opc = (int64_t)110;
    }else if (((int64_t)((*p).opcode)==(int64_t)224)) {
        opc = (int64_t)111;
    }else if (((int64_t)((*p).opcode)==(int64_t)225)) {
        opc = (int64_t)112;
    };
    if (((int64_t)((*p).a.optype)==(int64_t)3)) {
        ax = mm_libmcl_genint_mc((*p).a.value,(int64_t)8);
    }else if (((int64_t)((*p).a.optype)==(int64_t)5)) {
        ax = mm_libmcl_genrealimm_mc((*p).a.xvalue,(int64_t)((*p).a.size));
    }else if (((int64_t)((*p).a.optype)==(int64_t)6)) {
        ax = mm_libmcl_genlabel_mc(mm_libmcl_getstringindex((*mm_genmcl_aa).svalue,(int64_t)(strlen((int8_t *)((*mm_genmcl_aa).svalue)))));
    }else if (((int64_t)((*p).a.optype)==(int64_t)2)) {
        ax = mm_libmcl_genmemaddr_d_mc((*p).a.def);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_libpcl_opndnames[((int64_t)((*p).a.optype))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_gerror((uint8_t*)"db/dq optype?",(struct mm_decls_unitrec *)(0));
    };
    mm_libmcl_genmc(opc,ax,(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_pc_resb(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_resb");
}

static void mm_genmcl_pc_resw(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_resw");
}

static void mm_genmcl_pc_resd(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_resd");
}

static void mm_genmcl_pc_resq(struct mm_libpcl_pclrec * p) {
    mm_genmcl_unimpl((uint8_t*)"k_resq");
}

static void mm_genmcl_pc_copyblock(struct mm_libpcl_pclrec * p) {
    int64_t n;
    int64_t nwords;
    int64_t lab;
    int64_t oddbytes;
    int64_t offset;
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  rx;
    struct mm_mcldecls_opndrec *  rcount;
    int64_t av_1;
    n = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
    mm_libmcl_getopnds((int64_t)2);
    ax = mm_libmcl_genopndind((int64_t)1,(int64_t)8);
    bx = mm_libmcl_genopndind((int64_t)0,(int64_t)8);
    offset = (int64_t)0;
    oddbytes = (n % (int64_t)8);
    n -= oddbytes;
    nwords = (n / (int64_t)8);
    rx = mm_libmcl_gettempopnd_d8();
    rcount = mm_libmcl_gettempopnd_d8();
    if ((((int64_t)1 <= nwords) && (nwords <= (int64_t)4))) {
        offset = (int64_t)0;
        ax = mm_libmcl_changeopndsize(ax,mm_decls_targetsize);
        bx = mm_libmcl_changeopndsize(bx,mm_decls_targetsize);
        av_1 = nwords;
        while (av_1-- > 0) {
L728 :;
            mm_libmcl_genmc((int64_t)8,rx,mm_libmcl_applyoffset(bx,offset,(int64_t)0));
            mm_libmcl_genmc((int64_t)8,mm_libmcl_applyoffset(ax,offset,(int64_t)0),rx);
            offset += (int64_t)8;
L729 :;
        }L730 :;
        ;
    } else if ((nwords != (int64_t)0)) {
        lab = ++mm_decls_labelno;
        mm_libmcl_genmc((int64_t)8,rcount,mm_libmcl_genint_mc(nwords,(int64_t)8));
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(lab),(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_genmc((int64_t)8,rx,bx);
        mm_libmcl_genmc((int64_t)8,ax,rx);
        mm_libmcl_genmc((int64_t)24,mm_libmcl_genreg((int64_t)((*ax).reg),(int64_t)8),mm_libmcl_genint_mc(mm_decls_targetsize,(int64_t)8));
        mm_libmcl_genmc((int64_t)24,mm_libmcl_genreg((int64_t)((*bx).reg),(int64_t)8),mm_libmcl_genint_mc(mm_decls_targetsize,(int64_t)8));
        mm_libmcl_genmc((int64_t)49,rcount,(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_genmc_cond((int64_t)22,(int64_t)5,mm_libmcl_genlabel_mc(lab),(struct mm_mcldecls_opndrec *)(0));
        offset = (int64_t)0;
    };
    if (!!(oddbytes)) {
        n = oddbytes;
        if ((n >= (int64_t)4)) {
            rx = mm_libmcl_changeopndsize(rx,(int64_t)4);
            mm_libmcl_genmc((int64_t)8,rx,mm_libmcl_applyoffset(bx,offset,(int64_t)4));
            mm_libmcl_genmc((int64_t)8,mm_libmcl_applyoffset(ax,offset,(int64_t)4),rx);
            n -= (int64_t)4;
            offset += (int64_t)4;
        };
        if ((n >= (int64_t)2)) {
            rx = mm_libmcl_changeopndsize(rx,(int64_t)2);
            mm_libmcl_genmc((int64_t)8,rx,mm_libmcl_applyoffset(bx,offset,(int64_t)2));
            mm_libmcl_genmc((int64_t)8,mm_libmcl_applyoffset(ax,offset,(int64_t)2),rx);
            n -= (int64_t)2;
            offset += (int64_t)2;
        };
        if ((n == (int64_t)1)) {
            rx = mm_libmcl_changeopndsize(rx,(int64_t)1);
            mm_libmcl_genmc((int64_t)8,rx,mm_libmcl_applyoffset(bx,offset,(int64_t)1));
            mm_libmcl_genmc((int64_t)8,mm_libmcl_applyoffset(ax,offset,(int64_t)1),rx);
        };
    };
    mm_libmcl_freetempopnd_d8(rcount);
    mm_libmcl_freetempopnd_d8(rx);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_pc_csegment(struct mm_libpcl_pclrec * p) {
    mm_libmcl_setsegment((int64_t)67,(int64_t)1);
}

static void mm_genmcl_pc_isegment(struct mm_libpcl_pclrec * p) {
    mm_libmcl_setsegment((int64_t)73,(int64_t)1);
}

static void mm_genmcl_pc_zsegment(struct mm_libpcl_pclrec * p) {
    mm_libmcl_setsegment((int64_t)90,(int64_t)1);
}

static void mm_genmcl_showopndstack(void) {
    uint8_t str[256];
    int64_t reg;
    int64_t i;
    int64_t r;
    str[((int64_t)1)-1] = (uint64_t)0u;
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"                            # (");
    msysnewc_m_print_i64(mm_libmcl_noperands,NULL);
    msysnewc_m_print_end();
    ;
    L731 :;
    for (i=(int64_t)1;i<=mm_libmcl_noperands;i+=(int64_t)1) {
L732 :;
        reg = (int64_t)(mm_libmcl_opndstack[(i)-1]);
        if ((reg == (int64_t)0)) {
            strcat((int8_t *)(str),(int8_t *)(mlib_chr((int64_t)(mm_libmcl_opndkind[(i)-1]))));
            strcat((int8_t *)(str),(int8_t *)((uint8_t*)"T "));
        } else {
            if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)73)) {
                strcat((int8_t *)(str),(int8_t *)(mm_mcldecls_regnames[(reg)]));
            }else if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)70)) {
                strcat((int8_t *)(str),(int8_t *)(mm_libmcl_xregnames[(reg)]));
            }else if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)87)) {
                strcat((int8_t *)(str),(int8_t *)(mm_mcldecls_regnames[(reg)]));
                strcat((int8_t *)(str),(int8_t *)((uint8_t*)"/"));
                strcat((int8_t *)(str),(int8_t *)(mm_mcldecls_regnames[((int64_t)(mm_libmcl_opndreg2[(i)-1]))]));
            };
        };
        if ((i < mm_libmcl_noperands)) {
            strcat((int8_t *)(str),(int8_t *)((uint8_t*)","));
        };
L733 :;
    }L734 :;
    ;
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)") ("));
    L735 :;
    for (r=(int64_t)1;r<=(int64_t)9;r+=(int64_t)1) {
L736 :;
        strcat((int8_t *)(str),(!!((uint64_t)(mm_libmcl_regset[(r)-1]))?(int8_t *)((uint8_t*)"1 "):(int8_t *)((uint8_t*)"0 ")));
L737 :;
    }L738 :;
    ;
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)") ("));
    L739 :;
    for (r=(int64_t)1;r<=(int64_t)7;r+=(int64_t)1) {
L740 :;
        strcat((int8_t *)(str),(!!((uint64_t)(mm_libmcl_xregset[(r)-1]))?(int8_t *)((uint8_t*)"1 "):(int8_t *)((uint8_t*)"0 ")));
L741 :;
    }L742 :;
    ;
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)")"));
    mm_libmcl_gencomment_mc(str);
}

static void mm_genmcl_showopndstack_s(void) {
    uint8_t str[256];
    uint8_t str2[8];
    int64_t reg;
    int64_t i;
    int64_t r;
    strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"("));
    L743 :;
    for (i=(int64_t)1;i<=mm_libmcl_noperands;i+=(int64_t)1) {
L744 :;
        if (!!((uint64_t)(mm_libmcl_opndkind[(i)-1]))) {
            str2[((int64_t)1)-1] = (uint64_t)(mm_libmcl_opndkind[(i)-1]);
            str2[((int64_t)2)-1] = (uint64_t)0u;
            strcat((int8_t *)(str),(int8_t *)(str2));
        };
        reg = (int64_t)(mm_libmcl_opndstack[(i)-1]);
        strcat((int8_t *)(str),((reg == (int64_t)0)?(int8_t *)((uint8_t*)"T"):(int8_t *)(mm_mcldecls_regnames[(reg)])));
        if (((uint64_t)(mm_libmcl_opndkind[(i)-1]) == (uint64_t)87u)) {
            msysnewc_m_print_startstr(str2);
            msysnewc_m_print_str((uint8_t*)"/",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_u64(mm_libmcl_opndreg2[(i)-1],NULL);
            msysnewc_m_print_end();
            ;
            strcat((int8_t *)(str),(int8_t *)(str2));
        };
        if ((i < mm_libmcl_noperands)) {
            strcat((int8_t *)(str),(int8_t *)((uint8_t*)","));
        };
L745 :;
    }L746 :;
    ;
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)") ("));
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_end();
    ;
    L747 :;
    for (r=(int64_t)1;r<=(int64_t)9;r+=(int64_t)1) {
L748 :;
        msysnewc_m_print_startcon();
        msysnewc_m_print_u64(mm_libmcl_regset[(r)-1],NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(((r == (int64_t)9)?(uint8_t*)"":(uint8_t*)", "),NULL);
        msysnewc_m_print_end();
        ;
L749 :;
    }L750 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)")",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static int64_t mm_genmcl_findop(uint8_t * name) {
    int64_t av_1;
    int64_t i;
    L751 :;
    for (i=(int64_t)1;i<=(int64_t)230;i+=(int64_t)1) {
L752 :;
        if (!!(mlib_eqstring(name,(mm_libpcl_pclnames[(i)-1] + (int64_t)2)))) {
            return i;
        };
L753 :;
    }L754 :;
    ;
    return (int64_t)0;
}

static int64_t mm_genmcl_findcat(uint8_t * name) {
    int64_t i;
    L755 :;
    for (i=(int64_t)0;i<=(int64_t)33;i+=(int64_t)1) {
L756 :;
        if (!!(mlib_eqstring(name,mm_tables_stdtypenames[(i)]))) {
            return i;
        };
L757 :;
    }L758 :;
    ;
    return (int64_t)0;
}

static void mm_genmcl_dohandler(uint8_t * name,void (*fnaddr)(void)) {
    uint8_t str[128];
    int64_t opcodes[32];
    int64_t catmodes[32];
    uint8_t *  parts[32];
    int64_t nops;
    int64_t ncats;
    int64_t nparts;
    int64_t n;
    uint8_t *  s;
    uint8_t *  t;
    int64_t i;
    int64_t j;
    nops = (ncats = (nparts = (int64_t)0));
    s = str;
    t = (name + (int64_t)3);
    parts[(++nparts)-1] = s;
    L759 :;
    while (!!((uint64_t)((*t)))) {
        if (((uint64_t)((*t)) == '_')) {
            (*s++) = (uint64_t)0u;
            parts[(++nparts)-1] = s;
        } else {
            (*s++) = (uint64_t)((*t));
        };
        ++t;
L760 :;
    }L761 :;
    ;
    (*s) = (uint64_t)0u;
    L762 :;
    for (i=(int64_t)1;i<=nparts;i+=(int64_t)1) {
L763 :;
        if (!!((n = mm_genmcl_findop(parts[(i)-1])))) {
            opcodes[(++nops)-1] = n;
        } else if (!!((n = mm_genmcl_findcat(parts[(i)-1])))) {
            catmodes[(++ncats)-1] = n;
        } else {
            mm_support_gerror_s((uint8_t*)"Can't find opc/cat: #",name,(struct mm_decls_unitrec *)(0));
        };
L764 :;
    }L765 :;
    ;
    if ((nops == (int64_t)0)) {
        mm_support_gerror((uint8_t*)"pclhandlers/no ops",(struct mm_decls_unitrec *)(0));
    };
    if ((ncats == (int64_t)0)) {
        catmodes[(++ncats)-1] = (int64_t)0;
    };
    L766 :;
    for (i=(int64_t)1;i<=nops;i+=(int64_t)1) {
L767 :;
        L770 :;
        for (j=(int64_t)1;j<=ncats;j+=(int64_t)1) {
L771 :;
            mm_genmcl_handlertable[(opcodes[(i)-1])-1][(catmodes[(j)-1])] = (void (*)(struct mm_libpcl_pclrec *))(fnaddr);
L772 :;
        }L773 :;
        ;
L768 :;
    }L769 :;
    ;
}

static void mm_genmcl_fixdivopnds_d8(void) {
    int64_t regx;
    int64_t regy;
    int64_t zop;
    regx = (int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1]);
    regy = (int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    if ((regx == (int64_t)1)) {
        return;
    };
    if ((regy == (int64_t)1)) {
        mm_libmcl_genmc((int64_t)23,mm_libmcl_genopnd((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)0,(int64_t)8));
        mm_libmcl_swapopnds((int64_t)1,(int64_t)2);
        return;
    };
    if (((int64_t)((uint64_t)(mm_libmcl_regset[((int64_t)1)-1])) == (int64_t)0)) {
        mm_libmcl_genmc((int64_t)23,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)1,(int64_t)8));
        mm_libmcl_regset[(regx)-1] = (uint64_t)((int64_t)0);
        mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1] = (uint64_t)((int64_t)1);
        mm_libmcl_regset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
        return;
    };
    L774 :;
    for (zop=(int64_t)1;zop<=mm_libmcl_noperands;zop+=(int64_t)1) {
L775 :;
        if (((int64_t)((uint64_t)(mm_libmcl_opndstack[(zop)-1])) == (int64_t)1)) {
            goto L777 ;
        };
L776 :;
    }L777 :;
    ;
    mm_libmcl_genmc((int64_t)23,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genopnd((int64_t)1,(int64_t)8));
    {byte temp = mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1]; mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1] = mm_libmcl_opndstack[(zop)-1]; mm_libmcl_opndstack[(zop)-1] = temp; };
}

static void mm_genmcl_doshiftn(struct mm_libpcl_pclrec * p,int64_t opc) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  cx;
    struct mm_mcldecls_opndrec *  dx;
    mm_libmcl_getopnds((int64_t)2);
    ax = mm_libmcl_genopnd((int64_t)1,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]));
    cx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    dx = mm_libmcl_genreg((int64_t)11,(int64_t)8);
    mm_libmcl_genmc((int64_t)23,cx,dx);
    dx = mm_libmcl_genreg((int64_t)11,(int64_t)1);
    mm_libmcl_genmc(opc,ax,dx);
    mm_libmcl_popopnd();
}

static void mm_genmcl_doshiftnto(struct mm_libpcl_pclrec * p,int64_t opc) {
    struct mm_mcldecls_opndrec *  px;
    struct mm_mcldecls_opndrec *  cx;
    struct mm_mcldecls_opndrec *  dx;
    mm_libmcl_getopnds((int64_t)2);
    px = mm_libmcl_genopndind((int64_t)1,(int64_t)8);
    cx = mm_libmcl_genopnd((int64_t)0,(int64_t)8);
    dx = mm_libmcl_genreg((int64_t)11,(int64_t)8);
    mm_libmcl_genmc((int64_t)23,cx,dx);
    dx = mm_libmcl_genreg((int64_t)11,(int64_t)1);
    mm_libmcl_genmc(opc,px,dx);
    mm_libmcl_popopnd();
    mm_libmcl_popopnd();
}

static void mm_genmcl_docallff(int64_t nargs,int64_t floatmap,int64_t isfunction,int64_t isvariadic) {
    int64_t n;
    int64_t mask;
    int64_t av_1;
    int64_t i;
    n = (nargs<(int64_t)4?nargs:(int64_t)4);
    mask = (int64_t)1;
    L778 :;
    for (i=(int64_t)0;i<=(n - (int64_t)1);i+=(int64_t)1) {
L779 :;
        if (!!(isvariadic)) {
            if (!!((floatmap & mask))) {
                mm_libmcl_genmc((int64_t)10,mm_libmcl_genreg(((int64_t)11 + i),(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
                mm_libmcl_genmc((int64_t)14,mm_libmcl_genxreg(((int64_t)1 + i),(int64_t)8),mm_libmcl_genreg(((int64_t)11 + i),(int64_t)8));
            } else {
                mm_libmcl_genmc((int64_t)10,mm_libmcl_genreg(((int64_t)11 + i),(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
            };
        } else {
            if (!!((floatmap & mask))) {
                mm_libmcl_genmc((int64_t)14,mm_libmcl_genxreg(((int64_t)1 + i),(int64_t)8),mm_libmcl_genireg((int64_t)16,(int64_t)8,(int64_t)0));
                mm_libmcl_popstack_mc((int64_t)8);
            } else {
                mm_libmcl_genmc((int64_t)10,mm_libmcl_genreg(((int64_t)11 + i),(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
            };
        };
        --mm_libmcl_noperands;
        mask <<= (int64_t)1;
L780 :;
    }L781 :;
    ;
    if ((nargs <= (int64_t)4)) {
        mm_libmcl_genmc_sys((int64_t)10);
    } else {
        mm_libmcl_genmc_sys((((int64_t)10 + nargs) - (int64_t)4));
    };
    L782 :;
    for (i=(int64_t)5;i<=nargs;i+=(int64_t)1) {
L783 :;
        mm_libmcl_poparg();
L784 :;
    }L785 :;
    ;
}

static void mm_genmcl_docmaths1(uint8_t * name) {
    mm_libmcl_pushalloperands();
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genname_mc(name));
    mm_genmcl_docallff((int64_t)1,(int64_t)1,(int64_t)1,(int64_t)0);
    mm_genmcl_pc_pushffretval_pushretval_x8_x4((struct mm_libpcl_pclrec *)(0));
}

static void mm_genmcl_docmaths2(uint8_t * name) {
    mm_libmcl_pushalloperands();
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)1,(int64_t)8),mm_libmcl_genname_mc(name));
    mm_genmcl_docallff((int64_t)2,(int64_t)3,(int64_t)1,(int64_t)0);
    mm_genmcl_pc_pushffretval_pushretval_x8_x4((struct mm_libpcl_pclrec *)(0));
}

static void mm_genmcl_call128handler_f(int64_t fnindex,int64_t n) {
    mm_libmcl_pushalloperands();
    mm_libmcl_genmc_sys(fnindex);
    mm_libmcl_noperands -= (n - (int64_t)1);
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)1);
    mm_libmcl_opndreg2[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)2);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)87u;
    mm_libmcl_regset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
    mm_libmcl_regset[((int64_t)2)-1] = (uint64_t)((int64_t)1);
}

static void mm_genmcl_call128handler_p(int64_t fnindex,int64_t n) {
    mm_libmcl_pushalloperands();
    mm_libmcl_genmc_sys(fnindex);
    mm_libmcl_noperands -= n;
}

static void mm_genmcl_call64handler_f(int64_t fnindex,int64_t n) {
    mm_libmcl_pushalloperands();
    mm_libmcl_genmc_sys(fnindex);
    mm_libmcl_noperands -= (n - (int64_t)1);
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)1);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
    mm_libmcl_regset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
}

static void mm_genmcl_call64handler_p(int64_t fnindex,int64_t n) {
    mm_libmcl_pushalloperands();
    mm_libmcl_genmc_sys(fnindex);
    mm_libmcl_noperands -= n;
}

static void mm_genmcl_calldothandler(int64_t fnindex,int64_t nargs) {
    mm_libmcl_genmc_sys(fnindex);
    mm_libmcl_noperands -= (nargs - (int64_t)1);
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)1);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
    mm_libmcl_regset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
}

static void mm_genmcl_callpopdothandler(int64_t fnindex,int64_t nargs) {
    mm_libmcl_genmc_sys(fnindex);
    mm_libmcl_noperands -= nargs;
}

static void mm_genmcl_genstringtable(void) {
    int64_t i;
    mm_libmcl_setsegment((int64_t)73,(int64_t)8);
    if (!!(mm_libmcl_kk0used)) {
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_kk0used),(struct mm_mcldecls_opndrec *)(0));
        mm_genmcl_gendb((int64_t)0);
    };
    if (!(!!(mm_libmcl_nstrings))) {
        return;
    };
    L786 :;
    for (i=(int64_t)1;i<=mm_libmcl_nstrings;i+=(int64_t)1) {
L787 :;
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc((int64_t)((*mm_libmcl_stringlabtable)[(i)-1])),(struct mm_mcldecls_opndrec *)(0));
        mm_genmcl_genstring((*mm_libmcl_stringtable)[(i)-1],(int64_t)((*mm_libmcl_stringlentable)[(i)-1]),(int64_t)1);
L788 :;
    }L789 :;
    ;
}

void mm_genmcl_genstring(uint8_t * s,int64_t length,int64_t doterm) {
    int64_t c;
    int64_t seqlen;
    uint8_t *  seq;
    int64_t av_1;
    if ((length == (int64_t)0)) {
        mm_genmcl_gendb((int64_t)0);
        return;
    };
    seqlen = (int64_t)0;
    av_1 = length;
    while (av_1-- > 0) {
L790 :;
        c = (int64_t)((*s++));
        if ((((c < (int64_t)32) || (c >= (int64_t)127)) || (c == (int64_t)34))) {
            if (!!(seqlen)) {
                mm_genmcl_gendbstring(seq,seqlen);
                seqlen = (int64_t)0;
            };
            mm_genmcl_gendb(c);
        } else {
            if ((seqlen == (int64_t)0)) {
                seqlen = (int64_t)1;
                seq = (s - (int64_t)1);
            } else {
                ++seqlen;
            };
        };
L791 :;
    }L792 :;
    ;
    if (!!(seqlen)) {
        mm_genmcl_gendbstring(seq,seqlen);
    };
    if (!!(doterm)) {
        mm_genmcl_gendb((int64_t)0);
    };
}

static void mm_genmcl_gendb(int64_t a) {
    mm_libmcl_genmc((int64_t)109,mm_libmcl_genint_mc(a,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_gendw(int64_t a) {
    mm_libmcl_genmc((int64_t)110,mm_libmcl_genint_mc(a,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_gendbstring(uint8_t * s,int64_t length) {
    mm_libmcl_genmc((int64_t)109,mm_libmcl_genstrimm_mc(s,length),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_gendq(int64_t a) {
    mm_libmcl_genmc((int64_t)112,mm_libmcl_genint_mc(a,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_gendqname(struct mm_decls_strec * d) {
    mm_libmcl_genmc((int64_t)112,mm_libmcl_genmemaddr_d_mc(d),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_gendqlabel(int64_t lab) {
    mm_libmcl_genmc((int64_t)112,mm_libmcl_genlabel_mc(lab),(struct mm_mcldecls_opndrec *)(0));
}

static void mm_genmcl_genrealtable(void) {
    double x;
    int64_t i;
    if (!(!!(mm_libmcl_nreals))) {
        return;
    };
    mm_libmcl_gencomment_mc((uint8_t*)"Real Table");
    mm_libmcl_setsegment((int64_t)73,(int64_t)8);
    L793 :;
    for (i=(int64_t)1;i<=mm_libmcl_nreals;i+=(int64_t)1) {
L794 :;
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(labs((int64_t)((*mm_libmcl_reallabtable)[(i)-1]))),(struct mm_mcldecls_opndrec *)(0));
        x = (*mm_libmcl_realtable)[(i)-1];
        if (((int64_t)((*mm_libmcl_reallabtable)[(i)-1]) > (int64_t)0)) {
            mm_libmcl_genmc((int64_t)112,mm_libmcl_genrealimm_mc(x,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
        } else {
            mm_libmcl_genmc((int64_t)111,mm_libmcl_genrealimm_mc(x,(int64_t)4),(struct mm_mcldecls_opndrec *)(0));
        };
L795 :;
    }L796 :;
    ;
}

static void mm_genmcl_genfunctiondata(void) {
    int64_t i;
    int64_t nprocs;
    int64_t n;
    int64_t nexports;
    int64_t nparams;
    int64_t optflag;
    int64_t labelbase;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    struct mm_decls_strec *  params[100];
    int64_t j;
    nprocs = (int64_t)0;
    mm_libmcl_setsegment((int64_t)73,(int64_t)8);
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genstrimm_mc((uint8_t*)"m$fnaddresses:",(int64_t)-1),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_getsysfnlabel((int64_t)54)),(struct mm_mcldecls_opndrec *)(0));
    L797 :;
    for (i=(int64_t)1;i<=mm_decls_nmodules;i+=(int64_t)1) {
L798 :;
        d = (*mm_decls_moduletable[(i)].stmodule).deflist;
        L801 :;
        while (!!(d)) {
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)5)) {
                ++nprocs;
                mm_genmcl_gendqname(d);
            };
            d = (*d).nextdef;
L802 :;
        }L803 :;
        ;
L799 :;
    }L800 :;
    ;
    mm_genmcl_gendq((int64_t)0);
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genstrimm_mc((uint8_t*)"m$fnnames:",(int64_t)-1),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_getsysfnlabel((int64_t)53)),(struct mm_mcldecls_opndrec *)(0));
    n = (int64_t)0;
    labelbase = mm_decls_labelno;
    L804 :;
    for (i=(int64_t)1;i<=mm_decls_nmodules;i+=(int64_t)1) {
L805 :;
        d = (*mm_decls_moduletable[(i)].stmodule).deflist;
        L808 :;
        while (!!(d)) {
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)5)) {
                mm_genmcl_gendqlabel(++mm_decls_labelno);
            };
            d = (*d).nextdef;
L809 :;
        }L810 :;
        ;
L806 :;
    }L807 :;
    ;
    mm_genmcl_gendq((int64_t)0);
    n = (int64_t)0;
    L811 :;
    for (i=(int64_t)1;i<=mm_decls_nmodules;i+=(int64_t)1) {
L812 :;
        d = (*mm_decls_moduletable[(i)].stmodule).deflist;
        L815 :;
        while (!!(d)) {
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)5)) {
                ++n;
                mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc((n + labelbase)),(struct mm_mcldecls_opndrec *)(0));
                mm_genmcl_gendbstring((*d).name,(int64_t)-1);
                mm_genmcl_gendb((int64_t)0);
            };
            d = (*d).nextdef;
L816 :;
        }L817 :;
        ;
L813 :;
    }L814 :;
    ;
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genstrimm_mc((uint8_t*)"m$fnnprocs:",(int64_t)-1),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_getsysfnlabel((int64_t)51)),(struct mm_mcldecls_opndrec *)(0));
    mm_genmcl_gendq(nprocs);
    nprocs = (nexports = (int64_t)0);
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genstrimm_mc((uint8_t*)"!m$fnaddresses:",(int64_t)-1),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_getsysfnlabel((int64_t)55)),(struct mm_mcldecls_opndrec *)(0));
    L818 :;
    for (i=(int64_t)1;i<=mm_decls_nmodules;i+=(int64_t)1) {
L819 :;
        d = (*mm_decls_moduletable[(i)].stmodule).deflist;
        L822 :;
        while (!!(d)) {
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)5)) {
                ++nprocs;
                if (((int64_t)((uint64_t)((*d).isglobal)) == (int64_t)2)) {
                    ++nexports;
                    mm_genmcl_gendw(nprocs);
                    nparams = (int64_t)0;
                    e = (*d).paramlist;
                    L825 :;
                    while (!!(e)) {
                        if (((int64_t)((uint64_t)((*e).nameid)) == (int64_t)11)) {
                            ++nparams;
                            if ((nparams > (int64_t)100)) {
                                mm_support_gerror((uint8_t*)"Export: too many params",(struct mm_decls_unitrec *)(0));
                            };
                            params[(nparams)-1] = e;
                        };
                        e = (*e).nextdef;
L826 :;
                    }L827 :;
                    ;
                    nparams=(nparams<(int64_t)12?nparams:(int64_t)12);
;
                    mm_genmcl_gendb(mm_lib_getpacktype((int64_t)((*d).mode)));
                    mm_genmcl_gendb(nparams);
                    L828 :;
                    for (j=(int64_t)1;j<=(int64_t)12;j+=(int64_t)1) {
L829 :;
                        if ((j <= nparams)) {
                            e = params[(j)-1];
                            optflag = (!!((uint64_t)((*e).optional))?(int64_t)64:(int64_t)0);
                            mm_genmcl_gendb((mm_lib_getpacktype((int64_t)((*e).mode)) + optflag));
                        } else {
                            mm_genmcl_gendb((int64_t)0);
                        };
L830 :;
                    }L831 :;
                    ;
                };
            };
            d = (*d).nextdef;
L823 :;
        }L824 :;
        ;
L820 :;
    }L821 :;
    ;
    mm_genmcl_gendw((int64_t)0);
    mm_libmcl_genmc((int64_t)3,mm_libmcl_genstrimm_mc((uint8_t*)"!m$fnexports:",(int64_t)-1),(struct mm_mcldecls_opndrec *)(0));
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_getsysfnlabel((int64_t)52)),(struct mm_mcldecls_opndrec *)(0));
    mm_genmcl_gendq(nexports);
}

static void mm_genmcl_gensysfntable(void) {
    uint8_t name[256];
    int64_t proclab;
    struct mm_decls_strec *  d;
    int64_t av_1;
    int64_t i;
    mm_libmcl_gencomment_mc((uint8_t*)"SYSFN TABLE");
    mm_libmcl_setsegment((int64_t)73,(int64_t)8);
    L832 :;
    for (i=(int64_t)1;i<=(int64_t)181;i+=(int64_t)1) {
L833 :;
        if (!!(mm_decls_sysfnlabels[(i)-1])) {
            if ((i==(int64_t)51) || (i==(int64_t)52) || (i==(int64_t)53) || (i==(int64_t)54) || (i==(int64_t)55)) {
                goto L834 ;
            };
            strcpy((int8_t *)(name),(int8_t *)((uint8_t*)"m$"));
            strcat((int8_t *)(name),(int8_t *)((mm_tables_sysfnnames[(i)-1] + (int64_t)6)));
            d = mm_lex_findname(name);
            if (!(!!(d))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"Can't find",NULL);
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                goto L834 ;
            };
            proclab = (int64_t)0;
            L836 :;
            while (!!(d)) {
                if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)5)) {
                    proclab = (int64_t)((*d).labelno);
                    goto L838 ;
                };
                d = (*d).nextdupl;
L837 :;
            }L838 :;
            ;
            if (!(!!(proclab))) {
                goto L834 ;
            };
            mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_decls_sysfnlabels[(i)-1]),(struct mm_mcldecls_opndrec *)(0));
            mm_genmcl_gendqlabel(proclab);
        };
L834 :;
    }L835 :;
    ;
}

static void mm_genmcl_genabsneg(void) {
    mm_libmcl_setsegment((int64_t)73,(int64_t)16);
    if (!!(mm_libmcl_lababs32)) {
        mm_libmcl_gencomment_mc((uint8_t*)"lababs32");
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_lababs32),(struct mm_mcldecls_opndrec *)(0));
        mm_genmcl_gendq((int64_t)9223372034707292159);
        mm_genmcl_gendq((int64_t)9223372034707292159);
    };
    if (!!(mm_libmcl_lababs64)) {
        mm_libmcl_gencomment_mc((uint8_t*)"lababs64");
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_lababs64),(struct mm_mcldecls_opndrec *)(0));
        mm_genmcl_gendq((int64_t)((uint64_t)9223372036854775807u));
        mm_genmcl_gendq((int64_t)((uint64_t)9223372036854775807u));
    };
    if (!!(mm_libmcl_labneg32)) {
        mm_libmcl_gencomment_mc((uint8_t*)"labneg32");
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_labneg32),(struct mm_mcldecls_opndrec *)(0));
        mm_genmcl_gendq((int64_t)((uint64_t)9223372039002259456u));
        mm_genmcl_gendq((int64_t)((uint64_t)9223372039002259456u));
    };
    if (!!(mm_libmcl_labneg64)) {
        mm_libmcl_gencomment_mc((uint8_t*)"labneg64");
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_labneg64),(struct mm_mcldecls_opndrec *)(0));
        mm_genmcl_gendq((int64_t)((uint64_t)9223372036854775808u));
        mm_genmcl_gendq((int64_t)((uint64_t)9223372036854775808u));
    };
    if (!!(mm_libmcl_labzero)) {
        mm_libmcl_gencomment_mc((uint8_t*)"labzero");
        mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(mm_libmcl_labzero),(struct mm_mcldecls_opndrec *)(0));
        mm_genmcl_gendq((int64_t)0);
    };
}

void mm_libmcl_mclinit(void) {
    int64_t r;
    mm_libmcl_ptrsize = mm_decls_targetsize;
    L839 :;
    for (r=(int64_t)1;r<=(int64_t)16;r+=(int64_t)1) {
L840 :;
        mm_libmcl_regtable[(r)-1][((int64_t)1)-1] = mm_libmcl_genreg0(r,(int64_t)1);
        mm_libmcl_regtable[(r)-1][((int64_t)2)-1] = mm_libmcl_genreg0(r,(int64_t)2);
        mm_libmcl_regtable[(r)-1][((int64_t)4)-1] = mm_libmcl_genreg0(r,(int64_t)4);
        mm_libmcl_regtable[(r)-1][((int64_t)8)-1] = mm_libmcl_genreg0(r,(int64_t)8);
        mm_libmcl_regtable[(r)-1][((int64_t)16)-1] = mm_libmcl_genreg0(r,(int64_t)16);
L841 :;
    }L842 :;
    ;
    mm_libmcl_zero_opnd = mm_libmcl_genint_mc((int64_t)0,(int64_t)8);
    mm_libmcl_zero_unit = mm_lib_createconstunit((uint64_t)((int64_t)0),(int64_t)4);
    (*mm_libmcl_zero_unit).mode = (int64_t)4;
    mm_libmcl_dframeopnd = mm_libmcl_genreg((int64_t)15,(int64_t)8);
    mm_libmcl_dstackopnd = mm_libmcl_genreg((int64_t)16,(int64_t)8);
    mm_libmcl_initmcdest();
    mm_libmcl_setsegment((int64_t)67,(int64_t)1);
    mm_libmcl_stringtable = (uint8_t * (*)[])(mlib_pcm_alloc((int64_t)8192));
    mm_libmcl_stringlentable = (int32_t (*)[])(mlib_pcm_alloc((int64_t)4096));
    mm_libmcl_stringlabtable = (int32_t (*)[])(mlib_pcm_alloc((int64_t)4096));
    mm_libmcl_realtable = (double (*)[])(mlib_pcm_alloc((int64_t)128));
    mm_libmcl_reallabtable = (int32_t (*)[])(mlib_pcm_alloc((int64_t)64));
    mm_libmcl_stringtablesize = (int64_t)1024;
    mm_libmcl_realtablesize = (int64_t)16;
}

void mm_libmcl_initmcdest(void) {
    mm_libmcl_mccode = (mm_libmcl_mccodex = (struct mm_mcldecls_mclrec *)(0));
}

void mm_libmcl_genmc(int64_t opcode,struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    struct mm_mcldecls_mclrec *  m;
    struct mm_mcldecls_mclrec *  oldm;
    m = (struct mm_mcldecls_mclrec *)(mlib_pcm_alloc((int64_t)36));
    ++mm_decls_nmcl;
    (*m).lineno = mm_decls_mlineno;
    (*m).opcode = (uint64_t)(opcode);
    (*m).a = a;
    (*m).b = b;
    if ((opcode==(int64_t)8)) {
        if ((((!!(a) && ((int64_t)((uint64_t)((*a).mode)) == (int64_t)1)) && !!(b)) && ((int64_t)((uint64_t)((*b).mode)) == (int64_t)3))) {
            oldm = mm_libmcl_mccodex;
            if ((((!!(oldm) && ((int64_t)((uint64_t)((*oldm).opcode)) == (int64_t)8)) && ((int64_t)((uint64_t)((*(*oldm).a).mode)) == (int64_t)3)) && ((int64_t)((uint64_t)((*(*oldm).b).mode)) == (int64_t)1))) {
                if ((!!(mm_libmcl_sameoperand(a,(*oldm).b)) && !!(mm_libmcl_sameoperand((*oldm).a,b)))) {
                    return;
                };
            };
        };
    };
    if (!!(mm_libmcl_mccode)) {
        (*mm_libmcl_mccodex).nextmcl = m;
        mm_libmcl_mccodex = m;
    } else {
        mm_libmcl_mccode = (mm_libmcl_mccodex = m);
    };
}

void mm_libmcl_genmc_cond(int64_t opcode,int64_t cond,struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    mm_libmcl_genmc(opcode,a,b);
    (*mm_libmcl_mccodex).cond = (uint64_t)(cond);
}

struct mm_mcldecls_mclrec * mm_libmcl_lastmc(void) {
    return mm_libmcl_mccodex;
}

void mm_libmcl_genmcstr(int64_t opcode,uint8_t * s) {
    mm_libmcl_genmc(opcode,mm_libmcl_genstrimm_mc(s,(int64_t)-1),(struct mm_mcldecls_opndrec *)(0));
}

static struct mm_mcldecls_opndrec * mm_libmcl_newmclopnd(void) {
    struct mm_mcldecls_opndrec *  a;
    a = (struct mm_mcldecls_opndrec *)(mlib_pcm_allocz((int64_t)24));
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_duplopnd(struct mm_mcldecls_opndrec * a) {
    struct mm_mcldecls_opndrec *  b;
    b = (struct mm_mcldecls_opndrec *)(mlib_pcm_alloc((int64_t)24));
    (*b) = (*a);
    return b;
}

struct mm_mcldecls_opndrec * mm_libmcl_genxreg(int64_t xreg,int64_t size) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)5);
    (*a).reg = (uint64_t)(xreg);
    (*a).size = (uint64_t)(size);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genindex(int64_t areg,int64_t ireg,int64_t scale,int64_t offset,int64_t size,int64_t labno,struct mm_decls_strec * def) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)3);
    (*a).reg = (uint64_t)(areg);
    (*a).regix = (uint64_t)(ireg);
    (*a).scale = (uint64_t)(scale);
    (*a).size = (uint64_t)(size);
    (*a).offset = offset;
    if (!!(labno)) {
        (*a).value = labno;
        (*a).valtype = (uint64_t)((int64_t)6);
    } else if (!!(def)) {
        (*a).def = def;
        (*a).valtype = (uint64_t)((int64_t)5);
        if (!!(mm_libmcl_isframe(def))) {
            (*a).reg = (uint64_t)((int64_t)15);
        };
    };
    return a;
}

static void mm_libmcl_writemclblock(struct mm_mcldecls_mclrec * m) {
    int64_t i;
    i = (int64_t)1;
    L843 :;
    while (!!(m)) {
        mm_libmcl_writemcl(i,m);
        ++i;
        m = (*m).nextmcl;
L844 :;
    }L845 :;
    ;
}

struct mlib_strbuffer * mm_libmcl_writemclcode(uint8_t * caption) {
    mlib_gs_init(mm_lib_dest);
    mlib_gs_str(mm_lib_dest,(uint8_t*)"PROC ");
    mlib_gs_strln(mm_lib_dest,caption);
    mlib_gs_strln(mm_lib_dest,(uint8_t*)"!---------------------------------------------");
    mm_libmcl_writemclblock(mm_libmcl_allmclcode);
    mlib_gs_strln(mm_lib_dest,(uint8_t*)"!---------------------------------------------");
    return mm_lib_dest;
}

void mm_libmcl_gencomment_mc(uint8_t * s) {
    if (((s == 0) || ((int64_t)((*s)) == (int64_t)0))) {
    } else {
        mm_libmcl_genmcstr((int64_t)1,s);
    };
}

struct mm_mcldecls_opndrec * mm_libmcl_genstrimm_mc(uint8_t * s,int64_t length) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)2);
    if ((length < (int64_t)0)) {
        length = (int64_t)(strlen((int8_t *)(s)));
    };
    (*a).svalue = (uint8_t *)(mlib_pcm_alloc((length + (int64_t)1)));
    memcpy((void *)((*a).svalue),(void *)(s),(uint64_t)(length));
    (*((*a).svalue + length)) = (uint64_t)0u;
    (*a).valtype = (uint64_t)((int64_t)4);
    (*a).size = (uint64_t)(mm_libmcl_ptrsize);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genname_mc(uint8_t * s) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)2);
    (*a).svalue = mlib_pcm_copyheapstring(s);
    (*a).valtype = (uint64_t)((int64_t)7);
    (*a).size = (uint64_t)(mm_libmcl_ptrsize);
    return a;
}

void mm_libmcl_genmc_sys(int64_t fnindex) {
    mm_libmcl_genmc_cond((int64_t)18,fnindex,mm_libmcl_genlabel_mc(mm_libmcl_getsysfnlabel(fnindex)),(struct mm_mcldecls_opndrec *)(0));
    (*(*mm_libmcl_mccodex).a).mode = (uint64_t)((int64_t)3);
    (*(*mm_libmcl_mccodex).a).size = (uint64_t)((int64_t)8);
}

int64_t mm_libmcl_getsysfnlabel(int64_t fnindex) {
    if ((mm_decls_sysfnlabels[(fnindex)-1] == (int64_t)0)) {
        mm_decls_sysfnlabels[(fnindex)-1] = ++mm_decls_labelno;
        return mm_decls_labelno;
    };
    return mm_decls_sysfnlabels[(fnindex)-1];
}

static void mm_libmcl_writemcl(int64_t index,struct mm_mcldecls_mclrec * mcl) {
    mm_libmcl_strmcl(mcl);
    mlib_gs_line(mm_lib_dest);
}

void mm_libmcl_strmcl(struct mm_mcldecls_mclrec * mcl) {
    static uint8_t str[512];
    uint8_t opcname[128];
    struct mm_mcldecls_opndrec *  a;
    struct mm_mcldecls_opndrec *  b;
    int64_t opcode;
    int64_t cond;
    int64_t sizepref;
    uint8_t *  comment;
    opcode = (int64_t)((*mcl).opcode);
    cond = (int64_t)((*mcl).cond);
    a = (*mcl).a;
    b = (*mcl).b;
    comment = (uint8_t *)(0);
    if ((opcode==(int64_t)2)) {
        return;
    }else if ((opcode==(int64_t)1)) {
        mm_libmcl_asmchar((int64_t)59);
        mm_libmcl_asmstr((*a).svalue);
        return;
    }else if ((opcode==(int64_t)3)) {
        if (((int64_t)((*a).valtype)==(int64_t)5)) {
            mm_libmcl_asmstr(mm_lib_getfullname((*a).def,(int64_t)0));
        }else if (((int64_t)((*a).valtype)==(int64_t)4)) {
            mm_libmcl_asmstr((*a).svalue);
            return;
        } else {
            mm_support_gerror((uint8_t*)"strmcl/lab",(struct mm_decls_unitrec *)(0));
        };
        mm_libmcl_asmstr((!!((uint64_t)((*(*a).def).isglobal))?(uint8_t*)"::":(uint8_t*)":"));
        return;
    }else if ((opcode==(int64_t)5)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"L#:#");
        msysnewc_m_print_i64((*a).value,NULL);
        msysnewc_m_print_str((!!((uint64_t)((*mcl).isglobal))?(uint8_t*)":":(uint8_t*)""),NULL);
        msysnewc_m_print_end();
        ;
        mm_libmcl_asmstr(str);
        return;
    };
    if ((opcode==(int64_t)22)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((uint8_t*)"j",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mm_mcldecls_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    }else if ((opcode==(int64_t)54)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((uint8_t*)"set",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mm_mcldecls_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    }else if ((opcode==(int64_t)12)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((uint8_t*)"cmov",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mm_mcldecls_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    }else if ((opcode==(int64_t)18)) {
        if (!!(cond)) {
            comment = (mm_tables_sysfnnames[(cond)-1] + (int64_t)6);
        };
        strcpy((int8_t *)(opcname),(int8_t *)((uint8_t*)"call"));
    }else if ((opcode==(int64_t)34)) {
        strcpy((int8_t *)(opcname),(int8_t *)((uint8_t*)"and"));
    }else if ((opcode==(int64_t)35)) {
        strcpy((int8_t *)(opcname),(int8_t *)((uint8_t*)"or"));
    }else if ((opcode==(int64_t)36)) {
        strcpy((int8_t *)(opcname),(int8_t *)((uint8_t*)"xor"));
    }else if ((opcode==(int64_t)47)) {
        strcpy((int8_t *)(opcname),(int8_t *)((uint8_t*)"not"));
    }else if ((opcode==(int64_t)4)) {
        mm_libmcl_stropnd(a,(int64_t)0,(int64_t)0);
        mm_libmcl_asmstr((uint8_t*)"=");
        mm_libmcl_stropnd(b,(int64_t)0,(int64_t)0);
        return;
    } else {
        if ((opcode > (int64_t)143)) {
            strcpy((int8_t *)(opcname),(int8_t *)(msysnewc_strint(opcode,(uint8_t *)(0))));
        } else {
            strcpy((int8_t *)(opcname),(int8_t *)((mm_mcldecls_mclnames[(opcode)-1] + (int64_t)2)));
        };
    };
    mlib_ipadstr(opcname,(int64_t)10,(uint8_t*)" ");
    if (!(!!((int64_t)1))) {
        if ((!!(a) && !!(b))) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((uint8_t*)"  #/#");
            msysnewc_m_print_u64((*a).size,NULL);
            msysnewc_m_print_u64((*b).size,NULL);
            msysnewc_m_print_end();
            ;
        } else if (!!(a)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((uint8_t*)"  #");
            msysnewc_m_print_u64((*a).size,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"  "));
        };
    } else {
        strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"  "));
    };
    mlib_ipadstr(str,(int64_t)10,(uint8_t*)" ");
    strcat((int8_t *)(str),(int8_t *)(opcname));
    mm_libmcl_asmstr(str);
    if ((!!(a) && !!(b))) {
        sizepref = mm_libmcl_needsizeprefix(opcode,a,b);
        mm_libmcl_stropnd(a,sizepref,(int64_t)0);
        mm_libmcl_asmstr((uint8_t*)",\t");
        mm_libmcl_stropnd(b,sizepref,(int64_t)0);
    } else if ((!!(a) && !!((uint64_t)((*a).mode)))) {
        if ((opcode == (int64_t)18)) {
            mm_libmcl_stropnd(a,(int64_t)0,(int64_t)0);
        } else {
            mm_libmcl_stropnd(a,(int64_t)1,(int64_t)0);
        };
    };
    if ((opcode==(int64_t)85) || (opcode==(int64_t)86)) {
        mm_libmcl_asmstr((uint8_t*)", ");
        mm_libmcl_asmint((int64_t)((*mcl).c));
    };
    if (!!(comment)) {
        mm_libmcl_asmstr((uint8_t*)"\t!");
        mm_libmcl_asmstr(comment);
    };
}

void mm_libmcl_stropnd(struct mm_mcldecls_opndrec * a,int64_t sizeprefix,int64_t debug) {
    static uint8_t str[512];
    uint8_t str2[128];
    uint8_t *  plus;
    int64_t offset;
    if (((int64_t)((*a).mode)==(int64_t)1)) {
        mm_libmcl_asmstr(mm_libmcl_getregname((int64_t)((*a).reg),(int64_t)((*a).size)));
    }else if (((int64_t)((*a).mode)==(int64_t)2)) {
        mm_libmcl_strvalue(a);
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
        if (((int64_t)((*a).valtype)==(int64_t)1)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"#",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*a).value,NULL);
            msysnewc_m_print_end();
            ;
            mm_libmcl_asmstr(str);
        }else if (((int64_t)((*a).valtype)==(int64_t)2)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"#",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_r64((*a).xvalue,NULL);
            msysnewc_m_print_end();
            ;
            mm_libmcl_asmstr(str);
        }else if (((int64_t)((*a).valtype)==(int64_t)3)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((uint8_t*)"M#",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_r64((*a).xvalue,NULL);
            msysnewc_m_print_end();
            ;
            mm_libmcl_asmstr(str);
        };
        mm_libmcl_asmstr(mm_libmcl_getsizeprefix((int64_t)((*a).size),sizeprefix));
        mm_libmcl_asmstr((uint8_t*)"[");
        plus = (uint8_t*)"";
        if (!!((uint64_t)((*a).reg))) {
            mm_libmcl_asmstr(mm_libmcl_getregname((int64_t)((*a).reg),mm_libmcl_ptrsize));
            plus = (uint8_t*)"+";
        };
        if (!!((uint64_t)((*a).regix))) {
            mm_libmcl_asmstr(plus);
            mm_libmcl_asmstr(mm_libmcl_getregname((int64_t)((*a).regix),mm_libmcl_ptrsize));
            plus = (uint8_t*)"+";
            if (((int64_t)((uint64_t)((*a).scale)) > (int64_t)1)) {
                mm_libmcl_asmchar((int64_t)42);
                mm_libmcl_asmint((int64_t)((*a).scale));
            };
        };
        if ((((*a).valtype == (int64_t)5) || ((*a).valtype == (int64_t)6))) {
            if (((uint64_t)((*plus)) == '+')) {
                mm_libmcl_asmstr(plus);
            };
            mm_libmcl_strvalue(a);
        } else if (!!((offset = (int64_t)((*a).offset)))) {
            msysnewc_m_print_startstr(str2);
            msysnewc_m_print_i64(offset,(uint8_t*)"+");
            msysnewc_m_print_end();
            ;
            mm_libmcl_asmstr(str2);
        };
        mm_libmcl_asmchar((int64_t)93);
    }else if (((int64_t)((*a).mode)==(int64_t)5)) {
        mm_libmcl_asmstr(mm_libmcl_fgetregname((int64_t)((*a).reg),(int64_t)((*a).size)));
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"BAD OPND",NULL);
        msysnewc_m_print_u64((*a).mode,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_libmcl_asmstr((uint8_t*)"<BAD OPND>");
    };
}

void mm_libmcl_strvalue(struct mm_mcldecls_opndrec * a) {
    static uint8_t str[512];
    uint8_t str2[128];
    struct mm_decls_strec *  def;
    int64_t value;
    int64_t offset;
    def = (*a).def;
    value = (*a).value;
    if (((int64_t)((*a).valtype)==(int64_t)5)) {
        mm_libmcl_asmstr(mm_lib_getfullname(def,(int64_t)0));
        if (((int64_t)((uint64_t)((*def).namecat)) == (int64_t)3)) {
            mm_libmcl_asmchar((int64_t)42);
        };
        //addoffset:
L846 :;
;
        if (!!((offset = (int64_t)((*a).offset)))) {
            msysnewc_m_print_startstr(str2);
            msysnewc_m_print_str(((offset > (int64_t)0)?(uint8_t*)"+":(uint8_t*)""),NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64(offset,NULL);
            msysnewc_m_print_end();
            ;
            mm_libmcl_asmstr(str2);
        };
    }else if (((int64_t)((*a).valtype)==(int64_t)1)) {
        mm_libmcl_asmint(value);
    }else if (((int64_t)((*a).valtype)==(int64_t)2)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_r64((*a).xvalue,NULL);
        msysnewc_m_print_end();
        ;
        mm_libmcl_asmstr(str);
    }else if (((int64_t)((*a).valtype)==(int64_t)3)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_r64((*a).xvalue,NULL);
        msysnewc_m_print_end();
        ;
        mm_libmcl_asmstr(str);
    }else if (((int64_t)((*a).valtype)==(int64_t)4)) {
        mm_libmcl_asmchar((int64_t)34);
        mm_libmcl_asmstr((*a).svalue);
        mm_libmcl_asmchar((int64_t)34);
    }else if (((int64_t)((*a).valtype)==(int64_t)7)) {
        mm_libmcl_asmstr((*a).svalue);
    }else if (((int64_t)((*a).valtype)==(int64_t)8)) {
        mm_libmcl_asmstr((uint8_t*)"XXX");
    }else if (((int64_t)((*a).valtype)==(int64_t)6)) {
        mm_libmcl_asmchar((int64_t)76);
        mm_libmcl_asmint((*a).labelno);
        goto L846 ;
;
    } else {
    };
}

void mm_libmcl_setsegment(int64_t seg,int64_t align) {
    int64_t opc;
    if ((seg != mm_libmcl_currsegment)) {
        if ((seg==(int64_t)73)) {
            opc = (int64_t)115;
        }else if ((seg==(int64_t)90)) {
            opc = (int64_t)116;
        }else if ((seg==(int64_t)67)) {
            opc = (int64_t)117;
        }else if ((seg==(int64_t)82)) {
            mm_support_gerror((uint8_t*)"CAN'T DO RODATA SEG",(struct mm_decls_unitrec *)(0));
        } else {
            mm_support_gerror((uint8_t*)"BAD SEG CODE",(struct mm_decls_unitrec *)(0));
        };
        if ((!!(mm_libmcl_mccodex) && (((*mm_libmcl_mccodex).opcode == (int64_t)115) || ((*mm_libmcl_mccodex).opcode == (int64_t)116) || ((*mm_libmcl_mccodex).opcode == (int64_t)117)))) {
            (*mm_libmcl_mccodex).opcode = (uint64_t)(opc);
        } else {
            mm_libmcl_genmc(opc,(struct mm_mcldecls_opndrec *)(0),(struct mm_mcldecls_opndrec *)(0));
        };
        mm_libmcl_currsegment = seg;
    };
    if ((align != (int64_t)1)) {
        mm_libmcl_genmc((int64_t)118,mm_libmcl_genint_mc(align,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
    };
}

uint8_t * mm_libmcl_getprocname(struct mm_decls_strec * d) {
    return mm_lib_getdottedname(d);
    return (uint8_t*)"";
}

int64_t mm_libmcl_widenstr(uint8_t * s,int64_t w) {
    L847 :;
    while (((int64_t)(strlen((int8_t *)(s))) >= (w - (int64_t)2))) {
        w += (int64_t)8;
L848 :;
    }L849 :;
    ;
    return w;
}

uint8_t * mm_libmcl_strlabel(int64_t n) {
    static uint8_t str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((uint8_t*)"L",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

int64_t mm_libmcl_isframe(struct mm_decls_strec * d) {
    if (((int64_t)((*d).nameid)==(int64_t)10) || ((int64_t)((*d).nameid)==(int64_t)11)) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

uint8_t * mm_libmcl_getsizeprefix(int64_t size,int64_t enable) {
    if (!(!!(enable))) {
        return (uint8_t*)"";
    };
    if ((size==(int64_t)1)) {
        return (uint8_t*)"byte ";
    }else if ((size==(int64_t)2)) {
        return (uint8_t*)"word16 ";
    }else if ((size==(int64_t)4)) {
        return (uint8_t*)"word32 ";
    }else if ((size==(int64_t)8)) {
        return (uint8_t*)"word64 ";
    }else if ((size==(int64_t)16)) {
        return (uint8_t*)"word128 ";
    };
    return (uint8_t*)"";
}

int64_t mm_libmcl_needsizeprefix(int64_t opcode,struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    if ((opcode==(int64_t)15) || (opcode==(int64_t)16) || (opcode==(int64_t)79) || (opcode==(int64_t)80)) {
        return (int64_t)1;
    }else if ((opcode==(int64_t)75) || (opcode==(int64_t)76) || (opcode==(int64_t)77) || (opcode==(int64_t)78)) {
        return (int64_t)1;
    }else if ((opcode==(int64_t)39) || (opcode==(int64_t)41) || (opcode==(int64_t)40)) {
        if (((int64_t)((uint64_t)((*a).mode)) == (int64_t)3)) {
            return (int64_t)1;
        };
        return (int64_t)0;
    };
    if ((((((int64_t)((uint64_t)((*a).mode)) == (int64_t)1) || ((int64_t)((uint64_t)((*a).mode)) == (int64_t)5)) || ((int64_t)((uint64_t)((*b).mode)) == (int64_t)1)) || ((int64_t)((uint64_t)((*b).mode)) == (int64_t)5))) {
        return (int64_t)0;
    };
    return (int64_t)1;
}

struct mm_mcldecls_opndrec * mm_libmcl_changeopndsize(struct mm_mcldecls_opndrec * a,int64_t size) {
    struct mm_mcldecls_opndrec *  b;
    if (((int64_t)((uint64_t)((*a).size)) != size)) {
        if (((int64_t)((uint64_t)((*a).mode)) == (int64_t)1)) {
            b = mm_libmcl_regtable[((int64_t)((*a).reg))-1][(size)-1];
        } else {
            b = mm_libmcl_duplopnd(a);
            (*b).size = (uint64_t)(size);
        };
        return b;
    };
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_applyoffset(struct mm_mcldecls_opndrec * a,int64_t offset,int64_t size) {
    struct mm_mcldecls_opndrec *  b;
    if (((offset == (int64_t)0) && (size == (int64_t)0))) {
        return a;
    };
    b = mm_libmcl_duplopnd(a);
    (*b).offset += (int32_t)(offset);
    if (!!(size)) {
        (*b).size = (uint64_t)(size);
    };
    return b;
}

struct mm_mcldecls_opndrec * mm_libmcl_genint_mc(int64_t x,int64_t size) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)2);
    (*a).value = x;
    (*a).valtype = (uint64_t)((int64_t)1);
    (*a).size = (uint64_t)(size);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genrealmem_mc(double x,int64_t size) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)3);
    (*a).value = mm_libmcl_getrealindex(x,size);
    (*a).valtype = (uint64_t)((int64_t)6);
    (*a).size = (uint64_t)(size);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genrealimm_mc(double x,int64_t size) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)2);
    (*a).xvalue = x;
    (*a).valtype = (uint64_t)((int64_t)2);
    (*a).size = (uint64_t)(size);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genimm(struct mm_decls_unitrec * p,int64_t size) {
    struct mm_mcldecls_opndrec *  a;
    int64_t t;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)2);
    if (((int64_t)((*p).tag)==(int64_t)1)) {
        t = (int64_t)((*p).mode);
        if (!!((uint64_t)(mm_decls_ttisinteger[(t)]))) {
            (*a).value = (*p).value;
            (*a).valtype = (uint64_t)((int64_t)1);
            (*a).size = (!!(size)?(uint64_t)(size):(uint64_t)(mm_decls_ttsize[(t)]));
        } else if (!!((uint64_t)(mm_decls_ttisreal[(t)]))) {
            (*a).xvalue = (*p).xvalue;
            (*a).valtype = (uint64_t)((int64_t)3);
            (*a).size = (!!(size)?(uint64_t)(size):(uint64_t)(mm_decls_ttsize[(t)]));
        } else {
            mm_support_gerror((uint8_t*)"GENIMM/MODE?",(struct mm_decls_unitrec *)(0));
        };
    }else if (((int64_t)((*p).tag)==(int64_t)3)) {
        (*a).def = (*p).def;
        (*a).size = (uint64_t)(mm_decls_ttsize[((int64_t)((*(*p).def).mode))]);
    } else {
        mm_support_gerror((uint8_t*)"genimm/unit",(struct mm_decls_unitrec *)(0));
    };
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genlabel_mc(int64_t x) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).size = (uint64_t)(mm_decls_targetbits);
    (*a).mode = (uint64_t)((int64_t)2);
    (*a).value = x;
    (*a).valtype = (uint64_t)((int64_t)6);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genlabel_mem(int64_t x) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_genlabel_mc(x);
    (*a).mode = (uint64_t)((int64_t)3);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genmem_u_mc(struct mm_decls_unitrec * p,int64_t size) {
    return mm_libmcl_genmem_d_mc((*p).def,(int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]));
}

struct mm_mcldecls_opndrec * mm_libmcl_genmem_d_mc(struct mm_decls_strec * d,int64_t size) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)3);
    if (!!(mm_libmcl_isframe(d))) {
        (*a).reg = (uint64_t)((int64_t)15);
    };
    (*a).def = d;
    (*a).valtype = (uint64_t)((int64_t)5);
    (*a).size = (!!(size)?(uint64_t)(size):(uint64_t)(mm_decls_ttsize[((int64_t)((*d).mode))]));
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genmemaddr_u_mc(struct mm_decls_unitrec * p) {
    return mm_libmcl_genmemaddr_d_mc((*p).def);
}

struct mm_mcldecls_opndrec * mm_libmcl_genmemaddr_d_mc(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)2);
    if (!!(mm_libmcl_isframe(d))) {
        (*a).reg = (uint64_t)((int64_t)15);
    };
    (*a).def = d;
    (*a).valtype = (uint64_t)((int64_t)5);
    (*a).size = (uint64_t)(mm_libmcl_ptrsize);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genreg(int64_t reg,int64_t size) {
    static int64_t isnormal[9] = {(int64_t)0,(int64_t)1,(int64_t)1,(int64_t)0,(int64_t)1,(int64_t)0,(int64_t)0,(int64_t)0,(int64_t)1};
    if (!!((int64_t)1)) {
        return mm_libmcl_regtable[(reg)-1][(size)-1];
    };
    return mm_libmcl_genreg0(reg,size);
}

struct mm_mcldecls_opndrec * mm_libmcl_genreg0(int64_t reg,int64_t size) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)1);
    (*a).reg = (uint64_t)(reg);
    (*a).size = (uint64_t)(size);
    return a;
}

struct mm_mcldecls_opndrec * mm_libmcl_genireg(int64_t reg,int64_t size,int64_t offset) {
    struct mm_mcldecls_opndrec *  a;
    a = mm_libmcl_newmclopnd();
    (*a).mode = (uint64_t)((int64_t)3);
    (*a).reg = (uint64_t)(reg);
    (*a).size = (uint64_t)(size);
    (*a).offset = offset;
    return a;
}

int64_t mm_libmcl_getopndsize_u(struct mm_decls_unitrec * p) {
    return (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
}

int64_t mm_libmcl_getopndsize_d(struct mm_decls_strec * d) {
    return (int64_t)(mm_decls_ttsize[((int64_t)((*d).mode))]);
}

int64_t mm_libmcl_getmclcond(int64_t opc,int64_t m) {
    int64_t signedx;
    signedx = (int64_t)(mm_decls_ttisint[(m)]);
    if ((opc==(int64_t)36)) {
        return (int64_t)4;
    }else if ((opc==(int64_t)37)) {
        return (int64_t)5;
    };
    if (((uint64_t)(mm_decls_ttisreal[(m)]) == (uint64_t)82u)) {
        if ((opc==(int64_t)38)) {
            return (int64_t)16;
        }else if ((opc==(int64_t)39)) {
            return (int64_t)18;
        }else if ((opc==(int64_t)41)) {
            return (int64_t)17;
        }else if ((opc==(int64_t)40)) {
            return (int64_t)19;
        };
    } else {
        if ((opc==(int64_t)38)) {
            return (!!(signedx)?(int64_t)12:(int64_t)2);
        }else if ((opc==(int64_t)39)) {
            return (!!(signedx)?(int64_t)14:(int64_t)6);
        }else if ((opc==(int64_t)41)) {
            return (!!(signedx)?(int64_t)13:(int64_t)3);
        }else if ((opc==(int64_t)40)) {
            return (!!(signedx)?(int64_t)15:(int64_t)7);
        };
    };
    return (int64_t)0;
}

int64_t mm_libmcl_getmclcond_i(int64_t opc) {
    if ((opc==(int64_t)36)) {
        return (int64_t)4;
    }else if ((opc==(int64_t)37)) {
        return (int64_t)5;
    }else if ((opc==(int64_t)38)) {
        return (int64_t)12;
    }else if ((opc==(int64_t)39)) {
        return (int64_t)14;
    }else if ((opc==(int64_t)41)) {
        return (int64_t)13;
    }else if ((opc==(int64_t)40)) {
        return (int64_t)15;
    };
    return (int64_t)0;
}

int64_t mm_libmcl_getmclcond_u(int64_t opc) {
    if ((opc==(int64_t)36)) {
        return (int64_t)4;
    }else if ((opc==(int64_t)37)) {
        return (int64_t)5;
    }else if ((opc==(int64_t)38)) {
        return (int64_t)2;
    }else if ((opc==(int64_t)39)) {
        return (int64_t)6;
    }else if ((opc==(int64_t)41)) {
        return (int64_t)3;
    }else if ((opc==(int64_t)40)) {
        return (int64_t)7;
    };
    return (int64_t)0;
}

int64_t mm_libmcl_roundsizetg(int64_t size) {
    L850 :;
    while (!!((size & (mm_decls_targetsize - (int64_t)1)))) {
        ++size;
L851 :;
    }L852 :;
    ;
    return size;
}

uint8_t * mm_libmcl_getregname(int64_t reg,int64_t size) {
    static uint8_t *  prefix[17] = {
    (uint8_t*)"B",
    (uint8_t*)"W",
    (uint8_t*)"",
    (uint8_t*)"A",
    (uint8_t*)"",
    (uint8_t*)"",
    (uint8_t*)"",
    (uint8_t*)"D",
    (uint8_t*)"",
    (uint8_t*)"",
    (uint8_t*)"",
    (uint8_t*)"",
    (uint8_t*)"",
    (uint8_t*)"",
    (uint8_t*)"",
    (uint8_t*)"Q",
    (uint8_t*)"N"
};
    static uint8_t str[32];
    uint8_t str2[16];
    uint8_t *  rs;
    int64_t size2;
    size2 = size;
    if ((size2 > (int64_t)16)) {
        size2 = (int64_t)17;
    };
    if ((reg==(int64_t)0)) {
        return (uint8_t*)"-";
    }else if ((reg==(int64_t)15)) {
        rs = (uint8_t*)"frame";
    }else if ((reg==(int64_t)16)) {
        rs = (uint8_t*)"stack";
    } else {
        msysnewc_getstrint((reg - (int64_t)1),str2);
        rs = str2;
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str(prefix[(size2)-1],NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(rs,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

uint8_t * mm_libmcl_fgetregname(int64_t reg,int64_t size) {
    static uint8_t str[32];
    if (!!((int64_t)1)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"XMM",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64((reg - (int64_t)1),NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str(((size == (int64_t)8)?(uint8_t*)"DX":(uint8_t*)"SX"),NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64((reg - (int64_t)1),NULL);
        msysnewc_m_print_end();
        ;
    };
    return str;
}

static int64_t mm_libmcl_issimple0(struct mm_decls_unitrec * p) {
    if (((int64_t)((*p).tag)==(int64_t)1) || ((int64_t)((*p).tag)==(int64_t)3)) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

int64_t mm_libmcl_isintconst(struct mm_decls_unitrec * p) {
    if ((((int64_t)((*p).tag) == (int64_t)1) && !!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*p).mode))])))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

int64_t mm_libmcl_isint32const(struct mm_decls_unitrec * p) {
    int64_t a;
    if ((!!(mm_libmcl_isintconst(p)) && ((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) <= (int64_t)8))) {
        a = (*p).value;
        if (((a <= (int64_t)2147483647) && (a >= (int64_t)-2147483648))) {
            return (int64_t)1;
        };
    };
    return (int64_t)0;
}

static int64_t mm_libmcl_sameoperand(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    if (((uint64_t)((*a).mode) != (uint64_t)((*b).mode))) {
        return (int64_t)0;
    };
    if (((uint64_t)((*a).size) != (uint64_t)((*b).size))) {
        return (int64_t)0;
    };
    if (((*a).value != (*b).value)) {
        return (int64_t)0;
    };
    if (((uint64_t)((*a).reg) != (uint64_t)((*b).reg))) {
        return (int64_t)0;
    };
    if (((uint64_t)((*a).regix) != (uint64_t)((*b).regix))) {
        return (int64_t)0;
    };
    if (((uint64_t)((*a).valtype) != (uint64_t)((*b).valtype))) {
        return (int64_t)0;
    };
    if (((uint64_t)((*a).scale) != (uint64_t)((*b).scale))) {
        return (int64_t)0;
    };
    if ((((!!((*a).def) && !!((*b).def)) && ((*a).def == (*b).def)) && ((*a).value == (*b).value))) {
        return (int64_t)1;
    } else if (((((*a).def == 0) && ((*b).def == 0)) && ((*a).value == (*b).value))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

void mm_libmcl_genmsource(int64_t lineno) {
}

int64_t mm_libmcl_roundto(int64_t a,int64_t n) {
    --n;
    L853 :;
    while (!!((a & n))) {
        ++a;
L854 :;
    }L855 :;
    ;
    return a;
}

void mm_libmcl_pushstack_mc(int64_t n) {
    if (!!(n)) {
        mm_libmcl_genmc((int64_t)25,mm_libmcl_dstackopnd,mm_libmcl_genint_mc(n,(int64_t)8));
    };
}

void mm_libmcl_popstack_mc(int64_t n) {
    if (!!(n)) {
        mm_libmcl_genmc((int64_t)24,mm_libmcl_dstackopnd,mm_libmcl_genint_mc(n,(int64_t)8));
    };
}

int64_t mm_libmcl_definelabel_mc(void) {
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(++mm_decls_labelno),(struct mm_mcldecls_opndrec *)(0));
    return mm_decls_labelno;
}

int64_t mm_libmcl_createfwdlabel_mc(void) {
    return ++mm_decls_labelno;
}

void mm_libmcl_definefwdlabel_mc(int64_t lab) {
    mm_libmcl_genmc((int64_t)5,mm_libmcl_genlabel_mc(lab),(struct mm_mcldecls_opndrec *)(0));
}

void mm_libmcl_genjumpl_mc(int64_t lab) {
    mm_libmcl_genmc((int64_t)21,mm_libmcl_genlabel_mc(lab),(struct mm_mcldecls_opndrec *)(0));
}

int64_t mm_libmcl_getstringindex(uint8_t * s,int64_t length) {
    if ((s == 0)) {
        mm_libmcl_kk0used = ++mm_decls_labelno;
        return mm_libmcl_kk0used;
    };
    if ((mm_libmcl_nstrings >= mm_libmcl_stringtablesize)) {
        mm_libmcl_extendstringtable();
    };
    if ((!!(mm_libmcl_nstrings) && !!(mlib_eqstring((*mm_libmcl_stringtable)[(mm_libmcl_nstrings)-1],s)))) {
        return (int64_t)((*mm_libmcl_stringlabtable)[(mm_libmcl_nstrings)-1]);
    };
    (*mm_libmcl_stringtable)[(++mm_libmcl_nstrings)-1] = s;
    (*mm_libmcl_stringlentable)[(mm_libmcl_nstrings)-1] = length;
    (*mm_libmcl_stringlabtable)[(mm_libmcl_nstrings)-1] = ++mm_decls_labelno;
    return mm_decls_labelno;
}

int64_t mm_libmcl_getrealindex(double x,int64_t size) {
    if ((mm_libmcl_nreals >= mm_libmcl_realtablesize)) {
        mm_libmcl_extendrealtable();
    };
    (*mm_libmcl_realtable)[(++mm_libmcl_nreals)-1] = x;
    ++mm_decls_labelno;
    (*mm_libmcl_reallabtable)[(mm_libmcl_nreals)-1] = ((size == (int64_t)8)?mm_decls_labelno:-(mm_decls_labelno));
    return mm_decls_labelno;
}

static void mm_libmcl_extendstringtable(void) {
    uint8_t * (*oldstringtable)[];
    int32_t (*oldstringlentable)[];
    int32_t (*oldstringlabtable)[];
    int64_t oldstringtablesize;
    int64_t i;
    oldstringtablesize = mm_libmcl_stringtablesize;
    oldstringtable = mm_libmcl_stringtable;
    oldstringlentable = mm_libmcl_stringlentable;
    oldstringlabtable = mm_libmcl_stringlabtable;
    mm_libmcl_stringtablesize *= (int64_t)2;
    mm_libmcl_stringtable = (uint8_t * (*)[])(mlib_pcm_alloc(((int64_t)8 * mm_libmcl_stringtablesize)));
    mm_libmcl_stringlentable = (int32_t (*)[])(mlib_pcm_alloc(((int64_t)4 * mm_libmcl_stringtablesize)));
    mm_libmcl_stringlabtable = (int32_t (*)[])(mlib_pcm_alloc(((int64_t)4 * mm_libmcl_stringtablesize)));
    L856 :;
    for (i=(int64_t)1;i<=mm_libmcl_nstrings;i+=(int64_t)1) {
L857 :;
        (*mm_libmcl_stringtable)[(i)-1] = (*oldstringtable)[(i)-1];
        (*mm_libmcl_stringlentable)[(i)-1] = (int64_t)((*oldstringlentable)[(i)-1]);
        (*mm_libmcl_stringlabtable)[(i)-1] = (int64_t)((*oldstringlabtable)[(i)-1]);
L858 :;
    }L859 :;
    ;
    mlib_pcm_free((void *)(oldstringtable),((int64_t)8 * oldstringtablesize));
    mlib_pcm_free((void *)(oldstringlentable),((int64_t)4 * oldstringtablesize));
    mlib_pcm_free((void *)(oldstringlabtable),((int64_t)4 * oldstringtablesize));
}

static void mm_libmcl_extendrealtable(void) {
    double (*oldrealtable)[];
    int32_t (*oldreallabtable)[];
    int64_t oldrealtablesize;
    int64_t i;
    oldrealtablesize = mm_libmcl_realtablesize;
    oldrealtable = mm_libmcl_realtable;
    oldreallabtable = mm_libmcl_reallabtable;
    mm_libmcl_realtablesize *= (int64_t)2;
    mm_libmcl_realtable = (double (*)[])(mlib_pcm_alloc(((int64_t)8 * mm_libmcl_realtablesize)));
    mm_libmcl_reallabtable = (int32_t (*)[])(mlib_pcm_alloc(((int64_t)4 * mm_libmcl_realtablesize)));
    L860 :;
    for (i=(int64_t)1;i<=mm_libmcl_nreals;i+=(int64_t)1) {
L861 :;
        (*mm_libmcl_realtable)[(i)-1] = (*oldrealtable)[(i)-1];
        (*mm_libmcl_reallabtable)[(i)-1] = (int64_t)((*oldreallabtable)[(i)-1]);
L862 :;
    }L863 :;
    ;
    mlib_pcm_free((void *)(oldrealtable),((int64_t)8 * oldrealtablesize));
    mlib_pcm_free((void *)(oldreallabtable),((int64_t)4 * oldrealtablesize));
}

void mm_libmcl_genmc_loadint_d8(int64_t a) {
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genint_mc(a,(int64_t)8));
}

void mm_libmcl_genmc_loadint_d16(uint64_t low,uint64_t high) {
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genint_mc((int64_t)(low),(int64_t)8));
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genint_mc((int64_t)(high),(int64_t)8));
}

void mm_libmcl_genmc_loadint_vari64(int64_t a) {
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genint_mc((int64_t)1,(int64_t)8));
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genint_mc(a,(int64_t)8));
}

void mm_libmcl_genmc_loadword_d8(uint64_t a) {
    mm_support_gerror((uint8_t*)"MC/PUSHWORD",(struct mm_decls_unitrec *)(0));
}

void mm_libmcl_genmc_loadreal_d8(double x) {
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genrealmem_mc(x,(int64_t)8));
}

void mm_libmcl_genmc_loadreal_d4(double x) {
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genrealmem_mc(x,(int64_t)4));
}

void mm_libmcl_genmc_loadreal_x8(double x) {
    mm_libmcl_genmc((int64_t)14,mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genrealmem_mc(x,(int64_t)8));
}

void mm_libmcl_genmc_loadreal_x4(double x) {
    mm_libmcl_genmc((int64_t)13,mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8),mm_libmcl_genrealmem_mc(x,(int64_t)4));
}

void mm_libmcl_genmc_loadmem_d8(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genmem_d_mc(d,(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_loadmem_d16(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax1;
    struct mm_mcldecls_opndrec *  ax2;
    struct mm_mcldecls_opndrec *  bx;
    ax1 = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    ax2 = mm_libmcl_genreg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genmem_d_mc(d,(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax1,bx);
    mm_libmcl_genmc((int64_t)8,ax2,mm_libmcl_applyoffset(bx,(int64_t)8,(int64_t)0));
}

void mm_libmcl_genmc_loadmem_x8(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    if (((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) != (uint64_t)70u)) {
        mm_support_gerror((uint8_t*)"LOADMEM/X8 REG NOT 'F'",(struct mm_decls_unitrec *)(0));
    };
    ax = mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genmem_d_mc(d,(int64_t)8);
    mm_libmcl_genmc((int64_t)14,ax,bx);
}

void mm_libmcl_genmc_loadmem_x4(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    if (((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) != (uint64_t)70u)) {
        mm_support_gerror((uint8_t*)"LOADMEM/X4 REG NOT 'F'",(struct mm_decls_unitrec *)(0));
    };
    ax = mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genmem_d_mc(d,(int64_t)4);
    mm_libmcl_genmc((int64_t)13,ax,bx);
}

void mm_libmcl_genmc_loadmem_d124(struct mm_decls_strec * d,int64_t m) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    int64_t size;
    size = (int64_t)(mm_decls_ttsize[(m)]);
    ax = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),size);
    bx = mm_libmcl_genmem_d_mc(d,size);
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_loadmemaddr(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genmem_d_mc(d,(int64_t)8);
    mm_libmcl_genmc((int64_t)11,ax,bx);
}

void mm_libmcl_genmc_loadptr_d8(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genireg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8,offset);
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_loadptr_d16(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax1;
    struct mm_mcldecls_opndrec *  ax2;
    struct mm_mcldecls_opndrec *  px;
    int64_t reg1;
    int64_t reg2;
    reg1 = (int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    reg2 = mm_libmcl_getnextreg();
    ax1 = mm_libmcl_genreg(reg1,(int64_t)8);
    ax2 = mm_libmcl_genreg(reg2,(int64_t)8);
    px = mm_libmcl_genireg(reg1,(int64_t)8,offset);
    mm_libmcl_genmc((int64_t)8,ax2,mm_libmcl_applyoffset(px,(int64_t)8,(int64_t)0));
    mm_libmcl_genmc((int64_t)8,ax1,px);
    mm_libmcl_opndreg2[(mm_libmcl_noperands)-1] = (uint64_t)(reg2);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)87u;
}

void mm_libmcl_genmc_storeptr_d8(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genireg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8,offset);
    bx = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_storeptr_d16(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx1;
    struct mm_mcldecls_opndrec *  bx2;
    ax = mm_libmcl_genireg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8,offset);
    bx1 = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1]),(int64_t)8);
    bx2 = mm_libmcl_genreg((int64_t)(mm_libmcl_opndreg2[((mm_libmcl_noperands - (int64_t)1))-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,bx1);
    mm_libmcl_genmc((int64_t)8,mm_libmcl_applyoffset(ax,(int64_t)8,(int64_t)0),bx2);
}

void mm_libmcl_genmc_storeptr_x8(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genireg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8,offset);
    bx = mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)14,ax,bx);
}

void mm_libmcl_genmc_storeptr_x4(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genireg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)4,offset);
    bx = mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1]),(int64_t)4);
    mm_libmcl_genmc((int64_t)13,ax,bx);
}

void mm_libmcl_genmc_loadptr_d124(int64_t m,int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    struct mm_mcldecls_opndrec *  fx;
    ax = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genireg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)(mm_decls_ttsize[(m)]),offset);
    if ((m==(int64_t)1) || (m==(int64_t)2) || (m==(int64_t)3)) {
        mm_libmcl_genmc((int64_t)15,ax,bx);
    }else if ((m==(int64_t)6) || (m==(int64_t)7) || (m==(int64_t)8) || (m==(int64_t)13) || (m==(int64_t)14)) {
        mm_libmcl_genmc((int64_t)16,ax,bx);
    }else if ((m==(int64_t)11)) {
        fx = mm_libmcl_genxreg((int64_t)16,(int64_t)8);
        mm_libmcl_genmc((int64_t)13,fx,bx);
        mm_libmcl_genmc((int64_t)82,fx,bx);
        mm_libmcl_genmc((int64_t)14,ax,fx);
    } else {
        mm_support_gerror((uint8_t*)"LOADPTR-D124?",(struct mm_decls_unitrec *)(0));
    };
}

void mm_libmcl_genmc_storeptr_d124(int64_t m,int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genireg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)(mm_decls_ttsize[(m)]),offset);
    bx = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - (int64_t)1))-1]),(int64_t)(mm_decls_ttsize[(m)]));
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_floadmem(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx = mm_libmcl_genmem_d_mc(d,(int64_t)8);
    mm_libmcl_genmc((int64_t)14,ax,bx);
}

void mm_libmcl_genmc_loadmemw(struct mm_decls_strec * d) {
    mm_support_gerror((uint8_t*)"MC/PUSHMEMW",(struct mm_decls_unitrec *)(0));
}

void mm_libmcl_genmc_loadstr(uint8_t * s,int64_t length) {
    struct mm_mcldecls_opndrec *  ax;
    ax = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,mm_libmcl_genlabel_mc(mm_libmcl_getstringindex(s,length)));
}

void mm_libmcl_pushalloperands(void) {
    int64_t reg;
    int64_t reg2;
    int64_t i;
    int64_t r;
    L864 :;
    for (i=(int64_t)1;i<=mm_libmcl_noperands;i+=(int64_t)1) {
L865 :;
        reg = (int64_t)(mm_libmcl_opndstack[(i)-1]);
        if ((reg == (int64_t)0)) {
            goto L866 ;
        };
        if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)73)) {
            mm_libmcl_genmc((int64_t)9,mm_libmcl_genreg(reg,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_regset[(reg)-1] = (uint64_t)((int64_t)0);
        }else if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)70)) {
            mm_libmcl_genmc((int64_t)14,mm_libmcl_genreg((int64_t)14,(int64_t)8),mm_libmcl_genxreg(reg,(int64_t)8));
            mm_libmcl_genmc((int64_t)9,mm_libmcl_genreg((int64_t)14,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_xregset[(reg)-1] = (uint64_t)((int64_t)0);
        }else if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)87)) {
            mm_libmcl_genmc((int64_t)9,mm_libmcl_genreg((reg2 = (int64_t)(mm_libmcl_opndreg2[(i)-1])),(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_genmc((int64_t)9,mm_libmcl_genreg(reg,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
            mm_libmcl_opndreg2[(i)-1] = (uint64_t)((int64_t)0);
            mm_libmcl_regset[(reg)-1] = (uint64_t)((int64_t)0);
            mm_libmcl_regset[(reg2)-1] = (uint64_t)((int64_t)0);
        };
        mm_libmcl_opndstack[(i)-1] = (uint64_t)((int64_t)0);
L866 :;
    }L867 :;
    ;
    L868 :;
    for (r=(int64_t)1;r<=(int64_t)9;r+=(int64_t)1) {
L869 :;
        if ((!!((uint64_t)(mm_libmcl_regset[(r)-1])) || !!((uint64_t)(mm_libmcl_xregset[(r)-1])))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"REGS STILL IN USE AFTER PUSHALL",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_libmcl_gencomment_mc((uint8_t*)"REGS STILL IN USE AFTER PUSHALL");
        };
L870 :;
    }L871 :;
    ;
}

void mm_libmcl_newopnd_d8(void) {
    int64_t reg;
    if ((mm_libmcl_noperands >= (int64_t)100)) {
        mm_libmcl_gerrorc((uint8_t*)"newopnd_d8:opstack overflow");
        return;
    };
    reg = mm_libmcl_getnextreg();
    ++mm_libmcl_noperands;
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)(reg);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
}

void mm_libmcl_newopnd_d16(void) {
    int64_t reg1;
    int64_t reg2;
    if ((mm_libmcl_noperands >= (int64_t)100)) {
        mm_libmcl_gerrorc((uint8_t*)"newopnd_d16:opstack overflow");
        return;
    };
    mm_libmcl_checktwofreeregs();
    reg1 = mm_libmcl_getnextreg();
    reg2 = mm_libmcl_getnextreg();
    ++mm_libmcl_noperands;
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)(reg1);
    mm_libmcl_opndreg2[(mm_libmcl_noperands)-1] = (uint64_t)(reg2);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)87u;
}

void mm_libmcl_newopnd_x8(void) {
    int64_t reg;
    if ((mm_libmcl_noperands >= (int64_t)100)) {
        mm_libmcl_gerrorc((uint8_t*)"newopnd_x8:opstack overflow");
        return;
    };
    reg = mm_libmcl_getnextxreg();
    ++mm_libmcl_noperands;
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)(reg);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)70u;
}

void mm_libmcl_newstackopnd_d8(void) {
    mm_libmcl_pushalloperands();
    mm_libmcl_newopnd_d8();
    mm_libmcl_pushstack_mc((int64_t)8);
    mm_libmcl_regset[((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]))-1] = (uint64_t)((int64_t)0);
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)0);
}

void mm_libmcl_newstackopnd_d16(void) {
    mm_libmcl_pushalloperands();
    mm_libmcl_newopnd_d16();
    mm_libmcl_pushstack_mc((int64_t)16);
    mm_libmcl_regset[((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]))-1] = (uint64_t)((int64_t)0);
    mm_libmcl_regset[((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]))-1] = (uint64_t)((int64_t)0);
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)0);
}

void mm_libmcl_newstackopnd_var(void) {
    mm_libmcl_pushalloperands();
    mm_libmcl_newstackopnd_d8();
}

void mm_libmcl_newstackopnd_x8(void) {
    mm_libmcl_pushalloperands();
    mm_libmcl_newopnd_x8();
    mm_libmcl_pushstack_mc((int64_t)8);
    mm_libmcl_xregset[((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]))-1] = (uint64_t)((int64_t)0);
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)0);
}

void mm_libmcl_genmc_storemem_d8(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genmem_d_mc(d,(int64_t)8);
    bx = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_storemem_d16(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx1;
    struct mm_mcldecls_opndrec *  bx2;
    ax = mm_libmcl_genmem_d_mc(d,(int64_t)8);
    bx1 = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx2 = mm_libmcl_genreg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,bx1);
    mm_libmcl_genmc((int64_t)8,mm_libmcl_applyoffset(ax,(int64_t)8,(int64_t)0),bx2);
}

void mm_libmcl_genmc_storemem_x8(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genmem_d_mc(d,(int64_t)8);
    bx = mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)14,ax,bx);
}

void mm_libmcl_genmc_storemem_x4(struct mm_decls_strec * d) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genmem_d_mc(d,(int64_t)4);
    bx = mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)13,ax,bx);
}

void mm_libmcl_genmc_storemem_d124(struct mm_decls_strec * d,int64_t m) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genmem_d_mc(d,(int64_t)(mm_decls_ttsize[(m)]));
    bx = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)(mm_decls_ttsize[(m)]));
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_storeretval_d8(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    if (((mm_libpcl_framebytes == (int64_t)0) && (mm_libpcl_parambytes == (int64_t)0))) {
        ax = mm_libmcl_genireg((int64_t)16,(int64_t)8,(int64_t)0);
        (*ax).offset = (offset + (int64_t)8);
    } else {
        ax = mm_libmcl_genireg((int64_t)15,(int64_t)8,(int64_t)0);
        (*ax).offset = (offset + (int64_t)16);
    };
    bx = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_storeretval_d16_var(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx1;
    struct mm_mcldecls_opndrec *  bx2;
    if (((mm_libpcl_framebytes == (int64_t)0) && (mm_libpcl_parambytes == (int64_t)0))) {
        ax = mm_libmcl_genireg((int64_t)16,(int64_t)8,(int64_t)0);
        (*ax).offset = (offset + (int64_t)8);
    } else {
        ax = mm_libmcl_genireg((int64_t)15,(int64_t)8,(int64_t)0);
        (*ax).offset = (offset + (int64_t)16);
    };
    bx1 = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    bx2 = mm_libmcl_genreg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)8,ax,bx1);
    mm_libmcl_genmc((int64_t)8,mm_libmcl_applyoffset(ax,(int64_t)8,(int64_t)0),bx2);
}

void mm_libmcl_genmc_storeretval_x8(int64_t offset) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genireg((int64_t)15,(int64_t)8,(int64_t)0);
    (*ax).offset = (offset + (int64_t)16);
    bx = mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)8);
    mm_libmcl_genmc((int64_t)14,ax,bx);
}

void mm_libmcl_genmc_storememx(struct mm_decls_strec * d,int64_t m) {
    struct mm_mcldecls_opndrec *  ax;
    struct mm_mcldecls_opndrec *  bx;
    ax = mm_libmcl_genmem_d_mc(d,(int64_t)(mm_decls_ttsize[(m)]));
    bx = mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]),(int64_t)(mm_decls_ttsize[(m)]));
    mm_libmcl_genmc((int64_t)8,ax,bx);
}

void mm_libmcl_genmc_storememw(struct mm_decls_strec * d) {
    mm_support_gerror((uint8_t*)"MC/STOREMEMW",(struct mm_decls_unitrec *)(0));
}

void mm_libmcl_getopnds(int64_t n) {
    int64_t reg;
    struct mm_mcldecls_opndrec *  ax;
    int64_t av_1;
    int64_t i;
    if ((n > mm_libmcl_noperands)) {
        mm_libmcl_gerrorc((uint8_t*)"getopnds stack underflow");
    };
    L872 :;
    for (i=mm_libmcl_noperands;i>=((mm_libmcl_noperands - n) + (int64_t)1);i-=(int64_t)1) {
L873 :;
        if (((int64_t)((uint64_t)(mm_libmcl_opndstack[(i)-1])) == (int64_t)0)) {
            if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)73)) {
                reg = mm_libmcl_getnextreg();
                mm_libmcl_genmc((int64_t)10,mm_libmcl_genreg(reg,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
                mm_libmcl_opndstack[(i)-1] = (uint64_t)(reg);
            }else if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)87)) {
                reg = mm_libmcl_getnextreg();
                mm_libmcl_genmc((int64_t)10,mm_libmcl_genreg(reg,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
                mm_libmcl_opndstack[(i)-1] = (uint64_t)(reg);
                reg = mm_libmcl_getnextreg();
                mm_libmcl_genmc((int64_t)10,mm_libmcl_genreg(reg,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
                mm_libmcl_opndreg2[(i)-1] = (uint64_t)(reg);
            }else if (((int64_t)(mm_libmcl_opndkind[(i)-1])==(int64_t)70)) {
                reg = mm_libmcl_getnextxreg();
                ax = mm_libmcl_genreg((int64_t)14,(int64_t)8);
                mm_libmcl_genmc((int64_t)10,ax,(struct mm_mcldecls_opndrec *)(0));
                mm_libmcl_genmc((int64_t)14,mm_libmcl_genxreg(reg,(int64_t)8),ax);
                mm_libmcl_opndstack[(i)-1] = (uint64_t)(reg);
                mm_libmcl_opndkind[(i)-1] = (uint64_t)70u;
            } else {
                mm_support_gerror((uint8_t*)"getopnds/block?",(struct mm_decls_unitrec *)(0));
            };
        };
L874 :;
    }L875 :;
    ;
}

void mm_libmcl_getopndn_d8(int64_t n) {
    int64_t reg;
    int64_t nopnd;
    nopnd = (mm_libmcl_noperands - n);
    if ((n < (int64_t)1)) {
        mm_libmcl_gerrorc((uint8_t*)"n:opstack underflow2");
        return;
    };
    reg = (int64_t)(mm_libmcl_opndstack[(nopnd)-1]);
    if ((reg == (int64_t)0)) {
        reg = mm_libmcl_getnextreg();
        mm_libmcl_genmc((int64_t)10,mm_libmcl_genreg(reg,(int64_t)8),(struct mm_mcldecls_opndrec *)(0));
        mm_libmcl_opndstack[(nopnd)-1] = (uint64_t)(reg);
        mm_libmcl_opndkind[(nopnd)-1] = (uint64_t)73u;
    };
}

void mm_libmcl_popopnd(void) {
    int64_t reg;
    if ((mm_libmcl_noperands <= (int64_t)0)) {
        mm_libmcl_gerrorc((uint8_t*)"NO OPS: popopnd");
        return;
    };
    reg = (int64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1]);
    if (((int64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1])==(int64_t)73)) {
        if ((reg == (int64_t)0)) {
            mm_libmcl_popstack_mc((int64_t)8);
        } else {
            mm_libmcl_freereg(reg);
        };
    }else if (((int64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1])==(int64_t)70)) {
        if ((reg == (int64_t)0)) {
            mm_libmcl_popstack_mc((int64_t)8);
        } else {
            mm_libmcl_freexreg(reg);
        };
    }else if (((int64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1])==(int64_t)87)) {
        if ((reg == (int64_t)0)) {
            mm_libmcl_popstack_mc((int64_t)16);
        } else {
            mm_libmcl_freereg(reg);
            mm_libmcl_freereg((int64_t)(mm_libmcl_opndreg2[(mm_libmcl_noperands)-1]));
        };
    }else if (((int64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1])==(int64_t)66)) {
        mm_support_gerror((uint8_t*)"popopnds/B?",(struct mm_decls_unitrec *)(0));
    };
    --mm_libmcl_noperands;
}

void mm_libmcl_poparg(void) {
    if ((mm_libmcl_noperands <= (int64_t)0)) {
        mm_support_gerror((uint8_t*)"poparg?",(struct mm_decls_unitrec *)(0));
    };
    if (((int64_t)((uint64_t)(mm_libmcl_opndstack[(mm_libmcl_noperands)-1])) != (int64_t)0)) {
        mm_support_gerror((uint8_t*)"poparg/arg not on stack",(struct mm_decls_unitrec *)(0));
    };
    --mm_libmcl_noperands;
}

void mm_libmcl_newretvalopnd_d8(void) {
    mm_libmcl_regset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
    ++mm_libmcl_noperands;
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)1);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)73u;
}

void mm_libmcl_newretvalopnd_d16(void) {
    mm_libmcl_regset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
    mm_libmcl_regset[((int64_t)2)-1] = (uint64_t)((int64_t)1);
    ++mm_libmcl_noperands;
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)1);
    mm_libmcl_opndreg2[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)2);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)87u;
}

void mm_libmcl_newretvalopnd_x8(void) {
    mm_libmcl_xregset[((int64_t)1)-1] = (uint64_t)((int64_t)1);
    ++mm_libmcl_noperands;
    mm_libmcl_opndstack[(mm_libmcl_noperands)-1] = (uint64_t)((int64_t)1);
    mm_libmcl_opndkind[(mm_libmcl_noperands)-1] = (uint64_t)70u;
}

int64_t mm_libmcl_getnextreg(void) {
    int64_t av_1;
    int64_t r;
    av_1 = (int64_t)2;
    while (av_1-- > 0) {
L876 :;
        L879 :;
        for (r=(int64_t)1;r<=(int64_t)9;r+=(int64_t)1) {
L880 :;
            if (((int64_t)((uint64_t)(mm_libmcl_regset[(r)-1])) == (int64_t)0)) {
                mm_libmcl_regset[(r)-1] = (uint64_t)((int64_t)1);
                return r;
            };
L881 :;
        }L882 :;
        ;
        mm_libmcl_pushalloperands();
L877 :;
    }L878 :;
    ;
    mm_support_gerror((uint8_t*)"NO FREE REGS",(struct mm_decls_unitrec *)(0));
    return r;
}

void mm_libmcl_checktwofreeregs(void) {
    int64_t count;
    int64_t r;
    count = (int64_t)0;
    L883 :;
    for (r=(int64_t)1;r<=(int64_t)9;r+=(int64_t)1) {
L884 :;
        if (((int64_t)((uint64_t)(mm_libmcl_regset[(r)-1])) == (int64_t)0)) {
            if ((++count >= (int64_t)2)) {
                return;
            };
        };
L885 :;
    }L886 :;
    ;
    mm_libmcl_pushalloperands();
}

static int64_t mm_libmcl_getnexttempreg(void) {
    int64_t r;
    L887 :;
    for (r=(int64_t)1;r<=(int64_t)9;r+=(int64_t)1) {
L888 :;
        if (((int64_t)((uint64_t)(mm_libmcl_regset[(r)-1])) == (int64_t)0)) {
            mm_libmcl_regset[(r)-1] = (uint64_t)((int64_t)1);
            return r;
        };
L889 :;
    }L890 :;
    ;
    mm_support_gerror((uint8_t*)"No temp reg",(struct mm_decls_unitrec *)(0));
    return (int64_t)0;
}

static int64_t mm_libmcl_getnexttempxreg(void) {
    int64_t r;
    L891 :;
    for (r=(int64_t)1;r<=(int64_t)7;r+=(int64_t)1) {
L892 :;
        if (((int64_t)((uint64_t)(mm_libmcl_xregset[(r)-1])) == (int64_t)0)) {
            mm_libmcl_xregset[(r)-1] = (uint64_t)((int64_t)1);
            return r;
        };
L893 :;
    }L894 :;
    ;
    mm_support_gerror((uint8_t*)"No temp xreg",(struct mm_decls_unitrec *)(0));
    return (int64_t)0;
}

static int64_t mm_libmcl_getnextxreg(void) {
    int64_t xr;
    L895 :;
    while (1) {
        L897 :;
        for (xr=(int64_t)1;xr<=(int64_t)7;xr+=(int64_t)1) {
L898 :;
            if (((int64_t)((uint64_t)(mm_libmcl_xregset[(xr)-1])) == (int64_t)0)) {
                mm_libmcl_xregset[(xr)-1] = (uint64_t)((int64_t)1);
                return xr;
            };
L899 :;
        }L900 :;
        ;
        mm_libmcl_pushalloperands();
    }L896 :;
    ;
    return (int64_t)0;
}

void mm_libmcl_freereg(int64_t r) {
    mm_libmcl_regset[(r)-1] = (uint64_t)((int64_t)0);
}

void mm_libmcl_freexreg(int64_t xr) {
    mm_libmcl_xregset[(xr)-1] = (uint64_t)((int64_t)0);
}

void mm_libmcl_gerrorc(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_libmcl_gencomment_mc(mess);
}

struct mm_mcldecls_opndrec * mm_libmcl_genopndind(int64_t offset,int64_t size) {
    return mm_libmcl_genireg((int64_t)(mm_libmcl_opndstack[((mm_libmcl_noperands - offset))-1]),size,(int64_t)0);
}

struct mm_mcldecls_opndrec * mm_libmcl_gettempopnd_d8(void) {
    return mm_libmcl_genreg(mm_libmcl_getnexttempreg(),(int64_t)8);
}

void mm_libmcl_freetempopnd_d8(struct mm_mcldecls_opndrec * p) {
    mm_libmcl_freereg((int64_t)((*p).reg));
}

int64_t mm_libmcl_gettempreg_d8(void) {
    return mm_libmcl_getnexttempreg();
}

void mm_libmcl_freetempreg_d8(int64_t reg) {
    mm_libmcl_freereg(reg);
}

struct mm_mcldecls_opndrec * mm_libmcl_gettempopnd_x8(void) {
    return mm_libmcl_genxreg(mm_libmcl_getnexttempxreg(),(int64_t)8);
}

void mm_libmcl_freetempopnd_x8(struct mm_mcldecls_opndrec * p) {
    mm_libmcl_freexreg((int64_t)((*p).reg));
}

void mm_libmcl_swapopnds(int64_t m,int64_t n) {
    int64_t i;
    int64_t j;
    i = mm_libmcl_noperands;
    j = ((mm_libmcl_noperands - n) + (int64_t)1);
    {byte temp = mm_libmcl_opndstack[(i)-1]; mm_libmcl_opndstack[(i)-1] = mm_libmcl_opndstack[(j)-1]; mm_libmcl_opndstack[(j)-1] = temp; };
    {byte temp = mm_libmcl_opndreg2[(i)-1]; mm_libmcl_opndreg2[(i)-1] = mm_libmcl_opndreg2[(j)-1]; mm_libmcl_opndreg2[(j)-1] = temp; };
    {byte temp = mm_libmcl_opndsize[(i)-1]; mm_libmcl_opndsize[(i)-1] = mm_libmcl_opndsize[(j)-1]; mm_libmcl_opndsize[(j)-1] = temp; };
    {byte temp = mm_libmcl_opndkind[(i)-1]; mm_libmcl_opndkind[(i)-1] = mm_libmcl_opndkind[(j)-1]; mm_libmcl_opndkind[(j)-1] = temp; };
}

void mm_libmcl_dupltop(void) {
    mm_libmcl_getopnds((int64_t)1);
    if (((uint64_t)(mm_libmcl_opndkind[(mm_libmcl_noperands)-1]) != (uint64_t)73u)) {
        mm_support_gerror((uint8_t*)"dupltop?",(struct mm_decls_unitrec *)(0));
    };
    mm_libmcl_newopnd_d8();
    mm_libmcl_genmc((int64_t)8,mm_libmcl_genopnd((int64_t)0,(int64_t)8),mm_libmcl_genopnd((int64_t)1,(int64_t)8));
}

struct mm_mcldecls_opndrec * mm_libmcl_genopnd(int64_t offset,int64_t size) {
    int64_t index;
    index = (mm_libmcl_noperands - offset);
    if (((int64_t)(mm_libmcl_opndkind[(index)-1])==(int64_t)73)) {
        return mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(index)-1]),size);
    }else if (((int64_t)(mm_libmcl_opndkind[(index)-1])==(int64_t)70)) {
        return mm_libmcl_genxreg((int64_t)(mm_libmcl_opndstack[(index)-1]),size);
    }else if (((int64_t)(mm_libmcl_opndkind[(index)-1])==(int64_t)87)) {
        return mm_libmcl_genreg((int64_t)(mm_libmcl_opndstack[(index)-1]),size);
    } else {
        mm_support_gerror((uint8_t*)"genopnd/bad kind2",(struct mm_decls_unitrec *)(0));
        return (struct mm_mcldecls_opndrec *)(0);
    };
}

struct mm_mcldecls_opndrec * mm_libmcl_genopndh(int64_t offset) {
    return mm_libmcl_genreg((int64_t)(mm_libmcl_opndreg2[((mm_libmcl_noperands - offset))-1]),(int64_t)8);
}

struct mm_mcldecls_opndrec * mm_libmcl_genopndindh(int64_t offset,int64_t size) {
    return mm_libmcl_genireg((int64_t)(mm_libmcl_opndreg2[((mm_libmcl_noperands - offset))-1]),size,(int64_t)0);
}

static void mm_libmcl_asmstr(uint8_t * s) {
    mlib_gs_str(mm_lib_dest,s);
}

static void mm_libmcl_asmchar(int64_t c) {
    mlib_gs_char(mm_lib_dest,c);
}

static void mm_libmcl_asmint(int64_t a) {
    mlib_gs_strint(mm_lib_dest,a);
}

void mm_libmcl_checkmcl(uint8_t * caption) {
    struct mm_mcldecls_mclrec *  m;
    int64_t index;
    index = (int64_t)0;
    m = mm_libmcl_mccode;
    L901 :;
    while (!!(m)) {
        ++index;
        if (((int64_t)((uint64_t)((*m).opcode)) > (int64_t)143)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(caption,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)": BAD MCL OPCODE:",NULL);
            msysnewc_m_print_u64((*m).opcode,NULL);
            msysnewc_m_print_str((uint8_t*)"LINE:",NULL);
            msysnewc_m_print_i64(((*m).lineno & (int64_t)16777215),NULL);
            msysnewc_m_print_str((uint8_t*)"INDEX:",NULL);
            msysnewc_m_print_i64(index,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            exit(0);
            exit(0);
        };
        m = (*m).nextmcl;
L902 :;
    }L903 :;
    ;
}

void ma_genss_genss(void) {
    int64_t index;
    struct mm_mcldecls_mclrec *  m;
    ma_lib_initlib(mm_decls_labelno);
    ma_decls_ss_zdatalen = (int64_t)0;
    ma_decls_ss_zdata = ma_lib_buffercreate((int64_t)1024);
    ma_decls_ss_idata = ma_lib_buffercreate((int64_t)1024);
    ma_decls_ss_code = ma_lib_buffercreate((int64_t)1024);
    ma_decls_ss_idatarelocs = (struct ma_decls_relocrec *)(0);
    ma_decls_ss_coderelocs = (struct ma_decls_relocrec *)(0);
    ma_decls_ss_nsymbols = (int64_t)0;
    ma_genss_switchseg((int64_t)1);
    mm_decls_alineno = (int64_t)9999;
    ma_genss_extraparam = (struct mm_mcldecls_opndrec *)(0);
    m = mm_libmcl_mccode;
    index = (int64_t)0;
    L904 :;
    while (!!(m)) {
        mm_decls_alineno = ((*m).lineno & (int64_t)16777215);
        ma_genss_doinstr(m,++index);
        m = (*m).nextmcl;
L905 :;
    }L906 :;
    ;
    ma_genss_switchseg((int64_t)0);
    if (!!(ma_lib_bufferlength(ma_decls_ss_zdata))) {
        mm_support_axerror((uint8_t*)"Zdata contains code or data");
    };
}

static void ma_genss_doinstr(struct mm_mcldecls_mclrec * m,int64_t index) {
    struct mm_mcldecls_opndrec *  a;
    struct mm_mcldecls_opndrec *  b;
    struct mm_decls_strec *  d;
    int64_t x;
    int64_t offset;
    int64_t shortjmp;
    int64_t n;
    int64_t av_1;
    int64_t av_2;
    ma_lib_buffercheck(ma_genss_currdata,(int64_t)1024);
    ma_genss_rex = (ma_genss_sizeoverride = (ma_genss_addroverride = (ma_genss_f2override = (ma_genss_f3override = (int64_t)0))));
    a = (*m).a;
    b = (*m).b;
    ++ma_genss_instrno;
    mm_decls_alineno = ma_genss_instrno;
    if (((int64_t)((*m).opcode)==(int64_t)1) || ((int64_t)((*m).opcode)==(int64_t)2)) {
        return;
    };
    ma_genss_currmcl = m;
    switch ((int64_t)((*m).opcode)) {
    case 3:;
    {
        if (((int64_t)((*a).valtype)==(int64_t)4)) {
        }else if (((int64_t)((*a).valtype)==(int64_t)5)) {
            d = (*a).def;
            (*d).reftype = (uint64_t)((int64_t)2);
            (*d).segment = (uint64_t)(ma_genss_currseg);
            (*d).offset = ma_genss_getcurrdatalen((int64_t)6);
            if (!!((uint64_t)((*d).isglobal))) {
                ma_genss_getstindex(d);
            };
            ma_genss_dofwdrefs(d);
        };
    }break;
    case 5:;
    {
        d = (*ma_decls_labeldeftable)[((*a).labelno)-1];
        (*d).reftype = (uint64_t)((int64_t)2);
        (*d).segment = (uint64_t)(ma_genss_currseg);
        (*d).offset = ma_genss_getcurrdatalen((int64_t)6);
        ma_genss_dofwdrefs(d);
    }break;
    case 18:;
    {
        ma_genss_do_call(a);
    }break;
    case 21:;
    {
        ma_genss_do_jmp(a,m);
    }break;
    case 22:;
    {
        d = ma_genss_getdef(a,(int64_t)1);
        offset = ma_genss_getrel32(d,(ma_genss_getcurrdatalen((int64_t)7) + (int64_t)1));
        if ((offset < (int64_t)0)) {
            if ((offset < (int64_t)-126)) {
                ma_genss_genbyte((int64_t)15);
                ma_genss_genbyte(((int64_t)128 + (int64_t)((uint64_t)((*m).cond))));
                ma_genss_gendword((offset - (int64_t)4));
            } else {
                ma_genss_genbyte(((int64_t)112 + (int64_t)((uint64_t)((*m).cond))));
                ma_genss_genbyte(offset);
            };
        } else {
            shortjmp = ma_genss_checkshortjump(m,d);
            if (!(!!(shortjmp))) {
                ma_genss_genbyte((int64_t)15);
                ma_genss_genbyte(((int64_t)128 + (int64_t)((uint64_t)((*m).cond))));
                ma_genss_genrel32(a);
            } else {
                ma_genss_genbyte(((int64_t)112 + (int64_t)((uint64_t)((*m).cond))));
                ma_genss_genrel8(a);
            };
        };
    }break;
    case 109:;
    {
        ma_genss_genopnd(a,(int64_t)1);
    }break;
    case 110:;
    {
        ma_genss_genopnd(a,(int64_t)2);
    }break;
    case 111:;
    {
        ma_genss_genopnd(a,(int64_t)4);
    }break;
    case 112:;
    {
        ma_genss_genopnd(a,(int64_t)8);
    }break;
    case 113:;
    {
        ma_genss_genrel32(a);
    }break;
    case 114:;
    {
        ma_genss_switchseg((*a).value);
    }break;
    case 117:;
    {
        ma_genss_switchseg((int64_t)1);
    }break;
    case 115:;
    {
        ma_genss_switchseg((int64_t)2);
    }break;
    case 116:;
    {
        ma_genss_switchseg((int64_t)3);
    }break;
    case 6:;
    case 143:;
    {
        ma_genss_genbyte((int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 50:;
    {
        ma_genss_genbyte((int64_t)102);
        ma_genss_genbyte((int64_t)152);
    }break;
    case 51:;
    {
        ma_genss_genbyte((int64_t)102);
        ma_genss_genbyte((int64_t)153);
    }break;
    case 52:;
    {
        ma_genss_genbyte((int64_t)153);
    }break;
    case 53:;
    {
        ma_genss_genbyte((int64_t)72);
        ma_genss_genbyte((int64_t)153);
    }break;
    case 19:;
    {
        ma_genss_genbyte((int64_t)195);
    }break;
    case 20:;
    {
        if (((int64_t)((uint64_t)((*a).mode)) != (int64_t)2)) {
            mm_support_axerror((uint8_t*)"retn?");
        };
        ma_genss_genbyte((int64_t)194);
        ma_genss_genword((*a).value);
    }break;
    case 9:;
    {
        ma_genss_do_push(a);
    }break;
    case 10:;
    {
        ma_genss_do_pop(a);
    }break;
    case 48:;
    case 49:;
    {
        ma_genss_do_inc(a,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 46:;
    case 47:;
    case 29:;
    case 28:;
    case 33:;
    case 32:;
    {
        ma_genss_do_neg(a,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 24:;
    case 25:;
    case 34:;
    case 35:;
    case 36:;
    case 26:;
    case 27:;
    case 38:;
    {
        ma_genss_do_arith(a,b,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 8:;
    {
        ma_genss_do_mov(a,b);
    }break;
    case 11:;
    {
        ma_genss_do_lea(a,b);
    }break;
    case 15:;
    {
        ma_genss_do_movsx(a,b,(int64_t)190);
    }break;
    case 16:;
    {
        ma_genss_do_movsx(a,b,(int64_t)182);
    }break;
    case 17:;
    {
        ma_genss_do_movsxd(a,b);
    }break;
    case 23:;
    {
        ma_genss_do_exch(a,b);
    }break;
    case 30:;
    {
        ma_genss_do_imul2(a,b);
    }break;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    {
        if (((int64_t)((uint64_t)((*a).mode)) == (int64_t)2)) {
            n = ((*a).value * (int64_t)((uint64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1])));
            if ((ma_genss_currseg==(int64_t)1)) {
                av_1 = n;
                while (av_1-- > 0) {
L907 :;
                    ma_genss_genbyte((int64_t)144);
L908 :;
                }L909 :;
                ;
            }else if ((ma_genss_currseg==(int64_t)2)) {
                av_2 = n;
                while (av_2-- > 0) {
L910 :;
                    ma_genss_genbyte((int64_t)0);
L911 :;
                }L912 :;
                ;
            } else {
                ma_decls_ss_zdatalen += n;
            };
        } else {
            mm_support_axerror((uint8_t*)"resb?");
        };
    }break;
    case 118:;
    {
        if (((int64_t)((uint64_t)((*a).mode)) == (int64_t)2)) {
            x = (*a).value;
            if (((x < (int64_t)1) || (x > (int64_t)16384))) {
                mm_support_axerror((uint8_t*)"align2");
            };
            if ((ma_genss_currseg != (int64_t)3)) {
                L913 :;
                while (!!((ma_lib_bufferlength(ma_genss_currdata) % x))) {
                    ma_genss_genbyte(((ma_genss_currseg == (int64_t)1)?(int64_t)144:(int64_t)0));
L914 :;
                }L915 :;
                ;
            } else {
                L916 :;
                while (!!((ma_decls_ss_zdatalen % x))) {
                    ++ma_decls_ss_zdatalen;
L917 :;
                }L918 :;
                ;
            };
        } else {
            mm_support_axerror((uint8_t*)"align?");
        };
    }break;
    case 39:;
    case 41:;
    case 40:;
    case 42:;
    case 43:;
    case 44:;
    case 45:;
    {
        ma_genss_do_shift(a,b,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 37:;
    {
        ma_genss_do_test(a,b);
    }break;
    case 126:;
    case 125:;
    case 124:;
    {
        ma_genss_do_loop(a,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 127:;
    {
        ma_genss_do_jcxz(a,(int64_t)4);
    }break;
    case 128:;
    {
        ma_genss_do_jcxz(a,(int64_t)8);
    }break;
    case 123:;
    {
        ma_genss_genbyte((int64_t)215);
    }break;
    case 54:;
    {
        ma_genss_do_setcc((int64_t)((*m).cond),a);
    }break;
    case 13:;
    {
        ma_genss_do_movxmm(a,b,(int64_t)4);
    }break;
    case 14:;
    {
        ma_genss_do_movxmm(a,b,(int64_t)8);
    }break;
    case 59:;
    case 60:;
    case 61:;
    case 62:;
    case 58:;
    case 105:;
    case 106:;
    {
        ma_genss_do_arithxmm(a,b,(int64_t)243,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 63:;
    case 64:;
    case 65:;
    case 66:;
    case 57:;
    case 107:;
    case 108:;
    {
        ma_genss_do_arithxmm(a,b,(int64_t)242,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 72:;
    case 70:;
    {
        ma_genss_do_logicxmm(a,b,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]),(int64_t)4);
    }break;
    case 71:;
    case 69:;
    case 74:;
    case 73:;
    {
        ma_genss_do_logicxmm(a,b,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]),(int64_t)8);
    }break;
    case 85:;
    case 86:;
    {
        ma_genss_do_pcmpistri(a,b,(int64_t)((*m).c),(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 67:;
    {
        ma_genss_do_arithxmm(a,b,(int64_t)0,(int64_t)47);
    }break;
    case 68:;
    {
        ma_genss_do_arithxmm(a,b,(int64_t)102,(int64_t)47);
    }break;
    case 82:;
    {
        ma_genss_do_convertfloat(a,b,(int64_t)243);
    }break;
    case 81:;
    {
        ma_genss_do_convertfloat(a,b,(int64_t)242);
    }break;
    case 75:;
    {
        ma_genss_do_fix(a,b,(int64_t)243,(int64_t)45);
    }break;
    case 76:;
    {
        ma_genss_do_fix(a,b,(int64_t)242,(int64_t)45);
    }break;
    case 77:;
    {
        ma_genss_do_fix(a,b,(int64_t)243,(int64_t)44);
    }break;
    case 78:;
    {
        ma_genss_do_fix(a,b,(int64_t)242,(int64_t)44);
    }break;
    case 79:;
    {
        ma_genss_do_float(a,b,(int64_t)243);
    }break;
    case 80:;
    {
        ma_genss_do_float(a,b,(int64_t)242);
    }break;
    case 7:;
    {
        ma_genss_extraparam = a;
    }break;
    case 12:;
    {
        ma_genss_do_cmovcc((int64_t)((*m).cond),a,b);
    }break;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    {
        ma_genss_genbyte((int64_t)217);
        ma_genss_genbyte((int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 87:;
    case 88:;
    case 89:;
    {
        ma_genss_do_fmem(a,(int64_t)1,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 90:;
    case 91:;
    case 92:;
    {
        ma_genss_do_fmem(a,(int64_t)0,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 93:;
    case 94:;
    case 95:;
    case 96:;
    {
        ma_genss_genbyte((int64_t)222);
        ma_genss_genbyte((int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 129:;
    {
        ma_genss_genbyte((int64_t)166);
    }break;
    case 130:;
    {
        ma_genss_genbyte((int64_t)102);
        ma_genss_genbyte((int64_t)167);
    }break;
    case 131:;
    {
        ma_genss_genbyte((int64_t)167);
    }break;
    case 132:;
    {
        ma_genss_genbyte((int64_t)72);
        ma_genss_genbyte((int64_t)167);
    }break;
    case 133:;
    {
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte((int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 83:;
    case 84:;
    {
        ma_genss_do_movdqx(a,b,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 135:;
    {
        ma_genss_genbyte((int64_t)219);
        ma_genss_genbyte((int64_t)227);
    }break;
    case 136:;
    case 137:;
    case 138:;
    case 139:;
    case 140:;
    case 141:;
    case 142:;
    {
        ma_genss_genbyte((int64_t)217);
        ma_genss_genbyte((int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 134:;
    {
        ma_genss_do_popcnt(a,b);
    }break;
    case 55:;
    case 56:;
    {
        ma_genss_do_bsf(a,b,(int64_t)(mm_mcldecls_mclcodes[((int64_t)((*m).opcode))-1]));
    }break;
    case 1:;
    case 2:;
    {
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"*** Can't do opcode",NULL);
        msysnewc_m_print_str(mm_mcldecls_mclnames[((int64_t)((*m).opcode))-1],NULL);
        msysnewc_m_print_str((uint8_t*)"line",NULL);
        msysnewc_m_print_i64(mm_decls_alineno,NULL);
        msysnewc_m_print_str((uint8_t*)"M.OPCODE=",NULL);
        msysnewc_m_print_u64((*m).opcode,NULL);
        msysnewc_m_print_str((uint8_t*)"M_HALT=",NULL);
        msysnewc_m_print_i64((int64_t)143,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_axerror((uint8_t*)"STOPPING");
    }
    } //SW
;
}

static void ma_genss_genbyte(int64_t x) {
    (*(*ma_genss_currdata).pcurr++) = (uint64_t)(x);
}

static void ma_genss_genword(int64_t x) {
    ma_lib_addword(ma_genss_currdata,x);
}

static void ma_genss_gendword(int64_t x) {
    ma_lib_adddword(ma_genss_currdata,x);
}

static void ma_genss_genqword(int64_t x) {
    ma_lib_addqword(ma_genss_currdata,x);
}

static void ma_genss_genopnd(struct mm_mcldecls_opndrec * a,int64_t size) {
    uint8_t *  s;
    int64_t length;
    float x32;
    if ((size == (int64_t)0)) {
        size = (int64_t)((*a).size);
    };
    if (((int64_t)((*a).valtype)==(int64_t)4)) {
        s = (*a).svalue;
        length = (int64_t)(strlen((int8_t *)(s)));
        if ((length > (int64_t)100)) {
            ma_lib_buffercheck(ma_genss_currdata,msysnewc_m_imax((int64_t)1024,(length + (int64_t)1)));
        };
        L919 :;
        while (!!((uint64_t)((*s)))) {
            ma_genss_genbyte((int64_t)((*s++)));
L920 :;
        }L921 :;
        ;
        return;
    };
    if ((!!(ma_genss_getdef(a,(int64_t)0)) && (size <= (int64_t)2))) {
        mm_support_axerror((uint8_t*)"8/16-BIT RELOC");
    };
    if ((size==(int64_t)1)) {
        ma_genss_genbyte((*a).value);
    }else if ((size==(int64_t)2)) {
        ma_genss_genword((*a).value);
    }else if ((size==(int64_t)4)) {
        if (((int64_t)((*a).valtype)==(int64_t)1)) {
            ma_genss_gendword((*a).value);
        }else if (((int64_t)((*a).valtype)==(int64_t)2)) {
            x32 = (float)((*a).xvalue);
            ma_genss_gendword((int64_t)(*(int32_t*)&x32));
        }else if (((int64_t)((*a).valtype)==(int64_t)3)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"\t\tOPND/REALMEM4",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)((*a).valtype)==(int64_t)4)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"\t\tOPND/STRINGIMM4",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)((*a).valtype)==(int64_t)5) || ((int64_t)((*a).valtype)==(int64_t)6)) {
            ma_genss_genabs32(a);
        }else if (((int64_t)((*a).valtype)==(int64_t)7)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"\t\tOPND/NAME4",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_mcldecls_valtypenames[((int64_t)((*a).valtype))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_axerror((uint8_t*)"OPND/4/VALTYPE?");
        };
    }else if ((size==(int64_t)8)) {
        if (((int64_t)((*a).valtype)==(int64_t)1)) {
            ma_genss_genqword((*a).value);
        }else if (((int64_t)((*a).valtype)==(int64_t)2)) {
            ma_genss_genqword(*(int64_t*)&(*a).xvalue);
        }else if (((int64_t)((*a).valtype)==(int64_t)3)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"\t\tOPND/REALMEM8",NULL);
            msysnewc_m_print_i64(mm_decls_alineno,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)((*a).valtype)==(int64_t)4)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"\t\tOPND/STRINGIMM8",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)((*a).valtype)==(int64_t)5) || ((int64_t)((*a).valtype)==(int64_t)6)) {
            ma_genss_genabs64(a);
        }else if (((int64_t)((*a).valtype)==(int64_t)7)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"\t\tOPND/NAME8",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_mcldecls_valtypenames[((int64_t)((*a).valtype))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_axerror((uint8_t*)"OPND/8/VALTYPE?");
        };
    };
}

static void ma_genss_addrelocitem(int64_t reloctype,struct mm_decls_strec * d) {
    struct ma_decls_relocrec *  r;
    int64_t stindex;
    int64_t adjust;
    stindex = ma_genss_getstindex(d);
    adjust = (int64_t)4;
    if ((reloctype == (int64_t)1)) {
        adjust = (int64_t)8;
    };
    r = (struct ma_decls_relocrec *)(mlib_pcm_alloc((int64_t)32));
    (*r).nextreloc = ma_genss_currrelocs;
    (*r).reloctype = reloctype;
    (*r).offset = (ma_genss_getcurrdatalen((int64_t)1) - adjust);
    (*r).stindex = stindex;
    ++ma_genss_nrelocs;
    ma_genss_currrelocs = r;
}

static int64_t ma_genss_getstindex(struct mm_decls_strec * d) {
    if (((int64_t)((*d).stindex) == (int64_t)0)) {
        if ((ma_decls_ss_nsymbols >= ma_decls_ss_symboltablesize)) {
            ma_genss_extendsymboltable();
        };
        (*d).stindex = ++ma_decls_ss_nsymbols;
        (*ma_decls_ss_symboltable)[((int64_t)((*d).stindex))-1] = d;
        if (((int64_t)((uint64_t)((*d).segment)) == (int64_t)0)) {
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)6)) {
                (*d).segment = (uint64_t)((int64_t)1);
            };
        };
    };
    return (int64_t)((*d).stindex);
}

static void ma_genss_genrel32(struct mm_mcldecls_opndrec * a) {
    struct mm_decls_strec *  d;
    d = ma_genss_getdef(a,(int64_t)0);
    if ((d == 0)) {
        ma_genss_gendword((*a).value);
        return;
    };
    if (((int64_t)((*d).reftype)==(int64_t)2)) {
        if (((int64_t)((uint64_t)((*d).segment)) != ma_genss_currseg)) {
            mm_support_axerror((uint8_t*)"Rel label across segments");
        };
        ma_genss_gendword((((int64_t)((*d).offset) - (ma_genss_getcurrdatalen((int64_t)2) + (int64_t)4)) + (int64_t)((*a).offset)));
    }else if (((int64_t)((*d).reftype)==(int64_t)1)) {
        (*d).fwdrefs = ma_genss_addfwdref((*d).fwdrefs,ma_genss_getcurrdatalen((int64_t)3),(int64_t)4,(int64_t)0);
        ma_genss_gendword((int64_t)((*a).offset));
    } else {
        ma_genss_gendword((int64_t)((*a).offset));
        ma_genss_addrelocitem((int64_t)4,d);
    };
}

static struct mm_decls_strec * ma_genss_getdef(struct mm_mcldecls_opndrec * a,int64_t dneeded) {
    struct mm_decls_strec *  d;
    if ((((*a).mode == (int64_t)3) || ((*a).mode == (int64_t)2))) {
        if (((int64_t)((*a).valtype)==(int64_t)6)) {
            return (*ma_decls_labeldeftable)[((*a).labelno)-1];
        }else if (((int64_t)((*a).valtype)==(int64_t)5)) {
            d = (*a).def;
            if (((int64_t)((uint64_t)((*d).reftype)) == (int64_t)0)) {
                if (((int64_t)((uint64_t)((*d).nameid)) != (int64_t)6)) {
                    (*d).reftype = (uint64_t)((int64_t)1);
                };
            };
            return d;
        };
    };
    if (!!(dneeded)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_mcldecls_opndnames_ma[((int64_t)((*a).mode))],NULL);
        msysnewc_m_print_str(mm_mcldecls_valtypenames[((int64_t)((*a).valtype))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_axerror((uint8_t*)"getdef/no def");
    };
    return (struct mm_decls_strec *)(0);
}

static void ma_genss_genabs32(struct mm_mcldecls_opndrec * a) {
    struct mm_decls_strec *  d;
    d = ma_genss_getdef(a,(int64_t)1);
    if (((int64_t)((*d).reftype)==(int64_t)2)) {
        ma_genss_gendword(((int64_t)((*d).offset) + (int64_t)((*a).offset)));
        ma_genss_addrelocitem((int64_t)2,d);
    }else if (((int64_t)((*d).reftype)==(int64_t)1)) {
        (*d).fwdrefs = ma_genss_addfwdref((*d).fwdrefs,ma_genss_getcurrdatalen((int64_t)4),(int64_t)2,ma_genss_currseg);
        if ((((*d).nameid == (int64_t)10) || ((*d).nameid == (int64_t)11))) {
            ma_genss_gendword(((int64_t)((*d).offset) + (int64_t)((*a).offset)));
        } else {
            ma_genss_gendword((int64_t)((*a).offset));
            ma_genss_addrelocitem((int64_t)2,d);
        };
    } else {
        ma_genss_gendword((int64_t)((*a).offset));
        ma_genss_addrelocitem((int64_t)2,d);
    };
}

static void ma_genss_genabs64(struct mm_mcldecls_opndrec * a) {
    struct mm_decls_strec *  d;
    d = ma_genss_getdef(a,(int64_t)1);
    if (((int64_t)((*d).reftype)==(int64_t)2)) {
        ma_genss_genqword(((int64_t)((*d).offset) + (int64_t)((*a).offset)));
        ma_genss_addrelocitem((int64_t)1,d);
    }else if (((int64_t)((*d).reftype)==(int64_t)1)) {
        (*d).fwdrefs = ma_genss_addfwdref((*d).fwdrefs,ma_genss_getcurrdatalen((int64_t)5),(int64_t)1,ma_genss_currseg);
        if ((((*d).nameid == (int64_t)10) || ((*d).nameid == (int64_t)11))) {
            ma_genss_genqword(((int64_t)((*d).offset) + (int64_t)((*a).offset)));
        } else {
            ma_genss_genqword((int64_t)((*a).offset));
            ma_genss_addrelocitem((int64_t)1,d);
        };
    } else {
        ma_genss_genqword((int64_t)((*a).offset));
        ma_genss_addrelocitem((int64_t)1,d);
    };
}

static int64_t ma_genss_getrel32(struct mm_decls_strec * d,int64_t offset) {
    if (((int64_t)((uint64_t)((*d).reftype)) == (int64_t)2)) {
        if (((int64_t)((uint64_t)((*d).segment)) != ma_genss_currseg)) {
            mm_support_axerror((uint8_t*)"Rel label across segments2");
        };
        return ((int64_t)((*d).offset) - (offset + (int64_t)1));
    } else {
        return (int64_t)2147483647;
    };
}

static void ma_genss_dofwdrefs(struct mm_decls_strec * d) {
    struct mm_decls_fwdrec *  f;
    int64_t offset;
    byte *  p8;
    int32_t *  p32;
    int64_t *  p64;
    struct ma_decls_dbuffer *  data;
    if (((*d).fwdrefs == 0)) {
        return;
    };
    f = (*d).fwdrefs;
    L922 :;
    while (!!(f)) {
        offset = (int64_t)((*f).offset);
        if (((int64_t)((*f).reltype)==(int64_t)4)) {
            p32 = (int32_t *)(ma_lib_bufferelemptr(ma_genss_currdata,offset));
            (*p32) = (((int64_t)((*d).offset) - offset) - (int64_t)4);
        }else if (((int64_t)((*f).reltype)==(int64_t)2) || ((int64_t)((*f).reltype)==(int64_t)1)) {
            if (((int64_t)((*f).seg)==(int64_t)1)) {
                data = ma_decls_ss_code;
            }else if (((int64_t)((*f).seg)==(int64_t)3)) {
                mm_support_axerror((uint8_t*)"Fwd ref in zdata");
            }else if (((int64_t)((*f).seg)==(int64_t)2)) {
                data = ma_decls_ss_idata;
            };
            p32 = (int32_t *)(ma_lib_bufferelemptr(data,offset));
            if (((int64_t)((*f).reltype) == (int64_t)2)) {
                (*p32) = ((int64_t)((*p32)) + (int64_t)((*d).offset));
            } else {
                p64 = (int64_t *)(p32);
                (*p64) = ((*p64) + (int64_t)((*d).offset));
            };
        }else if (((int64_t)((*f).reltype)==(int64_t)6)) {
            p8 = (byte *)(ma_lib_bufferelemptr(ma_genss_currdata,offset));
            (*p8) = (uint64_t)((((int64_t)((*d).offset) - offset) - (int64_t)1));
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ma_objdecls_relocnames[((int64_t)((*f).reltype))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_gerror((uint8_t*)"DOFWDREFS/CAN'T DO RELTYPE",(struct mm_decls_unitrec *)(0));
        };
        f = (*f).nextfwd;
L923 :;
    }L924 :;
    ;
}

static void ma_genss_genrex(void) {
    if (!!(ma_genss_sizeoverride)) {
        ma_genss_genbyte((int64_t)102);
    };
    if (!!(ma_genss_addroverride)) {
        ma_genss_genbyte((int64_t)103);
    };
    if (!!(ma_genss_rex)) {
        if ((ma_genss_rex < (int64_t)64)) {
            ma_genss_genbyte(((int64_t)64 + ma_genss_rex));
        } else {
            ma_genss_genbyte(ma_genss_rex);
        };
    };
}

static int64_t ma_genss_isbytesized(int64_t x) {
    return (((int64_t)-128 <= x) && (x <= (int64_t)127));
}

static int64_t ma_genss_isdwordsized(int64_t x) {
    return (((int64_t)-2147483648 <= x) && (x <= (int64_t)2147483647));
}

static void ma_genss_do_push(struct mm_mcldecls_opndrec * a) {
    int64_t code;
    int64_t am;
    if (((int64_t)((*a).mode)==(int64_t)1)) {
        if (((int64_t)((uint64_t)((*a).size)) != (int64_t)8)) {
            mm_support_axerror((uint8_t*)"pushreg not 64-bit");
        };
        code = (int64_t)(mm_mcldecls_regcodes[((int64_t)((*a).reg))]);
        if ((code >= (int64_t)8)) {
            ma_genss_rex = (int64_t)1;
            code &= (int64_t)7;
        };
        ma_genss_genrex();
        ma_genss_genbyte(((int64_t)80 + code));
    }else if (((int64_t)((*a).mode)==(int64_t)2)) {
        if (!!(ma_genss_getdef(a,(int64_t)0))) {
            ma_genss_genbyte((int64_t)104);
            ma_genss_genopnd(a,(int64_t)4);
        } else if (!!(ma_genss_isbytesized((*a).value))) {
            ma_genss_genbyte((int64_t)106);
            ma_genss_genbyte((*a).value);
        } else if (!!(ma_genss_isdwordsized((*a).value))) {
            ma_genss_genbyte((int64_t)104);
            ma_genss_gendword((*a).value);
        } else {
            mm_support_axerror((uint8_t*)"push imm value too large");
        };
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
        if (((int64_t)((uint64_t)((*a).size)) != (int64_t)8)) {
            mm_support_axerror((uint8_t*)"push not 64-bit");
        };
        am = ma_genss_genrm(a,(int64_t)6);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)255);
        ma_genss_genamode(a,am);
    } else {
        mm_support_axerror((uint8_t*)"push opnd?");
    };
}

static void ma_genss_do_pop(struct mm_mcldecls_opndrec * a) {
    int64_t code;
    int64_t am;
    if (((int64_t)((*a).mode)==(int64_t)1)) {
        if (((int64_t)((uint64_t)((*a).size)) != (int64_t)8)) {
            mm_support_axerror((uint8_t*)"popreg not 64-bit");
        };
        code = (int64_t)(mm_mcldecls_regcodes[((int64_t)((*a).reg))]);
        if ((code >= (int64_t)8)) {
            ma_genss_rex = (int64_t)1;
            code &= (int64_t)7;
        };
        ma_genss_genrex();
        ma_genss_genbyte(((int64_t)88 + code));
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
        if (((int64_t)((uint64_t)((*a).size)) != (int64_t)8)) {
            mm_support_axerror((uint8_t*)"pop not 64-bit");
        };
        am = ma_genss_genrm(a,(int64_t)0);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)143);
        ma_genss_genamode(a,am);
    } else {
        mm_support_axerror((uint8_t*)"pop opnd?");
    };
}

static void ma_genss_do_inc(struct mm_mcldecls_opndrec * a,int64_t code) {
    int64_t opc;
    int64_t am;
    opc = (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)?(int64_t)254:(int64_t)255);
    if (((int64_t)((*a).mode)==(int64_t)1) || ((int64_t)((*a).mode)==(int64_t)3)) {
        am = ma_genss_genrm(a,code);
        ma_genss_checkhighreg(a);
        ma_genss_setopsize(a);
        ma_genss_genrex();
        ma_genss_genbyte(opc);
        ma_genss_genamode(a,am);
    } else {
        mm_support_axerror((uint8_t*)"inc/opnd?");
    };
}

static void ma_genss_do_neg(struct mm_mcldecls_opndrec * a,int64_t code) {
    int64_t opc;
    int64_t am;
    opc = (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)?(int64_t)246:(int64_t)247);
    if (((int64_t)((*a).mode)==(int64_t)1) || ((int64_t)((*a).mode)==(int64_t)3)) {
        am = ma_genss_genrm(a,code);
        ma_genss_checkhighreg(a);
        ma_genss_setopsize(a);
        ma_genss_genrex();
        ma_genss_genbyte(opc);
        ma_genss_genamode(a,am);
    } else {
        mm_support_axerror((uint8_t*)"neg/div/etc opnd?");
    };
}

static void ma_genss_genamode(struct mm_mcldecls_opndrec * a,int64_t am) {
    int64_t sib;
    int64_t mode;
    int64_t dispsize;
    int64_t offset;
    sib = (am >> (int64_t)16);
    mode = ((am >> (int64_t)8) & (int64_t)255);
    dispsize = (am & (int64_t)255);
    ma_genss_genbyte(mode);
    if ((sib >= (int64_t)0)) {
        ma_genss_genbyte(sib);
    };
    if ((dispsize==(int64_t)0)) {
    }else if ((dispsize==(int64_t)1)) {
        ma_genss_getdispsize(a,&offset);
        ma_genss_genbyte(offset);
    }else if ((dispsize==(int64_t)4)) {
        if (((int64_t)((*a).mode)==(int64_t)3)) {
            if (((int64_t)((*a).valtype)==(int64_t)5) || ((int64_t)((*a).valtype)==(int64_t)6)) {
                ma_genss_genabs32(a);
            }else if (((int64_t)((*a).valtype)==(int64_t)0)) {
                ma_genss_getdispsize(a,&offset);
                ma_genss_gendword(offset);
            } else {
                mm_support_axerror((uint8_t*)"genam/3");
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_mcldecls_opndnames_ma[((int64_t)((*a).mode))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_axerror((uint8_t*)"GENAMODE/MODE?");
        };
    } else {
        mm_support_axerror((uint8_t*)"genamode size 2/8");
    };
}

static int64_t ma_genss_makemodrm(int64_t mode,int64_t opc,int64_t rm) {
    return (((mode << (int64_t)6) + (opc << (int64_t)3)) + rm);
}

static void ma_genss_setopsize(struct mm_mcldecls_opndrec * a) {
    if (((int64_t)((*a).size)==(int64_t)1)) {
    }else if (((int64_t)((*a).size)==(int64_t)2)) {
        ma_genss_sizeoverride = (int64_t)1;
    }else if (((int64_t)((*a).size)==(int64_t)8)) {
        ma_genss_rex |= (int64_t)8;
    }else if (((int64_t)((*a).size)==(int64_t)4)) {
    } else {
        mm_support_axerror((uint8_t*)"Operand size not set");
    };
}

static void ma_genss_setaddrsize(struct mm_mcldecls_opndrec * a) {
    if ((((int64_t)((uint64_t)((*a).mode)) == (int64_t)3) && ((int64_t)((uint64_t)((*a).addrsize)) == (int64_t)4))) {
        ma_genss_addroverride = (int64_t)1;
    };
}

static int64_t ma_genss_getdispsize(struct mm_mcldecls_opndrec * a,int64_t * offset) {
    struct mm_decls_strec *  d;
    d = ma_genss_getdef(a,(int64_t)0);
    (*offset) = (int64_t)((*a).offset);
    if (!!(d)) {
        if (((int64_t)((*d).nameid)==(int64_t)10) || ((int64_t)((*d).nameid)==(int64_t)11)) {
            (*offset) += (int64_t)((*d).offset);
        } else {
            return (int64_t)4;
        };
    };
    if (!!((*offset))) {
        return (!!(ma_genss_isbytesized((*offset)))?(int64_t)1:(int64_t)4);
    } else {
        return (int64_t)0;
    };
}

static int64_t ma_genss_genrm(struct mm_mcldecls_opndrec * a,int64_t opc) {
    static int64_t scaletable[8] = {(int64_t)0,(int64_t)1,(int64_t)0,(int64_t)2,(int64_t)0,(int64_t)0,(int64_t)0,(int64_t)3};
    int64_t mode;
    int64_t rm;
    int64_t scale;
    int64_t dispsize;
    int64_t sib;
    int64_t index;
    int64_t base;
    int64_t reg;
    int64_t regix;
    int64_t code;
    int64_t offset;
    mode = (rm = (int64_t)0);
    scale = (int64_t)0;
    dispsize = (int64_t)0;
    sib = (int64_t)-1;
    if ((((int64_t)((uint64_t)((*a).mode)) == (int64_t)3) && ((int64_t)((uint64_t)((*a).addrsize)) == (int64_t)4))) {
        ma_genss_addroverride = (int64_t)1;
    };
    if (((int64_t)((*a).mode)==(int64_t)1)) {
        code = ma_genss_getregcodeb((int64_t)((*a).reg));
        return ma_genss_makeam(ma_genss_makemodrm((int64_t)3,opc,code),sib,dispsize);
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
    }else if (((int64_t)((*a).mode)==(int64_t)5)) {
        code = ma_genss_getregcodebx((int64_t)((*a).reg));
        return ma_genss_makeam(ma_genss_makemodrm((int64_t)3,opc,code),sib,dispsize);
    } else {
        mm_support_axerror((uint8_t*)"genrm not mem");
    };
    reg = (int64_t)((*a).reg);
    regix = (int64_t)((*a).regix);
    if (((!!(regix) && (reg == (int64_t)0)) && ((int64_t)((uint64_t)((*a).scale)) <= (int64_t)1))) {
        reg = regix;
        regix = (int64_t)0;
    };
    if (((reg == regix) && (regix == (int64_t)0))) {
        mode = (int64_t)0;
        rm = (int64_t)4;
        scale = (int64_t)1;
        index = (int64_t)4;
        base = (int64_t)5;
        dispsize = (int64_t)4;
    } else if ((((int64_t)((uint64_t)((*a).scale)) <= (int64_t)1) && (regix == (int64_t)0))) {
        dispsize = ma_genss_getdispsize(a,&offset);
        if (!!(dispsize)) {
            mode = ((dispsize == (int64_t)1)?(int64_t)1:(int64_t)2);
        };
        rm = (int64_t)(mm_mcldecls_regcodes[(reg)]);
        if (((rm != (int64_t)4) && (rm != (int64_t)12))) {
            base = rm;
            if ((((rm == (int64_t)5) || (rm == (int64_t)13)) && (dispsize == (int64_t)0))) {
                mode = (int64_t)1;
                dispsize = (int64_t)1;
            };
            index = (int64_t)0;
        } else {
            index = (int64_t)4;
            base = rm;
            scale = (int64_t)1;
        };
    } else if ((!!(regix) && (reg == (int64_t)0))) {
        dispsize = (int64_t)4;
        mode = (int64_t)0;
        rm = (int64_t)4;
        scale = (!!((uint64_t)((*a).scale))?(int64_t)((*a).scale):(int64_t)1);
        base = (int64_t)5;
        index = (int64_t)(mm_mcldecls_regcodes[(regix)]);
        if ((regix == (int64_t)16)) {
            mm_support_axerror((uint8_t*)"Scaled rstack?");
        };
    } else {
        dispsize = ma_genss_getdispsize(a,&offset);
        if (!!(dispsize)) {
            mode = ((dispsize == (int64_t)1)?(int64_t)1:(int64_t)2);
        };
        rm = (int64_t)4;
        scale = (!!((uint64_t)((*a).scale))?(int64_t)((*a).scale):(int64_t)1);
        if ((reg == (int64_t)0)) {
            base = (int64_t)5;
        } else {
            if (((reg == (int64_t)15) && (dispsize == (int64_t)0))) {
                mode = (int64_t)1;
                dispsize = (int64_t)1;
            };
            base = (int64_t)(mm_mcldecls_regcodes[(reg)]);
        };
        if ((regix == (int64_t)0)) {
            index = (int64_t)4;
        } else {
            index = (int64_t)(mm_mcldecls_regcodes[(regix)]);
        };
        if ((!!(regix) && !(!!(reg)))) {
            dispsize = (int64_t)4;
        };
        if (((regix == (int64_t)16) && (scale > (int64_t)1))) {
            mm_support_axerror((uint8_t*)"Can't scale rstack");
        };
    };
    if ((index >= (int64_t)8)) {
        ma_genss_rex |= (int64_t)2;
        index &= (int64_t)7;
    };
    if ((base >= (int64_t)8)) {
        ma_genss_rex |= (int64_t)1;
        base &= (int64_t)7;
    };
    if (!!(scale)) {
        sib = (((scaletable[(scale)-1] << (int64_t)6) + (index << (int64_t)3)) + base);
    };
    rm &= (int64_t)7;
    if (((ma_genss_makemodrm(mode,opc,rm) == (int64_t)4) && (sib == (int64_t)5))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"MOD/SIB=4/5",NULL);
        msysnewc_m_print_i64((mm_decls_alineno & (int64_t)16777215),NULL);
        msysnewc_m_print_i64((mm_decls_alineno >> (int64_t)24),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    return ma_genss_makeam(ma_genss_makemodrm(mode,opc,rm),sib,dispsize);
}

static void ma_genss_genrmbyte(int64_t mode,int64_t opc,int64_t rm) {
    ma_genss_genbyte((((mode << (int64_t)6) + (opc << (int64_t)3)) + rm));
}

static int64_t ma_genss_makeam(int64_t m,int64_t s,int64_t d) {
    return (((s << (int64_t)16) + (m << (int64_t)8)) + d);
}

static void ma_genss_do_arith(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t code) {
    int64_t am;
    int64_t regcode;
    int64_t opc;
    int64_t dispsize;
    int64_t x;
    if (((int64_t)((*a).mode)==(int64_t)1)) {
        if (((int64_t)((*b).mode)==(int64_t)1) || ((int64_t)((*b).mode)==(int64_t)3)) {
            regcode = ma_genss_getregcoder((int64_t)((*a).reg));
            am = ma_genss_genrm(b,regcode);
            ma_genss_checkhighreg(a);
            ma_genss_checkhighreg(b);
            ma_genss_setopsize(a);
            opc = ((code << (int64_t)3) | (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)?(int64_t)2:(int64_t)3));
            ma_genss_genrex();
            ma_genss_genbyte(opc);
            ma_genss_genamode(b,am);
        }else if (((int64_t)((*b).mode)==(int64_t)2)) {
            //doregimm:
L925 :;
;
            if (!!(ma_genss_getdef(b,(int64_t)0))) {
                if (((code < (int64_t)0) || (code > (int64_t)7))) {
                    mm_support_axerror((uint8_t*)"non-add arith/label");
                };
                if (((int64_t)((uint64_t)((*a).size)) < (int64_t)4)) {
                    mm_support_axerror((uint8_t*)"add imm/size");
                };
                am = ma_genss_genrm(a,code);
                ma_genss_setopsize(a);
                ma_genss_genrex();
                ma_genss_genbyte((int64_t)129);
                ma_genss_genamode(a,am);
                ma_genss_genopnd(b,(int64_t)4);
                return;
            };
            x = (*b).value;
            dispsize = (int64_t)1;
            if (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)) {
                opc = (int64_t)128;
            } else if ((((int64_t)-128 <= x) && (x <= (int64_t)127))) {
                opc = (int64_t)131;
            } else {
                if (!((((int64_t)-2147483648 <= x) && (x <= (int64_t)4294967295)))) {
                    mm_support_axerror((uint8_t*)"3:exceeding word32 value");
                };
                opc = (int64_t)129;
                dispsize = (((int64_t)((uint64_t)((*a).size)) == (int64_t)2)?(int64_t)2:(int64_t)4);
            };
            am = ma_genss_genrm(a,code);
            ma_genss_checkhighreg(a);
            ma_genss_setopsize(a);
            ma_genss_genrex();
            ma_genss_genbyte(opc);
            ma_genss_genamode(a,am);
            if ((dispsize==(int64_t)1)) {
                ma_genss_genbyte(x);
            }else if ((dispsize==(int64_t)2)) {
                ma_genss_genword(x);
            }else if ((dispsize==(int64_t)4)) {
                ma_genss_gendword(x);
            };
        } else {
            mm_support_axerror((uint8_t*)"ADD reg,???");
        };
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
        if (((int64_t)((*b).mode)==(int64_t)1)) {
            regcode = ma_genss_getregcoder((int64_t)((*b).reg));
            am = ma_genss_genrm(a,regcode);
            ma_genss_checkhighreg(b);
            ma_genss_setopsize(b);
            opc = ((code << (int64_t)3) | (((int64_t)((uint64_t)((*b).size)) == (int64_t)1)?(int64_t)0:(int64_t)1));
            ma_genss_genrex();
            ma_genss_genbyte(opc);
            ma_genss_genamode(a,am);
        }else if (((int64_t)((*b).mode)==(int64_t)2)) {
            goto L925 ;
;
        } else {
            mm_support_axerror((uint8_t*)"ADD mem,???");
        };
    } else {
        mm_support_axerror((uint8_t*)"Can't add to this opnd");
    };
}

static void ma_genss_do_mov(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    int64_t regcode;
    int64_t am;
    int64_t value;
    if (((int64_t)((*a).mode)==(int64_t)1)) {
        if (((int64_t)((*b).mode)==(int64_t)1) || ((int64_t)((*b).mode)==(int64_t)3)) {
            if ((((uint64_t)((*a).size) != (uint64_t)((*b).size)) && !!((uint64_t)((*b).size)))) {
                mm_support_axerror((uint8_t*)"Opnd size mismatch");
            };
            ma_genss_checkhighreg(a);
            ma_genss_checkhighreg(b);
            regcode = ma_genss_getregcoder((int64_t)((*a).reg));
            am = ma_genss_genrm(b,regcode);
            ma_genss_setopsize(a);
            ma_genss_genrex();
            ma_genss_genbyte((((int64_t)((uint64_t)((*a).size)) == (int64_t)1)?(int64_t)138:(int64_t)139));
            ma_genss_genamode(b,am);
        }else if (((int64_t)((*b).mode)==(int64_t)2)) {
            value = (*b).value;
            regcode = ma_genss_getregcodeb((int64_t)((*a).reg));
            if ((!!(ma_genss_getdef(b,(int64_t)0)) && ((int64_t)((uint64_t)((*a).size)) <= (int64_t)2))) {
                mm_support_axerror((uint8_t*)"mov imm?");
            };
            if (((int64_t)((*a).size)==(int64_t)1)) {
                ma_genss_checkhighreg(a);
                if (((int64_t)((*a).reg)==(int64_t)6) || ((int64_t)((*a).reg)==(int64_t)4) || ((int64_t)((*a).reg)==(int64_t)15) || ((int64_t)((*a).reg)==(int64_t)16)) {
                    ma_genss_rex |= (int64_t)64;
                };
                if (!((((int64_t)-128 <= value) && (value <= (int64_t)255)))) {
                    mm_support_axerror((uint8_t*)"exceeding byte value");
                };
                ma_genss_genrex();
                ma_genss_genbyte(((int64_t)176 + regcode));
                ma_genss_genbyte(value);
            }else if (((int64_t)((*a).size)==(int64_t)2)) {
                if (!((((int64_t)-32768 <= value) && (value <= (int64_t)65535)))) {
                    mm_support_axerror((uint8_t*)"exceeding word16 value");
                };
                ma_genss_genbyte((int64_t)102);
                ma_genss_genrex();
                ma_genss_genbyte(((int64_t)184 + regcode));
                ma_genss_genword(value);
            }else if (((int64_t)((*a).size)==(int64_t)4)) {
                if (!!(ma_genss_getdef(b,(int64_t)0))) {
                    ma_genss_genrex();
                    ma_genss_genbyte(((int64_t)184 + regcode));
                    ma_genss_genopnd(b,(int64_t)4);
                } else {
                    if (!((((int64_t)-2147483648 <= value) && (value <= (int64_t)((uint64_t)4294967295u))))) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_i64(value,NULL);
                        msysnewc_m_print_ptr((void *)(value),NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        mm_support_axerror((uint8_t*)"1:exceeding word32 value");
                    };
                    //doreg32:
L926 :;
;
                    ma_genss_genrex();
                    ma_genss_genbyte(((int64_t)184 + regcode));
                    ma_genss_gendword(value);
                };
            } else {
                if (!!(ma_genss_getdef(b,(int64_t)0))) {
                    ma_genss_rex |= (int64_t)8;
                    ma_genss_genrex();
                    ma_genss_genbyte(((int64_t)184 + regcode));
                    ma_genss_genopnd(b,(int64_t)8);
                } else {
                    if (((value >= (int64_t)0) && (value <= (int64_t)4294967295))) {
                        goto L926 ;
;
                    };
                    ma_genss_rex |= (int64_t)8;
                    ma_genss_genrex();
                    ma_genss_genbyte(((int64_t)184 + regcode));
                    ma_genss_genqword(value);
                };
            };
        } else {
            mm_support_axerror((uint8_t*)"MOV REG/??");
        };
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
        if (((int64_t)((*b).mode)==(int64_t)1)) {
            if ((((uint64_t)((*a).size) != (uint64_t)((*b).size)) && !!((uint64_t)((*a).size)))) {
                mm_support_axerror((uint8_t*)"Opnd size mismatch");
            };
            regcode = ma_genss_getregcoder((int64_t)((*b).reg));
            ma_genss_checkhighreg(b);
            am = ma_genss_genrm(a,regcode);
            ma_genss_setopsize(b);
            ma_genss_genrex();
            ma_genss_genbyte((((int64_t)((uint64_t)((*b).size)) == (int64_t)1)?(int64_t)136:(int64_t)137));
            ma_genss_genamode(a,am);
        }else if (((int64_t)((*b).mode)==(int64_t)2)) {
            value = (*b).value;
            am = ma_genss_genrm(a,(int64_t)0);
            if ((!!(ma_genss_getdef(b,(int64_t)0)) && ((int64_t)((uint64_t)((*a).size)) <= (int64_t)2))) {
                mm_support_axerror((uint8_t*)"mov imm?");
            };
            if (((int64_t)((uint64_t)((*a).size)) == (int64_t)0)) {
                (*a).size = (uint64_t)((int64_t)1);
            };
            if (((int64_t)((*a).size)==(int64_t)0) || ((int64_t)((*a).size)==(int64_t)1)) {
                if (!((((int64_t)-128 <= value) && (value <= (int64_t)255)))) {
                    mm_support_axerror((uint8_t*)"exceeding byte value");
                };
                ma_genss_setopsize(a);
                ma_genss_genrex();
                ma_genss_genbyte((int64_t)198);
                ma_genss_genamode(a,am);
                ma_genss_genbyte(value);
            }else if (((int64_t)((*a).size)==(int64_t)2)) {
                if (!((((int64_t)-32768 <= value) && (value <= (int64_t)65535)))) {
                    mm_support_axerror((uint8_t*)"exceeding word16 value");
                };
                ma_genss_setopsize(a);
                ma_genss_genrex();
                ma_genss_genbyte((int64_t)199);
                ma_genss_genamode(a,am);
                ma_genss_genword(value);
            }else if (((int64_t)((*a).size)==(int64_t)4) || ((int64_t)((*a).size)==(int64_t)8)) {
                if (!(!!(ma_genss_getdef(b,(int64_t)0)))) {
                    if (!((((int64_t)-2147483647 <= value) && (value <= (int64_t)4294967295)))) {
                        mm_support_axerror((uint8_t*)"2:exceeding word32 value");
                    };
                };
                ma_genss_setopsize(a);
                ma_genss_genrex();
                ma_genss_genbyte((int64_t)199);
                ma_genss_genamode(a,am);
                ma_genss_genopnd(b,(int64_t)4);
            };
        } else {
            mm_support_axerror((uint8_t*)"MOV MEM/?");
        };
    } else {
        mm_support_axerror((uint8_t*)"MOV ?/..");
    };
}

static int64_t ma_genss_getregcoder(int64_t reg) {
    int64_t regcode;
    regcode = (int64_t)(mm_mcldecls_regcodes[(reg)]);
    if ((regcode >= (int64_t)8)) {
        regcode -= (int64_t)8;
        ma_genss_rex |= (int64_t)4;
    };
    return regcode;
}

static int64_t ma_genss_getregcodeb(int64_t reg) {
    int64_t regcode;
    regcode = (int64_t)(mm_mcldecls_regcodes[(reg)]);
    if ((regcode >= (int64_t)8)) {
        regcode -= (int64_t)8;
        ma_genss_rex |= (int64_t)1;
    };
    return regcode;
}

static int64_t ma_genss_getregcodebx(int64_t reg) {
    int64_t regcode;
    regcode = (reg - (int64_t)1);
    if ((regcode >= (int64_t)8)) {
        regcode -= (int64_t)8;
        ma_genss_rex |= (int64_t)1;
    };
    return regcode;
}

static int64_t ma_genss_getregcoderx(int64_t reg) {
    int64_t regcode;
    regcode = (reg - (int64_t)1);
    if ((regcode >= (int64_t)8)) {
        regcode -= (int64_t)8;
        ma_genss_rex |= (int64_t)4;
    };
    return regcode;
}

static void ma_genss_do_lea(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    int64_t regcode;
    int64_t am;
    if (!((((int64_t)((uint64_t)((*a).mode)) == (int64_t)1) && ((int64_t)((uint64_t)((*b).mode)) == (int64_t)3)))) {
        mm_support_axerror((uint8_t*)"LEA not reg/mem");
    };
    if (((int64_t)((uint64_t)((*a).size)) < (int64_t)4)) {
        mm_support_axerror((uint8_t*)"LEA size error");
    };
    regcode = ma_genss_getregcoder((int64_t)((*a).reg));
    am = ma_genss_genrm(b,regcode);
    ma_genss_setopsize(a);
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)141);
    ma_genss_genamode(b,am);
}

static void ma_genss_do_movsx(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc) {
    int64_t am;
    int64_t regcode;
    if (((int64_t)((uint64_t)((*a).mode)) != (int64_t)1)) {
        mm_support_axerror((uint8_t*)"movsx not reg");
    };
    if ((((int64_t)((uint64_t)((*a).size)) == (int64_t)8) && ((int64_t)((uint64_t)((*b).size)) == (int64_t)4))) {
        if ((opc == (int64_t)190)) {
            ma_genss_do_movsxd(a,b);
        } else {
            a = mm_libmcl_regtable[((int64_t)((*a).reg))-1][((int64_t)4)-1];
            ma_genss_do_mov(a,b);
        };
        return;
    };
    if ((((int64_t)((uint64_t)((*a).size)) == (int64_t)1) || ((uint64_t)((*a).size) <= (uint64_t)((*b).size)))) {
        mm_support_axerror((uint8_t*)"movsx size error");
    };
    if (((opc == (int64_t)182) && ((int64_t)((uint64_t)((*b).size)) == (int64_t)4))) {
        mm_support_axerror((uint8_t*)"movsx 4=>8 bytes?");
    };
    if (((int64_t)((*b).mode)==(int64_t)1)) {
    }else if (((int64_t)((*b).mode)==(int64_t)3)) {
        if (((int64_t)((uint64_t)((*b).size)) == (int64_t)0)) {
            mm_support_axerror((uint8_t*)"movsx need size prefix");
        };
        if (((int64_t)((uint64_t)((*b).size)) == (int64_t)8)) {
            mm_support_axerror((uint8_t*)"movsx size 8");
        };
    } else {
        mm_support_axerror((uint8_t*)"movsx not reg/mem");
    };
    regcode = ma_genss_getregcoder((int64_t)((*a).reg));
    am = ma_genss_genrm(b,regcode);
    ma_genss_setopsize(a);
    ma_genss_checkhighreg(b);
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)15);
    ma_genss_genbyte((((int64_t)((uint64_t)((*b).size)) == (int64_t)1)?opc:(opc + (int64_t)1)));
    ma_genss_genamode(b,am);
}

static void ma_genss_checkhighreg(struct mm_mcldecls_opndrec * a) {
    if (((int64_t)((uint64_t)((*a).mode)) == (int64_t)1)) {
        if (((int64_t)((*a).reg)==(int64_t)6) || ((int64_t)((*a).reg)==(int64_t)4) || ((int64_t)((*a).reg)==(int64_t)15) || ((int64_t)((*a).reg)==(int64_t)16)) {
            ma_genss_rex |= (int64_t)64;
        };
    };
}

static void ma_genss_do_exch(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    int64_t regcode;
    int64_t am;
    if ((((((int64_t)((uint64_t)((*a).mode)) == (int64_t)1) && ((int64_t)((uint64_t)((*b).mode)) == (int64_t)1)) && (((int64_t)((uint64_t)((*a).reg)) == (int64_t)1) || ((int64_t)((uint64_t)((*b).reg)) == (int64_t)1))) && ((int64_t)((uint64_t)((*a).size)) != (int64_t)1))) {
        if (((int64_t)((uint64_t)((*a).reg)) != (int64_t)1)) {
            {struct mm_mcldecls_opndrec *  temp = a; a = b; b = temp; };
        };
        if (((uint64_t)((*a).size) != (uint64_t)((*b).size))) {
            mm_support_axerror((uint8_t*)"exch size");
        };
        ma_genss_setopsize(a);
        regcode = ma_genss_getregcodeb((int64_t)((*b).reg));
        ma_genss_genrex();
        ma_genss_genbyte(((int64_t)144 + regcode));
        return;
    };
    if (((int64_t)((uint64_t)((*a).mode)) == (int64_t)3)) {
        {struct mm_mcldecls_opndrec *  temp = a; a = b; b = temp; };
    };
    if (!((((int64_t)((uint64_t)((*a).mode)) == (int64_t)1) && (((int64_t)((uint64_t)((*b).mode)) == (int64_t)1) || ((int64_t)((uint64_t)((*b).mode)) == (int64_t)3))))) {
        mm_support_axerror((uint8_t*)"exch opnds");
    };
    if ((((int64_t)((uint64_t)((*b).size)) == (int64_t)0) && ((int64_t)((uint64_t)((*b).mode)) == (int64_t)3))) {
        (*b).size = (uint64_t)((*a).size);
    };
    if (((uint64_t)((*a).size) != (uint64_t)((*b).size))) {
        mm_support_axerror((uint8_t*)"exch size");
    };
    if (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)) {
        ma_genss_checkhighreg(a);
        ma_genss_checkhighreg(b);
    };
    regcode = ma_genss_getregcoder((int64_t)((*a).reg));
    am = ma_genss_genrm(b,regcode);
    ma_genss_setopsize(a);
    ma_genss_genrex();
    ma_genss_genbyte((((int64_t)((uint64_t)((*a).size)) == (int64_t)1)?(int64_t)134:(int64_t)135));
    ma_genss_genamode(b,am);
}

static void ma_genss_do_movsxd(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    int64_t regcode;
    int64_t am;
    if ((((int64_t)((uint64_t)((*b).mode)) == (int64_t)3) && ((int64_t)((uint64_t)((*b).size)) == (int64_t)0))) {
        (*b).size = (uint64_t)((int64_t)4);
    };
    if ((((int64_t)((uint64_t)((*a).size)) != (int64_t)8) || ((int64_t)((uint64_t)((*b).size)) > (int64_t)4))) {
        mm_support_axerror((uint8_t*)"movsxd size");
    };
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)1) || (((int64_t)((uint64_t)((*b).mode)) != (int64_t)1) && ((int64_t)((uint64_t)((*b).mode)) != (int64_t)3)))) {
        mm_support_axerror((uint8_t*)"movsxd opnds");
    };
    regcode = ma_genss_getregcoder((int64_t)((*a).reg));
    am = ma_genss_genrm(b,regcode);
    ma_genss_setopsize(a);
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)99);
    ma_genss_genamode(b,am);
}

static void ma_genss_do_imul2(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    int64_t regcode;
    int64_t am;
    int64_t opc;
    int64_t value;
    if (((int64_t)((uint64_t)((*a).mode)) != (int64_t)1)) {
        mm_support_axerror((uint8_t*)"imul2 opnds");
    };
    if (((int64_t)((uint64_t)((*b).size)) == (int64_t)0)) {
        (*b).size = (uint64_t)((*a).size);
    };
    if (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)) {
        mm_support_axerror((uint8_t*)"imul2 byte");
    };
    if (((int64_t)((*b).mode)==(int64_t)1) || ((int64_t)((*b).mode)==(int64_t)3)) {
        if (((uint64_t)((*a).size) != (uint64_t)((*b).size))) {
            mm_support_axerror((uint8_t*)"imul2 size");
        };
        regcode = ma_genss_getregcoder((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        ma_genss_setopsize(a);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte((int64_t)175);
        ma_genss_genamode(b,am);
    }else if (((int64_t)((*b).mode)==(int64_t)2)) {
        if (!!(ma_genss_getdef(b,(int64_t)0))) {
            mm_support_axerror((uint8_t*)"mul/label");
        };
        value = (*b).value;
        regcode = ma_genss_getregcoder((int64_t)((*a).reg));
        regcode = ma_genss_getregcodeb((int64_t)((*a).reg));
        opc = (((int64_t)192 + (regcode << (int64_t)3)) + regcode);
        ma_genss_setopsize(a);
        ma_genss_genrex();
        if ((((int64_t)-128 <= value) && (value <= (int64_t)127))) {
            ma_genss_genbyte((int64_t)107);
            ma_genss_genbyte(opc);
            ma_genss_genbyte(value);
        } else if (((int64_t)((uint64_t)((*a).size)) == (int64_t)2)) {
            ma_genss_genbyte((int64_t)105);
            ma_genss_genbyte(opc);
            ma_genss_genword(value);
        } else {
            ma_genss_genbyte((int64_t)105);
            ma_genss_genbyte(opc);
            ma_genss_gendword(value);
        };
    } else {
        mm_support_axerror((uint8_t*)"imul2 opnds");
    };
}

static void ma_genss_do_imul3(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,struct mm_mcldecls_opndrec * c) {
    int64_t value;
    int64_t regcode1;
    int64_t regcode2;
    int64_t opc;
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)1) || ((int64_t)((uint64_t)((*b).mode)) != (int64_t)1))) {
        mm_support_axerror((uint8_t*)"imul3 opnds");
    };
    if (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)) {
        mm_support_axerror((uint8_t*)"imul3 byte");
    };
    if (((int64_t)((uint64_t)((*c).mode)) != (int64_t)2)) {
        mm_support_axerror((uint8_t*)"imul3 not imm");
    };
    value = (*c).value;
    regcode1 = ma_genss_getregcoder((int64_t)((*a).reg));
    regcode2 = ma_genss_getregcodeb((int64_t)((*b).reg));
    opc = (((int64_t)192 + (regcode1 << (int64_t)3)) + regcode2);
    ma_genss_setopsize(a);
    ma_genss_genrex();
    if ((((int64_t)-128 <= value) && (value <= (int64_t)127))) {
        ma_genss_genbyte((int64_t)107);
        ma_genss_genbyte(opc);
        ma_genss_genbyte(value);
    } else if (((int64_t)((uint64_t)((*a).size)) == (int64_t)2)) {
        ma_genss_genbyte((int64_t)105);
        ma_genss_genbyte(opc);
        ma_genss_genword(value);
    } else {
        ma_genss_genbyte((int64_t)105);
        ma_genss_genbyte(opc);
        ma_genss_gendword(value);
    };
}

static void ma_genss_do_shift(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc) {
    int64_t am;
    int64_t w;
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)1) && ((int64_t)((uint64_t)((*a).mode)) != (int64_t)3))) {
        mm_support_axerror((uint8_t*)"shift opnds1?");
    };
    am = ma_genss_genrm(a,opc);
    ma_genss_checkhighreg(a);
    ma_genss_setopsize(a);
    ma_genss_genrex();
    w = (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)?(int64_t)0:(int64_t)1);
    if (((int64_t)((*b).mode)==(int64_t)2)) {
        if (!!(ma_genss_getdef(b,(int64_t)0))) {
            mm_support_axerror((uint8_t*)"shift/label");
        };
        if (((*b).value == (int64_t)1)) {
            ma_genss_genbyte(((int64_t)208 + w));
            ma_genss_genamode(a,am);
        } else {
            ma_genss_genbyte(((int64_t)192 + w));
            ma_genss_genamode(a,am);
            ma_genss_genbyte((*b).value);
        };
    }else if (((int64_t)((*b).mode)==(int64_t)1)) {
        if ((((int64_t)((uint64_t)((*b).reg)) != (int64_t)11) || ((int64_t)((uint64_t)((*b).size)) != (int64_t)1))) {
            mm_support_axerror((uint8_t*)"cl or b10 needed");
        };
        ma_genss_genbyte(((int64_t)210 + w));
        ma_genss_genamode(a,am);
    } else {
        mm_support_axerror((uint8_t*)"shift opnds2?");
    };
}

static void ma_genss_do_test(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    int64_t value;
    int64_t opc;
    int64_t am;
    int64_t regcode;
    if (((((int64_t)((uint64_t)((*a).mode)) == (int64_t)1) && ((int64_t)((uint64_t)((*a).reg)) == (int64_t)1)) && ((int64_t)((uint64_t)((*b).mode)) == (int64_t)2))) {
        value = (*b).value;
        if (((int64_t)((*a).size)==(int64_t)1)) {
            ma_genss_genbyte((int64_t)168);
            ma_genss_genbyte(value);
        }else if (((int64_t)((*a).size)==(int64_t)2)) {
            ma_genss_genbyte((int64_t)102);
            ma_genss_genbyte((int64_t)169);
            ma_genss_genword(value);
        }else if (((int64_t)((*a).size)==(int64_t)4)) {
            ma_genss_genbyte((int64_t)169);
            ma_genss_gendword(value);
        } else {
            ma_genss_genbyte((int64_t)72);
            ma_genss_genbyte((int64_t)169);
            ma_genss_gendword(value);
        };
    } else if (((((int64_t)((uint64_t)((*a).mode)) == (int64_t)1) || ((int64_t)((uint64_t)((*a).mode)) == (int64_t)3)) && ((int64_t)((uint64_t)((*b).mode)) == (int64_t)2))) {
        opc = (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)?(int64_t)246:(int64_t)247);
        value = (*b).value;
        am = ma_genss_genrm(a,(int64_t)0);
        ma_genss_checkhighreg(a);
        ma_genss_setopsize(a);
        ma_genss_genrex();
        ma_genss_genbyte(opc);
        ma_genss_genamode(a,am);
        if (((int64_t)((*a).size)==(int64_t)1)) {
            ma_genss_genbyte(value);
        }else if (((int64_t)((*a).size)==(int64_t)2)) {
            ma_genss_genword(value);
        } else {
            ma_genss_gendword(value);
        };
    } else if ((((int64_t)((uint64_t)((*a).mode)) == (int64_t)1) && (((int64_t)((uint64_t)((*b).mode)) == (int64_t)1) || ((int64_t)((uint64_t)((*b).mode)) == (int64_t)3)))) {
        //doregmem:
L927 :;
;
        regcode = ma_genss_getregcoder((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        ma_genss_checkhighreg(a);
        ma_genss_checkhighreg(b);
        ma_genss_setopsize(a);
        ma_genss_genrex();
        ma_genss_genbyte((((int64_t)((uint64_t)((*a).size)) == (int64_t)1)?(int64_t)132:(int64_t)133));
        ma_genss_genamode(b,am);
    } else if ((((int64_t)((uint64_t)((*a).mode)) == (int64_t)3) && ((int64_t)((uint64_t)((*b).mode)) == (int64_t)1))) {
        {struct mm_mcldecls_opndrec *  temp = a; a = b; b = temp; };
        goto L927 ;
;
    } else {
        mm_support_axerror((uint8_t*)"test opnds");
    };
}

static void ma_genss_do_loop(struct mm_mcldecls_opndrec * a,int64_t opc) {
    int64_t offset;
    offset = ma_genss_getrel32(ma_genss_getdef(a,(int64_t)1),(ma_genss_getcurrdatalen((int64_t)9) + (int64_t)1));
    if ((offset < (int64_t)0)) {
        if ((offset < (int64_t)-126)) {
            mm_support_axerror((uint8_t*)"loop jmp out of range");
        };
        ma_genss_genbyte(opc);
        ma_genss_genbyte(offset);
    } else {
        mm_support_axerror((uint8_t*)"Can't do loopxx fwd jump");
    };
}

static void ma_genss_do_jcxz(struct mm_mcldecls_opndrec * a,int64_t opsize) {
    int64_t offset;
    offset = ma_genss_getrel32(ma_genss_getdef(a,(int64_t)1),(ma_genss_getcurrdatalen((int64_t)10) + (int64_t)1));
    if ((offset < (int64_t)0)) {
        if ((offset < (int64_t)-126)) {
            mm_support_axerror((uint8_t*)"jcxz jmp out of range");
        };
        if ((opsize == (int64_t)4)) {
            ma_genss_genbyte((int64_t)103);
        };
        ma_genss_genbyte((int64_t)227);
        ma_genss_genbyte(offset);
    } else {
        mm_support_axerror((uint8_t*)"Can't do jcxz fwd jump");
    };
}

static void ma_genss_do_setcc(int64_t cond,struct mm_mcldecls_opndrec * a) {
    int64_t am;
    if (((((int64_t)((uint64_t)((*a).mode)) != (int64_t)1) && ((int64_t)((uint64_t)((*a).reg)) != (int64_t)3)) || ((int64_t)((uint64_t)((*a).size)) > (int64_t)1))) {
        mm_support_axerror((uint8_t*)"setcc opnd/size");
    };
    am = ma_genss_genrm(a,(int64_t)0);
    ma_genss_checkhighreg(a);
    ma_genss_genrex();
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)15);
    ma_genss_genbyte(((int64_t)144 + cond));
    ma_genss_genamode(a,am);
}

static void ma_genss_do_movxmm(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t size) {
    int64_t am;
    int64_t regcode;
    int64_t regcode1;
    int64_t regcode2;
    if (((int64_t)((*a).mode)==(int64_t)1)) {
        if (((int64_t)((*b).mode)==(int64_t)5)) {
            if (((int64_t)((uint64_t)((*a).size)) != size)) {
                mm_support_axerror((uint8_t*)"1:movdq size");
            };
            regcode = ma_genss_getregcoderx((int64_t)((*b).reg));
            am = ma_genss_genrm(a,regcode);
            ma_genss_setopsize(a);
            ma_genss_genbyte((int64_t)102);
            ma_genss_genrex();
            ma_genss_genbyte((int64_t)15);
            ma_genss_genbyte((int64_t)126);
            ma_genss_genamode(b,am);
        } else {
            mm_support_axerror((uint8_t*)"movdq reg,?");
        };
    }else if (((int64_t)((*a).mode)==(int64_t)5)) {
        if (((int64_t)((*b).mode)==(int64_t)1)) {
            if (((int64_t)((uint64_t)((*b).size)) != size)) {
                mm_support_axerror((uint8_t*)"3:movdq size");
            };
            regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
            am = ma_genss_genrm(b,regcode);
            ma_genss_setopsize(b);
            ma_genss_genbyte((int64_t)102);
            ma_genss_genrex();
            ma_genss_genbyte((int64_t)15);
            ma_genss_genbyte((int64_t)110);
            ma_genss_genamode(a,am);
        }else if (((int64_t)((*b).mode)==(int64_t)5)) {
            regcode1 = ma_genss_getregcoderx((int64_t)((*a).reg));
            regcode2 = ma_genss_getregcodebx((int64_t)((*b).reg));
            ma_genss_genbyte((int64_t)243);
            ma_genss_genrex();
            ma_genss_genbyte((int64_t)15);
            ma_genss_genbyte((int64_t)126);
            ma_genss_genbyte((((int64_t)192 + (regcode1 << (int64_t)3)) + regcode2));
        }else if (((int64_t)((*b).mode)==(int64_t)3)) {
            if ((!!((uint64_t)((*b).size)) && ((int64_t)((uint64_t)((*b).size)) != size))) {
                mm_support_axerror((uint8_t*)"4:movdq size");
            };
            regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
            am = ma_genss_genrm(b,regcode);
            if ((size == (int64_t)4)) {
                ma_genss_genbyte((int64_t)102);
                ma_genss_genrex();
                ma_genss_genbyte((int64_t)15);
                ma_genss_genbyte((int64_t)110);
            } else {
                ma_genss_genbyte((int64_t)243);
                ma_genss_genrex();
                ma_genss_genbyte((int64_t)15);
                ma_genss_genbyte((int64_t)126);
            };
            ma_genss_genamode(b,am);
        } else {
            mm_support_axerror((uint8_t*)"movdq xreg,?");
        };
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
        if (((int64_t)((*b).mode)==(int64_t)5)) {
            if ((!!((uint64_t)((*a).size)) && ((int64_t)((uint64_t)((*a).size)) != size))) {
                mm_support_axerror((uint8_t*)"5:movdq size");
            };
            regcode = ma_genss_getregcoderx((int64_t)((*b).reg));
            am = ma_genss_genrm(a,regcode);
            if ((size == (int64_t)4)) {
                ma_genss_genbyte((int64_t)102);
                ma_genss_genrex();
                ma_genss_genbyte((int64_t)15);
                ma_genss_genbyte((int64_t)126);
            } else {
                ma_genss_genbyte((int64_t)102);
                ma_genss_genrex();
                ma_genss_genbyte((int64_t)15);
                ma_genss_genbyte((int64_t)214);
            };
            ma_genss_genamode(a,am);
        } else {
            mm_support_axerror((uint8_t*)"movdq mem,?");
        };
    } else {
        mm_support_axerror((uint8_t*)"movdq opnds");
    };
}

static void ma_genss_do_arithxmm(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t prefix,int64_t opc) {
    int64_t am;
    int64_t regcode;
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)5) || (((int64_t)((uint64_t)((*b).mode)) != (int64_t)5) && ((int64_t)((uint64_t)((*b).mode)) != (int64_t)3)))) {
        mm_support_axerror((uint8_t*)"arithxmm opnds");
    };
    if (((int64_t)((uint64_t)((*b).mode)) == (int64_t)5)) {
        regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        if (!!(prefix)) {
            ma_genss_genbyte(prefix);
        };
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte(opc);
        ma_genss_genamode(a,am);
    } else {
        regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        if (!!(prefix)) {
            ma_genss_genbyte(prefix);
        };
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte(opc);
        ma_genss_genamode(b,am);
    };
}

static void ma_genss_do_logicxmm(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc,int64_t size) {
    int64_t am;
    int64_t regcode;
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)5) || (((int64_t)((uint64_t)((*b).mode)) != (int64_t)5) && ((int64_t)((uint64_t)((*b).mode)) != (int64_t)3)))) {
        mm_support_axerror((uint8_t*)"logicxmm opnds");
    };
    if ((size == (int64_t)8)) {
        ma_genss_genbyte((int64_t)102);
    };
    if (((int64_t)((uint64_t)((*b).mode)) == (int64_t)5)) {
        regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte(opc);
        ma_genss_genamode(b,am);
    } else {
        regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte(opc);
        ma_genss_genamode(b,am);
    };
}

static void ma_genss_do_convertfloat(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t prefix) {
    int64_t am;
    int64_t regcode;
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)5) || (((int64_t)((uint64_t)((*b).mode)) != (int64_t)5) && ((int64_t)((uint64_t)((*b).mode)) != (int64_t)3)))) {
        mm_support_axerror((uint8_t*)"convertfloat opnds");
    };
    ma_genss_genbyte(prefix);
    if (((int64_t)((uint64_t)((*a).mode)) == (int64_t)5)) {
        regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte((int64_t)90);
        ma_genss_genamode(b,am);
    } else {
        regcode = ma_genss_getregcoderx((int64_t)((*b).reg));
        am = ma_genss_genrm(a,regcode);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte((int64_t)90);
        ma_genss_genamode(b,am);
    };
}

static void ma_genss_do_fix(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t prefix,int64_t opc) {
    int64_t am;
    int64_t regcode;
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)1) || (((int64_t)((uint64_t)((*b).mode)) != (int64_t)5) && ((int64_t)((uint64_t)((*b).mode)) != (int64_t)3)))) {
        mm_support_axerror((uint8_t*)"fix opnds");
    };
    ma_genss_genbyte(prefix);
    if (((int64_t)((uint64_t)((*b).mode)) == (int64_t)5)) {
        regcode = ma_genss_getregcoder((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        ma_genss_setopsize(a);
    } else {
        regcode = ma_genss_getregcoder((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        ma_genss_setopsize(a);
    };
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)15);
    ma_genss_genbyte(opc);
    ma_genss_genamode(b,am);
}

static void ma_genss_do_float(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t prefix) {
    int64_t am;
    int64_t regcode;
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)5) || (((int64_t)((uint64_t)((*b).mode)) != (int64_t)1) && ((int64_t)((uint64_t)((*b).mode)) != (int64_t)3)))) {
        mm_support_axerror((uint8_t*)"float opnds");
    };
    if (((int64_t)((uint64_t)((*b).mode)) == (int64_t)3)) {
        if (((int64_t)((uint64_t)((*b).size)) == (int64_t)0)) {
            (*b).size = (uint64_t)((int64_t)4);
        };
        if ((((int64_t)((uint64_t)((*b).size)) != (int64_t)4) && ((int64_t)((uint64_t)((*b).size)) != (int64_t)8))) {
            mm_support_axerror((uint8_t*)"float size");
        };
    };
    ma_genss_genbyte(prefix);
    regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
    am = ma_genss_genrm(b,regcode);
    ma_genss_setopsize(b);
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)15);
    ma_genss_genbyte((int64_t)42);
    ma_genss_genamode(b,am);
}

static void ma_genss_do_call(struct mm_mcldecls_opndrec * a) {
    int64_t am;
    if (((int64_t)((*a).mode)==(int64_t)2)) {
        ma_genss_genbyte((int64_t)232);
        ma_genss_genrel32(a);
    } else {
        if (((int64_t)((*a).size)==(int64_t)0)) {
            (*a).size = (uint64_t)((int64_t)8);
        }else if (((int64_t)((*a).size)==(int64_t)1) || ((int64_t)((*a).size)==(int64_t)2) || ((int64_t)((*a).size)==(int64_t)4)) {
            mm_support_axerror((uint8_t*)"call[]size");
        };
        am = ma_genss_genrm(a,(int64_t)2);
        ma_genss_setopsize(a);
        ma_genss_setaddrsize(a);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)255);
        ma_genss_genamode(a,am);
    };
}

static void ma_genss_do_jmp(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_mclrec * m) {
    int64_t am;
    int64_t offset;
    int64_t shortjmp;
    struct mm_decls_strec *  d;
    if (((int64_t)((*a).mode)==(int64_t)2)) {
        if (((int64_t)((*a).valtype)==(int64_t)6) || ((int64_t)((*a).valtype)==(int64_t)5)) {
            d = ma_genss_getdef(a,(int64_t)1);
            offset = (ma_genss_getrel32(d,(ma_genss_getcurrdatalen((int64_t)11) + (int64_t)1)) + (int64_t)((*a).offset));
            if (((offset < (int64_t)0) && (offset > (int64_t)-126))) {
                ma_genss_genbyte((int64_t)235);
                ma_genss_genbyte(offset);
            } else {
                shortjmp = (int64_t)0;
                if ((offset > (int64_t)0)) {
                };
                if (!(!!(shortjmp))) {
                    ma_genss_genbyte((int64_t)233);
                    ma_genss_genrel32(a);
                } else {
                    ma_genss_genbyte((int64_t)235);
                    ma_genss_genrel8(a);
                };
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_mcldecls_valtypenames[((int64_t)((*a).valtype))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_axerror((uint8_t*)"JMP/IMM NOT LABELNO");
        };
    } else {
        if (((int64_t)((*a).size)==(int64_t)0)) {
            (*a).size = (uint64_t)((int64_t)8);
        }else if (((int64_t)((*a).size)==(int64_t)1) || ((int64_t)((*a).size)==(int64_t)2) || ((int64_t)((*a).size)==(int64_t)4)) {
            mm_support_axerror((uint8_t*)"jmp[]size");
        };
        am = ma_genss_genrm(a,(int64_t)4);
        ma_genss_setopsize(a);
        ma_genss_setaddrsize(a);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)255);
        ma_genss_genamode(a,am);
    };
}

static int64_t ma_genss_getcurrdatalen(int64_t id) {
    if ((ma_genss_currseg == (int64_t)3)) {
        return ma_decls_ss_zdatalen;
    };
    return ma_lib_bufferlength(ma_genss_currdata);
}

static void ma_genss_do_cmovcc(int64_t cond,struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    int64_t am;
    int64_t regcode;
    if ((((uint64_t)((*a).size) != (uint64_t)((*b).size)) && !!((uint64_t)((*b).size)))) {
        mm_support_axerror((uint8_t*)"Opnd size mismatch");
    };
    if (((int64_t)((uint64_t)((*a).size)) == (int64_t)1)) {
        mm_support_axerror((uint8_t*)"cmov/byte");
    };
    regcode = ma_genss_getregcoder((int64_t)((*a).reg));
    am = ma_genss_genrm(b,regcode);
    ma_genss_setopsize(a);
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)15);
    ma_genss_genbyte(((int64_t)64 + cond));
    ma_genss_genamode(b,am);
}

static void ma_genss_do_fmem(struct mm_mcldecls_opndrec * a,int64_t freal,int64_t code) {
    int64_t am;
    int64_t mf;
    if (((int64_t)((uint64_t)((*a).mode)) != (int64_t)3)) {
        mm_support_axerror((uint8_t*)"fmem/not mem");
    };
    if (!!(freal)) {
        if (((int64_t)((*a).size)==(int64_t)4)) {
            mf = (int64_t)0;
        }else if (((int64_t)((*a).size)==(int64_t)8)) {
            mf = (int64_t)2;
        }else if (((int64_t)((*a).size)==(int64_t)16)) {
            mf = (int64_t)1;
            if ((code==(int64_t)0)) {
                code = (int64_t)5;
            }else if ((code==(int64_t)3)) {
                code = (int64_t)7;
            } else {
                mm_support_axerror((uint8_t*)"r80 not allowed");
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"SIZE=",NULL);
            msysnewc_m_print_u64((*a).size,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_axerror((uint8_t*)"fmem size");
        };
    } else {
        if (((int64_t)((*a).size)==(int64_t)2)) {
            mf = (int64_t)3;
        }else if (((int64_t)((*a).size)==(int64_t)4)) {
            mf = (int64_t)1;
        }else if (((int64_t)((*a).size)==(int64_t)8)) {
            mf = (int64_t)3;
            if ((code==(int64_t)0)) {
                code = (int64_t)5;
            }else if ((code==(int64_t)3)) {
                code = (int64_t)7;
            } else {
                mm_support_axerror((uint8_t*)"fst i64?");
            };
        } else {
            mm_support_axerror((uint8_t*)"fmem int size");
        };
    };
    am = ma_genss_genrm(a,code);
    ma_genss_genrex();
    ma_genss_genbyte(((int64_t)217 + (mf << (int64_t)1)));
    ma_genss_genamode(a,am);
}

static int64_t ma_genss_getr32bits(double x) {
    float sx;
    sx = (float)(x);
    return (int64_t)(*(int32_t*)&sx);
}

static void ma_genss_genrel8(struct mm_mcldecls_opndrec * a) {
    struct mm_decls_strec *  d;
    d = ma_genss_getdef(a,(int64_t)1);
    if (((int64_t)((uint64_t)((*d).reftype)) == (int64_t)1)) {
        (*d).fwdrefs = ma_genss_addfwdref((*d).fwdrefs,ma_genss_getcurrdatalen((int64_t)3),(int64_t)6,(int64_t)0);
        ma_genss_genbyte((int64_t)0);
    } else {
        mm_support_axerror((uint8_t*)"genrel8");
    };
}

static int64_t ma_genss_checkshortjump(struct mm_mcldecls_mclrec * m,struct mm_decls_strec * d) {
    int64_t n;
    return (int64_t)0;
    n = (int64_t)0;
    m = (*m).nextmcl;
    L928 :;
    while ((!!(m) && (n <= (int64_t)8))) {
        if (((int64_t)((*m).opcode)==(int64_t)5)) {
            if (((*(*m).a).labelno == (int64_t)((*d).labelno))) {
                return (int64_t)1;
            };
        }else if (((int64_t)((*m).opcode)==(int64_t)1) || ((int64_t)((*m).opcode)==(int64_t)2)) {
        } else {
            ++n;
        };
        m = (*m).nextmcl;
L929 :;
    }L930 :;
    ;
    return (int64_t)0;
}

static struct mm_decls_fwdrec * ma_genss_addfwdref(struct mm_decls_fwdrec * p,int64_t offset,int64_t reltype,int64_t seg) {
    struct mm_decls_fwdrec *  q;
    q = (struct mm_decls_fwdrec *)(mlib_pcm_alloc((int64_t)16));
    (*q).nextfwd = p;
    (*q).offset = offset;
    (*q).reltype = reltype;
    (*q).seg = seg;
    return q;
}

static void ma_genss_switchseg(int64_t newseg) {
    if ((newseg == ma_genss_currseg)) {
        return;
    };
    if ((ma_genss_currseg==(int64_t)1)) {
        ma_decls_ss_coderelocs = ma_genss_currrelocs;
        ma_decls_ss_ncoderelocs = ma_genss_nrelocs;
    }else if ((ma_genss_currseg==(int64_t)2)) {
        ma_decls_ss_idatarelocs = ma_genss_currrelocs;
        ma_decls_ss_nidatarelocs = ma_genss_nrelocs;
    };
    ma_genss_currseg = newseg;
    if ((ma_genss_currseg==(int64_t)1)) {
        ma_genss_currdata = ma_decls_ss_code;
        ma_genss_currrelocs = ma_decls_ss_coderelocs;
        ma_genss_nrelocs = ma_decls_ss_ncoderelocs;
    }else if ((ma_genss_currseg==(int64_t)2)) {
        ma_genss_currdata = ma_decls_ss_idata;
        ma_genss_currrelocs = ma_decls_ss_idatarelocs;
        ma_genss_nrelocs = ma_decls_ss_nidatarelocs;
    }else if ((ma_genss_currseg==(int64_t)3)) {
        ma_genss_currdata = ma_decls_ss_zdata;
    };
}

static void ma_genss_do_movdqx(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc) {
    int64_t am;
    int64_t regcode;
    if (((int64_t)((*a).mode)==(int64_t)5)) {
        if (((int64_t)((*b).mode)==(int64_t)5)) {
            regcode = ma_genss_getregcodebx((int64_t)((*b).reg));
            am = ma_genss_genrm(a,regcode);
            ma_genss_genbyte(opc);
            ma_genss_genrex();
            ma_genss_genbyte((int64_t)15);
            ma_genss_genbyte((int64_t)111);
            ma_genss_genamode(a,am);
        }else if (((int64_t)((*b).mode)==(int64_t)3)) {
            regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
            am = ma_genss_genrm(b,regcode);
            ma_genss_genbyte(opc);
            ma_genss_genrex();
            ma_genss_genbyte((int64_t)15);
            ma_genss_genbyte((int64_t)111);
            ma_genss_genamode(b,am);
        } else {
            mm_support_axerror((uint8_t*)"movdqx?");
        };
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
        if (((int64_t)((*b).mode)==(int64_t)5)) {
            regcode = ma_genss_getregcoderx((int64_t)((*b).reg));
            am = ma_genss_genrm(a,regcode);
            ma_genss_genbyte(opc);
            ma_genss_genrex();
            ma_genss_genbyte((int64_t)15);
            ma_genss_genbyte((int64_t)127);
            ma_genss_genamode(a,am);
        } else {
            mm_support_axerror((uint8_t*)"movdqx");
        };
    } else {
        mm_support_axerror((uint8_t*)"movdqx");
    };
}

static void ma_genss_do_popcnt(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b) {
    int64_t am;
    int64_t regcode;
    if (((int64_t)((uint64_t)((*b).mode)) == (int64_t)3)) {
        if (((int64_t)((uint64_t)((*b).size)) == (int64_t)0)) {
            (*b).size = (uint64_t)((int64_t)8);
        };
    };
    ma_genss_genbyte((int64_t)243);
    regcode = ma_genss_getregcodebx((int64_t)((*a).reg));
    am = ma_genss_genrm(b,regcode);
    ma_genss_setopsize(a);
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)15);
    ma_genss_genbyte((int64_t)184);
    ma_genss_genamode(b,am);
}

static void ma_genss_do_bsf(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t opc) {
    int64_t am;
    int64_t regcode;
    if (((int64_t)((uint64_t)((*b).mode)) == (int64_t)3)) {
        if (((int64_t)((uint64_t)((*b).size)) == (int64_t)0)) {
            (*b).size = (uint64_t)((int64_t)8);
        };
    };
    if (((uint64_t)((*a).size) != (uint64_t)((*b).size))) {
        mm_support_gerror((uint8_t*)"bsf size",(struct mm_decls_unitrec *)(0));
    };
    regcode = ma_genss_getregcodebx((int64_t)((*a).reg));
    am = ma_genss_genrm(b,regcode);
    ma_genss_setopsize(a);
    ma_genss_genrex();
    ma_genss_genbyte((int64_t)15);
    ma_genss_genbyte(opc);
    ma_genss_genamode(b,am);
}

static void ma_genss_extendsymboltable(void) {
    struct mm_decls_strec * (*oldsymboltable)[];
    int64_t oldsymboltablesize;
    int64_t i;
    oldsymboltablesize = ma_decls_ss_symboltablesize;
    oldsymboltable = ma_decls_ss_symboltable;
    ma_decls_ss_symboltablesize *= (int64_t)2;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"EXTENDING SYMBOL TABLE TO",NULL);
    msysnewc_m_print_i64(ma_decls_ss_symboltablesize,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    ma_decls_ss_symboltable = (struct mm_decls_strec * (*)[])(mlib_pcm_alloc(((int64_t)8 * ma_decls_ss_symboltablesize)));
    L931 :;
    for (i=(int64_t)1;i<=ma_decls_ss_nsymbols;i+=(int64_t)1) {
L932 :;
        (*ma_decls_ss_symboltable)[(i)-1] = (*oldsymboltable)[(i)-1];
L933 :;
    }L934 :;
    ;
    mlib_pcm_free((void *)(oldsymboltable),((int64_t)8 * oldsymboltablesize));
}

static void ma_genss_showopnd(uint8_t * caption,struct mm_mcldecls_opndrec * a) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_str(mm_mcldecls_opndnames_ma[((int64_t)((*a).mode))],NULL);
    msysnewc_m_print_str(mm_mcldecls_valtypenames[((int64_t)((*a).valtype))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void ma_genss_do_pcmpistri(struct mm_mcldecls_opndrec * a,struct mm_mcldecls_opndrec * b,int64_t c,int64_t opc) {
    int64_t am;
    int64_t regcode;
    if ((((int64_t)((uint64_t)((*a).mode)) != (int64_t)5) || (((int64_t)((uint64_t)((*b).mode)) != (int64_t)5) && ((int64_t)((uint64_t)((*b).mode)) != (int64_t)3)))) {
        mm_support_gerror((uint8_t*)"pcmpistrx opnds",(struct mm_decls_unitrec *)(0));
    };
    ma_genss_genbyte((int64_t)102);
    if (((int64_t)((uint64_t)((*b).mode)) == (int64_t)5)) {
        {struct mm_mcldecls_opndrec *  temp = a; a = b; b = temp; };
        regcode = ma_genss_getregcoderx((int64_t)((*b).reg));
        am = ma_genss_genrm(a,regcode);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte((int64_t)58);
        ma_genss_genbyte(opc);
        ma_genss_genamode(a,am);
    } else {
        regcode = ma_genss_getregcoderx((int64_t)((*a).reg));
        am = ma_genss_genrm(b,regcode);
        ma_genss_genrex();
        ma_genss_genbyte((int64_t)15);
        ma_genss_genbyte((int64_t)58);
        ma_genss_genbyte(opc);
        ma_genss_genamode(b,am);
    };
    ma_genss_genbyte(c);
}

void ma_lib_initlib(int64_t nlabels) {
    uint8_t str[256];
    int64_t i;
    ma_decls_ss_symboltable = (struct mm_decls_strec * (*)[])(mlib_pcm_alloc((int64_t)131072));
    ma_decls_ss_symboltablesize = (int64_t)16384;
    ma_decls_ss_nsymbols = (int64_t)0;
    ma_decls_labeldeftable = (struct mm_decls_strec * (*)[])(mlib_pcm_alloc((nlabels * (int64_t)8)));
    L935 :;
    for (i=(int64_t)1;i<=nlabels;i+=(int64_t)1) {
L936 :;
        (*ma_decls_labeldeftable)[(i)-1] = mm_lib_newstrec();
        (*(*ma_decls_labeldeftable)[(i)-1]).labelno = i;
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"(L#)");
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_end();
        ;
        (*(*ma_decls_labeldeftable)[(i)-1]).name = mlib_pcm_copyheapstring(str);
        (*(*ma_decls_labeldeftable)[(i)-1]).reftype = (uint64_t)((int64_t)1);
L937 :;
    }L938 :;
    ;
}

static uint8_t * ma_lib_getsizetag(int64_t size) {
    if ((size==(int64_t)1)) {
        return (uint8_t*)"b";
    }else if ((size==(int64_t)2)) {
        return (uint8_t*)"h";
    }else if ((size==(int64_t)4)) {
        return (uint8_t*)"w";
    }else if ((size==(int64_t)8)) {
        return (uint8_t*)"d";
    };
    mm_support_axerror((uint8_t*)"GETSIZETAG?");
    return (uint8_t *)(0);
}

struct ma_decls_dbuffer * ma_lib_buffercreate(int64_t size) {
    struct ma_decls_dbuffer *  a;
    a = (struct ma_decls_dbuffer *)(mlib_pcm_alloc((int64_t)32));
    (*a).alloc = size;
    (*a).pstart = ((*a).pcurr = (byte *)(mlib_pcm_alloc((*a).alloc)));
    (*a).pend = ((*a).pstart + (*a).alloc);
    return a;
}

static void ma_lib_bufferexpand(struct ma_decls_dbuffer * a) {
    int64_t newalloc;
    int64_t usedbytes;
    byte *  p;
    newalloc = ((*a).alloc * (int64_t)2);
    usedbytes = ((*a).pcurr - (*a).pstart);
    if ((usedbytes > (*a).alloc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"dbuffer error",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    };
    p = (byte *)(mlib_pcm_alloc(newalloc));
    memcpy((void *)(p),(void *)((*a).pstart),(uint64_t)(usedbytes));
    (*a).pstart = p;
    (*a).pcurr = (p + usedbytes);
    (*a).alloc = newalloc;
    (*a).pend = (p + newalloc);
}

void ma_lib_buffercheck(struct ma_decls_dbuffer * a,int64_t n) {
    L939 :;
    while ((((*a).pend - (*a).pcurr) < n)) {
        ma_lib_bufferexpand(a);
L940 :;
    }L941 :;
    ;
}

int64_t ma_lib_bufferlength(struct ma_decls_dbuffer * a) {
    return ((*a).pcurr - (*a).pstart);
}

void * ma_lib_bufferelemptr(struct ma_decls_dbuffer * a,int64_t offset) {
    return (void *)(((*a).pstart + offset));
}

void ma_lib_addbyte(struct ma_decls_dbuffer * a,int64_t x) {
    (*(*a).pcurr) = (uint64_t)(x);
    ++(*a).pcurr;
}

void ma_lib_addword(struct ma_decls_dbuffer * a,int64_t x) {
    (*(*a).pcurr16) = (uint64_t)(x);
    ++(*a).pcurr16;
}

void ma_lib_adddword(struct ma_decls_dbuffer * a,int64_t x) {
    (*(*a).pcurr32) = (uint64_t)(x);
    ++(*a).pcurr32;
}

void ma_lib_addqword(struct ma_decls_dbuffer * a,int64_t x) {
    (*(*a).pcurr64) = (uint64_t)(x);
    ++(*a).pcurr64;
}

void ma_writeobj_writess(uint8_t * outfile) {
    ma_writeobj_writecoff(outfile);
}

static void ma_writeobj_writerecord(void * r,int64_t length) {
    memcpy((void *)(ma_writeobj_dataptr),r,(uint64_t)(length));
    ma_writeobj_dataptr += length;
}

static void ma_writeobj_writerelocs(struct ma_decls_relocrec * r,int64_t nrelocs) {
    static struct ma_objdecls_coffrelocrec s;
    struct mm_decls_strec *  d;
    if ((nrelocs == (int64_t)0)) {
        return;
    };
    L942 :;
    while (!!(r)) {
        if (((*r).reloctype==(int64_t)2) || ((*r).reloctype==(int64_t)1)) {
            d = (*ma_decls_ss_symboltable)[((*r).stindex)-1];
            if (((int64_t)((*d).segment)==(int64_t)3)) {
                s.stindex = (int64_t)2;
            }else if (((int64_t)((*d).segment)==(int64_t)2)) {
                s.stindex = (int64_t)4;
            }else if (((int64_t)((*d).segment)==(int64_t)1)) {
                s.stindex = (int64_t)6;
            }else if (((int64_t)((*d).segment)==(int64_t)0)) {
                s.stindex = ((*r).stindex + ma_writeobj_stoffset);
            } else {
                mm_support_gerror((uint8_t*)"wrelocs/bad seg",(struct mm_decls_unitrec *)(0));
            };
        } else {
            s.stindex = ((*r).stindex + ma_writeobj_stoffset);
        };
        s.reloctype = (*r).reloctype;
        s.virtualaddr = (*r).offset;
        memcpy((void *)(ma_writeobj_dataptr),(void *)(&s),(uint64_t)((int64_t)10));
        ma_writeobj_dataptr += (int64_t)10;
        r = (*r).nextreloc;
L943 :;
    }L944 :;
    ;
}

static void ma_writeobj_writedata(struct ma_decls_dbuffer * data) {
    memcpy((void *)(ma_writeobj_dataptr),ma_lib_bufferelemptr(data,(int64_t)0),(uint64_t)(ma_lib_bufferlength(data)));
    ma_writeobj_dataptr += ma_lib_bufferlength(data);
}

static void ma_writeobj_writesymboltable(void) {
    int64_t i;
    L945 :;
    for (i=(int64_t)1;i<=ma_writeobj_nsymbols;i+=(int64_t)1) {
L946 :;
        ma_writeobj_writerecord((void *)(&ma_writeobj_symboltable[(i)]),(int64_t)18);
L947 :;
    }L948 :;
    ;
}

static void ma_writeobj_writestringtable(void) {
    int32_t *  p;
    int64_t i;
    int64_t n;
    p = (int32_t *)(ma_writeobj_dataptr);
    (*p) = ma_writeobj_nextstringoffset;
    ma_writeobj_dataptr += (int64_t)4;
    L949 :;
    for (i=(int64_t)1;i<=ma_writeobj_nstrings;i+=(int64_t)1) {
L950 :;
        n = (ma_writeobj_stringlengths[(i)-1] + (int64_t)1);
        memcpy((void *)(ma_writeobj_dataptr),(void *)(ma_writeobj_stringtable[(i)-1]),(uint64_t)(n));
        ma_writeobj_dataptr += n;
L951 :;
    }L952 :;
    ;
}

static struct ma_objdecls_imagesymbol * ma_writeobj_makesymbol(uint8_t * name,int64_t namelen,int64_t value,int64_t sectionno,int64_t symtype,int64_t storage,int64_t naux) {
    static struct ma_objdecls_imagesymbol r;
    if ((namelen == (int64_t)0)) {
        namelen = (int64_t)(strlen((int8_t *)(name)));
    };
    if ((namelen < (int64_t)8)) {
        strcpy((int8_t *)(&r.shortname[((int64_t)1)-1]),(int8_t *)(name));
    } else if ((namelen == (int64_t)8)) {
        memcpy((void *)(&r.shortname[((int64_t)1)-1]),(void *)(name),(uint64_t)(namelen));
    } else {
        r.shortx = (uint64_t)((int64_t)0);
        r.longx = (uint64_t)(ma_writeobj_addstringentry(name,namelen));
    };
    r.value = (uint64_t)(value);
    r.sectionno = sectionno;
    r.symtype = (uint64_t)(symtype);
    r.storageclass = (uint64_t)(storage);
    r.nauxsymbols = (uint64_t)(naux);
    return &r;
}

static void ma_writeobj_addsymbol(struct ma_objdecls_imagesymbol * r) {
    if ((ma_writeobj_nsymbols >= (int64_t)10001)) {
        mm_support_gerror((uint8_t*)"as:Too many symbols",(struct mm_decls_unitrec *)(0));
    };
    memcpy((void *)(&ma_writeobj_symboltable[(++ma_writeobj_nsymbols)]),(void *)(r),(uint64_t)((int64_t)18));
}

static void ma_writeobj_initsymboltable(uint8_t * filename) {
    ma_writeobj_nsymbols = (int64_t)0;
    ma_writeobj_addsymbol(ma_writeobj_makesymbol((uint8_t*)".file",(int64_t)0,(int64_t)0,(int64_t)-2,(int64_t)0,(int64_t)103,(int64_t)1));
    ma_writeobj_addsymbol(ma_writeobj_strtoaux(filename));
    ma_writeobj_addsymbol(ma_writeobj_makesymbol((uint8_t*)".bss",(int64_t)0,(int64_t)0,(int64_t)1,(int64_t)0,(int64_t)3,(int64_t)1));
    ma_writeobj_addsymbol((struct ma_objdecls_imagesymbol *)(ma_writeobj_sectiontoaux((struct ma_decls_dbuffer *)(0),(int64_t)0)));
    ma_writeobj_addsymbol(ma_writeobj_makesymbol((uint8_t*)".data",(int64_t)0,(int64_t)0,(int64_t)2,(int64_t)0,(int64_t)3,(int64_t)1));
    ma_writeobj_addsymbol((struct ma_objdecls_imagesymbol *)(ma_writeobj_sectiontoaux(ma_decls_ss_idata,ma_decls_ss_nidatarelocs)));
    ma_writeobj_addsymbol(ma_writeobj_makesymbol((uint8_t*)".text",(int64_t)0,(int64_t)0,(int64_t)3,(int64_t)0,(int64_t)3,(int64_t)1));
    ma_writeobj_addsymbol((struct ma_objdecls_imagesymbol *)(ma_writeobj_sectiontoaux(ma_decls_ss_code,ma_decls_ss_ncoderelocs)));
}

static struct ma_objdecls_imagesymbol * ma_writeobj_strtoaux(uint8_t * s) {
    static struct ma_objdecls_imagesymbol r;
    byte *  p;
    int64_t n;
    p = (byte *)(&r);
    memset((void *)(p),(int64_t)0,(uint64_t)((int64_t)18));
    n = (int64_t)0;
    L953 :;
    while ((((int64_t)((*s)) != (int64_t)0) && (n < (int64_t)18))) {
        (*p++) = (uint64_t)((*s++));
        ++n;
L954 :;
    }L955 :;
    ;
    return &r;
}

static struct ma_objdecls_auxsectionrec * ma_writeobj_sectiontoaux(struct ma_decls_dbuffer * data,int64_t nrelocs) {
    static struct ma_objdecls_auxsectionrec r;
    memset((void *)(&r),(int64_t)0,(uint64_t)((int64_t)18));
    if ((data == 0)) {
        r.length = ma_decls_ss_zdatalen;
    } else {
        r.length = ma_lib_bufferlength(data);
    };
    r.nrelocs = nrelocs;
    return &r;
}

static int64_t ma_writeobj_addstringentry(uint8_t * s,int64_t length) {
    int64_t offset;
    offset = ma_writeobj_nextstringoffset;
    if ((ma_writeobj_nstrings > (int64_t)5000)) {
        mm_support_gerror((uint8_t*)"W:too many strings",(struct mm_decls_unitrec *)(0));
    };
    ma_writeobj_stringtable[(++ma_writeobj_nstrings)-1] = s;
    ma_writeobj_stringlengths[(ma_writeobj_nstrings)-1] = length;
    ma_writeobj_nextstringoffset += (length + (int64_t)1);
    return offset;
}

static void ma_writeobj_convertsymboltable(void) {
    struct mm_decls_strec *  s;
    uint8_t *  name;
    int64_t i;
    int64_t sect;
    int64_t scope;
    ma_writeobj_stoffset = (ma_writeobj_nsymbols - (int64_t)1);
    ma_writeobj_nstrings = (int64_t)0;
    ma_writeobj_nextstringoffset = (int64_t)4;
    L956 :;
    for (i=(int64_t)1;i<=ma_decls_ss_nsymbols;i+=(int64_t)1) {
L957 :;
        s = (*ma_decls_ss_symboltable)[(i)-1];
        name = (*s).name;
        if (!!((*s).truename)) {
            name = (*s).truename;
        };
        if ((name == 0)) {
            goto L958 ;
        };
        if (((int64_t)((*s).segment)==(int64_t)3)) {
            sect = (int64_t)1;
        }else if (((int64_t)((*s).segment)==(int64_t)2)) {
            sect = (int64_t)2;
        }else if (((int64_t)((*s).segment)==(int64_t)1)) {
            sect = (int64_t)3;
        } else {
            sect = (int64_t)0;
        };
        if (!!((uint64_t)((*s).isglobal))) {
            scope = (int64_t)2;
        } else {
            scope = (int64_t)3;
        };
        ma_writeobj_addsymbol(ma_writeobj_makesymbol(name,(int64_t)((*s).namelen),(int64_t)((*s).offset),sect,(int64_t)0,scope,(int64_t)0));
L958 :;
    }L959 :;
    ;
}

static void ma_writeobj_writecoff(uint8_t * outfile) {
    struct ma_objdecls_imagefileheader header;
    struct ma_objdecls_imagesectionheader zsection;
    struct ma_objdecls_imagesectionheader isection;
    struct ma_objdecls_imagesectionheader csection;
    int64_t offset;
    int64_t aa;
    memset((void *)(&header),(int64_t)0,(uint64_t)((int64_t)20));
    memset((void *)(&zsection),(int64_t)0,(uint64_t)((int64_t)40));
    memset((void *)(&isection),(int64_t)0,(uint64_t)((int64_t)40));
    memset((void *)(&csection),(int64_t)0,(uint64_t)((int64_t)40));
    header.machine = (uint64_t)((int64_t)34404);
    header.nsections = (uint64_t)((int64_t)3);
    strcpy((int8_t *)(&zsection.name[((int64_t)1)-1]),(int8_t *)((uint8_t*)".bss"));
    zsection.rawdata_size = (uint64_t)(ma_decls_ss_zdatalen);
    aa = (int64_t)3225419904;
    zsection.characteristics = (uint64_t)(aa);
    if (((ma_decls_ss_nidatarelocs > (int64_t)65536) || (ma_decls_ss_ncoderelocs > (int64_t)65536))) {
        mm_support_gerror((uint8_t*)"Too many relocs (exceeds 16-bit field)",(struct mm_decls_unitrec *)(0));
    };
    strcpy((int8_t *)(&isection.name[((int64_t)1)-1]),(int8_t *)((uint8_t*)".data"));
    isection.rawdata_size = (uint64_t)(ma_lib_bufferlength(ma_decls_ss_idata));
    isection.nrelocs = (uint64_t)(ma_decls_ss_nidatarelocs);
    aa = (int64_t)3226468416;
    isection.characteristics = (uint64_t)(aa);
    strcpy((int8_t *)(&csection.name[((int64_t)1)-1]),(int8_t *)((uint8_t*)".text"));
    csection.rawdata_size = (uint64_t)(ma_lib_bufferlength(ma_decls_ss_code));
    csection.nrelocs = (uint64_t)(ma_decls_ss_ncoderelocs);
    aa = (int64_t)1615855648;
    csection.characteristics = (uint64_t)(aa);
    ma_writeobj_initsymboltable(outfile);
    ma_writeobj_convertsymboltable();
    offset = (int64_t)20;
    offset += (int64_t)120;
    if (!!((uint64_t)(isection.nrelocs))) {
        isection.relocations_ptr = (uint64_t)(offset);
        offset += ((int64_t)((uint64_t)(isection.nrelocs)) * (int64_t)10);
    };
    if (!!((uint64_t)(csection.nrelocs))) {
        csection.relocations_ptr = (uint64_t)(offset);
        offset += ((int64_t)((uint64_t)(csection.nrelocs)) * (int64_t)10);
    };
    isection.rawdata_offset = (uint64_t)(offset);
    offset += (int64_t)(isection.rawdata_size);
    csection.rawdata_offset = (uint64_t)(offset);
    offset += (int64_t)(csection.rawdata_size);
    header.symtaboffset = (uint64_t)(offset);
    offset += (ma_writeobj_nsymbols * (int64_t)18);
    header.nsymbols = (uint64_t)(ma_writeobj_nsymbols);
    offset += ma_writeobj_nextstringoffset;
    ma_writeobj_datastart = (ma_writeobj_dataptr = (byte *)(malloc((uint64_t)(offset))));
    ma_writeobj_writerecord((void *)(&header),(int64_t)20);
    ma_writeobj_writerecord((void *)(&zsection),(int64_t)40);
    ma_writeobj_writerecord((void *)(&isection),(int64_t)40);
    ma_writeobj_writerecord((void *)(&csection),(int64_t)40);
    ma_writeobj_writerelocs(ma_decls_ss_idatarelocs,ma_decls_ss_nidatarelocs);
    ma_writeobj_writerelocs(ma_decls_ss_coderelocs,ma_decls_ss_ncoderelocs);
    ma_writeobj_writedata(ma_decls_ss_idata);
    ma_writeobj_writedata(ma_decls_ss_code);
    ma_writeobj_writesymboltable();
    ma_writeobj_writestringtable();
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Writing file:",NULL);
    msysnewc_m_print_str(outfile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_writefile(outfile,ma_writeobj_datastart,(ma_writeobj_dataptr - ma_writeobj_datastart));
}

void ma_writeexe_writeexe(uint8_t * outfile) {
    int64_t i;
    ma_writeexe_datastart = (ma_writeexe_dataptr = (byte *)(mlib_pcm_allocz(ma_writeexe_filesize)));
    ma_writeexe_writedosstub();
    ma_writeexe_writepesig();
    ma_writeexe_writefileheader();
    ma_writeexe_writeoptheader();
    L960 :;
    for (i=(int64_t)1;i<=ma_writeexe_nsections;i+=(int64_t)1) {
L961 :;
        ma_writeexe_writesectionheader(&ma_writeexe_sectiontable[(i)-1]);
L962 :;
    }L963 :;
    ;
    ma_writeexe_writepadding(ma_writeexe_sectiontable[((int64_t)1)-1].rawoffset);
    L964 :;
    for (i=(int64_t)1;i<=ma_writeexe_nsections;i+=(int64_t)1) {
L965 :;
        ma_writeexe_writesectiondata(&ma_writeexe_sectiontable[(i)-1]);
L966 :;
    }L967 :;
    ;
    if ((mm_decls_fverbose >= (int64_t)2)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Writing file:",NULL);
        msysnewc_m_print_str(outfile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if ((mlib_writefile(outfile,ma_writeexe_datastart,(ma_writeexe_dataptr - ma_writeexe_datastart)) == (int64_t)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Error writing exe file (possibly still running)",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((int64_t)1);
    };
}

void ma_writeexe_genexe(uint8_t * entrypoint) {
    ma_writeexe_setuplibfiles();
    ma_writeexe_userentrypoint = entrypoint;
    ma_writeexe_loadlibs();
    ma_writeexe_scanst();
    ma_writeexe_getoffsets();
    ma_writeexe_relocdata(&ma_writeexe_sectiontable[((int64_t)1)-1]);
    ma_writeexe_relocdata(&ma_writeexe_sectiontable[((int64_t)2)-1]);
}

static void ma_writeexe_loadlibs(void) {
    int64_t i;
    int64_t hinst;
    uint8_t filename[300];
    L968 :;
    for (i=(int64_t)1;i<=ma_decls_nsearchlibs;i+=(int64_t)1) {
L969 :;
        strcpy((int8_t *)(filename),(int8_t *)(ma_decls_searchlibs[(i)-1]));
        hinst = (int64_t)(oslinux_os_getdllinst(filename));
        if ((hinst == (int64_t)0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"File:",NULL);
            msysnewc_m_print_str(filename,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_axerror((uint8_t*)"Can't load search lib");
        };
        ma_writeexe_libinsttable[(i)-1] = hinst;
        ma_writeexe_libinstnames[(i)-1] = mlib_pcm_copyheapstring(filename);
L970 :;
    }L971 :;
    ;
}

struct mlib_strbuffer * ma_writeexe_writessdata(int64_t fexe) {
    mlib_gs_init(ma_lib_dest);
    ma_writeexe_showssdata(fexe);
    mlib_gs_line(ma_lib_dest);
    return ma_lib_dest;
}

void ma_writeexe_initsectiontable(void) {
    ma_writeexe_sectiontable[((int64_t)1)-1].name = (uint8_t*)".text";
    ma_writeexe_sectiontable[((int64_t)1)-1].segtype = (int64_t)1;
    ma_writeexe_sectiontable[((int64_t)1)-1].data = ma_decls_ss_code;
    ma_writeexe_sectiontable[((int64_t)1)-1].virtsize = ma_lib_bufferlength(ma_decls_ss_code);
    if ((ma_lib_bufferlength(ma_decls_ss_idata) == (int64_t)0)) {
        ma_lib_addqword(ma_decls_ss_idata,(int64_t)0);
    };
    ma_writeexe_sectiontable[((int64_t)2)-1].name = (uint8_t*)".data";
    ma_writeexe_sectiontable[((int64_t)2)-1].segtype = (int64_t)2;
    ma_writeexe_sectiontable[((int64_t)2)-1].data = ma_decls_ss_idata;
    ma_writeexe_sectiontable[((int64_t)2)-1].virtsize = ma_lib_bufferlength(ma_decls_ss_idata);
    ma_writeexe_sectiontable[((int64_t)2)-1].rawsize = ma_writeexe_roundtoblock(ma_writeexe_sectiontable[((int64_t)2)-1].virtsize,(int64_t)512);
    ma_writeexe_sectiontable[((int64_t)2)-1].nrelocs = ma_decls_ss_nidatarelocs;
    ma_writeexe_sectiontable[((int64_t)2)-1].relocs = ma_decls_ss_idatarelocs;
    if ((ma_decls_ss_zdatalen == (int64_t)0)) {
        ma_decls_ss_zdatalen = (int64_t)16;
    };
    ma_writeexe_sectiontable[((int64_t)3)-1].name = (uint8_t*)".bss";
    ma_writeexe_sectiontable[((int64_t)3)-1].segtype = (int64_t)3;
    ma_writeexe_sectiontable[((int64_t)3)-1].virtsize = ma_decls_ss_zdatalen;
    ma_writeexe_sectiontable[((int64_t)1)-1].rawsize = ma_writeexe_roundtoblock(ma_writeexe_sectiontable[((int64_t)1)-1].virtsize,(int64_t)512);
    ma_writeexe_sectiontable[((int64_t)1)-1].nrelocs = ma_decls_ss_ncoderelocs;
    ma_writeexe_sectiontable[((int64_t)1)-1].relocs = ma_decls_ss_coderelocs;
    ma_writeexe_sectiontable[((int64_t)4)-1].name = (uint8_t*)".idata";
    ma_writeexe_sectiontable[((int64_t)4)-1].segtype = (int64_t)5;
    ma_writeexe_sectiontable[((int64_t)4)-1].virtsize = (int64_t)0;
    ma_writeexe_sectiontable[((int64_t)4)-1].rawsize = (int64_t)0;
    ma_writeexe_nsections = (int64_t)4;
}

static void ma_writeexe_showssdata(int64_t fexe) {
    mlib_gs_strln(ma_lib_dest,(!!(fexe)?(uint8_t*)"EXE FORMAT":(uint8_t*)"AFTER GENSS"));
    ma_writeexe_showsections();
    mlib_gs_line(ma_lib_dest);
    ma_writeexe_showsectionrelocs2((uint8_t*)"Idata",ma_decls_ss_idatarelocs,ma_decls_ss_nidatarelocs);
    ma_writeexe_showsectionrelocs2((uint8_t*)"Code",ma_decls_ss_coderelocs,ma_decls_ss_ncoderelocs);
    mlib_gs_str(ma_lib_dest,(uint8_t*)"proc Section Zdata: ");
    mlib_gs_strint(ma_lib_dest,ma_decls_ss_zdatalen);
    mlib_gs_line(ma_lib_dest);
    ma_writeexe_showsectiondata(&ma_writeexe_sectiontable[((int64_t)2)-1]);
    ma_writeexe_showsectioncode(&ma_writeexe_sectiontable[((int64_t)1)-1]);
    if (!!(fexe)) {
        ma_writeexe_showsectiondata(&ma_writeexe_sectiontable[((int64_t)4)-1]);
    };
    ma_writeexe_showsymboltable2();
    ma_writeexe_showimporttable();
    mlib_gs_strln(ma_lib_dest,(uint8_t*)"END OF GENSS");
}

static void ma_writeexe_showsectiondata(struct ma_writeexe_sectionrec * d) {
    int64_t i;
    int64_t k;
    int64_t length;
    int64_t bb;
    uint8_t str[128];
    uint8_t str2[128];
    byte *  p;
    byte *  baseaddr;
    int64_t av_1;
    mlib_gs_str(ma_lib_dest,(uint8_t*)"proc Section ");
    mlib_gs_str(ma_lib_dest,(*d).name);
    mlib_gs_str(ma_lib_dest,(uint8_t*)" Size:");
    mlib_gs_strint(ma_lib_dest,(*d).virtsize);
    mlib_gs_line(ma_lib_dest);
    mlib_gs_line(ma_lib_dest);
    k = (int64_t)0;
    if (((*d).segtype != (int64_t)5)) {
        p = (byte *)(ma_lib_bufferelemptr((*d).data,(int64_t)0));
    } else {
        p = (*d).bytedata;
    };
    length = (*d).virtsize;
    str[((int64_t)1)-1] = (uint64_t)0u;
    baseaddr = (byte *)(((int64_t)4194304 + (*d).virtoffset));
    msysnewc_m_print_startstr(str2);
    msysnewc_m_print_ptr(baseaddr,(uint8_t*)"Z8H");
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)": ",NULL);
    msysnewc_m_print_end();
    ;
    mlib_gs_str(ma_lib_dest,str2);
    L972 :;
    for (i=(int64_t)1;i<=length;i+=(int64_t)1) {
L973 :;
        bb = (int64_t)((*p++));
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_i64(bb,(uint8_t*)"z2H");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(ma_lib_dest,str2);
        if ((((int64_t)32 <= bb) && (bb <= (int64_t)127))) {
            str2[((int64_t)1)-1] = (uint64_t)(bb);
            str2[((int64_t)2)-1] = (uint64_t)0u;
            strcat((int8_t *)(str),(int8_t *)(str2));
        } else {
            strcat((int8_t *)(str),(int8_t *)((uint8_t*)"."));
        };
        if (((++k == (int64_t)16) || (i == length))) {
            if ((k < (int64_t)16)) {
                av_1 = ((int64_t)16 - k);
                while (av_1-- > 0) {
L976 :;
                    mlib_gs_str(ma_lib_dest,(uint8_t*)"   ");
                    strcat((int8_t *)(str),(int8_t *)((uint8_t*)" "));
L977 :;
                }L978 :;
                ;
            };
            mlib_gs_str(ma_lib_dest,(uint8_t*)"\t[");
            mlib_gs_str(ma_lib_dest,str);
            mlib_gs_strln(ma_lib_dest,(uint8_t*)"]");
            k = (int64_t)0;
            str[((int64_t)1)-1] = (uint64_t)0u;
            baseaddr += (int64_t)16;
            msysnewc_m_print_startstr(str2);
            msysnewc_m_print_ptr(baseaddr,(uint8_t*)"z8h");
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)": ",NULL);
            msysnewc_m_print_end();
            ;
            mlib_gs_str(ma_lib_dest,str2);
        };
L974 :;
    }L975 :;
    ;
    if ((k == (int64_t)0)) {
        mlib_gs_line(ma_lib_dest);
    };
    mlib_gs_line(ma_lib_dest);
    if (!!(k)) {
        mlib_gs_line(ma_lib_dest);
    };
}

static void ma_writeexe_showsectioncode(struct ma_writeexe_sectionrec * p) {
    byte *  codeptr;
    byte *  codeend;
    byte *  codestart;
    int64_t length;
    int64_t offset;
    uint8_t *  s;
    uint8_t str[16];
    byte *  baseaddr;
    mlib_gs_strln(ma_lib_dest,(uint8_t*)"proc Section Code");
    length = (*p).virtsize;
    codestart = (codeptr = (byte *)(ma_lib_bufferelemptr((*p).data,(int64_t)0)));
    codeend = (codeptr + length);
    baseaddr = (byte *)(((int64_t)4194304 + (*p).virtoffset));
    L979 :;
    while ((codeptr < codeend)) {
        offset = (codeptr - codestart);
        s = (uint8_t *)(0);
        s = ma_disasm_decodeinstr(&codeptr,(baseaddr + offset));
        if ((s == 0)) {
            goto L981 ;
        };
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_i64(offset,(uint8_t*)"4");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(ma_lib_dest,str);
        mlib_gs_strln(ma_lib_dest,s);
L980 :;
    }L981 :;
    ;
    mlib_gs_line(ma_lib_dest);
}

static void ma_writeexe_showsectionrelocs2(uint8_t * caption,struct ma_decls_relocrec * relocs,int64_t nrelocs) {
    struct ma_decls_relocrec *  r;
    struct mm_decls_strec *  d;
    mlib_gs_str(ma_lib_dest,(uint8_t*)"proc Section Relocs: ");
    mlib_gs_str(ma_lib_dest,caption);
    mlib_gs_str(ma_lib_dest,(uint8_t*)" ");
    mlib_gs_strint(ma_lib_dest,nrelocs);
    mlib_gs_line(ma_lib_dest);
    r = relocs;
    L982 :;
    while (!!(r)) {
        mlib_gs_str(ma_lib_dest,(uint8_t*)"Reloc: ");
        mlib_gs_str(ma_lib_dest,ma_objdecls_relocnames[((*r).reloctype)]);
        mlib_gs_str(ma_lib_dest,(uint8_t*)" Offset: ");
        mlib_gs_strint(ma_lib_dest,(*r).offset);
        mlib_gs_str(ma_lib_dest,(uint8_t*)" ST Index: ");
        mlib_gs_strint(ma_lib_dest,(*r).stindex);
        mlib_gs_str(ma_lib_dest,(uint8_t*)" ");
        d = (*ma_decls_ss_symboltable)[((*r).stindex)-1];
        if (!!((*d).name)) {
            mlib_gs_str(ma_lib_dest,(*d).name);
        } else {
            mlib_gs_str(ma_lib_dest,(uint8_t*)"`L");
            mlib_gs_strint(ma_lib_dest,(int64_t)((*d).labelno));
        };
        mlib_gs_line(ma_lib_dest);
        r = (*r).nextreloc;
L983 :;
    }L984 :;
    ;
    mlib_gs_line(ma_lib_dest);
}

static void ma_writeexe_gs_value(uint8_t * caption,int64_t value) {
    uint8_t str[256];
    strcpy((int8_t *)(str),(int8_t *)(caption));
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)":"));
    mlib_ipadstr(str,(int64_t)20,(uint8_t*)" ");
    mlib_gs_str(ma_lib_dest,str);
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"0x# #");
    msysnewc_m_print_i64(value,(uint8_t*)"H");
    msysnewc_m_print_i64(value,NULL);
    msysnewc_m_print_end();
    ;
    mlib_gs_strln(ma_lib_dest,str);
}

static void ma_writeexe_showsymboltable2(void) {
    int64_t i;
    struct mm_decls_strec *  d;
    mlib_gs_strln(ma_lib_dest,(uint8_t*)"Proc Symbol Table");
    L985 :;
    for (i=(int64_t)1;i<=ma_decls_ss_nsymbols;i+=(int64_t)1) {
L986 :;
        mlib_gs_strint(ma_lib_dest,i);
        mlib_gs_str(ma_lib_dest,(uint8_t*)": ");
        d = (*ma_decls_ss_symboltable)[(i)-1];
        if (!!((*d).name)) {
            mlib_gs_strint(ma_lib_dest,(int64_t)((*d).offset));
            mlib_gs_str(ma_lib_dest,(uint8_t*)" ");
            mlib_gs_strln(ma_lib_dest,(*d).name);
        } else {
            mlib_gs_str(ma_lib_dest,(uint8_t*)"`L");
            mlib_gs_strint(ma_lib_dest,(int64_t)((*d).labelno));
            mlib_gs_line(ma_lib_dest);
        };
L987 :;
    }L988 :;
    ;
    mlib_gs_line(ma_lib_dest);
}

static void ma_writeexe_showimporttable(void) {
    uint8_t str[256];
    struct ma_writeexe_importrec p;
    int64_t i;
    mlib_gs_strln(ma_lib_dest,(uint8_t*)"Proc Dll List");
    L989 :;
    for (i=(int64_t)1;i<=ma_writeexe_ndlls;i+=(int64_t)1) {
L990 :;
        mlib_gs_strint(ma_lib_dest,i);
        mlib_gs_str(ma_lib_dest,(uint8_t*)": ");
        mlib_gs_str(ma_lib_dest,ma_writeexe_dlltable[(i)-1].name);
        mlib_gs_str(ma_lib_dest,(uint8_t*)" ");
        mlib_gs_strint(ma_lib_dest,ma_writeexe_dlltable[(i)-1].nprocs);
        mlib_gs_line(ma_lib_dest);
        ma_writeexe_gs_value((uint8_t*)"\t\tName Table Offset",ma_writeexe_dlltable[(i)-1].nametableoffset);
        ma_writeexe_gs_value((uint8_t*)"\t\tAddr Table Offset",ma_writeexe_dlltable[(i)-1].addrtableoffset);
        ma_writeexe_gs_value((uint8_t*)"\t\tDLL Name Offset  ",ma_writeexe_dlltable[(i)-1].dllnameoffset);
L991 :;
    }L992 :;
    ;
    mlib_gs_line(ma_lib_dest);
    mlib_gs_strln(ma_lib_dest,(uint8_t*)"Proc Import List");
    L993 :;
    for (i=(int64_t)1;i<=ma_writeexe_nimports;i+=(int64_t)1) {
L994 :;
        p = ma_writeexe_importtable[(i)-1];
        mlib_gs_strint(ma_lib_dest,i);
        mlib_gs_str(ma_lib_dest,(uint8_t*)": ");
        if (!!(p.libno)) {
            strcpy((int8_t *)(str),(int8_t *)(p.name));
            mlib_ipadstr(str,(int64_t)16,(uint8_t*)" ");
            mlib_gs_str(ma_lib_dest,str);
            mlib_gs_str(ma_lib_dest,(uint8_t*)" (");
            mlib_gs_str(ma_lib_dest,ma_writeexe_dlltable[(p.libno)-1].name);
            mlib_gs_strln(ma_lib_dest,(uint8_t*)")");
            ma_writeexe_gs_value((uint8_t*)"\tIAT Offset        ",p.iatoffset);
            ma_writeexe_gs_value((uint8_t*)"\tThunk Offset      ",p.thunkoffset);
            ma_writeexe_gs_value((uint8_t*)"\tHint/Name Offset  ",p.hintnameoffset);
        } else {
            strcpy((int8_t *)(str),(int8_t *)(p.name));
            mlib_ipadstr(str,(int64_t)20,(uint8_t*)" ");
            mlib_gs_str(ma_lib_dest,str);
            mlib_gs_strln(ma_lib_dest,(uint8_t*)" (---)");
        };
L995 :;
    }L996 :;
    ;
    mlib_gs_line(ma_lib_dest);
}

static int64_t ma_writeexe_roundtoblock(int64_t n,int64_t align) {
    if (((n & (align - (int64_t)1)) == (int64_t)0)) {
        return n;
    };
    return (n + (align - (n & (align - (int64_t)1))));
}

static void ma_writeexe_showsections(void) {
    struct ma_writeexe_sectionrec s;
    int64_t i;
    mlib_gs_strln(ma_lib_dest,(uint8_t*)"proc Section Headersxxx");
    mlib_gs_line(ma_lib_dest);
    L997 :;
    for (i=(int64_t)1;i<=ma_writeexe_nsections;i+=(int64_t)1) {
L998 :;
        s = ma_writeexe_sectiontable[(i)-1];
        mlib_gs_str(ma_lib_dest,(uint8_t*)"Section ");
        mlib_gs_strint(ma_lib_dest,i);
        mlib_gs_str(ma_lib_dest,(uint8_t*)": ");
        mlib_gs_str(ma_lib_dest,s.name);
        mlib_gs_str(ma_lib_dest,(uint8_t*)"  (");
        mlib_gs_str(ma_lib_dest,mm_mcldecls_segmentnames[(s.segtype)]);
        mlib_gs_strln(ma_lib_dest,(uint8_t*)")");
        ma_writeexe_gs_value((uint8_t*)"    Raw Offset",s.rawoffset);
        ma_writeexe_gs_value((uint8_t*)"    Raw Size",s.rawsize);
        ma_writeexe_gs_value((uint8_t*)"    Virtual Offset",s.virtoffset);
        ma_writeexe_gs_value((uint8_t*)"    Virtual Size",s.virtsize);
        ma_writeexe_gs_value((uint8_t*)"    Nrelocs",s.nrelocs);
        ma_writeexe_gs_value((uint8_t*)"    Data",(int64_t)(s.data));
        mlib_gs_line(ma_lib_dest);
L999 :;
    }L1000 :;
    ;
}

static uint8_t * ma_writeexe_extractlibname(uint8_t * name,int64_t * libno,int64_t moduleno) {
    uint8_t *  s;
    uint8_t *  name2;
    uint8_t str[256];
    int64_t i;
    int64_t n;
    name2 = (uint8_t *)(0);
    //reenter:
L1001 :;
;
    s = name;
    (*libno) = (int64_t)0;
    L1002 :;
    while (!!((uint64_t)((*s)))) {
        if (((uint64_t)((*s)) == '.')) {
            memcpy((void *)(str),(void *)(name),(uint64_t)((s - name)));
            str[(((s - name) + (int64_t)1))-1] = (uint64_t)0u;
            strcat((int8_t *)(str),(int8_t *)((uint8_t*)".dll"));
            L1005 :;
            for (i=(int64_t)1;i<=ma_writeexe_ndlls;i+=(int64_t)1) {
L1006 :;
                if (!!(mlib_eqstring(str,ma_writeexe_dlltable[(i)-1].name))) {
                    (*libno) = i;
                    ++ma_writeexe_dlltable[((*libno))-1].nprocs;
                    return (!!(name2)?name2:(s + (int64_t)1));
                };
L1007 :;
            }L1008 :;
            ;
            if ((ma_writeexe_ndlls >= (int64_t)50)) {
                mm_support_axerror((uint8_t*)"Too many libs");
            };
            (*libno) = ++ma_writeexe_ndlls;
            ma_writeexe_dlltable[((*libno))-1].name = mlib_pcm_copyheapstring(str);
            ma_writeexe_dlltable[((*libno))-1].nprocs = (int64_t)1;
            return (!!(name2)?name2:(s + (int64_t)1));
        };
        ++s;
L1003 :;
    }L1004 :;
    ;
    L1009 :;
    for (i=(int64_t)1;i<=ma_decls_nsearchlibs;i+=(int64_t)1) {
L1010 :;
        if (!!(oslinux_os_getdllprocaddr(ma_writeexe_libinsttable[(i)-1],name))) {
            n = i;
            goto L1012 ;
        };
L1011 :;
    }
    {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(name,NULL);
        msysnewc_m_print_str((uint8_t*)"in module",NULL);
        msysnewc_m_print_str(mm_decls_moduletable[(moduleno)].name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_axerror((uint8_t*)"Can't find external function");
    }L1012 :;
    ;
    if (!!(((*libno) = ma_writeexe_libnotable[(n)-1]))) {
        ++ma_writeexe_dlltable[((*libno))-1].nprocs;
        return name;
    };
    strcpy((int8_t *)(str),(int8_t *)(ma_decls_searchlibs[(n)-1]));
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)".dll"));
    if ((ma_writeexe_ndlls >= (int64_t)50)) {
        mm_support_axerror((uint8_t*)"2:Too many libs");
    };
    (*libno) = ++ma_writeexe_ndlls;
    ma_writeexe_dlltable[((*libno))-1].name = mlib_pcm_copyheapstring(str);
    ma_writeexe_dlltable[((*libno))-1].nprocs = (int64_t)1;
    ma_writeexe_libnotable[(n)-1] = (*libno);
    return name;
}

static void ma_writeexe_scanst(void) {
    int64_t i;
    int64_t libno;
    struct mm_decls_strec *  d;
    uint8_t *  name;
    L1013 :;
    for (i=(int64_t)1;i<=ma_decls_ss_nsymbols;i+=(int64_t)1) {
L1014 :;
        d = (*ma_decls_ss_symboltable)[(i)-1];
        if (!!(ma_writeexe_imported(d))) {
            if ((ma_writeexe_nimports >= (int64_t)3000)) {
                mm_support_axerror((uint8_t*)"genexe: Too many imports");
            };
            ++ma_writeexe_nimports;
            name = ma_writeexe_extractlibname((!!((*d).truename)?(*d).truename:(*d).name),&libno,(int64_t)((*d).moduleno));
            ma_writeexe_importtable[(ma_writeexe_nimports)-1].libno = libno;
            ma_writeexe_importtable[(ma_writeexe_nimports)-1].name = name;
            ma_writeexe_importtable[(ma_writeexe_nimports)-1].def = d;
            (*d).importindex = ma_writeexe_nimports;
        } else if (!!(ma_writeexe_exported(d))) {
            if (!!(ma_writeexe_userentrypoint)) {
                if (!!(mlib_eqstring((*d).name,ma_writeexe_userentrypoint))) {
                    ma_writeexe_stentrypoint = d;
                };
            } else {
                if (!!(mlib_eqstring((*d).name,(uint8_t*)"main"))) {
                    ma_writeexe_stentrypoint = d;
                } else if (!!(mlib_eqstring((*d).name,(uint8_t*)"start"))) {
                    ma_writeexe_stentrypoint2 = d;
                };
            };
        };
L1015 :;
    }L1016 :;
    ;
}

static void ma_writeexe_relocdata(struct ma_writeexe_sectionrec * s) {
    struct ma_writeexe_sectionrec *  u;
    struct ma_decls_relocrec *  r;
    byte *  p;
    uint32_t *  p32;
    struct mm_decls_strec *  d;
    int64_t index;
    int64_t thunkoffset;
    int64_t av_1;
    int64_t i;
    p = (byte *)(ma_lib_bufferelemptr((*s).data,(int64_t)0));
    r = (*s).relocs;
    L1017 :;
    while (!!(r)) {
        d = (*ma_decls_ss_symboltable)[((*r).stindex)-1];
        index = (int64_t)((*d).importindex);
        thunkoffset = ma_writeexe_importtable[(index)-1].thunkoffset;
        if (((*r).reloctype==(int64_t)4)) {
            if (!(!!(ma_writeexe_imported(d)))) {
                mm_support_axerror((uint8_t*)"rel32/not imported");
            };
            (*(uint32_t *)((p + (*r).offset))) = (uint64_t)(((thunkoffset - (*r).offset) - (int64_t)4));
        }else if (((*r).reloctype==(int64_t)2) || ((*r).reloctype==(int64_t)1)) {
            if (!!(ma_writeexe_imported(d))) {
                (*(uint32_t *)((p + (*r).offset))) = (uint64_t)((((int64_t)4194304 + thunkoffset) + ma_writeexe_sectiontable[((int64_t)1)-1].virtoffset));
            } else {
                u = (struct ma_writeexe_sectionrec *)(0);
                if (((int64_t)((*d).segment)==(int64_t)3)) {
                    u = &ma_writeexe_sectiontable[((int64_t)3)-1];
                }else if (((int64_t)((*d).segment)==(int64_t)2)) {
                    u = &ma_writeexe_sectiontable[((int64_t)2)-1];
                }else if (((int64_t)((*d).segment)==(int64_t)1)) {
                    u = &ma_writeexe_sectiontable[((int64_t)1)-1];
                } else {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str((*d).name,NULL);
                    msysnewc_m_print_u64((*d).segment,NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    if (((int64_t)((uint64_t)((*d).namelen)) == (int64_t)0)) {
                        L1020 :;
                        for (i=(int64_t)1;i<=(int64_t)181;i+=(int64_t)1) {
L1021 :;
                            if ((mm_decls_sysfnlabels[(i)-1] == (int64_t)((*d).labelno))) {
                                msysnewc_m_print_startcon();
                                msysnewc_m_print_setfmt((uint8_t*)"(Sysfn: #)");
                                msysnewc_m_print_str(mm_tables_sysfnnames[(i)-1],NULL);
                                msysnewc_m_print_newline();
                                msysnewc_m_print_end();
                                ;
                                goto L1023 ;
                            };
L1022 :;
                        }L1023 :;
                        ;
                    };
                    mm_support_axerror((uint8_t*)"RELOCDATA/SEG?");
                };
                p32 = (uint32_t *)((p + (*r).offset));
                (*p32) = (uint64_t)((((int64_t)((uint64_t)((*p32))) + (*u).virtoffset) + (int64_t)4194304));
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ma_objdecls_relocnames[((*r).reloctype)],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_axerror((uint8_t*)"Can't do this rel type");
        };
        r = (*r).nextreloc;
L1018 :;
    }L1019 :;
    ;
}

static void ma_writeexe_writerecordx(void * r,int64_t length) {
    memcpy((void *)(ma_writeexe_dataptr),r,(uint64_t)(length));
    ma_writeexe_dataptr += length;
}

static void ma_writeexe_writedosstub(void) {
    static byte stubdata[128] = {
    (uint8_t)77u,
    (uint8_t)90u,
    (uint8_t)144u,
    (uint8_t)0u,
    (uint8_t)3u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)4u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)255u,
    (uint8_t)255u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)184u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)64u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)128u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)14u,
    (uint8_t)31u,
    (uint8_t)186u,
    (uint8_t)14u,
    (uint8_t)0u,
    (uint8_t)180u,
    (uint8_t)9u,
    (uint8_t)205u,
    (uint8_t)33u,
    (uint8_t)184u,
    (uint8_t)1u,
    (uint8_t)76u,
    (uint8_t)205u,
    (uint8_t)33u,
    (uint8_t)84u,
    (uint8_t)104u,
    (uint8_t)105u,
    (uint8_t)115u,
    (uint8_t)32u,
    (uint8_t)112u,
    (uint8_t)114u,
    (uint8_t)111u,
    (uint8_t)103u,
    (uint8_t)114u,
    (uint8_t)97u,
    (uint8_t)109u,
    (uint8_t)32u,
    (uint8_t)99u,
    (uint8_t)97u,
    (uint8_t)110u,
    (uint8_t)110u,
    (uint8_t)111u,
    (uint8_t)116u,
    (uint8_t)32u,
    (uint8_t)98u,
    (uint8_t)101u,
    (uint8_t)32u,
    (uint8_t)114u,
    (uint8_t)117u,
    (uint8_t)110u,
    (uint8_t)32u,
    (uint8_t)105u,
    (uint8_t)110u,
    (uint8_t)32u,
    (uint8_t)68u,
    (uint8_t)79u,
    (uint8_t)83u,
    (uint8_t)32u,
    (uint8_t)109u,
    (uint8_t)111u,
    (uint8_t)100u,
    (uint8_t)101u,
    (uint8_t)46u,
    (uint8_t)13u,
    (uint8_t)13u,
    (uint8_t)10u,
    (uint8_t)36u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u,
    (uint8_t)0u
};
    ma_writeexe_writerecordx((void *)(&stubdata),(int64_t)128);
}

static void ma_writeexe_writepesig(void) {
    (*ma_writeexe_dataptr++) = (uint64_t)80u;
    (*ma_writeexe_dataptr++) = (uint64_t)69u;
    (*ma_writeexe_dataptr++) = (uint64_t)((int64_t)0);
    (*ma_writeexe_dataptr++) = (uint64_t)((int64_t)0);
}

static void ma_writeexe_writepadding(int64_t offset) {
    ma_writeexe_dataptr = (ma_writeexe_datastart + offset);
}

static void ma_writeexe_writefileheader(void) {
    struct ma_objdecls_imagefileheader header;
    memset((void *)(&header),(int64_t)0,(uint64_t)((int64_t)20));
    header.machine = (uint64_t)((int64_t)34404);
    header.nsections = (uint64_t)(ma_writeexe_nsections);
    header.optheadersize = (uint64_t)((int64_t)240);
    header.characteristics = (uint64_t)((int64_t)559);
    ma_writeexe_writerecordx((void *)(&header),(int64_t)20);
}

static void ma_writeexe_writeoptheader(void) {
    struct ma_objdecls_optionalheader header;
    memset((void *)(&header),(int64_t)0,(uint64_t)((int64_t)240));
    header.magic = (uint64_t)((int64_t)523);
    header.majorlv = (uint64_t)((int64_t)1);
    header.minorlv = (uint64_t)((int64_t)0);
    header.codesize = (uint64_t)(ma_writeexe_sectiontable[((int64_t)1)-1].rawsize);
    header.idatasize = (uint64_t)((ma_writeexe_sectiontable[((int64_t)2)-1].rawsize + ma_writeexe_sectiontable[((int64_t)4)-1].rawsize));
    header.zdatasize = (uint64_t)(ma_writeexe_roundtoblock(ma_writeexe_sectiontable[((int64_t)3)-1].virtsize,(int64_t)512));
    if ((ma_writeexe_stentrypoint == 0)) {
        ma_writeexe_stentrypoint = ma_writeexe_stentrypoint2;
        if ((ma_writeexe_stentrypoint == 0)) {
            ma_writeexe_stentrypoint = ma_writeexe_stentrypoint3;
            if (!!(ma_writeexe_stentrypoint)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"Using tertiary 'WinMain' entry point",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        };
    };
    if ((ma_writeexe_stentrypoint == 0)) {
        if (!!(ma_writeexe_userentrypoint)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ma_writeexe_userentrypoint,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_axerror((uint8_t*)"User entry point not found");
        } else {
            mm_support_axerror((uint8_t*)"Entry point not found: main or start");
        };
    };
    header.entrypoint = (uint64_t)((ma_writeexe_sectiontable[((int64_t)1)-1].virtoffset + (int64_t)((*ma_writeexe_stentrypoint).offset)));
    header.codebase = (uint64_t)((int64_t)4096);
    header.imagebase = (uint64_t)((int64_t)4194304);
    header.sectionalignment = (uint64_t)((int64_t)4096);
    header.filealignment = (uint64_t)((int64_t)512);
    header.majorosv = (uint64_t)((int64_t)4);
    header.minorosv = (uint64_t)((int64_t)0);
    header.majorssv = (uint64_t)((int64_t)5);
    header.minorssv = (uint64_t)((int64_t)2);
    header.imagesize = (uint64_t)(ma_writeexe_imagesize);
    header.headerssize = (uint64_t)(ma_writeexe_sectiontable[((int64_t)1)-1].rawoffset);
    header.subsystem = (uint64_t)((int64_t)3);
    header.stackreserve = (uint64_t)((int64_t)4194304);
    header.stackcommit = (uint64_t)((int64_t)2097152);
    header.heapreserve = (uint64_t)((int64_t)1048576);
    header.heapcommit = (uint64_t)((int64_t)4096);
    header.rvadims = (uint64_t)((int64_t)16);
    header.importtable.virtualaddr = (uint64_t)(ma_writeexe_sectiontable[((int64_t)4)-1].virtoffset);
    header.importtable.size = (uint64_t)((int64_t)128);
    header.iat.virtualaddr = (uint64_t)(ma_writeexe_fileiatoffset);
    header.iat.size = (uint64_t)(ma_writeexe_fileiatsize);
    ma_writeexe_writerecordx((void *)(&header),(int64_t)240);
}

static void ma_writeexe_writesectionheader(struct ma_writeexe_sectionrec * s) {
    struct ma_objdecls_imagesectionheader sheader;
    int64_t aa;
    memset((void *)(&sheader),(int64_t)0,(uint64_t)((int64_t)40));
    strcpy((int8_t *)(&sheader.name[((int64_t)1)-1]),(int8_t *)((*s).name));
    sheader.virtual_size = (uint64_t)((*s).virtsize);
    sheader.virtual_address = (uint64_t)((*s).virtoffset);
    sheader.rawdata_offset = (uint64_t)((*s).rawoffset);
    sheader.rawdata_size = (uint64_t)((*s).rawsize);
    if (((*s).segtype==(int64_t)3)) {
        aa = (int64_t)3226468480;
        sheader.characteristics = (uint64_t)(aa);
    }else if (((*s).segtype==(int64_t)2)) {
        aa = (int64_t)3226468416;
        sheader.characteristics = (uint64_t)(aa);
    }else if (((*s).segtype==(int64_t)1)) {
        aa = (int64_t)1615855648;
        sheader.characteristics = (uint64_t)(aa);
    }else if (((*s).segtype==(int64_t)5)) {
        aa = (int64_t)3224371264;
        sheader.characteristics = (uint64_t)(aa);
    };
    ma_writeexe_writerecordx((void *)(&sheader),(int64_t)40);
}

static void ma_writeexe_writesectiondata(struct ma_writeexe_sectionrec * s) {
    if (((*s).segtype==(int64_t)5)) {
        ma_writeexe_writerecordx((void *)((*s).bytedata),(*s).virtsize);
        if (((*s).rawsize > (*s).virtsize)) {
            ma_writeexe_dataptr += ((*s).rawsize - (*s).virtsize);
        };
    }else if (((*s).segtype==(int64_t)3)) {
    } else {
        ma_writeexe_writerecordx(ma_lib_bufferelemptr((*s).data,(int64_t)0),(*s).rawsize);
    };
}

static void ma_writeexe_getoffsets(void) {
    int64_t fileoffset;
    int64_t imageoffset;
    int64_t i;
    int64_t diroffset;
    int64_t impdirno;
    int64_t hinttableoffset;
    int64_t j;
    int64_t codesize;
    int64_t length;
    int64_t thunkoffset;
    int64_t offset;
    int64_t dirstartoffset;
    byte *  pcode;
    byte *  pimpdir;
    struct ma_objdecls_importdirrec *  pdir;
    int64_t *  paddr;
    int64_t *  pname;
    int64_t iatoffset;
    byte *  phint;
    uint32_t *  pextra;
    int64_t xxx;
    int64_t av_1;
    byte *  thunkptr;
    byte *  codebase;
    int64_t thunkaddr;
    fileoffset = (int64_t)392;
    fileoffset += ((int64_t)40 * ma_writeexe_nsections);
    fileoffset = ma_writeexe_roundtoblock(fileoffset,(int64_t)512);
    imageoffset = (int64_t)4096;
    codesize = ma_writeexe_sectiontable[((int64_t)1)-1].virtsize;
    pcode = (byte *)(ma_lib_bufferelemptr(ma_decls_ss_code,codesize));
    L1024 :;
    while (!!((codesize & (int64_t)7))) {
        (*pcode++) = (uint64_t)((int64_t)144);
        ++codesize;
L1025 :;
    }L1026 :;
    ;
    thunkoffset = codesize;
    codesize += (ma_writeexe_nimports * (int64_t)8);
    ma_writeexe_sectiontable[((int64_t)1)-1].virtsize = codesize;
    ma_writeexe_sectiontable[((int64_t)1)-1].rawsize = ma_writeexe_roundtoblock(codesize,(int64_t)512);
    ma_lib_buffercheck(ma_decls_ss_code,((codesize - thunkoffset) + (int64_t)16));
    L1027 :;
    for (i=(int64_t)1;i<=ma_writeexe_nsections;i+=(int64_t)1) {
L1028 :;
        if ((ma_writeexe_sectiontable[(i)-1].segtype != (int64_t)3)) {
            ma_writeexe_sectiontable[(i)-1].rawoffset = fileoffset;
        };
        if ((ma_writeexe_sectiontable[(i)-1].segtype != (int64_t)3)) {
            fileoffset = ma_writeexe_roundtoblock((fileoffset + ma_writeexe_sectiontable[(i)-1].virtsize),(int64_t)512);
        };
        ma_writeexe_sectiontable[(i)-1].virtoffset = imageoffset;
        if ((ma_writeexe_sectiontable[(i)-1].segtype == (int64_t)5)) {
            diroffset = imageoffset;
            impdirno = i;
        };
        imageoffset = ma_writeexe_roundtoblock((imageoffset + ma_writeexe_sectiontable[(i)-1].virtsize),(int64_t)4096);
L1029 :;
    }L1030 :;
    ;
    diroffset += ((ma_writeexe_ndlls + (int64_t)1) * (int64_t)20);
    L1031 :;
    for (i=(int64_t)1;i<=ma_writeexe_ndlls;i+=(int64_t)1) {
L1032 :;
        ma_writeexe_dlltable[(i)-1].nametableoffset = diroffset;
        diroffset += ((ma_writeexe_dlltable[(i)-1].nprocs + (int64_t)1) * (int64_t)8);
L1033 :;
    }L1034 :;
    ;
    ma_writeexe_fileiatoffset = diroffset;
    L1035 :;
    for (i=(int64_t)1;i<=ma_writeexe_ndlls;i+=(int64_t)1) {
L1036 :;
        ma_writeexe_dlltable[(i)-1].addrtableoffset = diroffset;
        diroffset += ((ma_writeexe_dlltable[(i)-1].nprocs + (int64_t)1) * (int64_t)8);
L1037 :;
    }L1038 :;
    ;
    ma_writeexe_fileiatsize = (diroffset - ma_writeexe_fileiatoffset);
    hinttableoffset = diroffset;
    L1039 :;
    for (i=(int64_t)1;i<=ma_writeexe_nimports;i+=(int64_t)1) {
L1040 :;
        length = ((int64_t)(strlen((int8_t *)(ma_writeexe_importtable[(i)-1].name))) + (int64_t)3);
        if (!!((length & (int64_t)1))) {
            ++length;
        };
        ma_writeexe_importtable[(i)-1].hintnameoffset = diroffset;
        diroffset += length;
L1041 :;
    }L1042 :;
    ;
    diroffset = ma_writeexe_roundtoblock(diroffset,(int64_t)4);
    L1043 :;
    for (i=(int64_t)1;i<=ma_writeexe_ndlls;i+=(int64_t)1) {
L1044 :;
        length = ((int64_t)(strlen((int8_t *)(ma_writeexe_dlltable[(i)-1].name))) + (int64_t)1);
        if (!!((length & (int64_t)1))) {
            ++length;
        };
        ma_writeexe_dlltable[(i)-1].dllextraoffset = diroffset;
        diroffset += (ma_writeexe_dlltable[(i)-1].nprocs * (int64_t)4);
        ma_writeexe_dlltable[(i)-1].dllnameoffset = diroffset;
        diroffset += length;
L1045 :;
    }L1046 :;
    ;
    dirstartoffset = ma_writeexe_sectiontable[(impdirno)-1].virtoffset;
    offset = (diroffset - dirstartoffset);
    ma_writeexe_sectiontable[(impdirno)-1].virtsize = offset;
    ma_writeexe_sectiontable[(impdirno)-1].rawsize = ma_writeexe_roundtoblock(offset,(int64_t)512);
    ma_writeexe_filesize = ma_writeexe_roundtoblock((fileoffset + offset),(int64_t)512);
    ma_writeexe_imagesize = ma_writeexe_roundtoblock((imageoffset + (diroffset - dirstartoffset)),(int64_t)4096);
    pimpdir = (ma_writeexe_sectiontable[(impdirno)-1].bytedata = (byte *)(mlib_pcm_allocz(offset)));
    pdir = (struct ma_objdecls_importdirrec *)(pimpdir);
    L1047 :;
    for (i=(int64_t)1;i<=ma_writeexe_ndlls;i+=(int64_t)1) {
L1048 :;
        (*pdir).implookuprva = (uint64_t)(ma_writeexe_dlltable[(i)-1].nametableoffset);
        (*pdir).impaddressrva = (uint64_t)(ma_writeexe_dlltable[(i)-1].addrtableoffset);
        (*pdir).namerva = (uint64_t)(ma_writeexe_dlltable[(i)-1].dllnameoffset);
        ++pdir;
        iatoffset = ma_writeexe_dlltable[(i)-1].addrtableoffset;
        paddr = (int64_t *)(((pimpdir + iatoffset) - dirstartoffset));
        pname = (int64_t *)(((pimpdir + ma_writeexe_dlltable[(i)-1].nametableoffset) - dirstartoffset));
        L1051 :;
        for (j=(int64_t)1;j<=ma_writeexe_nimports;j+=(int64_t)1) {
L1052 :;
            if ((ma_writeexe_importtable[(j)-1].libno == i)) {
                (*pname) = ((*paddr) = ma_writeexe_importtable[(j)-1].hintnameoffset);
                ma_writeexe_importtable[(j)-1].iatoffset = iatoffset;
                iatoffset += (int64_t)8;
                ++pname;
                ++paddr;
            };
L1053 :;
        }L1054 :;
        ;
L1049 :;
    }L1050 :;
    ;
    L1055 :;
    for (i=(int64_t)1;i<=ma_writeexe_nimports;i+=(int64_t)1) {
L1056 :;
        phint = ((pimpdir + ma_writeexe_importtable[(i)-1].hintnameoffset) - dirstartoffset);
        phint += (int64_t)2;
        strcpy((int8_t *)(phint),(int8_t *)(ma_writeexe_importtable[(i)-1].name));
L1057 :;
    }L1058 :;
    ;
    xxx = dirstartoffset;
    L1059 :;
    for (i=(int64_t)1;i<=ma_writeexe_ndlls;i+=(int64_t)1) {
L1060 :;
        pextra = (uint32_t *)(((pimpdir + ma_writeexe_dlltable[(i)-1].dllextraoffset) - dirstartoffset));
        L1063 :;
        for (j=(int64_t)1;j<=ma_writeexe_dlltable[(i)-1].nprocs;j+=(int64_t)1) {
L1064 :;
            (*pextra) = (uint64_t)(xxx);
            ++pextra;
L1065 :;
        }L1066 :;
        ;
        xxx += (int64_t)20;
        phint = ((pimpdir + ma_writeexe_dlltable[(i)-1].dllnameoffset) - dirstartoffset);
        strcpy((int8_t *)(phint),(int8_t *)(ma_writeexe_dlltable[(i)-1].name));
L1061 :;
    }L1062 :;
    ;
    thunkptr = (byte *)(ma_lib_bufferelemptr(ma_decls_ss_code,thunkoffset));
    codebase = (byte *)(ma_lib_bufferelemptr(ma_decls_ss_code,(int64_t)0));
    L1067 :;
    for (i=(int64_t)1;i<=ma_writeexe_nimports;i+=(int64_t)1) {
L1068 :;
        ma_writeexe_importtable[(i)-1].thunkoffset = (thunkptr - codebase);
        (*thunkptr++) = (uint64_t)((int64_t)72);
        (*thunkptr++) = (uint64_t)((int64_t)255);
        (*thunkptr++) = (uint64_t)((int64_t)36);
        (*thunkptr++) = (uint64_t)((int64_t)37);
        thunkaddr = ((int64_t)4194304 + ma_writeexe_importtable[(i)-1].iatoffset);
        (*(int32_t *)(thunkptr)) = thunkaddr;
        thunkptr += (int64_t)4;
L1069 :;
    }L1070 :;
    ;
}

static int64_t ma_writeexe_imported(struct mm_decls_strec * d) {
    if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)6)) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

static int64_t ma_writeexe_exported(struct mm_decls_strec * d) {
    if ((((int64_t)((uint64_t)((*d).nameid)) != (int64_t)6) && !!((uint64_t)((*d).isglobal)))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

static void ma_writeexe_addsearchlib(uint8_t * name) {
    int64_t i;
    L1071 :;
    for (i=(int64_t)1;i<=ma_decls_nsearchlibs;i+=(int64_t)1) {
L1072 :;
        if (!!(mlib_eqstring(ma_decls_searchlibs[(i)-1],name))) {
            return;
        };
L1073 :;
    }L1074 :;
    ;
    if ((ma_decls_nsearchlibs >= (int64_t)30)) {
        mm_support_axerror((uint8_t*)"Too many LIB files");
    };
    ma_decls_searchlibs[(++ma_decls_nsearchlibs)-1] = mlib_pcm_copyheapstring(mlib_changeext(name,(uint8_t*)""));
}

static void ma_writeexe_setuplibfiles(void) {
    int64_t i;
    ma_decls_nsearchlibs = (int64_t)0;
    ma_decls_searchlibs[((int64_t)1)-1] = (uint8_t*)"msvcrt";
    ma_decls_searchlibs[((int64_t)2)-1] = (uint8_t*)"gdi32";
    ma_decls_searchlibs[((int64_t)3)-1] = (uint8_t*)"user32";
    ma_decls_searchlibs[((int64_t)4)-1] = (uint8_t*)"kernel32";
    ma_decls_nsearchlibs = (int64_t)4;
    L1075 :;
    for (i=(int64_t)1;i<=mm_decls_nlibfiles;i+=(int64_t)1) {
L1076 :;
        ma_writeexe_addsearchlib(mm_decls_libfiles[(i)]);
L1077 :;
    }L1078 :;
    ;
    L1079 :;
    for (i=(int64_t)1;i<=mm_decls_ncclibs;i+=(int64_t)1) {
L1080 :;
        ma_writeexe_addsearchlib(mm_decls_cclibtable[(i)-1]);
L1081 :;
    }L1082 :;
    ;
    L1083 :;
    for (i=(int64_t)1;i<=mm_decls_ndllnametable;i+=(int64_t)1) {
L1084 :;
        if (((uint64_t)((*mm_decls_dllnametable[(i)-1])) != '$')) {
            ma_writeexe_addsearchlib(mm_decls_dllnametable[(i)-1]);
        };
L1085 :;
    }L1086 :;
    ;
}

uint8_t * ma_disasm_decodeinstr(byte * * cptr,byte * baseaddr) {
    int64_t n;
    int64_t w;
    int64_t opc;
    int64_t reg;
    int64_t op;
    byte *  pstart;
    static uint8_t str[256];
    uint8_t str2[128];
    int64_t av_1;
    int64_t av_2;
    ma_disasm_deststr[((int64_t)1)-1] = (uint64_t)0u;
    pstart = (ma_disasm_codeptr = (*cptr));
    ma_disasm_rex = (int64_t)0;
    ma_disasm_opsize = (int64_t)1;
    ma_disasm_f2override = (ma_disasm_f3override = (ma_disasm_sizeoverride = (ma_disasm_addroverride = (int64_t)0)));
    ma_disasm_basereg = (ma_disasm_indexreg = (ma_disasm_offset = (int64_t)0));
    //retry:
L1087 :;
;
    switch ((opc = (int64_t)((*ma_disasm_codeptr++)))) {
    case 0:;
    case 1:;
    case 8:;
    case 9:;
    case 16:;
    case 17:;
    case 24:;
    case 25:;
    case 32:;
    case 33:;
    case 40:;
    case 41:;
    case 48:;
    case 49:;
    case 56:;
    case 57:;
    {
        op = (opc >> (int64_t)3);
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_getsil(&ma_disasm_rmreg);
        ma_disasm_genstr(ma_disasm_opnames[(op)]);
        ma_disasm_printaddrmode((int64_t)0);
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
    }break;
    case 2:;
    case 3:;
    case 10:;
    case 11:;
    case 18:;
    case 19:;
    case 26:;
    case 27:;
    case 34:;
    case 35:;
    case 42:;
    case 43:;
    case 50:;
    case 51:;
    case 58:;
    case 59:;
    {
        op = (opc >> (int64_t)3);
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_genstr(ma_disasm_opnames[(op)]);
        ma_disasm_genstr((uint8_t*)" ");
        ma_disasm_getsil(&ma_disasm_rmreg);
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 4:;
    case 5:;
    case 12:;
    case 13:;
    case 20:;
    case 21:;
    case 28:;
    case 29:;
    case 36:;
    case 37:;
    case 44:;
    case 45:;
    case 52:;
    case 53:;
    case 60:;
    case 61:;
    {
        ma_disasm_genstr(ma_disasm_opnames[((opc >> (int64_t)3))]);
        ma_disasm_genstr((uint8_t*)" ");
        if (!!((opc & (int64_t)1))) {
            ma_disasm_opsize = (int64_t)4;
            if (!!(ma_disasm_sizeoverride)) {
                ma_disasm_opsize = (int64_t)2;
            };
            if (!!((ma_disasm_rex & (int64_t)8))) {
                ma_disasm_opsize = (int64_t)8;
            };
        };
        ma_disasm_genstr(ma_disasm_strreg((int64_t)1,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genintd(ma_disasm_readimm());
    }break;
    case 15:;
    {
        ma_disasm_decodetwobyteinstr();
    }break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    {
        ma_disasm_rex = opc;
        goto L1087 ;
;
    }break;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    {
        reg = ma_disasm_getreg((opc & (int64_t)7),(ma_disasm_rex & (int64_t)1));
        ma_disasm_genstr((uint8_t*)"push ");
        ma_disasm_genstr(ma_disasm_strreg(reg,(int64_t)8));
    }break;
    case 88:;
    case 89:;
    case 90:;
    case 91:;
    case 92:;
    case 93:;
    case 94:;
    case 95:;
    {
        reg = ma_disasm_getreg((opc & (int64_t)7),(ma_disasm_rex & (int64_t)1));
        ma_disasm_genstr((uint8_t*)"pop ");
        ma_disasm_genstr(ma_disasm_strreg(reg,(int64_t)8));
    }break;
    case 99:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((uint8_t*)"movsxd ");
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = (int64_t)4;
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 102:;
    {
        ma_disasm_sizeoverride = (int64_t)1;
        goto L1087 ;
;
    }break;
    case 103:;
    {
        ma_disasm_addroverride = (int64_t)1;
        goto L1087 ;
;
    }break;
    case 104:;
    {
        ma_disasm_genstr((uint8_t*)"push ");
        ma_disasm_genintd(ma_disasm_readint32());
    }break;
    case 106:;
    {
        ma_disasm_genstr((uint8_t*)"push ");
        ma_disasm_genintd(ma_disasm_readsbyte());
    }break;
    case 105:;
    case 107:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        if ((ma_disasm_basereg != ma_disasm_rmreg)) {
            ma_disasm_genstr((uint8_t*)"imul3");
            ma_disasm_genstr((uint8_t*)" ");
            ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
            ma_disasm_genstr((uint8_t*)", ");
        } else {
            ma_disasm_genstr((uint8_t*)"imul2");
        };
        ma_disasm_printaddrmode((int64_t)0);
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = (!!((opc & (int64_t)2))?(int64_t)1:ma_disasm_opsize);
        ma_disasm_genintd(ma_disasm_readimm());
    }break;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    case 125:;
    case 126:;
    case 127:;
    {
        ma_disasm_genstr((uint8_t*)"j");
        ma_disasm_genstr(ma_disasm_condnames[((opc & (int64_t)15))]);
        ma_disasm_genstr((uint8_t*)" ");
        ma_disasm_genintd(ma_disasm_readsbyte());
    }break;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    {
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_genstr(ma_disasm_opnames[(ma_disasm_rmopc)]);
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_printaddrmode((int64_t)0);
        ma_disasm_genstr((uint8_t*)", ");
        if ((opc != (int64_t)131)) {
            ma_disasm_genintd(ma_disasm_readimm());
        } else {
            ma_disasm_genintd(ma_disasm_readsbyte());
        };
    }break;
    case 132:;
    case 133:;
    {
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_getsil(&ma_disasm_rmreg);
        ma_disasm_genstr((uint8_t*)"test ");
        ma_disasm_printaddrmode((int64_t)0);
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
    }break;
    case 134:;
    case 135:;
    {
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_genstr((uint8_t*)"exch2 ");
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_getsil(&ma_disasm_rmreg);
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)",");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 136:;
    case 137:;
    {
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_genstr((uint8_t*)"mov");
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_getsil(&ma_disasm_rmreg);
        ma_disasm_printaddrmode((int64_t)0);
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
    }break;
    case 138:;
    case 139:;
    {
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_genstr((uint8_t*)"mov ");
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_getsil(&ma_disasm_rmreg);
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 141:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((uint8_t*)"lea ");
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 143:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_opsize = (int64_t)1;
        ma_disasm_genstr((uint8_t*)"pop");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 144:;
    {
        if (!!(ma_disasm_rex)) {
            goto L1088 ;
;
        };
        ma_disasm_genstr((uint8_t*)"nop");
    }break;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
    {
        //doexch:
L1088 :;
;
        reg = ((opc & (int64_t)7) + (int64_t)1);
        if (!!((ma_disasm_rex & (int64_t)1))) {
            reg += (int64_t)8;
        };
        ma_disasm_opsize = (!!(ma_disasm_sizeoverride)?(int64_t)2:(int64_t)4);
        if (!!((ma_disasm_rex & (int64_t)8))) {
            ma_disasm_opsize = (int64_t)8;
        };
        ma_disasm_genstr((uint8_t*)"xchg ");
        ma_disasm_genstr(ma_disasm_strreg((int64_t)1,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genstr(ma_disasm_strreg(reg,ma_disasm_opsize));
    }break;
    case 152:;
    {
        if (!!(ma_disasm_sizeoverride)) {
            ma_disasm_genstr((uint8_t*)"cbw");
        } else {
            ma_disasm_genstr((uint8_t*)"cbw???");
        };
    }break;
    case 153:;
    {
        if (!!(ma_disasm_sizeoverride)) {
            ma_disasm_genstr((uint8_t*)"cwd");
        } else if (!!((ma_disasm_rex & (int64_t)8))) {
            ma_disasm_genstr((uint8_t*)"cqo");
        } else {
            ma_disasm_genstr((uint8_t*)"cdq");
        };
    }break;
    case 155:;
    {
        ma_disasm_genstr((uint8_t*)"wait");
    }break;
    case 156:;
    {
        ma_disasm_genstr((uint8_t*)"pushf");
    }break;
    case 157:;
    {
        ma_disasm_genstr((uint8_t*)"popf");
    }break;
    case 158:;
    {
        ma_disasm_genstr((uint8_t*)"sahf");
    }break;
    case 159:;
    {
        ma_disasm_genstr((uint8_t*)"lahf");
    }break;
    case 164:;
    case 165:;
    case 166:;
    case 167:;
    case 170:;
    case 171:;
    case 172:;
    case 173:;
    case 174:;
    case 175:;
    {
        ma_disasm_genstr((((opc >> (int64_t)1) & (int64_t)7)==1?(uint8_t*)"?":(((opc >> (int64_t)1) & (int64_t)7)==2?(uint8_t*)"movs":(((opc >> (int64_t)1) & (int64_t)7)==3?(uint8_t*)"cmps":(((opc >> (int64_t)1) & (int64_t)7)==4?(uint8_t*)"?":(((opc >> (int64_t)1) & (int64_t)7)==5?(uint8_t*)"stos":(((opc >> (int64_t)1) & (int64_t)7)==6?(uint8_t*)"lods":(((opc >> (int64_t)1) & (int64_t)7)==7?(uint8_t*)"scas":(uint8_t*)"?"))))))));
        if (((opc & (int64_t)1) == (int64_t)0)) {
            ma_disasm_genstr((uint8_t*)"b");
        } else {
            if (!!((ma_disasm_rex & (int64_t)8))) {
                ma_disasm_genstr((uint8_t*)"q");
            } else if (!!(ma_disasm_sizeoverride)) {
                ma_disasm_genstr((uint8_t*)"w");
            } else {
                ma_disasm_genstr((uint8_t*)"d");
            };
        };
    }break;
    case 168:;
    case 169:;
    {
        ma_disasm_genstr((uint8_t*)"test ");
        if (!!((opc & (int64_t)1))) {
            ma_disasm_opsize = (!!(ma_disasm_sizeoverride)?(int64_t)2:(int64_t)4);
            if (!!((ma_disasm_rex & (int64_t)8))) {
                ma_disasm_opsize = (int64_t)8;
            };
        };
        ma_disasm_genstr(ma_disasm_strreg((int64_t)1,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genintd(ma_disasm_readimm());
    }break;
    case 176:;
    case 177:;
    case 178:;
    case 179:;
    case 180:;
    case 181:;
    case 182:;
    case 183:;
    case 184:;
    case 185:;
    case 186:;
    case 187:;
    case 188:;
    case 189:;
    case 190:;
    case 191:;
    {
        reg = ((opc & (int64_t)7) + (int64_t)1);
        if (!!((ma_disasm_rex & (int64_t)1))) {
            reg += (int64_t)8;
        };
        if (!!((opc & (int64_t)8))) {
            ma_disasm_opsize = (!!(ma_disasm_sizeoverride)?(int64_t)2:(int64_t)4);
            if (!!((ma_disasm_rex & (int64_t)8))) {
                ma_disasm_opsize = (int64_t)8;
            };
        };
        ma_disasm_genstr((uint8_t*)"mov ");
        ma_disasm_getsil(&reg);
        ma_disasm_genstr(ma_disasm_strreg(reg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genintd(ma_disasm_readimm8());
    }break;
    case 192:;
    case 193:;
    case 208:;
    case 209:;
    case 210:;
    case 211:;
    {
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_genstr(((ma_disasm_rmopc + (int64_t)1)==1?(uint8_t*)"rol":((ma_disasm_rmopc + (int64_t)1)==2?(uint8_t*)"ror":((ma_disasm_rmopc + (int64_t)1)==3?(uint8_t*)"rcl":((ma_disasm_rmopc + (int64_t)1)==4?(uint8_t*)"rcr":((ma_disasm_rmopc + (int64_t)1)==5?(uint8_t*)"shl":((ma_disasm_rmopc + (int64_t)1)==6?(uint8_t*)"shr":((ma_disasm_rmopc + (int64_t)1)==7?(uint8_t*)"?":((ma_disasm_rmopc + (int64_t)1)==8?(uint8_t*)"sar":(uint8_t*)"?")))))))));
        ma_disasm_printaddrmode((int64_t)0);
        if ((opc <= (int64_t)193)) {
            ma_disasm_genstr((uint8_t*)", ");
            ma_disasm_genintd(ma_disasm_readbyte());
        } else {
            ma_disasm_genstr((!!((opc & (int64_t)2))?(uint8_t*)", cl":(uint8_t*)", 1"));
        };
    }break;
    case 194:;
    {
        ma_disasm_genstr((uint8_t*)"retn ");
        ma_disasm_genintd((int64_t)(ma_disasm_readword16()));
    }break;
    case 195:;
    {
        ma_disasm_genstr((uint8_t*)"ret");
    }break;
    case 198:;
    case 199:;
    {
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_genstr((uint8_t*)"mov");
        ma_disasm_printaddrmode((int64_t)0);
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genintd(ma_disasm_readimm());
    }break;
    case 215:;
    {
        ma_disasm_genstr((uint8_t*)"xlat");
    }break;
    case 216:;
    case 217:;
    case 218:;
    case 219:;
    case 220:;
    case 221:;
    case 222:;
    case 223:;
    {
        ma_disasm_decode8087((opc & (int64_t)7));
    }break;
    case 224:;
    {
        ma_disasm_genstr((uint8_t*)"loopnz ");
        ma_disasm_genintd(ma_disasm_readsbyte());
    }break;
    case 225:;
    {
        ma_disasm_genstr((uint8_t*)"loopz ");
        ma_disasm_genintd(ma_disasm_readsbyte());
    }break;
    case 226:;
    {
        ma_disasm_genstr((uint8_t*)"loop ");
        ma_disasm_genintd(ma_disasm_readsbyte());
    }break;
    case 227:;
    {
        if (!!(ma_disasm_addroverride)) {
            ma_disasm_genstr((uint8_t*)"jecxz ");
        } else {
            ma_disasm_genstr((uint8_t*)"jrcxz ");
        };
        ma_disasm_genintd(ma_disasm_readsbyte());
    }break;
    case 232:;
    {
        ma_disasm_genstr((uint8_t*)"call ");
        ma_disasm_genintd(ma_disasm_readint32());
    }break;
    case 233:;
    {
        ma_disasm_genstr((uint8_t*)"[4] jmp ");
        ma_disasm_genintd(ma_disasm_readint32());
    }break;
    case 235:;
    {
        ma_disasm_genstr((uint8_t*)"jmp ");
        ma_disasm_genintd(ma_disasm_readsbyte());
    }break;
    case 242:;
    {
        if ((((int64_t)((uint64_t)((*ma_disasm_codeptr))) != (int64_t)15) && (((int64_t)((uint64_t)((*ma_disasm_codeptr))) < (int64_t)64) && ((int64_t)((uint64_t)((*ma_disasm_codeptr))) > (int64_t)79)))) {
            ma_disasm_genstr((uint8_t*)"repne");
        } else {
            ma_disasm_f2override = (int64_t)1;
            goto L1087 ;
;
        };
    }break;
    case 243:;
    {
        if ((((int64_t)((uint64_t)((*ma_disasm_codeptr))) != (int64_t)15) && (((int64_t)((uint64_t)((*ma_disasm_codeptr))) < (int64_t)64) && ((int64_t)((uint64_t)((*ma_disasm_codeptr))) > (int64_t)79)))) {
            ma_disasm_genstr((uint8_t*)"repe");
        } else {
            ma_disasm_f3override = (int64_t)1;
            goto L1087 ;
;
        };
    }break;
    case 244:;
    {
        return (uint8_t *)(0);
    }break;
    case 246:;
    case 247:;
    {
        ma_disasm_decodeaddr((opc & (int64_t)1));
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_genstr(((ma_disasm_rmopc + (int64_t)1)==1?(uint8_t*)"test":((ma_disasm_rmopc + (int64_t)1)==2?(uint8_t*)"?":((ma_disasm_rmopc + (int64_t)1)==3?(uint8_t*)"not":((ma_disasm_rmopc + (int64_t)1)==4?(uint8_t*)"neg":((ma_disasm_rmopc + (int64_t)1)==5?(uint8_t*)"mul":((ma_disasm_rmopc + (int64_t)1)==6?(uint8_t*)"imul":((ma_disasm_rmopc + (int64_t)1)==7?(uint8_t*)"div":((ma_disasm_rmopc + (int64_t)1)==8?(uint8_t*)"idiv":(uint8_t*)"?")))))))));
        ma_disasm_printaddrmode((int64_t)0);
        if ((ma_disasm_rmopc == (int64_t)0)) {
            if ((ma_disasm_opsize == (int64_t)8)) {
                ma_disasm_opsize = (int64_t)4;
            };
            ma_disasm_genstr((uint8_t*)", ");
            ma_disasm_genintd(ma_disasm_readimm());
        };
    }break;
    case 254:;
    {
        w = (int64_t)0;
        goto L1089 ;
;
    }break;
    case 255:;
    {
        w = (int64_t)1;
        //doff:
L1089 :;
;
        ma_disasm_decodeaddr(w);
        if ((ma_disasm_rmopc==(int64_t)0)) {
            ma_disasm_getsilx(&ma_disasm_basereg);
            ma_disasm_genstr((uint8_t*)"inc");
        }else if ((ma_disasm_rmopc==(int64_t)1)) {
            ma_disasm_getsilx(&ma_disasm_basereg);
            ma_disasm_genstr((uint8_t*)"dec");
        }else if ((ma_disasm_rmopc==(int64_t)2)) {
            ma_disasm_opsize = (int64_t)8;
            ma_disasm_genstr((uint8_t*)"icall");
        }else if ((ma_disasm_rmopc==(int64_t)4)) {
            ma_disasm_opsize = (int64_t)8;
            ma_disasm_genstr((uint8_t*)"jmp");
        }else if ((ma_disasm_rmopc==(int64_t)6)) {
            ma_disasm_opsize = (int64_t)8;
            ma_disasm_genstr((uint8_t*)"push");
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"FFxx?",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    default: {
        ma_disasm_genstr((uint8_t*)"Unknown opcode: ");
        ma_disasm_genhex(opc);
    }
    } //SW
;
    if (!!(baseaddr)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr(baseaddr,(uint8_t*)"z6h");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)": ",NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr(pstart,(uint8_t*)"z6h");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)": ",NULL);
        msysnewc_m_print_end();
        ;
    };
    n = (ma_disasm_codeptr - pstart);
    av_1 = n;
    while (av_1-- > 0) {
L1090 :;
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_i64((int64_t)((*pstart++)),(uint8_t*)"z2H");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_end();
        ;
        strcat((int8_t *)(str),(int8_t *)(str2));
L1091 :;
    }L1092 :;
    ;
    av_2 = ((int64_t)14 - n);
    while (av_2-- > 0) {
L1093 :;
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)"-- "));
L1094 :;
    }L1095 :;
    ;
    strcat((int8_t *)(str),(int8_t *)(ma_disasm_deststr));
    (*cptr) = ma_disasm_codeptr;
    return str;
}

static void ma_disasm_decodetwobyteinstr(void) {
    int64_t opc;
    int64_t rhssize;
    int64_t third;
    int64_t imm;
    uint8_t *  opcstr;
    switch ((opc = (int64_t)((*ma_disasm_codeptr++)))) {
    case 42:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        if (!!(ma_disasm_f3override)) {
            ma_disasm_genstr((uint8_t*)"cvtsi2ss ");
        } else {
            ma_disasm_genstr((uint8_t*)"cvtsi2sd ");
        };
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 44:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        if (!!(ma_disasm_f3override)) {
            ma_disasm_genstr((uint8_t*)"cvttss2si ");
            rhssize = (int64_t)4;
        } else {
            ma_disasm_genstr((uint8_t*)"cvttsd2si ");
            rhssize = (int64_t)8;
        };
        if (!!((ma_disasm_rex & (int64_t)8))) {
            ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,(int64_t)8));
        } else {
            ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,(int64_t)4));
        };
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = rhssize;
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 45:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        if (!!(ma_disasm_f3override)) {
            ma_disasm_genstr((uint8_t*)"cvtss2si ");
            rhssize = (int64_t)4;
        } else {
            ma_disasm_genstr((uint8_t*)"cvtsd2si ");
            rhssize = (int64_t)8;
        };
        if (!!((ma_disasm_rex & (int64_t)8))) {
            ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,(int64_t)8));
        } else {
            ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,(int64_t)4));
        };
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = rhssize;
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 47:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        if (!!(ma_disasm_sizeoverride)) {
            ma_disasm_opsize = (int64_t)8;
            ma_disasm_genstr((uint8_t*)"comisd ");
        } else {
            ma_disasm_opsize = (int64_t)4;
            ma_disasm_genstr((uint8_t*)"comiss ");
        };
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 58:;
    {
        third = (int64_t)((*ma_disasm_codeptr++));
        if ((third==(int64_t)99)) {
            ma_disasm_genstr((uint8_t*)"pcmpistri ");
        } else {
            ma_disasm_genstr((uint8_t*)"Unknown opcode 2-byte opcode: 0F ");
            ma_disasm_genhex(opc);
            return;
        };
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)1);
        ma_disasm_genstr((uint8_t*)", ");
        imm = (int64_t)((*ma_disasm_codeptr++));
        ma_disasm_genintd(imm);
    }break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((uint8_t*)"cmov");
        ma_disasm_genstr(ma_disasm_condnames[((opc & (int64_t)15))]);
        ma_disasm_genstr((uint8_t*)" ");
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 81:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_opsize = (!!(ma_disasm_f3override)?(int64_t)4:(int64_t)8);
        ma_disasm_genstr(((ma_disasm_opsize == (int64_t)4)?(uint8_t*)"sqrtss ":(uint8_t*)"sqrtsd "));
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 84:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((!!(ma_disasm_sizeoverride)?(uint8_t*)"andpd ":(uint8_t*)"andps "));
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = (!!(ma_disasm_sizeoverride)?(int64_t)8:(int64_t)4);
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 87:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((!!(ma_disasm_sizeoverride)?(uint8_t*)"xorpd ":(uint8_t*)"xorps "));
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = (!!(ma_disasm_sizeoverride)?(int64_t)8:(int64_t)4);
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 88:;
    {
        opcstr = (uint8_t*)"adds";
        //doarith:
L1096 :;
;
        ma_disasm_genstr(opcstr);
        ma_disasm_decodeaddr((int64_t)1);
        if (!!(ma_disasm_f2override)) {
            ma_disasm_opsize = (int64_t)8;
            ma_disasm_genstr((uint8_t*)"d ");
        } else {
            ma_disasm_opsize = (int64_t)4;
            ma_disasm_genstr((uint8_t*)"s ");
        };
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 89:;
    {
        opcstr = (uint8_t*)"muls";
        goto L1096 ;
;
    }break;
    case 90:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        if (!!(ma_disasm_f3override)) {
            ma_disasm_genstr((uint8_t*)"cvtss2sd ");
            rhssize = (int64_t)4;
        } else {
            ma_disasm_genstr((uint8_t*)"cvtsd2ss ");
            rhssize = (int64_t)8;
        };
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = rhssize;
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 92:;
    {
        opcstr = (uint8_t*)"subs";
        goto L1096 ;
;
    }break;
    case 93:;
    {
        opcstr = (uint8_t*)"mins";
        goto L1096 ;
;
    }break;
    case 94:;
    {
        opcstr = (uint8_t*)"divs";
        goto L1096 ;
;
    }break;
    case 95:;
    {
        opcstr = (uint8_t*)"maxs";
        goto L1096 ;
;
    }break;
    case 110:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_opsize = (!!((ma_disasm_rex & (int64_t)8))?(int64_t)8:(int64_t)4);
        ma_disasm_genstr(((ma_disasm_opsize == (int64_t)4)?(uint8_t*)"movd ":(uint8_t*)"movq "));
        if (!!(ma_disasm_sizeoverride)) {
            ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        } else {
            ma_disasm_genstr(ma_disasm_strmmx(ma_disasm_rmreg));
        };
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 111:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_opsize = (int64_t)16;
        if (!!(ma_disasm_sizeoverride)) {
            ma_disasm_genstr((uint8_t*)"movdqa ");
        } else if (!!(ma_disasm_f3override)) {
            ma_disasm_genstr((uint8_t*)"movdqu ");
        } else {
            ma_disasm_genstr((uint8_t*)"No 66/F3 ");
        };
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 126:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        if (!!(ma_disasm_f3override)) {
            ma_disasm_opsize = (int64_t)8;
            ma_disasm_genstr((uint8_t*)"movq ");
            ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
            ma_disasm_genstr((uint8_t*)", ");
            ma_disasm_printaddrmode((int64_t)1);
        } else if (!!((ma_disasm_rex & (int64_t)8))) {
            ma_disasm_opsize = (int64_t)8;
            ma_disasm_genstr((uint8_t*)"movq ");
            ma_disasm_printaddrmode((int64_t)0);
            ma_disasm_genstr((uint8_t*)", ");
            ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        } else {
            ma_disasm_opsize = (int64_t)4;
            ma_disasm_genstr((uint8_t*)"movd ");
            ma_disasm_printaddrmode((int64_t)0);
            ma_disasm_genstr((uint8_t*)", ");
            if (!!(ma_disasm_sizeoverride)) {
                ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
            } else {
                ma_disasm_genstr(ma_disasm_strmmx(ma_disasm_rmreg));
            };
        };
    }break;
    case 127:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_opsize = (int64_t)16;
        if (!!(ma_disasm_sizeoverride)) {
            ma_disasm_genstr((uint8_t*)"movdqa ");
        } else if (!!(ma_disasm_f3override)) {
            ma_disasm_genstr((uint8_t*)"movdqu ");
        } else {
            ma_disasm_genstr((uint8_t*)"No 66/F3 ");
        };
        ma_disasm_printaddrmode((int64_t)1);
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
    }break;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    case 132:;
    case 133:;
    case 134:;
    case 135:;
    case 136:;
    case 137:;
    case 138:;
    case 139:;
    case 140:;
    case 141:;
    case 142:;
    case 143:;
    {
        ma_disasm_genstr((uint8_t*)"[long] j");
        ma_disasm_genstr(ma_disasm_condnames[((opc & (int64_t)15))]);
        ma_disasm_genstr((uint8_t*)" ");
        if (!!(ma_disasm_sizeoverride)) {
            ma_disasm_genintd(ma_disasm_readint16());
        } else {
            ma_disasm_genintd(ma_disasm_readint32());
        };
    }break;
    case 144:;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
    case 152:;
    case 153:;
    case 154:;
    case 155:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    {
        ma_disasm_decodeaddr((int64_t)0);
        ma_disasm_genstr((uint8_t*)"set");
        ma_disasm_genstr(ma_disasm_condnames[((opc & (int64_t)15))]);
        ma_disasm_genstr((uint8_t*)" ");
        ma_disasm_getsilx(&ma_disasm_basereg);
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 175:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((uint8_t*)"imul ");
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 182:;
    case 183:;
    case 190:;
    case 191:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr(((opc < (int64_t)190)?(uint8_t*)"movzx ":(uint8_t*)"movsx "));
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = (!!((opc & (int64_t)1))?(int64_t)2:(int64_t)1);
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 184:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((uint8_t*)"popcnt ");
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_rmreg,ma_disasm_opsize));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_printaddrmode((int64_t)0);
    }break;
    case 214:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_opsize = (int64_t)8;
        ma_disasm_genstr((uint8_t*)"movq ");
        ma_disasm_printaddrmode((int64_t)1);
        ma_disasm_genstr((uint8_t*)",");
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
    }break;
    case 219:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((uint8_t*)"pand ");
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = (int64_t)8;
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    case 239:;
    {
        ma_disasm_decodeaddr((int64_t)1);
        ma_disasm_genstr((uint8_t*)"pxor ");
        ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_rmreg));
        ma_disasm_genstr((uint8_t*)", ");
        ma_disasm_opsize = (int64_t)8;
        ma_disasm_printaddrmode((int64_t)1);
    }break;
    default: {
        ma_disasm_genstr((uint8_t*)"Unknown opcode 2-byte opcode: 0F ");
        ma_disasm_genhex(opc);
    }
    } //SW
;
}

static void ma_disasm_decodeaddr(int64_t w) {
    int64_t modrm;
    int64_t xxx;
    int64_t mode;
    int64_t sib;
    int64_t rm;
    ma_disasm_basereg = (ma_disasm_indexreg = (int64_t)0);
    ma_disasm_scale = (int64_t)1;
    ma_disasm_offset = (int64_t)0;
    if (!!(w)) {
        ma_disasm_opsize = (!!(ma_disasm_sizeoverride)?(int64_t)2:(int64_t)4);
        if (!!((ma_disasm_rex & (int64_t)8))) {
            ma_disasm_opsize = (int64_t)8;
        };
    } else {
        ma_disasm_opsize = (int64_t)1;
    };
    modrm = (int64_t)((*ma_disasm_codeptr++));
    mode = (modrm >> (int64_t)6);
    xxx = ((modrm >> (int64_t)3) & (int64_t)7);
    rm = (modrm & (int64_t)7);
    if ((mode == (int64_t)3)) {
        ma_disasm_basereg = (rm + (int64_t)1);
        ma_disasm_addrmode = (int64_t)1;
    } else if ((rm != (int64_t)4)) {
        if (((mode == (int64_t)0) && (rm == (int64_t)5))) {
            ma_disasm_offset = ma_disasm_readint32();
            ma_disasm_addrmode = (int64_t)2;
        } else {
            ma_disasm_basereg = (rm + (int64_t)1);
            ma_disasm_addrmode = (int64_t)2;
            if ((mode==(int64_t)1)) {
                ma_disasm_offset = ma_disasm_readsbyte();
            }else if ((mode==(int64_t)2)) {
                ma_disasm_offset = ma_disasm_readint32();
            };
        };
    } else {
        ma_disasm_addrmode = (int64_t)2;
        sib = ma_disasm_readbyte();
        ma_disasm_indexreg = (((sib >> (int64_t)3) & (int64_t)7) + (int64_t)1);
        ma_disasm_basereg = ((sib & (int64_t)7) + (int64_t)1);
        ma_disasm_scale = (((sib >> (int64_t)6) + (int64_t)1)==1?(int64_t)1:(((sib >> (int64_t)6) + (int64_t)1)==2?(int64_t)2:(((sib >> (int64_t)6) + (int64_t)1)==3?(int64_t)4:(((sib >> (int64_t)6) + (int64_t)1)==4?(int64_t)8:(int64_t)0))));
        if (((mode == (int64_t)0) && (ma_disasm_basereg == (int64_t)6))) {
            ma_disasm_basereg = (int64_t)0;
            ma_disasm_offset = ma_disasm_readint32();
        } else {
            if ((mode==(int64_t)1)) {
                ma_disasm_offset = ma_disasm_readsbyte();
            }else if ((mode==(int64_t)2)) {
                ma_disasm_offset = ma_disasm_readint32();
            };
        };
        if ((ma_disasm_indexreg == (int64_t)5)) {
            ma_disasm_indexreg = (int64_t)0;
        };
    };
    if ((!!(ma_disasm_basereg) && !!((ma_disasm_rex & (int64_t)1)))) {
        ma_disasm_basereg += (int64_t)8;
    };
    if ((!!(ma_disasm_indexreg) && !!((ma_disasm_rex & (int64_t)2)))) {
        ma_disasm_indexreg += (int64_t)8;
    };
    ma_disasm_rmreg = (xxx + (int64_t)1);
    if (!!((ma_disasm_rex & (int64_t)4))) {
        ma_disasm_rmreg += (int64_t)8;
    };
    ma_disasm_rmopc = xxx;
}

static int64_t ma_disasm_readbyte(void) {
    return (int64_t)((*ma_disasm_codeptr++));
}

static int64_t ma_disasm_readsbyte(void) {
    return (int64_t)((*(int8_t *)(ma_disasm_codeptr++)));
}

static uint64_t ma_disasm_readword16(void) {
    uint64_t a;
    a = (uint64_t)((*(uint16_t *)(ma_disasm_codeptr)));
    ma_disasm_codeptr += (int64_t)2;
    return a;
}

static int64_t ma_disasm_readint16(void) {
    int64_t a;
    a = (int64_t)((*(int16_t *)(ma_disasm_codeptr)));
    ma_disasm_codeptr += (int64_t)2;
    return a;
}

static uint64_t ma_disasm_readword32(void) {
    uint64_t a;
    a = (uint64_t)((*(uint32_t *)(ma_disasm_codeptr)));
    ma_disasm_codeptr += (int64_t)4;
    return a;
}

static int64_t ma_disasm_readint32(void) {
    int64_t a;
    a = (int64_t)((*(int32_t *)(ma_disasm_codeptr)));
    ma_disasm_codeptr += (int64_t)4;
    return a;
}

static int64_t ma_disasm_readint64(void) {
    int64_t a;
    a = (*(int64_t *)(ma_disasm_codeptr));
    ma_disasm_codeptr += (int64_t)8;
    return a;
}

static int64_t ma_disasm_getreg(int64_t regcode,int64_t upper) {
    if (!!(upper)) {
        return ((regcode + (int64_t)8) + (int64_t)1);
    };
    return (regcode + (int64_t)1);
}

static uint8_t * ma_disasm_strreg(int64_t reg,int64_t opsize) {
    static uint8_t *  regnames8[20] = {
    (uint8_t*)"al",
    (uint8_t*)"cl",
    (uint8_t*)"dl",
    (uint8_t*)"bl",
    (uint8_t*)"ah",
    (uint8_t*)"ch",
    (uint8_t*)"dh",
    (uint8_t*)"bh",
    (uint8_t*)"r8b",
    (uint8_t*)"r9b",
    (uint8_t*)"r10b",
    (uint8_t*)"r11b",
    (uint8_t*)"r12b",
    (uint8_t*)"r13b",
    (uint8_t*)"r14b",
    (uint8_t*)"r15b",
    (uint8_t*)"spl",
    (uint8_t*)"bpl",
    (uint8_t*)"sil",
    (uint8_t*)"dil"
};
    static uint8_t *  regnames16[16] = {
    (uint8_t*)"ax",
    (uint8_t*)"cx",
    (uint8_t*)"dx",
    (uint8_t*)"bx",
    (uint8_t*)"sp",
    (uint8_t*)"bp",
    (uint8_t*)"si",
    (uint8_t*)"di",
    (uint8_t*)"r8w",
    (uint8_t*)"r9w",
    (uint8_t*)"r10w",
    (uint8_t*)"r11w",
    (uint8_t*)"r12w",
    (uint8_t*)"r13w",
    (uint8_t*)"r14w",
    (uint8_t*)"r15w"
};
    static uint8_t *  regnames32[16] = {
    (uint8_t*)"eax",
    (uint8_t*)"ecx",
    (uint8_t*)"edx",
    (uint8_t*)"ebx",
    (uint8_t*)"esp",
    (uint8_t*)"ebp",
    (uint8_t*)"esi",
    (uint8_t*)"edi",
    (uint8_t*)"r8d",
    (uint8_t*)"r9d",
    (uint8_t*)"r10d",
    (uint8_t*)"r11d",
    (uint8_t*)"r12d",
    (uint8_t*)"r13d",
    (uint8_t*)"r14d",
    (uint8_t*)"r15d"
};
    static uint8_t *  regnames64[16] = {
    (uint8_t*)"rax",
    (uint8_t*)"rcx",
    (uint8_t*)"rdx",
    (uint8_t*)"rbx",
    (uint8_t*)"rsp",
    (uint8_t*)"rbp",
    (uint8_t*)"rsi",
    (uint8_t*)"rdi",
    (uint8_t*)"r8",
    (uint8_t*)"r9",
    (uint8_t*)"r10",
    (uint8_t*)"r11",
    (uint8_t*)"r12",
    (uint8_t*)"r13",
    (uint8_t*)"r14",
    (uint8_t*)"r15"
};
    static uint8_t *  mregnames8[20] = {
    (uint8_t*)"B0",
    (uint8_t*)"B10",
    (uint8_t*)"B11",
    (uint8_t*)"B1",
    (uint8_t*)"B16",
    (uint8_t*)"B18",
    (uint8_t*)"B19",
    (uint8_t*)"B17",
    (uint8_t*)"B12",
    (uint8_t*)"B13",
    (uint8_t*)"B4",
    (uint8_t*)"B5",
    (uint8_t*)"B6",
    (uint8_t*)"B7",
    (uint8_t*)"B8",
    (uint8_t*)"B9",
    (uint8_t*)"B14",
    (uint8_t*)"B15",
    (uint8_t*)"B2",
    (uint8_t*)"B3"
};
    static uint8_t *  mregnames16[16] = {
    (uint8_t*)"W0",
    (uint8_t*)"W10",
    (uint8_t*)"W11",
    (uint8_t*)"W1",
    (uint8_t*)"Wsp",
    (uint8_t*)"Wbp",
    (uint8_t*)"W2",
    (uint8_t*)"W3",
    (uint8_t*)"W12",
    (uint8_t*)"W13",
    (uint8_t*)"W4",
    (uint8_t*)"W5",
    (uint8_t*)"W6",
    (uint8_t*)"W7",
    (uint8_t*)"W8",
    (uint8_t*)"W9"
};
    static uint8_t *  mregnames32[16] = {
    (uint8_t*)"A0",
    (uint8_t*)"A10",
    (uint8_t*)"A11",
    (uint8_t*)"A1",
    (uint8_t*)"Astack",
    (uint8_t*)"Aframe",
    (uint8_t*)"A2",
    (uint8_t*)"A3",
    (uint8_t*)"A12",
    (uint8_t*)"A13",
    (uint8_t*)"A4",
    (uint8_t*)"A5",
    (uint8_t*)"A6",
    (uint8_t*)"A7",
    (uint8_t*)"A8",
    (uint8_t*)"A9"
};
    static uint8_t *  mregnames64[16] = {
    (uint8_t*)"D0",
    (uint8_t*)"D10",
    (uint8_t*)"D11",
    (uint8_t*)"D1",
    (uint8_t*)"Dstack",
    (uint8_t*)"Dframe",
    (uint8_t*)"D2",
    (uint8_t*)"D3",
    (uint8_t*)"D12",
    (uint8_t*)"D13",
    (uint8_t*)"D4",
    (uint8_t*)"D5",
    (uint8_t*)"D6",
    (uint8_t*)"D7",
    (uint8_t*)"D8",
    (uint8_t*)"D9"
};
    if ((reg == (int64_t)0)) {
        return (uint8_t*)"<>";
    };
    if (!!((int64_t)1)) {
        if ((opsize==(int64_t)1)) {
            return mregnames8[(reg)-1];
        }else if ((opsize==(int64_t)2)) {
            return mregnames16[(reg)-1];
        }else if ((opsize==(int64_t)4)) {
            return mregnames32[(reg)-1];
        }else if ((opsize==(int64_t)8)) {
            return mregnames64[(reg)-1];
        };
    } else {
        if ((opsize==(int64_t)1)) {
            return regnames8[(reg)-1];
        }else if ((opsize==(int64_t)2)) {
            return regnames16[(reg)-1];
        }else if ((opsize==(int64_t)4)) {
            return regnames32[(reg)-1];
        }else if ((opsize==(int64_t)8)) {
            return regnames64[(reg)-1];
        };
    };
    return (uint8_t*)"";
}

static uint8_t * ma_disasm_strfreg(int64_t freg) {
    static uint8_t *  fregnames[8] = {(uint8_t*)"st0",(uint8_t*)"st1",(uint8_t*)"st2",(uint8_t*)"st3",(uint8_t*)"st4",(uint8_t*)"st5",(uint8_t*)"st6",(uint8_t*)"st7"};
    return fregnames[(freg)-1];
}

static void ma_disasm_printaddrmode(int64_t xmm) {
    uint8_t *  plus;
    int64_t addrsize;
    ma_disasm_genstr((uint8_t*)" ");
    if ((ma_disasm_addrmode==(int64_t)1)) {
        if (!!(xmm)) {
            ma_disasm_genstr(ma_disasm_strxmm(ma_disasm_basereg));
        } else {
            ma_disasm_getsilx(&ma_disasm_basereg);
            ma_disasm_genstr(ma_disasm_strreg(ma_disasm_basereg,ma_disasm_opsize));
        };
        return;
    };
    if ((ma_disasm_opsize==(int64_t)1)) {
        ma_disasm_genstr((uint8_t*)"byte ");
    }else if ((ma_disasm_opsize==(int64_t)2)) {
        ma_disasm_genstr((uint8_t*)"word ");
    }else if ((ma_disasm_opsize==(int64_t)4)) {
        ma_disasm_genstr((uint8_t*)"dword ");
    }else if ((ma_disasm_opsize==(int64_t)8)) {
        ma_disasm_genstr((uint8_t*)"qword ");
    }else if ((ma_disasm_opsize==(int64_t)10)) {
        ma_disasm_genstr((uint8_t*)"tword ");
    }else if ((ma_disasm_opsize==(int64_t)16)) {
        ma_disasm_genstr((uint8_t*)"oword ");
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"///OPSIZE",NULL);
        msysnewc_m_print_i64(ma_disasm_opsize,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    ma_disasm_genstr((uint8_t*)"[");
    plus = (uint8_t*)"";
    addrsize = (!!(ma_disasm_addroverride)?(int64_t)4:(int64_t)8);
    if (!!(ma_disasm_basereg)) {
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_basereg,addrsize));
        plus = (uint8_t*)"+";
    };
    if (!!(ma_disasm_indexreg)) {
        ma_disasm_genstr(plus);
        ma_disasm_genstr(ma_disasm_strreg(ma_disasm_indexreg,addrsize));
        if ((ma_disasm_scale > (int64_t)1)) {
            ma_disasm_genstr((uint8_t*)"*");
            ma_disasm_genintd(ma_disasm_scale);
        };
        plus = (uint8_t*)"+";
    };
    if ((!!(ma_disasm_offset) || ((ma_disasm_basereg == (int64_t)0) && (ma_disasm_indexreg == (int64_t)0)))) {
        if (((ma_disasm_basereg == (int64_t)0) && (ma_disasm_indexreg == (int64_t)0))) {
            ma_disasm_genhex(ma_disasm_offset);
        } else {
            if ((ma_disasm_offset > (int64_t)0)) {
                ma_disasm_genstr(plus);
            };
            ma_disasm_genintd(ma_disasm_offset);
        };
    };
    ma_disasm_genstr((uint8_t*)"]");
    if ((ma_disasm_addrmode == (int64_t)3)) {
        ma_disasm_genstr((uint8_t*)"+RIP");
    };
}

static void ma_disasm_genstr(uint8_t * s) {
    strcat((int8_t *)(ma_disasm_deststr),(int8_t *)(s));
}

static void ma_disasm_genintd(int64_t a) {
    ma_disasm_genstr(msysnewc_strint(a,(uint8_t *)(0)));
}

static void ma_disasm_genhex(int64_t a) {
    ma_disasm_genstr(msysnewc_strint(a,(uint8_t*)"h"));
}

static int64_t ma_disasm_readimm(void) {
    if ((ma_disasm_opsize==(int64_t)1)) {
        return ma_disasm_readsbyte();
    }else if ((ma_disasm_opsize==(int64_t)2)) {
        return ma_disasm_readint16();
    }else if ((ma_disasm_opsize==(int64_t)4) || (ma_disasm_opsize==(int64_t)8)) {
        return ma_disasm_readint32();
    };
    return (int64_t)0;
}

static int64_t ma_disasm_readimm8(void) {
    if ((ma_disasm_opsize < (int64_t)8)) {
        return ma_disasm_readimm();
    };
    return ma_disasm_readint64();
}

static uint8_t * ma_disasm_strxmm(int64_t reg) {
    static uint8_t str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((uint8_t*)"xmm",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (int64_t)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

static uint8_t * ma_disasm_strmmx(int64_t reg) {
    static uint8_t str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((uint8_t*)"mmx",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (int64_t)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

static void ma_disasm_decode8087(int64_t ttt) {
    byte bb;
    int64_t longopc;
    int64_t freg;
    int64_t shortopc;
    bb = (uint64_t)((*ma_disasm_codeptr++));
    longopc = ((ttt << (int64_t)8) + (int64_t)((uint64_t)(bb)));
    freg = (((int64_t)((uint64_t)(bb)) & (int64_t)7) + (int64_t)1);
    if ((longopc==(int64_t)1753)) {
        ma_disasm_genstr((uint8_t*)"fcompp");
    }else if ((longopc==(int64_t)484)) {
        ma_disasm_genstr((uint8_t*)"ftst");
    }else if ((longopc==(int64_t)485)) {
        ma_disasm_genstr((uint8_t*)"fxam");
    }else if ((longopc==(int64_t)494)) {
        ma_disasm_genstr((uint8_t*)"fldz");
    }else if ((longopc==(int64_t)488)) {
        ma_disasm_genstr((uint8_t*)"fld1");
    }else if ((longopc==(int64_t)491)) {
        ma_disasm_genstr((uint8_t*)"fldpi");
    }else if ((longopc==(int64_t)489)) {
        ma_disasm_genstr((uint8_t*)"fldl2t");
    }else if ((longopc==(int64_t)490)) {
        ma_disasm_genstr((uint8_t*)"fldl2e");
    }else if ((longopc==(int64_t)492)) {
        ma_disasm_genstr((uint8_t*)"fldlg2");
    }else if ((longopc==(int64_t)493)) {
        ma_disasm_genstr((uint8_t*)"fldln2");
    }else if ((longopc==(int64_t)506)) {
        ma_disasm_genstr((uint8_t*)"fsqrt");
    }else if ((longopc==(int64_t)510)) {
        ma_disasm_genstr((uint8_t*)"fsin");
    }else if ((longopc==(int64_t)511)) {
        ma_disasm_genstr((uint8_t*)"fcos");
    }else if ((longopc==(int64_t)507)) {
        ma_disasm_genstr((uint8_t*)"fsincos");
    }else if ((longopc==(int64_t)509)) {
        ma_disasm_genstr((uint8_t*)"fscale");
    }else if ((longopc==(int64_t)504)) {
        ma_disasm_genstr((uint8_t*)"fprem");
    }else if ((longopc==(int64_t)508)) {
        ma_disasm_genstr((uint8_t*)"frndint");
    }else if ((longopc==(int64_t)500)) {
        ma_disasm_genstr((uint8_t*)"fxtract");
    }else if ((longopc==(int64_t)481)) {
        ma_disasm_genstr((uint8_t*)"fabs");
    }else if ((longopc==(int64_t)480)) {
        ma_disasm_genstr((uint8_t*)"fchs");
    }else if ((longopc==(int64_t)498)) {
        ma_disasm_genstr((uint8_t*)"fptan");
    }else if ((longopc==(int64_t)499)) {
        ma_disasm_genstr((uint8_t*)"fpatan");
    }else if ((longopc==(int64_t)496)) {
        ma_disasm_genstr((uint8_t*)"f2xm1");
    }else if ((longopc==(int64_t)497)) {
        ma_disasm_genstr((uint8_t*)"fyl2x");
    }else if ((longopc==(int64_t)505)) {
        ma_disasm_genstr((uint8_t*)"fyl2xp1");
    }else if ((longopc==(int64_t)995)) {
        ma_disasm_genstr((uint8_t*)"finit");
    }else if ((longopc==(int64_t)992)) {
        ma_disasm_genstr((uint8_t*)"feni");
    }else if ((longopc==(int64_t)993)) {
        ma_disasm_genstr((uint8_t*)"fdisi");
    }else if ((longopc==(int64_t)994)) {
        ma_disasm_genstr((uint8_t*)"fclex");
    }else if ((longopc==(int64_t)503)) {
        ma_disasm_genstr((uint8_t*)"fincstp");
    }else if ((longopc==(int64_t)502)) {
        ma_disasm_genstr((uint8_t*)"fdecstp");
    }else if ((longopc==(int64_t)464)) {
        ma_disasm_genstr((uint8_t*)"fnop");
    } else {
        if (((longopc & (int64_t)2040)==(int64_t)448)) {
            ma_disasm_genstr((uint8_t*)"fld ");
            ma_disasm_genstr(ma_disasm_strfreg(freg));
        }else if (((longopc & (int64_t)2040)==(int64_t)1488)) {
            ma_disasm_genstr((uint8_t*)"fst ");
            ma_disasm_genstr(ma_disasm_strfreg(freg));
        }else if (((longopc & (int64_t)2040)==(int64_t)1496)) {
            ma_disasm_genstr((uint8_t*)"fstp ");
            ma_disasm_genstr(ma_disasm_strfreg(freg));
        }else if (((longopc & (int64_t)2040)==(int64_t)456)) {
            ma_disasm_genstr((uint8_t*)"fxch ");
            ma_disasm_genstr(ma_disasm_strfreg(freg));
        }else if (((longopc & (int64_t)2040)==(int64_t)208)) {
            ma_disasm_genstr((uint8_t*)"fcom ");
            ma_disasm_genstr(ma_disasm_strfreg(freg));
        }else if (((longopc & (int64_t)2040)==(int64_t)216)) {
            ma_disasm_genstr((uint8_t*)"fcomp ");
            ma_disasm_genstr(ma_disasm_strfreg(freg));
        }else if (((longopc & (int64_t)2040)==(int64_t)1472)) {
            ma_disasm_genstr((uint8_t*)"ffree ");
            ma_disasm_genstr(ma_disasm_strfreg(freg));
        } else {
            if (((longopc & (int64_t)504)==(int64_t)192)) {
                ma_disasm_do87arith((uint8_t*)"fadd",ttt,freg);
            }else if (((longopc & (int64_t)504)==(int64_t)224)) {
                ma_disasm_do87arith((uint8_t*)"fsub",ttt,freg);
            }else if (((longopc & (int64_t)504)==(int64_t)232)) {
                ma_disasm_do87arith((uint8_t*)"fsubr",ttt,freg);
            }else if (((longopc & (int64_t)504)==(int64_t)200)) {
                ma_disasm_do87arith((uint8_t*)"fmul",ttt,freg);
            }else if (((longopc & (int64_t)504)==(int64_t)240)) {
                ma_disasm_do87arith((uint8_t*)"fdiv",ttt,freg);
            }else if (((longopc & (int64_t)504)==(int64_t)248)) {
                ma_disasm_do87arith((uint8_t*)"fdivr",ttt,freg);
            } else {
                --ma_disasm_codeptr;
                ma_disasm_decodeaddr((int64_t)0);
                shortopc = ((ttt << (int64_t)3) + ma_disasm_rmopc);
                if ((shortopc==(int64_t)61)) {
                    ma_disasm_do87mem((uint8_t*)"fld",(int64_t)4);
                }else if ((shortopc==(int64_t)29)) {
                    ma_disasm_do87mem((uint8_t*)"fld",(int64_t)5);
                }else if ((shortopc==(int64_t)60)) {
                    ma_disasm_do87mem((uint8_t*)"fldbcd",(int64_t)-1);
                }else if ((shortopc==(int64_t)63)) {
                    ma_disasm_do87mem((uint8_t*)"fstp",(int64_t)4);
                }else if ((shortopc==(int64_t)31)) {
                    ma_disasm_do87mem((uint8_t*)"fstp",(int64_t)5);
                }else if ((shortopc==(int64_t)62)) {
                    ma_disasm_do87mem((uint8_t*)"fstpbcd",(int64_t)-1);
                }else if ((shortopc==(int64_t)13)) {
                    ma_disasm_do87mem((uint8_t*)"fldcw",(int64_t)-1);
                }else if ((shortopc==(int64_t)15)) {
                    ma_disasm_do87mem((uint8_t*)"fstcw",(int64_t)-1);
                }else if ((shortopc==(int64_t)47)) {
                    ma_disasm_do87mem((uint8_t*)"fstsw",(int64_t)-1);
                }else if ((shortopc==(int64_t)14)) {
                    ma_disasm_do87mem((uint8_t*)"fstenv",(int64_t)-1);
                }else if ((shortopc==(int64_t)12)) {
                    ma_disasm_do87mem((uint8_t*)"fldenv",(int64_t)-1);
                }else if ((shortopc==(int64_t)46)) {
                    ma_disasm_do87mem((uint8_t*)"fsave",(int64_t)-1);
                }else if ((shortopc==(int64_t)44)) {
                    ma_disasm_do87mem((uint8_t*)"frstor",(int64_t)-1);
                } else {
                    if (((shortopc & (int64_t)15)==(int64_t)8)) {
                        ma_disasm_do87mem((uint8_t*)"fld",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)10)) {
                        ma_disasm_do87mem((uint8_t*)"fst",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)11)) {
                        ma_disasm_do87mem((uint8_t*)"fstp",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)2)) {
                        ma_disasm_do87mem((uint8_t*)"fcom",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)3)) {
                        ma_disasm_do87mem((uint8_t*)"fcomp",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)0)) {
                        ma_disasm_do87mem((uint8_t*)"fadd",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)4)) {
                        ma_disasm_do87mem((uint8_t*)"fsub",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)5)) {
                        ma_disasm_do87mem((uint8_t*)"fsubr",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)1)) {
                        ma_disasm_do87mem((uint8_t*)"fmul",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)6)) {
                        ma_disasm_do87mem((uint8_t*)"fdiv",(ttt >> (int64_t)1));
                    }else if (((shortopc & (int64_t)15)==(int64_t)7)) {
                        ma_disasm_do87mem((uint8_t*)"fdivr",(ttt >> (int64_t)1));
                    } else {
                        ma_disasm_genstr((uint8_t*)"UNKNOWN x87 OPCODE");
                    };
                };
            };
        };
    };
}

static void ma_disasm_do87arith(uint8_t * opcstr,int64_t ttt,int64_t freg) {
    int64_t d;
    int64_t p;
    d = (ttt & (int64_t)4);
    p = (ttt & (int64_t)2);
    ma_disasm_genstr(opcstr);
    if (!!(p)) {
        ma_disasm_genstr((uint8_t*)"p");
    };
    ma_disasm_genstr((uint8_t*)" ");
    if ((d == (int64_t)0)) {
        ma_disasm_genstr((uint8_t*)"st0, ");
        ma_disasm_genstr(ma_disasm_strfreg(freg));
    } else {
        ma_disasm_genstr(ma_disasm_strfreg(freg));
        ma_disasm_genstr((uint8_t*)", st0");
    };
}

static void ma_disasm_do87mem(uint8_t * opcstr,int64_t mf) {
    ma_disasm_genstr((uint8_t*)"f");
    if ((mf==(int64_t)0)) {
        ma_disasm_opsize = (int64_t)4;
    }else if ((mf==(int64_t)1)) {
        ma_disasm_genstr((uint8_t*)"i");
        ma_disasm_opsize = (int64_t)4;
    }else if ((mf==(int64_t)2)) {
        ma_disasm_opsize = (int64_t)8;
    }else if ((mf==(int64_t)3)) {
        ma_disasm_genstr((uint8_t*)"i");
        ma_disasm_opsize = (int64_t)2;
    }else if ((mf==(int64_t)4)) {
        ma_disasm_genstr((uint8_t*)"i");
        ma_disasm_opsize = (int64_t)8;
    }else if ((mf==(int64_t)5)) {
        ma_disasm_opsize = (int64_t)10;
    };
    ma_disasm_genstr((opcstr + (int64_t)1));
    ma_disasm_genstr((uint8_t*)" ");
    ma_disasm_printaddrmode((int64_t)0);
}

static void ma_disasm_getsil(int64_t * reg) {
    if (((((ma_disasm_opsize == (int64_t)1) && !!(ma_disasm_rex)) && ((*reg) >= (int64_t)5)) && ((*reg) <= (int64_t)8))) {
        (*reg) += (int64_t)12;
    };
}

static void ma_disasm_getsilx(int64_t * reg) {
    if ((((((ma_disasm_addrmode == (int64_t)1) && (ma_disasm_opsize == (int64_t)1)) && !!(ma_disasm_rex)) && ((*reg) >= (int64_t)5)) && ((*reg) <= (int64_t)8))) {
        (*reg) += (int64_t)12;
    };
}

int64_t mm_parse_parsemodule(int64_t n) {
    struct mm_decls_modulerec m;
    struct mm_decls_strec *  owner;
    int64_t status;
    mm_parse_initparser();
    m = mm_decls_moduletable[(n)];
    mm_decls_currmoduleno = n;
    mm_decls_stmodule = mm_decls_moduletable[(n)].stmodule;
    mm_decls_currproc = mm_decls_stmodule;
    mm_lex_startlex((uint8_t*)"PARSEMODULE",m.fileno);
    owner = mm_decls_stmodule;
    mm_lex_lex();
    status = mm_parse_readmoduledefs(owner);
    if (!(!!(status))) {
        return (int64_t)0;
    };
    return status;
}

int64_t mm_parse_readmoduledefs(struct mm_decls_strec * owner) {
    struct mm_decls_strec *  dimport;
    struct mm_decls_strec *  stimport;
    int64_t globalflag;
    int64_t i;
    int64_t callbackflag;
    uint8_t *  name;
    globalflag = (int64_t)0;
    callbackflag = (int64_t)0;
    L1097 :;
    while (1) {
        switch ((int64_t)(mm_decls_lx.symbol)) {
        case 130:;
        {
            if (!!(globalflag)) {
                mm_support_serror((uint8_t*)"global global?");
            };
            globalflag = (int64_t)(mm_decls_lx.subcode);
            mm_lex_lex();
        }break;
        case 100:;
        case 101:;
        {
            mm_parse_readprocdef(owner,globalflag,callbackflag);
            callbackflag = (int64_t)0;
            globalflag = (int64_t)0;
        }break;
        case 61:;
        case 50:;
        case 14:;
        case 113:;
        case 66:;
        case 63:;
        case 117:;
        case 116:;
        {
            mm_parse_readvardef(owner,globalflag,(int64_t)0,(int64_t)9,(int64_t)114);
            globalflag = (int64_t)0;
        }break;
        case 114:;
        {
            mm_lex_lex();
            mm_parse_readvardef(owner,globalflag,(int64_t)0,(int64_t)9,(int64_t)114);
            globalflag = (int64_t)0;
        }break;
        case 115:;
        {
            mm_lex_lex();
            mm_parse_readvardef(owner,globalflag,(int64_t)0,(int64_t)9,(int64_t)115);
            globalflag = (int64_t)0;
        }break;
        case 107:;
        {
            mm_parse_readimportmodule(owner);
        }break;
        case 108:;
        {
            mm_lex_lex();
            mm_parse_checksymbol((int64_t)46);
            mm_lex_lex();
        }break;
        case 109:;
        {
            L1099 :;
            do {
                mm_lex_lex();
L1100 :;
            } while (!((mm_decls_lx.symbol == (int64_t)6) || (mm_decls_lx.symbol == (int64_t)36)));L1101 :;
            ;
        }break;
        case 111:;
        {
            mm_parse_readtypedef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 121:;
        {
            mm_parse_readconstdef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 125:;
        case 103:;
        {
            mm_parse_readclassdef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 123:;
        {
            mm_lex_lex();
            mm_parse_readenumtype(owner,(int64_t)0,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 143:;
        {
            mm_parse_readtabledef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 39:;
        {
            mm_parse_adddocstring(mm_decls_lx.svalue,(int64_t)(mm_decls_lx.length));
            mm_lex_lex();
        }break;
        case 106:;
        {
            if (!!(globalflag)) {
                mm_support_serror((uint8_t*)"glob/import?");
            };
            mm_lex_lex();
            if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)45))) {
                mm_lex_lex();
            };
            mm_parse_checksymbol((int64_t)50);
            dimport = mm_decls_lx.symptr;
            name = mm_start_mapimport((*dimport).name);
            L1102 :;
            for (i=(int64_t)1;i<=mm_decls_nmodules;i+=(int64_t)1) {
L1103 :;
                if (!!(mlib_eqstring(name,mm_decls_moduletable[(i)].name))) {
                    stimport = mm_decls_moduletable[(i)].stmodule;
                    goto L1105 ;
                };
L1104 :;
            }
            {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*mm_decls_lx.symptr).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                mm_support_serror((uint8_t*)"Import stmt out of position?");
            }L1105 :;
            ;
            mm_lex_lex();
            mm_parse_domappedalias(dimport,stimport);
            if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && !!(mlib_eqstring((*mm_decls_lx.symptr).name,(uint8_t*)"as")))) {
                mm_parse_readimportalias(dimport);
            };
        }break;
        case 6:;
        {
            mm_lex_lex();
        }break;
        case 36:;
        {
            goto L1098 ;
        }break;
        case 129:;
        {
            if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)4)) {
                callbackflag = (int64_t)4;
                mm_lex_lex();
            } else {
                goto L1106 ;
;
            };
        }break;
        case 118:;
        {
            mm_parse_readmacrodef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 119:;
        {
            mm_support_serror((uint8_t*)"MODULE/EXPAND");
        }break;
        case 120:;
        {
            mm_support_serror((uint8_t*)"MODULE/OPERATOR");
        }break;
        case 2:;
        {
            mm_support_serror((uint8_t*)"MODULE/DOT");
        }break;
        default: {
            //error:
L1106 :;
;
            mm_lex_ps1((uint8_t*)"symbol");
            mm_support_serror((uint8_t*)"Not allowed at module level");
        }
        } //SW
;
    }L1098 :;
    ;
    return (int64_t)1;
}

static void mm_parse_initparser(void) {
    uint8_t *  tabledataname;
    if (!(!!(mm_decls_nullunit))) {
        mm_decls_nullunit = mm_lib_createunit0((int64_t)2);
    };
    mm_parse_try_level = (int64_t)0;
    mm_decls_currproc = (struct mm_decls_strec *)(0);
    mm_parse_varattribs = (int64_t)0;
    mm_parse_intabledata = (int64_t)0;
    mm_parse_inreadprint = (int64_t)0;
    mm_parse_inparamlist = (int64_t)0;
    mm_parse_inrecordbody = (int64_t)0;
    mm_parse_inimportmodule = (int64_t)0;
    tabledataname = (uint8_t*)"";
    mm_parse_labelseen = (int64_t)0;
    mm_parse_ndollar = (int64_t)0;
}

static void mm_parse_skipsemi(void) {
    L1107 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)6)) {
        mm_lex_lex();
L1108 :;
    }L1109 :;
    ;
}

static struct mm_decls_unitrec * mm_parse_makeblock(struct mm_decls_unitrec * p) {
    return mm_lib_createunit1((int64_t)4,p);
}

static struct mm_decls_unitrec * mm_parse_makestmtblock(struct mm_decls_unitrec * p) {
    return mm_lib_createunit1((int64_t)5,p);
}

static void mm_parse_checkequals(void) {
    if (!((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)36)))) {
        mm_support_serror((uint8_t*)"\"=\" expected");
    };
}

static int64_t mm_parse_getcurrline(void) {
    return (int64_t)(mm_decls_lx.lineno);
}

static int64_t mm_parse_checkbegin(int64_t fbrack) {
    int64_t closesym;
    mm_parse_skipsemi();
    if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)12) && !!(fbrack))) {
        closesym = (int64_t)13;
        mm_lex_lex();
    } else if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)16)) {
        closesym = (int64_t)17;
        mm_lex_lex();
    } else {
        closesym = (int64_t)74;
    };
    return closesym;
}

static void mm_parse_checkbeginend(int64_t closesym,int64_t kwd,int64_t startline) {
    mm_parse_skipsemi();
    if (((closesym == (int64_t)13) || (closesym == (int64_t)17))) {
        mm_parse_checksymbol(closesym);
    } else {
        mm_parse_checkend(closesym,kwd,(int64_t)0,startline);
    };
    mm_lex_lex();
}

static void mm_parse_checkend(int64_t endsym,int64_t endkwd1,int64_t endkwd2,int64_t startline) {
    uint8_t str[100];
    if (((endsym == (int64_t)((uint64_t)(mm_decls_lx.symbol))) && ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13))) {
        return;
    };
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)74)) {
        strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"Bad 'end' "));
        //error:
L1110 :;
;
        if (!!(startline)) {
            msysnewc_m_print_startstr((str + (int64_t)(strlen((int8_t *)(str)))));
            msysnewc_m_print_setfmt((uint8_t*)" (from line #)");
            msysnewc_m_print_i64((startline & (int64_t)16777215),NULL);
            msysnewc_m_print_end();
            ;
        };
        mm_support_serror(str);
    };
    if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)0)) {
        return;
    };
    if (!(((!!(endkwd1) && (endkwd1 == (int64_t)((uint64_t)(mm_decls_lx.subcode)))) || (!!(endkwd2) && (endkwd2 == (int64_t)((uint64_t)(mm_decls_lx.subcode))))))) {
        strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"Mismatched 'end'"));
        goto L1110 ;
;
    };
}

static struct mm_decls_unitrec * mm_parse_readvardef(struct mm_decls_strec * owner,int64_t isglobal,int64_t isstatic,int64_t varid,int64_t k) {
    struct mm_decls_unitrec *  ulist;
    struct mm_decls_unitrec *  ulistx;
    struct mm_decls_unitrec *  p;
    int64_t nvars;
    int64_t m;
    struct mm_decls_strec *  stname;
    ulist = (ulistx = (struct mm_decls_unitrec *)(0));
    if (!!(mm_parse_istypestarter())) {
        m = mm_parse_readtypespec(owner,(int64_t)0);
    } else {
        m = (int64_t)34;
    };
    nvars = (int64_t)0;
    L1111 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
        ++nvars;
        stname = mm_lib_getduplnameptr(owner,mm_decls_lx.symptr,varid);
        mm_lib_storemode((int64_t)1,owner,m,&(*stname).mode);
        (*stname).isglobal = (uint64_t)(isglobal);
        (*stname).isstatic = (uint64_t)(isstatic);
        (*stname).islet = (uint64_t)((k == (int64_t)115));
        mm_lib_adddef(owner,stname);
        if ((varid == (int64_t)9)) {
            mm_lib_addstatic(stname);
        };
        mm_lex_lex();
        if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)9) || (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)36)))) {
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)9)) {
                if ((varid == (int64_t)9)) {
                    mm_support_serror((uint8_t*)"Need = on static not :=");
                };
            } else {
                if ((varid == (int64_t)10)) {
                    mm_support_serror((uint8_t*)"Need 'static' for '='");
                    mm_lib_addstatic(stname);
                };
            };
            mm_lex_lex();
            (*stname).code = mm_parse_readunit();
            (*stname).equals = (uint64_t)((int64_t)1);
            if ((varid == (int64_t)10)) {
                p = mm_lib_createunit2((int64_t)29,mm_lib_createname(stname),(*stname).code);
                (*p).initlet = (int64_t)1;
                mm_lib_addlistunit(&ulist,&ulistx,p);
            };
        } else if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
            if ((k == (int64_t)115)) {
                mm_support_serror((uint8_t*)"let@");
            };
            mm_lex_lex();
            (*stname).at = (uint64_t)((int64_t)1);
            (*stname).equivvar = mm_parse_readunit();
        } else if ((k == (int64_t)115)) {
            mm_support_serror((uint8_t*)"let needs :=/=");
        };
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1113 ;
        };
        mm_lex_lex();
L1112 :;
    }L1113 :;
    ;
    if ((nvars == (int64_t)0)) {
        mm_support_serror((uint8_t*)"No vars declared");
    };
    return ulist;
}

static void mm_parse_readconstdef(struct mm_decls_strec * owner,int64_t isglobal) {
    int64_t nconsts;
    int64_t deft;
    int64_t m;
    struct mm_decls_strec *  stname;
    mm_lex_lex();
    nconsts = (int64_t)0;
    if (!!(mm_parse_istypestarter())) {
        deft = mm_parse_readtypespec(owner,(int64_t)0);
    } else {
        deft = (int64_t)34;
    };
    L1114 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
        stname = mm_lib_getduplnameptr(owner,mm_decls_lx.symptr,(int64_t)8);
        mm_lex_lex();
        mm_parse_checkequals();
        mm_lex_lex();
        (*stname).code = mm_parse_readconstexpr((int64_t)1);
        m = deft;
        mm_lib_storemode((int64_t)2,owner,m,&(*stname).mode);
        ++nconsts;
        (*stname).isglobal = (uint64_t)(isglobal);
        mm_lib_adddef(owner,stname);
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1116 ;
        };
        mm_lex_lex();
L1115 :;
    }L1116 :;
    ;
    if ((nconsts == (int64_t)0)) {
        mm_support_serror((uint8_t*)"No consts declared");
    };
}

static struct mm_decls_unitrec * mm_parse_readlbrack(void) {
    struct mm_decls_unitrec *  ulist;
    struct mm_decls_unitrec *  ulistx;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  r;
    struct mm_decls_unitrec *  plower;
    int64_t oldirp;
    int64_t length;
    mm_lex_lex();
    ulist = (ulistx = (struct mm_decls_unitrec *)(0));
    plower = (struct mm_decls_unitrec *)(0);
    length = (int64_t)0;
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
        mm_lex_lex();
        oldirp = mm_parse_inreadprint;
        mm_parse_inreadprint = (int64_t)1;
        plower = mm_parse_readunit();
        mm_parse_inreadprint = oldirp;
        mm_parse_checksymbol((int64_t)7);
        mm_lex_lex();
    } else if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)41) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)7))) {
        plower = mm_lib_createconstunit((uint64_t)(mm_decls_lx.value),(int64_t)(mm_decls_lx.subcode));
        mm_lex_lex();
        mm_lex_lex();
    } else if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)13))) {
        p = mm_lib_createunit0((int64_t)107);
        (*p).opcode = (int64_t)(mm_decls_lx.subcode);
        mm_lex_lex();
        mm_lex_lex();
        return p;
    } else if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)9))) {
        p = mm_lib_createunit0((int64_t)107);
        (*p).opcode = mm_lib_getoptocode((int64_t)(mm_decls_lx.subcode));
        mm_lex_lex();
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
        return p;
    } else if (!!(mm_parse_istypestarter())) {
        p = mm_parse_readunit();
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
        return p;
    };
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)13)) {
        mm_lex_lex();
        p = mm_lib_createunit0((int64_t)19);
        (*p).b = plower;
        (*p).length = (int64_t)0;
        return p;
    } else {
        p = mm_parse_readxunit();
    };
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)13)) {
        mm_lex_lex();
        return p;
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)5)) {
        length = (int64_t)1;
        if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)13)) {
            mm_lex_lex();
            mm_lex_lex();
            p = mm_lib_createunit1((int64_t)19,p);
            (*p).length = length;
            (*p).b = plower;
            return p;
        };
        ulist = (ulistx = p);
        L1117 :;
        do {
            mm_lex_lex();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13)) {
                goto L1119 ;
            };
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
                mm_support_serror((uint8_t*)",, null expr not allowed");
            };
            mm_lib_addlistunit(&ulist,&ulistx,mm_parse_readxunit());
            ++length;
            mm_parse_skipsemi();
L1118 :;
        } while (!((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5));L1119 :;
        ;
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
        p = mm_lib_createunit1((int64_t)19,ulist);
        (*p).length = length;
        (*p).b = plower;
        return p;
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)19)) {
        mm_lex_lex();
        q = mm_parse_readxunit();
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)19)) {
            mm_lex_lex();
            r = mm_parse_readsunit((int64_t)0);
            mm_parse_checksymbol((int64_t)13);
            mm_lex_lex();
            return mm_lib_createunit3((int64_t)209,p,q,r);
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)13)) {
            mm_lex_lex();
            return mm_lib_createunit3((int64_t)209,p,q,(struct mm_decls_unitrec *)(0));
        };
        mm_lib_addlistunit(&ulist,&ulistx,q);
        mm_parse_checksymbol((int64_t)5);
        if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)19)) {
            L1120 :;
            do {
                mm_lex_lex();
                mm_lib_addlistunit(&ulist,&ulistx,mm_parse_readxunit());
L1121 :;
            } while (!((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5));L1122 :;
            ;
            mm_parse_checksymbol((int64_t)19);
        } else {
            mm_lex_lex();
        };
        mm_lex_lex();
        r = mm_parse_readxunit();
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
        return mm_lib_createunit3((int64_t)229,p,ulist,r);
    } else {
        mm_support_serror((uint8_t*)"(x ...");
    };
    return (struct mm_decls_unitrec *)(0);
}

static void mm_parse_addlistparam(struct mm_decls_strec * * ulist,struct mm_decls_strec * * ulistx,struct mm_decls_strec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextparam = p;
    };
    (*ulistx) = p;
}

static struct mm_decls_unitrec * mm_parse_readcast(void) {
    struct mm_decls_unitrec *  p;
    int64_t opc;
    int64_t t;
    t = mm_parse_readtypespec(mm_decls_currproc,(int64_t)0);
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)13)) {
        p = mm_lib_createunit0((int64_t)106);
        mm_lib_storemode((int64_t)4,mm_decls_currproc,t,(int32_t *)(&(*p).value));
        return p;
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)21)) {
        opc = (int64_t)105;
        mm_lex_lex();
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)2)) {
        if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)111)) {
            mm_lex_lex();
            p = mm_lib_createunit0((int64_t)106);
            mm_lib_storemode((int64_t)4,mm_decls_currproc,t,(int32_t *)(&(*p).value));
            mm_lex_lex();
        } else {
            p = mm_lib_createunit0((int64_t)106);
            mm_lib_storemode((int64_t)4,mm_decls_currproc,t,(int32_t *)(&(*p).value));
        };
        return p;
    } else {
        opc = (int64_t)102;
    };
    mm_parse_checksymbol((int64_t)12);
    mm_lex_lex();
    p = mm_parse_readunit();
    mm_parse_checksymbol((int64_t)13);
    mm_lex_lex();
    p = mm_lib_createunit1(opc,p);
    mm_lib_storemode((int64_t)5,mm_decls_currproc,t,&(*p).newmode);
    return p;
}

static struct mm_decls_unitrec * mm_parse_readopc(void) {
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  r;
    int64_t opc;
    opc = (int64_t)(mm_decls_lx.subcode);
    mm_lex_lex();
    if ((opc==(int64_t)43)) {
        return mm_parse_readterm2();
    }else if ((opc==(int64_t)44)) {
        opc = (int64_t)109;
    }else if ((opc==(int64_t)60) || (opc==(int64_t)61) || (opc==(int64_t)97) || (opc==(int64_t)132) || (opc==(int64_t)65) || (opc==(int64_t)66) || (opc==(int64_t)84) || (opc==(int64_t)83) || (opc==(int64_t)68) || (opc==(int64_t)69) || (opc==(int64_t)74) || (opc==(int64_t)75)) {
        p = mm_parse_readterm2();
        if (((int64_t)((*p).tag) == (int64_t)19)) {
            if (((int64_t)((*p).length) != (int64_t)2)) {
                mm_support_serror((uint8_t*)"Needs (x,y)");
            };
            q = (*p).a;
            r = (*q).nextunit;
            (*q).nextunit = (struct mm_decls_unitrec *)(0);
            return mm_lib_createunit2(opc,q,r);
        } else {
            if (!(((opc == (int64_t)68) || (opc == (int64_t)69) || (opc == (int64_t)84) || (opc == (int64_t)83)))) {
                mm_support_serror((uint8_t*)"Needs 2 opnds");
            };
            return mm_lib_createunit1(opc,p);
        };
    } else {
        if (!!((uint64_t)(mm_tables_binopset[(opc)]))) {
            mm_support_serror((uint8_t*)"Can't be used as unary op");
        };
    };
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)9)) {
        mm_lex_lex();
        opc = mm_lib_getoptocode(opc);
    };
    p = mm_lib_createunit1(opc,(q = mm_parse_readterm2()));
    if (((int64_t)((*q).tag) == (int64_t)19)) {
        mm_support_serror((uint8_t*)"Too many opnds");
    };
    return p;
}

static struct mm_decls_unitrec * mm_parse_readsprint(void) {
    int64_t oldinreadprint;
    int64_t opc;
    int64_t isfprint;
    struct mm_decls_unitrec *  pformat;
    struct mm_decls_unitrec *  pdev;
    struct mm_decls_unitrec *  printlist;
    struct mm_decls_unitrec *  printlistx;
    struct mm_decls_unitrec *  p;
    oldinreadprint = mm_parse_inreadprint;
    mm_parse_inreadprint = (int64_t)1;
    opc = (int64_t)(mm_decls_lx.subcode);
    mm_lex_lex();
    mm_parse_checksymbol((int64_t)12);
    mm_lex_lex();
    if ((opc==(int64_t)238) || (opc==(int64_t)235)) {
        isfprint = (int64_t)1;
    } else {
        isfprint = (int64_t)0;
    };
    printlist = (printlistx = (struct mm_decls_unitrec *)(0));
    pformat = (pdev = (struct mm_decls_unitrec *)(0));
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
        mm_lex_lex();
        pdev = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lex_lex();
        } else {
            goto L1123 ;
;
        };
    };
    if (!!(isfprint)) {
        pformat = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lex_lex();
        } else {
            goto L1123 ;
;
        };
    };
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13)) {
        goto L1123 ;
;
    };
    L1124 :;
    while (1) {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lib_addlistunit(&printlist,&printlistx,mm_lib_createunit0((int64_t)200));
        } else {
            p = mm_parse_readunit();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7)) {
                mm_lex_lex();
                p = mm_lib_createunit2((int64_t)199,p,mm_parse_readunit());
            };
            mm_lib_addlistunit(&printlist,&printlistx,p);
        };
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1125 ;
        };
        mm_lex_lex();
    }L1125 :;
    ;
    mm_parse_checksymbol((int64_t)13);
    //finish:
L1123 :;
;
    mm_lex_lex();
    mm_parse_inreadprint = oldinreadprint;
    if ((((opc == (int64_t)231) || (opc == (int64_t)233)) && (printlist == 0))) {
        mm_support_serror((uint8_t*)"No print items");
    };
    if (!!(isfprint)) {
        if (((int64_t)((*pformat).tag) == (int64_t)2)) {
            mm_support_serror((uint8_t*)"No fmt str");
        };
        return mm_lib_createunit3(opc,pdev,pformat,printlist);
    } else {
        return mm_lib_createunit2(opc,pdev,printlist);
    };
}

static struct mm_decls_unitrec * mm_parse_readsread(void) {
    int64_t oldinreadprint;
    int64_t opc;
    struct mm_decls_unitrec *  pformat;
    struct mm_decls_unitrec *  pdev;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  readlist;
    struct mm_decls_unitrec *  readlistx;
    oldinreadprint = mm_parse_inreadprint;
    mm_parse_inreadprint = (int64_t)1;
    opc = (int64_t)(mm_decls_lx.subcode);
    mm_lex_lex();
    mm_parse_checksymbol((int64_t)12);
    mm_lex_lex();
    readlist = (readlistx = (struct mm_decls_unitrec *)(0));
    pformat = (pdev = (struct mm_decls_unitrec *)(0));
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
        if ((opc == (int64_t)239)) {
            mm_support_serror((uint8_t*)"@ on read");
        };
        mm_lex_lex();
        pdev = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lex_lex();
        } else {
            goto L1126 ;
;
        };
    };
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13)) {
        goto L1126 ;
;
    };
    L1127 :;
    while (1) {
        p = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7)) {
            mm_lex_lex();
            p = mm_lib_createunit2((int64_t)199,p,mm_parse_readunit());
        };
        mm_lib_addlistunit(&readlist,&readlistx,p);
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1128 ;
        };
        mm_lex_lex();
    }L1128 :;
    ;
    mm_parse_checksymbol((int64_t)13);
    //finish:
L1126 :;
;
    mm_lex_lex();
    mm_parse_inreadprint = oldinreadprint;
    if (((opc == (int64_t)239) && (readlist == 0))) {
        mm_support_serror((uint8_t*)"No read items");
    };
    return mm_lib_createunit2(opc,pdev,readlist);
}

static struct mm_decls_unitrec * mm_parse_readcompilervar(void) {
    uint8_t str[100];
    struct oslinux_rsystemtime tm;
    static uint8_t *  monthnames[12] = {
    (uint8_t*)"Jan",
    (uint8_t*)"Feb",
    (uint8_t*)"Mar",
    (uint8_t*)"Apr",
    (uint8_t*)"May",
    (uint8_t*)"Jun",
    (uint8_t*)"Jul",
    (uint8_t*)"Aug",
    (uint8_t*)"Sep",
    (uint8_t*)"Oct",
    (uint8_t*)"Nov",
    (uint8_t*)"Dec"
};
    struct mm_decls_unitrec *  p;
    if (((int64_t)(mm_decls_lx.subcode)==(int64_t)185)) {
        p = mm_lib_createunit0((int64_t)185);
        mm_lex_lex();
        return p;
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)186)) {
        msysnewc_getstrint(((int64_t)(mm_decls_lx.lineno) & (int64_t)16777215),str);
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)187)) {
        p = mm_lib_createunit0((int64_t)187);
        mm_lex_lex();
        return p;
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)188)) {
        p = mm_lib_createunit0((int64_t)188);
        mm_lex_lex();
        return p;
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)189)) {
        strcpy((int8_t *)(str),(int8_t *)((*mm_decls_currproc).name));
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)190)) {
        oslinux_os_getsystime(&tm);
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"#-#-#");
        msysnewc_m_print_i64(tm.day,NULL);
        msysnewc_m_print_str(monthnames[((int64_t)(tm.month))-1],NULL);
        msysnewc_m_print_i64(tm.year,(uint8_t*)"4");
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)191)) {
        oslinux_os_getsystime(&tm);
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"#:#:#");
        msysnewc_m_print_i64(tm.hour,(uint8_t*)"z2");
        msysnewc_m_print_i64(tm.minute,(uint8_t*)"z2");
        msysnewc_m_print_i64(tm.second,(uint8_t*)"z2");
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)192)) {
        strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"Compiler:MM"));
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)194)) {
        mm_lex_lex();
        return mm_lib_createconstunit((uint64_t)(mm_decls_targetbits),(int64_t)4);
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)195)) {
        mm_lex_lex();
        return mm_lib_createconstunit((uint64_t)(mm_decls_targetsize),(int64_t)4);
    }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)196)) {
        strcpy((int8_t *)(str),(int8_t *)(mm_decls_targetnames[(mm_decls_target)-1]));
    } else {
        mm_support_serror_s((uint8_t*)"compiler not impl: #",mm_tables_jtagnames[((int64_t)(mm_decls_lx.subcode))]);
    };
    mm_lex_lex();
    return mm_lib_createstringconstunit(mlib_pcm_copyheapstring(str),(int64_t)-1);
}

static struct mm_decls_unitrec * mm_parse_readcastx(void) {
    int64_t opc;
    int64_t m;
    struct mm_decls_unitrec *  p;
    mm_lex_lex();
    opc = (int64_t)102;
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
        opc = (int64_t)105;
        mm_lex_lex();
    };
    mm_parse_checksymbol((int64_t)12);
    mm_lex_lex();
    m = (int64_t)0;
    p = mm_parse_readunit();
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
        if ((opc == (int64_t)105)) {
            mm_support_serror((uint8_t*)"@ type missing");
        };
        opc = (int64_t)104;
    } else {
        mm_lex_lex();
        m = mm_parse_readtypespec(mm_decls_currproc,(int64_t)0);
    };
    mm_parse_checksymbol((int64_t)13);
    mm_lex_lex();
    p = mm_lib_createunit1(opc,p);
    if (!!(m)) {
        mm_lib_storemode((int64_t)5,mm_decls_currproc,m,&(*p).newmode);
    };
    return p;
}

void mm_parse_checksymbol(int64_t symbol) {
    uint8_t str[100];
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != symbol)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"# expected, not #");
        msysnewc_m_print_str(mm_tables_symbolnames[(symbol)-1],NULL);
        msysnewc_m_print_str(mm_tables_symbolnames[((int64_t)(mm_decls_lx.symbol))-1],NULL);
        msysnewc_m_print_end();
        ;
        mm_support_serror(str);
    };
}

static int64_t mm_parse_readtypespec(struct mm_decls_strec * owner,int64_t typedefx) {
    struct mm_decls_strec *  d;
    int64_t t;
    int64_t fflang;
    struct mm_decls_unitrec *  dim;
    struct mm_decls_unitrec *  length;
    struct mm_decls_unitrec *  dims[30];
    int64_t ndims;
    int64_t i;
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)14)) {
        //arraybounds:
L1129 :;
;
        mm_lex_lex();
        ndims = (int64_t)0;
        mm_parse_inreadprint = (int64_t)1;
        L1130 :;
        while (1) {
            length = (struct mm_decls_unitrec *)(0);
            if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)15) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5))) {
                dim = (struct mm_decls_unitrec *)(0);
            } else {
                dim = mm_parse_readunit();
                if (((int64_t)(mm_decls_lx.symbol)==(int64_t)15) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)5)) {
                }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)7)) {
                    mm_lex_lex();
                    if (!((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)15)))) {
                        length = mm_parse_readunit();
                        dim = mm_lib_createunit2((int64_t)28,dim,length);
                    } else {
                        dim = mm_lib_createunit1((int64_t)28,dim);
                    };
                };
            };
            if ((ndims >= (int64_t)30)) {
                mm_support_serror((uint8_t*)"Too many array dims");
            };
            dims[(++ndims)-1] = dim;
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
                goto L1131 ;
            };
            mm_lex_lex();
        }L1131 :;
        ;
        mm_parse_inreadprint = (int64_t)0;
        mm_parse_checksymbol((int64_t)15);
        mm_lex_lex();
        t = mm_parse_readtypespec(owner,(int64_t)0);
        L1132 :;
        for (i=ndims;i>=(int64_t)1;i-=(int64_t)1) {
L1133 :;
            t = mm_lib_createarraymode(owner,t,dims[(i)-1],((i == (int64_t)1)?typedefx:(int64_t)0));
L1134 :;
        }L1135 :;
        ;
        return t;
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)61)) {
        t = (int64_t)(mm_decls_lx.subcode);
        mm_lex_lex();
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)50)) {
        d = mm_decls_lx.symptr;
        mm_lex_lex();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)2)) {
            mm_lex_lex();
            mm_parse_checksymbol((int64_t)50);
            t = mm_lib_newusertypex(d,mm_decls_lx.symptr);
            mm_lex_lex();
        } else {
            t = mm_lib_newusertypex(d,(struct mm_decls_strec *)(0));
        };
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)123)) {
        mm_lex_lex();
        t = mm_parse_readenumtype(owner,typedefx,(int64_t)0);
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)12)) {
        t = mm_parse_readenumtype(owner,typedefx,(int64_t)0);
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)103) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)104)) {
        mm_support_serror((uint8_t*)"Use 'record name =' syntax");
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)105)) {
        mm_support_serror((uint8_t*)"Top-level union not allowed");
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)113)) {
        fflang = (int64_t)0;
        //retry:
L1136 :;
;
        mm_lex_lex();
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)100) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)101)) {
            t = mm_parse_readrefproc(owner,typedefx,fflang);
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)129)) {
            fflang = (int64_t)(mm_decls_lx.subcode);
            goto L1136 ;
;
        } else {
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)61)) {
                if (((int64_t)(mm_decls_lx.subcode)==(int64_t)13)) {
                    t = mm_tables_trefchar;
                } else {
                    goto L1137 ;
;
                };
                mm_lex_lex();
            } else {
                //readtarget:
L1137 :;
;
                t = mm_parse_readtypespec(owner,(int64_t)0);
                t = mm_lib_createrefmode(owner,t,typedefx);
            };
        };
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)66)) {
        mm_lex_lex();
        t = mm_tables_trefchar;
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)63)) {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)12);
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)50);
        mm_support_serror((uint8_t*)"TYPEOF/NO 'NAME' MODULE");
        if (!!(d)) {
            t = (int64_t)((*d).mode);
        } else {
            mm_support_serror((uint8_t*)"Typeof?");
        };
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)116)) {
        t = mm_parse_readslicetype(owner,typedefx);
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)117)) {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)14);
        goto L1129 ;
;
    } else {
        mm_support_serror((uint8_t*)"Bad type starter");
    };
    return t;
}

static int64_t mm_parse_readslicetype(struct mm_decls_strec * owner,int64_t typedefx) {
    struct mm_decls_unitrec *  plower;
    int64_t t;
    mm_lex_lex();
    mm_parse_checksymbol((int64_t)14);
    mm_lex_lex();
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)15)) {
        mm_parse_inreadprint = (int64_t)1;
        plower = mm_parse_readunit();
        mm_parse_inreadprint = (int64_t)0;
        mm_parse_checksymbol((int64_t)7);
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)15);
    } else {
        plower = (struct mm_decls_unitrec *)(0);
    };
    mm_lex_lex();
    t = mm_parse_readtypespec(owner,typedefx);
    return mm_lib_createslicemode(owner,t,plower,typedefx);
}

static struct mm_decls_unitrec * mm_parse_readslist(int64_t iscall,int64_t donulls) {
    struct mm_decls_unitrec *  ulist;
    struct mm_decls_unitrec *  ulistx;
    int64_t oldinparamlist;
    struct mm_decls_unitrec *  pp;
    ulist = (ulistx = (struct mm_decls_unitrec *)(0));
    mm_parse_skipsemi();
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13)) {
        return ulist;
    };
    oldinparamlist = mm_parse_inparamlist;
    mm_parse_inparamlist = iscall;
    L1138 :;
    while (1) {
        mm_parse_skipsemi();
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)5)) {
            if (!!(donulls)) {
                mm_lib_addlistunit(&ulist,&ulistx,mm_lib_createunit0((int64_t)2));
            } else {
                mm_support_serror((uint8_t*)"null comma expr not allowed");
            };
            mm_lex_lex();
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)13)) {
            if (!!(donulls)) {
                mm_lib_addlistunit(&ulist,&ulistx,mm_decls_nullunit);
            };
            goto L1139 ;
        } else {
            mm_lib_addlistunit(&ulist,&ulistx,(pp = mm_parse_readunit()));
            ++mm_decls_nallparams;
            if (((int64_t)((*pp).tag)==(int64_t)3) || ((int64_t)((*pp).tag)==(int64_t)1)) {
                ++mm_decls_nsimple;
            };
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
                mm_lex_lex();
                if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13)) {
                    goto L1139 ;
                };
            } else {
                mm_parse_skipsemi();
                if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13)) {
                    goto L1139 ;
                };
                mm_support_serror((uint8_t*)"SLIST?");
            };
        };
    }L1139 :;
    ;
    mm_parse_inparamlist = oldinparamlist;
    return ulist;
}

static struct mm_decls_unitrec * mm_parse_readindex(struct mm_decls_unitrec * p,int64_t dot) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  plower;
    struct mm_decls_unitrec *  pupper;
    mm_lex_lex();
    if (!(!!(dot))) {
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)15)) {
            //fullslice:
L1140 :;
;
            mm_lex_lex();
            plower = mm_lib_createunit1((int64_t)133,mm_lib_duplunit(p,(int64_t)0));
            pupper = mm_lib_createunit1((int64_t)134,mm_lib_duplunit(p,(int64_t)0));
            p = mm_lib_createunit2((int64_t)89,p,mm_lib_createunit2((int64_t)20,plower,pupper));
            return p;
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)29) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)7)) {
            mm_lex_lex();
            mm_parse_checksymbol((int64_t)15);
            goto L1140 ;
;
        };
    };
    L1141 :;
    while (1) {
        if ((mm_parse_ndollar >= (int64_t)10)) {
            mm_support_serror((uint8_t*)"Too many nested a[$]");
        };
        mm_parse_dollarstack[(++mm_parse_ndollar)-1] = p;
        q = mm_parse_readunit();
        --mm_parse_ndollar;
        if (((int64_t)((*q).tag) == (int64_t)20)) {
            p = mm_lib_createunit2((!!(dot)?(int64_t)91:(int64_t)89),p,q);
        } else {
            p = mm_lib_createunit2((!!(dot)?(int64_t)90:(int64_t)88),p,q);
        };
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1142 ;
        };
        mm_lex_lex();
    }L1142 :;
    ;
    mm_parse_checksymbol((int64_t)15);
    mm_lex_lex();
    return p;
}

static struct mm_decls_unitrec * mm_parse_readdotsuffix(struct mm_decls_unitrec * p) {
    L1143 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)2)) {
        mm_lex_lex();
        switch ((int64_t)(mm_decls_lx.symbol)) {
        case 14:;
        {
            p = mm_parse_readindex(p,(int64_t)1);
        }break;
        case 50:;
        {
            p = mm_lib_createunit2((int64_t)95,p,mm_lib_createname(mm_decls_lx.symptr));
            mm_lex_lex();
        }break;
        case 32:;
        case 33:;
        {
            p = mm_lib_createunit1((int64_t)(mm_decls_lx.subcode),p);
            mm_lex_lex();
        }break;
        case 34:;
        {
            p = mm_lib_createunit1((int64_t)142,p);
            (*p).opcode = (int64_t)(mm_decls_lx.subcode);
            mm_lex_lex();
        }break;
        case 12:;
        {
            mm_lex_lex();
            p = mm_lib_createunit2((int64_t)96,p,mm_parse_readunit());
            mm_parse_checksymbol((int64_t)13);
            mm_lex_lex();
        }break;
        case 111:;
        {
            if (((int64_t)((*p).tag)==(int64_t)106)) {
            } else {
                p = mm_lib_createunit1((int64_t)140,p);
            };
            mm_lex_lex();
        }break;
        default: {
            mm_support_serror((uint8_t*)"Unknown dot suffix");
        }
        } //SW
;
L1144 :;
    }L1145 :;
    ;
    return p;
}

int64_t mm_parse_isconstexpr(struct mm_decls_unitrec * p) {
    return ((int64_t)((*p).tag) == (int64_t)1);
}

static struct mm_decls_unitrec * mm_parse_readkeyindex(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  r;
    mm_lex_lex();
    q = mm_parse_readunit();
    r = (struct mm_decls_unitrec *)(0);
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
        mm_lex_lex();
        r = mm_parse_readunit();
    };
    p = mm_lib_createunit3((int64_t)94,p,q,r);
    mm_parse_checksymbol((int64_t)17);
    mm_lex_lex();
    return p;
}

static struct mm_decls_unitrec * mm_parse_readconstexpr(int64_t needconst) {
    return mm_parse_readunit();
}

static int64_t mm_parse_readconstint(void) {
    int64_t x;
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)41)) {
        x = mm_decls_lx.value;
        mm_lex_lex();
        return x;
    } else if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)44))) {
        mm_lex_lex();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)41)) {
            x = mm_decls_lx.value;
            mm_lex_lex();
            return -(x);
        };
    };
    mm_support_serror((uint8_t*)"Can't do complex expr");
    return (int64_t)0;
}

static void mm_parse_readprocdef(struct mm_decls_strec * procowner,int64_t isglobal,int64_t fflang) {
    int64_t kwd;
    int64_t startline;
    int64_t closesym;
    struct mm_decls_strec *  stproc;
    struct mm_decls_strec *  stname;
    int64_t i;
    kwd = (int64_t)(mm_decls_lx.symbol);
    stproc = mm_parse_readprocdecl(procowner,isglobal,fflang);
    mm_parse_checkequals();
    mm_lex_lex();
    startline = mm_parse_getcurrline();
    closesym = mm_parse_checkbegin((int64_t)0);
    mm_parse_pushproc(stproc);
    mm_lib_nextavindex = (int64_t)0;
    ++mm_decls_nprocs;
    if (!!(mm_parse_dretvar)) {
        stname = mm_lib_getduplnameptr(stproc,mm_parse_dretvar,(int64_t)10);
        mm_lib_storemode((int64_t)1,stproc,(int64_t)((*stproc).mode),&(*stname).mode);
        mm_lib_adddef(stproc,stname);
    };
    mm_lib_addtoproclist(stproc);
    (*stproc).code = mm_parse_readsunit((int64_t)0);
    mm_parse_checkbeginend(closesym,kwd,startline);
    (*stproc).equals = (uint64_t)((int64_t)1);
    if (!!(mm_decls_ndocstrings)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*mm_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)":",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        L1146 :;
        for (i=(int64_t)1;i<=mm_decls_ndocstrings;i+=(int64_t)1) {
L1147 :;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(mm_decls_docstrings[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mlib_pcm_free((void *)(mm_decls_docstrings[(i)-1]),(int64_t)(strlen((int8_t *)((mm_decls_docstrings[(i)-1] + (int64_t)1)))));
L1148 :;
        }L1149 :;
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_decls_ndocstrings = (int64_t)0;
    };
    mm_parse_popproc();
}

struct mm_decls_strec * mm_parse_readprocdecl(struct mm_decls_strec * procowner,int64_t isglobal,int64_t fflang) {
    int64_t kwd;
    int64_t varparams;
    int64_t try_level;
    int64_t prettype;
    int64_t nparams;
    int64_t nretvalues;
    int64_t retmodes[4];
    uint8_t *  metadata;
    uint8_t *  truename;
    struct mm_decls_strec *  pequiv;
    struct mm_decls_strec *  stproc;
    struct mm_decls_strec *  owner;
    struct mm_decls_strec *  paramlist;
    struct mm_decls_strec *  nameptr;
    int64_t i;
    kwd = (int64_t)(mm_decls_lx.symbol);
    pequiv = (struct mm_decls_strec *)(0);
    metadata = (uint8_t*)"";
    truename = (uint8_t *)(0);
    varparams = (int64_t)0;
    try_level = (int64_t)0;
    mm_lex_lex();
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)46)) {
        truename = mlib_pcm_copyheapstring(mm_decls_lx.svalue);
        mlib_convlcstring(mm_decls_lx.svalue);
        mm_decls_lx.symptr = mm_lex_addnamestr(mm_decls_lx.svalue);
    } else {
        mm_parse_checksymbol((int64_t)50);
    };
    nameptr = mm_decls_lx.symptr;
    stproc = mm_lib_getduplnameptr(procowner,nameptr,(!!(mm_parse_insidedllimport)?(int64_t)6:(int64_t)5));
    if (!!(mm_parse_insidedllimport)) {
        isglobal = (int64_t)1;
    };
    if (!!(truename)) {
        (*stproc).truename = truename;
    };
    if ((((uint64_t)((*(*stproc).name)) == '$') && !!(mlib_eqstring((*stproc).name,(uint8_t*)"$init")))) {
        mm_decls_moduletable[((int64_t)((*mm_decls_stmodule).moduleno))].stinitproc = stproc;
    };
    mm_lib_adddef(procowner,stproc);
    if (((int64_t)((uint64_t)((*stproc).nameid)) == (int64_t)6)) {
        (*stproc).imported = (uint64_t)((int64_t)1);
        if (!!(mlib_eqstring((*procowner).name,(uint8_t*)"cstd"))) {
            (*stproc).imported = (uint64_t)((int64_t)2);
        };
    };
    owner = stproc;
    mm_parse_pushproc(stproc);
    mm_lex_lex();
    paramlist = (struct mm_decls_strec *)(0);
    prettype = (int64_t)0;
    nparams = (int64_t)0;
    nretvalues = (int64_t)0;
    if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)38))) {
        if (((int64_t)((uint64_t)((*stproc).nameid)) == (int64_t)6)) {
            mm_support_serror((uint8_t*)"Metadata on dllproc");
        };
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)46);
        (*stproc).metadata = mm_decls_lx.svalue;
        mm_lex_lex();
        if (!((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)40) || ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)41))))) {
            mm_support_serror((uint8_t*)"\">\" expected");
        };
        if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)41))) {
            mm_decls_lx.subcode = (uint64_t)((int64_t)36);
        } else {
            mm_lex_lex();
        };
    };
    nretvalues = (int64_t)0;
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)12)) {
        mm_lex_lex();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)13)) {
            paramlist = mm_parse_readparams(procowner,stproc,fflang,&varparams,&nparams);
            mm_parse_checksymbol((int64_t)13);
        };
        mm_lex_lex();
        if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)11))) {
            mm_lex_lex();
            nretvalues = mm_parse_readreturntype(owner,&retmodes);
        } else if ((!!((uint64_t)(mm_decls_typestarterset[((int64_t)(mm_decls_lx.symbol))])) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50))) {
            nretvalues = mm_parse_readreturntype(owner,&retmodes);
        };
    } else if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)11))) {
        mm_lex_lex();
        nretvalues = mm_parse_readreturntype(owner,&retmodes);
    };
    if (!!(nretvalues)) {
        prettype = retmodes[((int64_t)1)-1];
    };
    mm_parse_dretvar = (struct mm_decls_strec *)(0);
    if ((nretvalues == (int64_t)1)) {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
            mm_parse_dretvar = mm_decls_lx.symptr;
            mm_lex_lex();
        };
    };
    if (!((!!(nretvalues) || (kwd != (int64_t)101)))) {
        if (((!!(paramlist) && ((int64_t)((*paramlist).mode) == (int64_t)33)) || (paramlist == 0))) {
            retmodes[((int64_t)1)-1] = (int64_t)33;
            nretvalues = (int64_t)1;
        } else {
            mm_support_serror((uint8_t*)"Function needs ret type");
        };
    };
    if ((!!(nretvalues) && (kwd != (int64_t)101))) {
        mm_support_serror((uint8_t*)"Proc can't return value");
    };
    (*stproc).paramlist = paramlist;
    (*stproc).nretvalues = (uint64_t)(nretvalues);
    L1150 :;
    for (i=(int64_t)1;i<=nretvalues;i+=(int64_t)1) {
L1151 :;
        mm_lib_storemode((int64_t)6,procowner,retmodes[(i)-1],&(*stproc).modelist[(i)-1]);
L1152 :;
    }L1153 :;
    ;
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)50);
        mm_lex_lex();
        (*stproc).at = (uint64_t)((int64_t)1);
    };
    (*stproc).code = (struct mm_decls_unitrec *)(0);
    if ((fflang==(int64_t)2) || (fflang==(int64_t)1) || (fflang==(int64_t)3)) {
    } else {
        if (((int64_t)((*procowner).nameid)==(int64_t)2)) {
        }else if (((int64_t)((*procowner).nameid)==(int64_t)3)) {
            mm_support_serror((uint8_t*)"Need FF specifier");
        };
    };
    (*stproc).isglobal = (uint64_t)(isglobal);
    (*stproc).varparams = (uint64_t)(varparams);
    (*stproc).fflang = (uint64_t)(fflang);
    if ((((procowner == mm_decls_stmodule) && (((int64_t)((uint64_t)((*stproc).namelen)) == (int64_t)5) && !!(mlib_eqstring((*stproc).name,(uint8_t*)"start")))) || (((int64_t)((uint64_t)((*stproc).namelen)) == (int64_t)4) && !!(mlib_eqstring((*stproc).name,(uint8_t*)"main"))))) {
        (*stproc).isglobal = (uint64_t)((int64_t)1);
    };
    mm_parse_popproc();
    return stproc;
}

static struct mm_decls_strec * mm_parse_readparams(struct mm_decls_strec * procowner,struct mm_decls_strec * owner,int64_t fflang,int64_t * varparams,int64_t * nparams) {
    struct mm_decls_strec *  stlist;
    struct mm_decls_strec *  stlistx;
    struct mm_decls_strec *  stname;
    int64_t parammode;
    int64_t pmode;
    int64_t m;
    int64_t pmprefix;
    stlist = (stlistx = (struct mm_decls_strec *)(0));
    pmode = (int64_t)0;
    (*nparams) = (int64_t)0;
    pmprefix = (int64_t)0;
    parammode = (int64_t)0;
    if ((fflang == (int64_t)0)) {
        fflang = (int64_t)3;
    };
    if (((mm_decls_lx.symbol == (int64_t)65) || (mm_decls_lx.symbol == (int64_t)24))) {
        parammode = (int64_t)2;
        pmprefix = (int64_t)1;
        mm_lex_lex();
    } else if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)55))) {
        parammode = (int64_t)1;
        pmprefix = (int64_t)1;
        mm_lex_lex();
    };
    if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && ((mm_decls_nextlx.symbol == (int64_t)5) || (mm_decls_nextlx.symbol == (int64_t)13)))) {
        pmode = mm_parse_readtypespec(procowner,(int64_t)0);
        //typesonly:
L1154 :;
;
        return mm_parse_readparams_types(procowner,owner,fflang,varparams,nparams,pmode,parammode);
    } else {
        pmode = mm_parse_readtypespec(procowner,(int64_t)0);
        if (((mm_decls_lx.symbol == (int64_t)5) || (mm_decls_lx.symbol == (int64_t)13))) {
            goto L1154 ;
;
        };
    };
    if (!!(pmprefix)) {
        mm_support_serror((uint8_t*)"&/out must be applied to param name");
    };
    goto L1155 ;
;
    L1156 :;
    while (1) {
        if (!!(mm_parse_istypestarter())) {
            pmode = mm_parse_readtypespec(procowner,(int64_t)0);
        };
        //gotmode:
L1155 :;
;
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)32)) {
            if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) != (int64_t)55)) {
                mm_support_serror((uint8_t*)"params/op?");
            };
            parammode = (int64_t)1;
            mm_lex_lex();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7)) {
                mm_lex_lex();
            };
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)65) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)24)) {
            parammode = (int64_t)2;
            mm_lex_lex();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7)) {
                mm_lex_lex();
            };
        };
        mm_parse_checksymbol((int64_t)50);
        ++(*nparams);
        stname = mm_lib_getduplnameptr(owner,mm_decls_lx.symptr,(int64_t)11);
        mm_lib_adddef(owner,stname);
        mm_lex_lex();
        if ((parammode == (int64_t)2)) {
            m = mm_lib_createrefmode(procowner,pmode,(int64_t)0);
        } else {
            m = pmode;
        };
        mm_lib_storemode((int64_t)7,owner,m,&(*stname).mode);
        (*stname).parammode = (uint64_t)(parammode);
        mm_parse_addlistparam(&stlist,&stlistx,stname);
        parammode = (int64_t)0;
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)9)) {
            mm_lex_lex();
            //dodefvalue:
L1158 :;
;
            (*stname).code = mm_parse_readunit();
            (*stname).equals = (uint64_t)((int64_t)1);
            (*stname).optional = (uint64_t)((int64_t)1);
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)32)) {
            if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)36)) {
                mm_lex_lex();
                goto L1158 ;
;
            };
        };
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)5)) {
            mm_lex_lex();
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)13)) {
            goto L1157 ;
        } else {
            mm_support_serror((uint8_t*)"nameparams1");
        };
    }L1157 :;
    ;
    return stlist;
}

static struct mm_decls_strec * mm_parse_readparams_types(struct mm_decls_strec * procowner,struct mm_decls_strec * owner,int64_t fflang,int64_t * varparams,int64_t * nparams,int64_t pmode,int64_t parammode) {
    struct mm_decls_strec *  stlist;
    struct mm_decls_strec *  stlistx;
    struct mm_decls_strec *  stname;
    int64_t m;
    uint8_t str[30];
    stlist = (stlistx = (struct mm_decls_strec *)(0));
    stname = (struct mm_decls_strec *)(0);
    (*nparams) = (int64_t)0;
    goto L1159 ;
;
    L1160 :;
    while (1) {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)30)) {
            (*varparams) = (int64_t)1;
            mm_lex_lex();
            mm_parse_checksymbol((int64_t)13);
            goto L1161 ;
        };
        pmode = mm_parse_readtypespec(procowner,(int64_t)0);
        //gotmode:
L1159 :;
;
        ++(*nparams);
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((!!(mm_decls_ctarget)?(uint8_t*)"_":(uint8_t*)"$"),NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64((*nparams),NULL);
        msysnewc_m_print_end();
        ;
        stname = mm_lib_getduplnameptr(owner,mm_lex_addnamestr(str),(int64_t)11);
        mm_lib_adddef(owner,stname);
        if ((parammode == (int64_t)2)) {
            m = mm_lib_createrefmode(procowner,pmode,(int64_t)0);
        } else {
            m = pmode;
        };
        mm_lib_storemode((int64_t)8,owner,m,&(*stname).mode);
        (*stname).parammode = (uint64_t)(parammode);
        mm_parse_addlistparam(&stlist,&stlistx,stname);
        parammode = (int64_t)0;
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)9) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)32)) {
            if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) != (int64_t)36))) {
                mm_support_serror((uint8_t*)"rdparams");
            };
            mm_lex_lex();
            (*stname).code = mm_parse_readunit();
            (*stname).equals = (uint64_t)((int64_t)1);
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)50)) {
            mm_support_serror((uint8_t*)"Can't mixed unnamed/named params");
        };
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)5)) {
            mm_lex_lex();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)24)) {
                parammode = (int64_t)2;
                mm_lex_lex();
            };
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)13)) {
            goto L1161 ;
        } else {
            mm_support_serror((uint8_t*)"typeparams3");
        };
    }L1161 :;
    ;
    return stlist;
}

static struct mm_decls_unitrec * mm_parse_readcondsuffix(struct mm_decls_unitrec * p) {
    switch ((int64_t)(mm_decls_lx.symbol)) {
    case 79:;
    {
        mm_lex_lex();
        return mm_lib_createunit2((int64_t)209,mm_parse_readunit(),mm_lib_createunit1((int64_t)4,p));
    }break;
    case 75:;
    {
        mm_lex_lex();
        return mm_lib_createunit2((int64_t)209,mm_lib_createunit1((int64_t)15,mm_parse_readunit()),mm_lib_createunit1((int64_t)4,p));
    }break;
    default: {
        return p;
    }
    } //SW
;
}

static struct mm_decls_unitrec * mm_parse_readif(void) {
    int64_t line;
    int64_t kwd;
    int64_t lineno;
    struct mm_decls_unitrec *  pthen;
    struct mm_decls_unitrec *  pcond;
    struct mm_decls_unitrec *  plist;
    struct mm_decls_unitrec *  plistx;
    struct mm_decls_unitrec *  pelse;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  pelsif;
    line = (int64_t)(mm_decls_lx.lineno);
    kwd = (int64_t)(mm_decls_lx.symbol);
    mm_lex_lex();
    pcond = mm_parse_readsunit((int64_t)0);
    mm_parse_skipsemi();
    mm_parse_checksymbol((int64_t)68);
    mm_lex_lex();
    pthen = mm_parse_readsunit((int64_t)0);
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)69)) {
        lineno = (int64_t)(mm_decls_lx.lineno);
        plist = (plistx = mm_lib_createunit2((int64_t)198,pcond,pthen));
        L1162 :;
        while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)69)) {
            lineno = (int64_t)(mm_decls_lx.lineno);
            mm_lex_lex();
            pcond = mm_parse_readunit();
            mm_parse_checksymbol((int64_t)68);
            mm_lex_lex();
            pthen = mm_parse_readsunit((int64_t)0);
            pelsif = mm_lib_createunit2((int64_t)198,pcond,pthen);
            (*pelsif).lineno = lineno;
            mm_lib_addlistunit(&plist,&plistx,pelsif);
L1163 :;
        }L1164 :;
        ;
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)70)) {
            mm_lex_lex();
            pelse = mm_parse_readsunit((int64_t)0);
            mm_parse_checkend((int64_t)74,kwd,(int64_t)0,(int64_t)0);
            mm_lex_lex();
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)71) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)72)) {
            mm_decls_lx.symbol = (uint64_t)(kwd);
            pelse = mm_parse_makeblock(mm_parse_readswitchcase());
        } else {
            pelse = (struct mm_decls_unitrec *)(0);
            mm_parse_checkend((int64_t)74,kwd,(int64_t)0,(int64_t)0);
            mm_lex_lex();
        };
        p = mm_lib_createunit2((int64_t)210,plist,pelse);
        (*p).lineno = line;
        return p;
    };
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)70)) {
        mm_lex_lex();
        pelse = mm_parse_readsunit((int64_t)0);
        mm_parse_checkend((int64_t)74,kwd,(int64_t)0,(int64_t)0);
        mm_lex_lex();
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)71) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)72)) {
        mm_decls_lx.symbol = (uint64_t)(kwd);
        pelse = mm_parse_makeblock(mm_parse_readswitchcase());
    } else {
        pelse = (struct mm_decls_unitrec *)(0);
        mm_parse_checkend((int64_t)74,kwd,(int64_t)0,(int64_t)0);
        mm_lex_lex();
    };
    p = mm_lib_createunit3((int64_t)209,pcond,pthen,pelse);
    (*p).lineno = line;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readgoto(int64_t gototag) {
    struct mm_decls_unitrec *  p;
    if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)1)) {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)83);
    };
    mm_lex_lex();
    if ((((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)18)) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)14)) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) != (int64_t)2))) {
        p = mm_lib_createname(mm_decls_lx.symptr);
        mm_lex_lex();
    } else {
        mm_support_serror((uint8_t*)"GOTO LABEL EXPR");
    };
    return mm_parse_readcondsuffix(mm_lib_createunit1(gototag,p));
}

static struct mm_decls_unitrec * mm_parse_readunless(void) {
    int64_t line;
    struct mm_decls_unitrec *  pcond;
    struct mm_decls_unitrec *  pthen;
    struct mm_decls_unitrec *  pelse;
    struct mm_decls_unitrec *  p;
    line = (int64_t)(mm_decls_lx.lineno);
    mm_lex_lex();
    pcond = mm_parse_readsunit((int64_t)0);
    mm_parse_checksymbol((int64_t)68);
    mm_lex_lex();
    pthen = mm_parse_readsunit((int64_t)0);
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)70)) {
        mm_lex_lex();
        pelse = mm_parse_readsunit((int64_t)0);
    } else {
        pelse = (struct mm_decls_unitrec *)(0);
    };
    mm_parse_checkend((int64_t)74,(int64_t)75,(int64_t)0,(int64_t)0);
    mm_lex_lex();
    p = mm_lib_createunit3((int64_t)209,mm_lib_createunit1((int64_t)15,pcond),pthen,pelse);
    (*p).lineno = line;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readswitchcase(void) {
    int64_t line;
    int64_t kwd;
    int64_t opc;
    int64_t lineno;
    int64_t rangeused;
    int64_t nwhen;
    struct mm_decls_unitrec *  pexpr;
    struct mm_decls_unitrec *  pwhenlist;
    struct mm_decls_unitrec *  pwhenlistx;
    struct mm_decls_unitrec *  pwhen;
    struct mm_decls_unitrec *  pwhenx;
    struct mm_decls_unitrec *  pelse;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  pthen;
    struct mm_decls_unitrec *  pwhenthen;
    line = (int64_t)(mm_decls_lx.lineno);
    kwd = (int64_t)(mm_decls_lx.symbol);
    opc = (int64_t)(mm_decls_lx.subcode);
    mm_lex_lex();
    mm_parse_skipsemi();
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)79)) {
        if ((kwd == (int64_t)93)) {
            mm_support_serror((uint8_t*)"switch expr missing");
        };
        pexpr = (struct mm_decls_unitrec *)(0);
    } else {
        pexpr = mm_parse_readsunit((int64_t)0);
    };
    pwhenlist = (pwhenlistx = (struct mm_decls_unitrec *)(0));
    rangeused = (int64_t)0;
    nwhen = (int64_t)0;
    mm_parse_skipsemi();
    L1165 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)79)) {
        lineno = (int64_t)(mm_decls_lx.lineno);
        mm_lex_lex();
        pwhen = (pwhenx = (struct mm_decls_unitrec *)(0));
        L1168 :;
        while (1) {
            p = mm_parse_readunit();
            ++nwhen;
            (*p).lineno = lineno;
            if (((int64_t)((*p).tag) == (int64_t)20)) {
                rangeused = (int64_t)1;
            };
            mm_lib_addlistunit(&pwhen,&pwhenx,p);
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
                goto L1169 ;
            };
            mm_lex_lex();
        }L1169 :;
        ;
        mm_parse_checksymbol((int64_t)68);
        mm_lex_lex();
        pthen = mm_parse_readsunit((int64_t)0);
        pwhenthen = mm_lib_createunit2((int64_t)197,pwhen,pthen);
        (*pwhenthen).lineno = lineno;
        mm_lib_addlistunit(&pwhenlist,&pwhenlistx,pwhenthen);
L1166 :;
    }L1167 :;
    ;
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)70)) {
        mm_lex_lex();
        pelse = mm_parse_readsunit((int64_t)0);
        mm_parse_checkend((int64_t)74,kwd,(int64_t)0,(int64_t)0);
        mm_lex_lex();
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)69)) {
        mm_decls_lx.symbol = (uint64_t)(kwd);
        pelse = mm_parse_makeblock(mm_parse_readif());
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)71) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)72)) {
        mm_decls_lx.symbol = (uint64_t)(kwd);
        pelse = mm_parse_makeblock(mm_parse_readswitchcase());
    } else {
        pelse = (struct mm_decls_unitrec *)(0);
        mm_parse_checkend((int64_t)74,kwd,(int64_t)0,(int64_t)0);
        mm_lex_lex();
    };
    p = mm_lib_createunit3(opc,pexpr,pwhenlist,pelse);
    (*p).lineno = line;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readstop(void) {
    struct mm_decls_unitrec *  p;
    mm_lex_lex();
    if (!!((uint64_t)(mm_decls_exprstarterset[((int64_t)(mm_decls_lx.symbol))]))) {
        p = mm_lib_createunit1((int64_t)243,mm_parse_readunit());
    } else {
        p = mm_lib_createunit0((int64_t)243);
    };
    return mm_parse_readcondsuffix(p);
}

static struct mm_decls_unitrec * mm_parse_readreturn(void) {
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    mm_lex_lex();
    if (!!((uint64_t)(mm_decls_exprstarterset[((int64_t)(mm_decls_lx.symbol))]))) {
        q = mm_parse_readunit();
        p = mm_lib_createunit1((int64_t)203,q);
        (*p).length = (int64_t)1;
    } else {
        p = mm_lib_createunit0((int64_t)203);
        (*p).length = (int64_t)0;
    };
    return mm_parse_readcondsuffix(p);
}

static struct mm_decls_unitrec * mm_parse_readdo(void) {
    struct mm_decls_unitrec *  p;
    int64_t line;
    line = (int64_t)(mm_decls_lx.lineno);
    mm_lex_lex();
    p = mm_parse_readsunit((int64_t)0);
    mm_parse_checkend((int64_t)74,(int64_t)85,(int64_t)0,(int64_t)0);
    mm_lex_lex();
    p = mm_lib_createunit1((int64_t)223,p);
    (*p).lineno = line;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readto(void) {
    int64_t line;
    int64_t id;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  pcount;
    struct mm_decls_unitrec *  pbody;
    line = (int64_t)(mm_decls_lx.lineno);
    mm_lex_lex();
    pcount = mm_parse_readunit();
    mm_parse_checksymbol((int64_t)85);
    mm_lex_lex();
    pbody = mm_parse_readsunit((int64_t)0);
    mm_parse_checkend((int64_t)74,(int64_t)83,(int64_t)85,(int64_t)0);
    mm_lex_lex();
    id = (int64_t)10;
    if (((int64_t)((uint64_t)((*mm_decls_currproc).nameid)) != (int64_t)5)) {
        id = (int64_t)9;
    };
    p = mm_lib_createunit3((int64_t)208,pcount,pbody,mm_lib_createname(mm_lib_getavname(mm_decls_currproc,id)));
    (*p).lineno = line;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readwhile(void) {
    struct mm_decls_unitrec *  pcond;
    struct mm_decls_unitrec *  pbody;
    struct mm_decls_unitrec *  p;
    mm_lex_lex();
    pcond = mm_parse_readsunit((int64_t)1);
    mm_parse_checksymbol((int64_t)85);
    mm_lex_lex();
    pbody = mm_parse_readsunit((int64_t)0);
    mm_parse_checkend((int64_t)74,(int64_t)86,(int64_t)85,(int64_t)0);
    mm_lex_lex();
    p = mm_lib_createunit2((int64_t)214,pcond,pbody);
    return p;
}

static struct mm_decls_unitrec * mm_parse_readrepeat(void) {
    int64_t line;
    struct mm_decls_unitrec *  pbody;
    struct mm_decls_unitrec *  pcond;
    struct mm_decls_unitrec *  p;
    line = (int64_t)(mm_decls_lx.lineno);
    mm_lex_lex();
    pbody = mm_parse_readsunit((int64_t)0);
    mm_parse_checksymbol((int64_t)88);
    mm_lex_lex();
    pcond = mm_parse_readunit();
    p = mm_lib_createunit2((int64_t)215,pbody,pcond);
    (*p).lineno = line;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readloopcontrol(void) {
    int64_t opc;
    struct mm_decls_unitrec *  p;
    opc = (int64_t)(mm_decls_lx.subcode);
    mm_lex_lex();
    ++mm_decls_nexit;
    if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && !!(mlib_eqstring((*mm_decls_lx.symptr).name,(uint8_t*)"all")))) {
        mm_lex_lex();
        p = mm_lib_createunit1(opc,mm_lib_createconstunit((uint64_t)((int64_t)0),(int64_t)4));
        ++mm_decls_nnestedexit;
    } else if (!!((uint64_t)(mm_decls_exprstarterset[((int64_t)(mm_decls_lx.symbol))]))) {
        p = mm_lib_createunit1(opc,mm_parse_readconstexpr((int64_t)1));
        ++mm_decls_nnestedexit;
    } else {
        p = mm_lib_createunit1(opc,mm_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)4));
    };
    return mm_parse_readcondsuffix(p);
}

static struct mm_decls_unitrec * mm_parse_readprint(void) {
    int64_t oldinreadprint;
    int64_t opc;
    int64_t isfprint;
    int64_t fshowname;
    struct mm_decls_unitrec *  pformat;
    struct mm_decls_unitrec *  pdev;
    struct mm_decls_unitrec *  printlist;
    struct mm_decls_unitrec *  printlistx;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    struct mlib_strbuffer *  expr;
    uint8_t *  s;
    oldinreadprint = mm_parse_inreadprint;
    mm_parse_inreadprint = (int64_t)1;
    opc = (int64_t)(mm_decls_lx.subcode);
    if ((opc==(int64_t)233) || (opc==(int64_t)234) || (opc==(int64_t)235) || (opc==(int64_t)236)) {
        isfprint = (int64_t)1;
    } else {
        isfprint = (int64_t)0;
    };
    mm_lex_lex();
    printlist = (printlistx = (struct mm_decls_unitrec *)(0));
    pformat = (pdev = (struct mm_decls_unitrec *)(0));
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
        mm_lex_lex();
        pdev = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lex_lex();
        } else {
            goto L1170 ;
;
        };
    };
    if (!!(isfprint)) {
        if ((!(!!((uint64_t)(mm_decls_exprstarterset[((int64_t)(mm_decls_lx.symbol))]))) && (opc == (int64_t)236))) {
            goto L1170 ;
;
        };
        pformat = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lex_lex();
        } else {
            goto L1170 ;
;
        };
    };
    if (!(!!((uint64_t)(mm_decls_exprstarterset[((int64_t)(mm_decls_lx.symbol))])))) {
        goto L1170 ;
;
    };
    L1171 :;
    while (1) {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lib_addlistunit(&printlist,&printlistx,mm_lib_createunit0((int64_t)200));
        } else if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)141)) {
            mm_lib_addlistunit(&printlist,&printlistx,mm_lib_createunit0((int64_t)200));
            mm_lex_lex();
        } else {
            fshowname = (int64_t)0;
            if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)36))) {
                fshowname = (int64_t)1;
                mm_lex_lex();
            };
            p = mm_parse_readunit();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7)) {
                mm_lex_lex();
                p = mm_lib_createunit2((int64_t)199,p,mm_parse_readunit());
            };
            if (!!(fshowname)) {
                expr = mm_lib_strexpr(p);
                mlib_strbuffer_add(expr,(uint8_t*)"=",(int64_t)-1);
                s = (*expr).strptr;
                mlib_iconvucn((*expr).strptr,(int64_t)((*expr).length));
                mm_lib_addlistunit(&printlist,&printlistx,(q = mm_lib_createstringconstunit(s,(int64_t)((*expr).length))));
            };
            mm_lib_addlistunit(&printlist,&printlistx,p);
        };
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1172 ;
        };
        mm_lex_lex();
    }L1172 :;
    ;
    //finish:
L1170 :;
;
    mm_parse_inreadprint = oldinreadprint;
    if (((opc == (int64_t)231) && (printlist == 0))) {
        mm_support_serror((uint8_t*)"No print items");
    };
    if ((((opc == (int64_t)233) && (printlist == 0)) && (pformat == 0))) {
        mm_support_serror((uint8_t*)"No print items");
    };
    if ((((opc == (int64_t)235) && (printlist == 0)) && (pformat == 0))) {
        mm_support_serror((uint8_t*)"No cprint items");
    };
    if (!!(isfprint)) {
        if (((pformat == 0) && (opc != (int64_t)236))) {
            mm_support_serror((uint8_t*)"No fmt str");
        };
        return mm_lib_createunit3(opc,pdev,pformat,printlist);
    } else {
        return mm_lib_createunit2(opc,pdev,printlist);
    };
}

static struct mm_decls_unitrec * mm_parse_readread(void) {
    int64_t oldinreadprint;
    int64_t opc;
    struct mm_decls_unitrec *  pformat;
    struct mm_decls_unitrec *  pdev;
    struct mm_decls_unitrec *  readlist;
    struct mm_decls_unitrec *  readlistx;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  pread;
    oldinreadprint = mm_parse_inreadprint;
    mm_parse_inreadprint = (int64_t)1;
    opc = (int64_t)(mm_decls_lx.subcode);
    mm_lex_lex();
    readlist = (readlistx = (struct mm_decls_unitrec *)(0));
    pformat = (pdev = (struct mm_decls_unitrec *)(0));
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
        if ((opc == (int64_t)239)) {
            mm_support_serror((uint8_t*)"@ on read");
        };
        mm_lex_lex();
        pdev = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lex_lex();
        };
    };
    if ((opc == (int64_t)240)) {
        mm_lib_addlistunit(&readlist,&readlistx,mm_lib_createunit1((int64_t)240,pdev));
    };
    if (!(!!((uint64_t)(mm_decls_exprstarterset[((int64_t)(mm_decls_lx.symbol))])))) {
        goto L1173 ;
;
    };
    L1174 :;
    while (1) {
        p = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7)) {
            mm_lex_lex();
            pformat = mm_parse_readunit();
        } else {
            pformat = (struct mm_decls_unitrec *)(0);
        };
        pread = mm_lib_createunit1((int64_t)239,pformat);
        p = mm_lib_createunit2((int64_t)29,p,pread);
        mm_lib_addlistunit(&readlist,&readlistx,p);
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1175 ;
        };
        mm_lex_lex();
    }L1175 :;
    ;
    //finish:
L1173 :;
;
    mm_parse_inreadprint = oldinreadprint;
    if (((opc == (int64_t)239) && (readlist == 0))) {
        mm_support_serror((uint8_t*)"No read items");
    };
    return mm_parse_makestmtblock(readlist);
}

static struct mm_decls_unitrec * mm_parse_readtry(void) {
    struct mm_decls_unitrec *  ptry;
    struct mm_decls_unitrec *  pexceptlist;
    struct mm_decls_unitrec *  pexceptlistx;
    struct mm_decls_unitrec *  px;
    struct mm_decls_unitrec *  exlist;
    struct mm_decls_unitrec *  exlistx;
    ++mm_parse_try_level;
    mm_lex_lex();
    ptry = mm_parse_readsunit((int64_t)0);
    pexceptlist = (pexceptlistx = (struct mm_decls_unitrec *)(0));
    L1176 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)133)) {
        mm_lex_lex();
        exlist = (exlistx = (struct mm_decls_unitrec *)(0));
        L1179 :;
        while (1) {
            mm_lib_addlistunit(&exlist,&exlistx,mm_parse_readconstexpr((int64_t)1));
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
                goto L1180 ;
            };
            mm_lex_lex();
        }L1180 :;
        ;
        mm_parse_checksymbol((int64_t)68);
        mm_lex_lex();
        px = mm_parse_readsunit((int64_t)0);
        mm_lib_addlistunit(&pexceptlist,&pexceptlistx,mm_lib_createunit2((int64_t)245,exlist,px));
L1177 :;
    }L1178 :;
    ;
    mm_parse_checkend((int64_t)74,(int64_t)132,(int64_t)0,(int64_t)0);
    mm_lex_lex();
    --mm_parse_try_level;
    return mm_lib_createunit2((int64_t)244,ptry,pexceptlist);
}

static struct mm_decls_unitrec * mm_parse_readraise(void) {
    struct mm_decls_unitrec *  p;
    mm_lex_lex();
    p = mm_parse_readunit();
    return mm_lib_createunit1((int64_t)247,p);
}

static struct mm_decls_unitrec * mm_parse_readfor(void) {
    int64_t line;
    int64_t opc;
    int64_t kwd;
    struct mm_decls_unitrec *  pindex;
    struct mm_decls_unitrec *  plocal;
    struct mm_decls_unitrec *  pfrom;
    struct mm_decls_unitrec *  pto;
    struct mm_decls_unitrec *  pstep;
    struct mm_decls_unitrec *  prange;
    struct mm_decls_unitrec *  plist;
    struct mm_decls_unitrec *  passign;
    struct mm_decls_unitrec *  pcond;
    struct mm_decls_unitrec *  pbody;
    struct mm_decls_unitrec *  pelse;
    struct mm_decls_unitrec *  pto_temp;
    struct mm_decls_unitrec *  pstep_temp;
    struct mm_decls_unitrec *  ptemp;
    struct mm_decls_unitrec *  ptempx;
    struct mm_decls_unitrec *  plist_temp;
    struct mm_decls_unitrec *  prange_temp;
    struct mm_decls_unitrec *  p;
    kwd = (int64_t)(mm_decls_lx.symbol);
    line = (int64_t)(mm_decls_lx.lineno);
    mm_lex_lex();
    if ((kwd == (int64_t)80)) {
        pindex = mm_parse_readterm2();
        if (((int64_t)((*pindex).tag)==(int64_t)3)) {
        } else {
            mm_support_serror((uint8_t*)"For1");
        };
        plocal = (struct mm_decls_unitrec *)(0);
    } else {
        plocal = mm_parse_readterm2();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lex_lex();
            pindex = plocal;
            plocal = mm_parse_readterm2();
        } else {
            pindex = mm_lib_createname(mm_lib_getavname(mm_decls_currproc,(int64_t)10));
        };
        (*plocal).avcode = (uint64_t)76u;
    };
    (*pindex).avcode = (uint64_t)73u;
    if ((((int64_t)((*pindex).tag) != (int64_t)3) || (!!(plocal) && ((int64_t)((*plocal).tag) != (int64_t)3)))) {
        mm_support_serror((uint8_t*)"For: name expected");
    };
    opc = (int64_t)211;
    pstep = (struct mm_decls_unitrec *)(0);
    pcond = (struct mm_decls_unitrec *)(0);
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32)) {
        if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)57)) {
            opc = (int64_t)212;
        } else if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) != (int64_t)55)) {
            mm_support_serror((uint8_t*)"in/inrev expected");
        };
        mm_lex_lex();
        prange = mm_parse_readunit();
        if (((int64_t)((*prange).tag) == (int64_t)136)) {
            prange = (*prange).a;
        };
        pfrom = mm_lib_getrangelwbunit(prange);
        pto = mm_lib_getrangeupbunit(prange);
    } else {
        if ((kwd != (int64_t)80)) {
            mm_support_serror((uint8_t*)"forall needs \"in\"");
        };
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)9)) {
            mm_lex_lex();
            pfrom = mm_parse_readunit();
        } else {
            pfrom = mm_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)4);
        };
        mm_parse_checksymbol((int64_t)83);
        opc = (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)1)?(int64_t)212:(int64_t)211);
        mm_lex_lex();
        pto = mm_parse_readunit();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)84)) {
            mm_lex_lex();
            pstep = mm_parse_readconstexpr((int64_t)0);
            if ((((int64_t)((*pstep).tag) == (int64_t)1) && ((*pstep).value == (int64_t)1))) {
                pstep = (struct mm_decls_unitrec *)(0);
            };
        } else {
            pstep = (struct mm_decls_unitrec *)(0);
        };
    };
    if ((pstep == 0)) {
        pstep = mm_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)4);
    };
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)79)) {
        mm_lex_lex();
        pcond = mm_parse_readunit();
    };
    mm_parse_checksymbol((int64_t)85);
    mm_lex_lex();
    pbody = mm_parse_readsunit((int64_t)0);
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)70)) {
        mm_lex_lex();
        pelse = mm_parse_readsunit((int64_t)0);
    } else {
        pelse = (struct mm_decls_unitrec *)(0);
    };
    mm_parse_checkend((int64_t)74,(int64_t)80,(int64_t)85,(int64_t)0);
    mm_lex_lex();
    ptemp = (ptempx = (struct mm_decls_unitrec *)(0));
    pto_temp = (pstep_temp = (plist_temp = (struct mm_decls_unitrec *)(0)));
    if (!((((*pto).tag == (int64_t)1) || ((*pto).tag == (int64_t)3)))) {
        pto_temp = mm_lib_createname(mm_lib_getavname(mm_decls_currproc,(int64_t)10));
        (*pto_temp).avcode = (uint64_t)84u;
        mm_lib_addlistunit(&ptemp,&ptempx,pto_temp);
    };
    if (!((((*pstep).tag == (int64_t)1) || ((*pstep).tag == (int64_t)3)))) {
        pstep_temp = mm_lib_createname(mm_lib_getavname(mm_decls_currproc,(int64_t)10));
        (*pstep_temp).avcode = (uint64_t)83u;
        mm_lib_addlistunit(&ptemp,&ptempx,pstep_temp);
    };
    if ((kwd != (int64_t)80)) {
        plist = prange;
        if (!((((*prange).tag == (int64_t)1) || ((*prange).tag == (int64_t)3)))) {
            prange_temp = mm_lib_createname(mm_lib_getavname(mm_decls_currproc,(int64_t)10));
            (*prange_temp).avcode = (uint64_t)65u;
            mm_lib_addlistunit(&ptemp,&ptempx,prange_temp);
            plist = prange_temp;
        };
        passign = mm_lib_createunit2((int64_t)29,mm_lib_duplunit(plocal,(int64_t)0),mm_lib_createunit2((int64_t)88,mm_lib_duplunit(plist,(int64_t)0),mm_lib_duplunit(pindex,(int64_t)0)));
        pbody = mm_parse_createblock(passign,pbody);
        (*plocal).nextunit = plist;
    };
    if ((pcond != 0)) {
        pbody = mm_parse_makeblock(mm_lib_createunit2((int64_t)209,pcond,pbody));
    };
    (*pindex).nextunit = pfrom;
    (*pfrom).nextunit = pto;
    (*pto).nextunit = pstep;
    (*pstep).nextunit = plocal;
    (*pbody).nextunit = pelse;
    p = mm_lib_createunit3(opc,pindex,pbody,ptemp);
    (*p).lineno = line;
    return p;
}

void mm_parse_readtypedef(struct mm_decls_strec * owner,int64_t isglobal) {
    struct mm_decls_strec *  sttype;
    struct mm_decls_strec *  stname;
    int64_t t;
    int64_t m;
    mm_lex_lex();
    mm_parse_checksymbol((int64_t)50);
    stname = mm_decls_lx.symptr;
    mm_lex_lex();
    mm_parse_checkequals();
    mm_lex_lex();
    sttype = (struct mm_decls_strec *)(0);
    if ((sttype == 0)) {
        sttype = mm_lib_getduplnameptr(owner,stname,(int64_t)4);
        mm_lib_adddef(owner,sttype);
        m = mm_lib_createusertype(sttype);
        mm_decls_ttusercat[(m)] = (uint64_t)((int64_t)1);
    } else {
        m = (int64_t)((*sttype).mode);
    };
    t = mm_parse_readtypespec(sttype,m);
    (*sttype).isglobal = (uint64_t)(isglobal);
    mm_lib_storemode((int64_t)9,owner,t,&(*sttype).mode);
    if ((t >= (int64_t)0)) {
        mm_decls_ttisint[(m)] = (uint64_t)(mm_decls_ttisint[(t)]);
        mm_decls_ttisword[(m)] = (uint64_t)(mm_decls_ttisword[(t)]);
        mm_decls_ttiswordchar[(m)] = (uint64_t)(mm_decls_ttiswordchar[(t)]);
        mm_decls_ttisreal[(m)] = (uint64_t)(mm_decls_ttisreal[(t)]);
        mm_decls_ttisinteger[(m)] = (uint64_t)(mm_decls_ttisinteger[(t)]);
        mm_decls_ttisnumeric[(m)] = ((uint64_t)(mm_decls_ttisinteger[(t)]) | (uint64_t)(mm_decls_ttisreal[(t)]));
        mm_decls_ttisshortint[(m)] = (uint64_t)(mm_decls_ttisshortint[(t)]);
        mm_decls_ttisbit[(m)] = (uint64_t)(mm_decls_ttisbit[(t)]);
        mm_decls_ttisbit[(m)] = (uint64_t)(mm_decls_ttisbit[(t)]);
        mm_decls_ttisref[(m)] = (uint64_t)(mm_decls_ttisref[(t)]);
    };
}

void mm_parse_readrecordfields(struct mm_decls_strec * owner,int64_t m) {
    int64_t nvars;
    struct mm_decls_strec *  stname;
    struct mm_decls_strec *  stbitfield;
    nvars = (int64_t)0;
    L1181 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
        stname = mm_lib_getduplnameptr(owner,mm_decls_lx.symptr,(int64_t)12);
        mm_lib_storemode((int64_t)10,owner,m,&(*stname).mode);
        ++nvars;
        if (!!((uint64_t)(mm_parse_unionpend.ulength))) {
            mm_lib_unionstr_copy(&(*stname).uflags,&mm_parse_unionpend);
            mm_lib_unionstr_concat(&mm_parse_unionstring,&mm_parse_unionpend);
            mm_lib_unionstr_clear(&mm_parse_unionpend);
        } else {
            mm_lib_unionstr_clear(&(*stname).uflags);
        };
        mm_parse_unionlastvar = stname;
        mm_lib_adddef(owner,stname);
        mm_lex_lex();
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)21)) {
            mm_lex_lex();
            (*stname).at = (uint64_t)((int64_t)2);
            (*stname).equivfield = mm_parse_readequivfield(owner);
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)22)) {
            mm_lex_lex();
            mm_parse_checksymbol((int64_t)41);
            if ((mm_decls_lx.value==(int64_t)1) || (mm_decls_lx.value==(int64_t)2) || (mm_decls_lx.value==(int64_t)4) || (mm_decls_lx.value==(int64_t)8) || (mm_decls_lx.value==(int64_t)16)) {
                (*stname).align = (uint64_t)(mm_decls_lx.value);
            }else if ((mm_decls_lx.value==(int64_t)0)) {
                (*stname).align = (uint64_t)((int64_t)255);
            } else {
                mm_support_serror((uint8_t*)"@@ bad align");
            };
            mm_lex_lex();
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)7)) {
            mm_lex_lex();
            mm_parse_checksymbol((int64_t)12);
            L1184 :;
            do {
                mm_lex_lex();
                mm_parse_checksymbol((int64_t)50);
                stbitfield = mm_lib_getduplnameptr(owner,mm_decls_lx.symptr,(int64_t)12);
                (*stbitfield).mode = (int64_t)21;
                mm_lib_adddef(owner,stbitfield);
                (*stbitfield).at = (uint64_t)((int64_t)2);
                (*stbitfield).equivfield = stname;
                mm_lex_lex();
                mm_parse_checksymbol((int64_t)7);
                mm_lex_lex();
                mm_parse_checksymbol((int64_t)41);
                (*stbitfield).bitfieldwidth = (uint64_t)(mm_decls_lx.value);
                mm_lex_lex();
L1185 :;
            } while (!((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5));L1186 :;
            ;
            mm_parse_checksymbol((int64_t)13);
            mm_lex_lex();
        };
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1183 ;
        };
        mm_lex_lex();
L1182 :;
    }L1183 :;
    ;
    if ((nvars == (int64_t)0)) {
        mm_support_serror((uint8_t*)"No fields declared");
    };
}

void mm_parse_readtabledef(struct mm_decls_strec * owner,int64_t isglobal) {
    int64_t i;
    int64_t ncols;
    int64_t nrows;
    int64_t enums;
    int64_t nextenumvalue;
    int64_t firstval;
    int64_t lastval;
    int64_t startline;
    int64_t closesym;
    int64_t ltype;
    uint8_t *  enumtypename;
    struct mm_decls_strec *  stvar;
    struct mm_decls_strec *  stenum;
    struct mm_decls_strec *  stgen;
    struct mm_decls_strec *  varnameptrs[20];
    int64_t varlisttypes[20];
    struct mm_decls_unitrec *  plist[20];
    struct mm_decls_unitrec *  plistx[20];
    int64_t enumvalues[500];
    mm_lex_lex();
    enums = (int64_t)0;
    enumtypename = (uint8_t *)(0);
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)12)) {
        enums = (int64_t)1;
        mm_lex_lex();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
            enumtypename = (*mm_decls_lx.symptr).name;
            mm_lex_lex();
        };
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
    };
    nextenumvalue = (int64_t)1;
    nrows = (int64_t)0;
    ncols = (int64_t)0;
    L1187 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)32)) {
        ltype = mm_parse_readtypespec(owner,(int64_t)0);
        mm_parse_checksymbol((int64_t)50);
        if ((++ncols > (int64_t)20)) {
            mm_support_serror((uint8_t*)"tabledata/too many columns");
        };
        varnameptrs[(ncols)-1] = mm_decls_lx.symptr;
        varlisttypes[(ncols)-1] = ltype;
        mm_lex_lex();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
            mm_lex_lex();
        } else {
            goto L1189 ;
        };
L1188 :;
    }L1189 :;
    ;
    mm_parse_checkequals();
    mm_lex_lex();
    mm_parse_skipsemi();
    startline = mm_parse_getcurrline();
    closesym = mm_parse_checkbegin((int64_t)0);
    mm_parse_skipsemi();
    firstval = (lastval = (int64_t)0);
    L1190 :;
    for (i=(int64_t)1;i<=ncols;i+=(int64_t)1) {
L1191 :;
        plist[(i)-1] = (plistx[(i)-1] = (struct mm_decls_unitrec *)(0));
L1192 :;
    }L1193 :;
    ;
    mm_parse_intabledata = (int64_t)1;
    L1194 :;
    while (1) {
        mm_parse_skipsemi();
        mm_parse_checksymbol((int64_t)12);
        mm_lex_lex();
        if ((++nrows > (int64_t)500)) {
            mm_support_serror((uint8_t*)"tabledata:too many rows");
        };
        if (!!(enums)) {
            mm_parse_checksymbol((int64_t)50);
            stgen = mm_decls_lx.symptr;
            mm_parse_tabledataname = (*stgen).name;
            mm_lex_lex();
            if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)36))) {
                mm_lex_lex();
                nextenumvalue = mm_parse_readconstint();
            };
            enumvalues[(nrows)-1] = nextenumvalue;
            stenum = mm_lib_getduplnameptr(owner,stgen,(int64_t)8);
            mm_lib_storemode((int64_t)11,owner,(int64_t)4,&(*stenum).mode);
            (*stenum).code = mm_lib_createconstunit((uint64_t)(nextenumvalue),(int64_t)4);
            (*stenum).isglobal = (uint64_t)(isglobal);
            mm_lib_adddef(owner,stenum);
            if ((nrows == (int64_t)1)) {
                firstval = nextenumvalue;
            };
            lastval = nextenumvalue;
            ++nextenumvalue;
            if (!!(ncols)) {
                mm_parse_checksymbol((int64_t)5);
            };
            mm_lex_lex();
        };
        L1196 :;
        for (i=(int64_t)1;i<=ncols;i+=(int64_t)1) {
L1197 :;
            mm_lib_addlistunit(&plist[(i)-1],&plistx[(i)-1],mm_parse_readunit());
            if ((i == ncols)) {
                mm_parse_checksymbol((int64_t)13);
            } else {
                mm_parse_checksymbol((int64_t)5);
            };
            mm_lex_lex();
L1198 :;
        }L1199 :;
        ;
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1195 ;
        };
        mm_lex_lex();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == closesym)) {
            goto L1195 ;
        };
    }L1195 :;
    ;
    mm_parse_intabledata = (int64_t)0;
    mm_parse_skipsemi();
    mm_parse_checkbeginend(closesym,(int64_t)143,startline);
    if ((nrows == (int64_t)0)) {
        mm_support_serror((uint8_t*)"No table data");
    };
    L1200 :;
    for (i=(int64_t)1;i<=ncols;i+=(int64_t)1) {
L1201 :;
        stvar = mm_lib_getduplnameptr(owner,varnameptrs[(i)-1],(int64_t)9);
        (*stvar).code = mm_lib_createunit1((int64_t)19,plist[(i)-1]);
        (*(*stvar).code).length = nrows;
        mm_lib_storemode((int64_t)12,owner,varlisttypes[(i)-1],&(*stvar).mode);
        (*stvar).isglobal = (uint64_t)(isglobal);
        mm_lib_adddef(owner,stvar);
        mm_lib_addstatic(stvar);
L1202 :;
    }L1203 :;
    ;
}

void mm_parse_readclassdef(struct mm_decls_strec * owner,int64_t isglobal) {
    int64_t kwd;
    int64_t baseclass;
    int64_t m;
    int64_t startline;
    int64_t closesym;
    int64_t mrec;
    int64_t isrecord;
    int64_t align;
    struct mm_decls_strec *  nameptr;
    struct mm_decls_strec *  sttype;
    kwd = (int64_t)(mm_decls_lx.symbol);
    isrecord = (kwd == (int64_t)103);
    mm_lex_lex();
    mm_parse_checksymbol((int64_t)50);
    nameptr = mm_decls_lx.symptr;
    mm_lex_lex();
    baseclass = (int64_t)0;
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)12)) {
        mm_lex_lex();
        baseclass = mm_parse_readtypespec(owner,(int64_t)0);
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
    };
    mm_parse_checkequals();
    mm_lex_lex();
    align = (int64_t)0;
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)21)) {
        if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)0)) {
            mm_lex_lex();
            align = mm_parse_readconstint();
        } else {
            mm_lex_lex();
        };
        align = (int64_t)1;
    };
    sttype = mm_lib_getduplnameptr(owner,nameptr,(int64_t)4);
    mm_lib_adddef(owner,sttype);
    m = mm_lib_createusertype(sttype);
    mrec = mm_lib_createrecordmode(owner,m);
    mm_lib_storemode((int64_t)13,owner,mrec,&(*sttype).mode);
    mm_lib_storemode((int64_t)131,owner,baseclass,&(*sttype).baseclass);
    (*sttype).align = (uint64_t)(align);
    closesym = mm_parse_checkbegin((int64_t)1);
    startline = mm_parse_getcurrline();
    mm_parse_readclassbody(sttype,kwd);
    mm_parse_checkbeginend(closesym,kwd,startline);
    (*sttype).isglobal = (uint64_t)(isglobal);
}

static void mm_parse_readclassbody(struct mm_decls_strec * owner,int64_t classkwd) {
    int64_t kwd;
    int64_t t;
    mm_lib_unionstr_clear(&mm_parse_unionstring);
    mm_lib_unionstr_clear(&mm_parse_unionpend);
    L1204 :;
    switch ((int64_t)(mm_decls_lx.symbol)) {
    case 121:;
    {
        mm_parse_readconstdef(owner,(int64_t)0);
    }break;
    case 101:;
    case 100:;
    {
        kwd = (int64_t)(mm_decls_lx.symbol);
        if (!!((uint64_t)((*owner).imported))) {
            mm_parse_readprocdecl(owner,(int64_t)0,(int64_t)0);
        } else {
            mm_parse_readprocdef(owner,(int64_t)0,(int64_t)0);
        };
    }break;
    case 125:;
    case 103:;
    {
        mm_parse_readclassdef(owner,(int64_t)0);
    }break;
    case 111:;
    {
        mm_parse_readtypedef(owner,(int64_t)0);
    }break;
    case 36:;
    {
        mm_support_serror((uint8_t*)"Class eof?");
        goto L1205 ;
    }break;
    case 6:;
    {
        mm_lex_lex();
    }break;
    case 123:;
    {
        mm_lex_lex();
        mm_parse_readenumtype(owner,(int64_t)0,(int64_t)0);
    }break;
    case 143:;
    {
        mm_parse_readtabledef(owner,(int64_t)0);
    }break;
    case 118:;
    {
        mm_parse_readmacrodef(owner,(int64_t)0);
    }break;
    case 104:;
    case 105:;
    {
        mm_lib_unionstr_append(&mm_parse_unionpend,(((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)104)?(int64_t)83:(int64_t)85));
        mm_parse_unionlastvar = (struct mm_decls_strec *)(0);
        mm_lex_lex();
    }break;
    case 74:;
    case 13:;
    case 17:;
    {
        if (!!((uint64_t)(mm_parse_unionstring.ulength))) {
            mm_parse_checkend((int64_t)74,((mm_lib_unionstr_last(&mm_parse_unionstring) == (int64_t)83)?(int64_t)104:(int64_t)105),(int64_t)0,(int64_t)0);
            mm_lex_lex();
            if (((mm_parse_unionlastvar == 0) || !!((uint64_t)(mm_parse_unionpend.ulength)))) {
                mm_support_serror((uint8_t*)"Empty union group");
            };
            if ((mm_lib_unionstr_last(&(*mm_parse_unionlastvar).uflags)==(int64_t)69) || (mm_lib_unionstr_last(&(*mm_parse_unionlastvar).uflags)==(int64_t)42)) {
            } else {
                mm_lib_unionstr_append(&(*mm_parse_unionlastvar).uflags,(int64_t)42);
            };
            mm_lib_unionstr_append(&(*mm_parse_unionlastvar).uflags,(int64_t)69);
            --mm_parse_unionstring.ulength;
        } else {
            goto L1205 ;
        };
    }break;
    case 114:;
    {
        mm_lex_lex();
        if (!!(mm_parse_istypestarter())) {
            //readmut:
L1206 :;
;
            ++mm_parse_insiderecord;
            t = mm_parse_readtypespec(owner,(int64_t)0);
            --mm_parse_insiderecord;
        } else {
            mm_support_serror((uint8_t*)"need type");
        };
        mm_parse_readrecordfields(owner,t);
    }break;
    case 115:;
    {
        mm_support_serror((uint8_t*)"Let not allowed");
    }break;
    default: {
        if (!!(mm_parse_istypestarter())) {
            goto L1206 ;
;
        } else {
            goto L1205 ;
        };
    }
    } //SW
goto L1204 ;
L1205 :;
    ;
}

static int64_t mm_parse_readenumtype(struct mm_decls_strec * owner,int64_t typedefx,int64_t isglobal) {
    struct mm_decls_strec *  enumowner;
    struct mm_decls_strec *  stname;
    struct mm_decls_strec *  nameptr;
    int64_t isanon;
    int64_t index;
    int64_t startline;
    int64_t closesym;
    struct mm_decls_unitrec *  pone;
    struct mm_decls_unitrec *  pindex;
    enumowner = owner;
    isanon = (int64_t)0;
    if (!(!!(typedefx))) {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
            stname = mm_lib_getduplnameptr(owner,mm_decls_lx.symptr,(int64_t)4);
            owner = stname;
            mm_lex_lex();
            mm_parse_checkequals();
            mm_lex_lex();
            mm_lib_adddef(enumowner,owner);
        } else {
            isanon = (int64_t)1;
        };
        mm_parse_checksymbol((int64_t)12);
        mm_lex_lex();
    } else {
        owner = mm_decls_ttnamedef[(typedefx)];
        startline = mm_parse_getcurrline();
        closesym = mm_parse_checkbegin((int64_t)1);
    };
    pone = mm_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)4);
    pindex = pone;
    index = (int64_t)1;
    L1207 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
        nameptr = mm_decls_lx.symptr;
        mm_lex_lex();
        if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)36))) {
            mm_lex_lex();
            pindex = mm_parse_readunit();
        };
        if (!(!!(isanon))) {
            stname = mm_lib_getduplnameptr(owner,nameptr,(int64_t)14);
            (*stname).code = pindex;
            mm_lib_storemode((int64_t)14,owner,(int64_t)4,&(*stname).mode);
            mm_lib_adddef(owner,stname);
        } else {
            stname = mm_lib_getduplnameptr(enumowner,nameptr,(int64_t)8);
            (*stname).code = pindex;
            mm_lib_storemode((int64_t)15,owner,(int64_t)4,&(*stname).mode);
            mm_lib_adddef(enumowner,stname);
        };
        pindex = mm_lib_createunit2((int64_t)43,pindex,pone);
        (*stname).isglobal = (uint64_t)(isglobal);
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
            goto L1209 ;
        };
        mm_lex_lex();
L1208 :;
    }L1209 :;
    ;
    if (!(!!(typedefx))) {
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
    } else {
        mm_parse_checkbeginend(closesym,(int64_t)123,startline);
    };
    return (int64_t)0;
}

static void mm_parse_readimportmodule(struct mm_decls_strec * owner) {
    int64_t isnew;
    int64_t startline;
    int64_t closesym;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  stname;
    if (!!(mm_parse_insidedllimport)) {
        mm_support_serror((uint8_t*)"nested importdll");
    };
    mm_lex_lex();
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)46)) {
        stname = mm_lex_addnamestr(mm_decls_lx.svalue);
    } else {
        mm_parse_checksymbol((int64_t)50);
        stname = mm_decls_lx.symptr;
    };
    mm_lex_lex();
    mm_parse_checkequals();
    mm_lex_lex();
    isnew = (int64_t)1;
    d = (*stname).nextdupl;
    L1210 :;
    while (!!(d)) {
        if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)3)) {
            stname = d;
            isnew = (int64_t)0;
            goto L1212 ;
        };
        d = (*d).nextdupl;
L1211 :;
    }L1212 :;
    ;
    if (!!(isnew)) {
        stname = mm_lib_getduplnameptr(mm_decls_stmodule,stname,(int64_t)3);
        if (!!(mlib_eqstring((*stname).name,(uint8_t*)"sys"))) {
            mm_decls_stsysmodule = stname;
        };
        mm_lib_adddef(mm_decls_stmodule,stname);
        if ((mm_decls_ndllnametable >= (int64_t)50)) {
            mm_support_serror((uint8_t*)"Too many DLL libs");
        };
        mm_decls_dllnametable[(++mm_decls_ndllnametable)-1] = (*stname).name;
        (*stname).dllindex = (uint64_t)(mm_decls_ndllnametable);
    };
    startline = mm_parse_getcurrline();
    closesym = mm_parse_checkbegin((int64_t)0);
    mm_parse_insidedllimport = (int64_t)1;
    mm_parse_readimportbody(owner);
    mm_parse_insidedllimport = (int64_t)0;
    mm_parse_checkbeginend(closesym,(int64_t)107,startline);
}

static void mm_parse_readimportbody(struct mm_decls_strec * owner) {
    int64_t lineno;
    int64_t fflang;
    lineno = (int64_t)(mm_decls_lx.lineno);
    L1213 :;
    while (1) {
        mm_parse_skipsemi();
        switch ((int64_t)(mm_decls_lx.symbol)) {
        case 129:;
        {
            fflang = (int64_t)(mm_decls_lx.subcode);
            mm_lex_lex();
            if (((int64_t)(mm_decls_lx.symbol)==(int64_t)100) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)101)) {
                mm_parse_readprocdecl(owner,(int64_t)0,fflang);
            };
        }break;
        case 100:;
        case 101:;
        {
            mm_parse_readprocdecl(owner,(int64_t)0,(int64_t)0);
        }break;
        case 111:;
        {
            mm_parse_readtypedef(owner,(int64_t)0);
        }break;
        case 121:;
        {
            mm_parse_readconstdef(owner,(int64_t)1);
        }break;
        case 125:;
        case 103:;
        {
            mm_parse_readclassdef(owner,(int64_t)0);
        }break;
        case 114:;
        {
            mm_lex_lex();
            mm_parse_readvardef(owner,(int64_t)1,(int64_t)0,(int64_t)7,(int64_t)114);
        }break;
        case 36:;
        {
            goto L1214 ;
        }break;
        case 74:;
        {
            goto L1214 ;
        }break;
        default: {
            mm_lex_ps1((uint8_t*)"symbol");
            mm_support_serror((uint8_t*)"Not allowed in importmodule");
        }
        } //SW
;
    }L1214 :;
    ;
}

static struct mm_decls_strec * mm_parse_readequivfield(struct mm_decls_strec * owner) {
    struct mm_decls_strec *  p;
    struct mm_decls_strec *  d;
    mm_parse_checksymbol((int64_t)50);
    d = mm_decls_lx.symptr;
    mm_lex_lex();
    p = (*owner).deflist;
    L1215 :;
    while (!!(p)) {
        if (!!(mlib_eqstring((*p).name,(*d).name))) {
            return p;
        };
        p = (*p).nextdef;
L1216 :;
    }L1217 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_support_serror((uint8_t*)"Can't find @ field");
    return (struct mm_decls_strec *)(0);
}

static struct mm_decls_unitrec * mm_parse_readapplyop(int64_t inexpr) {
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    mm_lex_lex();
    mm_parse_checksymbol((int64_t)12);
    mm_lex_lex();
    p = mm_parse_readunit();
    mm_parse_checksymbol((int64_t)5);
    mm_lex_lex();
    a = mm_parse_readunit();
    b = (struct mm_decls_unitrec *)(0);
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
        mm_lex_lex();
        b = mm_parse_readunit();
    };
    mm_parse_checksymbol((int64_t)13);
    mm_lex_lex();
    return mm_lib_createunit3((!!(inexpr)?(int64_t)34:(int64_t)33),p,a,b);
}

static int64_t mm_parse_readrefproc(struct mm_decls_strec * owner,int64_t typedefx,int64_t fflang) {
    int64_t kwd;
    int64_t prettype;
    int64_t m;
    int64_t varparams;
    int64_t nparams;
    int64_t retmodes[4];
    struct mm_decls_strec *  paramlist;
    struct mm_decls_strec *  stproc;
    int64_t nretvalues;
    uint8_t *  name;
    int64_t i;
    kwd = (int64_t)(mm_decls_lx.symbol);
    mm_lex_lex();
    paramlist = (struct mm_decls_strec *)(0);
    prettype = (int64_t)0;
    nretvalues = (int64_t)0;
    name = mm_lib_nextautotype();
    stproc = mm_lib_getduplnameptr(mm_decls_stmodule,mm_lex_addnamestr(name),(int64_t)4);
    mm_lib_adddef(mm_decls_stmodule,stproc);
    if ((kwd == (int64_t)101)) {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)12)) {
            mm_lex_lex();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)13)) {
                paramlist = mm_parse_readparams(owner,stproc,(int64_t)0,&varparams,&nparams);
                mm_parse_checksymbol((int64_t)13);
            };
            mm_lex_lex();
            if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)11))) {
                mm_lex_lex();
                nretvalues = mm_parse_readreturntype(stproc,&retmodes);
            } else if ((!!((uint64_t)(mm_decls_typestarterset[((int64_t)(mm_decls_lx.symbol))])) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50))) {
                nretvalues = mm_parse_readreturntype(stproc,&retmodes);
            };
        } else if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)11))) {
            mm_lex_lex();
            nretvalues = mm_parse_readreturntype(stproc,&retmodes);
        };
        if ((nretvalues == (int64_t)0)) {
            mm_support_serror((uint8_t*)"Function needs return type");
        };
        if ((!!(nretvalues) && (kwd == (int64_t)100))) {
            mm_support_serror((uint8_t*)"Proc can't return value");
        };
    } else {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)12)) {
            mm_lex_lex();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)13)) {
                paramlist = mm_parse_readparams(owner,stproc,(int64_t)0,&varparams,&nparams);
                mm_parse_checksymbol((int64_t)13);
            };
            mm_lex_lex();
        };
        if (((!!((uint64_t)(mm_decls_typestarterset[((int64_t)(mm_decls_lx.symbol))])) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)7)) || ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)11))) {
            mm_support_serror((uint8_t*)"proc can't have ret value");
        };
    };
    m = mm_lib_createrefprocmode(owner,stproc,paramlist,kwd,prettype,typedefx);
    L1218 :;
    for (i=(int64_t)1;i<=nretvalues;i+=(int64_t)1) {
L1219 :;
        mm_lib_storemode((int64_t)17,owner,retmodes[(i)-1],&(*stproc).modelist[(i)-1]);
L1220 :;
    }L1221 :;
    ;
    (*stproc).nretvalues = (uint64_t)(nretvalues);
    mm_decls_ttnamedef[(m)] = stproc;
    (*stproc).fflang = (uint64_t)(fflang);
    return m;
}

static void mm_parse_pushproc(struct mm_decls_strec * p) {
    if ((mm_parse_nprocstack >= (int64_t)10)) {
        mm_support_serror((uint8_t*)"Too many nested proc");
    };
    mm_parse_procstack[(++mm_parse_nprocstack)-1] = mm_decls_currproc;
    mm_decls_currproc = p;
}

static void mm_parse_popproc(void) {
    if (!!(mm_parse_nprocstack)) {
        mm_decls_currproc = mm_parse_procstack[(mm_parse_nprocstack--)-1];
    } else {
        mm_decls_currproc = mm_decls_stmodule;
    };
}

static struct mm_decls_unitrec * mm_parse_readassemline(void) {
    mm_lex_lex();
    return mm_parse_assembleline((int64_t)1);
}

static struct mm_decls_unitrec * mm_parse_readassemblock(void) {
    struct mm_decls_unitrec *  ulist;
    struct mm_decls_unitrec *  ulistx;
    struct mm_decls_unitrec *  u;
    ulist = (ulistx = (struct mm_decls_unitrec *)(0));
    L1222 :;
    while (1) {
        mm_lex_lex();
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)36)) {
            mm_support_serror((uint8_t*)"EOF: 'End' missing in Assembler code");
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)74)) {
            mm_parse_checkend((int64_t)(mm_decls_lx.symbol),(int64_t)151,(int64_t)0,(int64_t)0);
            mm_lex_lex();
            goto L1223 ;
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)6)) {
        } else {
            u = mm_parse_assembleline((int64_t)0);
            mm_lib_addlistunit(&ulist,&ulistx,u);
        };
    }L1223 :;
    ;
    return mm_parse_makeblock(ulist);
}

static struct mm_decls_unitrec * mm_parse_assembleline(int64_t oneline) {
    struct mm_decls_unitrec *  dlist;
    struct mm_decls_unitrec *  dlistx;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  pname;
    struct mm_decls_unitrec *  q;
    int64_t opc;
    int64_t noperands;
    struct mm_decls_strec *  stname;
    dlist = (dlistx = (struct mm_decls_unitrec *)(0));
    if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && ((mm_decls_nextlx.symbol == (int64_t)7) || (mm_decls_nextlx.symbol == (int64_t)8)))) {
        p = mm_lib_createunit0((int64_t)218);
        stname = mm_lib_getduplnameptr(mm_decls_currproc,mm_decls_lx.symptr,(int64_t)15);
        (*p).def = stname;
        mm_lib_adddef(mm_decls_currproc,stname);
        mm_lex_lex();
        if (!!(oneline)) {
            mm_lex_lex();
        };
        return p;
    } else if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)45))) {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)50);
        pname = mm_lib_createname(mm_decls_lx.symptr);
        (*pname).lineno = (int64_t)(mm_decls_lx.lineno);
        mm_lex_lex();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)6)) {
            L1224 :;
            do {
                mm_lib_addlistunit(&dlist,&dlistx,mm_parse_readunit());
                if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
                    mm_lex_lex();
                };
L1225 :;
            } while (!((mm_decls_lx.symbol == (int64_t)6) || (mm_decls_lx.symbol == (int64_t)36)));L1226 :;
            ;
        };
        return mm_lib_createunit2((int64_t)8,pname,dlist);
    };
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32)) {
        if (((int64_t)(mm_decls_lx.subcode)==(int64_t)12)) {
            opc = (int64_t)34;
        }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)13)) {
            opc = (int64_t)35;
        }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)14)) {
            opc = (int64_t)36;
        }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)15)) {
            opc = (int64_t)47;
        } else {
            mm_support_serror((uint8_t*)"Asm op??");
        };
        p = mm_lib_createunit0((int64_t)7);
        (*p).opcode = opc;
        mm_lex_lex();
    } else if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
        p = mm_lib_createunit0((int64_t)7);
        if (((int64_t)(mm_decls_lx.subcode)==(int64_t)60)) {
            (*p).opcode = (int64_t)((*mm_decls_lx.symptr).index);
        }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)56)) {
            (*p).opcode = (int64_t)22;
            (*p).cond = (uint64_t)((*mm_decls_lx.symptr).index);
        }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)57)) {
            (*p).opcode = (int64_t)54;
            (*p).cond = (uint64_t)((*mm_decls_lx.symptr).index);
        }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)58)) {
            (*p).opcode = (int64_t)12;
            (*p).cond = (uint64_t)((*mm_decls_lx.symptr).index);
        } else {
            mm_support_serror((uint8_t*)"x64 op expected");
        };
        mm_lex_lex();
    } else {
        mm_support_serror((uint8_t*)"ASM???");
    };
    if (!(((mm_decls_lx.symbol == (int64_t)6) || (mm_decls_lx.symbol == (int64_t)36)))) {
        noperands = (int64_t)0;
        L1227 :;
        while (1) {
            q = mm_parse_readassemopnd();
            ++noperands;
            if ((noperands==(int64_t)1)) {
                (*p).a = q;
            }else if ((noperands==(int64_t)2)) {
                (*p).b = q;
            }else if ((noperands==(int64_t)3)) {
                (*p).c = q;
            } else {
                mm_support_serror((uint8_t*)"Too many asm opnds");
            };
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)5)) {
                goto L1228 ;
            } else {
                mm_lex_lex();
            };
        }L1228 :;
        ;
    };
    mm_parse_checksymbol((int64_t)6);
    return p;
}

static struct mm_decls_unitrec * mm_parse_readassemopnd(void) {
    struct mm_decls_unitrec *  p;
    int64_t reg;
    int64_t regix;
    int64_t scale;
    int64_t prefixmode;
    struct mm_decls_unitrec *  pcode;
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)41) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)43)) {
        return mm_parse_readunit();
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)50)) {
        if (((int64_t)((*mm_decls_lx.symptr).subcode)==(int64_t)52)) {
            p = mm_lib_createunit0((int64_t)9);
            (*p).index = (int64_t)((*mm_decls_lx.symptr).index);
            (*p).regsize = (uint64_t)((*mm_decls_lx.symptr).regsize);
            mm_lex_lex();
            return p;
        }else if (((int64_t)((*mm_decls_lx.symptr).subcode)==(int64_t)53)) {
            p = mm_lib_createunit0((int64_t)10);
            (*p).index = (int64_t)((*mm_decls_lx.symptr).index);
            mm_lex_lex();
            return p;
        };
        return mm_parse_readunit();
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)32)) {
        return mm_parse_readunit();
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)61)) {
        if (((int64_t)(mm_decls_lx.subcode)==(int64_t)6) || ((int64_t)(mm_decls_lx.subcode)==(int64_t)7) || ((int64_t)(mm_decls_lx.subcode)==(int64_t)8) || ((int64_t)(mm_decls_lx.subcode)==(int64_t)9)) {
        } else {
            mm_support_serror((uint8_t*)"Bad prefix");
        };
        prefixmode = (int64_t)(mm_decls_lx.subcode);
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)14);
        goto L1229 ;
;
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)14)) {
        prefixmode = (int64_t)0;
        //gotprefix:
L1229 :;
;
        reg = (regix = (int64_t)0);
        pcode = (struct mm_decls_unitrec *)(0);
        scale = (int64_t)1;
        mm_lex_lex();
        if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && ((int64_t)((*mm_decls_lx.symptr).subcode) == (int64_t)52))) {
            reg = (int64_t)((*mm_decls_lx.symptr).index);
            mm_lex_lex();
        };
        if (((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)50)) && ((int64_t)((*mm_decls_nextlx.symptr).subcode) == (int64_t)52))) {
            if (((int64_t)(mm_decls_lx.subcode)==(int64_t)43)) {
                mm_lex_lex();
            } else {
                mm_support_gerror((uint8_t*)"reg-reg etc",(struct mm_decls_unitrec *)(0));
            };
        };
        if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && ((int64_t)((*mm_decls_lx.symptr).subcode) == (int64_t)52))) {
            regix = (int64_t)((*mm_decls_lx.symptr).index);
            mm_lex_lex();
        };
        if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)32) && ((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)45))) {
            mm_lex_lex();
            mm_parse_checksymbol((int64_t)41);
            if (((scale = mm_decls_lx.value)==(int64_t)1) || ((scale = mm_decls_lx.value)==(int64_t)2) || ((scale = mm_decls_lx.value)==(int64_t)4) || ((scale = mm_decls_lx.value)==(int64_t)8)) {
            } else {
                mm_support_serror((uint8_t*)"Bad scale");
            };
            mm_lex_lex();
        };
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)32) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)41) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)50) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)12) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)153)) {
            pcode = mm_parse_readunit();
        };
        mm_parse_checksymbol((int64_t)15);
        mm_lex_lex();
        p = mm_lib_createunit1((int64_t)11,pcode);
        if (((regix == (int64_t)0) && (scale > (int64_t)1))) {
            regix = reg;
            reg = (int64_t)0;
        };
        if (((pcode == 0) && ((reg + regix) == (int64_t)0))) {
            mm_support_serror((uint8_t*)"Empty []");
        };
        (*p).reg = (uint64_t)(reg);
        (*p).regix = (uint64_t)(regix);
        (*p).scale = (uint64_t)(scale);
        (*p).prefixmode = (uint64_t)(prefixmode);
        return p;
    } else {
        mm_support_serror((uint8_t*)"ASM: Bad operand?");
    };
    return (struct mm_decls_unitrec *)(0);
}

static struct mm_decls_unitrec * mm_parse_makeastring(void) {
    struct mm_decls_unitrec *  ulist;
    struct mm_decls_unitrec *  ulistx;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  pconst;
    uint8_t *  s;
    int64_t length;
    int64_t av_1;
    ulist = (ulistx = (struct mm_decls_unitrec *)(0));
    s = mm_decls_lx.svalue;
    length = (int64_t)(mm_decls_lx.length);
    av_1 = length;
    while (av_1-- > 0) {
L1230 :;
        pconst = mm_lib_createconstunit((uint64_t)((*s)),(int64_t)4);
        mm_lib_addlistunit(&ulist,&ulistx,pconst);
        ++s;
L1231 :;
    }L1232 :;
    ;
    if (((uint64_t)(mm_decls_lx.subcode) == (uint64_t)90u)) {
        pconst = mm_lib_createconstunit((uint64_t)((int64_t)0),(int64_t)4);
        mm_lib_addlistunit(&ulist,&ulistx,pconst);
        ++length;
    };
    p = mm_lib_createunit1((int64_t)19,ulist);
    (*p).length = length;
    return p;
}

static int64_t mm_parse_readreturntype(struct mm_decls_strec * owner,int64_t (*retmodes)[]) {
    int64_t nretvalues;
    (*retmodes)[((int64_t)1)-1] = mm_parse_readtypespec(owner,(int64_t)0);
    nretvalues = (int64_t)1;
    L1233 :;
    while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)5)) {
        if ((nretvalues >= (int64_t)4)) {
            mm_support_serror((uint8_t*)"Too many return values");
        };
        mm_lex_lex();
        (*retmodes)[(++nretvalues)-1] = mm_parse_readtypespec(owner,(int64_t)0);
L1234 :;
    }L1235 :;
    ;
    return nretvalues;
}

static struct mm_decls_unitrec * mm_parse_readset(void) {
    int64_t length;
    int64_t nkeyvalues;
    int64_t oldirp;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  ulist;
    struct mm_decls_unitrec *  ulistx;
    mm_lex_lex();
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)15)) {
        mm_lex_lex();
        return mm_lib_createunit1((int64_t)21,(struct mm_decls_unitrec *)(0));
    }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)7)) {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)15);
        mm_lex_lex();
        return mm_lib_createunit1((int64_t)22,(struct mm_decls_unitrec *)(0));
    };
    length = (int64_t)0;
    nkeyvalues = (int64_t)0;
    ulist = (ulistx = (struct mm_decls_unitrec *)(0));
    L1236 :;
    while (1) {
        oldirp = mm_parse_inreadprint;
        mm_parse_inreadprint = (int64_t)0;
        p = mm_parse_readunit();
        mm_parse_inreadprint = oldirp;
        if (((int64_t)((*p).tag) == (int64_t)28)) {
            ++nkeyvalues;
        };
        ++length;
        mm_lib_addlistunit(&ulist,&ulistx,p);
        if (((int64_t)(mm_decls_lx.symbol)==(int64_t)5)) {
            mm_lex_lex();
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)15)) {
                goto L1237 ;
            };
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)6)) {
            mm_lex_lex();
            mm_parse_checksymbol((int64_t)15);
            goto L1237 ;
        }else if (((int64_t)(mm_decls_lx.symbol)==(int64_t)15)) {
            goto L1237 ;
        } else {
            mm_support_serror((uint8_t*)"readset?");
        };
        mm_parse_skipsemi();
    }L1237 :;
    ;
    mm_lex_lex();
    if (!!(nkeyvalues)) {
        if ((length > nkeyvalues)) {
            mm_support_serror((uint8_t*)"dict: mixed elements");
        };
        p = mm_lib_createunit1((int64_t)22,ulist);
    } else {
        p = mm_lib_createunit1((int64_t)21,ulist);
    };
    (*p).length = length;
    return p;
}

static int64_t mm_parse_istypestarter(void) {
    if ((!!((uint64_t)(mm_decls_typestarterset[((int64_t)(mm_decls_lx.symbol))])) || (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)50)))) {
        return (int64_t)1;
    };
    if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50) && ((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)24))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

static struct mm_decls_unitrec * mm_parse_readunit(void) {
    return mm_parse_readfactor((int64_t)8);
}

static struct mm_decls_unitrec * mm_parse_readfactor(int64_t level) {
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    int64_t opc;
    int64_t opprio;
    int64_t lineno;
    int64_t isassign;
    if ((level <= (int64_t)1)) {
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50)) {
            if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)6) || ((int64_t)(mm_decls_nextlx.symbol)==(int64_t)5)) {
                p = mm_lib_createname(mm_decls_lx.symptr);
                (*p).lineno = (int64_t)(mm_decls_lx.lineno);
                mm_lex_lex();
                return p;
            }else if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)32) || ((int64_t)(mm_decls_nextlx.symbol)==(int64_t)9)) {
                p = mm_lib_createname(mm_decls_lx.symptr);
                (*p).lineno = (int64_t)(mm_decls_lx.lineno);
                mm_lex_lex();
                goto L1238 ;
;
            };
        };
        p = mm_parse_readterm2();
    } else {
        p = mm_parse_readfactor((level - (int64_t)1));
    };
    L1239 :;
    switch ((int64_t)(mm_decls_lx.symbol)) {
    case 32:;
    case 9:;
    case 24:;
    case 29:;
    case 10:;
    {
        //gotterm:
L1238 :;
;
        opc = (int64_t)(mm_decls_lx.subcode);
        lineno = (int64_t)(mm_decls_lx.lineno);
        if (((mm_decls_nextlx.symbol == (int64_t)9) || (mm_decls_nextlx.symbol == (int64_t)10))) {
            mm_lex_lex();
            isassign = (int64_t)1;
            opprio = (int64_t)(mm_tables_jtagpriotable[((int64_t)29)]);
            opc = mm_lib_getoptocode(opc);
        } else {
            isassign = ((opc == (int64_t)29) || (opc == (int64_t)30));
            opprio = (int64_t)(mm_tables_jtagpriotable[(opc)]);
        };
        if ((opprio != level)) {
            goto L1240 ;
        };
        mm_lex_lex();
        if (!!(isassign)) {
            q = mm_parse_readunit();
        } else if ((opc == (int64_t)98)) {
            q = mm_parse_readfactor(level);
        } else {
            q = mm_parse_readfactor((level - (int64_t)1));
        };
        p = mm_lib_createunit2(opc,p,q);
        (*p).lineno = lineno;
    }break;
    default: {
        goto L1240 ;
    }
    } //SW
goto L1239 ;
L1240 :;
    ;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readterm2(void) {
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    int64_t opc;
    int64_t oldinrp;
    int64_t lineno;
    lineno = (int64_t)(mm_decls_lx.lineno);
    p = mm_parse_readterm();
    L1241 :;
    switch ((int64_t)(mm_decls_lx.symbol)) {
    case 12:;
    {
        mm_lex_lex();
        oldinrp = mm_parse_inreadprint;
        mm_parse_inreadprint = (int64_t)0;
        q = mm_parse_readslist((int64_t)1,(int64_t)1);
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
        if (((int64_t)((*p).tag) == (int64_t)204)) {
            (*p).a = q;
        } else {
            p = mm_lib_createunit2((int64_t)31,p,q);
        };
        mm_parse_inreadprint = oldinrp;
        p = mm_parse_readcondsuffix(p);
    }break;
    case 18:;
    {
        p = mm_lib_createunit1((int64_t)99,p);
        mm_lex_lex();
    }break;
    case 14:;
    {
        p = mm_parse_readindex(p,(int64_t)0);
    }break;
    case 2:;
    {
        p = mm_parse_readdotsuffix(p);
    }break;
    case 16:;
    {
        p = mm_parse_readkeyindex(p);
    }break;
    case 7:;
    {
        if (!!(mm_parse_inreadprint)) {
            goto L1242 ;
        };
        mm_lex_lex();
        q = mm_parse_readunit();
        p = mm_lib_createunit2((!!(mm_parse_inparamlist)?(int64_t)27:(int64_t)28),p,q);
    }break;
    case 40:;
    {
        if (((int64_t)(mm_decls_lx.subcode)==(int64_t)145)) {
            opc = (int64_t)147;
        }else if (((int64_t)(mm_decls_lx.subcode)==(int64_t)146)) {
            opc = (int64_t)148;
        };
        mm_lex_lex();
        p = mm_lib_createunit1(opc,p);
    }break;
    case 4:;
    {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)14);
        mm_lex_lex();
        q = mm_parse_readunit();
        if (((int64_t)((*q).tag) == (int64_t)20)) {
            p = mm_lib_createunit2((int64_t)93,p,q);
        } else {
            p = mm_lib_createunit2((int64_t)92,p,q);
        };
        mm_parse_checksymbol((int64_t)15);
        mm_lex_lex();
    }break;
    default: {
        goto L1242 ;
    }
    } //SW
goto L1241 ;
L1242 :;
    ;
    (*p).lineno = lineno;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readterm(void) {
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  r;
    uint8_t *  pbyte;
    uint64_t a;
    int64_t opc;
    int64_t lineno;
    int64_t shift;
    int64_t t;
    i128 *  pvalue;
    int64_t av_1;
    lineno = (int64_t)(mm_decls_lx.lineno);
    switch ((int64_t)(mm_decls_lx.symbol)) {
    case 50:;
    {
        if (((int64_t)((uint64_t)(mm_decls_nextlx.symbol)) == (int64_t)21)) {
            p = mm_parse_readcast();
        } else {
            p = mm_lib_createname(mm_decls_lx.symptr);
            (*p).lineno = (int64_t)(mm_decls_lx.lineno);
            mm_lex_lex();
        };
    }break;
    case 41:;
    case 43:;
    {
        p = mm_lib_createconstunit((uint64_t)(mm_decls_lx.value),(int64_t)(mm_decls_lx.subcode));
        mm_lex_lex();
    }break;
    case 46:;
    {
        p = mm_lib_createstringconstunit(mm_decls_lx.svalue,(int64_t)(mm_decls_lx.length));
        mm_lex_lex();
    }break;
    case 47:;
    {
        p = mm_parse_makeastring();
        mm_lex_lex();
    }break;
    case 42:;
    {
        (*(mm_decls_lx.svalue + (int64_t)(mm_decls_lx.length))) = (uint64_t)0u;
        p = mm_lib_createunit0((int64_t)6);
        (*p).svalue = mm_decls_lx.svalue;
        (*p).slength = (int64_t)(mm_decls_lx.length);
        (*p).mode = (int64_t)33;
        mm_lex_lex();
    }break;
    case 44:;
    {
        a = (uint64_t)((int64_t)0);
        shift = (int64_t)0;
        pbyte = mm_decls_lx.svalue;
        if (((int64_t)(mm_decls_lx.length) > (int64_t)8)) {
            pvalue = (i128 *)(mlib_pcm_alloc((int64_t)16));
            memset((void *)(pvalue),(int64_t)0,(uint64_t)((int64_t)16));
            memcpy((void *)(pvalue),(void *)(pbyte),(uint64_t)(mm_decls_lx.length));
            p = mm_lib_createconstunit((uint64_t)(pvalue),(int64_t)10);
        } else {
            av_1 = (int64_t)(mm_decls_lx.length);
            while (av_1-- > 0) {
L1243 :;
                a = (a | ((uint64_t)((*pbyte)) << shift));
                shift += (int64_t)8;
                ++pbyte;
L1244 :;
            }L1245 :;
            ;
            if ((a <= (uint64_t)9223372036854775807u)) {
                t = (int64_t)15;
            } else {
                t = (int64_t)15;
            };
            p = mm_lib_createconstunit(a,t);
        };
        mm_lex_lex();
    }break;
    case 12:;
    {
        p = mm_parse_readlbrack();
    }break;
    case 61:;
    case 113:;
    case 66:;
    case 63:;
    {
        p = mm_parse_readcast();
    }break;
    case 117:;
    {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)12);
        p = mm_parse_readlbrack();
        (*p).makearray = (int64_t)1;
    }break;
    case 32:;
    {
        p = mm_parse_readopc();
    }break;
    case 33:;
    {
        p = mm_parse_readopc();
    }break;
    case 14:;
    {
        p = mm_parse_readset();
    }break;
    case 40:;
    {
        opc = (int64_t)(mm_decls_lx.subcode);
        mm_lex_lex();
        p = mm_lib_createunit1(opc,mm_parse_readterm2());
    }break;
    case 96:;
    {
        p = mm_parse_readsprint();
    }break;
    case 98:;
    case 99:;
    {
        p = mm_parse_readsread();
    }break;
    case 24:;
    {
        mm_lex_lex();
        p = mm_lib_createunit1((int64_t)100,mm_parse_readterm2());
        if (((int64_t)((*(*p).a).tag) == (int64_t)31)) {
            if (!!((*(*p).a).b)) {
                mm_support_serror((uint8_t*)"Params not allowed");
            };
            (*p).a = (*(*p).a).a;
        };
    }break;
    case 4:;
    {
        mm_lex_lex();
        p = mm_lib_createunit1((int64_t)101,mm_parse_readterm2());
    }break;
    case 140:;
    {
        p = mm_parse_readcompilervar();
    }break;
    case 149:;
    {
        p = mm_lib_createconstunit((uint64_t)(mm_decls_lx.subcode),(int64_t)4);
        mm_lex_lex();
    }break;
    case 141:;
    {
        if (!!(mm_parse_intabledata)) {
            p = mm_lib_createstringconstunit(mm_parse_tabledataname,(int64_t)-1);
        } else {
            if ((mm_parse_ndollar <= (int64_t)0)) {
                mm_support_serror((uint8_t*)"[$] No array");
            };
            p = mm_lib_createunit1((int64_t)134,mm_parse_dollarstack[(mm_parse_ndollar)-1]);
        };
        mm_lex_lex();
    }break;
    case 145:;
    {
        p = mm_parse_readapplyop((int64_t)1);
    }break;
    case 138:;
    {
        p = mm_parse_readcastx();
    }break;
    case 139:;
    {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)12);
        mm_lex_lex();
        p = mm_lib_createunit0((int64_t)106);
        mm_lib_storemode((int64_t)3,mm_decls_currproc,mm_parse_readtypespec(mm_decls_currproc,(int64_t)0),(int32_t *)(&(*p).value));
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
    }break;
    case 147:;
    {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)12);
        mm_lex_lex();
        p = mm_parse_readunit();
        mm_parse_checksymbol((int64_t)5);
        mm_lex_lex();
        q = mm_parse_readunit();
        if ((((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13) && ((int64_t)((*q).tag) == (int64_t)20))) {
            r = (*q).b;
            q = (*q).a;
        } else {
            mm_parse_checksymbol((int64_t)5);
            mm_lex_lex();
            r = mm_parse_readunit();
            mm_parse_checksymbol((int64_t)13);
        };
        mm_lex_lex();
        q = mm_lib_createunit2((int64_t)61,p,q);
        p = mm_lib_createunit2((int64_t)60,q,r);
    }break;
    case 92:;
    {
        p = mm_parse_readgoto((int64_t)216);
    }break;
    case 67:;
    {
        p = mm_parse_readif();
    }break;
    case 75:;
    {
        p = mm_parse_readunless();
    }break;
    case 76:;
    case 77:;
    case 93:;
    case 94:;
    {
        p = mm_parse_readswitchcase();
    }break;
    case 78:;
    {
        p = mm_parse_readrecase();
    }break;
    case 80:;
    case 81:;
    case 82:;
    {
        p = mm_parse_readfor();
    }break;
    case 83:;
    {
        p = mm_parse_readto();
    }break;
    case 85:;
    {
        p = mm_parse_readdo();
    }break;
    case 86:;
    {
        p = mm_parse_readwhile();
    }break;
    case 87:;
    {
        p = mm_parse_readrepeat();
    }break;
    case 91:;
    {
        p = mm_parse_readloopcontrol();
    }break;
    case 89:;
    {
        p = mm_parse_readreturn();
    }break;
    case 90:;
    {
        p = mm_parse_readstop();
    }break;
    case 95:;
    {
        p = mm_parse_readprint();
    }break;
    case 97:;
    {
        p = mm_parse_readread();
    }break;
    case 132:;
    {
        p = mm_parse_readtry();
    }break;
    case 135:;
    {
        p = mm_parse_readraise();
    }break;
    case 148:;
    {
        mm_lex_lex();
        mm_parse_checksymbol((int64_t)12);
        mm_lex_lex();
        p = mm_parse_readunit();
        mm_parse_checksymbol((int64_t)5);
        mm_lex_lex();
        q = mm_parse_readunit();
        mm_parse_checksymbol((int64_t)13);
        mm_lex_lex();
        p = mm_lib_createunit2((int64_t)228,p,q);
    }break;
    case 142:;
    {
        mm_lex_lex();
        p = mm_lib_createunit1((int64_t)248,mm_parse_readunit());
    }break;
    case 151:;
    {
        (*mm_decls_currproc).asmused = (uint64_t)((int64_t)1);
        mm_decls_assemmode = (int64_t)1;
        if (((int64_t)((uint64_t)(mm_decls_lx.subcode)) == (int64_t)0)) {
            p = mm_parse_readassemline();
        } else {
            p = mm_parse_readassemblock();
        };
        mm_decls_assemmode = (int64_t)0;
    }break;
    case 16:;
    {
        mm_lex_lex();
        p = mm_parse_readsunit((int64_t)0);
        mm_parse_checksymbol((int64_t)17);
        mm_lex_lex();
        p = mm_lib_createunit1((int64_t)249,p);
    }break;
    case 152:;
    {
        p = mm_lib_createstringconstunit(mm_decls_lx.svalue,(int64_t)(mm_decls_lx.length));
        (*p).tag = (int64_t)250;
        mm_lex_lex();
    }break;
    case 153:;
    {
        p = mm_lib_createunit0((int64_t)204);
        (*p).opcode = (int64_t)(mm_decls_lx.subcode);
        mm_lex_lex();
    }break;
    case 27:;
    {
        mm_lex_lex();
        p = mm_parse_readunit();
        mm_parse_checksymbol((int64_t)27);
        mm_lex_lex();
        p = mm_lib_createunit1((int64_t)251,p);
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_tables_symbolnames[((int64_t)(mm_decls_lx.symbol))-1],NULL);
        msysnewc_m_print_str((uint8_t*)"LX.SYMBOL=",NULL);
        msysnewc_m_print_u64(mm_decls_lx.symbol,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_serror((uint8_t*)"readterm?");
    }
    } //SW
;
    (*p).lineno = lineno;
    return p;
}

static struct mm_decls_unitrec * mm_parse_readxunit(void) {
    return mm_parse_readsunit((int64_t)0);
}

static struct mm_decls_unitrec * mm_parse_readsunit(int64_t inwhile) {
    int64_t lineno;
    int64_t sym;
    int64_t opc;
    struct mm_decls_unitrec *  ulist;
    struct mm_decls_unitrec *  ulistx;
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  r;
    struct mm_decls_strec *  stname;
    lineno = (int64_t)(mm_decls_lx.lineno);
    ulist = (ulistx = (struct mm_decls_unitrec *)(0));
    L1246 :;
    do {
        L1249 :;
        while (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)6)) {
            mm_lex_lex();
L1250 :;
        }L1251 :;
        ;
        switch ((int64_t)(mm_decls_lx.symbol)) {
        case 131:;
        {
            mm_lex_lex();
            if (((mm_decls_lx.symbol == (int64_t)115) || (mm_decls_lx.symbol == (int64_t)114))) {
                opc = (int64_t)(mm_decls_lx.symbol);
                mm_lex_lex();
            } else {
                opc = (int64_t)114;
            };
            mm_parse_readvardef(mm_decls_currproc,(int64_t)0,(int64_t)1,(int64_t)9,opc);
        }break;
        case 100:;
        case 101:;
        {
            mm_parse_readprocdef(mm_decls_currproc,(int64_t)0,(int64_t)0);
        }break;
        case 61:;
        case 14:;
        case 113:;
        case 66:;
        case 63:;
        case 117:;
        case 116:;
        {
            if (((mm_decls_nextlx.symbol == (int64_t)12) || (mm_decls_nextlx.symbol == (int64_t)21) || (mm_decls_nextlx.symbol == (int64_t)2))) {
                goto L1252 ;
;
            } else {
                sym = (int64_t)114;
                goto L1253 ;
;
            };
        }break;
        case 114:;
        case 115:;
        {
            sym = (int64_t)(mm_decls_lx.symbol);
            mm_lex_lex();
            //dovar:
L1253 :;
;
            q = mm_parse_readvardef(mm_decls_currproc,(int64_t)0,(int64_t)0,(int64_t)10,sym);
            L1254 :;
            while (!!(q)) {
                r = (*q).nextunit;
                (*q).nextunit = (struct mm_decls_unitrec *)(0);
                mm_lib_addlistunit(&ulist,&ulistx,q);
                q = r;
L1255 :;
            }L1256 :;
            ;
        }break;
        case 111:;
        {
            mm_parse_readtypedef(mm_decls_currproc,(int64_t)0);
        }break;
        case 121:;
        {
            mm_parse_readconstdef(mm_decls_currproc,(int64_t)0);
        }break;
        case 143:;
        {
            mm_parse_readtabledef(mm_decls_currproc,(int64_t)0);
        }break;
        case 125:;
        case 103:;
        {
            mm_parse_readclassdef(mm_decls_currproc,(int64_t)0);
        }break;
        case 39:;
        {
            mm_parse_adddocstring(mm_decls_lx.svalue,(int64_t)(mm_decls_lx.length));
            mm_lex_lex();
        }break;
        case 123:;
        {
            mm_lex_lex();
            mm_parse_readenumtype(mm_decls_currproc,(int64_t)0,(int64_t)0);
        }break;
        case 118:;
        {
            mm_parse_readmacrodef(mm_decls_currproc,(int64_t)0);
        }break;
        case 36:;
        {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*mm_decls_currproc).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_serror((uint8_t*)"Unexpected EOF in proc");
        }break;
        case 13:;
        case 68:;
        case 69:;
        case 70:;
        case 88:;
        case 79:;
        case 71:;
        case 72:;
        case 133:;
        case 74:;
        case 17:;
        {
            goto L1248 ;
        }break;
        case 50:;
        {
            if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)8)) {
                p = mm_lib_createunit0((int64_t)218);
                stname = mm_lib_getduplnameptr(mm_decls_currproc,mm_decls_lx.symptr,(int64_t)15);
                mm_lib_adddef(mm_decls_currproc,stname);
                (*p).def = stname;
                (*p).trylevel = mm_parse_try_level;
                mm_lex_lex();
                mm_decls_lx.symbol = (uint64_t)((int64_t)6);
                mm_lib_addlistunit(&ulist,&ulistx,p);
            }else if (((int64_t)(mm_decls_nextlx.symbol)==(int64_t)50)) {
                sym = (int64_t)114;
                goto L1253 ;
;
                goto L1252 ;
;
            } else {
                goto L1252 ;
;
            };
        }break;
        case 85:;
        {
            if (!!(inwhile)) {
                goto L1248 ;
            };
            goto L1252 ;
;
        }break;
        case 6:;
        {
        }break;
        default: {
            //doexec:
L1252 :;
;
            p = mm_parse_readunit();
            //doexec2:
L1257 :;
;
            if ((((int64_t)((*p).tag) == (int64_t)3) && ((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)50))) {
                mm_support_serror((uint8_t*)"Possibly var/let needed");
            };
            mm_lib_addlistunit(&ulist,&ulistx,p);
            if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)85)) {
                goto L1248 ;
            };
        }
        } //SW
;
L1247 :;
    } while (!((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)6));L1248 :;
    ;
    if (((int64_t)(mm_decls_lx.symbol)==(int64_t)13) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)68) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)69) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)70) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)88) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)79) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)85) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)71) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)72) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)133) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)74) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)17) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)5) || ((int64_t)(mm_decls_lx.symbol)==(int64_t)19)) {
    } else {
        mm_support_serror((uint8_t*)"Readsunit: \";\" expected, or bad unit starter");
    };
    if (((ulist == 0) || !!((*ulist).nextunit))) {
        return mm_lib_createunit1((int64_t)4,ulist);
    } else {
        return ulist;
    };
}

static void mm_parse_readmacrodef(struct mm_decls_strec * owner,int64_t isglobal) {
    struct mm_decls_strec *  nameptr;
    struct mm_decls_strec *  stmacro;
    struct mm_decls_strec *  paramlist;
    struct mm_decls_strec *  paramlistx;
    struct mm_decls_strec *  stname;
    mm_lex_lex();
    mm_parse_checksymbol((int64_t)50);
    nameptr = mm_decls_lx.symptr;
    stmacro = mm_lib_getduplnameptr(owner,nameptr,(int64_t)18);
    mm_lib_adddef(owner,stmacro);
    owner = stmacro;
    mm_lex_lex();
    paramlist = (paramlistx = (struct mm_decls_strec *)(0));
    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)12)) {
        mm_lex_lex();
        if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) != (int64_t)13)) {
            L1258 :;
            while (1) {
                if (((int64_t)(mm_decls_lx.symbol)==(int64_t)50)) {
                    stname = mm_lib_getduplnameptr(owner,mm_decls_lx.symptr,(int64_t)19);
                    mm_lib_adddef(owner,stname);
                    mm_parse_addlistparam(&paramlist,&paramlistx,stname);
                    (*stname).nulldef = mm_decls_lx.symptr;
                    mm_lex_lex();
                    if (((int64_t)((uint64_t)(mm_decls_lx.symbol)) == (int64_t)13)) {
                        goto L1259 ;
                    };
                    mm_parse_checksymbol((int64_t)5);
                    mm_lex_lex();
                } else {
                    mm_support_serror((uint8_t*)"macro def params");
                };
            }L1259 :;
            ;
        };
        mm_lex_lex();
    };
    (*stmacro).paramlist = paramlist;
    (*stmacro).isglobal = (uint64_t)(isglobal);
    mm_parse_checkequals();
    mm_lex_lex();
    (*stmacro).code = mm_parse_readunit();
}

static void mm_parse_readimportalias(struct mm_decls_strec * dimport) {
    struct mm_decls_strec *  stmacro;
    mm_lex_lex();
    mm_parse_checksymbol((int64_t)50);
    stmacro = mm_lib_getduplnameptr(mm_decls_stmodule,mm_decls_lx.symptr,(int64_t)18);
    mm_lib_adddef(mm_decls_stmodule,stmacro);
    mm_lex_lex();
    (*stmacro).paramlist = (struct mm_decls_strec *)(0);
    (*stmacro).code = mm_lib_createname(dimport);
}

static void mm_parse_domappedalias(struct mm_decls_strec * dimport,struct mm_decls_strec * stimport) {
    struct mm_decls_strec *  stmacro;
    if (!!(mlib_eqstring((*dimport).name,(*stimport).name))) {
        return;
    };
    stmacro = mm_lib_getduplnameptr(mm_decls_stmodule,dimport,(int64_t)18);
    mm_lib_adddef(mm_decls_stmodule,stmacro);
    (*stmacro).paramlist = (struct mm_decls_strec *)(0);
    (*stmacro).code = mm_lib_createname(stimport);
}

static struct mm_decls_unitrec * mm_parse_readrecase(void) {
    mm_lex_lex();
    return mm_lib_createunit1((int64_t)230,mm_parse_readunit());
}

static struct mm_decls_unitrec * mm_parse_createblock(struct mm_decls_unitrec * p,struct mm_decls_unitrec * q) {
    if ((q == 0)) {
        return p;
    } else if (((int64_t)((*q).tag) == (int64_t)4)) {
        (*p).nextunit = (*q).a;
        (*q).a = p;
        return q;
    } else {
        (*p).nextunit = q;
        return mm_parse_makeblock(p);
    };
}

static void mm_parse_adddocstring(uint8_t * s,int64_t n) {
    if ((mm_decls_ndocstrings > (int64_t)20)) {
        mm_support_serror((uint8_t*)"Too many docstrings");
    };
    mm_decls_docstrings[(++mm_decls_ndocstrings)-1] = mlib_pcm_copyheapstringn(s,n);
}

void mm_name_rx_typetable(void) {
    struct mm_decls_strec *  d;
    int64_t i;
    L1260 :;
    for (i=(int64_t)37;i<=mm_decls_ntypes;i+=(int64_t)1) {
L1261 :;
        if (((int64_t)(mm_decls_ttbasetype[(i)]) == (int64_t)25)) {
            d = mm_decls_ttnamedef[(i)];
            if (!!((int64_t)((*d).baseclass))) {
                mm_name_do_baseclass(d);
            };
        };
L1262 :;
    }L1263 :;
    ;
}

void mm_name_rx_unit(struct mm_decls_strec * owner,struct mm_decls_unitrec * p) {
    struct mm_decls_strec *  d;
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    int64_t n;
    int64_t oldnoexpand;
    int64_t oldnoassem;
    a = (*p).a;
    b = (*p).b;
    mm_decls_mlineno = (int64_t)((*p).lineno);
    switch ((int64_t)((*p).tag)) {
    case 3:;
    {
        mm_name_resolvename(owner,p);
        if ((((int64_t)((uint64_t)((*(*p).def).nameid)) == (int64_t)18) && !(!!(mm_name_noexpand)))) {
            ++mm_name_macrolevels;
            mm_name_expandmacro(p,p,(struct mm_decls_unitrec *)(0));
            mm_name_rx_unit(owner,p);
            --mm_name_macrolevels;
        };
    }break;
    case 27:;
    {
        mm_name_rx_unit(owner,b);
    }break;
    case 95:;
    {
        if (((int64_t)((*b).tag) == (int64_t)3)) {
            d = mm_name_resolvetopname(owner,(*b).def,(int64_t)((*b).moduleno),(int64_t)0,(int64_t)0);
            if (((!!(d) && ((int64_t)((uint64_t)((*d).nameid)) == (int64_t)18)) && !(!!(mm_name_noexpand)))) {
                (*b).def = d;
                ++mm_name_macrolevels;
                mm_name_expandmacro(b,b,(struct mm_decls_unitrec *)(0));
                mm_name_rx_unit(owner,b);
                --mm_name_macrolevels;
                if (((int64_t)((*b).tag) == (int64_t)21)) {
                    mm_name_rx_unit(owner,a);
                    (*p).tag = (int64_t)91;
                    mm_lib_deleteunit(b,(*b).a);
                    return;
                };
            };
        };
        mm_name_resolvedot(owner,p);
    }break;
    case 201:;
    case 31:;
    case 32:;
    {
        if (((int64_t)((*a).tag) == (int64_t)3)) {
            oldnoexpand = mm_name_noexpand;
            mm_name_noexpand = (int64_t)1;
            mm_name_rx_unit(owner,a);
            mm_name_noexpand = oldnoexpand;
        } else {
            mm_name_rx_unit(owner,a);
        };
        mm_name_rx_unitlist(owner,b);
        if (((int64_t)((*a).tag) == (int64_t)3)) {
            d = (*a).def;
            if (((int64_t)((*d).nameid)==(int64_t)4)) {
                (*p).tag = (int64_t)102;
                mm_lib_storemode((int64_t)17,owner,(int64_t)((*d).mode),&(*p).newmode);
                (*p).a = b;
                (*p).b = (struct mm_decls_unitrec *)(0);
                if (!!((*b).nextunit)) {
                    (*p).a = mm_lib_createunit1((int64_t)19,b);
                    n = (int64_t)0;
                    L1264 :;
                    while (!!(b)) {
                        ++n;
                        b = (*b).nextunit;
L1265 :;
                    }L1266 :;
                    ;
                    (*(*p).a).length = n;
                };
            }else if (((int64_t)((*d).nameid)==(int64_t)18)) {
                ++mm_name_macrolevels;
                mm_name_expandmacro(p,a,b);
                mm_name_rx_unit(owner,p);
                --mm_name_macrolevels;
            } else {
                if (((int64_t)((*d).mode) == (int64_t)0)) {
                    (*p).tag = (int64_t)201;
                };
            };
        };
    }break;
    case 36:;
    case 37:;
    case 38:;
    case 39:;
    case 41:;
    case 40:;
    {
        if (((int64_t)((*(*p).a).tag)==(int64_t)36) || ((int64_t)((*(*p).a).tag)==(int64_t)37) || ((int64_t)((*(*p).a).tag)==(int64_t)38) || ((int64_t)((*(*p).a).tag)==(int64_t)39) || ((int64_t)((*(*p).a).tag)==(int64_t)41) || ((int64_t)((*(*p).a).tag)==(int64_t)40)) {
            mm_name_converteqeq(owner,p);
        } else {
            goto L1267 ;
;
        };
        goto L1267 ;
;
    }break;
    case 8:;
    {
        mm_name_resolvename(owner,a);
        if (!(!!(mm_name_noexpand))) {
            ++mm_name_macrolevels;
            oldnoassem = mm_name_noassem;
            mm_name_noassem = (int64_t)1;
            mm_name_expandmacro(p,a,b);
            mm_name_noassem = oldnoassem;
            mm_name_rx_unit(owner,p);
            --mm_name_macrolevels;
        };
    }break;
    default: {
        //doabc:
L1267 :;
;
        mm_name_rx_unitlist(owner,a);
        //dobc:
L1268 :;
;
        if (!!(b)) {
            mm_name_rx_unitlist(owner,b);
            if (!!((*p).c)) {
                mm_name_rx_unitlist(owner,(*p).c);
            };
        };
    }
    } //SW
;
}

int64_t mm_name_rx_module(int64_t n) {
    mm_decls_currmoduleno = n;
    mm_name_rx_passdef(mm_decls_stprogram,mm_decls_moduletable[(n)].stmodule);
    return (int64_t)1;
}

void mm_name_rx_deflist(struct mm_decls_strec * owner,struct mm_decls_strec * p) {
    struct mm_decls_strec *  pstart;
    pstart = p;
    L1269 :;
    while (!!(p)) {
        mm_name_rx_passdef(owner,p);
        p = (*p).nextdef;
L1270 :;
    }L1271 :;
    ;
}

void mm_name_rx_passdef(struct mm_decls_strec * owner,struct mm_decls_strec * p) {
    if (((int64_t)((*p).nameid)==(int64_t)2) || ((int64_t)((*p).nameid)==(int64_t)3)) {
        mm_name_rx_deflist(p,(*p).deflist);
    }else if (((int64_t)((*p).nameid)==(int64_t)5)) {
        mm_name_fixmode(owner,p);
        mm_name_rx_deflist(p,(*p).deflist);
        mm_name_currstproc = p;
        mm_name_rx_unit(p,(*p).code);
        mm_name_currstproc = (struct mm_decls_strec *)(0);
    }else if (((int64_t)((*p).nameid)==(int64_t)6)) {
        mm_name_fixmode(owner,p);
        mm_name_rx_deflist(p,(*p).deflist);
    }else if (((int64_t)((*p).nameid)==(int64_t)8) || ((int64_t)((*p).nameid)==(int64_t)9) || ((int64_t)((*p).nameid)==(int64_t)10) || ((int64_t)((*p).nameid)==(int64_t)11)) {
        mm_name_fixmode(owner,p);
        if (((int64_t)((uint64_t)((*p).at)) == (int64_t)1)) {
            mm_name_rx_unit(owner,(*p).equivvar);
        };
        if ((!!((*p).code) && ((int64_t)((uint64_t)((*p).nameid)) != (int64_t)10))) {
            mm_name_rx_unit(owner,(*p).code);
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)4)) {
        mm_name_rx_deflist(p,(*p).deflist);
        mm_name_fixmode(owner,p);
    } else {
    };
}

static void mm_name_rx_unitlist(struct mm_decls_strec * owner,struct mm_decls_unitrec * p) {
    L1272 :;
    while (!!(p)) {
        mm_name_rx_unit(owner,p);
        p = (*p).nextunit;
L1273 :;
    }L1274 :;
    ;
}

struct mm_decls_strec * mm_name_resolvetopname(struct mm_decls_strec * owner,struct mm_decls_strec * stnewname,int64_t moduleno,int64_t fmodule,int64_t fdoambig) {
    int64_t i;
    int64_t extcount;
    int64_t modno;
    struct mm_decls_strec *  p;
    struct mm_decls_strec *  powner;
    struct mm_decls_strec *  dlldef;
    struct mm_decls_strec *  extdef;
    struct mm_decls_strec *  moddef;
    struct mm_decls_strec *  extmod;
    struct mm_decls_strec *  q;
    struct mm_decls_strec *  ambiglist[10];
    if (((int64_t)((uint64_t)((*owner).nameid)) == (int64_t)5)) {
        q = (*owner).deflist;
        L1275 :;
        while (!!(q)) {
            if (((*q).firstdupl == stnewname)) {
                return q;
            };
            q = (*q).nextdef;
L1276 :;
        }L1277 :;
        ;
    };
    p = (*stnewname).nextdupl;
    extcount = (int64_t)0;
    extmod = (dlldef = (extdef = (moddef = (struct mm_decls_strec *)(0))));
    L1278 :;
    while (!!(p)) {
        powner = (*p).owner;
        switch ((int64_t)((*powner).nameid)) {
        case 5:;
        {
            if ((powner == owner)) {
                return p;
            };
            if ((powner == (*owner).owner)) {
                return p;
            };
        }break;
        case 2:;
        {
            if (((int64_t)((uint64_t)((*powner).moduleno)) == moduleno)) {
                if (((int64_t)((uint64_t)((*owner).nameid)) == (int64_t)2)) {
                    return p;
                };
                moddef = p;
            } else if (!!((uint64_t)(mm_decls_moduletable[(moduleno)].importmap[((int64_t)((*powner).moduleno))-1]))) {
                if (!!((uint64_t)((*p).isglobal))) {
                    ++extcount;
                    extdef = p;
                    if ((extcount < (int64_t)10)) {
                        ambiglist[(extcount)-1] = extdef;
                    };
                };
            };
        }break;
        case 3:;
        {
            modno = (int64_t)((*(*powner).owner).moduleno);
            if (((modno == moduleno) || !!((uint64_t)(mm_decls_moduletable[(moduleno)].importmap[(modno)-1])))) {
                dlldef = p;
            };
        }break;
        case 4:;
        {
            if ((powner == owner)) {
                return p;
            };
            if ((powner == (*owner).owner)) {
                return p;
            };
        }break;
        case 1:;
        {
            if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)2)) {
                if (((int64_t)((uint64_t)((*p).moduleno)) == moduleno)) {
                    if (!!(fmodule)) {
                        return p;
                    };
                } else {
                    extmod = p;
                };
            };
        }break;
        default: {
        }
        } //SW
;
        p = (*p).nextdupl;
L1279 :;
    }L1280 :;
    ;
    if (!!(moddef)) {
        return moddef;
    };
    if (!!(extdef)) {
        if (((extcount > (int64_t)1) && !!(fdoambig))) {
            L1281 :;
            for (i=(int64_t)1;i<=extcount;i+=(int64_t)1) {
L1282 :;
                extdef = ambiglist[(i)-1];
                msysnewc_m_print_startcon();
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_str((*(*extdef).owner).name,NULL);
                msysnewc_m_print_str(mm_tables_namenames[((int64_t)((*(*extdef).owner).nameid))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
L1283 :;
            }L1284 :;
            ;
            mm_support_rxerror_s((uint8_t*)"Ambiguous ext name: #",(*extdef).name,(struct mm_decls_unitrec *)(0));
        };
        return extdef;
    };
    if (!!(extmod)) {
        return extmod;
    };
    return dlldef;
}

void mm_name_resolvename(struct mm_decls_strec * owner,struct mm_decls_unitrec * p) {
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    int64_t moduleno;
    int64_t mode;
    d = (*p).def;
    moduleno = (int64_t)((*p).moduleno);
    if (((int64_t)((uint64_t)((*d).nameid)) != (int64_t)0)) {
        return;
    };
    e = mm_name_resolvetopname(owner,d,moduleno,mm_name_allowmodname,(int64_t)1);
    if (!(!!(e))) {
        mode = (int64_t)0;
        if (((int64_t)((*p).avcode)==(int64_t)73) || ((int64_t)((*p).avcode)==(int64_t)84) || ((int64_t)((*p).avcode)==(int64_t)83)) {
            mode = (int64_t)4;
        }else if (((int64_t)((*p).avcode)==(int64_t)76) || ((int64_t)((*p).avcode)==(int64_t)65)) {
            mode = (int64_t)20;
        };
        if ((mode == (int64_t)0)) {
            mm_support_rxerror_s((uint8_t*)"Undefined: #",(*d).name,p);
        } else {
            e = mm_name_addframevar(owner,d,moduleno,mode);
            (*e).lineno = (int64_t)((*p).lineno);
            if ((mode != (int64_t)20)) {
                (*e).islet = (uint64_t)((int64_t)1);
            };
        };
    };
    (*e).used = (uint64_t)((int64_t)1);
    mm_name_fixmode(owner,e);
    if ((((int64_t)((uint64_t)((*e).nameid)) == (int64_t)11) && ((int64_t)((uint64_t)((*e).parammode)) == (int64_t)2))) {
        (*p).tag = (int64_t)99;
        (*p).a = mm_lib_createname(e);
        (*p).def = (struct mm_decls_strec *)(0);
    };
    (*p).def = e;
    if (((int64_t)((*e).nameid)==(int64_t)5)) {
        if (!!((uint64_t)((*e).isglobal))) {
            (*e).namecat = (uint64_t)((int64_t)2);
        };
    };
}

struct mm_decls_strec * mm_name_finddupl(struct mm_decls_strec * d,struct mm_decls_strec * pdupl) {
    if (((int64_t)((uint64_t)((*pdupl).nameid)) != (int64_t)0)) {
        return pdupl;
    };
    pdupl = (*pdupl).nextdupl;
    L1285 :;
    while (!!(pdupl)) {
        if (((*pdupl).owner == d)) {
            return pdupl;
        };
        pdupl = (*pdupl).nextdupl;
L1286 :;
    }L1287 :;
    ;
    return (struct mm_decls_strec *)(0);
}

static void mm_name_resolvedot(struct mm_decls_strec * owner,struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  lhs;
    struct mm_decls_unitrec *  rhs;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    struct mm_decls_strec *  t;
    int64_t m;
    lhs = (*p).a;
    rhs = (*p).b;
    e = (*rhs).def;
    mm_name_rx_unit(owner,lhs);
    if (((int64_t)((*lhs).tag)==(int64_t)3)) {
        d = (*lhs).def;
        if (((int64_t)((*d).nameid)==(int64_t)2) || ((int64_t)((*d).nameid)==(int64_t)4) || ((int64_t)((*d).nameid)==(int64_t)5) || ((int64_t)((*d).nameid)==(int64_t)4) || ((int64_t)((*d).nameid)==(int64_t)3)) {
            e = mm_name_finddupl(d,e);
            if (!!(e)) {
                (*p).tag = (int64_t)3;
                (*p).a = ((*p).b = (struct mm_decls_unitrec *)(0));
                (*p).def = e;
                if (((int64_t)((*e).nameid)==(int64_t)14)) {
                }else if (((int64_t)((*e).nameid)==(int64_t)8)) {
                }else if (((int64_t)((*e).nameid)==(int64_t)18)) {
                    if ((((int64_t)((uint64_t)((*e).nameid)) == (int64_t)18) && !(!!(mm_name_noexpand)))) {
                        ++mm_name_macrolevels;
                        mm_name_expandmacro(p,p,(struct mm_decls_unitrec *)(0));
                        mm_name_rx_unit(owner,p);
                        --mm_name_macrolevels;
                    };
                };
            } else {
                mm_support_rxerror_s((uint8_t*)"Can't resolve .#",(*(*(*p).b).def).name,p);
            };
        }else if (((int64_t)((*d).nameid)==(int64_t)10) || ((int64_t)((*d).nameid)==(int64_t)9) || ((int64_t)((*d).nameid)==(int64_t)11)) {
            m = (int64_t)((*d).mode);
            if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)25)) {
            }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)19)) {
                L1288 :;
                while (1) {
                    m = (int64_t)(mm_decls_tttarget[(m)]);
                    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)25)) {
                        goto L1289 ;
                    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)19)) {
                    } else {
                        mm_support_rxerror((uint8_t*)"2:record expected",(struct mm_decls_unitrec *)(0));
                    };
                }L1289 :;
                ;
            } else {
                mm_support_rxerror((uint8_t*)"record expected",(struct mm_decls_unitrec *)(0));
            };
            t = mm_decls_ttnamedef[(m)];
            e = mm_name_finddupl(t,e);
            if (!!(e)) {
                (*(*p).b).def = e;
            } else {
                mm_support_rxerror_s((uint8_t*)"Not a field: #",(*(*rhs).def).name,(struct mm_decls_unitrec *)(0));
            };
        };
    } else {
        if (!(!!((*e).nextdupl))) {
            mm_support_rxerror_s((uint8_t*)"Not a field: #",(*e).name,(struct mm_decls_unitrec *)(0));
        };
    };
}

static void mm_name_fixmode(struct mm_decls_strec * owner,struct mm_decls_strec * p) {
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    int64_t m;
    return;
    m = (int64_t)((*p).mode);
    if ((m >= (int64_t)0)) {
        return;
    };
    m = -(m);
    if (!!(mm_decls_ttxmap[(m)])) {
        (*p).mode = mm_decls_ttxmap[(m)];
        return;
    };
    if (!!(mm_decls_ttnamedefx2[(m)])) {
        mm_support_rxerror((uint8_t*)"Can't resolve a:b tentative types yet",(struct mm_decls_unitrec *)(0));
    };
    d = mm_decls_ttnamedefx[(m)];
    e = mm_name_resolvetopname(owner,d,(int64_t)(mm_decls_ttxmoduleno[(m)]),(int64_t)0,(int64_t)1);
    if (!!(e)) {
        mm_decls_ttxmap[(m)] = (int64_t)((*e).mode);
        (*p).mode = (int64_t)((*e).mode);
    } else {
        mm_decls_mlineno = (mm_decls_ttlinenox[(m)] + (int64_t)(((uint64_t)(mm_decls_ttxmoduleno[(m)]) << (int64_t)24)));
        mm_support_rxerror_s((uint8_t*)"Can't resolve tentative type: #",(*d).name,(struct mm_decls_unitrec *)(0));
    };
}

static int64_t mm_name_fixmode2(struct mm_decls_strec * owner,int64_t m) {
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    uint8_t str[256];
    if ((m >= (int64_t)0)) {
        return m;
    };
    m = -(m);
    if ((!!(mm_decls_ttxmap[(m)]) && (mm_decls_ttxmap[(m)] >= (int64_t)0))) {
        return mm_decls_ttxmap[(m)];
    };
    if (!!(mm_decls_ttnamedefx2[(m)])) {
        mm_support_rxerror((uint8_t*)"2:Can't resolve a:b tentative types yet",(struct mm_decls_unitrec *)(0));
    };
    d = mm_decls_ttnamedefx[(m)];
    if ((owner == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_rxerror((uint8_t*)"FIXMODE2 OWNER=0",(struct mm_decls_unitrec *)(0));
    };
    e = mm_name_resolvetopname(owner,d,(int64_t)(mm_decls_ttxmoduleno[(m)]),(int64_t)0,(int64_t)1);
    L1290 :;
    while (((!!(e) && ((int64_t)((uint64_t)((*e).nameid)) != (int64_t)4)) && !!((*owner).owner))) {
        owner = (*owner).owner;
        e = mm_name_resolvetopname(owner,d,(int64_t)(mm_decls_ttxmoduleno[(m)]),(int64_t)0,(int64_t)1);
L1291 :;
    }L1292 :;
    ;
    if ((!!(e) && ((int64_t)((uint64_t)((*e).nameid)) == (int64_t)4))) {
        mm_decls_ttxmap[(m)] = (int64_t)((*e).mode);
        return (int64_t)((*e).mode);
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"# in module #, line:#");
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(mm_decls_moduletable[((int64_t)(mm_decls_ttxmoduleno[(m)]))].name,NULL);
        msysnewc_m_print_i64(mm_decls_ttlinenox[(m)],NULL);
        msysnewc_m_print_end();
        ;
        mm_decls_mlineno = (mm_decls_ttlinenox[(m)] + (int64_t)(((uint64_t)(mm_decls_ttxmoduleno[(m)]) << (int64_t)24)));
        mm_support_rxerror_s((uint8_t*)"2:Can't resolve tentative type: #",str,(struct mm_decls_unitrec *)(0));
    };
    return (int64_t)0;
}

void mm_name_fixusertypes(void) {
    struct mm_decls_userxrec *  p;
    int64_t m;
    int64_t rescan;
    int64_t i;
    L1293 :;
    for (i=(int64_t)1;i<=(int64_t)2;i+=(int64_t)1) {
L1294 :;
        p = mm_decls_userxmodelist;
        rescan = (int64_t)0;
        L1297 :;
        while (!!(p)) {
            m = (int64_t)((*(*p).pmode));
            if ((m < (int64_t)0)) {
                m = mm_name_fixmode2((*p).owner,m);
                if ((((m < (int64_t)0) && (i == (int64_t)2)) && !!(mm_decls_ttxmap[(labs(m))]))) {
                    m = mm_decls_ttxmap[(labs(m))];
                };
                if ((m < (int64_t)0)) {
                    rescan = (int64_t)1;
                } else {
                    (*(*p).pmode) = m;
                    if (((int64_t)(mm_decls_tttarget[(m)]) == m)) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_str((uint8_t*)"TTNAME[M]=",NULL);
                        msysnewc_m_print_str(mm_decls_ttname[(m)],NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        mm_support_rxerror((uint8_t*)"RECURSIVE TYPE?",(struct mm_decls_unitrec *)(0));
                    };
                };
            };
            p = (*p).nextmode;
L1298 :;
        }L1299 :;
        ;
        if (!(!!(rescan))) {
            goto L1296 ;
        };
L1295 :;
    }L1296 :;
    ;
    if (!!(rescan)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Type phase errors - check these user types:",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        p = mm_decls_userxmodelist;
        L1300 :;
        while (!!(p)) {
            m = (int64_t)((*(*p).pmode));
            if ((m < (int64_t)0)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"\t",NULL);
                msysnewc_m_print_str((mm_lib_strmode(m,(int64_t)1) + (int64_t)1),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            p = (*p).nextmode;
L1301 :;
        }L1302 :;
        ;
        mm_support_rxerror((uint8_t*)"Stopping due to phase error",(struct mm_decls_unitrec *)(0));
    };
}

static void mm_name_rx_assem(struct mm_decls_strec * owner,struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_strec *  d;
    uint8_t *  s;
    uint8_t *  pdest;
    uint8_t str[512];
    int64_t c;
    q = b;
    L1303 :;
    while (!!(q)) {
        if (((int64_t)((*q).tag) == (int64_t)3)) {
            mm_name_resolvename(owner,q);
        };
        q = (*q).nextunit;
L1304 :;
    }L1305 :;
    ;
    pdest = str;
    s = (*a).svalue;
    q = b;
    L1306 :;
    while (!!((c = (int64_t)((*s++))))) {
        if ((c == (int64_t)35)) {
            if (((int64_t)((*q).tag)==(int64_t)3)) {
                d = (*q).def;
                if (((int64_t)((*d).nameid)==(int64_t)8)) {
                    mm_type_tx_namedconst(d);
                }else if (((int64_t)((*d).nameid)==(int64_t)10) || ((int64_t)((*d).nameid)==(int64_t)11)) {
                } else {
                };
            }else if (((int64_t)((*q).tag)==(int64_t)1)) {
                if ((!(mm_decls_ttisint[((int64_t)((*q).mode))]) != (int64_t)73)) {
                    mm_support_rxerror((uint8_t*)"assem/macro/not int",(struct mm_decls_unitrec *)(0));
                };
            } else {
                mm_support_rxerror((uint8_t*)"assem/macro/arg?",(struct mm_decls_unitrec *)(0));
            };
            q = (*q).nextunit;
        } else {
        };
L1307 :;
    }L1308 :;
    ;
    (*pdest) = (uint64_t)0u;
    (*a).svalue = mlib_pcm_copyheapstring(str);
    (*a).slength = (int64_t)(strlen((int8_t *)(str)));
}

struct mm_decls_strec * mm_name_resolve_equiv_name(struct mm_decls_strec * owner,struct mm_decls_strec * p) {
    if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)12)) {
        return p;
    };
    mm_support_rxerror((uint8_t*)"RESOLVE EQUIV FIELD/COMPLEX",(struct mm_decls_unitrec *)(0));
    return (struct mm_decls_strec *)(0);
}

static struct mm_decls_strec * mm_name_addframevar(struct mm_decls_strec * owner,struct mm_decls_strec * d,int64_t moduleno,int64_t mode) {
    struct mm_decls_strec *  e;
    e = mm_lib_getduplnameptr(owner,d,(int64_t)10);
    mm_lib_storemode((int64_t)1,owner,mode,&(*e).mode);
    mm_lib_adddef(owner,e);
    return e;
}

static void mm_name_converteqeq(struct mm_decls_strec * owner,struct mm_decls_unitrec * p) {
    int64_t leftop;
    int64_t rightop;
    struct mm_decls_unitrec *  w;
    struct mm_decls_unitrec *  y1;
    struct mm_decls_unitrec *  y2;
    struct mm_decls_unitrec *  z;
    w = (*p).a;
    y1 = (*w).b;
    y2 = mm_lib_duplunit(y1,(int64_t)0);
    z = (*p).b;
    leftop = (int64_t)((*w).tag);
    rightop = (int64_t)((*p).tag);
    (*p).tag = (int64_t)12;
    (*p).b = mm_lib_createunit2(rightop,y2,z);
    (*(*p).b).lineno = (int64_t)((*p).lineno);
    mm_name_rx_unitlist(owner,w);
    mm_name_rx_unitlist(owner,y2);
    mm_name_rx_unitlist(owner,z);
}

static struct mm_decls_unitrec * mm_name_copylistunit(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  plist;
    struct mm_decls_unitrec *  plistx;
    plist = (plistx = (struct mm_decls_unitrec *)(0));
    L1309 :;
    while (!!(p)) {
        q = mm_name_copyunit(p);
        mm_lib_addlistunit(&plist,&plistx,q);
        p = (*p).nextunit;
L1310 :;
    }L1311 :;
    ;
    return plist;
}

static struct mm_decls_unitrec * mm_name_copyunit(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_strec *  d;
    int64_t i;
    if ((p == 0)) {
        return (struct mm_decls_unitrec *)(0);
    };
    if (((int64_t)((*p).tag) == (int64_t)3)) {
        d = (*p).def;
        L1312 :;
        for (i=(int64_t)1;i<=mm_name_nmacroparams;i+=(int64_t)1) {
L1313 :;
            if ((mm_name_macroparamsgen[(i)-1] == d)) {
                return mm_name_copyunit(mm_name_macroargs[(i)-1]);
                goto L1315 ;
            };
L1314 :;
        }L1315 :;
        ;
    };
    q = mm_lib_createunit0((int64_t)((*p).tag));
    (*q).a = mm_name_copylistunit((*p).a);
    (*q).b = mm_name_copylistunit((*p).b);
    (*q).c = mm_name_copylistunit((*p).c);
    (*q).lineno = (int64_t)((*p).lineno);
    (*q).value = (*p).value;
    (*q).opcode = (int64_t)((*p).opcode);
    (*q).mode = (int64_t)((*p).mode);
    (*q).newmode = (int64_t)((*p).newmode);
    (*q).moduleno = (int64_t)((*p).moduleno);
    (*q).isastring = (int64_t)((*p).isastring);
    (*q).nextunit = (struct mm_decls_unitrec *)(0);
    (*q).reginfo = (*p).reginfo;
    return q;
}

static void mm_name_replaceunit(struct mm_decls_unitrec * p,struct mm_decls_unitrec * q) {
    struct mm_decls_unitrec *  pnext;
    pnext = (*p).nextunit;
    (*p) = (*q);
    (*p).nextunit = pnext;
}

static void mm_name_expandmacro(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  pm;
    struct mm_decls_unitrec *  pnew;
    int64_t ignoreargs;
    if ((mm_name_macrolevels > (int64_t)10)) {
        mm_support_rxerror((uint8_t*)"Too many macro levels (recursive macro?)",(struct mm_decls_unitrec *)(0));
    };
    d = (*a).def;
    pm = (*d).paramlist;
    mm_name_nmacroparams = (int64_t)0;
    L1316 :;
    while (!!(pm)) {
        if ((mm_name_nmacroparams >= (int64_t)50)) {
            mm_support_rxerror((uint8_t*)"macro param overflow",(struct mm_decls_unitrec *)(0));
        };
        mm_name_macroparams[(++mm_name_nmacroparams)-1] = pm;
        mm_name_macroparamsgen[(mm_name_nmacroparams)-1] = (*pm).nulldef;
        pm = (*pm).nextparam;
L1317 :;
    }L1318 :;
    ;
    mm_name_nmacroargs = (int64_t)0;
    L1319 :;
    while (!!(b)) {
        if ((mm_name_nmacroargs >= (int64_t)50)) {
            mm_support_rxerror((uint8_t*)"macro arg overflow",(struct mm_decls_unitrec *)(0));
        };
        mm_name_macroargs[(++mm_name_nmacroargs)-1] = b;
        b = (*b).nextunit;
L1320 :;
    }L1321 :;
    ;
    if ((mm_name_nmacroargs < mm_name_nmacroparams)) {
        mm_support_rxerror((uint8_t*)"Too few macro args",(struct mm_decls_unitrec *)(0));
    };
    ignoreargs = (int64_t)0;
    if (((mm_name_nmacroargs > (int64_t)0) && (mm_name_nmacroparams == (int64_t)0))) {
        ignoreargs = (int64_t)1;
        mm_name_nmacroargs = (mm_name_nmacroparams = (int64_t)0);
    } else if ((mm_name_nmacroargs > mm_name_nmacroparams)) {
        mm_support_rxerror((uint8_t*)"Too many macro args",(struct mm_decls_unitrec *)(0));
    };
    pnew = mm_name_copyunit((*d).code);
    if (!(!!(ignoreargs))) {
        mm_name_replaceunit(p,pnew);
    } else {
        (*p).a = pnew;
    };
}

static void mm_name_duplfield(struct mm_decls_strec * owner,struct mm_decls_strec * p,struct mm_decls_strec * q) {
    if (!!((*p).code)) {
        mm_support_serror((uint8_t*)"DUPLFIELD");
    };
    (*q).at = (uint64_t)((*p).at);
    (*q).uflags = (*p).uflags;
    mm_lib_storemode((int64_t)16,owner,(int64_t)((*p).mode),&(*q).mode);
}

static void mm_name_do_baseclass(struct mm_decls_strec * p) {
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    struct mm_decls_strec *  newd;
    struct mm_decls_strec *  dbase;
    int64_t normalexit;
    dbase = mm_decls_ttnamedef[((int64_t)((*p).baseclass))];
    d = (*dbase).deflist;
    L1322 :;
    while (!!(d)) {
        e = (*p).deflist;
        normalexit = (int64_t)1;
        L1325 :;
        while (!!(e)) {
            if (!!(mlib_eqstring((*d).name,(*e).name))) {
                normalexit = (int64_t)0;
                goto L1327 ;
            };
            e = (*e).nextdef;
L1326 :;
        }L1327 :;
        ;
        if (!!(normalexit)) {
            if (((int64_t)((*d).nameid)==(int64_t)5)) {
                newd = mm_lib_getduplnameptr(p,d,(int64_t)20);
                (*newd).equivfield = d;
            } else {
                newd = mm_lib_getduplnameptr(p,d,(int64_t)((*d).nameid));
                mm_name_duplfield((*p).owner,d,newd);
            };
            mm_lib_adddef(p,newd);
        };
        d = (*d).nextdef;
L1323 :;
    }L1324 :;
    ;
}

void mm_type_tx_allprocs(void) {
    struct mm_decls_procrec *  pp;
    pp = mm_decls_proclist;
    L1328 :;
    while (!!(pp)) {
        mm_decls_currproc = (*pp).def;
        mm_type_tpass((*mm_decls_currproc).code,(((int64_t)((uint64_t)((*mm_decls_currproc).nretvalues)) > (int64_t)1)?(int64_t)36:(int64_t)((*mm_decls_currproc).mode)),(int64_t)0);
        pp = (*pp).nextproc;
L1329 :;
    }L1330 :;
    ;
}

static void mm_type_tpass(struct mm_decls_unitrec * p,int64_t t,int64_t lv) {
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    int64_t oldmlineno;
    int64_t m;
    int64_t paramtype;
    int64_t restype;
    if ((p == 0)) {
        return;
    };
    if ((((lv == (int64_t)1) || (lv == (int64_t)2) || (lv == (int64_t)4)) && (!(!!((uint64_t)(mm_tables_refunitset[((int64_t)((*p).tag))]))) || ((int64_t)((*p).tag) == (int64_t)89)))) {
        if (((int64_t)((*p).tag)==(int64_t)1) || ((int64_t)((*p).tag)==(int64_t)31) || ((int64_t)((*p).tag)==(int64_t)201)) {
            mm_support_txerror((uint8_t*)"not allowed as lvalue",(struct mm_decls_unitrec *)(0));
        };
    };
    oldmlineno = mm_decls_mlineno;
    mm_decls_mlineno = (int64_t)((*p).lineno);
    a = (*p).a;
    b = (*p).b;
    switch ((int64_t)((*p).tag)) {
    case 3:;
    {
        mm_type_tx_name(p,t,lv);
    }break;
    case 1:;
    case 6:;
    {
    }break;
    case 106:;
    {
        (*p).mode = (int64_t)4;
    }break;
    case 139:;
    case 138:;
    {
        mm_type_tx_bytesize(p,a);
    }break;
    case 43:;
    case 44:;
    {
        mm_type_tx_add(p,a,b);
    }break;
    case 45:;
    case 46:;
    case 47:;
    case 48:;
    case 60:;
    case 61:;
    {
        mm_type_tx_mul(p,a,b);
    }break;
    case 205:;
    case 207:;
    {
        mm_type_tx_assign(p,a,b,(int64_t)0);
    }break;
    case 29:;
    case 30:;
    {
        mm_type_tx_assign(p,a,b,t);
    }break;
    case 25:;
    {
        L1331 :;
        while (!!(a)) {
            mm_type_tpass(a,(int64_t)20,(int64_t)0);
            a = (*a).nextunit;
L1332 :;
        }L1333 :;
        ;
    }break;
    case 97:;
    case 132:;
    {
        mm_type_tx_atan2(p,a,b);
    }break;
    case 53:;
    case 54:;
    {
        mm_type_tx_shl(p,a,b);
    }break;
    case 50:;
    case 51:;
    case 52:;
    {
        mm_type_tx_iand(p,a,b);
    }break;
    case 36:;
    case 37:;
    {
        mm_type_tx_eq(p,a,b);
    }break;
    case 38:;
    case 39:;
    case 41:;
    case 40:;
    {
        mm_type_tx_lt(p,a,b);
    }break;
    case 42:;
    {
        mm_type_tx_isequal(p,a,b);
    }break;
    case 100:;
    {
        if (((int64_t)((*a).tag) == (int64_t)99)) {
            mm_lib_deleteunit(p,a);
            mm_lib_deleteunit(p,(*p).a);
            mm_type_tpass(p,t,(int64_t)0);
        } else {
            mm_type_tpass(a,(int64_t)20,(int64_t)1);
            (*p).mode = mm_lib_createrefmode((struct mm_decls_strec *)(0),(int64_t)((*a).mode),(int64_t)0);
        };
    }break;
    case 101:;
    {
        mm_type_tx_addroffirst(p,a,t);
    }break;
    case 151:;
    case 152:;
    case 153:;
    case 154:;
    case 155:;
    case 160:;
    case 161:;
    case 166:;
    case 167:;
    case 156:;
    {
        mm_type_tx_addto(p,a,b);
    }break;
    case 157:;
    case 158:;
    case 159:;
    case 162:;
    case 163:;
    case 164:;
    case 165:;
    {
        mm_type_tx_iandto(p,a,b);
    }break;
    case 209:;
    {
        mm_type_tx_if(p,a,b,(*p).c,t,lv);
    }break;
    case 210:;
    {
        mm_type_tx_longif(p,a,b,t,lv);
    }break;
    case 88:;
    {
        mm_type_tx_index(p,a,b,t,lv);
    }break;
    case 99:;
    {
        mm_type_tx_ptr(p,a,t,lv);
    }break;
    case 201:;
    case 31:;
    case 202:;
    case 32:;
    {
        mm_type_tx_callproc(p,a,b,t);
    }break;
    case 95:;
    {
        mm_type_tx_dot(p,a,b,lv);
    }break;
    case 114:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    case 125:;
    case 126:;
    case 127:;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    {
        mm_type_tx_sqrt(p,a);
    }break;
    case 117:;
    {
        mm_type_tx_sign(p,a);
    }break;
    case 98:;
    {
        mm_type_tx_power(p,a,b);
    }break;
    case 12:;
    case 13:;
    case 14:;
    case 17:;
    case 18:;
    {
        mm_type_tx_andl(p,a,b);
    }break;
    case 109:;
    case 110:;
    case 115:;
    case 116:;
    {
        mm_type_tx_neg(p,a,b);
    }break;
    case 111:;
    {
        mm_type_tx_inot(p,a);
    }break;
    case 15:;
    {
        mm_type_tx_notl(p,a);
    }break;
    case 16:;
    {
        mm_type_tx_istruel(p,a);
    }break;
    case 102:;
    {
        mm_type_tx_convert(p,a,(int64_t)1);
    }break;
    case 105:;
    {
        mm_type_tx_typepun(p,a,lv);
    }break;
    case 135:;
    {
        mm_type_tx_len(p,a);
    }break;
    case 137:;
    {
        mm_type_tx_lenstr(p,a);
    }break;
    case 133:;
    {
        mm_type_tx_lwb(p,a);
    }break;
    case 134:;
    {
        mm_type_tx_upb(p,a);
    }break;
    case 136:;
    {
        mm_type_tx_bounds(p,a);
    }break;
    case 87:;
    {
        mm_type_tx_sliceptr(p,a);
    }break;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    {
        mm_type_tx_preincr(p,a,t);
    }break;
    case 20:;
    {
        mm_type_tx_makerange(p,a,b);
    }break;
    case 21:;
    {
        mm_type_tx_makeset(p,a,t);
    }break;
    case 22:;
    {
        mm_type_tx_makedict(p,a,t);
    }break;
    case 228:;
    {
        mm_type_tx_swap(p,a,b);
    }break;
    case 229:;
    {
        mm_type_tx_select(p,a,b,(*p).c,t,lv);
    }break;
    case 226:;
    case 227:;
    {
        mm_type_tx_switch(p,a,b,(*p).c,t,lv);
    }break;
    case 224:;
    case 225:;
    {
        mm_type_tx_case(p,a,b,(*p).c,t,lv);
    }break;
    case 24:;
    {
        mm_type_tx_exprlist(p,a,t);
    }break;
    case 90:;
    case 91:;
    case 92:;
    {
        mm_type_tx_dotindex(p,a,b,lv);
    }break;
    case 89:;
    {
        mm_type_tx_slice(p,a,b);
    }break;
    case 94:;
    {
        mm_type_tx_keyindex(p,a,b,(*p).c,lv);
    }break;
    case 143:;
    case 144:;
    {
        mm_type_tx_minvalue(p,a);
    }break;
    case 170:;
    case 171:;
    case 172:;
    case 173:;
    {
        if (!!(b)) {
            mm_support_txerror((uint8_t*)"Extra operand for unary op",(struct mm_decls_unitrec *)(0));
        };
        mm_type_tx_negto(p,a);
    }break;
    case 4:;
    case 5:;
    {
        mm_type_tx_block(p,a,t,lv);
    }break;
    case 248:;
    {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        (*p).mode = (int64_t)((*a).mode);
    }break;
    case 223:;
    {
        mm_type_tpass(a,(int64_t)0,(int64_t)0);
    }break;
    case 203:;
    {
        mm_type_tx_return(p,a,t);
    }break;
    case 231:;
    case 232:;
    case 233:;
    case 234:;
    {
        mm_type_tx_unitlist(a,(int64_t)20,(int64_t)0);
        L1334 :;
        while (!!(b)) {
            if (((int64_t)((*b).tag) == (int64_t)199)) {
                mm_type_tpass((*b).a,(int64_t)20,(int64_t)0);
                mm_type_tpass((*b).b,mm_tables_trefchar,(int64_t)0);
            } else {
                mm_type_tpass(b,(int64_t)20,(int64_t)0);
            };
            b = (*b).nextunit;
L1335 :;
        }L1336 :;
        ;
        mm_type_tx_unitlist((*p).c,(int64_t)20,(int64_t)0);
    }break;
    case 211:;
    case 212:;
    {
        mm_type_tx_for(a,b,(*p).c);
    }break;
    case 208:;
    {
        mm_type_tpass(a,(int64_t)4,(int64_t)0);
        mm_type_tpass(b,(int64_t)0,(int64_t)0);
    }break;
    case 104:;
    {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        if ((t == (int64_t)20)) {
            mm_support_txerror((uint8_t*)"cast() needs type",(struct mm_decls_unitrec *)(0));
        };
        mm_type_coerceunit(a,t,(int64_t)1);
        mm_lib_deleteunit(p,a);
    }break;
    case 19:;
    {
        mm_type_tx_makelist(p,a,t,lv);
    }break;
    case 243:;
    {
        mm_type_tpass(a,(int64_t)4,(int64_t)0);
    }break;
    case 222:;
    case 220:;
    case 219:;
    case 221:;
    {
        mm_type_tx_exit(p,a);
    }break;
    case 216:;
    {
        mm_type_tx_goto(p,a);
    }break;
    case 218:;
    {
    }break;
    case 214:;
    {
        mm_type_tcond(a);
        mm_type_tpass(b,(int64_t)0,(int64_t)0);
    }break;
    case 215:;
    {
        mm_type_tpass(a,(int64_t)0,(int64_t)0);
        mm_type_tcond(b);
    }break;
    case 200:;
    {
    }break;
    case 7:;
    {
        if ((t != (int64_t)0)) {
            (*p).mode = t;
        };
        mm_type_inassem = (int64_t)1;
        mm_type_tx_unitlist(a,(int64_t)20,(int64_t)0);
        mm_type_tx_unitlist(b,(int64_t)20,(int64_t)0);
        mm_type_tx_unitlist((*p).c,(int64_t)20,(int64_t)0);
        mm_type_inassem = (int64_t)0;
    }break;
    case 9:;
    case 10:;
    {
    }break;
    case 11:;
    {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
    }break;
    case 140:;
    {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        if (((int64_t)((*a).tag) == (int64_t)106)) {
            (*p).value = (*a).value;
        } else {
            (*p).value = (int64_t)((*a).mode);
        };
        (*p).tag = (int64_t)106;
        (*p).mode = (int64_t)4;
        (*p).a = (struct mm_decls_unitrec *)(0);
    }break;
    case 141:;
    {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        if (((int64_t)((*a).tag) == (int64_t)106)) {
            m = (*a).value;
        } else {
            mm_type_tpass(a,(int64_t)20,(int64_t)0);
            m = (int64_t)((*a).mode);
        };
        (*p).tag = (int64_t)1;
        (*p).mode = mm_tables_trefchar;
        (*p).svalue = mlib_pcm_copyheapstring(mm_lib_strmode(m,(int64_t)0));
        (*p).slength = (int64_t)(strlen((int8_t *)((*p).svalue)));
        (*p).isastring = (int64_t)1;
        (*p).a = (struct mm_decls_unitrec *)(0);
    }break;
    case 103:;
    {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
    }break;
    case 199:;
    {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        mm_type_tpass(b,(int64_t)20,(int64_t)0);
    }break;
    case 240:;
    {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
    }break;
    case 239:;
    {
        if (!!(a)) {
            mm_type_tpass(a,(int64_t)15,(int64_t)0);
        };
        if (!!((uint64_t)(mm_decls_ttisnumeric[(t)]))) {
            t = (int64_t)(mm_tables_stdtypebase[((int64_t)(mm_decls_ttbasetype[(t)]))]);
        };
        (*p).mode = t;
    }break;
    case 55:;
    case 56:;
    {
        mm_type_tx_in(p,a,b);
    }break;
    case 230:;
    {
        mm_type_tpass(a,(int64_t)4,(int64_t)0);
        if (((int64_t)((*a).tag) != (int64_t)1)) {
            mm_support_txerror((uint8_t*)"recase must be const",(struct mm_decls_unitrec *)(0));
        };
    }break;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 78:;
    case 68:;
    case 69:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 76:;
    {
        mm_type_tx_head(p,a,b);
    }break;
    case 81:;
    case 66:;
    case 65:;
    {
        mm_type_tx_concat(p,a,b);
    }break;
    case 185:;
    {
        (*p).mode = (int64_t)4;
    }break;
    case 188:;
    case 187:;
    {
        (*p).mode = mm_tables_trefchar;
    }break;
    case 142:;
    {
        mm_type_tx_bitfield(p,a,lv);
    }break;
    case 250:;
    {
    }break;
    case 204:;
    {
        restype = (int64_t)0;
        paramtype = (int64_t)0;
        if (((int64_t)((*p).opcode)==(int64_t)46)) {
            restype = (int64_t)4;
        }else if (((int64_t)((*p).opcode)==(int64_t)47)) {
            restype = (int64_t)4;
        }else if (((int64_t)((*p).opcode)==(int64_t)48)) {
            paramtype = (int64_t)4;
            restype = mm_tables_trefchar;
        }else if (((int64_t)((*p).opcode)==(int64_t)49)) {
            paramtype = (int64_t)4;
            restype = (int64_t)19;
        }else if (((int64_t)((*p).opcode)==(int64_t)50)) {
            paramtype = (int64_t)4;
            restype = (int64_t)19;
        };
        if ((paramtype != (int64_t)0)) {
            if ((a == 0)) {
                mm_support_txerror((uint8_t*)"sys: arg missing",(struct mm_decls_unitrec *)(0));
            };
            mm_type_tpass(a,paramtype,(int64_t)0);
            if (!!((*a).nextunit)) {
                mm_support_txerror((uint8_t*)"sys: too many args",(struct mm_decls_unitrec *)(0));
            };
        } else if (!!(a)) {
            mm_support_txerror((uint8_t*)"sys: too many args",(struct mm_decls_unitrec *)(0));
        };
        (*p).mode = restype;
    }break;
    case 113:;
    {
        mm_type_tpass(a,(int64_t)33,(int64_t)0);
        (*p).mode = (int64_t)4;
    }break;
    case 112:;
    {
        mm_type_tpass(a,(int64_t)33,(int64_t)0);
        (*p).mode = (int64_t)33;
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"TXUNIT: CAN'T DO:",NULL);
        msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        //doelse:
L1337 :;
;
        mm_type_tx_unitlist(a,t,(int64_t)0);
        mm_type_tx_unitlist(b,t,(int64_t)0);
        mm_type_tx_unitlist((*p).c,t,(int64_t)0);
    }
    } //SW
;
    mm_type_tevaluate(p);
    if (((int64_t)((*p).tag)==(int64_t)19) || ((int64_t)((*p).tag)==(int64_t)203)) {
    } else {
        if ((((t != (int64_t)20) && (t != (int64_t)0)) && ((int64_t)((*p).mode) != t))) {
            mm_type_coerceunit(p,t,(int64_t)0);
        };
    };
    if ((t == (int64_t)0)) {
        mm_type_fixvoidunit(p);
    };
    mm_decls_mlineno = oldmlineno;
}

static void mm_type_tx_block(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t,int64_t lv) {
    L1338 :;
    while ((!!(a) && !!((*a).nextunit))) {
        mm_type_tpass(a,(int64_t)0,(int64_t)0);
        a = (*a).nextunit;
L1339 :;
    }L1340 :;
    ;
    if (!!(a)) {
        mm_type_tx_unitlist(a,t,lv);
        (*p).mode = ((t != (int64_t)0)?(int64_t)((*a).mode):(int64_t)0);
    };
}

void mm_type_tx_typetable(void) {
    struct mm_decls_strec *  d;
    int64_t i;
    L1341 :;
    for (i=(int64_t)37;i<=mm_decls_ntypes;i+=(int64_t)1) {
L1342 :;
        if (((int64_t)(mm_decls_ttbasetype[(i)]) == (int64_t)25)) {
            mm_type_tx_passdef((d = mm_decls_ttnamedef[(i)]));
        };
        mm_type_setmodesize(i);
L1343 :;
    }L1344 :;
    ;
}

static void mm_type_setmodesize(int64_t m) {
    if (!!((int64_t)(mm_decls_ttsize[(m)]))) {
        return;
    };
    mm_decls_mlineno = (int64_t)(mm_decls_ttlineno[(m)]);
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)24)) {
        mm_type_setarraysize(m);
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)25)) {
        mm_type_setrecordsize(m);
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)0) || ((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)26)) {
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)23)) {
        mm_type_setslicesize(m);
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)34)) {
        mm_support_txerror((uint8_t*)"SETMODESIZE/AUTO?",(struct mm_decls_unitrec *)(0));
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)20)) {
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"SIZE 0:",NULL);
        msysnewc_m_print_str(mm_lib_strmode(m,(int64_t)1),NULL);
        msysnewc_m_print_str((uint8_t*)"M=",NULL);
        msysnewc_m_print_i64(m,NULL);
        msysnewc_m_print_str(mm_tables_stdtypenames[((int64_t)(mm_decls_ttbasetype[(m)]))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"********",NULL);
        msysnewc_m_print_ptr(mm_decls_ttnamedef[(m)],NULL);
        msysnewc_m_print_ptr(mm_decls_ttowner[(m)],NULL);
        msysnewc_m_print_str((uint8_t*)"M=",NULL);
        msysnewc_m_print_i64(m,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Can't set mode size",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void mm_type_setarraysize(int64_t m) {
    int64_t lower;
    int64_t length;
    int64_t elemsize;
    int64_t target;
    struct mm_decls_unitrec *  pdim;
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    if (!!((uint64_t)(mm_decls_ttsizeset[(m)]))) {
        return;
    };
    pdim = mm_decls_ttdimexpr[(m)];
    if (!!(pdim)) {
        a = (*pdim).a;
        b = (*pdim).b;
        mm_name_rx_unit(mm_decls_ttowner[(m)],pdim);
        if (((int64_t)((*pdim).tag)==(int64_t)20)) {
            mm_type_tpass(a,(int64_t)20,(int64_t)0);
            mm_type_tpass(b,(int64_t)20,(int64_t)0);
            lower = mm_type_getconstint(a,(int64_t)20);
            length = ((mm_type_getconstint(b,(int64_t)20) - lower) + (int64_t)1);
        }else if (((int64_t)((*pdim).tag)==(int64_t)28)) {
            mm_type_tpass(a,(int64_t)20,(int64_t)0);
            lower = mm_type_getconstint(a,(int64_t)20);
            if (!!(b)) {
                mm_type_tpass(b,(int64_t)20,(int64_t)0);
                length = mm_type_getconstint(b,(int64_t)20);
            } else {
                length = (int64_t)0;
            };
        } else {
            mm_type_tpass(pdim,(int64_t)20,(int64_t)0);
            length = mm_type_getconstint(pdim,(int64_t)20);
            lower = (int64_t)1;
        };
    } else {
        lower = (int64_t)1;
        length = (int64_t)0;
    };
    mm_decls_ttdimexpr[(m)] = (struct mm_decls_unitrec *)(0);
    mm_decls_ttlower[(m)] = lower;
    mm_decls_ttlength[(m)] = length;
    target = (int64_t)(mm_decls_tttarget[(m)]);
    mm_type_setmodesize(target);
    elemsize = (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[(m)]))]);
    mm_decls_ttsize[(m)] = (length * elemsize);
    mm_decls_ttsizeset[(m)] = (uint64_t)((int64_t)1);
    if ((lower==(int64_t)1)) {
        ++mm_decls_nonebased;
    }else if ((lower==(int64_t)0)) {
        ++mm_decls_nzerobased;
    } else {
        ++mm_decls_notherbased;
    };
}

static void mm_type_setslicesize(int64_t m) {
    struct mm_decls_unitrec *  pdim;
    if (!!((int64_t)(mm_decls_ttsize[(m)]))) {
        return;
    };
    pdim = mm_decls_ttdimexpr[(m)];
    if (!!(pdim)) {
        mm_name_rx_unit(mm_decls_ttowner[(m)],pdim);
        mm_type_tpass(pdim,(int64_t)20,(int64_t)0);
        mm_decls_ttlower[(m)] = mm_type_getconstint(pdim,(int64_t)20);
        mm_decls_ttdimexpr[(m)] = (struct mm_decls_unitrec *)(0);
    } else {
        mm_decls_ttlower[(m)] = (int64_t)1;
    };
    mm_type_setmodesize((int64_t)(mm_decls_tttarget[(m)]));
    mm_decls_ttsize[(m)] = (int64_t)(mm_decls_ttsize[((int64_t)23)]);
}

static void mm_type_tcond(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    a = (*p).a;
    b = (*p).b;
    if (((int64_t)((*p).tag)==(int64_t)12) || ((int64_t)((*p).tag)==(int64_t)13) || ((int64_t)((*p).tag)==(int64_t)14)) {
        mm_type_tcond(a);
        mm_type_tcond(b);
    }else if (((int64_t)((*p).tag)==(int64_t)15)) {
        mm_type_tcond(a);
        if (((int64_t)((*a).tag) == (int64_t)15)) {
            mm_lib_deleteunit(p,a);
            (*p).tag = (int64_t)16;
            if (!!((uint64_t)(mm_tables_boolunitset[((int64_t)((*(*p).a).tag))]))) {
                mm_lib_deleteunit(p,(*p).a);
            };
        };
    }else if (((int64_t)((*p).tag)==(int64_t)16)) {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        if (!!((uint64_t)(mm_tables_boolunitset[((int64_t)((*a).tag))]))) {
            mm_lib_deleteunit(p,a);
        };
    } else {
        mm_type_tpass(p,(int64_t)20,(int64_t)0);
        mm_type_twidenopnd(p);
        if (!(!!((uint64_t)(mm_tables_boolunitset[((int64_t)((*p).tag))])))) {
            mm_lib_insertunit(p,(int64_t)16);
        };
    };
    (*p).mode = (int64_t)4;
}

int64_t mm_type_tx_module(int64_t n) {
    mm_decls_currmoduleno = n;
    mm_type_tx_passdef(mm_decls_moduletable[(n)].stmodule);
    return (int64_t)1;
}

void mm_type_tx_passdef(struct mm_decls_strec * p) {
    struct mm_decls_strec *  d;
    int64_t oldmlineno;
    int64_t simplefunc;
    struct mm_decls_unitrec *  q;
    if (!!((uint64_t)((*p).txdone))) {
        return;
    };
    oldmlineno = mm_decls_mlineno;
    mm_decls_mlineno = (int64_t)((*p).lineno);
    simplefunc = (int64_t)1;
    d = (*p).deflist;
    L1345 :;
    while (!!(d)) {
        mm_type_tx_passdef(d);
        if ((((int64_t)((uint64_t)((*p).nameid)) == (int64_t)5) && (((*d).nameid == (int64_t)10) || ((*d).nameid == (int64_t)11)))) {
            if (!(!!(mm_lib_issimpletype((int64_t)((*d).mode))))) {
                simplefunc = (int64_t)0;
            };
        };
        d = (*d).nextdef;
L1346 :;
    }L1347 :;
    ;
    q = (*p).code;
    if (((int64_t)((*p).nameid)==(int64_t)5)) {
        if ((((int64_t)((uint64_t)((*p).nretvalues)) > (int64_t)1) || !(!!(mm_lib_issimpletype((int64_t)((*p).mode)))))) {
            simplefunc = (int64_t)0;
        };
        (*p).simplefunc = (uint64_t)(simplefunc);
        mm_decls_currproc = (struct mm_decls_strec *)(0);
    }else if (((int64_t)((*p).nameid)==(int64_t)8) || ((int64_t)((*p).nameid)==(int64_t)14)) {
        mm_type_tx_namedconst(p);
    }else if (((int64_t)((*p).nameid)==(int64_t)9) || ((int64_t)((*p).nameid)==(int64_t)10) || ((int64_t)((*p).nameid)==(int64_t)11)) {
        mm_type_tx_namedef(p);
    };
    (*p).txdone = (uint64_t)((int64_t)1);
    mm_decls_mlineno = oldmlineno;
}

static void mm_type_tx_unitlist(struct mm_decls_unitrec * p,int64_t t,int64_t lv) {
    L1348 :;
    while (!!(p)) {
        mm_type_tpass(p,t,(int64_t)0);
        p = (*p).nextunit;
L1349 :;
    }L1350 :;
    ;
}

static void mm_type_tx_namedef(struct mm_decls_strec * d) {
    int64_t m;
    struct mm_decls_unitrec *  dcode;
    m = (int64_t)((*d).mode);
    mm_type_setmodesize(m);
    if (!!((uint64_t)((*d).circflag))) {
        mm_support_txerror((uint8_t*)"Circular reference detected",(struct mm_decls_unitrec *)(0));
    };
    if (!!((uint64_t)((*d).txdone))) {
        return;
    };
    dcode = (*d).code;
    (*d).circflag = (uint64_t)((int64_t)1);
    if (((int64_t)((uint64_t)((*d).at)) == (int64_t)1)) {
        mm_type_tpass((*d).equivvar,(int64_t)19,(int64_t)0);
    };
    if ((!!(dcode) && ((int64_t)((uint64_t)((*d).nameid)) != (int64_t)10))) {
        if (((((int64_t)(mm_decls_ttbasetype[(m)]) == (int64_t)23) && ((int64_t)((*dcode).tag) == (int64_t)1)) && ((int64_t)((*dcode).mode) == mm_tables_trefchar))) {
            mm_type_tpass(dcode,mm_tables_trefchar,(int64_t)0);
        } else {
            mm_type_tpass(dcode,m,(int64_t)0);
        };
        (*d).circflag = (uint64_t)((int64_t)0);
        (*d).txdone = (uint64_t)((int64_t)1);
        if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)9)) {
            mm_type_checkconstexpr((*d).code);
        };
        if ((((int64_t)(mm_decls_ttbasetype[(m)]) == (int64_t)24) && ((int64_t)(mm_decls_ttlength[(m)]) == (int64_t)0))) {
            (*d).mode = (int64_t)((*dcode).mode);
        };
    } else if ((((!!(dcode) && ((int64_t)((uint64_t)((*d).nameid)) == (int64_t)10)) && ((int64_t)(mm_decls_ttbasetype[(m)]) == (int64_t)24)) && ((int64_t)(mm_decls_ttlength[(m)]) == (int64_t)0))) {
        mm_type_tpass(dcode,m,(int64_t)0);
        (*d).mode = (int64_t)((*dcode).mode);
        (*d).circflag = (uint64_t)((int64_t)0);
        (*d).txdone = (uint64_t)((int64_t)1);
    } else {
        (*d).circflag = (uint64_t)((int64_t)0);
        (*d).txdone = (uint64_t)((int64_t)1);
    };
}

void mm_type_tx_namedconst(struct mm_decls_strec * d) {
    int64_t m;
    struct mm_decls_unitrec *  q;
    if (!!((uint64_t)((*d).circflag))) {
        mm_support_txerror((uint8_t*)"Circular const reference detected",(struct mm_decls_unitrec *)(0));
    };
    if (!!((uint64_t)((*d).txdone))) {
        return;
    };
    q = (*d).code;
    m = (int64_t)((*d).mode);
    (*d).circflag = (uint64_t)((int64_t)1);
    mm_type_tx_expr(q,((m == (int64_t)34)?(int64_t)20:m));
    (*d).circflag = (uint64_t)((int64_t)0);
    mm_type_checkconstexpr(q);
    if ((m == (int64_t)34)) {
        (*d).mode = (int64_t)((*q).mode);
    };
    (*d).txdone = (uint64_t)((int64_t)1);
}

static void mm_type_tx_expr(struct mm_decls_unitrec * p,int64_t t) {
    mm_type_tpass(p,t,(int64_t)0);
}

static void mm_type_checkconstexpr(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  q;
    if (((int64_t)((*p).tag)==(int64_t)1)) {
        return;
    }else if (((int64_t)((*p).tag)==(int64_t)19)) {
        q = (*p).a;
        L1351 :;
        while (!!(q)) {
            mm_type_checkconstexpr(q);
            q = (*q).nextunit;
L1352 :;
        }L1353 :;
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)103)) {
        if (((int64_t)(mm_decls_tttarget[((int64_t)((*(*p).a).mode))]) == (int64_t)0)) {
            (*(*p).a).mode = (int64_t)((*p).mode);
            mm_lib_deleteunit(p,(*p).a);
        } else {
            goto L1354 ;
;
        };
    }else if (((int64_t)((*p).tag)==(int64_t)102)) {
        if (((int64_t)((*p).opcode)==(int64_t)1) || ((int64_t)((*p).opcode)==(int64_t)0) || ((int64_t)((*p).opcode)==(int64_t)28)) {
        } else {
            goto L1354 ;
;
        };
    }else if (((int64_t)((*p).tag)==(int64_t)100)) {
        if (((int64_t)((*(*p).a).tag)==(int64_t)3)) {
        } else {
            goto L1354 ;
;
        };
    } else {
        //error:
L1354 :;
;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_tables_jtagnames[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_str(mm_lib_strmode((int64_t)((*p).mode),(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_diags_printunit(p,(int64_t)0,(uint8_t*)"*",0);
        mm_support_txerror((uint8_t*)"Getconstexpr: not const",(struct mm_decls_unitrec *)(0));
    };
}

static int64_t mm_type_getconstint(struct mm_decls_unitrec * q,int64_t t) {
    mm_type_checkconstexpr(q);
    if (!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*q).mode))]))) {
        if (((int64_t)(mm_decls_ttsize[((int64_t)((*q).mode))]) == (int64_t)16)) {
            mm_support_gerror((uint8_t*)"GETCONSTINT/128",(struct mm_decls_unitrec *)(0));
        };
        return (*q).value;
    } else if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*q).mode))]))) {
        return (int64_t)((*q).xvalue);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(mm_lib_strmode((int64_t)((*q).mode),(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_txerror((uint8_t*)"Getconstint: not int32/64",(struct mm_decls_unitrec *)(0));
    };
    return (int64_t)0;
}

static void mm_type_tevaluate(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  a;
    struct mm_decls_unitrec *  b;
    int64_t tag;
    tag = (int64_t)((*p).tag);
    if (!!((uint64_t)(mm_tables_binopset[(tag)]))) {
        mm_type_tevalbinop(p);
    } else if (!!((uint64_t)(mm_tables_monopset[(tag)]))) {
        mm_type_tevalmonop(p);
    } else {
        if ((tag==(int64_t)20)) {
            a = (*p).a;
            b = (*p).b;
            if (((int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))]) <= (int64_t)8)) {
                mm_type_tevaluate(a);
                mm_type_tevaluate(b);
                if ((((int64_t)((*a).tag) == (int64_t)1) && ((int64_t)((*b).tag) == (int64_t)1))) {
                    (*p).isconst = ((int64_t)((*a).isconst) & (int64_t)((*b).isconst));
                };
            };
        }else if ((tag==(int64_t)102)) {
            mm_type_tevalconvert(p);
        };
    };
}

static void mm_type_tevalbinop(struct mm_decls_unitrec * p) {
    int64_t a;
    int64_t b;
    int64_t c;
    double x;
    double y;
    double z;
    if ((((int64_t)((*(*p).a).tag) != (int64_t)1) || ((int64_t)((*(*p).b).tag) != (int64_t)1))) {
        return;
    };
    if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) > (int64_t)8)) {
        return;
    };
    if (!!((uint64_t)(mm_decls_ttisint[((int64_t)((*p).mode))]))) {
        a = (*(*p).a).value;
        b = (*(*p).b).value;
        switch ((int64_t)((*p).tag)) {
        case 43:;
        {
            c = (a + b);
        }break;
        case 44:;
        {
            c = (a - b);
        }break;
        case 45:;
        {
            c = (a * b);
        }break;
        case 46:;
        case 47:;
        {
            if ((b == (int64_t)0)) {
                mm_support_txerror((uint8_t*)"div by 0",(struct mm_decls_unitrec *)(0));
            };
            c = (a / b);
        }break;
        case 48:;
        {
            if ((b == (int64_t)0)) {
                mm_support_txerror((uint8_t*)"div by 0",(struct mm_decls_unitrec *)(0));
            };
            c = (a % b);
        }break;
        case 53:;
        {
            c = (a << b);
        }break;
        case 54:;
        {
            c = (a >> b);
        }break;
        case 50:;
        {
            c = (a & b);
        }break;
        case 51:;
        {
            c = (a | b);
        }break;
        case 52:;
        {
            c = (a ^ b);
        }break;
        default: {
            return;
        }
        } //SW
;
        mm_type_makenewconst(p,c,(int64_t)0);
    } else if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
        x = (*(*p).a).xvalue;
        y = (*(*p).b).xvalue;
        switch ((int64_t)((*p).tag)) {
        case 43:;
        {
            z = (x + y);
        }break;
        case 44:;
        {
            z = (x - y);
        }break;
        case 45:;
        {
            z = (x * y);
        }break;
        case 46:;
        {
            if ((y == (double)0.)) {
                mm_support_txerror((uint8_t*)"div by 0",(struct mm_decls_unitrec *)(0));
            };
            z = (x / y);
        }break;
        default: {
            return;
        }
        } //SW
;
        mm_type_makenewconst(p,*(int64_t*)&z,(int64_t)0);
    };
}

static void mm_type_tevalmonop(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  a;
    int64_t ix;
    int64_t iz;
    double x;
    double z;
    a = (*p).a;
    if (((int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]) > (int64_t)8)) {
        return;
    };
    if (((int64_t)((*a).tag) != (int64_t)1)) {
        if (((int64_t)((*p).tag)==(int64_t)139)) {
            if (((int64_t)((*a).tag) == (int64_t)106)) {
                mm_type_makenewconst(p,(int64_t)(mm_decls_ttsize[((*a).value)]),(int64_t)0);
            } else {
                mm_type_makenewconst(p,(int64_t)(mm_decls_ttsize[((int64_t)((*a).mode))]),(int64_t)0);
            };
        }else if (((int64_t)((*p).tag)==(int64_t)138)) {
            if (((int64_t)((*a).tag) == (int64_t)106)) {
                mm_type_makenewconst(p,(int64_t)(mm_decls_ttbitwidth[((*a).value)]),(int64_t)0);
            } else {
                mm_type_makenewconst(p,(int64_t)(mm_decls_ttbitwidth[((int64_t)((*a).mode))]),(int64_t)0);
            };
        };
        return;
    };
    if (!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*p).mode))]))) {
        ix = (*a).value;
        switch ((int64_t)((*p).tag)) {
        case 109:;
        {
            iz = -(ix);
        }break;
        case 111:;
        {
            iz = ~(ix);
        }break;
        case 15:;
        {
            iz = !(ix);
        }break;
        case 110:;
        {
            iz = labs(ix);
        }break;
        case 139:;
        {
            iz = (int64_t)(mm_decls_ttsize[((int64_t)((*p).mode))]);
        }break;
        default: {
            return;
        }
        } //SW
;
        mm_type_makenewconst(p,iz,(int64_t)0);
    } else if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*p).mode))]))) {
        x = (*a).xvalue;
        switch ((int64_t)((*p).tag)) {
        case 109:;
        {
            z = -(x);
        }break;
        default: {
            return;
        }
        } //SW
;
        mm_type_makenewconst(p,*(int64_t*)&z,(int64_t)0);
    };
}

static void mm_type_tevalconvert(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  q;
    int64_t a;
    int64_t b;
    uint64_t u;
    double x;
    int64_t s;
    int64_t t;
    i128 *  p128;
    q = (*p).a;
    mm_type_tevaluate(q);
    s = (int64_t)((*q).mode);
    if (((int64_t)((*p).opcode)==(int64_t)1)) {
        //dosoft:
L1355 :;
;
        if (!(!!(mm_decls_ctarget))) {
            //delmode:
L1356 :;
;
            if (((int64_t)((*q).tag)==(int64_t)47) || ((int64_t)((*q).tag)==(int64_t)48)) {
            } else {
                (*q).mode = (int64_t)((*p).mode);
                mm_lib_deleteunit(p,q);
            };
            return;
        } else if (((((*p).mode == (int64_t)4) || ((*p).mode == (int64_t)9)) && ((int64_t)((*q).mode) == (int64_t)15))) {
            goto L1356 ;
;
        };
    }else if (((int64_t)((*p).opcode)==(int64_t)25)) {
        if (!(!!(mm_decls_ctarget))) {
            goto L1355 ;
;
        };
        (*p).tag = (int64_t)103;
        return;
    }else if (((int64_t)((*p).opcode)==(int64_t)23) || ((int64_t)((*p).opcode)==(int64_t)24)) {
        goto L1355 ;
;
    };
    if (((int64_t)((*q).tag) != (int64_t)1)) {
        return;
    };
    if ((s == mm_tables_trefchar)) {
        return;
    };
    t = (int64_t)(mm_decls_ttbasetype[((int64_t)((*p).newmode))]);
    if ((s == t)) {
        mm_lib_deleteunit(p,q);
    };
    x = (*q).xvalue;
    a = (*q).value;
    u = (*q).uvalue;
    if (((int64_t)((*p).opcode)==(int64_t)19) || ((int64_t)((*p).opcode)==(int64_t)20)) {
        if (((s == (int64_t)5) || (s == (int64_t)10))) {
            a = (int64_t)(mm_lib_getlow128((*q).pvalue128));
        };
        if ((t==(int64_t)6) || (t==(int64_t)13)) {
            b = (a & (int64_t)255);
        }else if ((t==(int64_t)7) || (t==(int64_t)14)) {
            b = (a & (int64_t)65535);
        }else if ((t==(int64_t)8)) {
            b = (a & (int64_t)4294967295);
        }else if ((t==(int64_t)9) || (t==(int64_t)4) || (t==(int64_t)15)) {
            b = a;
        }else if ((t==(int64_t)1)) {
            b = (int64_t)((int8_t)((a & (int64_t)255)));
        }else if ((t==(int64_t)2)) {
            b = (int64_t)((int16_t)((a & (int64_t)65535)));
        }else if ((t==(int64_t)3)) {
            b = (int64_t)((int32_t)((a & (int64_t)4294967295)));
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"STRMODE(S)=",NULL);
            msysnewc_m_print_str(mm_lib_strmode(s,(int64_t)1),NULL);
            msysnewc_m_print_str((uint8_t*)"=>",NULL);
            msysnewc_m_print_str(mm_lib_strmode(t,(int64_t)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_txerror((uint8_t*)"EVALC/TRUNC",(struct mm_decls_unitrec *)(0));
        };
        mm_type_makenewconst(p,b,(int64_t)0);
    }else if (((int64_t)((*p).opcode)==(int64_t)4) || ((int64_t)((*p).opcode)==(int64_t)5)) {
        if ((t==(int64_t)5) || (t==(int64_t)10)) {
            p128 = (i128 *)(mlib_pcm_allocz((int64_t)16));
            mm_lib_putlow128(p128,(uint64_t)(a));
            if ((!!((uint64_t)(mm_decls_ttisint[(s)])) && (a < (int64_t)0))) {
                mm_lib_puthigh128(p128,(uint64_t)18446744073709551615u);
            };
            mm_type_makenewconst(p,*(int64_t*)&p128,(int64_t)0);
        } else {
            mm_type_makenewconst(p,(int64_t)(u),(int64_t)0);
        };
    }else if (((int64_t)((*p).opcode)==(int64_t)6)) {
        x = (double)(a);
        mm_type_makenewconst(p,*(int64_t*)&x,(int64_t)0);
    }else if (((int64_t)((*p).opcode)==(int64_t)7)) {
        x = (double)(a);
        mm_type_makenewconst(p,*(int64_t*)&x,(int64_t)0);
    }else if (((int64_t)((*p).opcode)==(int64_t)8)) {
        a = ((*p).value = (int64_t)(x));
        mm_type_makenewconst(p,(int64_t)(x),(int64_t)0);
    }else if (((int64_t)((*p).opcode)==(int64_t)9)) {
        mm_support_txerror((uint8_t*)"UFIX",(struct mm_decls_unitrec *)(0));
    }else if (((int64_t)((*p).opcode)==(int64_t)22)) {
        mm_support_txerror((uint8_t*)"EVALC/FWIDEN",(struct mm_decls_unitrec *)(0));
    }else if (((int64_t)((*p).opcode)==(int64_t)21)) {
        mm_type_makenewconst(p,*(int64_t*)&x,(int64_t)11);
    }else if (((int64_t)((*p).opcode)==(int64_t)18)) {
        mm_support_txerror((uint8_t*)"EVALC/NARROW",(struct mm_decls_unitrec *)(0));
    } else {
    };
}

static void mm_type_makenewconst(struct mm_decls_unitrec * p,int64_t x,int64_t t) {
    (*p).tag = (int64_t)1;
    (*p).value = x;
    (*p).a = (struct mm_decls_unitrec *)(0);
    (*p).b = (struct mm_decls_unitrec *)(0);
    (*p).isconst = (int64_t)1;
    if ((t != (int64_t)0)) {
        (*p).mode = t;
    };
}

static void mm_type_tx_name(struct mm_decls_unitrec * p,int64_t t,int64_t lv) {
    struct mm_decls_strec *  d;
    int64_t oldmlineno;
    struct mm_decls_unitrec *  pcode;
    oldmlineno = mm_decls_mlineno;
    d = (*p).def;
    mm_decls_mlineno = (int64_t)((*d).lineno);
    switch ((int64_t)((*d).nameid)) {
    case 8:;
    case 14:;
    {
        if (!!(lv)) {
            mm_support_txerror((uint8_t*)"&const",(struct mm_decls_unitrec *)(0));
        };
        mm_type_tx_namedconst(d);
        pcode = (*d).code;
        (*p).tag = (int64_t)1;
        (*p).def = (struct mm_decls_strec *)(0);
        (*p).a = (struct mm_decls_unitrec *)(0);
        (*p).c = (struct mm_decls_unitrec *)(0);
        if (((int64_t)((*pcode).tag) == (int64_t)102)) {
            (*p).value = (*(*pcode).a).value;
        } else {
            (*p).value = (*pcode).value;
        };
        (*p).slength = (int64_t)((*pcode).slength);
        (*p).mode = (int64_t)((*d).mode);
        (*p).isconst = (int64_t)1;
        (*p).isastring = (int64_t)((*pcode).isastring);
    }break;
    case 9:;
    case 10:;
    case 11:;
    {
        if ((!!((uint64_t)((*d).islet)) && !!(lv))) {
            mm_support_txerror_s((uint8_t*)"Let: can't use # as lvalue",(*d).name,p);
        };
        mm_type_tx_namedef(d);
        if (!(!!(mm_type_inassem))) {
            (*p).mode = (int64_t)((*d).mode);
            mm_type_twiden(p,lv);
        } else {
            (*p).mode = mm_tables_trefchar;
        };
    }break;
    case 5:;
    case 6:;
    {
        (*p).mode = mm_tables_trefproc;
    }break;
    case 15:;
    case 16:;
    {
        (*p).mode = mm_tables_treflabel;
    }break;
    case 2:;
    {
        mm_support_txerror_s((uint8_t*)"Module name can't be used on it's own: #",(*d).name,(struct mm_decls_unitrec *)(0));
    }break;
    case 12:;
    {
        (*p).mode = (int64_t)((*d).mode);
    }break;
    case 4:;
    {
        (*p).tag = (int64_t)106;
        (*p).value = (int64_t)((*d).mode);
        (*p).mode = (int64_t)4;
    }break;
    case 7:;
    {
        if (!!((*d).code)) {
            mm_support_txerror((uint8_t*)"Can't init dllvar",(struct mm_decls_unitrec *)(0));
        };
        (*p).mode = (int64_t)((*d).mode);
    }break;
    case 20:;
    {
        (*p).def = (*d).equivfield;
        (*p).mode = mm_tables_trefproc;
    }break;
    default: {
        mm_support_txerror_ss((uint8_t*)"TNAME? # #",mm_tables_namenames[((int64_t)((*d).nameid))],(*d).name);
    }
    } //SW
;
    mm_decls_mlineno = oldmlineno;
}

static void mm_type_getdominantmode(int64_t tag,int64_t s,int64_t t,int64_t * u,int64_t * v) {
    int64_t sbase;
    int64_t tbase;
    sbase = (int64_t)(mm_decls_ttbasetype[(s)]);
    tbase = (int64_t)(mm_decls_ttbasetype[(t)]);
    if (((sbase <= (int64_t)20) && (tbase <= (int64_t)20))) {
        (*u) = (int64_t)(mm_tables_dominantmode[(sbase)][(tbase)]);
        if (((*u) == (int64_t)19)) {
            (*u) = s;
        };
        (*v) = (*u);
        return;
    };
    (*u) = ((*v) = s);
    if (((s == (int64_t)33) || (t == (int64_t)33))) {
        (*u) = ((*v) = (int64_t)33);
    } else if (!!(mm_type_comparemodes(s,t))) {
    } else {
        (*u) = ((*v) = (int64_t)0);
    };
}

static void mm_type_getdominantmodepp(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t * u,int64_t * v) {
    int64_t abase;
    int64_t bbase;
    int64_t amode;
    int64_t bmode;
    int64_t tag;
    abase = (int64_t)(mm_decls_ttbasetype[((amode = (int64_t)((*a).mode)))]);
    bbase = (int64_t)(mm_decls_ttbasetype[((bmode = (int64_t)((*b).mode)))]);
    (*u) = ((*v) = amode);
    tag = (int64_t)((*p).tag);
    if ((abase == (int64_t)19)) {
        if ((bbase == (int64_t)19)) {
            switch (tag) {
            case 36:;
            case 37:;
            {
                if ((((int64_t)(mm_decls_tttarget[(amode)]) == (int64_t)0) || ((int64_t)(mm_decls_tttarget[(bmode)]) == (int64_t)0))) {
                    return;
                };
            }break;
            case 38:;
            case 39:;
            case 41:;
            case 40:;
            case 209:;
            {
            }break;
            case 44:;
            {
                (*p).tag = (int64_t)62;
            }break;
            default: {
                if (((((((((int64_t)((*p).tag) == (int64_t)43) && (amode == mm_tables_trefchar)) && (bmode == mm_tables_trefchar)) && ((int64_t)((*a).tag) == (int64_t)1)) && ((int64_t)((*b).tag) == (int64_t)1)) && !!((int64_t)((*a).isastring))) && !!((int64_t)((*b).isastring)))) {
                    mm_type_joinstrings(p,a,b);
                    return;
                };
                mm_support_txerror((uint8_t*)"ref+ref",(struct mm_decls_unitrec *)(0));
            }
            } //SW
;
            if (!(!!(mm_type_comparemodes(amode,bmode)))) {
                (*u) = ((*v) = (int64_t)0);
            };
        } else if (!!((uint64_t)(mm_decls_ttisinteger[(bbase)]))) {
            if (!(((tag == (int64_t)43) || (tag == (int64_t)44)))) {
                mm_support_txerror((uint8_t*)"ref+T",(struct mm_decls_unitrec *)(0));
            };
            (*p).tag = ((tag == (int64_t)43)?(int64_t)63:(int64_t)64);
            (*v) = (int64_t)4;
        } else if ((bbase == (int64_t)33)) {
            (*u) = ((*v) = (int64_t)33);
        } else {
            (*u) = ((*v) = (int64_t)0);
        };
        return;
    } else if (((abase <= (int64_t)20) && (abase <= (int64_t)20))) {
        if (!!((uint64_t)(mm_decls_ttisshortint[(abase)]))) {
            abase = mm_type_twidenshort(a);
        };
        if (!!((uint64_t)(mm_decls_ttisshortint[(bbase)]))) {
            bbase = mm_type_twidenshort(b);
        };
        (*u) = (int64_t)(mm_tables_dominantmode[(abase)][(bbase)]);
        if (((*u) == (int64_t)19)) {
            (*u) = amode;
        };
        (*v) = (*u);
        return;
    } else if (!!(mm_type_comparemodes(amode,bmode))) {
        return;
    } else if (((abase == (int64_t)33) || (bbase == (int64_t)33))) {
        (*u) = ((*v) = (int64_t)33);
        return;
    };
    (*u) = ((*v) = (int64_t)0);
}

static void mm_type_coerceunit(struct mm_decls_unitrec * p,int64_t t,int64_t hard) {
    int64_t s;
    int64_t sbase;
    int64_t tbase;
    int64_t cc;
    int64_t starget;
    int64_t ttarget;
    int64_t result;
    if ((t == (int64_t)0)) {
        return;
    };
    s = (int64_t)((*p).mode);
    //retry:
L1357 :;
;
    if ((s == t)) {
        return;
    };
    if (!!(mm_type_comparemodes(s,t))) {
        return;
    };
    if (((s == (int64_t)0) && (t != (int64_t)0))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"COERCE",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_diags_printunit(p,(int64_t)0,(uint8_t*)"*",0);
        mm_support_txerror((uint8_t*)"Void type not allowed in expr",(struct mm_decls_unitrec *)(0));
    };
    sbase = (int64_t)(mm_decls_ttbasetype[(s)]);
    tbase = (int64_t)(mm_decls_ttbasetype[(t)]);
    result = t;
    if (((sbase >= (int64_t)20) || (tbase >= (int64_t)20))) {
        cc = (int64_t)0;
        if ((tbase==(int64_t)33)) {
            cc = (int64_t)26;
        } else {
            if ((sbase==(int64_t)24)) {
                if ((tbase==(int64_t)23)) {
                    mm_lib_insertunit(p,(int64_t)89);
                    (*p).mode = t;
                    return;
                };
            }else if ((sbase==(int64_t)19)) {
                if (((s == mm_tables_trefchar) && (tbase == (int64_t)23))) {
                    mm_type_tstringslice(p,t);
                    return;
                };
            }else if ((sbase==(int64_t)33)) {
                cc = (int64_t)29;
            }else if ((sbase==(int64_t)36)) {
                if ((((int64_t)((*p).tag) == (int64_t)31) && ((int64_t)((*(*p).a).tag) == (int64_t)3))) {
                    s = (int64_t)((*(*(*p).a).def).mode);
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str((uint8_t*)"STRMODE(S)=",NULL);
                    msysnewc_m_print_str(mm_lib_strmode(s,(int64_t)1),NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    goto L1357 ;
;
                } else {
                    mm_support_txerror((uint8_t*)"coerce/mult",(struct mm_decls_unitrec *)(0));
                };
            };
        };
        if ((cc == (int64_t)0)) {
            if (!(!!(hard))) {
                mm_support_txerror_ss((uint8_t*)"Explicit cast needed: # => #",mm_lib_strmode(s,(int64_t)1),mm_lib_strmode2(t,(int64_t)1));
            } else {
                cc = (int64_t)2;
            };
        };
    } else if ((!!((uint64_t)(mm_decls_ttisinteger[(sbase)])) && !!((uint64_t)(mm_decls_ttisshortint[(tbase)])))) {
        cc = (!!(hard)?(int64_t)20:(int64_t)19);
    } else if ((!!((uint64_t)(mm_decls_ttisshortint[(sbase)])) && !!((uint64_t)(mm_decls_ttisinteger[(tbase)])))) {
        mm_type_twidenopnd(p);
        (*p).mode = (int64_t)(((*p).newmode = t));
        mm_type_tevalconvert(p);
        return;
    } else if ((!!((uint64_t)(mm_decls_ttisshortint[(sbase)])) && !!((uint64_t)(mm_decls_ttisreal[(tbase)])))) {
        cc = (!!((uint64_t)(mm_decls_ttisint[(sbase)]))?(int64_t)6:(int64_t)7);
        goto L1358 ;
;
    } else if ((!!((uint64_t)(mm_decls_ttisreal[(sbase)])) && !!((uint64_t)(mm_decls_ttisshortint[(tbase)])))) {
        cc = (!!((uint64_t)(mm_decls_ttisint[(tbase)]))?(int64_t)8:(int64_t)9);
    } else {
        cc = (int64_t)(mm_tables_conversionops[(sbase)][(tbase)]);
        //gotcc:
L1358 :;
;
        if ((cc==(int64_t)32)) {
            mm_support_txerror_ss((uint8_t*)"Conversion not allowed: # => #",mm_lib_strmode(s,(int64_t)1),mm_lib_strmode2(t,(int64_t)1));
        }else if ((cc==(int64_t)0)) {
        }else if ((cc==(int64_t)25)) {
            starget = (int64_t)(mm_decls_tttarget[(s)]);
            ttarget = (int64_t)(mm_decls_tttarget[(t)]);
            if ((starget == ttarget)) {
                return;
            } else if (((starget == (int64_t)0) || (ttarget == (int64_t)0))) {
                if ((!!(mm_decls_ctarget) && (starget != (int64_t)0))) {
                    cc = (int64_t)1;
                };
            } else if (!(!!(hard))) {
                if (!(!!(mm_type_comparemodes(s,t)))) {
                    if (((!!(mm_decls_ctarget) && (starget == (int64_t)13)) && (ttarget == (int64_t)1))) {
                        cc = (int64_t)1;
                    } else if (((!!(mm_decls_ctarget) && (starget == (int64_t)1)) && (ttarget == (int64_t)13))) {
                        cc = (int64_t)1;
                    } else {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_str(mm_lib_strmode(s,(int64_t)1),NULL);
                        msysnewc_m_print_str((uint8_t*)"||",NULL);
                        msysnewc_m_print_str(mm_lib_strmode2(t,(int64_t)1),NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        mm_support_txerror((uint8_t*)"ref->ref needs explicit cast",(struct mm_decls_unitrec *)(0));
                    };
                };
            };
        }else if ((cc==(int64_t)23) || (cc==(int64_t)24)) {
            if (!(!!(hard))) {
                mm_support_txerror_ss((uint8_t*)"ref<=>int need explicit cast: # => #",mm_lib_strmode(s,(int64_t)1),mm_lib_strmode2(t,(int64_t)1));
            };
        };
    };
    if ((cc == (int64_t)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"COERCEUNIT",NULL);
        msysnewc_m_print_str(mm_lib_strmode(s,(int64_t)1),NULL);
        msysnewc_m_print_str(mm_lib_strmode(t,(int64_t)1),NULL);
        msysnewc_m_print_i64(hard,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_diags_printunit(p,(int64_t)0,(uint8_t*)"*",0);
        mm_support_txerror((uint8_t*)"CONV CODE=0",(struct mm_decls_unitrec *)(0));
    };
    mm_lib_insertunit(p,(int64_t)102);
    if (((cc == (int64_t)19) && !!(hard))) {
        cc = (int64_t)20;
    };
    (*p).opcode = cc;
    (*p).newmode = t;
    (*p).mode = result;
    mm_type_tevalconvert(p);
}

static void mm_type_tx_add(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    int64_t v;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    mm_type_getdominantmodepp(p,a,b,&u,&v);
    if (((int64_t)((*p).tag) == (int64_t)1)) {
        return;
    };
    mm_type_coerceunit(a,u,(int64_t)0);
    mm_type_coerceunit(b,v,(int64_t)0);
    (*p).mode = u;
    if ((u == (int64_t)0)) {
        mm_support_txerror((uint8_t*)"add/no dom",p);
    };
    mm_type_coerceunit(a,u,(int64_t)0);
    mm_type_coerceunit(b,v,(int64_t)0);
    (*p).mode = u;
    if ((((int64_t)((*p).tag) == (int64_t)62) && !!((uint64_t)(mm_decls_ttisref[(v)])))) {
        (*p).mode = (int64_t)4;
    };
    if (((int64_t)(mm_decls_ttbasetype[(u)]) == (int64_t)19)) {
        if (((!(!!(mm_decls_ctarget)) && ((int64_t)((*b).tag) == (int64_t)1)) && ((int64_t)(mm_decls_ttbasetype[((int64_t)((*b).mode))]) != (int64_t)19))) {
            (*b).value *= (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))]);
            if (((int64_t)((*p).tag)==(int64_t)63)) {
                (*p).tag = (int64_t)43;
            }else if (((int64_t)((*p).tag)==(int64_t)64)) {
                (*p).tag = (int64_t)44;
            };
        };
    };
}

static void mm_type_tx_mul(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    int64_t v;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    mm_type_getdominantmodepp(p,a,b,&u,&v);
    if ((u == (int64_t)0)) {
        mm_support_txerror((uint8_t*)"Bad mul/div/rem types",p);
    };
    mm_type_coerceunit(a,u,(int64_t)0);
    mm_type_coerceunit(b,v,(int64_t)0);
    (*p).mode = u;
    if (((((uint64_t)(mm_tables_stdtypecode[(u)]) != (uint64_t)82u) && ((int64_t)((*p).tag) == (int64_t)46)) && (u != (int64_t)33))) {
        (*p).tag = (int64_t)47;
    };
}

static void mm_type_tx_shl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    mm_type_twidenopnd(a);
    if (!((!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])) || !!((uint64_t)(mm_decls_ttisvar[((int64_t)((*a).mode))]))))) {
        mm_support_txerror((uint8_t*)"SHL/not int",(struct mm_decls_unitrec *)(0));
    };
    if (((int64_t)((*b).mode) != (int64_t)33)) {
        mm_type_coerceunit(b,(int64_t)4,(int64_t)0);
    };
    (*p).mode = (int64_t)((*a).mode);
}

static void mm_type_tx_iand(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    int64_t v;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    mm_type_getdominantmodepp(p,a,b,&u,&v);
    if (!((!!((uint64_t)(mm_decls_ttisinteger[(u)])) || !!((uint64_t)(mm_decls_ttisvar[(u)]))))) {
        mm_support_txerror((uint8_t*)"IAND/not int",(struct mm_decls_unitrec *)(0));
    };
    mm_type_coerceunit(a,u,(int64_t)0);
    mm_type_coerceunit(b,u,(int64_t)0);
    (*p).mode = u;
}

static void mm_type_tx_eq(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    int64_t v;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    if (((!!((uint64_t)(mm_decls_ttisref[((int64_t)((*a).mode))])) && !!((uint64_t)(mm_decls_ttisref[((int64_t)((*b).mode))]))) && (((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]) == (int64_t)0) || ((int64_t)(mm_decls_tttarget[((int64_t)((*b).mode))]) == (int64_t)0)))) {
    } else {
        mm_type_getdominantmodepp(p,a,b,&u,&v);
        if ((u == (int64_t)0)) {
            mm_support_txerror((uint8_t*)"EQ/NE",(struct mm_decls_unitrec *)(0));
        };
        mm_type_coerceunit(a,u,(int64_t)0);
        mm_type_coerceunit(b,u,(int64_t)0);
    };
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_isequal(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    if (!((((int64_t)((*a).mode) == (int64_t)((*b).mode)) && ((int64_t)((*b).mode) == (int64_t)33)))) {
        mm_support_txerror((uint8_t*)"isequal: must be vars",(struct mm_decls_unitrec *)(0));
    };
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_lt(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    int64_t v;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    mm_type_getdominantmodepp(p,a,b,&u,&v);
    if ((u == (int64_t)0)) {
        mm_support_txerror((uint8_t*)"lt/le/ge/gt",(struct mm_decls_unitrec *)(0));
    };
    mm_type_coerceunit(a,u,(int64_t)0);
    mm_type_coerceunit(b,u,(int64_t)0);
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_callproc(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * pargs,int64_t t) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    struct mm_decls_strec *  pm;
    struct mm_decls_strec *  paramlist[100];
    struct mm_decls_unitrec *  arglist[100];
    struct mm_decls_unitrec *  newarglist[100];
    int64_t nparams;
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t nargs;
    int64_t m;
    int64_t kwdused;
    int64_t qm;
    uint8_t *  name;
    struct mm_decls_unitrec *  ulist;
    struct mm_decls_unitrec *  ulistx;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    nargs = (nparams = (int64_t)0);
    //retry:
L1359 :;
;
    if (((int64_t)((*a).tag)==(int64_t)3)) {
        d = (*a).def;
        if ((((*d).nameid == (int64_t)5) || ((*d).nameid == (int64_t)6))) {
            //getparams:
L1360 :;
;
            e = (*d).deflist;
            L1361 :;
            while (!!(e)) {
                if (((int64_t)((uint64_t)((*e).nameid)) == (int64_t)11)) {
                    if ((nparams >= (int64_t)100)) {
                        mm_support_txerror((uint8_t*)"Param overflow",(struct mm_decls_unitrec *)(0));
                    };
                    paramlist[(++nparams)-1] = e;
                };
                e = (*e).nextdef;
L1362 :;
            }L1363 :;
            ;
        } else {
            L1364 :;
            while (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]) == (int64_t)19)) {
                mm_lib_insertunit(a,(int64_t)99);
                (*a).mode = (int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]);
L1365 :;
            }L1366 :;
            ;
            goto L1367 ;
;
        };
    }else if (((int64_t)((*a).tag)==(int64_t)209) || ((int64_t)((*a).tag)==(int64_t)229)) {
        mm_support_txerror((uint8_t*)"Can't do ifx/function",(struct mm_decls_unitrec *)(0));
    } else {
        //dorefproc:
L1367 :;
;
        if (((int64_t)((*a).tag) == (int64_t)95)) {
            mm_type_tmethodcall(p,a,pargs);
            a = (*p).a;
            pargs = (*p).b;
            goto L1359 ;
;
        };
        if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]) != (int64_t)26)) {
            mm_support_txerror((uint8_t*)"Function pointer expected",(struct mm_decls_unitrec *)(0));
        };
        d = mm_decls_ttnamedef[((int64_t)((*a).mode))];
        if ((d == 0)) {
            mm_support_txerror((uint8_t*)"Function expected",(struct mm_decls_unitrec *)(0));
        };
        goto L1360 ;
;
    };
    q = pargs;
    L1368 :;
    while (!!(q)) {
        if ((nargs >= (int64_t)100)) {
            mm_support_txerror((uint8_t*)"Param overflow",(struct mm_decls_unitrec *)(0));
        };
        arglist[(++nargs)-1] = q;
        q = (*q).nextunit;
L1369 :;
    }L1370 :;
    ;
    (*p).mode = (int64_t)((*d).mode);
    if (((int64_t)((uint64_t)((*d).nretvalues)) > (int64_t)1)) {
        (*p).mode = (int64_t)36;
    };
    if ((((int64_t)((*p).mode) == (int64_t)0) && ((int64_t)((*p).tag) == (int64_t)31))) {
        (*p).tag = (int64_t)201;
    };
    if (!!((int64_t)((*p).mode))) {
        mm_type_twiden(p,(int64_t)0);
    };
    if (!!((uint64_t)((*d).varparams))) {
        L1371 :;
        for (i=(int64_t)1;i<=nargs;i+=(int64_t)1) {
L1372 :;
            if ((i <= nparams)) {
                mm_type_tpass(arglist[(i)-1],(int64_t)((*paramlist[(i)-1]).mode),(int64_t)0);
            } else {
                mm_type_tpass(arglist[(i)-1],(int64_t)20,(int64_t)0);
            };
            if ((mm_decls_targetbits == (int64_t)64)) {
                mm_type_twidenopnd(arglist[(i)-1]);
            };
L1373 :;
        }L1374 :;
        ;
        return;
    };
    k = (int64_t)0;
    kwdused = (int64_t)0;
    L1375 :;
    for (i=(int64_t)1;i<=nparams;i+=(int64_t)1) {
L1376 :;
        newarglist[(i)-1] = (struct mm_decls_unitrec *)(0);
L1377 :;
    }L1378 :;
    ;
    L1379 :;
    for (i=(int64_t)1;i<=nargs;i+=(int64_t)1) {
L1380 :;
        q = arglist[(i)-1];
        switch ((int64_t)((*q).tag)) {
        case 27:;
        {
            name = (*(*(*q).a).def).name;
            L1383 :;
            for (j=(int64_t)1;j<=nparams;j+=(int64_t)1) {
L1384 :;
                if (!!(mlib_eqstring((*paramlist[(j)-1]).name,name))) {
                    goto L1386 ;
                };
L1385 :;
            }
            {
                mm_support_txerror_s((uint8_t*)"Can't find kwd param: #",name,(struct mm_decls_unitrec *)(0));
            }L1386 :;
            ;
            if (!!(newarglist[(j)-1])) {
                mm_support_txerror_s((uint8_t*)"Kwd: # already used or was implicit",name,(struct mm_decls_unitrec *)(0));
            };
            newarglist[(j)-1] = (*q).b;
            kwdused = (int64_t)1;
        }break;
        case 2:;
        {
            if (!!(kwdused)) {
                mm_support_txerror((uint8_t*)"Normal param follows kwd",(struct mm_decls_unitrec *)(0));
            };
            q = (struct mm_decls_unitrec *)(0);
            goto L1387 ;
;
        }break;
        default: {
            //doregparam:
L1387 :;
;
            if (!!(kwdused)) {
                mm_support_txerror((uint8_t*)"Normal param follows kwd",(struct mm_decls_unitrec *)(0));
            };
            if ((k >= nparams)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"K=",NULL);
                msysnewc_m_print_i64(k,NULL);
                msysnewc_m_print_str((uint8_t*)"NPARAMS=",NULL);
                msysnewc_m_print_i64(nparams,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                mm_support_txerror((uint8_t*)"Too many params supplied",(struct mm_decls_unitrec *)(0));
            };
            newarglist[(++k)-1] = q;
        }
        } //SW
;
L1381 :;
    }L1382 :;
    ;
    L1388 :;
    for (i=(int64_t)1;i<=nparams;i+=(int64_t)1) {
L1389 :;
        q = newarglist[(i)-1];
        pm = paramlist[(i)-1];
        if ((q == 0)) {
            if (!(!!((uint64_t)((*pm).optional)))) {
                mm_support_txerror_s((uint8_t*)"Param not optional: #",msysnewc_strint(i,(uint8_t *)(0)),(struct mm_decls_unitrec *)(0));
            };
            if (!!((*pm).code)) {
                newarglist[(i)-1] = mm_lib_duplunit((*pm).code,(int64_t)((*p).lineno));
            } else {
                newarglist[(i)-1] = mm_lib_createconstunit((uint64_t)((int64_t)0),(int64_t)4);
            };
        };
L1390 :;
    }L1391 :;
    ;
    ulist = (struct mm_decls_unitrec *)(0);
    L1392 :;
    for (i=(int64_t)1;i<=nparams;i+=(int64_t)1) {
L1393 :;
        pm = paramlist[(i)-1];
        q = newarglist[(i)-1];
        if (((int64_t)((uint64_t)((*pm).parammode)) == (int64_t)2)) {
            mm_type_tpass(q,(int64_t)20,(int64_t)1);
            m = (int64_t)(mm_decls_tttarget[((int64_t)((*pm).mode))]);
            qm = (int64_t)((*q).mode);
            if (!(!!(mm_type_comparemodes(qm,m)))) {
                mm_support_txerror((uint8_t*)"&param: type mismatch",(struct mm_decls_unitrec *)(0));
            };
            mm_lib_insertunit(q,(int64_t)100);
            (*q).mode = mm_lib_createrefmode((struct mm_decls_strec *)(0),qm,(int64_t)0);
        } else {
            mm_type_tpass(q,(int64_t)((*pm).mode),(int64_t)0);
            if ((mm_decls_targetbits == (int64_t)64)) {
                mm_type_twidenopnd(q);
            };
        };
        if ((ulist == 0)) {
            ulist = q;
        } else {
            (*ulistx).nextunit = q;
        };
        ulistx = q;
        (*q).nextunit = (struct mm_decls_unitrec *)(0);
L1394 :;
    }L1395 :;
    ;
    (*p).b = ulist;
}

static void mm_type_tx_neg(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    if ((!(!!(mm_lib_isnumericmode((int64_t)((*a).mode)))) && !(!!((uint64_t)(mm_decls_ttisvar[((int64_t)((*a).mode))]))))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"STRMODE(A.MODE)=",NULL);
        msysnewc_m_print_str(mm_lib_strmode((int64_t)((*a).mode),(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_support_txerror((uint8_t*)"Neg: not numeric",a);
    };
    mm_type_twidenopnd(a);
    u = (int64_t)((*a).mode);
    mm_type_coerceunit(a,u,(int64_t)0);
    (*p).mode = u;
}

static void mm_type_tx_if(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t t,int64_t lv) {
    int64_t u;
    int64_t v;
    mm_type_tcond(a);
    mm_type_tpass(b,t,lv);
    if (((t != (int64_t)0) && !(!!(c)))) {
        mm_support_txerror((uint8_t*)"if needs else",(struct mm_decls_unitrec *)(0));
    };
    mm_type_tpass(c,t,lv);
    if ((t == (int64_t)20)) {
        mm_type_getdominantmodepp(p,b,c,&u,&v);
        mm_type_coerceunit(b,u,(int64_t)0);
        mm_type_coerceunit(c,u,(int64_t)0);
        (*p).mode = u;
    } else {
        (*p).mode = t;
    };
}

static void mm_type_tx_longif(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t t,int64_t lv) {
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  r;
    int64_t u;
    int64_t v;
    u = (int64_t)0;
    q = a;
    L1396 :;
    while (!!(q)) {
        mm_type_tcond((*q).a);
        r = (*q).b;
        mm_type_tpass(r,t,lv);
        if ((t == (int64_t)20)) {
            if ((u == (int64_t)0)) {
                u = (int64_t)((*r).mode);
            } else {
                mm_type_getdominantmode((int64_t)0,u,(int64_t)((*r).mode),&u,&v);
            };
        };
        q = (*q).nextunit;
L1397 :;
    }L1398 :;
    ;
    if (((t != (int64_t)0) && (b == 0))) {
        mm_support_txerror((uint8_t*)"longif needs else",(struct mm_decls_unitrec *)(0));
    };
    mm_type_tpass(b,t,lv);
    if ((t == (int64_t)20)) {
        mm_type_getdominantmode((int64_t)0,u,(int64_t)((*b).mode),&u,&v);
    };
    if ((t != (int64_t)0)) {
        q = a;
        L1399 :;
        while (!!(q)) {
            if ((t == (int64_t)20)) {
                mm_type_coerceunit((*q).b,u,(int64_t)0);
            };
            (*q).mode = (int64_t)((*(*q).b).mode);
            q = (*q).nextunit;
L1400 :;
        }L1401 :;
        ;
        if ((t == (int64_t)20)) {
            mm_type_coerceunit(b,u,(int64_t)0);
        };
        (*p).mode = (int64_t)((*b).mode);
    };
}

static void mm_type_tx_preincr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t) {
    mm_type_tpass(a,(int64_t)20,(int64_t)1);
    if (!(((!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])) || !!((uint64_t)(mm_decls_ttisref[((int64_t)((*a).mode))]))) || !!((uint64_t)(mm_decls_ttisvar[((int64_t)((*a).mode))]))))) {
        mm_support_txerror((uint8_t*)"incr: not int/ref/var",(struct mm_decls_unitrec *)(0));
    };
    if ((t == (int64_t)0)) {
        if (((int64_t)((*p).tag)==(int64_t)145) || ((int64_t)((*p).tag)==(int64_t)147)) {
            (*p).tag = (int64_t)149;
        }else if (((int64_t)((*p).tag)==(int64_t)146) || ((int64_t)((*p).tag)==(int64_t)148)) {
            (*p).tag = (int64_t)150;
        };
    } else {
        (*p).mode = (int64_t)((*a).mode);
    };
    if ((t != (int64_t)0)) {
        mm_type_twiden(p,(int64_t)0);
    };
}

static void mm_type_tx_for(struct mm_decls_unitrec * pindex,struct mm_decls_unitrec * pbody,struct mm_decls_unitrec * ptemps) {
    struct mm_decls_unitrec *  pfrom;
    struct mm_decls_unitrec *  pto;
    struct mm_decls_unitrec *  pstep;
    struct mm_decls_unitrec *  plocal;
    struct mm_decls_unitrec *  plist;
    int64_t u;
    int64_t mlist;
    int64_t elemtype;
    pfrom = (*pindex).nextunit;
    pto = (*pfrom).nextunit;
    pstep = (*pto).nextunit;
    plocal = (*pstep).nextunit;
    mm_type_tpass(pindex,(int64_t)20,(int64_t)0);
    u = (int64_t)((*pindex).mode);
    mm_type_tpass(pfrom,u,(int64_t)0);
    mm_type_tpass(pto,u,(int64_t)0);
    mm_type_tpass(pstep,u,(int64_t)0);
    if (!!(plocal)) {
        plist = (*plocal).nextunit;
        mm_type_tpass(plist,(int64_t)20,(int64_t)0);
        mlist = (int64_t)((*plist).mode);
        if (((int64_t)(mm_decls_ttbasetype[(mlist)])==(int64_t)24)) {
            elemtype = (int64_t)(mm_decls_tttarget[(mlist)]);
        }else if (((int64_t)(mm_decls_ttbasetype[(mlist)])==(int64_t)33)) {
            elemtype = (int64_t)33;
        }else if (((int64_t)(mm_decls_ttbasetype[(mlist)])==(int64_t)23)) {
            elemtype = (int64_t)(mm_decls_tttarget[(mlist)]);
        } else {
            mm_support_txerror((uint8_t*)"forall/can't iterate",(struct mm_decls_unitrec *)(0));
        };
        mm_type_tpass(plocal,(int64_t)20,(int64_t)0);
        if (((int64_t)((*plocal).mode) == (int64_t)20)) {
            (*plocal).mode = elemtype;
            (*(*plocal).def).mode = elemtype;
        };
    };
    mm_type_tpass(pbody,(int64_t)0,(int64_t)0);
    mm_type_tpass((*pbody).nextunit,(int64_t)0,(int64_t)0);
}

static void mm_type_tx_index(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t t,int64_t lv) {
    int64_t amode;
    mm_type_tpass(a,(int64_t)20,lv);
    mm_type_deref(a);
    amode = (int64_t)((*a).mode);
    mm_type_tpass(b,(int64_t)4,(int64_t)0);
    if (!(((mm_decls_ttbasetype[(amode)] == (int64_t)24) || (mm_decls_ttbasetype[(amode)] == (int64_t)23) || (mm_decls_ttbasetype[(amode)] == (int64_t)33)))) {
        mm_support_txerror_s((uint8_t*)"Can't index: #",mm_lib_strmode(amode,(int64_t)1),(struct mm_decls_unitrec *)(0));
    };
    if (((int64_t)(mm_decls_ttbasetype[(amode)])==(int64_t)33)) {
        (*p).mode = (int64_t)33;
    } else {
        (*p).mode = (int64_t)(mm_decls_tttarget[(amode)]);
        mm_type_twiden(p,lv);
    };
}

static void mm_type_tx_keyindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t lv) {
    int64_t amode;
    mm_type_tpass(a,(int64_t)33,lv);
    mm_type_deref(a);
    amode = (int64_t)((*a).mode);
    mm_type_tpass(b,(int64_t)33,(int64_t)0);
    mm_type_tpass(c,(int64_t)33,(int64_t)0);
    (*p).mode = (int64_t)33;
}

static void mm_type_tx_makerange(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    int64_t v;
    int64_t amode;
    int64_t bmode;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    amode = (int64_t)((*a).mode);
    bmode = (int64_t)((*b).mode);
    if ((!!((uint64_t)(mm_decls_ttisvar[(amode)])) || !!((uint64_t)(mm_decls_ttisvar[(bmode)])))) {
        mm_type_coerceunit(a,(int64_t)33,(int64_t)0);
        mm_type_coerceunit(b,(int64_t)33,(int64_t)0);
        (*p).mode = (int64_t)33;
        return;
    };
    if ((!(!!((uint64_t)(mm_decls_ttisinteger[(amode)]))) || !(!!((uint64_t)(mm_decls_ttisinteger[(bmode)]))))) {
        mm_support_txerror((uint8_t*)"range not int",(struct mm_decls_unitrec *)(0));
    };
    mm_type_getdominantmodepp(p,a,b,&u,&v);
    if (!!((uint64_t)(mm_decls_ttisint[(amode)]))) {
        mm_type_coerceunit(a,(int64_t)4,(int64_t)0);
        mm_type_coerceunit(b,(int64_t)4,(int64_t)0);
    } else {
        mm_type_coerceunit(a,(int64_t)9,(int64_t)0);
        mm_type_coerceunit(b,(int64_t)9,(int64_t)0);
    };
    (*p).mode = (int64_t)22;
}

static void mm_type_tx_makeset(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t) {
    int64_t y;
    int64_t isconst;
    int64_t lower;
    int64_t upper;
    if ((t == (int64_t)0)) {
        mm_support_txerror((uint8_t*)"open(var) set type",(struct mm_decls_unitrec *)(0));
    };
    lower = (int64_t)2000000000;
    upper = (int64_t)-2000000000;
    isconst = (int64_t)1;
    L1402 :;
    while (!!(a)) {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        if (!(!!((int64_t)((*a).isconst)))) {
            isconst = (int64_t)0;
        } else {
            if (((int64_t)((*a).tag)==(int64_t)20)) {
                lower=(lower<(*(*a).a).value?lower:(*(*a).a).value);
;
                upper=(upper>(*(*a).b).value?upper:(*(*a).b).value);
;
            }else if (((int64_t)((*a).tag)==(int64_t)1)) {
                mm_type_coerceunit(a,(int64_t)4,(int64_t)0);
                lower=(lower<(y = (*a).value)?lower:(y = (*a).value));
;
                upper=(upper>(y = (*a).value)?upper:(y = (*a).value));
;
            };
        };
        a = (*a).nextunit;
L1403 :;
    }L1404 :;
    ;
    (*p).isconst = isconst;
    (*p).range_lower = lower;
    (*p).range_upper = upper;
    (*p).mode = (int64_t)33;
}

static void mm_type_tx_makedict(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t) {
    int64_t isconst;
    if ((t == (int64_t)0)) {
        mm_support_txerror((uint8_t*)"open(var) dict type",(struct mm_decls_unitrec *)(0));
    };
    (*p).isconst = isconst;
    (*p).mode = (int64_t)33;
}

static void mm_type_tx_ptr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t,int64_t lv) {
    struct mm_decls_strec *  d;
    if (((int64_t)((*p).tag)==(int64_t)3)) {
        d = (*p).def;
        if (((int64_t)((*d).nameid)==(int64_t)9) || ((int64_t)((*d).nameid)==(int64_t)10) || ((int64_t)((*d).nameid)==(int64_t)11)) {
        } else {
            mm_support_txerror_s((uint8_t*)"Can't use as ptr: ",(*d).name,(struct mm_decls_unitrec *)(0));
        };
    };
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)0)) {
        mm_support_txerror((uint8_t*)"Deref Void",(struct mm_decls_unitrec *)(0));
    }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)19)) {
        (*p).mode = (int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]);
    }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)23)) {
        mm_support_txerror((uint8_t*)"Can't deref slice",(struct mm_decls_unitrec *)(0));
    }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)33)) {
        (*p).mode = (int64_t)33;
    } else {
        mm_support_txerror((uint8_t*)"PTR: need ref T",(struct mm_decls_unitrec *)(0));
    };
    mm_type_twiden(p,lv);
}

static void mm_type_setrecordsize(int64_t m) {
    struct mm_decls_strec *  fieldlist[208];
    int64_t nfields;
    int64_t size;
    int64_t index;
    int64_t maxalign;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    uint8_t *  flags;
    int64_t flag;
    if (!!((int64_t)(mm_decls_ttsize[(m)]))) {
        return;
    };
    d = mm_decls_ttnamedef[(m)];
    e = (*d).deflist;
    nfields = (int64_t)0;
    fieldlist[(++nfields)-1] = (struct mm_decls_strec *)'S';
    L1405 :;
    while (!!(e)) {
        if (((int64_t)((uint64_t)((*e).nameid)) == (int64_t)12)) {
            if ((nfields >= (int64_t)200)) {
                mm_support_gerror((uint8_t*)"srs:too many fields",(struct mm_decls_unitrec *)(0));
            };
            mm_type_setmodesize((int64_t)((*e).mode));
            flags = (uint8_t *)(&(*e).uflags);
            L1408 :;
            if (((int64_t)((*flags))==(int64_t)83) || ((int64_t)((*flags))==(int64_t)85)) {
                flag = (int64_t)((*flags));
                fieldlist[(++nfields)-1] = *(struct mm_decls_strec **)&flag;
                ++flags;
            } else {
                goto L1409 ;
            }goto L1408 ;
L1409 :;
            ;
            fieldlist[(++nfields)-1] = e;
            L1410 :;
            while (1) {
                flag = (int64_t)((*flags++));
                if ((flag==(int64_t)42)) {
                }else if ((flag==(int64_t)69)) {
                    fieldlist[(++nfields)-1] = (struct mm_decls_strec *)'E';
                } else {
                    goto L1411 ;
                };
            }L1411 :;
            ;
        };
        e = (*e).nextdef;
L1406 :;
    }L1407 :;
    ;
    fieldlist[(++nfields)-1] = (struct mm_decls_strec *)'E';
    fieldlist[((nfields + (int64_t)1))-1] = (struct mm_decls_strec *)(0);
    mm_type_countedfields = (int64_t)0;
    index = (int64_t)2;
    maxalign = (int64_t)1;
    mm_type_scanrecord((int64_t)83,&fieldlist,&index,&size,(int64_t)0,(int64_t)((*d).align),&maxalign);
    if (!!((uint64_t)((*d).align))) {
        size = mm_type_roundoffset(size,maxalign);
        (*d).maxalign = (uint64_t)(maxalign);
    } else {
        (*d).maxalign = (uint64_t)((int64_t)1);
    };
    mm_decls_ttsize[(m)] = size;
    mm_decls_ttlength[(m)] = mm_type_countedfields;
    mm_decls_ttlower[(m)] = (int64_t)1;
}

static void mm_type_scanrecord(int64_t state,struct mm_decls_strec * (*fields)[],int64_t * index,int64_t * isize,int64_t offset,int64_t calign,int64_t * maxalign) {
    struct mm_decls_strec *  e;
    struct mm_decls_strec *  f;
    struct mm_decls_strec *  ea;
    int64_t size;
    int64_t fieldsize;
    int64_t bitoffset;
    int64_t alignment;
    int64_t newoffset;
    size = (int64_t)0;
    L1412 :;
    while (!!((f = (*fields)[((*index)++)-1]))) {
        if (((int64_t)(f)==(int64_t)83) || ((int64_t)(f)==(int64_t)85)) {
            mm_type_scanrecord((int64_t)(f),fields,index,&fieldsize,offset,calign,maxalign);
        }else if (((int64_t)(f)==(int64_t)69)) {
            if ((state == (int64_t)85)) {
                ++mm_type_countedfields;
            };
            (*isize) = size;
            return;
        } else {
            if (((int64_t)((*f).mode) == (int64_t)21)) {
                fieldsize = (int64_t)0;
                ea = (*f).equivfield;
                (*f).offset = (int64_t)((*ea).offset);
                (*f).bitoffset = (uint64_t)(bitoffset);
                bitoffset += (int64_t)((*f).bitfieldwidth);
                if ((bitoffset > (int64_t)((uint64_t)(mm_decls_ttbitwidth[((int64_t)((*(*f).equivfield).mode))])))) {
                    mm_support_txerror((uint8_t*)"Bit fields overflow type",(struct mm_decls_unitrec *)(0));
                };
            } else if (!!((uint64_t)((*f).at))) {
                bitoffset = (int64_t)0;
                e = (*f).equivfield;
                fieldsize = (int64_t)0;
                ea = mm_name_resolve_equiv_name((*f).owner,e);
                (*f).offset = (int64_t)((*ea).offset);
            } else {
                bitoffset = (int64_t)0;
                if ((state == (int64_t)83)) {
                    ++mm_type_countedfields;
                };
                fieldsize = (int64_t)(mm_decls_ttsize[((int64_t)((*f).mode))]);
                if (!!(calign)) {
                    alignment = mm_type_getalignment((int64_t)((*f).mode));
                    if ((alignment > (*maxalign))) {
                        (*maxalign) = alignment;
                    };
                    newoffset = mm_type_roundoffset(offset,alignment);
                    size += (newoffset - offset);
                } else {
                    newoffset = offset;
                };
                (*f).offset = newoffset;
                offset = newoffset;
            };
        };
        if ((state == (int64_t)83)) {
            offset += fieldsize;
            size += fieldsize;
        } else {
            size = (size>fieldsize?size:fieldsize);
        };
L1413 :;
    }L1414 :;
    ;
}

static int64_t mm_type_roundoffset(int64_t offset,int64_t alignment) {
    int64_t mask;
    if ((alignment == (int64_t)1)) {
        return offset;
    };
    mask = (alignment - (int64_t)1);
    L1415 :;
    while (!!((offset & mask))) {
        ++offset;
L1416 :;
    }L1417 :;
    ;
    return offset;
}

int64_t mm_type_getalignment(int64_t m) {
    int64_t a;
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)24)) {
        return mm_type_getalignment((int64_t)(mm_decls_tttarget[(m)]));
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)25)) {
        return (int64_t)((*mm_decls_ttnamedef[(m)]).maxalign);
    };
    a = (int64_t)(mm_decls_ttsize[(m)]);
    if ((a==(int64_t)1) || (a==(int64_t)2) || (a==(int64_t)4) || (a==(int64_t)8)) {
        return a;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(mm_lib_strmode(m,(int64_t)1),NULL);
    msysnewc_m_print_i64(a,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mm_support_serror((uint8_t*)"GETALIGN SIZE NOT 1248");
    return (int64_t)0;
}

static void mm_type_tx_convert(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t hard) {
    if (((int64_t)((*a).tag) == (int64_t)19)) {
        mm_type_tx_makelist(a,(*a).a,(int64_t)((*p).newmode),(int64_t)0);
    } else {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        mm_type_coerceunit(a,(int64_t)((*p).newmode),hard);
    };
    mm_lib_deleteunit(p,a);
}

static void mm_type_tx_makelist(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t,int64_t lv) {
    int64_t alength;
    int64_t tlength;
    int64_t elemtype;
    int64_t newt;
    int64_t isconst;
    int64_t m;
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  b;
    struct mm_decls_strec *  e;
    alength = (int64_t)((*p).length);
    newt = (int64_t)0;
    isconst = (int64_t)1;
    tlength = (int64_t)(mm_decls_ttlength[(t)]);
    if (!!(tlength)) {
        if ((alength < tlength)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"ALENGTH=",NULL);
            msysnewc_m_print_i64(alength,NULL);
            msysnewc_m_print_str((uint8_t*)"TLENGTH=",NULL);
            msysnewc_m_print_i64(tlength,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_txerror((uint8_t*)"Too few elements",(struct mm_decls_unitrec *)(0));
        } else if ((alength > tlength)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"ALENGTH=",NULL);
            msysnewc_m_print_i64(alength,NULL);
            msysnewc_m_print_str((uint8_t*)"TLENGTH=",NULL);
            msysnewc_m_print_i64(tlength,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_txerror((uint8_t*)"Too many elements",(struct mm_decls_unitrec *)(0));
        };
    };
    if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)24)) {
        elemtype = (int64_t)(mm_decls_tttarget[(t)]);
        if ((tlength == (int64_t)0)) {
            newt = mm_lib_createarraymodek((struct mm_decls_strec *)(0),elemtype,(int64_t)(mm_decls_ttlower[(t)]),alength,(int64_t)0);
        } else {
            newt = t;
        };
        q = a;
        L1418 :;
        while (!!(q)) {
            mm_type_tpass(q,elemtype,lv);
            if (!(((int64_t)((*q).tag) == (int64_t)1))) {
                isconst = (int64_t)0;
            };
            q = (*q).nextunit;
L1419 :;
        }L1420 :;
        ;
        (*p).mode = newt;
    }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)25)) {
        e = (*mm_decls_ttnamedef[(t)]).deflist;
        q = a;
        L1421 :;
        while ((!!(q) && !!(e))) {
            if (((int64_t)((uint64_t)((*e).nameid)) == (int64_t)12)) {
                L1424 :;
                while (((int64_t)((*e).mode) == (int64_t)21)) {
                    e = (*e).nextdef;
                    if (!(!!(e))) {
                        goto L1426 ;
                    };
L1425 :;
                }L1426 :;
                ;
                mm_type_tpass(q,(int64_t)((*e).mode),lv);
                if (!(((int64_t)((*q).tag) == (int64_t)1))) {
                    isconst = (int64_t)0;
                };
                q = (*q).nextunit;
            };
            e = (*e).nextdef;
L1422 :;
        }L1423 :;
        ;
        L1427 :;
        while ((!!(e) && (((int64_t)((uint64_t)((*e).nameid)) != (int64_t)12) || ((int64_t)((*e).mode) == (int64_t)21)))) {
            e = (*e).nextdef;
L1428 :;
        }L1429 :;
        ;
        if ((!!(q) || !!(e))) {
            mm_support_txerror((uint8_t*)"Can't initialise unions",(struct mm_decls_unitrec *)(0));
        };
        (*p).mode = t;
    }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)23)) {
        if ((((a == 0) || !!((b = (*a).nextunit,(b == 0)))) || !!((*b).nextunit))) {
            mm_support_txerror((uint8_t*)"bad slice init",(struct mm_decls_unitrec *)(0));
        };
        (*p).b = b;
        (*a).nextunit = (struct mm_decls_unitrec *)(0);
        mm_type_tpass(a,(int64_t)20,lv);
        if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]) != (int64_t)19)) {
            mm_support_txerror((uint8_t*)"slice init not ref",(struct mm_decls_unitrec *)(0));
        };
        if (((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]) != (int64_t)0)) {
            if (!(!!(mm_type_comparemodes((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]),(int64_t)(mm_decls_tttarget[(t)]))))) {
                mm_support_txerror((uint8_t*)"slice/ptr mismatch",(struct mm_decls_unitrec *)(0));
            };
        };
        mm_type_tpass(b,(int64_t)4,(int64_t)0);
        (*p).mode = t;
        (*p).tag = (int64_t)23;
    }else if (((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)0) || ((int64_t)(mm_decls_ttbasetype[(t)])==(int64_t)33)) {
        q = a;
        if (!!((int64_t)((*p).makearray))) {
            if ((q == 0)) {
                mm_support_txerror((uint8_t*)"array()?",(struct mm_decls_unitrec *)(0));
            };
            mm_type_tpass(q,(int64_t)20,lv);
            m = (int64_t)((*q).mode);
            q = (*q).nextunit;
        } else {
            m = (int64_t)33;
        };
        L1430 :;
        while (!!(q)) {
            mm_type_tpass(q,m,lv);
            if (!(((int64_t)((*q).tag) == (int64_t)1))) {
                isconst = (int64_t)0;
            };
            q = (*q).nextunit;
L1431 :;
        }L1432 :;
        ;
        (*p).mode = (int64_t)33;
    } else {
        mm_support_txerror_s((uint8_t*)"Unknown makelist type: #",mm_lib_strmode(t,(int64_t)1),(struct mm_decls_unitrec *)(0));
    };
    (*p).isconst = isconst;
    mm_type_tpass((*p).b,(int64_t)4,(int64_t)0);
}

static void mm_type_tx_dot(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t lv) {
    int64_t recmode;
    int64_t recbasemode;
    int64_t i;
    int64_t j;
    int64_t newtag;
    int64_t tmode;
    struct mm_decls_unitrec *  pindex;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  dequiv;
    mm_type_tpass(a,(int64_t)20,lv);
    recmode = (int64_t)((*a).mode);
    recbasemode = (int64_t)(mm_decls_ttbasetype[(recmode)]);
    L1433 :;
    while ((recbasemode == (int64_t)19)) {
        tmode = (int64_t)(mm_decls_tttarget[(recmode)]);
        mm_lib_insertunit(a,(int64_t)99);
        recmode = (int64_t)(((*a).mode = tmode));
        recbasemode = (int64_t)(mm_decls_ttbasetype[(recmode)]);
L1434 :;
    }L1435 :;
    ;
    if (((int64_t)(mm_decls_ttbasetype[(recmode)]) != (int64_t)25)) {
        mm_support_txerror((uint8_t*)"Bad record type",(struct mm_decls_unitrec *)(0));
    };
    d = (*b).def;
    if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)0)) {
        d = ((*b).def = mm_type_resolvefield(d,recmode));
    };
    if (((int64_t)((*d).mode) == (int64_t)21)) {
        i = (int64_t)((*d).bitoffset);
        j = ((i + (int64_t)((uint64_t)((*d).bitfieldwidth))) - (int64_t)1);
        dequiv = (*d).equivfield;
        (*b).def = dequiv;
        (*b).mode = (int64_t)((*dequiv).mode);
        (*p).offset = (int64_t)((*d).offset);
        if ((i == j)) {
            pindex = mm_lib_createconstunit((uint64_t)(i),(int64_t)4);
            newtag = (int64_t)90;
        } else {
            pindex = mm_lib_createunit2((int64_t)20,mm_lib_createconstunit((uint64_t)(i),(int64_t)4),mm_lib_createconstunit((uint64_t)(j),(int64_t)4));
            (*pindex).mode = (int64_t)22;
            newtag = (int64_t)91;
        };
        (*p).mode = (int64_t)((*b).mode);
        mm_type_twiden(p,lv);
        mm_lib_insertunit(p,newtag);
        (*p).mode = (int64_t)9;
        (*p).b = pindex;
        return;
    };
    (*b).mode = (int64_t)((*d).mode);
    (*p).mode = (int64_t)((*d).mode);
    if (!!((uint64_t)(mm_decls_ttisvar[((int64_t)((*d).mode))]))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"DOT:NEED TO REMOVE ADDR OF",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mm_type_removeaddrof(a);
    };
    (*p).offset = (int64_t)((*d).offset);
    mm_type_twiden(p,lv);
}

static struct mm_decls_strec * mm_type_resolvefield(struct mm_decls_strec * d,int64_t m) {
    struct mm_decls_strec *  e;
    struct mm_decls_strec *  t;
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)25)) {
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)19)) {
        m = (int64_t)(mm_decls_tttarget[(m)]);
        if (((int64_t)(mm_decls_ttbasetype[(m)]) != (int64_t)25)) {
            mm_support_txerror((uint8_t*)"3:record expected",(struct mm_decls_unitrec *)(0));
        };
    } else {
        mm_support_txerror((uint8_t*)"4:record expected",(struct mm_decls_unitrec *)(0));
    };
    t = mm_decls_ttnamedef[(m)];
    e = mm_name_finddupl(t,d);
    if (!(!!(e))) {
        mm_support_txerror_s((uint8_t*)"Not a field: #",(*d).name,(struct mm_decls_unitrec *)(0));
    };
    return e;
}

static int64_t mm_type_comparemodes(int64_t s,int64_t t) {
    int64_t sbase;
    int64_t tbase;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    if ((s == t)) {
        return (int64_t)1;
    };
    sbase = (int64_t)(mm_decls_ttbasetype[(s)]);
    tbase = (int64_t)(mm_decls_ttbasetype[(t)]);
    if ((sbase != tbase)) {
        return (int64_t)0;
    };
    if ((sbase==(int64_t)19)) {
        return mm_type_comparemodes((int64_t)(mm_decls_tttarget[(s)]),(int64_t)(mm_decls_tttarget[(t)]));
    }else if ((sbase==(int64_t)24)) {
        if ((!!(mm_type_comparemodes((int64_t)(mm_decls_tttarget[(s)]),(int64_t)(mm_decls_tttarget[(t)]))) && ((((int64_t)(mm_decls_ttlength[(s)]) == (int64_t)(mm_decls_ttlength[(t)])) || ((int64_t)(mm_decls_ttlength[(s)]) == (int64_t)0)) || ((int64_t)(mm_decls_ttlength[(t)]) == (int64_t)0)))) {
            return (int64_t)1;
        };
    }else if ((sbase==(int64_t)23)) {
        return mm_type_comparemodes((int64_t)(mm_decls_tttarget[(s)]),(int64_t)(mm_decls_tttarget[(t)]));
    }else if ((sbase==(int64_t)26)) {
        d = mm_decls_ttnamedef[(s)];
        e = mm_decls_ttnamedef[(t)];
        if ((!!(d) && !!(e))) {
            if (!(!!(mm_type_comparemodes((int64_t)((*d).mode),(int64_t)((*e).mode))))) {
                return (int64_t)0;
            };
            if ((((*d).paramlist == 0) && ((*e).paramlist == 0))) {
                return (int64_t)1;
            };
        };
    };
    return (int64_t)0;
}

static int64_t mm_type_isboolunit(struct mm_decls_unitrec * p) {
    return (int64_t)(mm_tables_boolunitset[((int64_t)((*p).tag))]);
}

static void mm_type_checkbool(int64_t m) {
}

static void mm_type_tx_andl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    if (!(!!(mm_type_isboolunit(a)))) {
        mm_lib_insertunit(a,(int64_t)16);
    };
    if (!(!!(mm_type_isboolunit(b)))) {
        mm_lib_insertunit(b,(int64_t)16);
    };
    mm_type_checkbool((int64_t)((*a).mode));
    mm_type_checkbool((int64_t)((*b).mode));
    (*p).mode = (int64_t)4;
}

static void mm_type_convintconst(struct mm_decls_unitrec * p,int64_t x) {
    (*p).tag = (int64_t)1;
    (*p).mode = (int64_t)4;
    (*p).value = x;
    (*p).a = ((*p).b = ((*p).c = (struct mm_decls_unitrec *)(0)));
    (*p).isconst = (int64_t)1;
}

static void mm_type_tx_upb(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t m;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_deref(a);
    m = (int64_t)((*a).mode);
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)24)) {
        mm_type_convintconst(p,(((int64_t)(mm_decls_ttlower[(m)]) + (int64_t)(mm_decls_ttlength[(m)])) - (int64_t)1));
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)23) || ((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)33)) {
    } else {
        mm_support_txerror_s((uint8_t*)"UPB #",mm_lib_strmode(m,(int64_t)1),(struct mm_decls_unitrec *)(0));
    };
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_len(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t m;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_deref(a);
    m = (int64_t)((*a).mode);
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)24)) {
        mm_type_convintconst(p,(int64_t)(mm_decls_ttlength[(m)]));
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)23) || ((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)33)) {
    } else {
        mm_support_txerror_s((uint8_t*)"LEN #",mm_lib_strmode(m,(int64_t)1),(struct mm_decls_unitrec *)(0));
    };
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_lenstr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t m;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    m = (int64_t)((*a).mode);
    if ((m != mm_tables_trefchar)) {
        mm_support_txerror((uint8_t*)"ichar expected",(struct mm_decls_unitrec *)(0));
    };
    if (((int64_t)((*a).tag) == (int64_t)1)) {
        mm_lib_deleteunit(p,a);
        (*p).tag = (int64_t)1;
        (*p).value = (int64_t)((*p).slength);
    };
    (*p).mode = (int64_t)4;
    (*p).isastring = (int64_t)0;
}

static void mm_type_tx_lwb(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t m;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_deref(a);
    m = (int64_t)((*a).mode);
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)24)) {
        mm_type_convintconst(p,(int64_t)(mm_decls_ttlower[(m)]));
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)23)) {
        mm_type_convintconst(p,(int64_t)(mm_decls_ttlower[(m)]));
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)33)) {
    } else {
        mm_support_txerror_s((uint8_t*)"LWB #",mm_lib_strmode(m,(int64_t)1),(struct mm_decls_unitrec *)(0));
    };
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_bounds(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t m;
    int64_t lower;
    int64_t upper;
    i128 *  p128;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_deref(a);
    m = (int64_t)((*a).mode);
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)24)) {
        lower = (int64_t)(mm_decls_ttlower[(m)]);
        upper = ((lower + (int64_t)(mm_decls_ttlength[(m)])) - (int64_t)1);
    }else if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)23) || ((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)33)) {
        (*p).mode = (int64_t)33;
        return;
    } else {
        mm_support_txerror_s((uint8_t*)"BOUNDS #",mm_lib_strmode(m,(int64_t)1),(struct mm_decls_unitrec *)(0));
    };
    (*p).tag = (int64_t)1;
    (*p).mode = (int64_t)22;
    p128 = (i128 *)(mlib_pcm_alloc((int64_t)16));
    mm_lib_putlow128(p128,(uint64_t)(lower));
    mm_lib_putlow128(p128,(uint64_t)(upper));
    (*p).pvalue128 = p128;
    (*p).a = ((*p).b = ((*p).c = (struct mm_decls_unitrec *)(0)));
    (*p).isconst = (int64_t)1;
}

static void mm_type_tx_sliceptr(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t m;
    int64_t tmode;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    m = (int64_t)((*a).mode);
    if (((int64_t)(mm_decls_ttbasetype[(m)])==(int64_t)23)) {
    } else {
        mm_support_txerror_s((uint8_t*)"SLICEPTR #",mm_lib_strmode(m,(int64_t)1),(struct mm_decls_unitrec *)(0));
    };
    tmode = mm_lib_createarraymodek((struct mm_decls_strec *)(0),(int64_t)(mm_decls_tttarget[(m)]),(int64_t)(mm_decls_ttlower[(m)]),(int64_t)0,(int64_t)0);
    (*p).mode = mm_lib_createrefmode((struct mm_decls_strec *)(0),tmode,(int64_t)0);
}

static void mm_type_tx_inot(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t u;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    if (((int64_t)((*a).mode) == (int64_t)33)) {
        (*p).mode = (int64_t)33;
        return;
    };
    if (!(!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])))) {
        mm_support_txerror((uint8_t*)"INOT/not int",(struct mm_decls_unitrec *)(0));
    };
    mm_type_twidenopnd(a);
    u = (int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
    mm_type_coerceunit(a,u,(int64_t)0);
    (*p).mode = u;
}

static void mm_type_tx_atan2(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    if ((((int64_t)((*a).mode) == (int64_t)33) || ((int64_t)((*b).mode) == (int64_t)33))) {
        u = (int64_t)33;
    } else {
        u = (int64_t)12;
    };
    mm_type_coerceunit(a,u,(int64_t)0);
    mm_type_coerceunit(b,u,(int64_t)0);
    (*p).mode = u;
    if ((((uint64_t)(mm_tables_stdtypecode[(u)]) != (uint64_t)82u) && ((int64_t)((*p).tag) == (int64_t)46))) {
        (*p).tag = (int64_t)47;
    };
}

static void mm_type_tx_swap(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_type_tpass(a,(int64_t)20,(int64_t)1);
    mm_type_tpass(b,(int64_t)20,(int64_t)1);
    if (!(!!(mm_type_comparemodes((int64_t)((*a).mode),(int64_t)((*b).mode))))) {
        mm_support_txerror((uint8_t*)"SWAP: type mismatch",(struct mm_decls_unitrec *)(0));
    };
    (*p).mode = (int64_t)0;
}

static void mm_type_tx_sqrt(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    if (((int64_t)((*a).mode) == (int64_t)33)) {
        (*p).mode = (int64_t)33;
        return;
    };
    if (!(!!(mm_lib_isnumericmode((int64_t)((*a).mode))))) {
        mm_support_txerror((uint8_t*)"maths: not numeric",(struct mm_decls_unitrec *)(0));
    };
    mm_type_coerceunit(a,(int64_t)12,(int64_t)0);
    (*p).mode = (int64_t)12;
}

static void mm_type_tx_select(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t t,int64_t lv) {
    int64_t u;
    int64_t v;
    struct mm_decls_unitrec *  q;
    mm_type_tpass(a,(int64_t)4,(int64_t)0);
    q = b;
    L1436 :;
    while (!!(q)) {
        mm_type_tpass(q,t,lv);
        if ((q == b)) {
            u = (int64_t)((*q).mode);
        } else {
            mm_type_getdominantmode((int64_t)0,u,(int64_t)((*q).mode),&u,&v);
        };
        q = (*q).nextunit;
L1437 :;
    }L1438 :;
    ;
    mm_type_tpass(c,t,lv);
    mm_type_getdominantmode((int64_t)0,u,(int64_t)((*c).mode),&u,&v);
    q = b;
    L1439 :;
    while (!!(q)) {
        mm_type_coerceunit(q,u,(int64_t)0);
        q = (*q).nextunit;
L1440 :;
    }L1441 :;
    ;
    (*p).mode = u;
}

static void mm_type_tx_case(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t t,int64_t lv) {
    int64_t amode;
    int64_t u;
    int64_t v;
    struct mm_decls_unitrec *  wt;
    struct mm_decls_unitrec *  w;
    if ((((int64_t)((*p).tag) == (int64_t)225) && !!(lv))) {
        mm_support_gerror((uint8_t*)"&docase",(struct mm_decls_unitrec *)(0));
    };
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    if ((a == 0)) {
        amode = (int64_t)20;
    } else {
        amode = (int64_t)((*a).mode);
    };
    if ((!!((uint64_t)(mm_decls_ttisinteger[(amode)])) && ((int64_t)(mm_decls_ttsize[(amode)]) < (int64_t)8))) {
        mm_type_coerceunit(a,(int64_t)4,(int64_t)0);
        amode = (int64_t)4;
    };
    u = (int64_t)0;
    wt = b;
    L1442 :;
    while (!!(wt)) {
        w = (*wt).a;
        L1445 :;
        while (!!(w)) {
            mm_type_tpass(w,(int64_t)20,(int64_t)0);
            if (((int64_t)((*w).tag) == (int64_t)20)) {
                if (!(!!((uint64_t)(mm_decls_ttisinteger[(amode)])))) {
                    mm_support_txerror((uint8_t*)"case: need int index",(struct mm_decls_unitrec *)(0));
                };
            } else {
                mm_type_coerceunit(w,amode,(int64_t)0);
                if (((amode == (int64_t)20) && !(!!(mm_type_isboolunit(w))))) {
                    mm_lib_insertunit(w,(int64_t)16);
                };
            };
            w = (*w).nextunit;
L1446 :;
        }L1447 :;
        ;
        mm_type_tpass((*wt).b,t,lv);
        if ((t != (int64_t)0)) {
            if (!!(u)) {
                mm_type_getdominantmode((int64_t)0,u,(int64_t)((*(*wt).b).mode),&u,&v);
            } else {
                u = (int64_t)((*(*wt).b).mode);
            };
        };
        wt = (*wt).nextunit;
L1443 :;
    }L1444 :;
    ;
    if (!!(c)) {
        mm_type_tpass(c,t,lv);
        if ((t == (int64_t)20)) {
            mm_type_getdominantmode((int64_t)0,u,(int64_t)((*c).mode),&u,&v);
        };
    } else if ((t != (int64_t)0)) {
        mm_support_txerror((uint8_t*)"case needs else",(struct mm_decls_unitrec *)(0));
    };
    if ((t != (int64_t)0)) {
        (*p).mode = u;
    } else {
        (*p).mode = (int64_t)0;
    };
}

static void mm_type_tx_notl(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    if (((int64_t)((*a).tag)==(int64_t)15)) {
        mm_lib_deleteunit(p,a);
        (*p).tag = (int64_t)16;
    };
    if ((((int64_t)((*p).tag) == (int64_t)16) && !!(mm_type_isboolunit((*p).a)))) {
        mm_lib_deleteunit(p,(*p).a);
    };
    mm_type_checkbool((int64_t)((*a).mode));
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_istruel(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    if (!!(mm_type_isboolunit(a))) {
        mm_lib_deleteunit(p,a);
    };
    mm_type_checkbool((int64_t)((*a).mode));
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_addto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t issub;
    int64_t atype;
    int64_t btype;
    int64_t u;
    mm_type_tpass(a,(int64_t)20,(int64_t)1);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    issub = ((int64_t)((*p).tag) == (int64_t)44);
    atype = (int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
    btype = (int64_t)(mm_decls_ttbasetype[((int64_t)((*b).mode))]);
    if (((((int64_t)((*p).tag) == (int64_t)154) && ((uint64_t)(mm_tables_stdtypecode[(atype)]) != (uint64_t)82u)) && (atype != (int64_t)33))) {
        (*p).tag = (int64_t)155;
    };
    u = atype;
    if ((atype==(int64_t)19)) {
        if ((btype == (int64_t)19)) {
            if (!(!!(issub))) {
                mm_support_txerror((uint8_t*)"ref+ref",(struct mm_decls_unitrec *)(0));
            };
            if (!(!!(mm_type_comparemodes((int64_t)((*a).mode),(int64_t)((*b).mode))))) {
                mm_support_txerror((uint8_t*)"ref-ref bad types",(struct mm_decls_unitrec *)(0));
            };
            u = btype;
        } else {
            u = (int64_t)4;
        };
    };
    mm_type_coerceunit(b,u,(int64_t)0);
    if (!!(mm_lib_isrefmode(atype))) {
        if (((!(!!(mm_decls_ctarget)) && ((int64_t)((*b).tag) == (int64_t)1)) && (btype != (int64_t)19))) {
            (*b).value *= (int64_t)(mm_decls_ttsize[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))]);
        } else {
            (*p).tag = (((int64_t)((*p).tag) == (int64_t)151)?(int64_t)168:(int64_t)169);
        };
    };
    (*p).mode = (int64_t)0;
}

static void mm_type_tx_iandto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_type_tpass(a,(int64_t)20,(int64_t)1);
    mm_type_tpass(b,(int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]),(int64_t)0);
    if (!((!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])) || !!((uint64_t)(mm_decls_ttisvar[((int64_t)((*a).mode))]))))) {
        mm_support_txerror((uint8_t*)"iandto: not int",(struct mm_decls_unitrec *)(0));
    };
    (*p).mode = (int64_t)0;
}

static void mm_type_tx_negto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_type_tpass(a,(int64_t)20,(int64_t)1);
    (*p).mode = (int64_t)0;
}

static void mm_type_tx_typepun(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t lv) {
    if (((int64_t)((*a).tag)==(int64_t)19)) {
        mm_support_txerror((uint8_t*)"TYPEPUN/LIST",(struct mm_decls_unitrec *)(0));
    } else {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        (*p).mode = (int64_t)((*p).newmode);
    };
}

static void mm_type_tx_bytesize(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    (*p).mode = (int64_t)4;
}

static void mm_type_tx_exit(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    if ((a == 0)) {
        return;
    };
    mm_type_tpass(a,(int64_t)4,(int64_t)0);
    if (((int64_t)((*a).tag) != (int64_t)1)) {
        mm_support_txerror((uint8_t*)"exit/etc not const",(struct mm_decls_unitrec *)(0));
    };
    (*p).index = (*a).value;
    (*p).a = (struct mm_decls_unitrec *)(0);
}

static void mm_type_tx_goto(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t m;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    m = (int64_t)((*a).mode);
    if ((((int64_t)(mm_decls_ttbasetype[(m)]) != (int64_t)19) || ((int64_t)(mm_decls_ttbasetype[((int64_t)(mm_decls_tttarget[(m)]))]) != (int64_t)35))) {
        mm_support_txerror((uint8_t*)"goto: not label",(struct mm_decls_unitrec *)(0));
    };
}

static void mm_type_tx_switch(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,struct mm_decls_unitrec * c,int64_t t,int64_t lv) {
    byte valueset[2001];
    struct mm_decls_unitrec *  wt;
    struct mm_decls_unitrec *  w;
    int64_t ax;
    int64_t bx;
    int64_t i;
    int64_t u;
    int64_t v;
    if ((((int64_t)((*p).tag) == (int64_t)227) && !!(lv))) {
        mm_support_gerror((uint8_t*)"&doswitch",(struct mm_decls_unitrec *)(0));
    };
    mm_type_tpass(a,(int64_t)4,(int64_t)0);
    memset((void *)(&valueset),(int64_t)0,(uint64_t)((int64_t)2001));
    u = (int64_t)0;
    wt = b;
    L1448 :;
    while (!!(wt)) {
        w = (*wt).a;
        L1451 :;
        while (!!(w)) {
            mm_type_tpass(w,(int64_t)20,(int64_t)0);
            if (!(!!(mm_lib_isconstunit(w)))) {
                mm_support_txerror((uint8_t*)"Switch not constant",(struct mm_decls_unitrec *)(0));
            };
            if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*w).mode))])==(int64_t)22)) {
                ax = (*(*w).a).value;
                bx = (*(*w).b).value;
                //dorange:
L1454 :;
;
                L1455 :;
                for (i=ax;i<=bx;i+=(int64_t)1) {
L1456 :;
                    if (((i < (int64_t)0) || (i > (int64_t)2000))) {
                        mm_support_txerror((uint8_t*)"switch: value out of range",(struct mm_decls_unitrec *)(0));
                    };
                    if (!!((uint64_t)(valueset[(i)]))) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_i64(i,NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        mm_support_txerror((uint8_t*)"Duplicate switch value",(struct mm_decls_unitrec *)(0));
                    };
                    valueset[(i)] = (uint64_t)((int64_t)1);
L1457 :;
                }L1458 :;
                ;
            } else {
                mm_type_coerceunit(w,(int64_t)4,(int64_t)0);
                mm_type_tevaluate(w);
                if (((int64_t)((*w).tag) != (int64_t)1)) {
                    mm_support_txerror((uint8_t*)"Switch value: not const int",(struct mm_decls_unitrec *)(0));
                };
                ax = (bx = (*w).value);
                goto L1454 ;
;
            };
            w = (*w).nextunit;
L1452 :;
        }L1453 :;
        ;
        mm_type_tpass((*wt).b,t,lv);
        if ((t == (int64_t)20)) {
            if (!!(u)) {
                mm_type_getdominantmode((int64_t)0,u,(int64_t)((*(*wt).b).mode),&u,&v);
            } else {
                u = (int64_t)((*(*wt).b).mode);
            };
        };
        wt = (*wt).nextunit;
L1449 :;
    }L1450 :;
    ;
    if (!!(c)) {
        mm_type_tpass(c,t,lv);
        if ((t == (int64_t)20)) {
            mm_type_getdominantmode((int64_t)0,u,(int64_t)((*c).mode),&u,&v);
        };
    } else if ((t != (int64_t)0)) {
        mm_support_txerror((uint8_t*)"switch needs else",(struct mm_decls_unitrec *)(0));
    };
    if ((t != (int64_t)0)) {
        w = (*b).a;
        L1459 :;
        while (!!(w)) {
            if ((t == (int64_t)20)) {
                mm_type_coerceunit((*b).b,u,(int64_t)0);
            };
            (*w).mode = (int64_t)((*(*b).b).mode);
            w = (*w).nextunit;
L1460 :;
        }L1461 :;
        ;
        if ((t == (int64_t)20)) {
            mm_type_coerceunit(c,u,(int64_t)0);
            (*p).mode = u;
        } else {
            (*p).mode = t;
        };
    } else {
        (*p).mode = (int64_t)0;
    };
}

static void mm_type_tx_power(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    int64_t v;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    mm_type_getdominantmodepp(p,a,b,&u,&v);
    mm_type_coerceunit(a,u,(int64_t)0);
    mm_type_coerceunit(b,v,(int64_t)0);
    (*p).mode = u;
}

static void mm_type_tx_addroffirst(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t) {
    int64_t m;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    m = (int64_t)((*a).mode);
    if (((int64_t)(mm_decls_ttbasetype[(m)]) != (int64_t)24)) {
        mm_support_txerror((uint8_t*)"&. ref[] expected",(struct mm_decls_unitrec *)(0));
    };
    m = mm_lib_createrefmode((struct mm_decls_strec *)(0),(int64_t)(mm_decls_tttarget[(m)]),(int64_t)0);
    if (((int64_t)((*a).tag) == (int64_t)3)) {
        (*a).addroffirst = (int64_t)1;
    };
    (*p).mode = m;
}

static void mm_type_tx_minvalue(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    int64_t u;
    int64_t tmax;
    int64_t x;
    i128 *  aa;
    if (((int64_t)((*a).tag) == (int64_t)106)) {
        u = (int64_t)(mm_decls_ttbasetype[((*a).value)]);
        //dotypeconst:
L1462 :;
;
        tmax = (int64_t)4;
        if (((int64_t)((*p).tag) == (int64_t)143)) {
            if ((u==(int64_t)1)) {
                x = (int64_t)-128;
            }else if ((u==(int64_t)2)) {
                x = (int64_t)-32768;
            }else if ((u==(int64_t)3)) {
                x = (int64_t)-2147483648;
            }else if ((u==(int64_t)4)) {
                x = (int64_t)(-9223372036854775807-1);
            }else if ((u==(int64_t)5)) {
                aa = (i128 *)(mlib_pcm_allocz((int64_t)16));
                mm_lib_puthigh128(aa,(uint64_t)9223372036854775808u);
                x = (int64_t)(aa);
                tmax = (int64_t)5;
            }else if ((u==(int64_t)6) || (u==(int64_t)7) || (u==(int64_t)8) || (u==(int64_t)9) || (u==(int64_t)10) || (u==(int64_t)13) || (u==(int64_t)14)) {
                x = (int64_t)0;
            } else {
                mm_support_txerror_s((uint8_t*)"Can't do minvalue on #",mm_lib_strmode(u,(int64_t)1),(struct mm_decls_unitrec *)(0));
            };
        } else {
            if ((u==(int64_t)1)) {
                x = (int64_t)127;
            }else if ((u==(int64_t)2)) {
                x = (int64_t)32767;
            }else if ((u==(int64_t)3)) {
                x = (int64_t)2147483647;
            }else if ((u==(int64_t)4)) {
                x = (int64_t)((uint64_t)9223372036854775807u);
            }else if ((u==(int64_t)5)) {
                aa = (i128 *)(mlib_pcm_allocz((int64_t)16));
                mm_lib_putlow128(aa,(uint64_t)18446744073709551615u);
                mm_lib_puthigh128(aa,(uint64_t)9223372036854775807u);
                x = (int64_t)(aa);
                tmax = (int64_t)5;
            }else if ((u==(int64_t)6) || (u==(int64_t)13)) {
                x = (int64_t)255;
            }else if ((u==(int64_t)7) || (u==(int64_t)14)) {
                x = (int64_t)65535;
            }else if ((u==(int64_t)8)) {
                x = (int64_t)4294967295;
            }else if ((u==(int64_t)9)) {
                x = (int64_t)0;
                --x;
                tmax = (int64_t)9;
            }else if ((u==(int64_t)10)) {
                aa = (i128 *)(mlib_pcm_allocz((int64_t)16));
                mm_lib_putlow128(aa,(uint64_t)18446744073709551615u);
                mm_lib_puthigh128(aa,(uint64_t)18446744073709551615u);
                x = (int64_t)(aa);
                tmax = (int64_t)10;
            } else {
                mm_support_txerror_s((uint8_t*)"Can't do maxvalue on #",mm_lib_strmode(u,(int64_t)1),(struct mm_decls_unitrec *)(0));
            };
        };
        (*p).tag = (int64_t)1;
        (*p).value = x;
        (*p).a = (struct mm_decls_unitrec *)(0);
        (*p).mode = tmax;
        (*p).isconst = (int64_t)1;
    } else {
        mm_type_tpass(a,(int64_t)20,(int64_t)0);
        if (((int64_t)((*a).tag) == (int64_t)106)) {
            u = (int64_t)(mm_decls_ttbasetype[((*a).value)]);
        } else {
            u = (int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
        };
        goto L1462 ;
;
    };
}

static void mm_type_tx_return(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t) {
    int64_t m;
    int64_t nret;
    int64_t i;
    struct mm_decls_unitrec *  q;
    m = (int64_t)((*mm_decls_currproc).mode);
    nret = (int64_t)((*mm_decls_currproc).nretvalues);
    if ((a == 0)) {
        if (!!(nret)) {
            mm_support_txerror((uint8_t*)"return value(s) missing",(struct mm_decls_unitrec *)(0));
        };
        return;
    } else if ((nret == (int64_t)0)) {
        mm_support_txerror((uint8_t*)"Superfluous return value",(struct mm_decls_unitrec *)(0));
    };
    if (((int64_t)((*a).tag) == (int64_t)19)) {
        (*a).tag = (int64_t)26;
        if (((int64_t)((*a).length) != nret)) {
            mm_support_txerror((uint8_t*)"Wrong number of return values",(struct mm_decls_unitrec *)(0));
        };
        q = (*a).a;
        L1463 :;
        for (i=(int64_t)1;i<=nret;i+=(int64_t)1) {
L1464 :;
            mm_type_tpass(q,(int64_t)((*mm_decls_currproc).modelist[(i)-1]),(int64_t)0);
            q = (*q).nextunit;
L1465 :;
        }L1466 :;
        ;
        mm_lib_deleteunit(p,a);
        if ((t == (int64_t)0)) {
            (*p).mode = (int64_t)0;
        } else {
            (*p).mode = (int64_t)36;
        };
    } else {
        if ((nret > (int64_t)1)) {
            mm_support_txerror((uint8_t*)"RETERROR?",(struct mm_decls_unitrec *)(0));
        };
        mm_type_tpass(a,m,(int64_t)0);
        if ((t == (int64_t)0)) {
            (*p).mode = (int64_t)0;
        } else {
            if (!(!!(mm_decls_ctarget))) {
                mm_lib_deleteunit(p,a);
            } else {
                (*p).mode = (int64_t)((*a).mode);
            };
        };
    };
}

static void mm_type_tx_dotindex(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t lv) {
    int64_t pmode;
    struct mm_decls_unitrec *  i;
    struct mm_decls_unitrec *  j;
    mm_type_tpass(a,(int64_t)20,lv);
    pmode = (int64_t)9;
    if (!(!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])))) {
        if (((int64_t)((*a).mode)==(int64_t)33)) {
            pmode = (int64_t)33;
        } else {
            mm_support_txerror((uint8_t*)"a.[i]: not int/str value",(struct mm_decls_unitrec *)(0));
        };
    };
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*b).mode))])==(int64_t)22)) {
        i = (*b).a;
        j = (*b).b;
        if ((((int64_t)((*i).tag) == (int64_t)((*j).tag)) && ((int64_t)((*j).tag) == (int64_t)1))) {
            if (((*i).value > (*j).value)) {
                {struct mm_decls_unitrec *  temp = (*b).a; (*b).a = (*b).b; (*b).b = temp; };
            };
        };
    }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*b).mode))])==(int64_t)33)) {
    } else {
        mm_type_coerceunit(b,(int64_t)4,(int64_t)0);
    };
    (*p).mode = pmode;
}

static void mm_type_tx_slice(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    if (((int64_t)((*a).mode) == mm_tables_trefchar)) {
        (*p).mode = mm_lib_createslicemodek(mm_decls_currproc,(int64_t)13,(int64_t)1,(int64_t)0);
    } else {
        mm_type_deref(a);
        if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)24)) {
            (*p).mode = mm_lib_createslicemodek(mm_decls_currproc,(int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]),(int64_t)1,(int64_t)0);
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)23)) {
            (*p).mode = (int64_t)((*a).mode);
        }else if (((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)33)) {
            (*p).mode = (int64_t)33;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"STRMODE(A.MODE)=",NULL);
            msysnewc_m_print_str(mm_lib_strmode((int64_t)((*a).mode),(int64_t)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mm_support_txerror((uint8_t*)"a[i..j]: not array",(struct mm_decls_unitrec *)(0));
        };
    };
}

static void mm_type_tx_assign(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b,int64_t t) {
    int64_t m;
    if (((int64_t)((*a).tag)==(int64_t)19)) {
        mm_type_tx_multassign(a,b);
    }else if (((int64_t)((*a).tag)==(int64_t)90) || ((int64_t)((*a).tag)==(int64_t)91)) {
        mm_type_tx_dotindex(a,(*a).a,(*a).b,(int64_t)1);
        mm_type_tpass(b,(int64_t)((*a).mode),(int64_t)0);
    } else {
        if (((((int64_t)((*a).tag) == (int64_t)3) && !!((uint64_t)((*(*a).def).islet))) && !!((int64_t)((*p).initlet)))) {
            mm_type_tpass(a,(int64_t)20,(int64_t)0);
        } else {
            mm_type_tpass(a,(int64_t)20,(int64_t)1);
        };
        m = (int64_t)((*a).mode);
        if ((mm_lib_gettypecat_t(m) == (int64_t)27)) {
            mm_type_tpass(b,(int64_t)(mm_tables_stdtypebase[((int64_t)(mm_decls_ttbasetype[(m)]))]),(int64_t)0);
            (*p).mode = m;
            if ((t != (int64_t)0)) {
                mm_type_twidenopnd(p);
            };
        } else {
            mm_type_tpass(b,m,(int64_t)0);
            (*p).mode = m;
        };
    };
}

static void mm_type_tx_multassign(struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    struct mm_decls_unitrec *  p;
    struct mm_decls_unitrec *  q;
    struct mm_decls_unitrec *  lhs;
    struct mm_decls_unitrec *  rhs;
    int64_t nretmodes;
    int64_t i;
    struct mm_decls_strec *  d;
    nretmodes = (int64_t)0;
    if (((int64_t)((*b).tag) != (int64_t)19)) {
        mm_type_tpass(b,(int64_t)20,(int64_t)0);
        d = mm_type_getprocretmodes(b);
        nretmodes = (int64_t)((*d).nretvalues);
        if (((int64_t)((*a).length) > nretmodes)) {
            mm_support_txerror((uint8_t*)"mult ass/mult returns don't agree in number",(struct mm_decls_unitrec *)(0));
        };
        if ((nretmodes <= (int64_t)1)) {
            mm_support_txerror((uint8_t*)"mult ass rhs needs fn yielding 2+ values",(struct mm_decls_unitrec *)(0));
        };
        p = (*a).a;
        i = (int64_t)1;
        L1467 :;
        while (!!(p)) {
            mm_type_tpass(p,(int64_t)20,(int64_t)1);
            if (((int64_t)((*p).mode) != (int64_t)((*d).modelist[(i++)-1]))) {
                mm_support_txerror((uint8_t*)"mult ass/mult fn needs exact type match",(struct mm_decls_unitrec *)(0));
            };
            p = (*p).nextunit;
L1468 :;
        }L1469 :;
        ;
        return;
    };
    if (((int64_t)((*a).length) != (int64_t)((*b).length))) {
        mm_support_txerror((uint8_t*)"Mult assign: count mismatch",(struct mm_decls_unitrec *)(0));
    };
    if (((int64_t)((*a).length) == (int64_t)0)) {
        mm_support_txerror((uint8_t*)"Invalid assignment",(struct mm_decls_unitrec *)(0));
    };
    rhs = (*b).a;
    lhs = (*a).a;
    p = lhs;
    L1470 :;
    while (!!(p)) {
        mm_type_tpass(p,(int64_t)20,(int64_t)1);
        p = (*p).nextunit;
L1471 :;
    }L1472 :;
    ;
    p = lhs;
    q = rhs;
    L1473 :;
    while (!!(q)) {
        mm_type_tpass(q,(int64_t)((*p).mode),(int64_t)0);
        p = (*p).nextunit;
        q = (*q).nextunit;
L1474 :;
    }L1475 :;
    ;
}

static void mm_type_tx_in(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    (*p).mode = (int64_t)4;
    if ((((int64_t)((*a).mode) == (int64_t)33) || ((int64_t)((*a).mode) == (int64_t)33))) {
        mm_type_coerceunit(a,(int64_t)33,(int64_t)0);
        mm_type_coerceunit(b,(int64_t)33,(int64_t)0);
        return;
    };
    if (!(!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])))) {
        mm_support_txerror((uint8_t*)"'in' opnd must be int",(struct mm_decls_unitrec *)(0));
    };
    if (((int64_t)((*b).tag)==(int64_t)20)) {
        if (((int64_t)((*p).tag) == (int64_t)56)) {
            (*p).tag = (int64_t)58;
            mm_lib_insertunit(p,(int64_t)15);
        } else {
            (*p).tag = (int64_t)58;
        };
    }else if (((int64_t)((*b).tag)==(int64_t)21)) {
        if (((int64_t)((*p).tag) == (int64_t)56)) {
            (*p).tag = (int64_t)59;
            mm_lib_insertunit(p,(int64_t)15);
        } else {
            (*p).tag = (int64_t)59;
        };
    } else {
        if (!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*b).mode))]))) {
        } else {
            mm_support_txerror((uint8_t*)"in rhs must be range/set",(struct mm_decls_unitrec *)(0));
        };
    };
}

static struct mm_decls_strec * mm_type_getprocretmodes(struct mm_decls_unitrec * p) {
    struct mm_decls_unitrec *  a;
    if (((int64_t)((*p).tag) != (int64_t)31)) {
        mm_support_txerror((uint8_t*)"multass/need multfn",(struct mm_decls_unitrec *)(0));
    };
    a = (*p).a;
    if (((int64_t)((*a).tag)==(int64_t)3)) {
        return (*a).def;
    } else {
        return mm_decls_ttnamedef[((int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]))];
    };
}

static void mm_type_tx_exprlist(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t t) {
    struct mm_decls_unitrec *  q;
    q = a;
    L1476 :;
    while ((!!(q) && !!((*q).nextunit))) {
        mm_type_tpass(q,(int64_t)20,(int64_t)0);
        q = (*q).nextunit;
L1477 :;
    }L1478 :;
    ;
    mm_type_tpass(q,t,(int64_t)0);
    (*p).mode = (int64_t)((*q).mode);
}

static void mm_type_tx_sign(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    if (!!((uint64_t)(mm_decls_ttisreal[((int64_t)((*a).mode))]))) {
        mm_type_coerceunit(a,(int64_t)12,(int64_t)0);
        (*p).mode = (int64_t)12;
    } else {
        mm_type_coerceunit(a,(int64_t)4,(int64_t)0);
        (*p).mode = (int64_t)4;
    };
}

static void mm_type_fixvoidunit(struct mm_decls_unitrec * a) {
    if (((int64_t)((*a).tag)==(int64_t)29)) {
        (*a).tag = (int64_t)205;
    }else if (((int64_t)((*a).tag)==(int64_t)209) || ((int64_t)((*a).tag)==(int64_t)210) || ((int64_t)((*a).tag)==(int64_t)224) || ((int64_t)((*a).tag)==(int64_t)226) || ((int64_t)((*a).tag)==(int64_t)203) || ((int64_t)((*a).tag)==(int64_t)229) || ((int64_t)((*a).tag)==(int64_t)4)) {
        if (((int64_t)((*a).mode) != (int64_t)0)) {
            (*a).popflag = (int64_t)1;
        };
    }else if (((int64_t)((*a).tag)==(int64_t)30)) {
        (*a).tag = (int64_t)207;
    }else if (((int64_t)((*a).tag)==(int64_t)203)) {
        if (!!((*a).a)) {
        };
    } else {
        if (((int64_t)((*a).mode) == (int64_t)0)) {
        } else {
            (*a).popflag = (int64_t)1;
        };
    };
}

static void mm_type_twiden(struct mm_decls_unitrec * p,int64_t lv) {
    int64_t m;
    int64_t mbase;
    mbase = (int64_t)(mm_decls_ttbasetype[((m = (int64_t)((*p).mode)))]);
    if ((lv==(int64_t)1)) {
    }else if ((lv==(int64_t)3) || (lv==(int64_t)4)) {
        if (!(!!((uint64_t)(mm_decls_ttisvar[(m)])))) {
            if ((((lv == (int64_t)4) || (((uint64_t)(mm_tables_stdtypecode[(mbase)]) == (uint64_t)65u) && ((int64_t)((uint64_t)(mm_tables_stdtypecat[(mbase)])) == (int64_t)32))) || (mbase == (int64_t)25))) {
                if (((int64_t)((*p).tag) == (int64_t)99)) {
                    mm_lib_deleteunit(p,(*p).a);
                } else {
                    mm_lib_insertunit(p,(int64_t)100);
                    (*p).mode = mm_lib_createrefmode((struct mm_decls_strec *)(0),m,(int64_t)0);
                };
            };
        };
    }else if ((lv==(int64_t)2)) {
        mm_support_txerror((uint8_t*)"widen/addrof",(struct mm_decls_unitrec *)(0));
    };
}

static int64_t mm_type_twidenshort(struct mm_decls_unitrec * p) {
    if (((int64_t)((*p).tag) == (int64_t)1)) {
        (*p).mode = (int64_t)(mm_tables_stdtypebase[((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]))]);
        return (int64_t)((*p).mode);
    };
    mm_lib_insertunit(p,(int64_t)102);
    if (((int64_t)(((*p).newmode = (int64_t)(mm_tables_stdtypebase[((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]))])))==(int64_t)4)) {
        (*p).opcode = (int64_t)4;
    }else if (((int64_t)(((*p).newmode = (int64_t)(mm_tables_stdtypebase[((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]))])))==(int64_t)9) || ((int64_t)(((*p).newmode = (int64_t)(mm_tables_stdtypebase[((int64_t)(mm_decls_ttbasetype[((int64_t)((*p).mode))]))])))==(int64_t)15)) {
        (*p).opcode = (int64_t)5;
    };
    (*p).mode = (int64_t)((*p).newmode);
    return (int64_t)((*p).mode);
}

static void mm_type_tx_head(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    (*p).mode = (int64_t)((*a).mode);
    if (((int64_t)((*p).tag)==(int64_t)85)) {
        (*p).mode = mm_lib_createrefmode((struct mm_decls_strec *)(0),(int64_t)6,(int64_t)0);
    }else if (((int64_t)((*p).tag)==(int64_t)86)) {
        (*p).mode = mm_tables_trefchar;
    };
    if (((int64_t)((*a).mode) != (int64_t)33)) {
        mm_support_txerror((uint8_t*)"head/etc can't be used with this type",(struct mm_decls_unitrec *)(0));
    };
    if (((int64_t)((*p).tag)==(int64_t)74) || ((int64_t)((*p).tag)==(int64_t)75) || ((int64_t)((*p).tag)==(int64_t)68) || ((int64_t)((*p).tag)==(int64_t)69) || ((int64_t)((*p).tag)==(int64_t)83) || ((int64_t)((*p).tag)==(int64_t)84)) {
        if ((b == 0)) {
            if (((int64_t)((*p).tag)==(int64_t)68) || ((int64_t)((*p).tag)==(int64_t)69)) {
                (*p).b = mm_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)4);
            }else if (((int64_t)((*p).tag)==(int64_t)83) || ((int64_t)((*p).tag)==(int64_t)84)) {
                (*p).b = mm_lib_createconstunit((uint64_t)((int64_t)-1),(int64_t)4);
            } else {
                mm_support_txerror((uint8_t*)"count missing",(struct mm_decls_unitrec *)(0));
            };
        } else {
            mm_type_tpass(b,(int64_t)4,(int64_t)0);
        };
    } else {
        if (!!(b)) {
            mm_support_txerror((uint8_t*)"Extra opnd",(struct mm_decls_unitrec *)(0));
        };
    };
}

static void mm_type_tx_concat(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t u;
    int64_t v;
    mm_type_tpass(a,(int64_t)20,(int64_t)0);
    mm_type_tpass(b,(int64_t)20,(int64_t)0);
    (*p).mode = (int64_t)((*a).mode);
    if (((int64_t)((*a).mode) != (int64_t)33)) {
        mm_support_txerror((uint8_t*)"head/etc can't be used with this type",(struct mm_decls_unitrec *)(0));
    };
    mm_type_getdominantmodepp(p,a,b,&u,&v);
    mm_type_coerceunit(a,u,(int64_t)0);
    mm_type_coerceunit(b,v,(int64_t)0);
}

static void mm_type_twidenopnd(struct mm_decls_unitrec * p) {
    if (!!((uint64_t)(mm_decls_ttisshortint[((int64_t)((*p).mode))]))) {
        mm_type_twidenshort(p);
    };
}

static void mm_type_joinstrings(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,struct mm_decls_unitrec * b) {
    int64_t newlen;
    int64_t alen;
    int64_t blen;
    uint8_t *  newstr;
    alen = (int64_t)((*a).slength);
    blen = (int64_t)((*b).slength);
    newlen = (alen + blen);
    newstr = (uint8_t *)(mlib_pcm_alloc((newlen + (int64_t)1)));
    if (!!(alen)) {
        memcpy((void *)(newstr),(void *)((*a).svalue),(uint64_t)(alen));
    };
    if (!!(blen)) {
        memcpy((void *)((newstr + alen)),(void *)((*b).svalue),(uint64_t)(blen));
    };
    (*((newstr + alen) + blen)) = (uint64_t)0u;
    (*a).svalue = newstr;
    (*a).slength = newlen;
    mm_lib_deleteunit(p,a);
}

static void mm_type_removeaddrof(struct mm_decls_unitrec * p) {
    if ((p == 0)) {
        return;
    };
    if (((int64_t)((*p).tag)==(int64_t)100)) {
        mm_lib_deleteunit(p,(*p).a);
    }else if (((int64_t)((*p).tag)==(int64_t)209)) {
        mm_type_removeaddrof((*p).b);
        mm_type_removeaddrof((*p).c);
    } else {
        mm_support_txerror((uint8_t*)"dot/flex: complex record expr, can't remove &",(struct mm_decls_unitrec *)(0));
    };
}

static void mm_type_tstringslice(struct mm_decls_unitrec * p,int64_t slicemode) {
    struct mm_decls_unitrec *  b;
    if (((int64_t)(mm_decls_tttarget[(slicemode)]) != (int64_t)13)) {
        mm_support_txerror((uint8_t*)"Not char slice",(struct mm_decls_unitrec *)(0));
    };
    mm_lib_insertunit(p,(int64_t)89);
    b = mm_lib_duplunit((*p).a,(int64_t)0);
    mm_lib_insertunit(b,(int64_t)137);
    mm_type_tx_lenstr(b,(*b).a);
    (*p).b = mm_lib_createunit2((int64_t)20,mm_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)4),b);
    (*(*p).b).mode = (int64_t)22;
    (*p).mode = slicemode;
}

static void mm_type_tx_bitfield(struct mm_decls_unitrec * p,struct mm_decls_unitrec * a,int64_t lv) {
    int64_t i;
    int64_t j;
    int64_t bitsize;
    int64_t topbit;
    struct mm_decls_unitrec *  r;
    mm_type_tpass(a,(int64_t)20,lv);
    if (!(!!((uint64_t)(mm_decls_ttisinteger[((int64_t)((*a).mode))])))) {
        mm_support_txerror((uint8_t*)"Int needed",(struct mm_decls_unitrec *)(0));
    };
    bitsize = (int64_t)(mm_decls_ttbitwidth[((int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]))]);
    topbit = (bitsize - (int64_t)1);
    if (((int64_t)((*p).opcode)==(int64_t)2)) {
        i = (int64_t)0;
        j = (int64_t)7;
    }else if (((int64_t)((*p).opcode)==(int64_t)1)) {
        j = topbit;
        i = (topbit - (int64_t)7);
    }else if (((int64_t)((*p).opcode)==(int64_t)4)) {
        i = (j = (int64_t)0);
    }else if (((int64_t)((*p).opcode)==(int64_t)7) || ((int64_t)((*p).opcode)==(int64_t)8)) {
        if (!!(lv)) {
            mm_support_txerror((uint8_t*)"Can't assign",(struct mm_decls_unitrec *)(0));
        };
        i = (j = (int64_t)0);
    }else if (((int64_t)((*p).opcode)==(int64_t)3)) {
        i = (j = topbit);
    }else if (((int64_t)((*p).opcode)==(int64_t)6)) {
        i = (int64_t)0;
        j = ((bitsize / (int64_t)2) - (int64_t)1);
    }else if (((int64_t)((*p).opcode)==(int64_t)5)) {
        i = (bitsize / (int64_t)2);
        j = topbit;
    };
    if ((i == j)) {
        (*p).tag = (int64_t)90;
        (*p).b = mm_lib_createconstunit((uint64_t)(i),(int64_t)4);
        if (((int64_t)((*p).opcode) == (int64_t)8)) {
            (*p).mode = (int64_t)9;
            mm_lib_insertunit(p,(int64_t)15);
        };
    } else {
        r = mm_lib_createunit2((int64_t)20,mm_lib_createconstunit((uint64_t)(i),(int64_t)4),mm_lib_createconstunit((uint64_t)(j),(int64_t)4));
        (*r).mode = (int64_t)22;
        (*p).tag = (int64_t)91;
        (*p).b = r;
    };
    (*p).mode = (int64_t)9;
}

static void mm_type_deref(struct mm_decls_unitrec * a) {
    int64_t abasemode;
    int64_t tmode;
    abasemode = (int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
    L1479 :;
    while ((abasemode == (int64_t)19)) {
        tmode = (int64_t)(mm_decls_tttarget[((int64_t)((*a).mode))]);
        mm_lib_insertunit(a,(int64_t)99);
        (*a).mode = tmode;
        abasemode = (int64_t)(mm_decls_ttbasetype[((int64_t)((*a).mode))]);
L1480 :;
    }L1481 :;
    ;
}

static void mm_type_tmethodcall(struct mm_decls_unitrec * p,struct mm_decls_unitrec * pdot,struct mm_decls_unitrec * pargs) {
    int64_t mrec;
    struct mm_decls_unitrec *  prec;
    struct mm_decls_unitrec *  pfield;
    struct mm_decls_unitrec *  pfunc;
    struct mm_decls_strec *  d;
    struct mm_decls_strec *  e;
    prec = (*pdot).a;
    pfield = (*pdot).b;
    mrec = (int64_t)((*prec).mode);
    d = (*pfield).def;
    e = mm_type_resolvefield(d,mrec);
    if ((e == 0)) {
        mm_support_txerror_s((uint8_t*)"Can't resolve method:",(*d).name,(struct mm_decls_unitrec *)(0));
    };
    pfunc = mm_lib_createname(e);
    (*pfunc).mode = (int64_t)((*e).mode);
    (*prec).nextunit = pargs;
    (*p).a = pfunc;
    (*p).b = prec;
}


/* ********** End of C Code ********** */
