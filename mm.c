/*

'M' Compiler Transpiled to C64/Linux

This cannot generated binaries on Linux, even in EXE format,
as it relies on various DLLs which searched for imported symbols.

But it can generate ASM, and there are options to parse only etc.

Build the single mm.c file on Linux as follows:

    gcc -O3 mm.c -omm -ldl -lm -fno-builtin

Run it as follows:

    ./mm file                    # to compile file.m


For some test files, try: 

  https://github.com/sal55/langs/tree/master/MLang/Examples

For bigger programs, see the .ma files here:

  https://github.com/sal55/langs/tree/master/sources

For my big 740Kloc test input, see:

  https://github.com/sal55/langs/blob/master/fann4.zip

(Had to be zipped as it's a 9MB file.)

I suggest these options when running this compiler:

    ./mm -time -asm file.m
    ./mm -time -load file.m        # load only
    ./mm -time -parse file.m       # load and parse
    ./mm -time -name file.m        # load, parse, resolve
    ./mm -time -type file.m        # load, parse, resolve, types
    ./mm -time -mcl file.m         # load, parse, resolve, types, codegen

-time gives timings for individual passes (I think the values will be in microseconds),
and overall compile-time.

To self-compiling, download mm.ma then compile as:

    ./mm -asm mm.ma                # (This is the Windows/x64 version)


*/

#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

//#include <stdio.h>
//#include <stdlib.h>
//#include <ctype.h>
//#include <string.h>
//#include <math.h>
//#include <time.h>
//#include <sys/types.h>
//#include <sys/stat.h>

//#pragma pack(1)

typedef signed char         i8;
typedef short              i16;
typedef int                i32;
typedef long long          i64;

typedef unsigned char       u8;
typedef unsigned short     u16;
typedef unsigned int       u32;
typedef unsigned long long u64;

typedef unsigned char     byte;

typedef float              r32;
typedef double             r64;

extern r64 sqrt(r64);
extern r64 fabs(r64);

typedef struct {void* ptr; u64 length;} Slice;

#define NULL ((void*)0)

#ifndef CALLBACK
#define CALLBACK
#endif

i64 m$llabs(i64 a){ return (a>=0?a:-a);}
#define m$infinity (1.0/0.0)


/* Forward Struct Declarations */
struct mm_decls$tokenrec;
struct mm_decls$overloadrec;
struct mm_decls$procrec;
struct mm_decls$typenamerec;
struct mm_decls$posrec;
struct mm_decls$uflagsrec;
struct mm_decls$strec;
struct mm_decls$unitrec;
struct mm_decls$fwdrec;
struct mm_decls$modulerec;
struct mm_decls$subprogrec;
struct mc_decls$opndrec;
struct mc_decls$mclrec;
struct mc_decls$constrec;
struct mc_decls$relocrec;
struct mc_decls$dbuffer;
struct mc_objdecls$imagefileheader;
struct mc_objdecls$imagedir;
struct mc_objdecls$optionalheader;
struct mc_objdecls$imagesectionheader;
struct mc_objdecls$imagesymbol;
struct mc_objdecls$importdirrec;
struct mc_objdecls$coffrelocrec;
struct mc_objdecls$auxsectionrec;
struct mc_objdecls$sectionrec;
struct mc_objdecls$importrec;
struct mc_objdecls$exportrec;
struct mc_objdecls$dllrec;
struct mc_objdecls$exportdirrec;
struct mc_writeexe$basereloc;
struct mx_decls$mcxreloc;
struct mx_decls$librec;
struct mx_show$showrelocs$dummy;
struct msysc$procinforec;
struct msysc$fmtrec;
struct mlib$strbuffer;
struct mlinux$termios;
struct mlinux$rsystemtime;

/* Struct Definitions */
struct mm_decls$tokenrec {
    byte symbol;
    byte subcode;
    u16 spare;
    u32 pos;
    union {
        struct mm_decls$strec *  symptr;
        i64 value;
        r64 xvalue;
        u64 uvalue;
        u8 *  svalue;
    };
};

struct mm_decls$overloadrec {
    i32 amode;
    i32 bmode;
    i32 rmode;
    i16 moduleno;
    i16 flags;
    struct mm_decls$unitrec *  fncode;
    struct mm_decls$overloadrec* nextoverload;
};

struct mm_decls$procrec {
    struct mm_decls$strec *  def;
    struct mm_decls$procrec* nextproc;
};

struct mm_decls$typenamerec {
    struct mm_decls$strec *  owner;
    struct mm_decls$strec *  defa;
    union {
        struct mm_decls$strec *  defb;
        struct mm_decls$strec *  def;
    };
    i32 *  pmode;
};

struct mm_decls$posrec {
    u32 pos;
};

struct mm_decls$uflagsrec {
    byte codes[7];
    byte ulength;
};

struct mm_decls$strec {
    u8 *  name;
    struct mm_decls$strec* owner;
    struct mm_decls$strec* deflist;
    struct mm_decls$strec* deflistx;
    struct mm_decls$strec* nextdef;
    struct mm_decls$strec* nextdupl;
    struct mm_decls$strec* firstdupl;
    struct mm_decls$unitrec *  code;
    i32 mode;
    byte namelen;
    byte symbol;
    byte nameid;
    byte subcode;
    union {
        i32 index;
        i32 labelno;
    };
    i32 offset;
    u32 pos;
    u16 flags;
    byte moduleno;
    byte subprogno;
    struct mm_decls$unitrec *  equivvar;
    struct {
        u8 *  truename;
        struct mm_decls$strec* paramlist;
        byte asmused;
        byte dllindex;
        byte fflang;
        byte nretvalues;
        byte varparams;
        byte isthreaded;
        i16 dummy1;
    };
    struct {
        struct mm_decls$strec* equivfield;
        struct mm_decls$uflagsrec uflags;
        i32 baseclass;
        byte bitfieldwidth;
        byte align;
        byte bitoffset;
        byte equivoffset;
    };
    struct {
        struct mm_decls$strec* nextparam;
        byte parammode;
        byte optional;
        byte variadic;
        byte dummy3;
    };
    i16 nrefs;
    i16 regsize;
    i16 maxalign;
    struct mm_decls$fwdrec *  fwdrefs;
    byte reftype;
    byte segment;
    i32 stindex;
    i16 importindex;
    struct mm_decls$strec* nextsym;
    i16 impindex;
    i16 expindex;
    byte reg;
    byte scope;
    byte equals;
};

struct mm_decls$unitrec {
    byte tag;
    byte simple;
    byte ifretflag;
    byte spare;
    u32 pos;
    struct mm_decls$unitrec* nextunit;
    union {
        struct {
            union {
                struct mm_decls$unitrec* a;
                struct mm_decls$strec *  def;
                struct mm_decls$strec *  labeldef;
                i64 value;
                u64 uvalue;
                r64 xvalue;
                u8 *  svalue;
                i64 range_lower;
            };
            union {
                struct mm_decls$unitrec* b;
                i64 range_upper;
            };
            struct mm_decls$unitrec* c;
        };
        struct mm_decls$unitrec *  abc[3];
    };
    union {
        struct {
            u32 slength;
            byte isastring;
        };
        struct {
            byte dottedname;
            byte avcode;
        };
        union {
            struct {
                byte reg;
                byte regix;
                byte scale;
                byte prefixmode;
                byte regsize;
                byte cond;
                byte spare2;
                byte spare3;
            };
            u64 reginfo;
        };
        union {
            u32 length;
            byte makearray;
        };
        byte addroffirst;
        u32 offset;
        i32 whenlabel;
        i32 swapvar;
        struct {
            union {
                i16 bitopindex;
                i16 opcindex;
                i16 fnindex;
                i16 condcode;
                i16 asmopcode;
                i16 bfcode;
            };
        };
        i32 index;
        byte cmpgenop[4];
    };
    i32 mode;
    i32 convmode;
    byte moduleno;
    byte subprogno;
    byte initlet;
    byte isconst;
    byte resultflag;
    byte pclop;
    byte istrueconst;
    byte memmode;
};

struct mm_decls$fwdrec {
    struct mm_decls$fwdrec* nextfwd;
    i32 offset;
    i16 reltype;
    i16 seg;
};

struct mm_decls$modulerec {
    u8 *  name;
    struct mm_decls$strec *  stmodule;
    struct mm_decls$strec *  stsubprog;
    u8 *  path;
    struct mm_decls$strec *  ststart;
    struct mm_decls$strec *  stmain;
    struct mm_decls$strec *  stmacro;
    struct mm_decls$unitrec *  modulecode;
    i16 fileno;
    i16 issyslib;
    i16 subprogno;
};

struct mm_decls$subprogrec {
    u8 *  name;
    struct mm_decls$strec *  stsubprog;
    i64 issyslib;
    u8 *  path;
    i16 firstmodule;
    i64 fileno;
};

struct mc_decls$opndrec {
    union {
        struct mm_decls$strec *  def;
        i64 value;
        r64 xvalue;
        u8 *  svalue;
        i64 labelno;
        i64 sysfn;
    };
    u16 misc;
    byte reg;
    byte regix;
    i32 offset;
};

struct mc_decls$mclrec {
    struct mc_decls$mclrec* nextmcl;
    struct mc_decls$opndrec *  a;
    struct mc_decls$opndrec *  b;
    byte opcode;
    byte cond;
    byte c;
    byte spare;
    u32 seqno;
};

struct mc_decls$constrec {
    union {
        i64 value;
        r64 xvalue;
        u8 *  svalue;
    };
    struct mc_decls$constrec* nextconst;
    i64 labelno;
};

struct mc_decls$relocrec {
    struct mc_decls$relocrec* nextreloc;
    i64 reloctype;
    i64 offset;
    i64 stindex;
};

struct mc_decls$dbuffer {
    byte *  pstart;
    union {
        byte *  pcurr;
        u16 *  pcurr16;
        u32 *  pcurr32;
        u64 *  pcurr64;
    };
    byte *  pend;
    i64 alloc;
};

struct mc_objdecls$imagefileheader {
    u16 machine;
    u16 nsections;
    u32 timedatestamp;
    u32 symtaboffset;
    u32 nsymbols;
    u16 optheadersize;
    u16 characteristics;
};

struct mc_objdecls$imagedir {
    u32 virtualaddr;
    u32 size;
};

struct mc_objdecls$optionalheader {
    u16 magic;
    byte majorlv;
    byte minorlv;
    u32 codesize;
    u32 idatasize;
    u32 zdatasize;
    u32 entrypoint;
    u32 codebase;
    u64 imagebase;
    u32 sectionalignment;
    u32 filealignment;
    u16 majorosv;
    u16 minorosv;
    u16 majorimagev;
    u16 minorimagev;
    u16 majorssv;
    u16 minorssv;
    u32 win32version;
    u32 imagesize;
    u32 headerssize;
    u32 checksum;
    u16 subsystem;
    u16 dllcharacteristics;
    u64 stackreserve;
    u64 stackcommit;
    u64 heapreserve;
    u64 heapcommit;
    u32 loaderflags;
    u32 rvadims;
    struct mc_objdecls$imagedir exporttable;
    struct mc_objdecls$imagedir importtable;
    struct mc_objdecls$imagedir resourcetable;
    struct mc_objdecls$imagedir exceptiontable;
    struct mc_objdecls$imagedir certtable;
    struct mc_objdecls$imagedir basereloctable;
    struct mc_objdecls$imagedir debug;
    struct mc_objdecls$imagedir architecture;
    struct mc_objdecls$imagedir globalptr;
    struct mc_objdecls$imagedir tlstable;
    struct mc_objdecls$imagedir loadconfigtable;
    struct mc_objdecls$imagedir boundimport;
    struct mc_objdecls$imagedir iat;
    struct mc_objdecls$imagedir delayimportdescr;
    struct mc_objdecls$imagedir clrheader;
    struct mc_objdecls$imagedir reserved;
};

struct mc_objdecls$imagesectionheader {
    u8 name[8];
    union {
        u32 physical_address;
        u32 virtual_size;
    };
    u32 virtual_address;
    u32 rawdata_size;
    u32 rawdata_offset;
    u32 relocations_ptr;
    u32 linenos_offset;
    u16 nrelocs;
    u16 nlinenos;
    u32 characteristics;
};

struct mc_objdecls$imagesymbol {
    union {
        u8 shortname[8];
        struct {
            u32 shortx;
            u32 longx;
        };
        u64 longname;
    };
    u32 value;
    i16 sectionno;
    u16 symtype;
    byte storageclass;
    byte nauxsymbols;
};

struct mc_objdecls$importdirrec {
    u32 implookuprva;
    u32 timedatestamp;
    u32 fwdchain;
    u32 namerva;
    u32 impaddressrva;
};

struct mc_objdecls$coffrelocrec {
    i32 virtualaddr;
    i32 stindex;
    i16 reloctype;
};

struct mc_objdecls$auxsectionrec {
    i32 length;
    i16 nrelocs;
    i16 nlines;
    i32 checksum;
    i16 sectionno;
    i32 dummy;
};

struct mc_objdecls$sectionrec {
    union {
        struct mc_decls$dbuffer *  data;
        byte *  bytedata;
    };
    u8 *  name;
    i64 segtype;
    i64 rawsize;
    i64 rawoffset;
    i64 virtsize;
    i64 virtoffset;
    struct mc_decls$relocrec *  relocs;
    i64 nrelocs;
};

struct mc_objdecls$importrec {
    struct mm_decls$strec *  def;
    i64 libno;
    u8 *  name;
    i64 hintnameoffset;
    i64 iatoffset;
    i64 thunkoffset;
};

struct mc_objdecls$exportrec {
    struct mm_decls$strec *  def;
    u8 *  name;
};

struct mc_objdecls$dllrec {
    u8 *  name;
    i64 nprocs;
    i64 nametableoffset;
    i64 addrtableoffset;
    i64 dllnameoffset;
    i64 dllextraoffset;
};

struct mc_objdecls$exportdirrec {
    u32 exportflags;
    u32 timedatestamp;
    u16 majorversion;
    u16 minorversion;
    u32 namerva;
    u32 ordinalbase;
    u32 naddrtable;
    u32 nnamepointers;
    u32 expaddressrva;
    u32 namepointerrva;
    u32 ordtablerva;
};

struct mc_writeexe$basereloc {
    struct mc_writeexe$basereloc* nextitem;
    u32 address;
    i32 reloctype;
};

struct mx_decls$mcxreloc {
    u32 offset;
    union {
        u16 stindex;
        byte targetsegment;
    };
    byte segment;
    byte reloctype;
};

struct mx_decls$librec {
    u8 *  version;
    i64 codesize;
    i64 idatasize;
    i64 zdatasize;
    i64 nrelocs;
    i64 ndlllibs;
    i64 nlibs;
    i64 nimports;
    i64 nexports;
    byte *  codeptr;
    byte *  idataptr;
    struct mx_decls$mcxreloc (*reloctable)[];
    u8 *(*dllnames)[];
    u8 *(*libnames)[];
    u8 *(*importnames)[];
    u8 *(*exports)[];
    byte (*exportsegs)[];
    u64 (*exportoffsets)[];
    u64 entryoffset;
    byte *  zdataptr;
    i64 codexsize;
    u64 (*exportaddr)[];
    i16 (*importxreftable)[];
    u8 *  filespec;
    u8 *  libname;
    byte *  entryaddr;
    i64 libno;
};

struct mx_show$showrelocs$dummy {
    union {
        u64 *  baseptr64;
        u32 *  baseptr32;
    };
};

struct msysc$procinforec {
    u16 fnindex;
    byte rettype;
    byte nparams;
    byte paramlist[12];
};

struct msysc$fmtrec {
    byte minwidth;
    i8 precision;
    byte base;
    u8 quotechar;
    u8 padchar;
    u8 realfmt;
    u8 plus;
    u8 sepchar;
    u8 lettercase;
    u8 justify;
    u8 suffix;
    u8 usigned;
    u8 charmode;
    u8 heapmode;
    u8 param;
    byte spare;
};

struct mlib$strbuffer {
    u8 *  strptr;
    i32 length;
    i32 allocated;
};

struct mlinux$termios {
    i32 c_iflag;
    i32 c_oflag;
    i32 c_cflag;
    i32 c_lflag;
    u8 c_line;
    u8 c_cc[32];
    byte filler[3];
    i32 c_ispeed;
    i32 c_ospeed;
};

struct mlinux$rsystemtime {
    i32 year;
    i32 month;
    i32 dayofweek;
    i32 day;
    i32 hour;
    i32 minute;
    i32 second;
    i64 milliseconds;
};


/* PROCDECLS */
int main(int, char**, char**);
static void mm_cli$do_loadmodules(void);
static void mm_cli$do_parse(void);
static void mm_cli$do_name(void);
static void mm_cli$do_type(void);
static void mm_cli$initdata(void);
static void mm_cli$getinputoptions(void);
static void mm_cli$do_option(i64 sw,u8 *value);
static void mm_cli$showcaption(void);
void mm_cli$showhelp(void);
void mm_cli$initassemsymbols(void);
static void mm_cli$do_writeexports(void);
static u8 *mm_cli$getoutfilename(u8 *file,u8 *ext);
static void mm_cli$fixstartprocs(void);
static struct mm_decls$strec *mm_cli$addstartproc(struct mm_decls$strec *owner,u8 *name,i64 scope,i64 moduleno);
static void mm_cli$stepruncount(void);
void mm_cli$start(void);
struct mm_decls$unitrec *mm_assem$readassemline(void);
struct mm_decls$unitrec *mm_assem$readassemblock(void);
static struct mm_decls$unitrec *mm_assem$assembleline(i64 oneline);
static struct mm_decls$unitrec *mm_assem$readassemopnd(void);
void mm_assem$start(void);
struct mc_decls$opndrec *mc_blockmcl$loadunit(struct mm_decls$unitrec *p,i64 reg);
struct mc_decls$opndrec *mc_blockmcl$evalunit(struct mm_decls$unitrec *p,i64 access);
static struct mc_decls$opndrec *mc_blockmcl$loadref(struct mm_decls$unitrec *p,i64 reg);
void mc_blockmcl$pushunit(struct mm_decls$unitrec *p);
static struct mc_decls$opndrec *mc_blockmcl$poptoreg(i64 m,i64 reg);
i64 mc_blockmcl$poptoarg(i64 m,i64 argno,i64 variadic);
void mc_blockmcl$loadarg(struct mm_decls$unitrec *p,i64 argno,i64 variadic);
static void mc_blockmcl$loadbin(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg,i64 isrev,i64 loadb);
static void mc_blockmcl$loadbinto(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 loadb);
static struct mc_decls$opndrec *mc_blockmcl$do_const(struct mm_decls$unitrec *p,i64 load,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_name(struct mm_decls$unitrec *p,i64 load,i64 reg);
static void mc_blockmcl$genjumpl(i64 lab);
static struct mc_decls$opndrec *mc_blockmcl$do_assign(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static struct mc_decls$opndrec *mc_blockmcl$loadmem(i64 load,struct mc_decls$opndrec *ax,i64 reg,i64 mode);
static struct mc_decls$opndrec *mc_blockmcl$loadmemaddr(struct mc_decls$opndrec *ax,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$storemem(struct mc_decls$opndrec *ax,struct mc_decls$opndrec *bx,i64 mode,i64 needres);
static struct mc_decls$opndrec *mc_blockmcl$do_bin(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_unary(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg);
static void mc_blockmcl$do_labeldef(struct mm_decls$unitrec *p);
static void mc_blockmcl$do_goto(struct mm_decls$unitrec *a);
static void mc_blockmcl$do_to(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mc_blockmcl$docond(i64 opc,struct mm_decls$unitrec *p,i64 lab);
static void mc_blockmcl$genjumpcond(i64 opc,struct mm_decls$unitrec *p,i64 lab);
static void mc_blockmcl$gcomparejump(i64 jumpopc,i64 cond,struct mm_decls$unitrec *lhs,struct mm_decls$unitrec *rhs,i64 lab);
i64 mc_blockmcl$reversecond(i64 pclop);
static void mc_blockmcl$setmultopnd(struct mc_decls$opndrec *ax,struct mc_decls$opndrec *rx);
static struct mc_decls$opndrec *mc_blockmcl$do_if(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pcond,struct mm_decls$unitrec *plist,struct mm_decls$unitrec *pelse,i64 isref,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_andl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_orl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_notl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_istruel(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_ptr(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 load,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_index(struct mm_decls$unitrec *parray,struct mm_decls$unitrec *pindex,i64 load,i64 reg);
static void mc_blockmcl$mulreg(struct mc_decls$opndrec *rx,i64 x);
static struct mc_decls$opndrec *mc_blockmcl$do_dot(struct mm_decls$unitrec *pdot,i64 load,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$getaddrmode(struct mc_decls$opndrec *ax,struct mm_decls$unitrec *pindex,i64 size,i64 offset);
static void mc_blockmcl$do_while(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pcond,struct mm_decls$unitrec *pbody,struct mm_decls$unitrec *pincr);
static void mc_blockmcl$do_repeat(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mc_blockmcl$do_incr(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mc_blockmcl$do_incrstep(struct mc_decls$opndrec *ax,i64 step,i64 isincr);
static struct mc_decls$opndrec *mc_blockmcl$do_incrload(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg);
static void mc_blockmcl$do_for(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *pfrom,struct mm_decls$unitrec *pbody,i64 down);
static void mc_blockmcl$do_forall(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *plist,struct mm_decls$unitrec *pbody,i64 down);
static void mc_blockmcl$do_print(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static struct mc_decls$opndrec *mc_blockmcl$do_callproc(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 isfn);
static void mc_blockmcl$do_stop(struct mm_decls$unitrec *a);
static void mc_blockmcl$do_do(struct mm_decls$unitrec *a);
static void mc_blockmcl$do_exit(struct mm_decls$unitrec *p,i64 k);
static void mc_blockmcl$do_swap(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mc_blockmcl$saverdx(void);
static void mc_blockmcl$restorerdx(void);
static struct mc_decls$opndrec *mc_blockmcl$do_divrem(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 issigned,i64 isdiv);
static i64 mc_blockmcl$fixdivopnds(struct mc_decls$opndrec *ax,struct mc_decls$opndrec *bx);
static struct mc_decls$opndrec *mc_blockmcl$do_shift(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 opc);
static struct mc_decls$opndrec *mc_blockmcl$do_convert(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg);
static void mc_blockmcl$do_clear(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static struct mc_decls$opndrec *mc_blockmcl$do_case(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *pwhenthen,struct mm_decls$unitrec *pelse,i64 loopsw,i64 isref,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_switch(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *pwhenthen,struct mm_decls$unitrec *pelse,i64 loopsw,i64 isref,i64 reg);
static void mc_blockmcl$do_binto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mc_blockmcl$do_bintomem(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 opc);
static void mc_blockmcl$do_bintoreg(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 opc);
static struct mc_decls$opndrec *mc_blockmcl$do_return(struct mm_decls$unitrec *a);
static struct mc_decls$opndrec *mc_blockmcl$do_returnmult(struct mm_decls$unitrec *a);
static void mc_blockmcl$do_addrefoffto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 isincr);
static void mc_blockmcl$domaxto_int(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 cond);
static struct mc_decls$opndrec *mc_blockmcl$do_setcc(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_read(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mc_blockmcl$do_readln(struct mm_decls$unitrec *a);
static struct mc_decls$opndrec *mc_blockmcl$do_syscall(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_dotindex(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_dotslice(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_typepun(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg);
static void mc_blockmcl$do_shiftnto(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 opc);
static struct mc_decls$opndrec *mc_blockmcl$do_select(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 isref,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_setccchain(struct mm_decls$unitrec *p,struct mm_decls$unitrec *q,i64 reg);
static struct mc_decls$opndrec *mc_blockmcl$do_maths(struct mm_decls$unitrec *a,i64 reg,u8 *opname);
static struct mc_decls$opndrec *mc_blockmcl$do_maths2(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg,u8 *opname);
static void mc_blockmcl$do_callext(struct mc_decls$opndrec *px);
static struct mc_decls$opndrec *mc_blockmcl$do_storedotindex(struct mm_decls$unitrec *a,struct mm_decls$unitrec *rhs,i64 resflag);
static struct mc_decls$opndrec *mc_blockmcl$do_storedotslice(struct mm_decls$unitrec *a,struct mm_decls$unitrec *rhs,i64 resflag);
static struct mc_decls$opndrec *mc_blockmcl$do_slice(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg);
static void mc_blockmcl$do_assignms(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
void mc_blockmcl$start(void);
void mm_winx64$codegen(void);
i64 mm_winx64$runlibfile(u8 *filename);
i64 mm_winx64$writeexefile(u8 *filename,i64 gendll);
i64 mm_winx64$writelibfile(u8 *filename);
i64 mm_winx64$writeasmfile(u8 *filename);
void mm_winx64$start(void);
void mm_decls$start(void);
void mm_diags$printoverloads(void *f);
void mm_diags$printst(void *f,struct mm_decls$strec *p,i64 level);
static void mm_diags$printstrec(void *f,struct mm_decls$strec *p,i64 level);
void mm_diags$printstflat(void *f);
void mm_diags$printcode(void *f,u8 *caption);
void mm_diags$printunit(struct mm_decls$unitrec *p,i64 level,u8 *prefix,void *dev);
static void mm_diags$printunitlist(void *dev,struct mm_decls$unitrec *p,i64 level,u8 *prefix);
static u8 *mm_diags$getprefix(i64 level,u8 *prefix,struct mm_decls$unitrec *p);
static u8 *mm_diags$getlineinfok(void);
void mm_diags$printmodelist(void *f);
void mm_diags$showprojectinfo(void *dev);
void mm_diags$showlogfile(void);
static void mm_diags$showstflat(u8 *caption,void *f);
static void mm_diags$showsttree(u8 *caption,void *f);
void mm_diags$showast(u8 *filename);
void mm_diags$printsymbol(struct mm_decls$tokenrec *lp);
void mm_diags$start(void);
void mm_export$writeexports(u8 *outfile,u8 *modulename);
static void mm_export$exportstatic(struct mm_decls$strec *d);
static void mm_export$exportconst(struct mm_decls$strec *d);
static void mm_export$exportproc(struct mm_decls$strec *d);
static void mm_export$wxstr(u8 *s);
static void mm_export$wxstrln(u8 *s);
static void mm_export$wxline(void);
static void mm_export$exportrecord(struct mm_decls$strec *d);
static void mm_export$wxmode(i64 mode);
void mm_export$start(void);
void mm_lex$lexreadtoken(void);
void mm_lex$lex(void);
void mm_lex$lexsetup(void);
void mm_lex$printstrn(u8 *s,i64 length);
static void mm_lex$readrawstring(void);
static void mm_lex$lookup(u8 *name,i64 length,i64 hashindex0);
static i64 mm_lex$lookupsys(u8 *name);
static i64 mm_lex$gethashvaluez(u8 *s);
static void mm_lex$inithashtable(void);
void mm_lex$printhashtable(void);
void mm_lex$addreservedword(u8 *name,i64 symbol,i64 subcode,i64 regsize);
static i64 mm_lex$dolexdirective(i64 index);
void mm_lex$startlex(i64 fileno);
void mm_lex$start(void);
struct mm_decls$strec *mm_lex$addnamestr(u8 *name);
void mm_lex$ps(u8 *caption);
void mm_lex$psnext(u8 *caption);
void mm_lex$psx(u8 *caption);
void mm_lex$stacksource(i64 fileno,i64 isimport);
void mm_lex$unstacksource(void);
static void mm_lex$readarraystring(i64 prefix);
static i64 mm_lex$setinttype(u64 a);
static void mm_lex$readrawxname(void);
static void mm_lex$lxerror_s(u8 *mess,u8 *s);
static void mm_lex$lxreadstring(i64 termchar);
static void mm_lex$readdec(void);
static void mm_lex$readhex(void);
static void mm_lex$readoct(void);
static void mm_lex$readbin(void);
static void mm_lex$readreal(void);
struct mm_decls$strec *mm_lib$newstrec(void);
struct mm_decls$strec *mm_lib$getduplnameptr(struct mm_decls$strec *owner,struct mm_decls$strec *symptr,i64 id);
void mm_lib$adddef(struct mm_decls$strec *owner,struct mm_decls$strec *p);
struct mm_decls$unitrec *mm_lib$createname(struct mm_decls$strec *p);
struct mm_decls$unitrec *mm_lib$createunit0(i64 tag);
struct mm_decls$unitrec *mm_lib$createunit1(i64 tag,struct mm_decls$unitrec *p);
struct mm_decls$unitrec *mm_lib$createunit2(i64 tag,struct mm_decls$unitrec *p,struct mm_decls$unitrec *q);
struct mm_decls$unitrec *mm_lib$createunit3(i64 tag,struct mm_decls$unitrec *p,struct mm_decls$unitrec *q,struct mm_decls$unitrec *r);
void mm_lib$insertunit(struct mm_decls$unitrec *p,i64 tag);
void mm_lib$deleteunit(struct mm_decls$unitrec *p,struct mm_decls$unitrec *q);
struct mm_decls$unitrec *mm_lib$createconstunit(u64 a,i64 t);
struct mm_decls$unitrec *mm_lib$createstringconstunit(u8 *s,i64 length);
i64 mm_lib$newtypename(struct mm_decls$strec *a,struct mm_decls$strec *b);
i64 mm_lib$createusertype(struct mm_decls$strec *stname);
i64 mm_lib$createusertypefromstr(u8 *name);
struct mm_decls$unitrec *mm_lib$getrangelwbunit(struct mm_decls$unitrec *p);
struct mm_decls$unitrec *mm_lib$getrangeupbunit(struct mm_decls$unitrec *p);
i64 mm_lib$createarraymode(struct mm_decls$strec *owner,i64 target,struct mm_decls$unitrec *dimexpr,i64 typedefx);
static i64 mm_lib$sameunit(struct mm_decls$unitrec *p,struct mm_decls$unitrec *q,struct mm_decls$strec *powner,struct mm_decls$strec *qowner);
i64 mm_lib$createarraymodek(struct mm_decls$strec *owner,i64 target,i64 lower,i64 length,i64 typedefx);
u8 *mm_lib$nextautotype(void);
i64 mm_lib$createslicemode(struct mm_decls$strec *owner,i64 slicetype,i64 target,struct mm_decls$unitrec *dimexpr,i64 typedefx);
i64 mm_lib$createslicemodek(struct mm_decls$strec *owner,i64 target,i64 lower,i64 typedefx);
i64 mm_lib$createrefmode(struct mm_decls$strec *owner,i64 target,i64 typedefx);
i64 mm_lib$createrefprocmode(struct mm_decls$strec *owner,struct mm_decls$strec *stproc,struct mm_decls$strec *paramlist,i64 kwd,i64 prettype,i64 typedefx);
void mm_lib$copyttvalues(i64 dest,i64 source);
u8 *mm_lib$getdottedname(struct mm_decls$strec *p);
struct mm_decls$strec *mm_lib$getavname(struct mm_decls$strec *owner,i64 id);
void mm_lib$unionstr_clear(struct mm_decls$uflagsrec *u);
void mm_lib$unionstr_append(struct mm_decls$uflagsrec *u,i64 c);
void mm_lib$unionstr_concat(struct mm_decls$uflagsrec *u,struct mm_decls$uflagsrec *v);
i64 mm_lib$unionstr_last(struct mm_decls$uflagsrec *u);
void mm_lib$unionstr_copy(struct mm_decls$uflagsrec *u,struct mm_decls$uflagsrec *v);
i64 mm_lib$createrecordmode(struct mm_decls$strec *owner,i64 typedefx);
i64 mm_lib$createtuplemode(struct mm_decls$strec *owner,i64 (*elements)[],i64 elementslen,i64 typedefx);
i64 mm_lib$convertstring(u8 *s,u8 *t);
struct mlib$strbuffer *mm_lib$strexpr(struct mm_decls$unitrec *p);
void mm_lib$jevalx(struct mlib$strbuffer *dest,struct mm_decls$unitrec *p);
u8 *mm_lib$strmode(i64 m,i64 expand);
u8 *mm_lib$strmode2(i64 m,i64 expand);
void mm_lib$istrmode(i64 m,i64 expand,u8 *dest);
void mm_lib$addtoproclist(struct mm_decls$strec *d);
void mm_lib$addstatic(struct mm_decls$strec *d);
void mm_lib$addexpconst(struct mm_decls$strec *d);
u8 *mm_lib$typename(i64 m);
struct mm_decls$unitrec *mm_lib$allocunitrec(void);
struct mm_decls$strec *mm_lib$createdupldef(struct mm_decls$strec *owner,struct mm_decls$strec *symptr,i64 id);
struct mm_decls$strec *mm_lib$createnewmoduledef(struct mm_decls$strec *owner,struct mm_decls$strec *symptr,i64 id);
struct mm_decls$unitrec *mm_lib$duplunit(struct mm_decls$unitrec *p,i64 lineno);
i64 mm_lib$checkblockreturn(struct mm_decls$unitrec *p);
i64 mm_lib$isconstunit(struct mm_decls$unitrec *a);
void mm_lib$getownername(struct mm_decls$strec *d,u8 *dest);
i64 mm_lib$getalignment(i64 m);
i64 mm_lib$ispoweroftwo(i64 x);
void mm_lib$addlistunit(struct mm_decls$unitrec **ulist,struct mm_decls$unitrec **ulistx,struct mm_decls$unitrec *p);
i64 mm_lib$storemode(struct mm_decls$strec *owner,i64 m,i32 *pmode);
i64 mm_lib$gettypebase(i64 m);
void mm_lib$writegsfile(u8 *filename,struct mlib$strbuffer *d);
void mm_lib$addtolog(u8 *filename,void *logdest);
struct mm_decls$strec *mm_lib$getprocretmodes(struct mm_decls$unitrec *p);
i64 mm_lib$getmemmode(struct mm_decls$unitrec *p);
i64 mm_lib$getpclmode(i64 t);
u8 *mm_lib$getfullname(struct mm_decls$strec *d);
u8 *mm_lib$getbasename(u8 *s);
void mm_lib$start(void);
i64 mm_libsources$findsyslib(u8 *filename);
void mm_libsources$start(void);
void mm_modules$readprojectfile(u8 *filename);
static void mm_modules$initheadervars(void);
static void mm_modules$readmoduledir(void);
static i64 mm_modules$checkwhen(void);
static void mm_modules$addmodule(u8 *modulename,struct mm_decls$strec *stalias);
static void mm_modules$addsubprogram(u8 *subprogname,i64 fileno);
static void mm_modules$addfirstsubprogram(u8 *progname,i64 fileno);
static void mm_modules$readsubprogram(void);
static void mm_modules$readimport(void);
static void mm_modules$readinclude(void);
static u8 *mm_modules$readvar(void);
static u8 *mm_modules$fixpath(u8 *path);
static void mm_modules$dosetvar(void);
static void mm_modules$doshowvar(void);
static void mm_modules$setmixedprogram(u8 *basefile);
static void mm_modules$setmixedimport(void);
void mm_modules$loadmodules(void);
static void mm_modules$loadmodule(struct mm_decls$modulerec *pm);
static void mm_modules$addsyslib(void);
void mm_modules$addlib(u8 *libname,i64 libtype);
static u8 *mm_modules$readfileline(u8 *s);
static u8 *mm_modules$findnextlineheader(u8 *s);
static u8 *mm_modules$loadmafile(u8 *filespec,u8 *builtinstr);
void mm_modules$start(void);
void mm_name$rx_typetable(void);
void mm_name$rx_unit(struct mm_decls$strec *owner,struct mm_decls$unitrec *p);
i64 mm_name$rx_module(i64 n);
void mm_name$rx_deflist(struct mm_decls$strec *owner,struct mm_decls$strec *p);
void mm_name$rx_passdef(struct mm_decls$strec *owner,struct mm_decls$strec *p);
static void mm_name$rx_unitlist(struct mm_decls$strec *owner,struct mm_decls$unitrec *p);
struct mm_decls$strec *mm_name$resolvetopname(struct mm_decls$strec *owner,struct mm_decls$strec *stnewname,i64 moduleno,i64 allowmod);
void mm_name$resolvename(struct mm_decls$strec *owner,struct mm_decls$unitrec *p);
struct mm_decls$strec *mm_name$finddupl(struct mm_decls$strec *d,struct mm_decls$strec *pdupl);
struct mm_decls$strec *mm_name$finddupl_sub(struct mm_decls$strec *d,struct mm_decls$strec *pdupl);
static void mm_name$resolvedot(struct mm_decls$strec *owner,struct mm_decls$unitrec *p);
static void mm_name$fixmode(struct mm_decls$typenamerec *p);
void mm_name$fixusertypes(void);
static struct mm_decls$strec *mm_name$addframevar(struct mm_decls$strec *owner,struct mm_decls$strec *d,i64 moduleno,i64 mode);
static struct mm_decls$unitrec *mm_name$copylistunit(struct mm_decls$unitrec *p);
static struct mm_decls$unitrec *mm_name$copyunit(struct mm_decls$unitrec *p);
static void mm_name$replaceunit(struct mm_decls$unitrec *p,struct mm_decls$unitrec *q);
static void mm_name$expandmacro(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mm_name$duplfield(struct mm_decls$strec *owner,struct mm_decls$strec *p,struct mm_decls$strec *q);
static void mm_name$do_baseclass(struct mm_decls$strec *p);
void mm_name$start(void);
i64 mm_parse$parsemodule(i64 n);
struct mm_decls$unitrec *mm_parse$readmoduledefs(struct mm_decls$strec *owner);
static void mm_parse$initparser(void);
void mm_parse$skipsemi(void);
struct mm_decls$unitrec *mm_parse$makeblock(struct mm_decls$unitrec *p);
static void mm_parse$checkequals(void);
static i64 mm_parse$getcurrline(void);
static i64 mm_parse$checkbegin(i64 fbrack);
static void mm_parse$checkbeginend(i64 closesym,i64 kwd,i64 startline);
void mm_parse$checkend(i64 endsym,i64 endkwd1,i64 endkwd2,i64 startline);
static struct mm_decls$unitrec *mm_parse$readvardef(struct mm_decls$strec *owner,i64 scope,i64 isstatic,i64 varid,i64 k);
static void mm_parse$readconstdef(struct mm_decls$strec *owner,i64 scope);
static struct mm_decls$unitrec *mm_parse$readlbrack(void);
static void mm_parse$addlistparam(struct mm_decls$strec **ulist,struct mm_decls$strec **ulistx,struct mm_decls$strec *p);
static struct mm_decls$unitrec *mm_parse$readcast(void);
static struct mm_decls$unitrec *mm_parse$readopc(void);
static struct mm_decls$unitrec *mm_parse$readsprint(void);
static struct mm_decls$unitrec *mm_parse$readsread(void);
static struct mm_decls$unitrec *mm_parse$readcompilervar(void);
static struct mm_decls$unitrec *mm_parse$readcastx(void);
void mm_parse$checksymbol(i64 symbol);
void mm_parse$lexchecksymbol(i64 symbol);
i64 mm_parse$readtypespec(struct mm_decls$strec *owner,i64 typedefx);
static i64 mm_parse$readslicetype(struct mm_decls$strec *owner,i64 slicetype,i64 typedefx);
static struct mm_decls$unitrec *mm_parse$readslist(i64 iscall,i64 donulls);
static struct mm_decls$unitrec *mm_parse$readindex(struct mm_decls$unitrec *p,i64 dot);
static struct mm_decls$unitrec *mm_parse$readdotsuffix(struct mm_decls$unitrec *p);
static struct mm_decls$unitrec *mm_parse$readconstexpr(i64 needconst);
static i64 mm_parse$readconstint(void);
static void mm_parse$readprocdef(struct mm_decls$strec *procowner,i64 scope,i64 fflang);
struct mm_decls$strec *mm_parse$readprocdecl(struct mm_decls$strec *procowner,i64 scope,i64 fflang);
static struct mm_decls$strec *mm_parse$readparams(struct mm_decls$strec *procowner,struct mm_decls$strec *owner,i64 fflang,i64 *varparams,i64 *nparams);
static struct mm_decls$unitrec *mm_parse$readcondsuffix(struct mm_decls$unitrec *p);
static struct mm_decls$unitrec *mm_parse$readif(void);
static struct mm_decls$unitrec *mm_parse$readgoto(i64 gototag);
static struct mm_decls$unitrec *mm_parse$readunless(void);
static struct mm_decls$unitrec *mm_parse$readswitchcase(void);
static struct mm_decls$unitrec *mm_parse$readstop(void);
static struct mm_decls$unitrec *mm_parse$readreturn(void);
static struct mm_decls$unitrec *mm_parse$readdo(void);
static struct mm_decls$unitrec *mm_parse$readto(void);
static struct mm_decls$unitrec *mm_parse$readwhile(void);
static struct mm_decls$unitrec *mm_parse$readrepeat(void);
static struct mm_decls$unitrec *mm_parse$readloopcontrol(void);
static struct mm_decls$unitrec *mm_parse$readprint(void);
static struct mm_decls$unitrec *mm_parse$readread(void);
static struct mm_decls$unitrec *mm_parse$readfor(void);
static struct mm_decls$unitrec *mm_parse$readname(void);
void mm_parse$readtypedef(struct mm_decls$strec *owner,i64 scope);
void mm_parse$readrecordfields(struct mm_decls$strec *owner,i64 m);
void mm_parse$readtabledef(struct mm_decls$strec *owner,i64 scope);
void mm_parse$readclassdef(struct mm_decls$strec *owner,i64 scope);
static void mm_parse$readclassbody(struct mm_decls$strec *owner,i64 classkwd);
static void mm_parse$readimportmodule(struct mm_decls$strec *owner);
static void mm_parse$readimportbody(struct mm_decls$strec *owner);
static struct mm_decls$strec *mm_parse$readequivfield(struct mm_decls$strec *owner);
static i64 mm_parse$readrefproc(struct mm_decls$strec *owner,i64 typedefx,i64 fflang);
static void mm_parse$pushproc(struct mm_decls$strec *p);
static void mm_parse$popproc(void);
static struct mm_decls$unitrec *mm_parse$makeastring(void);
static i64 mm_parse$readreturntype(struct mm_decls$strec *owner,i64 (*retmodes)[]);
static struct mm_decls$unitrec *mm_parse$readset(void);
static i64 mm_parse$istypestarter(void);
struct mm_decls$unitrec *mm_parse$readunit(void);
static struct mm_decls$unitrec *mm_parse$readassignment(struct mm_decls$unitrec *pt);
static struct mm_decls$unitrec *mm_parse$readorterms(struct mm_decls$unitrec *pt);
static struct mm_decls$unitrec *mm_parse$readandterms(struct mm_decls$unitrec *pt);
static struct mm_decls$unitrec *mm_parse$readcmpterms(struct mm_decls$unitrec *pt);
static struct mm_decls$unitrec *mm_parse$readinterms(struct mm_decls$unitrec *pt);
static struct mm_decls$unitrec *mm_parse$readrangeterm(struct mm_decls$unitrec *pt);
static struct mm_decls$unitrec *mm_parse$readaddterms(struct mm_decls$unitrec *pt);
static struct mm_decls$unitrec *mm_parse$readmulterms(struct mm_decls$unitrec *pt);
static struct mm_decls$unitrec *mm_parse$readpowerterms(struct mm_decls$unitrec *p);
static struct mm_decls$unitrec *mm_parse$readterm2(void);
static struct mm_decls$unitrec *mm_parse$readterm(void);
static void mm_parse$readmacrodef(struct mm_decls$strec *owner,i64 scope);
static struct mm_decls$unitrec *mm_parse$readrecase(void);
static void mm_parse$adddocstring(u8 *s);
static struct mm_decls$unitrec *mm_parse$fixcond(struct mm_decls$unitrec *p);
static struct mm_decls$unitrec *mm_parse$readsunit(i64 inwhile);
void mm_parse$start(void);
i64 mm_support$loadsourcefile(u8 *filespec);
static i64 mm_support$loadbundledfile(u8 *filespec,i64 issyslib,i64 support);
void mm_support$mcerror(u8 *mess);
void mm_support$serror_gen(u8 *mess);
static void mm_support$showdivider(u64 ch);
static void mm_support$showerrorsource(i64 pos,struct mm_decls$strec *stproc);
void mm_support$stopcompiler(u8 *filename,i64 lineno);
void mm_support$serror(u8 *mess);
void mm_support$serror_s(u8 *mess,u8 *a);
void mm_support$error_gen(i64 pass,u8 *mess,struct mm_decls$unitrec *p);
void mm_support$rxerror(u8 *mess,struct mm_decls$unitrec *p);
i64 mm_support$gerror(u8 *mess,struct mm_decls$unitrec *p);
void mm_support$axerror(u8 *mess);
void mm_support$txerror(u8 *mess,struct mm_decls$unitrec *p);
void mm_support$txerror_s(u8 *mess,u8 *a,struct mm_decls$unitrec *p);
void mm_support$txerror_ss(u8 *mess,u8 *a,u8 *b);
void mm_support$rxerror_s(u8 *mess,u8 *a,struct mm_decls$unitrec *p);
void mm_support$gerror_s(u8 *mess,u8 *s,struct mm_decls$unitrec *p);
void mm_support$gerror_t(u8 *mess,struct mm_decls$unitrec *p);
void mm_support$lxerror_gen(u8 *mess);
void mm_support$lxerror(u8 *mess);
void mm_support$loaderror(u8 *mess,u8 *mess2,u8 *mess3);
void mm_support$gs_additem(struct mlib$strbuffer *dest,u8 *s);
void mm_support$gs_copytostr(struct mlib$strbuffer *source,u8 *s);
i64 mm_support$isalphanum(i64 c);
void mm_support$init_tt_tables(void);
void mm_support$addspecialtypes(void);
i64 mm_support$getsupportfile(u8 *filename,u8 *ext,u8 *path,i64 issyslib,i64 issupport);
static i64 mm_support$isabspath(u8 *filespec);
void mm_support$initbblib(void);
i64 mm_support$getfileno(u64 pos);
i64 mm_support$getlineno(u64 pos);
static u8 *mm_support$getsourceline(u64 pos);
static u8 *mm_support$getsourcestart(u64 pos);
static u8 *mm_support$getsourcepos(u64 pos);
void mm_support$do_writema(void);
void mm_support$start(void);
void mm_tables$start(void);
static void mm_type$tpass(struct mm_decls$unitrec *p,i64 t,i64 lv);
void mm_type$tx_allprocs(void);
static void mm_type$tx_block(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t,i64 lv);
void mm_type$tx_typetable(void);
static void mm_type$setmodesize(i64 m);
static void mm_type$setarraysize(i64 m);
static void mm_type$setslicesize(i64 m);
i64 mm_type$tx_module(i64 n);
void mm_type$tx_passdef(struct mm_decls$strec *p);
static void mm_type$tx_unitlist(struct mm_decls$unitrec *p,i64 t,i64 lv);
static void mm_type$tx_namedef(struct mm_decls$strec *d);
void mm_type$tx_namedconst(struct mm_decls$strec *d);
static void mm_type$checkconstexpr(struct mm_decls$unitrec *p);
static i64 mm_type$getconstint(struct mm_decls$unitrec *q);
static void mm_type$makenewconst(struct mm_decls$unitrec *p,i64 x,i64 t);
static void mm_type$tx_name(struct mm_decls$unitrec *p,i64 t,i64 lv);
static void mm_type$tx_bin(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mm_type$tx_binto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static i64 mm_type$getdominantmode(i64 amode,i64 bmode);
static void mm_type$tx_cmpchain(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$tx_callproc(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *pargs,i64 t);
static void mm_type$tx_unary(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$tx_if(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pcond,struct mm_decls$unitrec *plist,struct mm_decls$unitrec *pelse,i64 t,i64 lv);
static void mm_type$tx_incrto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t);
static void mm_type$tx_for(struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *pfrom,struct mm_decls$unitrec *pbody);
static void mm_type$tx_forall(struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *plist,struct mm_decls$unitrec *pbody);
static void mm_type$tx_index(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 t,i64 lv);
static void mm_type$tx_makerange(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mm_type$tx_ptr(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t,i64 lv);
static void mm_type$setrecordsize(i64 m);
static void mm_type$checkblocktype(i64 m);
static void mm_type$scanrecord(i64 state,struct mm_decls$strec *(*fields)[],i64 *index,i64 *isize,i64 offset,i64 calign,i64 *maxalign);
static i64 mm_type$roundoffset(i64 offset,i64 alignment);
static void mm_type$tx_convert(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 hard);
static void mm_type$tx_makelist(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t,i64 lv);
static void mm_type$tx_makeslice(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t);
static void mm_type$tx_makeset(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t);
static void mm_type$tx_dot(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 lv);
static struct mm_decls$strec *mm_type$resolvefield(struct mm_decls$strec *d,i64 m);
static void mm_type$tx_andl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mm_type$convintconst(struct mm_decls$unitrec *p,i64 x);
static void mm_type$tx_sliceptr(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$tx_swap(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mm_type$tx_select(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 t,i64 lv);
static void mm_type$tx_case(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 t,i64 lv);
static void mm_type$tx_notl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$tx_istruel(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$tx_typepun(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$tx_exit(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$tx_goto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$tx_switch(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 t,i64 lv);
static void mm_type$tx_addroffirst(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t);
static void mm_type$tx_return(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t);
static void mm_type$tx_dotindex(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 lv);
static void mm_type$tx_slice(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mm_type$twiden(struct mm_decls$unitrec *p,i64 lv);
static void mm_type$tstringslice(struct mm_decls$unitrec *p,i64 slicemode);
static void mm_type$tx_bitfield(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 lv);
static void mm_type$deref(struct mm_decls$unitrec *a,i64 needres);
static void mm_type$tmethodcall(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pdot,struct mm_decls$unitrec *pargs);
static void mm_type$do_bounds(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$addnotl(struct mm_decls$unitrec *p);
static void mm_type$tevaluate(struct mm_decls$unitrec *p);
static struct mm_decls$unitrec *mm_type$addrdotindex(struct mm_decls$unitrec *p,i64 *offset);
static void mm_type$tevalbinop(struct mm_decls$unitrec *p);
static void mm_type$tevalmonop(struct mm_decls$unitrec *p);
static i64 mm_type$iscondtrue(struct mm_decls$unitrec *p);
static i64 mm_type$iscondfalse(struct mm_decls$unitrec *p);
static void mm_type$fixchararray(struct mm_decls$unitrec *a);
static void mm_type$combinestrings(struct mm_decls$unitrec *p);
static void mm_type$tx_strinclude(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a);
static void mm_type$coerceunit(struct mm_decls$unitrec *p,i64 t,i64 hard);
static i64 mm_type$getconversionop(i64 s,i64 t,i64 hard);
static void mm_type$applyconversion(struct mm_decls$unitrec *p,i64 s,i64 t,i64 opc);
static void mm_type$checkmodes(i64 s,i64 t);
static i64 mm_type$comparemodes(i64 s,i64 t);
static i64 mm_type$tevalconvert(struct mm_decls$unitrec *p,i64 s,i64 t,i64 opc);
static void mm_type$tx_assign(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 t);
static void mm_type$tx_assignmultmult(struct mm_decls$unitrec *pp,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mm_type$tx_assignmultscalar(struct mm_decls$unitrec *pp,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 t);
static void mm_type$tpasslv(struct mm_decls$unitrec *p,i64 t);
static i64 mm_type$dobinnumx(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static i64 mm_type$dobinnumf(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static i64 mm_type$dobinnumi(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static i64 mm_type$doin(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b);
static void mm_type$setsimple(struct mm_decls$unitrec *p);
void mm_type$start(void);
i64 mc_genmcl$codegen_mcl(void);
static void mc_genmcl$genprocdef(struct mm_decls$strec *p);
static void mc_genmcl$dostaticvar(struct mm_decls$strec *d);
static void mc_genmcl$genidata(struct mm_decls$unitrec *p,i64 doterm,i64 am,i64 offset);
static void mc_genmcl$checkreturn(struct mm_decls$strec *p);
static void mc_genmcl$genreturn(void);
static void mc_genmcl$genlocals(struct mm_decls$strec *p);
static void mc_genmcl$spillparams(void);
static void mc_genmcl$genblocktemps(void);
static void mc_genmcl$docallproc(struct mm_decls$strec *d);
static void mc_genmcl$genmaindef(struct mm_decls$strec *p);
static void mc_genmcl$genstartdef(struct mm_decls$strec *p);
struct mm_decls$strec *mc_genmcl$newblocktemp(i64 m);
static void mc_genmcl$setmclentry(struct mc_decls$mclrec *p);
static struct mc_decls$mclrec *mc_genmcl$resetmclentry(void);
void mc_genmcl$start(void);
void mc_genss$genss(void);
static void mc_genss$doinstr(struct mc_decls$mclrec *m,i64 index);
static void mc_genss$genword(i64 x);
static void mc_genss$gendword(i64 x);
static void mc_genss$genqword(i64 x);
static void mc_genss$genopnd(struct mc_decls$opndrec *a,i64 size);
static void mc_genss$addrelocitem(i64 reloctype,struct mm_decls$strec *d);
static i64 mc_genss$getstindex(struct mm_decls$strec *d);
static void mc_genss$genrel32(struct mc_decls$opndrec *a);
static struct mm_decls$strec *mc_genss$getdef(struct mc_decls$opndrec *a,i64 dneeded);
static void mc_genss$genabs32(struct mc_decls$opndrec *a);
static void mc_genss$genabs64(struct mc_decls$opndrec *a);
static i64 mc_genss$getrel32(struct mm_decls$strec *d,i64 offset);
static void mc_genss$dofwdrefs(struct mm_decls$strec *d);
static void mc_genss$genrex(void);
static i64 mc_genss$isbytesized(i64 x);
static i64 mc_genss$isdwordsized(i64 x);
static void mc_genss$do_push(struct mc_decls$opndrec *a);
static void mc_genss$do_pop(struct mc_decls$opndrec *a);
static void mc_genss$do_inc(struct mc_decls$opndrec *a,i64 code);
static void mc_genss$do_neg(struct mc_decls$opndrec *a,i64 code);
static void mc_genss$genamode(struct mc_decls$opndrec *a,i64 am);
static void mc_genss$setopsize(struct mc_decls$opndrec *a);
static i64 mc_genss$getdispsize(struct mc_decls$opndrec *a,i64 *offset);
static i64 mc_genss$genrm(struct mc_decls$opndrec *a,i64 opc);
static i64 mc_genss$makeam(i64 m,i64 s,i64 d);
static i64 mc_genss$makemodrm(i64 mode,i64 opc,i64 rm);
static void mc_genss$do_arith(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 code);
static void mc_genss$do_mov(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
static i64 mc_genss$getregcoder(i64 reg);
static i64 mc_genss$getregcodeb(i64 reg);
static i64 mc_genss$getregcodebx(i64 reg);
static i64 mc_genss$getregcoderx(i64 reg);
static void mc_genss$do_lea(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
static void mc_genss$do_movsx(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc);
static void mc_genss$checkhighreg(struct mc_decls$opndrec *a);
static void mc_genss$do_exch(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
static void mc_genss$do_movsxd(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
static void mc_genss$do_imul2(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
static void mc_genss$do_shift(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc);
static void mc_genss$do_test(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
static void mc_genss$do_loop(struct mc_decls$opndrec *a,i64 opc);
static void mc_genss$do_jcxz(struct mc_decls$opndrec *a,i64 opsize);
static void mc_genss$do_setcc(i64 cond,struct mc_decls$opndrec *a);
static void mc_genss$do_movxmm(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 size);
static void mc_genss$do_arithxmm(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 prefix,i64 opc);
static void mc_genss$do_logicxmm(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc,i64 size);
static void mc_genss$do_convertfloat(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 prefix);
static void mc_genss$do_fix(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 prefix,i64 opc);
static void mc_genss$do_float(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 prefix);
static void mc_genss$do_call(struct mc_decls$opndrec *a);
static void mc_genss$do_jmp(struct mc_decls$opndrec *a,struct mc_decls$mclrec *m);
static i64 mc_genss$getcurrdatalen(i64 id);
static void mc_genss$do_cmovcc(i64 cond,struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
static void mc_genss$do_fmem(struct mc_decls$opndrec *a,i64 freal,i64 code);
static void mc_genss$genrel8(struct mc_decls$opndrec *a);
static i64 mc_genss$checkshortjump(struct mc_decls$mclrec *m,struct mm_decls$strec *d);
static struct mm_decls$fwdrec *mc_genss$addfwdref(struct mm_decls$fwdrec *p,i64 offset,i64 reltype,i64 seg);
static void mc_genss$switchseg(i64 newseg);
static void mc_genss$do_movdqx(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc);
static void mc_genss$do_popcnt(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
static void mc_genss$do_bsf(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc);
static void mc_genss$extendsymboltable(void);
static void mc_genss$fixregvar(void);
void mc_genss$initlib(i64 nlabels);
struct mc_decls$dbuffer *mc_genss$buffercreate(i64 size);
static void mc_genss$bufferexpand(struct mc_decls$dbuffer *a);
void mc_genss$buffercheck(struct mc_decls$dbuffer *a,i64 n);
i64 mc_genss$bufferlength(struct mc_decls$dbuffer *a);
void *mc_genss$bufferelemptr(struct mc_decls$dbuffer *a,i64 offset);
void mc_genss$addword(struct mc_decls$dbuffer *a,i64 x);
void mc_genss$adddword(struct mc_decls$dbuffer *a,i64 x);
void mc_genss$addqword(struct mc_decls$dbuffer *a,i64 x);
void mc_genss$start(void);
void mc_libmcl$mclinit(void);
void mc_libmcl$initmcdest(void);
void mc_libmcl$genmc(i64 opcode,struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
void mc_libmcl$genmc_cond(i64 opcode,i64 cond,struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
void mc_libmcl$genmc_str(i64 opcode,u8 *s);
struct mc_decls$opndrec *mc_libmcl$newmclopnd(void);
struct mc_decls$opndrec *mc_libmcl$duplopnd(struct mc_decls$opndrec *a);
struct mc_decls$opndrec *mc_libmcl$genxreg(i64 xreg,i64 size);
struct mc_decls$opndrec *mc_libmcl$genindex(i64 areg,i64 ireg,i64 scale,i64 offset,i64 size,i64 labno,struct mm_decls$strec *def);
struct mlib$strbuffer *mc_libmcl$getmclstr(void);
void mc_libmcl$gencomment(u8 *s,u8 *t);
struct mc_decls$opndrec *mc_libmcl$genstring(u8 *s,i64 length);
struct mc_decls$opndrec *mc_libmcl$gencommentstring(u8 *s,i64 length);
struct mc_decls$opndrec *mc_libmcl$genname(u8 *s);
static void mc_libmcl$writemcl(i64 index,struct mc_decls$mclrec *mcl);
void mc_libmcl$strmcl(struct mc_decls$mclrec *mcl);
void mc_libmcl$asmopnd(struct mc_decls$opndrec *a,i64 sizeprefix,i64 debug);
void mc_libmcl$setsegment(i64 seg,i64 align);
u8 *mc_libmcl$getsizeprefix(i64 size,i64 enable);
i64 mc_libmcl$needsizeprefix(i64 opcode,struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
struct mc_decls$opndrec *mc_libmcl$changeopndsize(struct mc_decls$opndrec *a,i64 size);
struct mc_decls$opndrec *mc_libmcl$makeopndind(struct mc_decls$opndrec *a,i64 size);
struct mc_decls$opndrec *mc_libmcl$applyoffset(struct mc_decls$opndrec *a,i64 offset,i64 size);
struct mc_decls$opndrec *mc_libmcl$genint(i64 x,i64 size);
struct mc_decls$opndrec *mc_libmcl$genrealmem(r64 x,i64 mode);
struct mc_decls$opndrec *mc_libmcl$genrealimm(r64 x,i64 mode);
struct mc_decls$opndrec *mc_libmcl$genlabel(i64 x);
struct mc_decls$opndrec *mc_libmcl$genlabelmem(i64 x);
struct mc_decls$opndrec *mc_libmcl$genregvar(struct mm_decls$strec *d);
struct mc_decls$opndrec *mc_libmcl$genxregvar(struct mm_decls$strec *d);
struct mc_decls$opndrec *mc_libmcl$genmem(struct mm_decls$strec *d);
struct mc_decls$opndrec *mc_libmcl$genmemaddr(struct mm_decls$strec *d);
struct mc_decls$opndrec *mc_libmcl$genreg(i64 reg,i64 size);
struct mc_decls$opndrec *mc_libmcl$genreg0(i64 reg,i64 size);
struct mc_decls$opndrec *mc_libmcl$genireg(i64 reg,i64 size,i64 offset);
i64 mc_libmcl$roundsizetg(i64 size);
u8 *mc_libmcl$getregname(i64 reg,i64 size);
u8 *mc_libmcl$getxregname(i64 reg,i64 size);
i64 mc_libmcl$sameoperand(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
i64 mc_libmcl$sameregopnd(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b);
i64 mc_libmcl$getstringindex(u8 *s);
i64 mc_libmcl$addconst(struct mc_decls$constrec **clist,i64 value);
i64 mc_libmcl$getrealindex(r64 x);
i64 mc_libmcl$getreal32index(r64 x);
static void mc_libmcl$asmstr(u8 *s);
static void mc_libmcl$asmchar(i64 c);
u8 *mc_libmcl$getdispname(struct mm_decls$strec *d);
void mc_libmcl$merror(u8 *mess,u8 *param);
void mc_libmcl$merrort(u8 *mess,i64 t);
void mc_libmcl$genstringtable(void);
void mc_libmcl$genstringimm(u8 *s,i64 doterm);
static void mc_libmcl$gendb(i64 a);
static void mc_libmcl$gendbstring(u8 *s,i64 length);
static void mc_libmcl$gendq(i64 a);
void mc_libmcl$genrealtable(void);
void mc_libmcl$genabsneg(void);
i64 mc_libmcl$createfwdlabel(void);
void mc_libmcl$definefwdlabel(i64 lab);
i64 mc_libmcl$definelabel(void);
u8 *mc_libmcl$stropnd(struct mc_decls$opndrec *a,i64 sizeprefix,i64 debug);
static u8 *mc_libmcl$strreg(i64 reg,i64 size);
static struct mm_decls$strec *mc_libmcl$checkregvar(i64 reg,i64 isfloat);
u8 *mc_libmcl$strvalue(struct mc_decls$opndrec *a);
static struct mc_decls$opndrec *mc_libmcl$makesimpleaddr(struct mc_decls$opndrec *ax);
static struct mc_decls$opndrec *mc_libmcl$makeblockaddr(struct mc_decls$opndrec *ax);
void mc_libmcl$clearblock(struct mc_decls$opndrec *ax,i64 n);
void mc_libmcl$copyblock(struct mc_decls$opndrec *ax,struct mc_decls$opndrec *bx,i64 n,i64 savedest);
void mc_libmcl$genfunctable(void);
struct mc_decls$opndrec *mc_libmcl$genextname(u8 *s);
void mc_libmcl$domcl_assem(struct mm_decls$unitrec *pcode);
static struct mc_decls$opndrec *mc_libmcl$genasmopnd(struct mm_decls$unitrec *p);
i64 mc_libmcl$getnextreg(void);
i64 mc_libmcl$getnextxreg(void);
void mc_libmcl$pushstack(i64 n);
void mc_libmcl$popstack(i64 n);
u8 *mc_libmcl$showregset(u8 *caption);
void mc_libmcl$stacklooplabels(i64 a,i64 b,i64 c);
i64 mc_libmcl$findlooplabel(i64 k,i64 n);
i64 mc_libmcl$getopndmov(struct mc_decls$opndrec *ax);
struct mc_decls$opndrec *mc_libmcl$getregopnd(struct mm_decls$unitrec *a);
i64 mc_libmcl$getmclcond(i64 cond,i64 mode);
void mc_libmcl$popregs(u64 regs,struct mc_decls$opndrec *ax);
i64 mc_libmcl$getlowreg(struct mc_decls$opndrec *ax);
void mc_libmcl$mulimm(struct mc_decls$opndrec *ax,i64 n);
i64 mc_libmcl$scaleindex(struct mc_decls$opndrec *ax,i64 scale);
struct mc_decls$opndrec *mc_libmcl$gensysfn(i64 fnindex,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c);
struct mc_decls$opndrec *mc_libmcl$gensysproc(i64 fnindex,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 asfunc);
struct mm_decls$strec *mc_libmcl$getsysfnhandler(i64 fn);
static void mc_libmcl$setbit(u64 *a,i64 n,i64 x);
static i64 mc_libmcl$getbit(u64 a,i64 n);
void mc_libmcl$setregbit(i64 n);
void mc_libmcl$clrregbit(i64 n);
i64 mc_libmcl$getregbit(i64 n);
void mc_libmcl$setxregbit(i64 n);
void mc_libmcl$clrxregbit(i64 n);
i64 mc_libmcl$getxregbit(i64 n);
void mc_libmcl$setopndsize(struct mc_decls$opndrec *ax,i64 size);
struct mc_decls$opndrec *mc_libmcl$getretopnd(i64 mode);
void mc_libmcl$start(void);
void mc_decls$start(void);
void mc_objdecls$start(void);
struct mx_decls$librec *mc_run$writememlib(u8 *filename);
static void mc_run$roundsegment(struct mc_decls$dbuffer *p,i64 align,i64 value);
static void mc_run$writerelocs(struct mx_decls$librec *lib);
static void mc_run$addsymbols(struct mx_decls$librec *lib);
void mc_run$start(void);
void mc_write$writemcx(u8 *filename);
void mc_write$writerelocs(void);
void mc_write$countsymbols(void);
static void mc_write$writesymbols(void);
static void mc_write$roundsegment(struct mc_decls$dbuffer *p,i64 align,i64 value);
static void mc_write$genbyte(i64 x);
static void mc_write$genword32(i64 x);
static void mc_write$genstring(u8 *s);
static void mc_write$genblock(void *p,i64 length);
void mc_write$start(void);
void mc_writeexe$writeexe(u8 *outfile,i64 dodll);
void mc_writeexe$genexe(u8 *entrypoint,u8 *outfile,i64 dodll);
static void mc_writeexe$loadlibs(void);
void mc_writeexe$initsectiontable(void);
static u8 *mc_writeexe$extractlibname(u8 *name,i64 *libno,i64 moduleno);
static void mc_writeexe$scanst(void);
static void mc_writeexe$relocdata(struct mc_objdecls$sectionrec *s);
static void mc_writeexe$getbaserelocs(struct mc_objdecls$sectionrec *s);
static void mc_writeexe$writerecordx(void *r,i64 length);
static void mc_writeexe$writedosstub(void);
static void mc_writeexe$writepesig(void);
static void mc_writeexe$writepadding(i64 offset);
static void mc_writeexe$writefileheader(void);
static void mc_writeexe$writeoptheader(void);
static void mc_writeexe$writesectionheader(struct mc_objdecls$sectionrec *s);
static void mc_writeexe$writesectiondata(struct mc_objdecls$sectionrec *s);
static void mc_writeexe$writeexporttable(byte *pstart);
static i64 mc_writeexe$getexporttablesize(void);
static void mc_writeexe$newbasereloc(i64 addr,i64 reltype);
static void mc_writeexe$scanbaserelocs(void);
static void mc_writeexe$writebasereloctable(byte *pstart);
static void mc_writeexe$sortexports(i64 (*sortindex)[]);
static i64 mc_writeexe$getsectionno(i64 segment);
static void mc_writeexe$getoffsets(void);
void mc_writeexe$start(void);
void mx_decls$start(void);
struct mx_decls$librec *mx_lib$readlibfile(u8 *filespec,byte *p);
static i64 mx_lib$readbyte(byte **p);
static u64 mx_lib$readu32(byte **p);
static u8 *mx_lib$readstring(byte **p);
void mx_lib$alloclibdata(struct mx_decls$librec *lib);
void mx_lib$error(u8 *mess,u8 *param);
void mx_lib$loadmemmcu(struct mx_decls$librec *lib);
void mx_lib$checknew(u8 *name,u8 *filename);
i64 mx_lib$findlib(u8 *name);
i64 mx_lib$mxaddlib(u8 *name);
void mx_lib$fixuplib(struct mx_decls$librec *lib);
static void mx_lib$loaddlls(void);
static void *mx_lib$finddllsymbol(u8 *name,i64 *dllindex);
static void mx_lib$checksymbols(void);
static void mx_lib$dorelocations(void);
static void mx_lib$reloclib(struct mx_decls$librec *lib);
void mx_lib$loadimports(struct mx_decls$librec *plib);
static void mx_lib$dosublib(u8 *name);
struct mx_decls$librec *mx_lib$loadlibfile(u8 *filename,i64 libno);
static void mx_lib$dosymbols(struct mx_decls$librec *lib);
static byte *mx_lib$readmxfile(u8 *filename);
static void mx_lib$adddll(u8 *name);
static i64 mx_lib$addsymbol(u8 *name);
static void mx_lib$setspecialglobals(i64 cmdskip);
void mx_lib$runprogram(struct mx_decls$librec *lib,i64 cmdskip);
void mx_lib$calllibinit(struct mx_decls$librec *lib);
void *mx_lib$findsymbol(u8 *name);
struct mx_decls$librec *mx_lib$loadmx(u8 *filename);
struct mx_decls$librec *mx_lib$loadmemmcb(u8 *filename,byte *p);
void mx_lib$mltest(void);
void mx_lib$start(void);
void mx_show$initlogfile(void);
void mx_show$closelogfile(void);
void mx_show$showlibs(void);
void mx_show$showlib(struct mx_decls$librec *lib,void *logdev);
static void mx_show$showstr(u8 *str);
static void mx_show$showstrln(u8 *str);
static void mx_show$showstrint(i64 a);
static void mx_show$shownames(u8 *(*names)[],i64 n);
static void mx_show$showrelocs(struct mx_decls$librec *lib);
static void mx_show$showsectiondata(byte *p,i64 length);
static void mx_show$showsectioncode(byte *p,i64 length,i64 extra);
void mx_show$showglobals(void *logdev);
void mx_show$start(void);
void msysc$m_init(i64 nargs,u8 *(*args)[],u8 *(*envstrings)[]);
i64 msysc$m_getdotindex(u64 a,i64 i);
u64 msysc$m_setdotindex(u64 a,i64 i,i64 x);
i64 msysc$m_getdotslice(u64 a,i64 i,i64 j);
u64 msysc$m_setdotslice(u64 a,i64 i,i64 j,u64 x);
i64 msysc$m_get_nprocs(void);
i64 msysc$m_get_nexports(void);
u8 *msysc$m_get_procname(i64 n);
void *msysc$m_get_procaddr(i64 n);
void *msysc$m_get_procexport(i64 n);
static void msysc$pushio(void);
void msysc$m_print_startfile(void *dev);
void msysc$m_print_startstr(u8 *s);
void msysc$m_print_startptr(u8 **p);
void msysc$m_print_startcon(void);
void msysc$m_print_setfmt(u8 *format);
void msysc$m_print_end(void);
void msysc$m_print_ptr(void *a,u8 *fmtstyle);
void msysc$m_print_i64(i64 a,u8 *fmtstyle);
void msysc$m_print_u64(u64 a,u8 *fmtstyle);
void msysc$m_print_r64(r64 x,u8 *fmtstyle);
void msysc$m_print_r32(r32 x,u8 *fmtstyle);
void msysc$m_print_c8(i64 a,u8 *fmtstyle);
void msysc$m_print_str(u8 *s,u8 *fmtstyle);
void msysc$m_print_newline(void);
void msysc$m_print_nogap(void);
void msysc$m_print_space(void);
void msysc$printstr(u8 *s);
void msysc$printstr_n(u8 *s,i64 n);
void msysc$printstrn_app(u8 *s,i64 length,void *f);
static u8 *msysc$makezstring(u8 *s,i64 n,u8 *local);
static void msysc$freezstring(u8 *t,i64 n);
static void msysc$printchar(i64 ch);
void msysc$nextfmtchars(i64 lastx);
void msysc$strtofmt(u8 *s,i64 slen,struct msysc$fmtrec *fmt);
static i64 msysc$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt);
static i64 msysc$expandstr(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt);
static i64 msysc$u64tostr(u64 aa,u8 *s,u64 base,i64 sep);
static i64 msysc$i64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt);
static i64 msysc$u64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt);
static i64 msysc$i64mintostr(u8 *s,i64 base,i64 sep);
static i64 msysc$strtostrfmt(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt);
static void msysc$tostr_i64(i64 a,struct msysc$fmtrec *fmt);
static void msysc$tostr_u64(u64 a,struct msysc$fmtrec *fmt);
static void msysc$tostr_r64(r64 x,struct msysc$fmtrec *fmt);
static void msysc$tostr_str(u8 *s,struct msysc$fmtrec *fmt);
static struct msysc$fmtrec *msysc$getfmt(u8 *fmtstyle);
u8 *msysc$strint(i64 a,u8 *fmtstyle);
void msysc$getstrint(i64 a,u8 *dest);
u8 *msysc$strword(u64 a,u8 *fmtstyle);
u8 *msysc$strreal(r64 a,u8 *fmtstyle);
static u8 *msysc$getstr(u8 *s,struct msysc$fmtrec *fmt);
static void msysc$initreadbuffer(void);
void msysc$m_read_conline(void);
void msysc$m_read_fileline(void *f);
void msysc$m_read_strline(u8 *s);
static u8 *msysc$readitem(i64 *itemlength);
i64 msysc$strtoint(u8 *s,i64 length,i64 base);
i64 msysc$m_read_i64(i64 fmt);
r64 msysc$m_read_r64(i64 fmt);
void msysc$m_read_str(u8 *dest,i64 destlen,i64 fmt);
void msysc$readstr(u8 *dest,i64 fmt,i64 destlen);
void msysc$rereadln(void);
void msysc$reread(void);
i64 msysc$valint(u8 *s,i64 fmt);
r64 msysc$valreal(u8 *s);
static void msysc$iconvlcn(u8 *s,i64 n);
static void msysc$iconvucn(u8 *s,i64 n);
static void msysc$convlcstring(u8 *s);
static void msysc$convucstring(u8 *s);
i64 msysc$m_power_i64(i64 n,i64 a);
void msysc$m_intoverflow(void);
void msysc$m_dotindex(u64 i,u64 a);
void msysc$m_dotslice(u64 j,u64 i,u64 a);
void msysc$m_popdotindex(u64 i,u64 *p,u64 x);
void msysc$m_popdotslice(u64 j,u64 i,u64 *p,u64 x);
i64 msysc$m_imin(i64 a,i64 b);
i64 msysc$m_imax(i64 a,i64 b);
r64 msysc$m_sign(r64 x);
r64 msysc$m_tp_i64tor64(i64 a);
i64 msysc$m_tp_r64toi64(r64 x);
i64 msysc$m_tp_reftoi64(void *p);
void *msysc$m_tp_i64toref(i64 a);
void msysc$start(void);
void *mlib$pcm_alloc(i64 n);
void mlib$pcm_free(void *p,i64 n);
void mlib$pcm_freeac(void *p,i64 alloc);
void mlib$pcm_clearmem(void *p,i64 n);
void mlib$pcm_init(void);
i64 mlib$pcm_getac(i64 size);
void *mlib$pcm_newblock(i64 itemsize);
i64 mlib$pcm_round(i64 n);
void *mlib$pcm_allocz(i64 n);
u8 *mlib$pcm_copyheapstring(u8 *s);
u8 *mlib$pcm_copyheapstringn(u8 *s,i64 n);
u8 *mlib$pcm_copyheapblock(u8 *s,i64 length);
static void mlib$addtomemalloc(i32 *ptr,i64 size);
static void mlib$removefrommemalloc(i32 *ptr,i64 size);
void *mlib$allocmem(i64 n);
void *mlib$reallocmem(void *p,i64 n);
void mlib$abortprogram(u8 *s);
i64 mlib$getfilesize(void *handlex);
void mlib$readrandom(void *handlex,byte *mem,i64 offset,i64 size);
i64 mlib$writerandom(void *handlex,byte *mem,i64 offset,i64 size);
i64 mlib$setfilepos(void *file,i64 offset);
i64 mlib$getfilepos(void *file);
byte *mlib$readfile(u8 *filename);
i64 mlib$writefile(u8 *filename,byte *data,i64 size);
i64 mlib$checkfile(u8 *file);
void mlib$readlinen(void *handlex,u8 *buffer,i64 size);
void mlib$iconvlcn(u8 *s,i64 n);
void mlib$iconvucn(u8 *s,i64 n);
u8 *mlib$convlcstring(u8 *s);
u8 *mlib$convucstring(u8 *s);
u8 *mlib$changeext(u8 *s,u8 *newext);
u8 *mlib$extractext(u8 *s,i64 period);
u8 *mlib$extractpath(u8 *s);
u8 *mlib$extractfile(u8 *s);
u8 *mlib$extractbasefile(u8 *s);
u8 *mlib$addext(u8 *s,u8 *newext);
void *mlib$pcm_alloc32(void);
void mlib$pcm_free32(void *p);
void *mlib$pcm_alloc64(void);
void mlib$pcm_free64(void *p);
void *mlib$pcm_alloc16(void);
void mlib$pcm_free16(void *p);
void mlib$outbyte(void *f,i64 x);
void mlib$outword16(void *f,u64 x);
void mlib$outword32(void *f,u64 x);
void mlib$outword64(void *f,u64 x);
void mlib$outstring(void *f,u8 *s);
void mlib$outblock(void *f,void *p,i64 n);
i64 mlib$myeof(void *f);
void mlib$strbuffer_add(struct mlib$strbuffer *dest,u8 *s,i64 n);
void mlib$gs_init(struct mlib$strbuffer *dest);
void mlib$gs_free(struct mlib$strbuffer *dest);
void mlib$gs_str(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_char(struct mlib$strbuffer *dest,i64 c);
void mlib$gs_strn(struct mlib$strbuffer *dest,u8 *s,i64 length);
void mlib$gs_strvar(struct mlib$strbuffer *dest,struct mlib$strbuffer *s);
void mlib$gs_strint(struct mlib$strbuffer *dest,i64 a);
void mlib$gs_strln(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_strsp(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_line(struct mlib$strbuffer *dest);
i64 mlib$gs_getcol(struct mlib$strbuffer *dest);
void mlib$gs_leftstr(struct mlib$strbuffer *dest,u8 *s,i64 w,i64 padch);
void mlib$gs_leftint(struct mlib$strbuffer *dest,i64 a,i64 w,i64 padch);
void mlib$gs_padto(struct mlib$strbuffer *dest,i64 col,i64 ch);
void mlib$gs_println(struct mlib$strbuffer *dest,void *f);
i64 mlib$nextcmdparamnew(i64 *paramno,u8 **name,u8 **value,u8 *defext);
static i64 mlib$readnextfileitem(u8 **fileptr,u8 **item);
void mlib$ipadstr(u8 *s,i64 width,u8 *padchar);
u8 *mlib$padstr(u8 *s,i64 width,u8 *padchar);
u8 *mlib$chr(i64 c);
i64 mlib$cmpstring(u8 *s,u8 *t);
i64 mlib$cmpstringn(u8 *s,u8 *t,i64 n);
i64 mlib$eqstring(u8 *s,u8 *t);
i64 mlib$cmpbytes(void *p,void *q,i64 n);
i64 mlib$eqbytes(void *p,void *q,i64 n);
void mlib$mseed(u64 a,u64 b);
u64 mlib$mrandom(void);
i64 mlib$mrandomp(void);
i64 mlib$mrandomint(i64 n);
i64 mlib$mrandomrange(i64 a,i64 b);
r64 mlib$mrandomreal(void);
r64 mlib$mrandomreal1(void);
byte *mlib$checkpackfile(void);
u8 *mlib$readline(void);
void *mlib$findfunction(u8 *name);
i64 mlib$roundtoblock(i64 n,i64 align);
void mlib$start(void);
extern void *malloc(u64 $1);
extern void *realloc(void *$1,u64 $2);
extern void free(void *$1);
extern void memset(void *$1,i32 $2,u64 $3);
extern void memcpy(void *$1,void *$2,u64 $3);
extern void memmove(void *$1,void *$2,u64 $3);
extern i32 clock(void);
extern i32 ftell(void *$1);
extern i32 fseek(void *$1,i32 $2,i32 $3);
extern u64 fread(void *$1,u64 $2,u64 $3,void *$4);
extern u64 fwrite(void *$1,u64 $2,u64 $3,void *$4);
extern i32 getc(void *$1);
extern i32 ungetc(i32 $1,void *$2);
extern void *fopen(u8 *a,u8 *b);
extern i32 fclose(void *$1);
extern u8 *fgets(u8 *$1,i64 $2,void *$3);
extern i32 remove(u8 *$1);
extern i32 rename(u8 *$1,u8 *$2);
extern i32 getchar(void);
extern void putchar(i32 $1);
extern void setbuf(void *$1,byte *$2);
extern i64 strlen(u8 *$1);
extern u8 *strcpy(u8 *$1,u8 *$2);
extern i32 strcmp(u8 *$1,u8 *$2);
extern i32 strncmp(u8 *$1,u8 *$2,u64 $3);
extern u64 strncpy(u8 *$1,u8 *$2,u64 $3);
extern i32 memcmp(void *$1,void *$2,u64 $3);
extern u8 *strcat(u8 *$1,u8 *$2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u8 *strstr(u8 *$1,u8 *$2);
extern i64 atol(u8 *$1);
extern i32 atoi(u8 *$1);
extern r64 strtod(u8 *$1,u8 **$2);
extern u8 *_strdup(u8 *$1);
extern i32 puts(u8 *$1);
extern i32 printf(u8 *$1,...);
extern i32 sprintf(u8 *$1,u8 *$2,...);
extern i32 sscanf(u8 *$1,u8 *$2,...);
extern i32 scanf(u8 *$1,...);
extern i32 rand(void);
extern void srand(u32 $1);
extern i32 system(u8 *$1);
extern i32 fgetc(void *$1);
extern i32 fputc(i32 $1,void *$2);
extern i32 fprintf(void *$1,u8 *$2,...);
extern i32 fputs(u8 *$1,void *$2);
extern i32 feof(void *$1);
extern i32 getch(void);
extern i32 _getch(void);
extern i32 kbhit(void);
extern i32 _mkdir(u8 *$1);
extern i32 mkdir(u8 *$1);
extern u8 *strchr(u8 *$1,i32 $2);
extern i32 _setmode(i32 $1,i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1,r64 $2);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern i64 llabs(i64 $1);
extern void qsort(void *$1,u64 $2,u64 $3,void (*$4)(void));
extern void sleep(u32 $1);
extern i32 __getmainargs(i32 *$1,void *$2,void *$3,i64 $4,void *$5);
void mclib$start(void);
extern void *dlopen(u8 *$1,i32 $2);
extern void *dlsym(void *$1,u8 *$2);
extern i32 tcgetattr(i32 $1,struct mlinux$termios *$2);
extern i32 tcsetattr(i32 $1,i32 $2,struct mlinux$termios *$3);
void mlinux$os_init(void);
i64 mlinux$os_execwait(u8 *cmdline,i64 newconsole,u8 *workdir);
i64 mlinux$os_execcmd(u8 *cmdline,i64 newconsole);
i64 mlinux$os_getch(void);
i64 mlinux$os_kbhit(void);
void mlinux$os_flushkeys(void);
void *mlinux$os_getconsolein(void);
void *mlinux$os_getconsoleout(void);
void *mlinux$os_proginstance(void);
u64 mlinux$os_getdllinst(u8 *name);
void *mlinux$os_getdllprocaddr(i64 hlib,u8 *name);
void mlinux$os_initwindows(void);
i64 mlinux$os_getchx(void);
u8 *mlinux$os_getos(void);
i64 mlinux$os_gethostsize(void);
i64 mlinux$os_iswindows(void);
i64 mlinux$os_shellexec(u8 *opc,u8 *file);
void mlinux$os_sleep(i64 a);
void *mlinux$os_getstdin(void);
void *mlinux$os_getstdout(void);
u8 *mlinux$os_gethostname(void);
u8 *mlinux$os_getmpath(void);
void mlinux$os_exitprocess(i64 x);
i64 mlinux$os_clock(void);
i64 mlinux$os_ticks(void);
i64 mlinux$os_getclockspersec(void);
void mlinux$os_setmesshandler(void *addr);
i64 mlinux$os_hpcounter(void);
i64 mlinux$os_hpfrequency(void);
i64 mlinux$os_filelastwritetime(u8 *filename);
void mlinux$os_getsystime(struct mlinux$rsystemtime *tm);
void mlinux$os_peek(void);
byte *mlinux$os_allocexecmem(i64 n);
void mlinux$start(void);
u64 mwindllc$os_calldllfunction(void (*fnaddr)(void),i64 retcode,i64 nargs,i64 (*args)[],byte (*argcodes)[]);
u64 mwindllc$os_pushargs(u64 (*args)[],i64 nargs,i64 nextra,void (*fnaddr)(void),i64 isfloat);
static i64 mwindllc$calldll_cint(void (*fnaddr)(void),i64 (*params)[],i64 nparams);
static i64 mwindllc$calldll_creal(void (*fnaddr)(void),i64 (*params)[],i64 nparams);
void mwindllc$os_dummycall(r64 a,r64 b,r64 c,r64 d);
void mwindllc$start(void);

/* VARS */
static u8 *  mm_cli$optionnames[58] = {
    (byte*)"header",
    (byte*)"load",
    (byte*)"fixup",
    (byte*)"parse",
    (byte*)"name",
    (byte*)"type",
    (byte*)"asm",
    (byte*)"c",
    (byte*)"mcl",
    (byte*)"obj",
    (byte*)"mx",
    (byte*)"ml",
    (byte*)"exe",
    (byte*)"mexe",
    (byte*)"run",
    (byte*)"sys",
    (byte*)"minsys",
    (byte*)"nosys",
    (byte*)"minos",
    (byte*)"nofile",
    (byte*)"debug",
    (byte*)"gcc",
    (byte*)"tcc",
    (byte*)"tc",
    (byte*)"bcc",
    (byte*)"ma",
    (byte*)"mas",
    (byte*)"docs",
    (byte*)"exp",
    (byte*)"lib",
    (byte*)"opt",
    (byte*)"opt1",
    (byte*)"opt2",
    (byte*)"ast1",
    (byte*)"ast2",
    (byte*)"ast3",
    (byte*)"showmx",
    (byte*)"showasm",
    (byte*)"st",
    (byte*)"pst",
    (byte*)"stflat",
    (byte*)"types",
    (byte*)"overloads",
    (byte*)"ss",
    (byte*)"modules",
    (byte*)"shortnames",
    (byte*)"time",
    (byte*)"v",
    (byte*)"vv",
    (byte*)"q",
    (byte*)"h",
    (byte*)"help",
    (byte*)"ext",
    (byte*)"out",
    (byte*)"outpath",
    (byte*)"unused",
    (byte*)"set",
    (byte*)"linux"
};
static byte mm_cli$fasmexe;
static i64 mm_cli$abc;
static i64 mm_cli$def;
static u8 *  mm_cli$outext = (byte*)"";
static i64 mm_cli$startclock;
static i64 mm_cli$endclock;
static i64 mm_cli$rpclock;
static byte mm_cli$msfile;
static u8 *  mm_cli$inputfile;
static struct mm_decls$unitrec *  mc_blockmcl$casestmt[20];
static i64 mc_blockmcl$caseelse[20];
static i64 mc_blockmcl$casedepth;
static i64 (*mc_blockmcl$sw_labeltable)[];
static i64 (*mc_blockmcl$sw_valuetable)[];
static i64 mc_blockmcl$sw_lower;
static i64 mc_blockmcl$sw_ncases;
static byte mc_blockmcl$sw_defaultseen;
static i64 mc_blockmcl$sw_defaultlabel;
static i64 mc_blockmcl$sw_breaklabel;
static i64 mc_blockmcl$maxreg = (i64)0;
static struct mc_decls$opndrec *  mc_blockmcl$axb;
static struct mc_decls$opndrec *  mc_blockmcl$bxb;
static i64 mm_winx64$cmdskip;
static byte mm_winx64$fshortnames;
static struct mm_decls$strec *  mm_decls$stprogram;
static struct mm_decls$strec *  mm_decls$stmodule;
static struct mm_decls$strec *  mm_decls$stsubprog;
static struct mm_decls$strec *  mm_decls$stsysmodule;
static struct mm_decls$strec *  mm_decls$alldeflist;
static i64 mm_decls$currmoduleno;
static struct mm_decls$tokenrec mm_decls$lx;
static struct mm_decls$tokenrec mm_decls$nextlx;
static struct mm_decls$modulerec mm_decls$moduletable[201];
static byte mm_decls$moduletosub[201];
static struct mm_decls$subprogrec mm_decls$subprogtable[31];
static u8 *  mm_decls$libfiles[51];
static byte mm_decls$libtypes[51];
static u8 *  mm_decls$sourcefilespecs[1001];
static u8 *  mm_decls$sourcefilepaths[1001];
static u8 *  mm_decls$sourcefilenames[1001];
static byte mm_decls$sourcefilesys[1001];
static byte mm_decls$sourcefilesupport[1001];
static u8 *  mm_decls$sourcefiletext[1001];
static u8 *  mm_decls$sourcefiledupl[1001];
static i64 mm_decls$sourcefilesizes[1001];
static i64 mm_decls$nmodules;
static i64 mm_decls$nsubprogs;
static i64 mm_decls$nsourcefiles;
static i64 mm_decls$nlibfiles;
static i64 mm_decls$mainmoduleno;
static i64 mm_decls$ntypes;
static struct mm_decls$strec *  mm_decls$ttnamedef[6001];
static struct mm_decls$strec *  mm_decls$ttowner[6001];
static i32 mm_decls$ttbasetype[6001];
static u8 *  mm_decls$ttname[6001];
static u32 mm_decls$ttsize[6001];
static byte mm_decls$ttsizeset[6001];
static i32 mm_decls$ttlower[6001];
static i32 mm_decls$ttlength[6001];
static i32 (*mm_decls$ttmult[6001])[];
static struct mm_decls$unitrec *  mm_decls$ttdimexpr[6001];
static i32 mm_decls$tttarget[6001];
static byte mm_decls$ttusercat[6001];
static i32 mm_decls$ttlineno[6001];
static byte mm_decls$ttsigned[6001];
static byte mm_decls$ttisreal[6001];
static byte mm_decls$ttisinteger[6001];
static byte mm_decls$ttisshort[6001];
static byte mm_decls$ttisref[6001];
static byte mm_decls$ttcat[6001];
static byte mm_decls$ttisblock[6001];
static struct mm_decls$typenamerec mm_decls$typenames[8001];
static struct mm_decls$posrec mm_decls$typenamepos[8001];
static i64 mm_decls$ntypenames;
static byte mm_decls$typestarterset[173];
static struct mm_decls$strec *  mm_decls$currproc;
static struct mm_decls$strec *  mm_decls$currsubprog;
static i64 mm_decls$debug = (i64)0;
static i64 mm_decls$assemmode = (i64)0;
static i64 mm_decls$headermode = (i64)0;
static struct mm_decls$procrec *  mm_decls$proclist;
static struct mm_decls$procrec *  mm_decls$proclistx;
static struct mm_decls$procrec *  mm_decls$staticlist;
static struct mm_decls$procrec *  mm_decls$staticlistx;
static struct mm_decls$procrec *  mm_decls$constlist;
static struct mm_decls$procrec *  mm_decls$constlistx;
static struct mm_decls$unitrec *  mm_decls$nullunit;
static struct mm_decls$unitrec *  mm_decls$voidvarunit;
static i64 mm_decls$targetbits = (i64)64;
static i64 mm_decls$targetsize = (i64)8;
static u8 *  mm_decls$docstrings[20];
static i64 mm_decls$ndocstrings;
static i64 mm_decls$ndllproctable;
static struct mm_decls$strec *  mm_decls$dllproctable[1000];
static i64 mm_decls$fverbose = (i64)1;
static byte mm_decls$msyslevel = (byte)(i64)2;
static byte mm_decls$mvarlib = (byte)(i64)0;
static byte mm_decls$fvarnames = (byte)(i64)0;
static byte mm_decls$minos = (byte)(i64)0;
static byte mm_decls$freadma;
static byte mm_decls$fwritema;
static byte mm_decls$fwriteexports;
static byte mm_decls$fwritedocs;
static byte mm_decls$fexe;
static byte mm_decls$fobj;
static byte mm_decls$fwritelibs;
static byte mm_decls$fshowtiming;
static byte mm_decls$fshowss;
static byte mm_decls$fshowmx;
static byte mm_decls$fshowpcl;
static byte mm_decls$fshowasm;
static byte mm_decls$fshowast1;
static byte mm_decls$fshowast2;
static byte mm_decls$fshowast3;
static byte mm_decls$fshowst;
static byte mm_decls$fshowstflat;
static byte mm_decls$fshowtypes;
static byte mm_decls$fshowoverloads;
static byte mm_decls$fshowmodules;
static byte mm_decls$foptim;
static byte mm_decls$fcheckunusedlocals = (byte)(i64)0;
static byte mm_decls$fwindows = (byte)(i64)1;
static byte mm_decls$flinux;
static byte mm_decls$fnofile;
static byte mm_decls$dointlibs = (byte)(i64)1;
static u8 *  mm_decls$passnames[14] = {
    (byte*)"header_pass",
    (byte*)"load_pass",
    (byte*)"parse_pass",
    (byte*)"fixup_pass",
    (byte*)"name_pass",
    (byte*)"type_pass",
    (byte*)"pcl_pass",
    (byte*)"mcl_pass",
    (byte*)"asm_pass",
    (byte*)"objpass",
    (byte*)"exe_pass",
    (byte*)"lib_pass",
    (byte*)"run_pass",
    (byte*)"clang_pass"
};
static u8 *  mm_decls$ccnames[4] = {(byte*)"gcc_cc",(byte*)"tcc_cc",(byte*)"tc_cc",(byte*)"bcc_cc"};
static i64 mm_decls$passlevel = (i64)0;
static i64 mm_decls$prodmode = (i64)0;
static i64 mm_decls$debugmode = (i64)0;
static i64 mm_decls$libmode = (i64)0;
static i64 mm_decls$mxstub = (i64)0;
static i64 mm_decls$ccompiler = (i64)1;
static u8 *  mm_decls$outfile;
static u8 *  mm_decls$destfilename;
static u8 *  mm_decls$destfilepath;
static u8 *  mm_decls$asmfilename;
static u8 *  mm_decls$pclfilename;
static u8 *  mm_decls$exefilename;
static u8 *  mm_decls$libfilename;
static u8 *  mm_decls$objfilename;
static u8 *  mm_decls$mafilename;
static u8 *  mm_decls$expfilename;
static struct mm_decls$strec *  mm_decls$extendtypelist;
static struct mm_decls$overloadrec *  mm_decls$overloadtable[132];
static i64 mm_decls$nunits;
static i64 mm_decls$nstrecs;
static i64 mm_decls$nreadassign;
static i64 mm_decls$nsimple;
static i64 mm_diags$currlineno;
static i64 mm_diags$currfileno;
static struct mlib$strbuffer mm_export$sbuffer;
static struct mlib$strbuffer *  mm_export$dest = (struct mlib$strbuffer *)&mm_export$sbuffer;
static u8 *  mm_lex$lxstart_stack[20];
static u8 *  mm_lex$lxsource_stack[20];
static u8 *  mm_lex$lxsptr_stack[20];
static i64 mm_lex$lxfileno_stack[20];
static struct mm_decls$tokenrec mm_lex$lxnextlx_stack[20];
static byte mm_lex$lximport_stack[20];
static i64 mm_lex$sourcelevel = (i64)0;
static i64 mm_lex$lximport;
static u8 *  mm_lex$lxsource;
static u8 *  mm_lex$lxstart;
static u8 *  mm_lex$lxsptr;
static i64 mm_lex$lxifcond;
static i64 mm_lex$longsuffix;
static i64 mm_lex$lxalllines;
static i64 mm_lex$lxfileno;
static struct mm_decls$strec *  mm_lex$hashtable[65536];
static i64 mm_lex$astringlength;
static u8 *  mm_lex$u64maxstr = (byte*)"18446744073709551615";
static byte mm_lex$alphamap[256];
static struct mm_decls$strec *  mm_lex$shortnames[26];
static i64 mm_lib$autotypeno = (i64)0;
static i64 mm_lib$nextavindex = (i64)0;
static i64 mm_lib$nextsvindex = (i64)0;
static struct mlib$strbuffer mm_lib$exprstrvar;
static struct mlib$strbuffer *  mm_lib$exprstr = (struct mlib$strbuffer *)&mm_lib$exprstrvar;
static struct mm_decls$unitrec *  mm_lib$unitheapptr = 0;
static i64 mm_lib$remainingunits = (i64)0;
static struct mlib$strbuffer mm_lib$sbuffer;
static struct mlib$strbuffer *  mm_lib$dest = (struct mlib$strbuffer *)&mm_lib$sbuffer;
static u8 *  mm_lib$framevarname;
static u8 *  mm_libsources$syslibnames[5] = {(byte*)"msys.m",(byte*)"mlib.m",(byte*)"mclib.m",(byte*)"mwindows.m",(byte*)"mwindll.m"};
static u8 *  mm_libsources$libtext[5] = {
(byte*)"global record procinforec=\n\tword16\t\tfnindex\n\tbyte\t\trettype\n\tbyte\t\tnparams\n\t[12]byte\tparamlist\nend\n\n!for print/read routines\n!------------------------------------------\nrecord fmtrec=\t! (default)\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\n\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\n\tchar\tpadchar\t\t! Pc, Z (' ')\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\n\n\tchar\tplus\t\t! (0)   0 or '+'\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\n\tchar\tcharmode\t! C,D (0)  0 or 'C' or 'D'\to/p int as int or single char or double/multi-char\n\tchar\theapmode\t! M (0)  'M' for str-functions, return ptr tp heap string\n\tchar\tparam\t\t! Use int value for <fmtparam>\n\tbyte\tspare\nend\n\nint fmtparam\t\t\t!as set with :'V'\n\nenumdata =\n\tstd_io,file_io,str_io\nend\n\nconst comma = ','\n\nexport int $cmdskip\t\t\t!0 unless set by READMCX/etc\n\nexport int needgap\t\t\t= 0\nint outdev\t\t\t= std_io\nfilehandle outchan\t= nil\nref char fmtstr \t= nil\n\nconst maxiostack=10\narray [maxiostack]filehandle\toutchan_stack\narray [maxiostack]int\t\t\toutdev_stack\narray [maxiostack]ref char\tfmtstr_stack\narray [maxiostack]byte\t\tneedgap_stack\n\narray [maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\nint niostack=0\n\narray [0:]char digits=A\"0123456789ABCDEF\"\nconst onesixty=360\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\n\n!Read buffer vars\nconst rd_buffersize = 16384\t!total capacity of line buffer\n!const rd_buffersize = 524288\t!total capacity of line buffer\n\n!global ref char rd_buffer\t\t! point to start of read buffer\nexport ref char rd_buffer\t\t! point to start of read buffer\nexport int rd_length\t\t\t! length of this line (as read by readln)\nref char rd_pos\t\t\t! current position it's up to (next read starts here)\nref char rd_lastpos\t\t! set by sread() just before reading used for reread()\nint termchar\t\t\t! terminator char set by readxxx()\nint itemerror\t\t\t!\tset by some read functions, eg for reals\n\narray [4096]char printbuffer\nichar printptr\nint printlen\n\n!------------------------------------------\n\nconst maxparam=128\nexport int nsysparams\nexport int ncmdparams\nexport int nenvstrings\nexport [maxparam]ichar sysparams\n!export ref[]ichar cmdparams\nexport ref[0:]ichar cmdparams\nexport ref[]ichar envstrings\n!export [maxparam]ichar envstrings\n\nconst maxcallback=8\narray [0..maxcallback,8]word64 callbackstack\nint ncallbacks=0\n\nword64 mask63\t= 0x7FFF'FFFF'FFFF'FFFF\nreal offset64\t= 9223372036854775808.0\t\t! 2**63 as r64\nreal offset32\t= 9223372036854775808.0\t\t! 2**63 as r32\n\n!global proc m$init=\nproc start=\n\tint32 nargs\n\tint nargs64\n\tref[]ichar args\n\tstatic [128]byte startupinfo\t\t\t! 68 or 104 bytes\n\tint res\n!\tichar s\n\t\n\n\tres:=__getmainargs(&nargs,cast(&args),cast(&envstrings),0,cast(&startupinfo))\n\t\n\tnsysparams:=nargs\n\t\n\tif nsysparams>maxparam then\n\t\tprintf(\"Too many params\\n\")\n\t\tstop 50\n\tfi\n\n\tnargs64:=nargs\t\t\t!bug when using 32-bit limit when compiled with mm\n\tfor i:=1 to nargs64 do\n\t\tsysparams[i]:=args[i]\n\tod\n\t\n!assume nsysparams is >=1, since first is always the program name\n\tncmdparams:=nsysparams-($cmdskip+1)\n\tcmdparams:=cast(&sysparams[$cmdskip+1])\n\n\tint j:=1\n\tnenvstrings:=0\n\twhile envstrings[j] do\n\t\t++nenvstrings\n\t\t++j\n\tod\n\n!\t_setmode(0,32768);\n!\t_setmode(1,32768);\n!\t_setmode(2,32768);\n\nend\n\nproc pushio=\n\tif niostack>=maxiostack then\n\t\tprintf(\"Too many io levels\\n\")\n\t\tstop 53\n\tfi\n\t++niostack\n\toutchan_stack[niostack]\t:= outchan\n\toutdev_stack[niostack]\t:= outdev\n\tfmtstr_stack[niostack]\t:= fmtstr\n\tneedgap_stack[niostack]\t:= needgap\n\tneedgap:=0\n\tfmtstr:=nil\n\toutchan:=nil\nend\n\nexport proc m$print_startfile(ref void dev)=\n\tpushio()\n\toutchan:=cast(dev)\n\tif dev then\n\t\toutdev:=file_io\n\telse\n\t\toutdev:=std_io\n\tfi\n\tresetprintbuffer()\nend\n\nexport proc m$print_startstr(ref char s)=\n\tref ref char p\n\tpushio()\n\n\tptr_stack[niostack]:=s\n\tp:=&ptr_stack[niostack]\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startptr(ref ref char p)=\n\tpushio()\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startcon=\n!PRINTF(\"STARTCON %d\\n\",NIOSTACK);\n\tpushio()\n\toutdev:=std_io\n\tresetprintbuffer()\nend\n\nexport proc m$print_setfmt(ref char format)=\n\tfmtstr:=format\nend\n\nexport proc m$print_end=\n\tneedgap:=0\n\tnextfmtchars(1)\n\tif niostack=1 and outdev in [std_io,file_io] then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif niostack=0 then return fi\n\toutchan\t:= outchan_stack[niostack]\n\toutdev\t:= outdev_stack[niostack]\n\tfmtstr\t:= fmtstr_stack[niostack]\n\tneedgap\t:= needgap_stack[niostack]\n\n\n\t--niostack\n!PRINTF(\"ENDCON %d\\n\",NIOSTACK);\nend\n\nexport proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n\tarray [20]char s\n\n\tif fmtstyle=nil then\n\t\tfmtstyle:=\"z8H\"\n\tfi\n\tm$print_u64(a,fmtstyle)\nend\n\nexport proc m$print_ptr_nf(u64 a)=\n\tm$print_ptr(a)\nend\n\nexport proc m$print_i64(int64 a,ichar fmtstyle=nil)=\n\tarray [40]char s\n\tfmtrec fmt\n\tint n\n!PRINTF(\"M$PRTI64 NG=%lld\\n\",NEEDGAP)\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tif a>=0 then\n\t\t\tn:=u64tostr(a,&.s,10,0)\n\t\telse\n\t\t\ts[1]:='-'\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\n\t\tfi\n\n\t\tprintstr_n(&.s,n)\n\n\telse\n\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\tif fmt.param='V' then\n\t\t\tfmtparam:=a\n\t\t\tneedgap:=0\n\t\telse\n\t\t\ttostr_i64(a,&fmt)\n\t\tfi\n\tfi\n\tneedgap:=1\nend\n!PRINTF(\"....M$PRTI64 NG=%lld\\n\",NEEDGAP)\n\nexport proc m$print_i64_nf(int64 a)=\n\tm$print_i64(a)\nend\n\nexport proc m$print_bool(int64 a, ichar fmtstyle=nil)=\n\tif a then\n\t\tm$print_str(\"True\",fmtstyle)\n\telse\n\t\tm$print_str(\"False\",fmtstyle)\n\tfi\nend\n\nexport proc m$print_u64(word64 a,ichar fmtstyle=nil)=\n\tarray [40]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%llu\",a)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_u64(a,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_r64(real x,ichar fmtstyle=nil)=\n\tarray [360]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%f\",x)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_r64(x,&fmt)\n\tfi\n\n\tneedgap:=1\nend\n\nexport proc m$print_r32(real32 x,ichar fmtstyle=nil)=\n\tm$print_r64(x,fmtstyle)\nend\n\nglobal proc m$print_c8(int64 a,ichar fmtstyle=nil)=\n\tarray [40]char s\n\tfmtrec fmt\n\tint n\n\n\tnextfmtchars()\n\n\ts[1]:=a\n\ts[2]:=0\n\tprintstr(&.s)\n\tneedgap:=1\nend\n\nexport proc m$print_str(ichar s, fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr(s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,-1,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr_n(s,length)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,length,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_str_nf(ichar s)=\n\tm$print_str(s)\nend\n\nexport proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tfmtrec fmt\n!\tif fmtstyle=nil then\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\n!\telse\n\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\n!\t\tstrtofmt(fmtstyle,-1,&fmt)\n!\t\ttostr_str(s,s.len,&fmt)\n!\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_newline=\n\tneedgap:=0\n\tnextfmtchars(1)\n!RETURN\n\tprintstr(\"\\w\")\n!\tprintstr(\"\\n\")\nend\n\nexport proc m$print_nogap=\n\tneedgap:=0\nend\n\nexport proc m$print_space=\n\tneedgap:=0\n!RETURN\n\tprintstr(\" \")\nend\n\nexport proc printstr(ichar s)=\n\tprintstr_n(s,strlen(s))\nend\n\nexport proc printstr_n(ichar s,int n)=\n\tref ref char p\n\n\treturn when n=0\n\n\tif niostack=1 and outdev in [std_io,file_io] then\n\t\taddtobuffer(s,n)\n\telse\n\t\tdumpstr(s,n)\n\tfi\nend\n\nexport proc printstrn_app(ichar s, int length, filehandle f=nil)=\nif length then\n\tif f=nil then\n\t\tprintf(\"%.*s\",length,s)\n\telse\n\t\tfprintf(f,\"%.*s\",length,s)\n\tfi\nfi\nend\n\nproc printchar(int ch)=\n\tref ref char p\n\tarray [4]char str\n!RETURN\n\n\tstr[1]:=ch\n\tstr[0]:=ch\n\tprintstr_n(str,1)\nend\n\nglobal proc nextfmtchars(int lastx=0)=\n\tchar c\n\tref char pstart\n\tint n\n\tif not fmtstr then\t\t\t!format not in use\n\t\tif needgap then\n\t\t\tprintchar(' ')\n\t\tfi\n\t\tneedgap:=0\n\t\treturn\n\tfi\n\n\tpstart:=fmtstr\n\tn:=0\n\n\tdo\n\t\tc:=fmtstr^\n\t\tswitch c\n\t\twhen '#' then\n\t\t\tif lastx then\n\t\t\t\tgoto skip\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\tfi\n\t\t\treturn\n\t\twhen 0 then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\telsif not lastx then\n\t\t\t\tprintstr_n(\"|\",1)\n\t\t\tfi\n\t\t\treturn\n\t\twhen '~' then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\t\tn:=0\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tc:=fmtstr^\n\t\t\tif c then\n\t\t\t\t++fmtstr\n\t\t\t\tprintchar(c)\n\t\t\tfi\n\t\t\tpstart:=fmtstr\n\t\telse\n\tskip::\n\t\t\t++n\n\t\t\t++fmtstr\n\t\tendswitch\n\tod\nend\n\nproc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\n!convert format code string in s, to fmtrec at fmt^\n!Format code is a string containing the following char codes (upper or lower when mostly)\n!n\tWidth\n!.n\tMax width/precision\n!A\tConvert to upper when\n!a\tConvert to lower when\n!B\tBinary\n!C\tShow int as single n-bit (unicode) character\n!D\tShow int as multi-bit (unicode) character\n!E,F,G\tSpecify format for double (corresponds to C format codes)\n!F\n!G\n!H\tHex\n!JC\tJustify centre\n!JL\tJustify left\n!JR\tJustify right\n!M\tHEAPMODE???\n!O\tOctal\n!Pc\tUse padding char c\n!Q\tAdd double quotes around string (and deal with embedded quotes)\n!'\tAdd single quotes around string (and deal with embedded quotes)\n!Sc\tUse separator char c between every 3 or 4 digits\n!Tc\tUse terminator char c (typically B or H)\n!U\tShow ints as unsigned\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\n!W\tUnsigned\n!Xn\tUse base n (n is hex 0 to F)\n!Z\tUse \"0\" padding\n!+\tAlways have + or - in front of integers\n!~\tQuote char is ~\n!*\tSame as n but uses parameter set with :'V' on previous int\n\n\tint c, base\n\tbyte wset\n\tint n\n\tarray [0:100]char str\n\n\tfmt^:=defaultfmt\n\n\tif s=nil then return fi\n\n\tif slen=-1 then slen:=strlen(s) fi\n\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\n\tstr[slen]:=0\n\ts:=&.str\n\n\twset:=0\n\twhile s^ do\n\t\tc:=s^\n\t\t++s\n\t\tswitch c\n\t\twhen 'B', 'b' then fmt.base:=2\n\t\twhen 'H', 'h' then fmt.base:=16\n\t\twhen 'O', 'o' then fmt.base:=8\n\t\twhen 'X', 'x' then\n\t\t\tbase:=0\n\t\t\tdo\n\t\t\t\tc:=s^\n\t\t\t\tif c in '0'..'9' then\n\t\t\t\t\tbase:=base*10+c-'0'\n\t\t\t\t\t++s\n\t\t\t\telse\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\tod\n\t\t\tif base in 2..16 then\n\t\t\t\tfmt.base:=base\n\t\t\tfi\n\n\t\twhen 'Q', 'q' then fmt.quotechar:='\"'\n\t\twhen '~' then fmt.quotechar:='~'\n\t\twhen 'J', 'j' then\n\t\t\tfmt.justify:=toupper(s^)\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'A' then fmt.lettercase:='A'\n\t\twhen 'a' then fmt.lettercase:='a'\n\t\twhen 'Z', 'z' then fmt.padchar:='0'\n\t\twhen 'S', 's' then\n\t\t\tfmt.sepchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'P', 'p' then\n\t\t\tfmt.padchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'T', 't' then\n\t\t\tfmt.suffix:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'W', 'w' then fmt.usigned:='W'\n\t\twhen 'E', 'e' then fmt.realfmt:='e'\n\t\twhen 'F', 'f' then fmt.realfmt:='f'\n\t\twhen 'G', 'g' then fmt.realfmt:='g'\n! when '0','1','2','3','4','5','6','7','8','9' then\n\t\twhen '.' then\n\t\t\twset:=1\n\t\twhen comma,'_' then fmt.sepchar:=c\n\t\twhen '+' then fmt.plus:='+'\n\t\twhen 'D', 'd' then fmt.charmode:='D'\n\t\twhen 'C', 'c' then fmt.charmode:='C'\n\t\twhen 'M', 'm' then fmt.heapmode:='M'\n\t\twhen 'V','v' then fmt.param:='V'\n\t\twhen '*' then\n\t\t\tn:=fmtparam\n\t\t\tgoto gotwidth\n\t\telse\n\t\t\tif c>='0' and c<='9' then\n\t\t\t\tn:=c-'0'\n\t\t\t\tdo\n\t\t\t\t\tc:=s^\n\t\t\t\t\tif s^=0 then\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tif c>='0' and c<='9' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\tn:=n*10+c-'0'\n\t\t\t\t\telse\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\tod\ngotwidth::\n\t\t\t\tif not wset then\n\t\t\t\t\tfmt.minwidth:=n\n\t\t\t\t\twset:=1\n\t\t\t\telse\n\t\t\t\t\tfmt.precision:=n\n\t\t\t\tfi\n\t\t\tfi\n\t\tendswitch\n\tod\nend\n\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\n!there are n (4 or 8) chars at p.!\n!There could be 0 to 4 or 8 printable chars converted to string at dest\n\tarray [0:20]char str\n\tref char q\n\tint i,nchars\n\n\tq:=&.str\n\n\tnchars:=n\n\n\tto n do\n\t\tif p^=0 then exit fi\n\t\tq^:=p^\n\t\t++q\n\t\t++p\n\tod\n\tq^:=0\n\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\nend\n\nfunction expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\n!s contains a partly stringified value.\n!widen s if necessary, according to fmt, and copy result to t\n!n is current length of s\n!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving\n!a leading +/- when right-justifying with '0' padding.\n!t MUST be big enough for the expanded string; caller must take care of this\n!result will be zero-terminated, for use in this module\n\n\tint i,w,m\n\n!check to see if result is acceptable as it is\n\tw:=fmt.minwidth\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\n\t\tstrncpy(t,s,n)\n\t\t(t+n)^:=0\n\t\treturn n\n\tfi\n\n\tif fmt.justify='L' then\t! left-justify\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tfor i:=1 to w-n do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\telsif fmt.justify='R' then\n\t\tif fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside \n\t\t\tt^:=s^\n\t\t\t++t\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s+1,n-1)\n\t\t\t(t+n-1)^:=0\n\t\telse\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s,n)\n\t\t\t(t+n)^:=0\n\t\tfi\n\n\telse\t\t\t\t! centre-justify?\n\n\t\tm:=(w-n+1)/2\n\t\tto m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tto w-n-m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\n\tfi\n\treturn w\nend\n\nfunction u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\n!convert 64-bit int a to string in s^\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\n!result when a=minint (will give \"<minint>\")\n\tarray [0:onesixty]char t\n\tu64 dd\n\tint i,j,k,g\n\tint cc\n\tint dummy\n\tref char s0\n\n\ti:=0\n\tk:=0\n\tg:=(base=10|3|4)\n\n\trepeat\n\t\tif base=10 then\n\t\t\tassem\n\t\t\t\tmov\t\trcx, [aa]\n\t\t\t\tmov\t\trax, rcx\n\t\t\t\tmov\t\trdx, 7378697629483820647\n\t\t\t\timul\trdx\n\t\t\t\tmov\t\trax, rdx\n\t\t\t\tmov\t\trdx, rcx\n\t\t\t\tsar\t\trdx, 63\n\t\t\t\tsar\t\trax, 2\n\t\t\t\tsub\t\trax, rdx\n\t\t\t\tlea\t\trdx, [rax+rax*4]\n\t\t\t\tadd\t\trdx, rdx\n\t\t\t\tsub\t\trcx, rdx\n\t\t\t\tmov\t\t[dd], rcx\n\t\t\t\tmov\t\t[aa], rax\n\t\t\tend\n\t\telse\n\t\t\tdd:=aa rem base\n\t\t\taa:=aa/base\n\t\tfi\n\n\t\tt[++i]:=digits[dd]\n\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\n!out a full length binary\n!so perhaps move this out to expandstr\n\t\t++k\n\t\tif sep and aa<>0 and k=g then\n\t\t\tt[++i]:=sep\n\t\t\tk:=0\n\t\tfi\n\tuntil aa=0\n\n\tj:=i\n\ts0:=s\n\twhile i do\n\t\ts^:=t[i--]\n\t\t++s\n\tod\n\ts^:=0\n\n\treturn j\nend\n\nfunction i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\n!convert a to a string in s, according to fmt\n!a basic conversion is done first,: the field manipulation is done\n!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)\n!returns length of s\n\tarray [0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint i,j,k,n,w,usigned\n\tconst i64 mindint=0x8000'0000'0000'0000\n\n\n\n\tusigned:=0\n\tif fmt.usigned then\n\t\tusigned:=1\n\tfi\n!PUTS(\"I64TOSTR\")\n\tif aa=mindint and not usigned then\t\t! minint\n\n\t\tstr[0]:='-'\n\t\tn:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1\n!CPL =INT(STR[0])\n!CPL =INT(STR[1])\n\n\telse\n\t\tif (not usigned and aa<-0) or fmt.plus then\n\t\t\tif aa<0 then\n\t\t\t\taa:=-aa\n\t\t\t\tstr[0]:='-'\n\t\t\telse\n\t\t\t\tstr[0]:='+'\n\t\t\tfi\n\t\t\tn:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1\n\t\telse\n\t\t\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\t\tfi\n\tfi\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'\tthen\t! need lower when\n\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nfunction u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\n!see i64tostrfmt\n\tarray [0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint i,j,k,n,w\n\n\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif fmt.base>10 or fmt.suffix and fmt.lettercase='a'\tthen\t! need lower when\n!\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nfunction i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\n!convert minint to string in s do not include minus sign\n!return number of chars in string\n\tarray [0:onesixty]char t\n\tint i,j,k,g,neg\n\n\tswitch base\n\twhen 10 then\n\t\tstrcpy(&t[0],\"9223372036854775808\")\n\t\tj:=3\n\twhen 16 then\n\t\tstrcpy(&t[0],\"8000000000000000\")\n\t\tj:=1\n\twhen 2 then\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\n\t\tj:=7\n\telse\n\t\tstrcpy(&t[0],\"<mindint>\")\n\tendswitch\n\n\ti:=strlen(&t[0])\n\ts+:=i\n\tif sep then\n\t\ts+:=j\n\tfi\n\ts^:=0\n\n\tk:=0\n\tg:=(base=10|3|4)\n\n\twhile i do\n\t\t--s\n\t\ts^:=t[i-- -1]\n\t\tif sep and i and ++k=g then\n\t\t\t--s\n\t\t\ts^:=sep\n\t\t\tk:=0\n\t\tfi\n\tod\n\treturn strlen(s)\nend\n\nfunction strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\n!s is a string process according to fmtrec fmt^, and return result in t\n!caller should check whether any changes are required to s (now it can just use s), but this\n!check is done here anyway (with a simple copy to t)\n!n is current length of s\n!return length of t\n!Three processing stages:\n!1 Basic input string s\n!2 Additions or mods: quotes, suffix, when conversion\n!3 Width adjustment\n!1 is detected here, 2 is done here, 3 is done by expandstr\n\tref char u,v\n\tarray [256]char str\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\n\n\tnheap:=0\n\n\tif fmt.quotechar or fmt.lettercase then\t\t! need local copy\n\t\tif n<256 then\n\t\t\tu:=&.str\n\t\telse\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\n\t\t\tu:=pcm_alloc(nheap)\n\t\tfi\n\t\tif fmt.quotechar then\n\t\t\tv:=u\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tif n then\n\t\t\t\tstrcpy(v,s)\n\t\t\t\tv+:=n\n\t\t\tfi\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tv^:=0\n\t\t\tn+:=2\n\t\telse\n\t\t\tmemcpy(u,s,n)\n\t\tfi\n\t\tswitch fmt.lettercase\n\t\twhen 'a' then\t! need lower when\n\t\t\tconvlcstring(u)\n\t\twhen 'A' then\n\t\t\tconvucstring(u)\n\t\tendswitch\n\t\ts:=u\n\tfi\n\n\tw:=fmt.minwidth\n\tif w>n then\n\t\tn:=expandstr(s,t,n,fmt)\n\telse\n\t\tmemcpy(t,s,n)\n\tfi\n\tif nheap then\n\t\tpcm_free(u,nheap)\n\tfi\n\treturn n\nend\n\nproc tostr_i64(int64 a, ref fmtrec fmt)=\n\tarray [360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 0 then\n\t\tn:=i64tostrfmt(a,&.str,fmt)\n\twhen 'D','d' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\telse\t\t\t\t\t\t!assume 'C'\n\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_u64(word64 a, ref fmtrec fmt)=\n\tarray [360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 'D','d' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\twhen 'C','c' then\n\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\n\telse\n\t\tn:=u64tostrfmt(a,&.str,fmt)\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_r64(real x,ref fmtrec fmt) =\n\tarray [360]char str,str2\n\tarray [0:10]char cfmt\n\tint n\n\n\tcfmt[0]:='%'\n\n\tif fmt.precision then\n\t\tcfmt[1]:='.'\n\t\tcfmt[2]:='*'\n\t\tcfmt[3]:=fmt.realfmt\n\t\tcfmt[4]:=0\n\t\tsprintf(&.str,&.cfmt,fmt.precision,x)\n\telse\n\t\tcfmt[1]:=fmt.realfmt\n\t\tcfmt[2]:=0\n\t\tsprintf(&.str,&.cfmt,x)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\n\tn:=strlen(&.str)\t\t! current length\n\n\tif n<fmt.minwidth then\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\n\t\tstrcpy(&.str,&.str2)\n\tfi\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_str(ref char s, int oldlen, ref fmtrec fmt) =\n\tint newlen,n\n\tref char t\n\n!try and work out size of formatted string\n\tif oldlen=-1 then\n\t\toldlen:=strlen(s)\n\tfi\n\tnewlen:=oldlen\n\n\tif fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then\n\t\tif fmt.quotechar then\n\t\t\tnewlen+:=2\n\t\tfi\n\t\tif fmt.minwidth>newlen then\n\t\t\tnewlen:=fmt.minwidth\n\t\tfi\n\t\tt:=pcm_alloc(newlen+1)\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\n\t\tif fmt.precision then\n\t\t\tn min:=fmt.precision\n\t\tfi\n\n\t\tprintstr_n(t,n)\n\t\tpcm_free(t,newlen+1)\n\telse\n\t\tprintstr_n(s,oldlen)\n\tfi\nend\n\nfunction getfmt(ichar fmtstyle)ref fmtrec=\n\tstatic fmtrec fmt\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\treturn &fmt\n\telse\n\t\treturn &defaultfmt\n\tfi\nend\n\nexport function strint(int64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport proc getstrint(int64 a, ichar dest)=\n\tm$print_startstr(dest)\n\ttostr_i64(a,getfmt(nil))\n\tm$print_end()\nend\n\nexport function strword(word64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function strreal(real a, ichar fmtstyle=nil)ichar=\n\tstatic [320]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function getstr(ichar s, ref fmtrec fmt)ichar=\n\tif fmt.heapmode then\n\t\treturn pcm_copyheapstring(s)\n\telse\n\t\treturn s\n\tfi\nend\n\nproc initreadbuffer=\n\tif rd_buffer then return fi\n\trd_buffer:=pcm_alloc(rd_buffersize)\n\trd_buffer^:=0\n\trd_pos:=rd_lastpos:=rd_buffer\nend\n\nglobal proc m$read_conline=\n\tinitreadbuffer()\n\n\treadlinen(nil,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_fileline(filehandle f)=\n\tichar p\n\tinitreadbuffer()\n\n\tif f=filehandle(1) then\nABORTPROGRAM(\"READ CMDLINE\")\n!\t\trd_buffer^:=0\n!\t\tp:=getcommandlinea()\n!\t\trepeat\n!\t\t\t++p\n!\t\tuntil p^ in [' ','\\t',0]\n!\t\tstrcpy(rd_buffer, p)\n!\t\trd_length:=strlen(rd_buffer)\n!\t\trd_pos:=rd_buffer\n!\t\trd_lastpos:=nil\n\t\treturn\n\tfi\n\n\treadlinen(f,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_strline(ichar s)=\n\tint n\n\n\tinitreadbuffer()\n\tn:=strlen(s)\n\n\tif n<rd_buffersize then\n\t\tstrcpy(rd_buffer,s)\n\telse\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\n\t\t(rd_buffer+rd_buffersize-1)^:=0\n\tfi\n\trd_length:=n\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nfunction readitem(int &itemlength)ref char =\n!read next item from rd_buffer\n!identify a substring that can contain a name, int, real, string or filename\n!return updated position of s that points past the item and past the immediate\n!terminator \n!information about the read item is returned in itemstr, which points to\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\n!Item can be quoted, then the item points inside the quotes\n!Any embedded quotes are removed, and the characters moved up. The item will\n!be that reduced subsequence\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\n!I can mitigate this by adding spaces between the end of the item, and the next item,\n!overwriting also the terminator. But this won't restore the line if one of the next\n!reads is literal, using 'L' or 'C' codes.\n\tref char p,s,itemstr\n\tchar quotechar, c\n\n\tunless rd_buffer then \n\t\tinitreadbuffer()\n\tend unless\n\n\ts:=rd_pos\n\n!scan string, eliminating leading white space\n\twhile s^=' ' or s^=9 do\n\t\t++s\n\tod\n\n\titemstr:=s\t\t\t\t!assume starts here\n\trd_lastpos:=rd_pos:=s\n\n\tif s^=0 then\t\t\t! No more chars left to read return null string\n\t\ttermchar:=0\n\t\titemlength:=0\n\t\treturn s\n\tfi\n\n\tquotechar:=0\t\t\t! Allow possible enclosing single or double quotes\n\tif s^='\"' then\n\t\tquotechar:='\"'\n\t\t++s\n\telsif s^='\\'' then\n\t\tquotechar:='\\''\n\t\t++s\n\tfi\n\n!loop reading characters until separator or end reached\n\tp:=itemstr:=s\n\n\twhile s^ do\n\t\tc:=s++^\n\t\tswitch c\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\n\t\t\t\tgoto normalchar\n\t\t\tfi\n\t\t\ttermchar:=c\n\t\t\texit\n\t\telse\n\tnormalchar::\n\t\t\tif c=quotechar then\n\t\t\t\tif s^=quotechar then\t! embedded quote\n\t\t\t\t\tp^:=c\n\t\t\t\t\t++s\n\t\t\t\t\t++p\n\t\t\t\telse\t\t\t\t\t! end of name\n\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tif termchar=',' or termchar='=' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tfi\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tp^:=c\n\t\t\t\t++p\n\t\t\tfi\n\t\tendswitch\n\tod\n\n\tif s^=0 then\n\t\ttermchar:=0\n\tfi\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\n\trd_pos:=s\n\n\treturn itemstr\nend\n\nexport function strtoint(ichar s,int length=-1, word base=10)int64=\n!return point to next char after terminator (which can be just off length of string)\n\tbyte signd\n\tword64 aa\n\tword c,d\n\n\titemerror:=0\n\n\tif length=-1 then\n\t\tlength:=strlen(s)\n\tfi\n!check for sign\n\tsignd:=0\n\tif length and s^='-' then\n\t\tsignd:=1; ++s; --length\n\telsif length and s^='+' then\n\t\t++s; --length\n\tfi\n\n\taa:=0\n\twhile length do\n\t\tc:=s++^\n\t\t--length\n\t\tswitch c\n\t\twhen 'A'..'F' then d:=c-'A'+10\n\t\twhen 'a'..'f' then d:=c-'a'+10\n\t\twhen '0'..'9' then d:=c-'0'\n\t\twhen '_', '\\'' then\n\t\t\tnext\n\t\telse\n\t\t\titemerror:=1\n\t\t\texit\n\t\tendswitch\n\n\t\tif d>=base then\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\t\taa:=aa*base+d\n\tod\n\n\tif signd then\n\t\treturn -aa\n\telse\n\t\treturn aa\n\tfi\nend\n\nglobal function m$read_i64(int fmt=0)int64=\n\tref char s\n\tint length,c\n\tint64 aa\n\n\tcase fmt\n\twhen 'C','c' then\n\t\trd_lastpos:=rd_pos\n\t\tif rd_pos^ then\n\t\t\treturn rd_pos++^\n\t\telse\n\t\t\treturn 0\n\t\tfi\n\twhen 'T','t' then\n\t\treturn termchar\n\twhen 'E','e' then\n\t\treturn itemerror\n\tesac\n\n\ts:=readitem(length)\n\n\tcase fmt\n\twhen 0,'I','i' then\n\t\treturn strtoint(s,length)\n\twhen 'B','b' then\n\t\treturn strtoint(s,length,2)\n\twhen 'H','h' then\n\t\treturn strtoint(s,length,16)\n\tesac\n\treturn 0\nend\n\nglobal function m$read_r64(int fmt=0)real=\n\tarray [512]char str\n\tref char s\n\tint length\n\tint32 numlength\n\treal x\n\n\ts:=readitem(length)\n\n\tif length=0 or length>=str.len then\t\t!assume not a real\n\t\treturn 0.0\n\tfi\n\tmemcpy(&.str,s,length)\n\tstr[length+1]:=0\n\n\titemerror:=0\n\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\n\t\tx:=0.0\n\t\titemerror:=1\n\tfi\n\n\treturn x\nend\n\nglobal proc m$read_str(ref char dest, int destlen=0,fmt=0)=\n\tref char s\n\tint length,numlength\n\treal x\n\n\titemerror:=0\n\tif fmt='L' or fmt='l' then\n\t\ts:=rd_pos\n\t\tlength:=rd_buffer+rd_length-rd_pos\n\n\telse\n\t\ts:=readitem(length)\n\n\t\tif fmt='N' or fmt='n' then\n\t\t\ticonvlcn(s,length)\n\t\tfi\n\tfi\n\n\tif destlen>0 then\n\t\tif length>=destlen then\n\t\t\tlength:=destlen-1\n\t\t\titemerror:=1\n\t\tfi\n\tfi\n\tmemcpy(dest,s,length)\n\t(dest+length)^:=0\nend\n\nexport proc readstr(ref char dest, int fmt=0,destlen=0)=\n\tm$read_str(dest,destlen,fmt)\nend\n\nexport proc rereadln=\n\trd_pos:=rd_buffer\n\trd_lastpos:=rd_pos\nend\n\nexport proc reread=\n\trd_pos:=rd_lastpos\nend\n\nexport function valint(ichar s, int fmt=0)int64=\n\tref char old_pos, old_lastpos\n\tint64 aa\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\taa:=m$read_i64(fmt)\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn aa\nend\n\nexport function valreal(ichar s)real=\n\tref char old_pos, old_lastpos\n\treal x\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\tx:=m$read_r64()\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn x\nend\n\nproc mclunimpl(ichar mess)=\n\tprintf(\"MCL-UNIMPL: %s\\n\",mess)\n\tstop 1\nend\n\nproc dumpstr(ichar s, int n, fbuffer=0)=\n!fbuffer=1 when outputting contents of buffer\n\n\tref ref char p\n\n\treturn when n=0\n\n\tif outdev=str_io then\n\t\tp:=cast(outchan)\n\t\tmemcpy(p^,s,n)\n\t\tp^+:=n\n\t\tp^^:=0\n\t\treturn\n\tfi\n\n\tif fbuffer and n>=2 and outdev=std_io then\n\t\t--printptr\t\t\t\t!point to last char\n\t\tif printptr^=10 then\n\t\t\tif (printptr-1)^=13 then\t\t!crlf\n!PUTS(\"<CRLF>\")\n\t\t\t\t(printptr-1)^:=0\n\t\t\telse\t\t\t\t\t\t\t!lf only\n!PUTS(\"<LF>\")\n\t\t\t\tprintptr^:=0\n\t\t\tfi\n\t\t\tputs(printbuffer)\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\tesac\nend\n\nproc dumpprintbuffer=\n\tif printlen then\n\t\tdumpstr(&.printbuffer,printlen,1)\n\tfi\n\n\tresetprintbuffer()\nend\n\nproc resetprintbuffer=\n\tprintptr:=&.printbuffer\n\tprintlen:=0\nend\n\nproc addtobuffer(ichar s, int n)=\n!RETURN\n\tif printlen+n>=(printbuffer.len-8) then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif n<printbuffer.len then\n\t\tmemcpy(printptr,s,n)\n\t\tprintptr+:=n\n\t\tprintlen+:=n\n\t\treturn\n\tfi\n\n\tdumpstr(s, n)\t\t\t!don't bother with buffer\nend\n\nglobal function m$power_i64(int64 a,n)int64=\n\tif n<0 then\n\t\treturn 0\n\telsif n=0 then\n\t\treturn 1\n\telsif n=1 then\n\t\treturn a\n\telsif (n iand 1)=0 then\n\t\treturn m$power_i64(sqr a,n/2)\n\telse\t\t\t!assume odd\n\t\treturn m$power_i64(sqr a,(n-1)/2)*a\n\tfi\nend\n\nexport function vector_dupl(ref void p, int size)ref void=\n\tCPL \"VECTOR_DUPL\",P,SIZE\n\tp\nend\n",
(byte*)"!const mem_check=1\nconst mem_check=0\n\nglobal [0..300]u64 allocupper\nglobal int alloccode\t\t\t\t!set by heapalloc\nexport int allocbytes\t\t\t\t!set by heapalloc\nexport int fdebug=0\nexport int rfsize\n\nconst threshold=1<<25\nconst alloc_step=1<<25\nword maxmemory\nint  maxalloccode\n\nGLOBAL REF VOID ALLOCBASE\n\nbyte pcm_setup=0\n\nint show=0\n\nglobal int memtotal=0\nexport int64 smallmemtotal=0\nglobal int smallmemobjs=0\nglobal int maxmemtotal=0\n\n!EXPORT INT BIGMEMTOTAL\n!EXPORT INT BIGMEMMAX\n!EXPORT INT SMALLMEMMAX\n\n\n!store all allocated pointers\nconst int maxmemalloc=(mem_check|500000|2)\narray [maxmemalloc+1]ref int32 memalloctable\narray [maxmemalloc+1]int32 memallocsize\n\nconst pcheapsize=1048576*2\nref byte pcheapstart\nref byte pcheapend\t\t\t!points to first address past heap\nref byte pcheapptr\n\nconst int maxblockindex = 8 \t\t!2048\nexport const int maxblocksize = 2048\nexport const int $maxblocksizexx = 2048\n\narray [0:maxblocksize+1]byte sizeindextable\t!convert byte size to block index 1..maxblockindex\n\nconst int size16   = 1\t\t\t!the various index codes\nconst int size32   = 2\nconst int size64   = 3\nconst int size128  = 4\nconst int size256  = 5\nconst int size512  = 6\nconst int size1024 = 7\nconst int size2048 = 8\n\nexport [0:9]ref word freelist\n\nexport record strbuffer =\n\tichar strptr\n\tint32 length\n\tint32 allocated\nend\n\n!export tabledata() [0:]ichar pmnames=\nexport enumdata [0:]ichar pmnames=\n\t(pm_end=0,\t\t$),\n\t(pm_option,\t\t$),\n\t(pm_sourcefile,\t$),\n\t(pm_libfile,\t$),\n\t(pm_colon,\t\t$),\n\t(pm_extra,\t\t$),\nend\n\n[2]word seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)\n!array [2]int seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)\n\nexport function pcm_alloc(int n)ref void =\n\tref byte p\n!CPL \"ALLOC\"\n\n\tif not pcm_setup then\n\t\tpcm_init()\n\tfi\n\n\tif n>maxblocksize then\t\t\t!large block allocation\n\n\t\talloccode:=pcm_getac(n)\n\t\tallocbytes:=allocupper[alloccode]\n\n\t\tp:=allocmem(allocbytes)\n\t\tif not p then\n\t\t\tabortprogram(\"pcm_alloc failure\")\n\t\tfi\n!bigmemtotal+:=allocbytes\n!bigmemmax max:=bigmemtotal\n\n\t\tif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\n\n\t\treturn p\n\tfi\n\n\talloccode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\tallocbytes:=allocupper[alloccode]\n\tsmallmemtotal+:=allocbytes\n!SMALLMEMMAX MAX:=SMALLMEMTOTAL\n\n\tif p:=ref byte(freelist[alloccode]) then\t\t!Items of this block size available\n\t\tif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\n\t\tfreelist[alloccode]:=ref word(int((freelist[alloccode])^))\n\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\tp:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\n\tpcheapptr+:=allocbytes\t\t\t!Shrink remaining pool\n\n\tif pcheapptr>=pcheapend then\t\t!Overflows?\n\t\tp:=pcm_newblock(allocbytes)\t\t!Create new heap block, and allocate from start of that\n\t\treturn p\n\tfi\n\tif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\n\n\treturn p\nend\n\nexport proc pcm_free(ref void p,int n) =\n!n can be the actual size requested it does not need to be the allocated size\n\tint acode\n\n\tif n=0 then return fi\n\n\tif n>maxblocksize then\t\t!large block\n\t\tif mem_check then removefrommemalloc(p,n) fi\n\nMAXMEMTOTAL-:=N\n\n\t\tfree(p)\n\t\treturn\n\tfi\n\n\tif p then\n\t\tacode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\n\t\tsmallmemtotal-:=allocupper[acode]\n\n\t\tif mem_check then removefrommemalloc(p,allocupper[acode]) fi\n\n\t\tcast(p,ref word)^:=word(int(freelist[acode]))\n\t\tfreelist[acode]:=p\n\tfi\nend\n\nexport proc pcm_freeac(ref void p,int alloc) =\n\tpcm_free(p,allocupper[alloc])\nend\n\n!export proc pcm_copymem4(ref void p,q,int n) =\t!PCM_COPYMEM4\n!!copy n bytes of memory from q to p.\n!!the memory spaces used are multiples of 16 bytes, but n itself could be anything\n!!n can be zero, and need not be a multiple of 4 bytes\n!\n!\tmemcpy(p,q,n)\n!end\n\nexport proc pcm_clearmem(ref void p,int n) =\n\tmemset(p,0,n)\nend\n\nexport proc pcm_init =\n!set up sizeindextable too\n\tint j,k,k1,k2\n\tint64 size\n\tconst limit=1<<33\n\n\talloccode:=0\n\tif pcm_setup then\n\t\treturn\n\tfi\n\n\tpcm_newblock(0)\n\n!\tALLOCBASE:=PCHEAPPTR\n\n\tfor i to maxblocksize do\t!table converts eg. 78 to 4 (4th of 16,32,64,128)\n\t\tj:=1\n\t\tk:=16\n\t\twhile i>k do\n\t\t\tk:=k<<1\n\t\t\t++j\n\t\tod\n\t\tsizeindextable[i]:=j\n\tod\n\n\tallocupper[1]:=16\n\tsize:=16\n\n\tfor i:=2 to 27 do\n\t\tsize*:=2\n\t\tallocupper[i]:=size\n\t\tif size>=threshold then\n\t\t\t\tk:=i\n\t\t\texit\n\t\tfi\n\tod\n\n\tfor i:=k+1 to allocupper.upb do\n\t\tsize+:=alloc_step\n\t\tif size<limit then\n\t\t\tallocupper[i]:=size\n\t\t\tmaxmemory:=size\n\t\telse\n\t\t\tmaxalloccode:=i-1\n\t\t\texit\n\t\tfi\n\t\t\n\tod\n\tpcm_setup:=1\nend\n\nexport function pcm_getac(int size)int =\n! convert linear blocksize from 0..approx 2GB to 8-bit allocation code\n\n!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]\t\t!size 0 to 2KB\n\tfi\n\n\tsize:=(size+255)>>8\t\t\t\t\t!scale by 256\n\n!now same sizetable can be used for 2KB to 512KB (288 to 2KB)\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+8\n\tfi\n\n!sizetable now used for 512KB to 128MB (to 2KB)\n\tsize:=(size+63)>>6\t\t\t\t\t!scale by 256\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+14\n\tfi\n\n!size>2048, which means it had been over 128MB.\n\tsize:=(size-2048+2047)/2048+22\n\treturn size\nend\n\nexport function pcm_newblock(int itemsize)ref void=\n!create new heap block (can be first)\n!also optionally allocate small item at start\n!return pointer to this item (and to the heap block)\n\tstatic int totalheapsize\n\tref byte p\n\n\ttotalheapsize+:=pcheapsize\n\talloccode:=0\n\tp:=allocmem(pcheapsize)\t!can't free this block until appl terminates\n\tif p=nil then\n\t\tabortprogram(\"Can't alloc pc heap\")\n\tfi\n\n\tpcheapptr:=p\n\tpcheapend:=p+pcheapsize\n\n\tif pcheapstart=nil then\t\t!this is first block\n\t\tpcheapstart:=p\n\tfi\n\tpcheapptr+:=itemsize\n\treturn ref u32(p)\nend\n\nexport function pcm_round(int n)int =\n!for any size n, return actual number of bytes that would be allocated\n\tstatic [0:maxblockindex+1]int32 allocbytes=(0,16,32,64,128,256,512,1024,2048)\n\n\tif n>maxblocksize then\n\t\treturn n\n\telse\n\t\treturn allocbytes[sizeindextable[n]]\n\tfi\nend\n\n!export function pcm_array(int n)int =\t\t!PCM_ARRAY\n!!n bytes are needed for an array return the number of bytes to be actually allocated\n!\tint m\n!\n!\tif n<=maxblocksize then\t!automatic rounding up used for small heap\n!\t\treturn pcm_round(n)\n!\telse\t\t\t\t!devise some strategy probably doubling up.\n!\t\tm:=2048\n!\t\twhile n>m do\n!\t\t\tm<<:=1\n!\t\tod\n!\t\treturn m\n!\tfi\n!\n!end\n!\n!global proc pcm_printfreelist(int size,ref word p) =\t\t!PCM_PRINTFREELIST\n!\tprintln \"Size: \",size\n!\twhile p do\n!\t\tprint \" \",,p:\"h\"\n!\t\tp:=ref word(int(p^))\n!\tod\n!\tputs(\"\")\n!end\n!\n!global proc pcm_diags(ref char caption) =\t\t!PCM_DIAGS\n!\tint m\n!\n!\tprintln \"HEAP FREELISTS:\",caption\n!\n!\tm:=16\n!\tfor i:=1 to 8 do\n!\t\tpcm_printfreelist(m,freelist[i])\n!\t\tm<<:=1\n!\tod\n!end\n\nexport function pcm_allocz(int n)ref void =\n\tref void p\n\tp:=pcm_alloc(n)\n\n\tmemset(p,0,n)\n\treturn p\nend\n\nexport function pcm_copyheapstring(ref char s)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tint n\n\tif s=nil then return nil fi\n\n\tn:=strlen(s)+1\n\tq:=pcm_alloc(n)\n\tmemcpy(q,s,n)\n\treturn q\nend\n\nexport function pcm_copyheapstringn(ref char s,int n)ref char =\n\tref char q\n\tif s=nil then return nil fi\n\n\tq:=pcm_alloc(n+1)\n\tmemcpy(q,s,n)\n\t(q+n)^:=0\n\treturn q\nend\n\nexport function pcm_copyheapblock(ref char s, int length)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tif length=0 then return nil fi\n\n\tq:=pcm_alloc(length)\n\tmemcpy(q,s,length)\n\treturn q\nend\n\nproc addtomemalloc(ref int32 ptr,int size)=\n!add ptr to allocated table\n\tint allocated, code\n\nCPL \"***************ADD TO ALLOC:\",ptr,size\n\tfor i to maxmemalloc do\n\t\tif memalloctable[i]=ptr then\n\t\t\tCPL \"ALLOC ERROR:\",ptr,\"ALREADY ALLOCATED\\n\\n\\n\"\n\t\t\tstop 2\n\t\tfi\n\n\t\tif memalloctable[i]=nil then\t\t!unused entry\n\t\t\tmemalloctable[i]:=ptr\n\n\t\t\tcode:=pcm_getac(size)\n\t\t\tallocated:=allocupper[code]\n\n!CPL \"STORING\",SIZE,ALLOCATED\n\t\t\tmemallocsize[i]:=allocated\n!\t\t\tmemallocsize[i]:=size\n\t\t\treturn\n\t\tfi\n\tod\n\tCPL \"MEMALLOCTABLE FULL\\n\\n\\n\\n\"; os_getch()\n\tCPL\n\tstop 3\nend\n\nproc removefrommemalloc(ref int32 ptr,int size)=\n!remove ptr to allocated table\n\tint allocated, code\n\nCPL \"------------------************REMOVE FROM ALLOC:\",ptr,size\n\tcode:=pcm_getac(size)\n\tallocated:=allocupper[code]\n\n\tfor i to maxmemalloc do\n\t\tif memalloctable[i]=ptr then\n\t\t\tif memallocsize[i]<>ALLOCATED then\n!\t\t\t\tCPL \"REMOVE:FOUND\",ptr,\"IN MEMALLOCTABLE, FREESIZE=\",size,\", BUT STORED AS BLOCK SIZE:\",memallocsize[i]\n\t\t\t\tCPL \"REMOVE:FOUND\",ptr,\"IN MEMALLOCTABLE, ROUNDED FREESIZE=\",ALLOCATED,\", BUT STORED AS BLOCK SIZE:\",memallocsize[i]\n\t\t\t\tabortprogram(\"MEMSIZE\")\n\t\t\tfi\n\t\t\tmemalloctable[i]:=nil\n\t\t\treturn\n\t\tfi\n\tod\n\tCPL \"CAN'T FIND\",ptr,\"IN MEMALLOCTABLE\",size\n\tCPL \nos_GETCH()\n\tabortprogram(\"MEM\")\n\tstop 4\nend\n\nexport function allocmem(int n)ref void =\n\tref void p\n\n\tp:=malloc(n)\n\tif p then\n\t\treturn p\n\tfi\n\tprintln n,memtotal\n\tabortprogram(\"Alloc mem failure\")\n\treturn nil\nend\n\nglobal function reallocmem(ref void p,int n)ref void =\n\tp:=realloc(p,n)\n\treturn p when p\n\tprintln n\n\tabortprogram(\"Realloc mem failure\")\n\treturn nil\nend\n\nexport proc abortprogram(ref char s) =\n\tprintln s\n\tprint   \"ABORTING: Press key...\"\n!os_getch()\n\tstop 5\nend\n\nexport function getfilesize(filehandle handlex)int=\n\tword32 p,size\n\n\tp:=ftell(handlex)\t\t!current position\n\tfseek(handlex,0,2)\t\t!get to eof\n\tsize:=ftell(handlex)\t\t!size in bytes\n\tfseek(handlex,p,seek_set)\t!restore position\n\treturn size\nend\n\nexport proc readrandom(filehandle handlex, ref byte mem, int offset, size) =\n\tint a\n\tfseek(handlex,offset,seek_set)\n\ta:=fread(mem,1,size,handlex)\t\t\t!assign so as to remove gcc warning\nend\n\nexport function writerandom(filehandle handlex, ref byte mem, int offset,size)int =\n\tfseek(handlex,offset,seek_set)\n\treturn fwrite(mem,1,size,handlex)\nend\n\nexport function setfilepos(filehandle file,int offset)int=\n\treturn fseek(file,offset,0)\nend\n\nexport function getfilepos(filehandle file)int=\n\treturn ftell(file)\nend\n\nexport function readfile(ref char filename)ref byte =\n\tfilehandle f\n\tint size\n\tref byte m,p\n\n\tf:=fopen(filename,\"rb\")\n\tif f=nil then\n\t\treturn nil\n\tfi\n\trfsize:=size:=getfilesize(f)\n\n\tm:=malloc(size+2)\t\t!allow space for etx/zeof etc\n\n\tif m=nil then\n\t\treturn nil\n\tfi\n\n\treadrandom(f,m,0,size)\n\tp:=m+size\t\t\t!point to following byte\n\t(ref u16(p)^:=0)\t!add two zero bytes\n\n\tfclose(f)\n\treturn m\nend\n\nexport function writefile(ref char filename,ref byte data,int size)int =\n\tfilehandle f\n\tint n\n\n\tf:=fopen(filename,\"wb\")\n\tif f=nil then\n\t\treturn 0\n\tfi\n\n\tn:=writerandom(f,data,0,size)\n\tfclose(f)\n\treturn n\nend\n\nexport function checkfile(ref char file)int=\n\tfilehandle f\n\tif f:=fopen(file,\"rb\") then\n\t\tfclose(f)\n\t\treturn 1\n\tfi\n\treturn 0\nend\n\nexport proc readlinen(filehandle handlex,ref char buffer,int size) =\n!size>2\n\tint ch\n\tref char p\n\tint n\n\tarray [0:100]char buff\n\tbyte crseen\n\n\tif handlex=nil then\n\t\thandlex:=filehandle(os_getstdin())\n\tfi\n\tif handlex=nil then\n\t\tn:=0\n\t\tp:=buffer\n\t\tdo\n\t\t\tch:=getchar()\n\t\t\tif ch=13 or ch=10 or ch=-1 then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\t\tp++^:=ch\n\t\t\t++n\n\t\t\tif n>=(size-2) then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\tod\n\tfi\n\n\tbuffer^:=0\n\tif fgets(buffer,size-2,handlex)=nil then\n\t\treturn\n\tfi\n\n\tn:=strlen(buffer)\n\tif n=0 then\n\t\treturn\n\tfi\n\n\tp:=buffer+n-1\t\t!point to last char\n\tcrseen:=0\n\twhile (p>=buffer and (p^=13 or p^=10)) do\n\t\tif p^=13 or p^=10 then crseen:=1 fi\n\t\tp--^ :=0\n\tod\n\n!NOTE: this check doesn't work when a line simply doesn't end with cr-lf\n\n\tif not crseen and (n+4>size) then\n\t\tcpl size,n\n\t\tabortprogram(\"line too long\")\n\tfi\nend\n\nexport proc iconvlcn(ref char s,int n) =\n\tto n do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\nend\n\nexport proc iconvucn(ref char s,int n) =\n\tto n do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\nend\n\nexport function convlcstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function convucstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function changeext(ref char s,newext)ichar=\n!whether filespec has an extension or not, change it to newext\n!newext should start with \".\"\n!return new string (locally stored static string, so must be used before calling again)\n\tstatic [260]char newfile\n\tarray [32]char newext2\n\tref char sext\n\tint n\n\n\tstrcpy(&newfile[1],s)\n\n\tcase newext^\n\twhen 0 then\n\t\tnewext2[1]:=0\n\t\tnewext2[2]:=0\n\twhen '.' then\n\t\tstrcpy(&newext2[1],newext)\n\telse\n\t\tstrcpy(&newext2[1],\".\")\n\t\tstrcat(&newext2[1],newext)\n\tesac\n\n\n\tsext:=extractext(s,1)\t\t\t!include \".\" when it is only extension\n\n\tcase sext^\n\twhen 0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[1])\n\twhen '.' then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[2])\n\telse\t\t\t\t\t\t\t!has extension\n\t\tn:=sext-s-2\t\t\t!n is number of chars before the \".\"\n\t\tstrcpy(&newfile[1]+n+1,&newext2[1])\n\tesac\n\n\treturn &newfile[1]\nend\n\nexport function extractext(ref char s,int period=0)ichar=\n!if filespec s has an extension, then return pointer to it otherwise return \"\"\n!if s ends with \".\", then returns \".\"\n\tref char t,u\n\n\tt:=extractfile(s)\n\n\tif t^=0 then\t\t\t!s contains no filename\n\t\treturn \"\"\n\tfi\n\n!t contains filename+ext\n\tu:=t+strlen(t)-1\t\t!u points to last char of t\n\n\twhile u>=t do\n\t\tif u^='.' then\t\t!start extension found\n\t\t\tif (u+1)^=0 then\t\t!null extension\n\t\t\t\treturn (period|\".\"|\"\")\n\t\t\tfi\n\t\t\treturn u+1\t\t\t!return last part of filename as extension exclude the dot\n\t\tfi\n\t\t--u\n\tod\n\treturn \"\"\t\t\t!no extension seen\nend\n\nexport function extractpath(ref char s)ichar=\n\tstatic [0:260]char str\n\tref char t\n\tint n\n\n\tt:=s+strlen(s)-1\t\t!t points to last char\n\n\twhile (t>=s) do\n\t\tswitch t^\n\t\twhen '\\\\','/',':' then\t\t!path separator or drive letter terminator assume no extension\n\t\t\tn:=t-s+1\t\t\t!n is number of chars in path, which includes rightmost / or \\ or :\n\t\t\tmemcpy(&.str,s,n)\n\t\t\tstr[n]:=0\n\t\t\treturn &.str\n\t\tendswitch\n\t\t--t\n\tod\n\treturn \"\"\t\t\t!no path found\nend\n\nexport function extractfile(ref char s)ichar=\n\tref char t\n\n\tt:=extractpath(s)\n\n\tif t^=0 then\t\t\t!s contains no path\n\t\treturn s\n\tfi\n\n\treturn s+strlen(t)\t\t!point to last part of s that contains the file\n\tend\n\nexport function extractbasefile(ref char s)ichar=\n\tstatic [0:100]char str\n\tref char f,e\n\tint n,flen\n\n\tf:=extractfile(s)\n\tflen:=strlen(f)\n\tif flen=0 then\t\t!s contains no path\n\t\treturn \"\"\n\tfi\n\te:=extractext(f,0)\n\n\tif e^ then\t\t\t!not null extension\n\t\tn:=flen-strlen(e)-1\n\t\tmemcpy(&str,f,n)\n\t\tstr[n]:=0\n\t\treturn &.str\n\tfi\n\tif (f+flen-1)^='.' then\n\t\tmemcpy(&str,f,flen-1)\n\t\tstr[flen-1]:=0\n\t\treturn &.str\n\tfi\n\treturn f\nend\n\nexport function addext(ref char s,ref char newext)ichar=\n!when filespec has no extension of its own, add newext\n\tref char sext\n\n\tsext:=extractext(s,1)\n\n\tif sext^=0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\treturn changeext(s,newext)\n\tfi\n\n\treturn s\t\t\t\t\t\t\t!has own extension; use that\nend\n\n!export function alloctable(int n, size)ref void =\t\t!ALLOCTABLE\n!!Allocate table space for n elements, each of size <size>\n!!Allows for 1-based indexing, so allocates (n+1) elements\n!\tref void p\n!\n!\tp:=malloc((n+1)*size)\n!\n!\tif not p then\n!\t\tabortprogram(\"Alloctable failure\")\n!\tfi\n!\treturn p\n!end\n\n!export function zalloctable(int n, size)ref void =\t\t!ALLOCTABLE\n!!Allocate table space for n elements, each of size <size>\n!!Allows for 1-based indexing, so allocates (n+1) elements\n!\tref int p\n!\n!\tp:=alloctable(n,size)\n!\n!\tpcm_clearmem(p,(n+1)*size)\n!\treturn p\n!end\n!\n!global proc checkfreelists(ichar s)=\n!\tref word p,q\n!\tint64 aa\n!\n!\tfor i:=2 to 2 do\n!\t\tp:=freelist[i]\n!\n!\t\twhile p do\n!\t\t\taa:=int64(p)\n!\t\t\tif aa>0xffff'FFFF or aa<100 then\n!\t\t\t\tCPL s,\"FREE LIST ERROR\",i,p,q\n!!\t\t\tos_getch(); stop 1\n!\t\t\tfi\n!\t\t\tq:=p\n!\t\t\tp:=ref word(int(p^))\n!\t\tod\n!\n!\tod\n!end\n\nexport function pcm_alloc32:ref void =\n\tref byte p\n\n!RETURN PCM_ALLOC(32)\n\n\tallocbytes:=32\n\tsmallmemtotal+:=32\n!SMALLMEMMAX MAX:=SMALLMEMTOTAL\n\n\tif p:=ref byte(freelist[2]) then\t\t!Items of this block size available\n\t\tfreelist[2]:=ref word(int((freelist[2])^))\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\treturn pcm_alloc(32)\nend\n\nexport proc pcm_free32(ref void p) =\n!n can be the actual size requested it does not need to be the allocated size\n\n!PCM_FREE(P,32)\n!RETURN\n\n\tsmallmemtotal-:=32\n\tif mem_check then removefrommemalloc(p,32) fi\n\n\tcast(p,ref word)^:=word(int(freelist[2]))\n\tfreelist[2]:=p\nend\n\nexport function pcm_alloc64:ref void =\n\tref byte p\n\tallocbytes:=64\n\tsmallmemtotal+:=64\n!SMALLMEMMAX MAX:=SMALLMEMTOTAL\n\n\tif p:=ref byte(freelist[3]) then\t\t!Items of this block size available\n\t\tfreelist[3]:=ref word(int((freelist[3])^))\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\treturn pcm_alloc(64)\n\n!\tp:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\n!\tpcheapptr+:=64\t\t\t!Shrink remaining pool\n!\n!\tif pcheapptr>=pcheapend then\t\t!Overflows?\n!\t\tp:=pcm_newblock(64)\t\t!Create new heap block, and allocate from start of that\n!\t\treturn p\n!\tfi\n!\tif mem_check then addtomemalloc(ref int32(p),allocbytes) fi\n!\n!\treturn p\nend\n\nexport proc pcm_free64(ref void p) =\n!n can be the actual size requested it does not need to be the allocated size\n\n\tsmallmemtotal-:=64\n\tif mem_check then removefrommemalloc(p,64) fi\n\n\tcast(p,ref word)^:=word(int(freelist[3]))\n\tfreelist[3]:=p\nend\n\nexport function pcm_alloc16:ref void =\n\tref byte p\n\tallocbytes:=16\n\tsmallmemtotal+:=16\n!SMALLMEMMAX MAX:=SMALLMEMTOTAL\n\n\tif p:=ref byte(freelist[1]) then\t\t!Items of this block size available\n\t\tfreelist[1]:=ref word(int((freelist[1])^))\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\treturn pcm_alloc(16)\nend\n\nexport proc pcm_free16(ref void p) =\n!n can be the actual size requested it does not need to be the allocated size\n\n\tsmallmemtotal-:=16\n\tif mem_check then removefrommemalloc(p,32) fi\n\n\tcast(p,ref word)^:=word(int(freelist[1]))\n\tfreelist[1]:=p\nend\n\nexport proc outbyte(filehandle f,int x)=\n\tfwrite(&x,1,1,f)\nend\n\nexport proc outword16(filehandle f,word x)=\n\tfwrite(&x,2,1,f)\nend\n\nexport proc outword32(filehandle f,word x)=\n\tfwrite(&x,4,1,f)\nend\n\nexport proc outword64(filehandle f,word64 x)=\n\tfwrite(&x,8,1,f)\nend\n\nexport proc outstring(filehandle f, ichar s)=\n\tfwrite(s,strlen(s)+1,1,f)\nend\n\nexport proc outblock(filehandle f, ref void p, int n)=\n\tfwrite(p,n,1,f)\nend\n\nexport function myeof(filehandle f)int=\n\tint c\n\n\tc:=fgetc(f)\n\tif c=c_eof then return 1 fi\n\tungetc(c,f)\n\treturn 0;\nend\n\nexport proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)=\n\tint newlen,oldlen\n\tichar newptr\n\n\tIF N=0 THEN CPL \"N=0\" FI\n\n\tif n=-1 then\n\t\tn:=strlen(s)\n\tfi\n\n\toldlen:=dest.length\n\n\tif oldlen=0 then\t\t\t\t!first string\n\t\tdest.strptr:=pcm_alloc(n+1)\n\t\tdest.allocated:=allocbytes\n\t\tdest.length:=n\t\t\t\t!length always excludes terminator\n\t\tmemcpy(dest.strptr,s,n)\n\t\t(dest.strptr+n)^:=0\n\t\treturn\n\tfi\n\n\tnewlen:=oldlen+n\n\tif newlen+1>dest.allocated then\n\t\tnewptr:=pcm_alloc(newlen+1)\n\t\tmemcpy(newptr,dest.strptr,oldlen)\n\t\tdest.strptr:=newptr\n\t\tdest.allocated:=allocbytes\n\tfi\n\n\tmemcpy(dest.strptr+oldlen,s,n)\n\t(dest.strptr+newlen)^:=0\n\n\tdest.length:=newlen\nend\n\nexport proc gs_init(ref strbuffer dest)=\n\tpcm_clearmem(dest,strbuffer.bytes)\nend\n\nexport proc gs_free(ref strbuffer dest)=\n\tif dest.allocated then\n\t\tpcm_free(dest.strptr,dest.allocated)\n\tfi\nend\n\nexport proc gs_str(ref strbuffer dest,ichar s)=\n\tstrbuffer_add(dest,s)\nend\n\nexport proc gs_char(ref strbuffer dest,int c)=\n\tarray [16]char s\n\n\ts[1]:=c\n\ts[2]:=0\n\n\tstrbuffer_add(dest,&.s,1)\nend\n\nexport proc gs_strn(ref strbuffer dest,ichar s,int length)=\n\tstrbuffer_add(dest,s,length)\nend\n\nexport proc gs_strvar(ref strbuffer dest,s)=\n\tstrbuffer_add(dest,s.strptr)\nend\n\nexport proc gs_strint(ref strbuffer dest,int64 a)=\n\tstrbuffer_add(dest,strint(a))\nend\n\nexport proc gs_strln(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_line(dest)\nend\n\nexport proc gs_strsp(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_str(dest,\" \")\nend\n\nexport proc gs_line(ref strbuffer dest)=\n\tstrbuffer_add(dest,\"\\w\")\nend\n\nexport function gs_getcol(ref strbuffer dest)int=\n\treturn dest.length\nend\n\nexport proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')=\n\tint col,i,n,slen\n\tarray [2560]char str\n\tcol:=dest.length\n\tstrcpy(&.str,s)\n\tslen:=strlen(s)\n\tn:=w-slen\n\tif n>0 then\n\t\tfor i:=1 to n do\n\t\t\tstr[slen+i]:=padch\n\t\tod\n\t\tstr[slen+n+1]:=0\n\tfi\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')=\n\tgs_leftstr(dest,strint(a),w,padch)\nend\n\nexport proc gs_padto(ref strbuffer dest,int col, ch=' ')=\n\tint n\n\tarray [2560]char str\n\n\tn:=col-dest.length\n\tif n<=0 then return fi\n\tfor i:=1 to n do\n\t\tstr[i]:=ch\n\tod\n\tstr[n+1]:=0\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_println(ref strbuffer dest,filehandle f=nil)=\n\tif dest.length=0 then return fi\n\t(dest.strptr+dest.length)^:=0\n\n\tif f=nil then\n!\t\tprintln dest.strptr,,\"\\c\"\n\t\tprintln dest.strptr\n\telse\n!\t\tprintln @f,dest.strptr,,\"\\c\"\n\t\tprintln @f,dest.strptr\n\tfi\nend\n\nexport function nextcmdparamnew(int &paramno, ichar &name, &value, ichar defext=nil)int=\n\tstatic int infile=0\n\tstatic ichar filestart=nil\n\tstatic ichar fileptr=nil\n\tstatic byte colonseen=0\n\tref char q\n\tichar item,fileext\n\tichar rest\n\tint length\n\tstatic [300]char str\n\n\treenter::\n\tvalue:=nil\n\tname:=nil\n\n\tif infile then\n\t\tif readnextfileitem(fileptr,item)=0 then\t\t!eof\n\t\t\tfree(filestart)\t\t\t\t\t\t\t\t!file allocated via malloc\n\t\t\tinfile:=0\n\t\t\tgoto reenter\n\t\tfi\n\telse\n\t\tif paramno>ncmdparams then\n\t\t\treturn pm_end\n\t\tfi\n\t\titem:=cmdparams[paramno]\n\t\t++paramno\n\n\t\tlength:=strlen(item)\n\n\t\tif item^='@' then\t\t!@ file\n!\t\t\tfilestart:=fileptr:=cast(readfile(item+1))\n!\t\t\tif filestart=nil then\n!\t\t\t\tprintln \"Can't open\",item\n!\t\t\t\tstop 7\n!\t\t\tfi\n\t\t\tinfile:=1\n\t\t\tgoto reenter\n\t\tfi\n\n\t\tif item^=':' then\n\t\t\tcolonseen:=1\n\t\t\treturn pm_colon\n\t\tfi\n\tfi\n\n\tvalue:=nil\n\tif item^='-' then\n\t\tname:=item+(colonseen|0|1)\n\t\tq:=strchr(item,':')\n\t\tif not q then\n\t\t\tq:=strchr(item,'=')\n\t\tfi\n\t\tif q then\n\t\t\tvalue:=q+1\n\t\t\tq^:=0\n\t\tfi\n\t\treturn (colonseen|pm_extra|pm_option)\n\tfi\n\n\tfileext:=extractext(item,0)\n\tname:=item\n\n\tif fileext^=0 then\t\t\t\t\t\t\t!no extension\n\t\tstrcpy(&.str,name)\n\t\tif defext and not colonseen then\n\t\t\tname:=addext(&.str,defext)\t\t\t\t!try .c\n\t\tfi\n!\telsif eqstring(fileext,\"dll\") then\n\telsif eqstring(fileext,\"dll\") or eqstring(fileext,\"mcx\") then\n\t\treturn (colonseen|pm_extra|pm_libfile)\n\tfi\n\treturn (colonseen|pm_extra|pm_sourcefile)\nend\n\nfunction readnextfileitem(ichar &fileptr,&item)int=\n\tref char p,pstart,pend\n\tint n\n\tstatic [256]char str\n\n\tp:=fileptr\n\n\treenter::\n\tdo\n\t\tcase p^\n\t\twhen ' ','\\t',13,10 then\t!skip white space\n\t\t\t++p\n\t\twhen 26,0 then\t\t\t\t!eof\n\t\t\treturn 0\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\n\tcase p^\n\twhen '!', '#' then\t\t\t!comment\n\t\t++p\n\t\tdocase p++^\n\t\twhen 10 then\n\t\t\tgoto reenter\n\t\twhen 26,0 then\n\t\t\tfileptr:=p-1\n\t\t\treturn 0\n\t\telse\n\n\t\tenddocase\n\tesac\n\n\n\tcase p^\n\twhen '\"' then\t\t\t\t!read until closing \"\n\t\tpstart:=++p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tprintln \"Unexpected EOF in @file\"\n\t\t\t\tstop 8\n\t\t\twhen '\"' then\n\t\t\t\tpend:=p++\n\t\t\t\tif p^=',' then ++p fi\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\telse\n\t\tpstart:=p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tpend:=p\n\t\t\t\texit\n\t\t\twhen ' ','\\t',',',13,10 then\n\t\t\t\tpend:=p++\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\tesac\n\n\tn:=pend-pstart\n\tif n>=str.len then\n\t\tprintln \"@file item too long\"\n\t\tstop 9\n\tfi\n\tmemcpy(&.str,pstart,n)\n\tstr[n+1]:=0\n\titem:=&.str\n\tfileptr:=p\n\n\treturn 1\nend\n\nexport proc ipadstr(ref char s,int width,ref char padchar=\" \")=\n\tint n\n\n\tn:=strlen(s)\n\tto width-n do\n\t\tstrcat(s,padchar)\n\tod\nend\n\nexport function padstr(ref char s,int width,ref char padchar=\" \")ichar=\n\tstatic [256]char str\n\n\tstrcpy(&.str,s)\n\tipadstr(&.str,width,padchar)\n\treturn &.str\nend\n\nexport function chr(int c)ichar=\n\tstatic [8]char str\n\n\tstr[1]:=c\n\tstr[2]:=0\n\treturn &.str\nend\n\nexport function cmpstring(ichar s,t)int=\n\tint res\n\tif (res:=strcmp(s,t))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function cmpstringn(ichar s,t,int n)int=\n\tint res\n\tif (res:=strncmp(s,t,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqstring(ichar s,t)int=\n\treturn strcmp(s,t)=0\nend\n\nexport function cmpbytes(ref void p,q,int n)int=\n\tint res\n\tif (res:=memcmp(p,q,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqbytes(ref void p,q,int n)int=\n\treturn memcmp(p,q,n)=0\nend\n\nexport proc mseed(word64 a,b=0)=\n\tseed[1]:=a\n\tif b then\n\t\tseed[2]:=b\n\telse\n\t\tseed[2] ixor:=a\n\tfi\nend\n\nexport function mrandom:word =\n!return pure 64-bit word value, 0 to 2**64-1\n!(cast result for signed value)\n!\tword64 x,y\n\tint x,y\n\tx:=seed[1]\n\ty:=seed[2]\n\tseed[1]:=y\n\tx ixor:=(x<<23)\n\tseed[2]:= x ixor y ixor (x>>17) ixor (y>>26)\n\treturn seed[2]+y\nend\n\nexport function mrandomp:int =\n!pure 64-bit int value, positive only, 0 to 2**63-1\n\treturn mrandom() iand 0x7FFF'FFFF'FFFF'FFFF\nend\n\nexport function mrandomint(int n)int=\n!positive random int value from 0 to n-1\n\treturn mrandomp() rem n\nend\n\nexport function mrandomrange(int a,b)int=\n!random int value from a to b inclusive\n!span extent must be 1 to 2**63-1\n\tint span\n\tspan:=b-a+1\n\tif span<=0 then\n\t\treturn 0\n\tfi\n\treturn (mrandomp() rem span)+a\nend\n\nexport function mrandomreal:real x=\n!positive random real value from 0 to just under (but not including) 1.0\n\trepeat x:=mrandomp()/9223372036854775808.0 until x<>1.0\n\treturn x\nend\n\nexport function mrandomreal1:real=\n!positive random real value from 0 to 1.0 inclusive\n\treturn mrandomp()/9223372036854775807\nend\n\nexport function checkpackfile:ref byte=\n!find out if this executable contains extra packed files\n!return 1 or 0\n\n\tint a,offset,i,size\n\tarray [100]char name\n\tarray [300]char exefile\n\tref byte packexeptr\t\t\t!for embedded pack files, contains pointer to in-memory version of this .exe file plus extras; else nil\n\tint packexesize\t\t\t\t!byte size\n\tref char packfilename\n\tint packfilesize\n\tref byte packfileptr\n\n!macro getfileint(data,offset)=(ref int32(data+offset))^\n\tmacro getfileint(data,offset)=cast(data+offset,ref int32)^\n\n\tstrcpy(&exefile[1],os_gethostname())\n\tprintln \"Attempting to open\",&exefile\n\tpackexeptr:=readfile(&exefile[1])\n\n\tif not packexeptr then\n\t\tcpl \"Can't open\",&exefile,&packexeptr\n\t\tstop\n\tfi\n\n\tpackexesize:=rfsize\n\tcpl \"File read OK. Size\",packexesize\n\n\ta:=getfileint(packexeptr,packexesize-int32.bytes)\n\tif a<>'PCAK' then\n\t\tfree(packexeptr)\n\t\tpackfileptr:=nil\n\t\treturn nil\n\tfi\n\n\toffset:=getfileint(packexeptr,packexesize-int32.bytes*2)\n\n\tpackfilename:=cast(packexeptr+offset)\n\toffset+:=strlen(packfilename)+1\n\tpackfilesize:=getfileint(packexeptr,offset)\n\tpackfileptr:=packexeptr+offset+int32.bytes\n\n\treturn packfileptr\nend\n\n!export function pcm_allocx:ref void =\n!\tconst n=32\n!\tref word p\n!\n!\tallocbytes:=32\n!\n!\tif p:=ref word(freelist[2]) then\t\t!Items of this block size available\n!\t\tfreelist[2]:=ref word(int((freelist[2])^))\n!\n!\telse\n!\n!!No items in freelists: allocate new space in this heap block\n!\t\tp:=cast(pcheapptr)\t\t\t\t!Create item at start of remaining pool in heap block\n!\t\tpcheapptr+:=32\t\t\t!Shrink remaining pool\n!\n!\t\tif pcheapptr>=pcheapend then\t\t!Overflows?\n!\t\t\tp:=pcm_newblock(32)\t\t!Create new heap block, and allocate from start of that\n!\t\tfi\n!\n!\t\tp^:=0\n!\t\t(p+1)^:=0\n!\t\t(p+2)^:=0\n!\t\t(p+3)^:=0\n!\n!\t\treturn p\n!\tfi\n!end\n\nexport function readline:ichar=\n\treadln\n\treturn rd_buffer\nend\n\n!export function stralloc(ref void p)ichar=\n!\treturn strint(int(ref byte(p)-allocbase))\n!end\n\nexport function findfunction(ichar name)ref void=\n\tfor i to $getnprocs() do\n\t\tif eqstring($getprocname(i),name) then\n\t\t\treturn $getprocaddr(i)\n\t\tfi\n\tod\n\treturn nil\nend\n\nexport function roundtoblock(int n,align)int=\n!round up n until it is a multiple of filealign (which is a power of two)\n!return aligned value. Returns original if already aligned\n\tif n iand (align-1)=0 then return n fi\n\treturn n+(align-(n iand (align-1)))\nend\n\n",
(byte*)"export type filehandle=ref void\n\nimportdll $cstd=\n\tfunc  malloc\t\t(word64)ref void\n\tfunc  realloc\t(ref void, word)ref void\n\tproc free\t\t(ref void)\n\tproc memset\t\t(ref void, int32, word)\n\tproc memcpy\t\t(ref void, ref void, word)\n\tproc memmove\t\t(ref void, ref void, word)\n\tfunc  clock\t\t:int32\n\tfunc  ftell\t\t(filehandle)int32\n\tfunc  fseek\t\t(filehandle, int32, int32)int32\n\tfunc  fread\t\t(ref void, word, word, filehandle)word\n\tfunc  fwrite\t\t(ref void, word, word, filehandle)word\n\tfunc  getc\t\t(filehandle)int32\n\tfunc  ungetc\t\t(int32, filehandle)int32\n\tfunc  fopen\t\t(ichar a, b=\"rb\")filehandle\n\tfunc  fclose\t\t(filehandle)int32\n\tfunc  fgets\t\t(ichar, int, filehandle)ichar\n\tfunc  remove\t\t(ichar)int32\n\tfunc  rename\t\t(ichar, ichar)int32\n\tfunc  getchar\t:int32\n\tproc putchar\t(int32)\n\tproc setbuf\t\t(filehandle, ref byte)\n\n\tfunc  strlen\t\t(ichar)int\n\tfunc  strcpy\t\t(ichar, ichar)ichar\n\tfunc  strcmp\t\t(ichar, ichar)int32\n\tfunc  strncmp\t(ichar, ichar, word)int32\n\tfunc  strncpy\t(ichar, ichar, word)word\n\tfunc  memcmp\t\t(ref void, ref void, word)int32\n\tfunc  strcat\t\t(ichar, ichar)ichar\n\tfunc  tolower\t(int32)int32\n\tfunc  toupper\t(int32)int32\n\tfunc  isalpha\t(int32)int32\n\tfunc  isupper\t(int32)int32\n\tfunc  islower\t(int32)int32\n\tfunc  isalnum\t(int32)int32\n\tfunc  isspace\t(int32)int32\n\tfunc  strstr\t\t(ichar, ichar)ichar\n\tfunc  atol\t\t(ichar)int\n\tfunc  atoi\t\t(ichar)int32\n!\tfunc  strtod\t\t(ichar,ref ref char)real64\n\tfunc  strtod\t\t(ichar,ref ref char)real64\n\tfunc  _strdup\t(ichar)ichar\n\n\tfunc  puts\t\t(ichar)int32\n\tfunc  printf\t\t(ichar, ...)int32\n\n\tfunc  sprintf\t(ichar, ichar, ...)int32\n\n\tfunc  sscanf\t\t(ichar, ichar, ...)int32\n\tfunc  scanf\t\t(ichar, ...)int32\n\n\tfunc  rand\t\t:int32\n\tproc srand\t\t(word32)\n\tfunc  system\t\t(ichar)int32\n\n\tfunc  fgetc\t\t(filehandle)int32\n\tfunc  fputc\t\t(int32,  filehandle)int32\n\tfunc  fprintf\t(filehandle, ichar, ...)int32\n\tfunc  fputs\t\t(ichar,  filehandle)int32\n\tfunc  feof\t\t(filehandle)int32\n\tfunc  getch\t\t:int32\n\tfunc  _getch\t\t:int32\n\tfunc  kbhit\t\t:int32\n\tfunc  _mkdir\t\t(ichar)int32\n\tfunc  mkdir\t\t(ichar)int32\n\tfunc  strchr\t\t(ichar,int32)ichar\n\n\tfunc  _setmode\t(int32,int32)int32\n\n\tproc _exit\t\t(int32)\n\tproc \"exit\"\t\t(int32)\n!\tproc `exit\t\t(int32)\n\tfunc  pow\t\t(real,real)real\n\n\tfunc  `sin \t\t(real)real\n\tfunc  `cos\t\t(real)real\n\tfunc  `tan\t\t(real)real\n\tfunc  `asin\t\t(real)real\n\tfunc  `acos\t\t(real)real\n\tfunc  `atan \t\t(real)real\n\tfunc  `log\t\t(real)real\n\tfunc  `log10\t\t(real)real\n\tfunc  `exp\t\t(real)real\n\tfunc  `floor\t\t(real)real\n\tfunc  `ceil\t\t(real)real\n\n\tfunc  `llabs\t(i64)i64\n\n\tproc  qsort   \t(ref void, word64, word64, ref proc)\n\tproc  sleep\t\t(word32)\n\nend\n\nexport macro strdup=_strdup\n\nimportdll $cstdextra=\n\tfunc  __getmainargs(ref int32, ref void, ref void, int, ref void)int32\nend\n\nexport const c_eof\t\t=-1\nexport const seek_set\t= 0\nexport const seek_curr\t= 1\nexport const seek_end\t= 2\n",
(byte*)"const wm_destroy=2\n\ntype wt_word\t= word16\ntype wt_wordpm\t= word32\ntype wt_bool\t= word32\ntype wt_dword\t= word32\ntype wt_wchar\t= word16\ntype wt_wcharpm\t= word32\ntype wt_char\t= byte\ntype wt_ichar\t= ref char\ntype wt_ptr\t\t= ref void\ntype wt_wndproc\t= ref proc\ntype wt_handle\t= ref void\ntype wt_int\t\t= int32\ntype wt_uint\t= word32\ntype wt_long\t= int32\ntype wt_wparam\t= word\ntype wt_lparam\t= word\ntype wt_point\t= rpoint\n\nexport record rsystemtime =\n\twt_word year\n\twt_word month\n\twt_word dayofweek\n\twt_word day\n\twt_word hour\n\twt_word minute\n\twt_word second\n\twt_word milliseconds\nend\n\nimportdll $windowsdlls=\n!\twindows function  \"VirtualAlloc\"(wt_ptr, dint,wt_dword,wt_dword)wt_ptr\n\twindows function  \"GetStdHandle\"(wt_dword)wt_handle\n\twindows function  \"GetConsoleScreenBufferInfo\"(wt_handle,wt_ptr)int\n\twindows function  \"SetConsoleCtrlHandler\"(wt_wndproc,int)int\n\twindows function  \"SetConsoleMode\"(wt_handle,wt_dword)int\n\twindows function  \"CreateProcessA\"(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,\n\t\t\t\t\t\twt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int\n\twindows function  \"GetLastError\":wt_dword\n\twindows function  \"WaitForSingleObject\"(wt_handle,wt_dword)wt_dword\n\twindows function  \"GetExitCodeProcess\"(wt_handle,wt_ptr)int\n\twindows function  \"CloseHandle\"(wt_handle)int\n\twindows function  \"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)int\n\twindows function  \"FlushConsoleInputBuffer\"(wt_handle)int\n\twindows function  \"LoadLibraryA\"(wt_ichar)wt_handle\n!\twindows function  \"GetProcAddress\"(wt_handle,wt_ichar)wt_wndproc\n\twindows function  \"GetProcAddress\"(wt_handle,wt_ichar)ref void\n\twindows function  \"LoadCursorA\"(wt_handle,wt_ichar)wt_handle\n\twindows function  \"RegisterClassExA\"(wt_ptr)wt_wordpm\n\twindows function  \"DefWindowProcA\"(wt_handle,wt_uint,wt_wparam,wt_lparam)int\n\twindows function  \"ReadConsoleInputA\"(wt_handle,wt_ptr,wt_dword,wt_ptr)int\n\twindows procedure \"Sleep\"(wt_dword)\n\twindows function  \"GetModuleFileNameA\"(wt_handle,wt_ichar,wt_dword)wt_dword\n\n\twindows procedure \"ExitProcess\"(wt_uint)\n\twindows proc\t \"PostQuitMessage\"(wt_int)\n\n\twindows proc\t \"MessageBoxA\"(wt_int x=0,wt_ichar message, caption=\"Caption\",wt_int y=0)\n\n\twindows function  \"QueryPerformanceCounter\"(ref int64)wt_bool\n\twindows function  \"QueryPerformanceFrequency\"(ref int64)wt_bool\n\n\twindows function  \"CreateFileA\"(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle\n\twindows function  \"GetFileTime\"(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool\n\n\twindows procedure \"GetSystemTime\"(ref rsystemtime)\n\twindows procedure \"GetLocalTime\"(ref rsystemtime)\n\n\twindows function  \"GetTickCount64\":u64\n\twindows function  \"PeekMessageA\"\t\t(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool\n\n\twindows function  \"GetCommandLineA\":ichar\n\n\twindows function  \"VirtualAlloc\" (ref void, wt_dword, wt_dword, wt_dword)ref void\n\twindows function  \"VirtualProtect\" (ref void, wt_dword, wt_dword, ref wt_dword)wt_bool\n\nend\n\nrecord input_record = $caligned\n\twt_word\teventtype\n!\tword16\tpadding\n\t\twt_bool\tkeydown\t\t\t!key event record (was inside 'Event' union in win32)\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nrecord rspoint=(int16 x,y)\n\nrecord rsrect=\n\tint16 leftx,top,rightx,bottom\nend\n\nglobal record rpoint =\n\twt_long x,y\nend\n\nrecord rconsole=\n\trspoint size,pos\n\tword16 attributes\n\trsrect window\n\trspoint maxwindowsize\nend\n\nrecord rstartupinfo =\n\twt_dword\tsize\n\tword32 dummy1\n\twt_ichar\treserved\n\twt_ichar\tdesktop\n\twt_ichar\ttitle\n\twt_dword\tx\n\twt_dword\ty\n\twt_dword\txsize\n\twt_dword\tysize\n\twt_dword\txcountchars\n\twt_dword\tycountchars\n\twt_dword\tfillattribute\n\twt_dword\tflags\n\twt_word\t\tshowwindow\n\twt_word\t\treserved2\n\tword32 dummy2\n\twt_ptr\t\treserved4\n\twt_handle\tstdinput\n\twt_handle\tstdoutput\n\twt_handle\tstderror\nend\n\nrecord rprocess_information =\n\twt_handle process\n\twt_handle thread\n\twt_dword processid\n\twt_dword threadid\nend\n\nrecord rwndclassex =\n\twt_uint\t\tsize\n\twt_uint\t\tstyle\n\twt_wndproc\twndproc\n\twt_int\t\tclsextra\n\twt_int\t\twndextra\n\twt_handle\tinstance\n\twt_handle\ticon\n\twt_handle\tcursor\n\twt_handle\tbackground\n\twt_ichar\tmenuname\n\twt_ichar\tclassname\n\twt_handle\ticonsm\nend\n\nglobal record rmsg =\n\twt_handle\thwnd\n\twt_uint\t\tmessage\n\tword32\t\tdummy1\n\twt_wparam\twParam\n\twt_lparam\tlParam\n\twt_dword\ttime\n\tword32\t\tdummy2\n\twt_point\tpt\nend\n\nconst NORMAL_PRIORITY_CLASS=32\nconst CREATE_NEW_CONSOLE=16\nconst DETACHED_PROCESS=16\n\nconst MEM_COMMIT\t\t\t\t= 4096\nconst MEM_RESERVE\t\t\t\t= 8192\nconst PAGE_EXECUTE\t\t\t\t= 16\nconst PAGE_EXECUTE_READ\t\t\t= 32\nconst PAGE_EXECUTE_READWRITE\t= 64\nconst PAGE_NOACCESS\t\t\t\t= 1\n\n\nwt_handle hconsole, hconsolein\n\ninput_record lastkey, pendkey\nint keypending\t\t\t!whether pendkey contains a new key event detected by flushkbd\n\nref function (ref void)int wndproc_callbackfn=nil\t!windows call-back: address of handler\n\nint init_flag=0\n\nexport proc os_init=\n\tint i,count\n\trconsole info\n\n!general initialisation\n\thconsole:=GetStdHandle(u32(-11))\n\thconsolein:=GetStdHandle(u32(-10))\n\n\tlastkey.repeatcount:=0\n\tkeypending:=0\n\n\tSetConsoleCtrlHandler(nil,1)\n\n\tSetConsoleMode(hconsole,1 ior 2)\n\n\tinit_flag:=1\n\nend\n\nexport function  os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\n\twt_dword exitcode\n\tint status\n\tint cflags:=0\n\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tswitch newconsole\n\twhen 0 then cflags := NORMAL_PRIORITY_CLASS\n\twhen 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE\n\twhen 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS\n\tendswitch\n\n\tsi.size := rstartupinfo.bytes\n\n\tstatus:=CreateProcessA(\n\t\tnil,\n\t\tcmdline,\n\t\tnil,\n\n\t\tnil,\n\t\t1,\n\t\tcflags,\n\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tif status=0 then\t\t!fails\n\t\tstatus:=GetLastError()\n\t\tprintf(\"Winexec error: %lld\\n\",status)\n\t\treturn -1\n\tfi\n\n\tWaitForSingleObject(xpi.process, 0xFFFF'FFFF)\n\tGetExitCodeProcess(xpi.process,&exitcode)\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn exitcode\nend\n\nexport function  os_execcmd(ichar cmdline, int newconsole=0)int =\n\twt_dword exitcode\n\tint i,j,k\n\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tsi.size := rstartupinfo.bytes\n\n\tCreateProcessA( nil,\n\t\tcmdline,\n\t\tnil,\n\t\tnil,\n\t\t1,\n\t\tNORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn 1\nend\n\nexport function  os_getch:int=\n\tint k\n\n\tk:=os_getchx() iand 255\n\n\treturn k\nend\n\nexport function  os_kbhit:int=\n\twt_dword count\n\n\tunless init_flag then os_init() end\n\n\tGetNumberOfConsoleInputEvents(hconsolein,&count)\n\treturn count>1\nend\n\nexport function  os_getdllinst(ichar name)u64=\n\twt_handle hinst\n\n\thinst:=LoadLibraryA(name)\n\treturn cast(hinst)\nend\n\nexport function  os_getdllprocaddr(int hinst,ichar name)ref void=\n\treturn GetProcAddress(cast(hinst),name)\nend\n\nexport proc os_initwindows=\n\tos_init()\n!\tos_gxregisterclass(\"m2022\")\n\tos_gxregisterclass(\"pcc001\")\nend\n\nexport proc os_gxregisterclass(ichar classname)=\n\tconst idcarrow=32512\n\trwndclassex r\n\tstatic byte registered\n\n\tif registered then\n\t\treturn\n\tfi\n\n\tclear r\n\n\tr.size:=r.bytes\n\tr.style:=8 ior 32\t\t!CS_DBLCLKS | CS_OWNDC\n\tr.wndproc:=cast(&mainwndproc)\n\tr.instance:=nil\n\n\tr.icon:=nil\t\t!loadicon(proginstance,\"SCW32\")\n\tr.cursor:=LoadCursorA(nil,ref void(idcarrow))\t\t!IDC_ARROW)\n\tr.background:=cast(15+1)\t\t\t\t\t!COLOR_BTNFACE+1\n\tr.menuname:=nil\n\tr.classname:=classname\n\tr.iconsm:=nil\t!loadicon(proginstance,\"SCW32\")\n\n\tif RegisterClassExA(&r)=0 then\n\t\tprintf(\"Regclass error: %lld %lld\\n\",classname,GetLastError())\n\t\tstop 1\n\tend\n\tregistered:=1\nend\n\nglobal callback function  mainwndproc (\n\t\twt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)int=\n\trmsg m\n\tint i,result\n\tint l\n\tstatic int count=0\n\n!CPL \"MAINWNDPROC\",MESSAGE\n!RETURN 0\n\tm.hwnd:=hwnd\n\tm.message:=message\n\tm.wParam:=wParam\n\tm.lParam:=lParam\n\tm.pt.x:=0\n\tm.pt.y:=0\n\t\n\tif (wndproc_callbackfn) then\n\t\tresult:=(wndproc_callbackfn^)(&m)\n\telse\n\t\tresult:=0\n\tfi\n\n\tif m.message=wm_destroy then\n\t\treturn 0\n\tfi\n\n\tif not result then\n\t\treturn DefWindowProcA(hwnd,message,wParam,lParam)\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport proc os_setmesshandler(ref void addr)=\n\twndproc_callbackfn:=addr\nend\n\nexport function  os_getchx:int=\n!Q! function  os_getchx_c:int\n!return a 32-bit value containing:\n! 15..B0:\tchar code\n! 23..16\tvirtual keycode\n! 31..24\tshift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)\n\tconst rightaltmask\t= 1\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\tint count\n\tint charcode,keyshift,keycode\n\tint altdown,ctrldown,shiftdown,capslock\n\n\tunless init_flag then os_init() end\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\tReadConsoleInputA(hconsolein,&lastkey,1,&count)\n\t\t\tuntil (lastkey.eventtype=1 and lastkey.keydown=1)\n\t\tfi\n\tfi\n\n!set shift flags\n\n\taltdown\t\t:= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)\n\tctrldown\t:= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)\n\tshiftdown\t:= ((lastkey.controlkeystate iand shiftmask)|1|0)\n\tcapslock\t:= ((lastkey.controlkeystate iand capsmask)|1|0)\n\n\t--lastkey.repeatcount\t\t!count this key out\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n\tif charcode<0 then\n\t\tif charcode<-128 then\n\t\t\tcharcode:=0\n\t\telse\n\t\t\tcharcode+:=256\n\t\tfi\n\tfi\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!....\n\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\treturn keyshift<<24 ior keycode<<16 ior charcode\nend\n\nexport function  os_getos=>ichar=\n\tif $targetbits=32 then\n\t\treturn \"W32\"\n\telse\n\t\treturn \"W64\"\n\tfi\nend\n\nexport function  os_gethostsize=>int=\n\treturn $targetbits\nend\n\nexport function  os_shellexec(ichar opc, file)int=\n\treturn system(file)\nend\n\nexport proc  os_sleep(int a)=\n\tSleep(a)\nend\n\nexport function  os_getstdin:filehandle =\n\treturn fopen(\"con\",\"rb\")\nend\n\nexport function  os_getstdout:filehandle =\n\treturn fopen(\"con\",\"wb\")\nend\n\nexport function  os_gethostname:ichar=\n\tstatic [300]char name\n\tstatic int n\n\n\tGetModuleFileNameA(nil,&.name,name.bytes)\n\treturn &.name\nend\n\nexport function  os_getmpath:ichar=\n\treturn F\"C:\\m\\\"\nend\n\n!export proc os_exitprocess(int x)=\n!\tstop x\n!end\n\nexport function  os_clock:int64=\n\treturn clock()\nend\n\nexport function  os_ticks:int64=\n\treturn GetTickCount64()\nend\n\nexport function  os_iswindows:int=\n\treturn 1\nend\n\nexport proc os_getsystime(ref rsystemtime tm)=\n\tGetLocalTime(tm)\nend\n\nexport proc os_peek=\n\tint ticks\n\tstatic int lastticks\n\tarray [100]byte m\n\tticks:=GetTickCount64()\n\tif ticks-lastticks>=1000 then\n\t\tlastticks:=ticks\n\t\tPeekMessageA(&m,nil,0,0,0)\n\tfi\nend\n\nexport function  os_allocexecmem(int n)ref byte=\n\tref byte p\n\tu32 oldprot\n\tint status\n\n\tp := VirtualAlloc(nil, n, MEM_RESERVE ior MEM_COMMIT, PAGE_NOACCESS);\n\tif p = nil then return nil fi\n\n\tstatus := VirtualProtect(p, n, PAGE_EXECUTE_READWRITE, &oldprot);\n\tif status = 0 then return nil fi\n\n\treturn p\nend\n\nproc start=\nend\n\n",(byte*)"export function os_calldllfunction(ref proc fnaddr,\n\t\tint retcode, nargs, ref[]i64 args, ref[]byte argcodes)word64 =\n\tword64 a\n\treal64 x\n\tint nextra, pushedbytes\n\n\tnextra:=0\n\n\tif nargs<4 then\n\t\tnextra:=4-nargs\t\t\t!need at least 4 slots for shadow space\n\telsif nargs.odd then\t\t!need one more for a 16-byte-aligned stack\n\t\tnextra:=1\n\tfi\n\n\tpushedbytes:=(nextra+nargs)*8\n\n\tto nextra do\n\t\tasm push 0\n\tod\n\n\tfor i:=nargs downto 1 do\n\t\ta:=args^[i]\t\t\t\t\t!get generic 64-bit value to push\n\t\tasm push word64 [a]\n\tod\n\n!load first 4 args to registers; this first version will blindly load 4 args\n!(even if there are less) to both integer and xmm registers. Should be int/pointer\n!types to integer regs; float types to xmm; and variadic to both\n!This requires the flags in argcodes[], currently not used\n\n\tassem\n\t\tmov D10,[Dstack]\n\t\tmovq XMM0,[Dstack]\n\t\tmov D11,[Dstack+8]\n\t\tmovq XMM1,[Dstack+8]\n\t\tmov D12,[Dstack+16]\n\t\tmovq XMM2,[Dstack+16]\n\t\tmov D13,[Dstack+24]\n\t\tmovq XMM3,[Dstack+24]\n\tend\n\n\tif retcode='I' then\n\t\ta:=((ref function:int64(fnaddr))^())\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn a\n\telse\n\t\tx:=((ref function:real64(fnaddr))^())\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn word64@(x)\n\tfi\nend\t\n\nglobal function os_pushargs(ref[]word64 args, int nargs, nextra,\n\t\t\t\t\tref proc fnaddr, int isfloat)word64=\n!implements central part of 'callapplproc' which needs to be in asm\n\tword64 a\n\treal64 x\n\n\tto nextra do\n\t\tasm\tpush 0\n\tend\n\n\tfor i to nargs do\n\t\ta:=args[i]\n\t\tasm push word64 [a]\n\tod\n\n\tif isfloat then\n\t\tx:=((ref function:real64(fnaddr))^())\n\t\ta:=int64@(x)\n\telse\n\t\ta:=((ref function:int64(fnaddr))^())\n\tfi\n\n\treturn a\nend\n"};
static byte mm_libsources$syslibfileno[5];
static u8 *  mm_modules$headerpathx = (byte*)"";
static u8 *  mm_modules$altpathx = (byte*)"";
static u8 *  mm_modules$importpathx = (byte*)"";
static u8 *  mm_modules$subprogpath = (byte*)"";
static i64 mm_modules$dirpos;
static i64 mm_modules$issyslib;
static u8 *  mm_modules$headervars[11];
static struct mm_decls$strec *  mm_name$currstproc;
static i64 mm_name$allowmodname = (i64)0;
static i64 mm_name$noexpand;
static i64 mm_name$noassem;
static i64 mm_name$macrolevels;
static struct mm_decls$strec *  mm_name$macroparams[50];
static struct mm_decls$strec *  mm_name$macroparamsgen[50];
static struct mm_decls$unitrec *  mm_name$macroargs[50];
static i64 mm_name$nmacroparams;
static i64 mm_name$nmacroargs;
static i64 mm_parse$intabledata = (i64)0;
static i64 mm_parse$inreadprint = (i64)0;
static i64 mm_parse$inparamlist = (i64)0;
static i64 mm_parse$inrecordbody = (i64)0;
static i64 mm_parse$inimportmodule = (i64)0;
static i64 mm_parse$labelseen = (i64)0;
static u8 *  mm_parse$tabledataname = 0;
static struct mm_decls$strec *  mm_parse$procstack[10];
static i64 mm_parse$nprocstack = (i64)0;
static struct mm_decls$uflagsrec mm_parse$unionstring;
static struct mm_decls$uflagsrec mm_parse$unionpend;
static struct mm_decls$strec *  mm_parse$unionlastvar = 0;
static struct mm_decls$strec *  mm_parse$dretvar;
static i64 mm_parse$try_level = (i64)0;
static i64 mm_parse$varattribs = (i64)0;
static struct mm_decls$unitrec *  mm_parse$dollarstack[10];
static i64 mm_parse$ndollar = (i64)0;
static i64 mm_parse$insiderecord = (i64)0;
static i64 mm_parse$insidedllimport = (i64)0;
static struct mm_decls$strec *  mm_parse$forindexvars[10];
static i64 mm_parse$nforloops;
static void *  mm_parse$docfile;
static byte mm_support$bytemasks[8] = {(u8)1u,(u8)2u,(u8)4u,(u8)8u,(u8)16u,(u8)32u,(u8)64u,(u8)128u};
static u8 *  mm_tables$stdnames[30] = {
    (byte*)"void",
    (byte*)"c64",
    (byte*)"u64",
    (byte*)"i64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"bool64",
    (byte*)"ref",
    (byte*)"rec",
    (byte*)"range",
    (byte*)"array",
    (byte*)"slice",
    (byte*)"c8",
    (byte*)"b8",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"u8",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"ichar",
    (byte*)"auto",
    (byte*)"any",
    (byte*)"proc",
    (byte*)"label",
    (byte*)"type",
    (byte*)"bitfl",
    (byte*)"tuple",
    (byte*)"pend",
    (byte*)"last "
};
static byte mm_tables$stdbits[30] = {
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)32u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)128u,
    (u8)0u,
    (u8)128u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)8u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte mm_tables$stdcat[30] = {
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)5u,
    (u8)5u,
    (u8)5u,
    (u8)5u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static u8 *  mm_tables$catnames[6] = {(byte*)"voidcat",(byte*)"d64cat",(byte*)"x32cat",(byte*)"x64cat",(byte*)"shortcat",(byte*)"blockcat"};
static i64 mm_tables$trefproc;
static i64 mm_tables$treflabel;
static u8 *  mm_tables$sysfnnames[36] = {
    (byte*)"sf_init",
    (byte*)"sf_print_startfile",
    (byte*)"sf_print_startstr",
    (byte*)"sf_print_startptr",
    (byte*)"sf_print_startcon",
    (byte*)"sf_print_setfmt",
    (byte*)"sf_print_nogap",
    (byte*)"sf_print_space",
    (byte*)"sf_print_i64",
    (byte*)"sf_print_i64_nf",
    (byte*)"sf_print_u64",
    (byte*)"sf_print_r64",
    (byte*)"sf_print_r32",
    (byte*)"sf_print_str",
    (byte*)"sf_print_str_nf",
    (byte*)"sf_print_strsl",
    (byte*)"sf_print_ptr",
    (byte*)"sf_print_ptr_nf",
    (byte*)"sf_print_c8",
    (byte*)"sf_print_bool",
    (byte*)"sf_print_newline",
    (byte*)"sf_print_end",
    (byte*)"sf_read_i64",
    (byte*)"sf_read_r64",
    (byte*)"sf_read_str",
    (byte*)"sf_read_fileline",
    (byte*)"sf_read_strline",
    (byte*)"sf_read_conline",
    (byte*)"sf_get_nprocs",
    (byte*)"sf_get_procname",
    (byte*)"sf_get_procaddr",
    (byte*)"sf_gettttable",
    (byte*)"sf_getsttable",
    (byte*)"sf_getfftable",
    (byte*)"sf_power_i64",
    (byte*)"sf_unimpl"
};
static byte mm_tables$sysfnparams[36] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte mm_tables$sysfnres[36] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u
};
static struct mm_decls$strec *  mm_tables$sysfnhandlers[36];
static i64 mm_tables$mlineno;
static u8 *  mm_tables$jtagnames[132] = {
    (byte*)"jnone",
    (byte*)"jconst",
    (byte*)"jnull",
    (byte*)"jvoidvar",
    (byte*)"jname",
    (byte*)"jnamelv",
    (byte*)"jblock",
    (byte*)"jdecimal",
    (byte*)"jassem",
    (byte*)"jassemmacro",
    (byte*)"jassemreg",
    (byte*)"jassemxreg",
    (byte*)"jassemmem",
    (byte*)"jstrinclude",
    (byte*)"jandl",
    (byte*)"jorl",
    (byte*)"jnotl",
    (byte*)"jistruel",
    (byte*)"jmakelist",
    (byte*)"jmakerange",
    (byte*)"jmakeset",
    (byte*)"jmakedict",
    (byte*)"jmakeslice",
    (byte*)"jreturnmult",
    (byte*)"jkeyword",
    (byte*)"jkeyvalue",
    (byte*)"jassign",
    (byte*)"jassignmm",
    (byte*)"jassignms",
    (byte*)"jassignmdrem",
    (byte*)"jcopy",
    (byte*)"jcallfn",
    (byte*)"jcmp",
    (byte*)"jcmpchain",
    (byte*)"jbin",
    (byte*)"junary",
    (byte*)"jbinto",
    (byte*)"junaryto",
    (byte*)"jincr",
    (byte*)"jinrev",
    (byte*)"jinrange",
    (byte*)"jinset",
    (byte*)"jclamp",
    (byte*)"jstringz",
    (byte*)"jindex",
    (byte*)"jslice",
    (byte*)"jdot",
    (byte*)"jdotindex",
    (byte*)"jdotslice",
    (byte*)"jptr",
    (byte*)"jaddrof",
    (byte*)"jaddroffirst",
    (byte*)"jconvert",
    (byte*)"jshorten",
    (byte*)"jautocast",
    (byte*)"jtypepun",
    (byte*)"jtypeconst",
    (byte*)"joperator",
    (byte*)"jupper",
    (byte*)"jbitwidth",
    (byte*)"jbytesize",
    (byte*)"jtypeof",
    (byte*)"jtypestr",
    (byte*)"jbitfield",
    (byte*)"jminvalue",
    (byte*)"jmaxvalue",
    (byte*)"jcvlineno",
    (byte*)"jcvstrlineno",
    (byte*)"jcvmodulename",
    (byte*)"jcvfilename",
    (byte*)"jcvfunction",
    (byte*)"jcvdate",
    (byte*)"jcvtime",
    (byte*)"jcvversion",
    (byte*)"jcvtypename",
    (byte*)"jcvtargetbits",
    (byte*)"jcvtargetsize",
    (byte*)"jcvtargetcode",
    (byte*)"jcvctarget",
    (byte*)"jcvwindows",
    (byte*)"jcvlinux",
    (byte*)"jcvnil",
    (byte*)"jcvpi",
    (byte*)"jcvinfinity",
    (byte*)"jcvtrue",
    (byte*)"jcvfalse",
    (byte*)"jwhenthen",
    (byte*)"jfmtitem",
    (byte*)"jnogap",
    (byte*)"jspace",
    (byte*)"jcallproc",
    (byte*)"jreturn",
    (byte*)"jsyscall",
    (byte*)"jto",
    (byte*)"jif",
    (byte*)"jforup",
    (byte*)"jfordown",
    (byte*)"jforall",
    (byte*)"jforallrev",
    (byte*)"jwhile",
    (byte*)"jrepeat",
    (byte*)"jgoto",
    (byte*)"jlabeldef",
    (byte*)"jredo",
    (byte*)"jnext",
    (byte*)"jexit",
    (byte*)"jdo",
    (byte*)"jcase",
    (byte*)"jdocase",
    (byte*)"jswitch",
    (byte*)"jdoswitch",
    (byte*)"jswap",
    (byte*)"jselect",
    (byte*)"jrecase",
    (byte*)"jprint",
    (byte*)"jprintln",
    (byte*)"jfprint",
    (byte*)"jfprintln",
    (byte*)"jsprint",
    (byte*)"jsfprint",
    (byte*)"jread",
    (byte*)"jreadln",
    (byte*)"jsread",
    (byte*)"jsreadln",
    (byte*)"jstop",
    (byte*)"jeval",
    (byte*)"jstack",
    (byte*)"junstack",
    (byte*)"jempty",
    (byte*)"jemitc",
    (byte*)"jinfinity",
    (byte*)"jdummy"
};
static byte mm_tables$jsubs[132] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)3u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte mm_tables$jisexpr[132] = {
    (u8)0u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)3u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)3u,
    (u8)1u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)0u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)3u
};
static u8 *  mm_tables$bitfieldnames[8] = {(byte*)"bf_msb",(byte*)"bf_lsb",(byte*)"bf_msbit",(byte*)"bf_lsbit",(byte*)"bf_msw",(byte*)"bf_lsw",(byte*)"bf_odd",(byte*)"bf_even"};
static u8 *  mm_tables$optypenames[4] = {(byte*)"no_op",(byte*)"bin_op",(byte*)"mon_op",(byte*)"prop_op"};
static u8 *  mm_tables$symbolnames[172] = {
    (byte*)"errorsym",
    (byte*)".",
    (byte*)"lexdotsym",
    (byte*)"&.",
    (byte*)",",
    (byte*)";",
    (byte*)":",
    (byte*)"::",
    (byte*)":=",
    (byte*)"::=",
    (byte*)"=>",
    (byte*)"->",
    (byte*)"(",
    (byte*)")",
    (byte*)"[",
    (byte*)"]",
    (byte*)"{",
    (byte*)"}",
    (byte*)"^",
    (byte*)"|",
    (byte*)"||",
    (byte*)"@",
    (byte*)"@@",
    (byte*)"?",
    (byte*)"&",
    (byte*)"&&",
    (byte*)"~",
    (byte*)"..",
    (byte*)"...",
    (byte*)"#",
    (byte*)"+",
    (byte*)"-",
    (byte*)"*",
    (byte*)"/",
    (byte*)"%",
    (byte*)"rem",
    (byte*)"rem",
    (byte*)"iand",
    (byte*)"ior",
    (byte*)"ixor",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"min",
    (byte*)"max",
    (byte*)"and",
    (byte*)"or",
    (byte*)"xor",
    (byte*)"=",
    (byte*)"cmp",
    (byte*)"**",
    (byte*)"==",
    (byte*)"in",
    (byte*)"notin",
    (byte*)"inrev",
    (byte*)"$neg",
    (byte*)"not",
    (byte*)"istrue",
    (byte*)"inot",
    (byte*)"abs",
    (byte*)"sign",
    (byte*)"sqrt",
    (byte*)"sqr",
    (byte*)"propsym",
    (byte*)"mathsopsym",
    (byte*)"maths2opsym",
    (byte*)"bitfieldsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"rawxnamesym",
    (byte*)"docstringsym",
    (byte*)"incrsym",
    (byte*)"intconstsym",
    (byte*)"decimalconstsym",
    (byte*)"realconstsym",
    (byte*)"charconstsym",
    (byte*)"wcharconstsym",
    (byte*)"stringconstsym",
    (byte*)"astringconstsym",
    (byte*)"wstringconstsym",
    (byte*)"unitnamesym",
    (byte*)"namesym",
    (byte*)"ksourcedirsym",
    (byte*)"kstrincludesym",
    (byte*)"regsym",
    (byte*)"xregsym",
    (byte*)"fregsym",
    (byte*)"mregsym",
    (byte*)"jmpccsym",
    (byte*)"setccsym",
    (byte*)"movccsym",
    (byte*)"segnamesym",
    (byte*)"asmopcodesym",
    (byte*)"stdtypesym",
    (byte*)"ktypeofsym",
    (byte*)"ksubrangesym",
    (byte*)"koutsym",
    (byte*)"kicharsym",
    (byte*)"kifsym",
    (byte*)"kthensym",
    (byte*)"kelsifsym",
    (byte*)"kelsesym",
    (byte*)"kelsecasesym",
    (byte*)"kelseswitchsym",
    (byte*)"kelseselectsym",
    (byte*)"kendsym",
    (byte*)"kunlesssym",
    (byte*)"kcasesym",
    (byte*)"kdocasesym",
    (byte*)"krecasesym",
    (byte*)"kwhensym",
    (byte*)"kforsym",
    (byte*)"ktosym",
    (byte*)"kbysym",
    (byte*)"kdosym",
    (byte*)"kwhilesym",
    (byte*)"krepeatsym",
    (byte*)"kuntilsym",
    (byte*)"kreturnsym",
    (byte*)"kstopsym",
    (byte*)"kloopsym",
    (byte*)"kstepsym",
    (byte*)"kgotosym",
    (byte*)"kswitchsym",
    (byte*)"kdoswitchsym",
    (byte*)"kprintsym",
    (byte*)"ksprintsym",
    (byte*)"kreadsym",
    (byte*)"ksreadsym",
    (byte*)"ksreadlnsym",
    (byte*)"kprocsym",
    (byte*)"kfunctionsym",
    (byte*)"klabelsym",
    (byte*)"krecordsym",
    (byte*)"kstructsym",
    (byte*)"kunionsym",
    (byte*)"kimportmodulesym",
    (byte*)"ktypesym",
    (byte*)"ktypealiassym",
    (byte*)"kextendtypesym",
    (byte*)"krefsym",
    (byte*)"kmutsym",
    (byte*)"kletsym",
    (byte*)"kslicesym",
    (byte*)"karraysym",
    (byte*)"kdictsym",
    (byte*)"kmacrosym",
    (byte*)"kexpandsym",
    (byte*)"koperatorsym",
    (byte*)"kconstsym",
    (byte*)"knewsym",
    (byte*)"kclearsym",
    (byte*)"kclasssym",
    (byte*)"kheadersym",
    (byte*)"kheadervarsym",
    (byte*)"kfflangsym",
    (byte*)"kglobalsym",
    (byte*)"kstaticsym",
    (byte*)"kcastsym",
    (byte*)"compilervarsym",
    (byte*)"dollarsym",
    (byte*)"kevalsym",
    (byte*)"ktabledatasym",
    (byte*)"kstacksym",
    (byte*)"kclampsym",
    (byte*)"kswapsym",
    (byte*)"kerrorsym",
    (byte*)"kassemsym",
    (byte*)"ksyscallsym",
    (byte*)"kemitcsym",
    (byte*)"kemptysym",
    (byte*)"kcopysym",
    (byte*)"kdummysym"
};
static byte mm_tables$symboloptypes[172] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte mm_tables$symbolgenops[172] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)15u,
    (u8)16u,
    (u8)24u,
    (u8)25u,
    (u8)0u,
    (u8)17u,
    (u8)0u,
    (u8)51u,
    (u8)23u,
    (u8)13u,
    (u8)14u,
    (u8)0u,
    (u8)29u,
    (u8)32u,
    (u8)33u,
    (u8)31u,
    (u8)30u,
    (u8)49u,
    (u8)35u,
    (u8)34u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte mm_tables$symbolgentoops[172] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)59u,
    (u8)60u,
    (u8)61u,
    (u8)62u,
    (u8)63u,
    (u8)64u,
    (u8)0u,
    (u8)65u,
    (u8)66u,
    (u8)67u,
    (u8)68u,
    (u8)69u,
    (u8)70u,
    (u8)71u,
    (u8)72u,
    (u8)73u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)79u,
    (u8)80u,
    (u8)78u,
    (u8)77u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte mm_tables$symbolopprios[172] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)5u,
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)4u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)3u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)3u,
    (u8)3u,
    (u8)4u,
    (u8)4u,
    (u8)7u,
    (u8)8u,
    (u8)8u,
    (u8)6u,
    (u8)6u,
    (u8)2u,
    (u8)6u,
    (u8)6u,
    (u8)6u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte mm_tables$exprstarter[172] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u
};
static u8 *  mm_tables$pclnames[105] = {
    (byte*)"kzero",
    (byte*)"kadd",
    (byte*)"ksub",
    (byte*)"kmul",
    (byte*)"kdiv",
    (byte*)"kidiv",
    (byte*)"kirem",
    (byte*)"kidivrem",
    (byte*)"kiand",
    (byte*)"kior",
    (byte*)"kixor",
    (byte*)"kshl",
    (byte*)"kshr",
    (byte*)"kin",
    (byte*)"knotin",
    (byte*)"kmin",
    (byte*)"kmax",
    (byte*)"keq",
    (byte*)"kne",
    (byte*)"klt",
    (byte*)"kle",
    (byte*)"kge",
    (byte*)"kgt",
    (byte*)"ksame",
    (byte*)"kandl",
    (byte*)"korl",
    (byte*)"kaddrefoff",
    (byte*)"ksubrefoff",
    (byte*)"ksubref",
    (byte*)"kneg",
    (byte*)"kabs",
    (byte*)"kinot",
    (byte*)"knotl",
    (byte*)"kistruel",
    (byte*)"ksqr",
    (byte*)"ksqrt",
    (byte*)"ksin",
    (byte*)"kcos",
    (byte*)"ktan",
    (byte*)"kasin",
    (byte*)"kacos",
    (byte*)"katan",
    (byte*)"kln",
    (byte*)"klog",
    (byte*)"kexp",
    (byte*)"kround",
    (byte*)"kfloor",
    (byte*)"kceil",
    (byte*)"kfract",
    (byte*)"ksign",
    (byte*)"katan2",
    (byte*)"kpower",
    (byte*)"kfmod",
    (byte*)"kincr",
    (byte*)"kdecr",
    (byte*)"kincrload",
    (byte*)"kdecrload",
    (byte*)"kloadincr",
    (byte*)"kloaddecr",
    (byte*)"kaddto",
    (byte*)"ksubto",
    (byte*)"kmulto",
    (byte*)"kdivto",
    (byte*)"kidivto",
    (byte*)"kiremto",
    (byte*)"kiandto",
    (byte*)"kiorto",
    (byte*)"kixorto",
    (byte*)"kshlto",
    (byte*)"kshrto",
    (byte*)"kminto",
    (byte*)"kmaxto",
    (byte*)"kandlto",
    (byte*)"korlto",
    (byte*)"kaddrefoffto",
    (byte*)"ksubrefoffto",
    (byte*)"knegto",
    (byte*)"kabsto",
    (byte*)"kinotto",
    (byte*)"knotlto",
    (byte*)"kistruelto",
    (byte*)"ktypepun",
    (byte*)"ksoftconv",
    (byte*)"kfloat",
    (byte*)"kfix",
    (byte*)"ktruncate",
    (byte*)"kfwiden",
    (byte*)"kfnarrow",
    (byte*)"klen",
    (byte*)"klwb",
    (byte*)"kupb",
    (byte*)"kbounds",
    (byte*)"klenstr",
    (byte*)"kbitwidth",
    (byte*)"kbytesize",
    (byte*)"kminvalue",
    (byte*)"kmaxvalue",
    (byte*)"ktypestr",
    (byte*)"kerror",
    (byte*)"kharderror",
    (byte*)"karraytoslice",
    (byte*)"kichartoslice",
    (byte*)"ksofttruncshort",
    (byte*)"kcharaxtoichar",
    (byte*)"ksliceptr"
};
static u8 *  mm_tables$ccopnames[105] = {
    0,
    (byte*)"+",
    (byte*)"-",
    (byte*)"*",
    (byte*)"/",
    (byte*)"/",
    (byte*)"%",
    0,
    (byte*)"&",
    (byte*)"|",
    (byte*)"^",
    (byte*)"<<",
    (byte*)">>",
    0,
    0,
    0,
    0,
    (byte*)"==",
    (byte*)"!=",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">=",
    (byte*)">",
    0,
    (byte*)"&&",
    (byte*)"||",
    (byte*)"+",
    (byte*)"-",
    (byte*)"-",
    (byte*)"-",
    0,
    (byte*)"~",
    (byte*)"!",
    (byte*)"!!",
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    (byte*)"+=",
    (byte*)"-=",
    (byte*)"*=",
    (byte*)"/=",
    (byte*)"/=",
    (byte*)"%=",
    (byte*)"&=",
    (byte*)"|=",
    (byte*)"^=",
    (byte*)"<<=",
    (byte*)">>=",
    0,
    0,
    (byte*)"&&=",
    (byte*)"||=",
    (byte*)"+=",
    (byte*)"-=",
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
static byte mm_tables$complexops[15] = {
    (u8)51u,
    (u8)50u,
    (u8)36u,
    (u8)37u,
    (u8)38u,
    (u8)39u,
    (u8)40u,
    (u8)42u,
    (u8)43u,
    (u8)44u,
    (u8)45u,
    (u8)46u,
    (u8)47u,
    (u8)48u,
    (u8)52u
};
static byte mm_tables$complexopset[105];
static u8 *  mm_tables$sourcedirnames[2] = {(byte*)"includedir",(byte*)"binincludedir"};
static u8 *  mm_tables$headerdirnames[16] = {
    (byte*)"hdr_module",
    (byte*)"hdr_import",
    (byte*)"hdr_subprog",
    (byte*)"hdr_sysmodule",
    (byte*)"hdr_sysimport",
    (byte*)"hdr_syssubprog",
    (byte*)"hdr_minclude",
    (byte*)"hdr_altpath",
    (byte*)"hdr_importpath",
    (byte*)"hdr_linkdll",
    (byte*)"hdr_linklib",
    (byte*)"hdr_exportmodule",
    (byte*)"hdr_file",
    (byte*)"hdr_runexe",
    (byte*)"hdr_setvar",
    (byte*)"hdr_showvar"
};
static u8 *  mm_tables$headervarnames[11] = {
    (byte*)"hv_devpath",
    (byte*)"hv_mmpath",
    (byte*)"hv_hdrpath",
    (byte*)"hv_ctarget",
    (byte*)"hv_windows",
    (byte*)"hv_linux",
    (byte*)"hv_optim",
    (byte*)"hv_mainmodule",
    (byte*)"hv_a",
    (byte*)"hv_b",
    (byte*)"hv_c"
};
static u8 *  mm_tables$fflangnames[5] = {(byte*)"noff",(byte*)"windowsff",(byte*)"clangff",(byte*)"mlangff",(byte*)"callbackff"};
static u8 *  mm_tables$scopenames[4] = {(byte*)"Local",(byte*)"Global",(byte*)"Program",(byte*)"Export"};
static u8 *  mm_tables$parammodenames[4] = {(byte*)"Var ",(byte*)"In ",(byte*)"Out ",(byte*)"Opt "};
static u8 *  mm_tables$namenames[21] = {
    (byte*)"nullid",
    (byte*)"programid",
    (byte*)"subprogid",
    (byte*)"moduleid",
    (byte*)"dllmoduleid",
    (byte*)"typeid",
    (byte*)"procid",
    (byte*)"dllprocid",
    (byte*)"dllvarid",
    (byte*)"genprocid",
    (byte*)"constid",
    (byte*)"staticid",
    (byte*)"frameid",
    (byte*)"paramid",
    (byte*)"fieldid",
    (byte*)"genfieldid",
    (byte*)"enumid",
    (byte*)"labelid",
    (byte*)"macroid",
    (byte*)"macroparamid",
    (byte*)"linkid"
};
static u8 *  mm_tables$stnames[262] = {
    (byte*)"if",
    (byte*)"then",
    (byte*)"elsif",
    (byte*)"else",
    (byte*)"elsecase",
    (byte*)"elseswitch",
    (byte*)"case",
    (byte*)"docase",
    (byte*)"recase",
    (byte*)"when",
    (byte*)"for",
    (byte*)"forall",
    (byte*)"to",
    (byte*)"downto",
    (byte*)"by",
    (byte*)"do",
    (byte*)"end",
    (byte*)"while",
    (byte*)"repeat",
    (byte*)"until",
    (byte*)"always",
    (byte*)"return",
    (byte*)"stop",
    (byte*)"redo",
    (byte*)"loop",
    (byte*)"next",
    (byte*)"exit",
    (byte*)"$step",
    (byte*)"goto",
    (byte*)"go",
    (byte*)"switch",
    (byte*)"doswitch",
    (byte*)"tabledata",
    (byte*)"enumdata",
    (byte*)"clamp",
    (byte*)"eval",
    (byte*)"evalloadref",
    (byte*)"evalgetref",
    (byte*)"evalget",
    (byte*)"evalload",
    (byte*)"print",
    (byte*)"println",
    (byte*)"fprint",
    (byte*)"fprintln",
    (byte*)"sprint",
    (byte*)"sfprint",
    (byte*)"cp",
    (byte*)"cpl",
    (byte*)"read",
    (byte*)"readln",
    (byte*)"cast",
    (byte*)"function",
    (byte*)"func",
    (byte*)"procedure",
    (byte*)"proc",
    (byte*)"fun",
    (byte*)"sub",
    (byte*)"threadedproc",
    (byte*)"type",
    (byte*)"class",
    (byte*)"record",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"ref",
    (byte*)"pointer",
    (byte*)"returning",
    (byte*)"mut",
    (byte*)"var",
    (byte*)"let",
    (byte*)"include",
    (byte*)"strinclude",
    (byte*)"bininclude",
    (byte*)"emitc",
    (byte*)"macro",
    (byte*)"assem",
    (byte*)"asm",
    (byte*)"static",
    (byte*)"const",
    (byte*)"$get_nprocs",
    (byte*)"$getnprocs",
    (byte*)"$get_procname",
    (byte*)"$getprocname",
    (byte*)"$get_procaddr",
    (byte*)"$getprocaddr",
    (byte*)"$gettttable",
    (byte*)"$getsttable",
    (byte*)"$getfftable",
    (byte*)"importdll",
    (byte*)"importlib",
    (byte*)"unless",
    (byte*)"out",
    (byte*)"global",
    (byte*)"export",
    (byte*)"clang",
    (byte*)"mlang",
    (byte*)"windows",
    (byte*)"callback",
    (byte*)"swap",
    (byte*)"void",
    (byte*)"int",
    (byte*)"word",
    (byte*)"real",
    (byte*)"ichar",
    (byte*)"int8",
    (byte*)"int16",
    (byte*)"int32",
    (byte*)"int64",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"i64",
    (byte*)"real32",
    (byte*)"real64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"float32",
    (byte*)"float64",
    (byte*)"byte",
    (byte*)"u8",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"u64",
    (byte*)"word8",
    (byte*)"word16",
    (byte*)"word32",
    (byte*)"word64",
    (byte*)"char",
    (byte*)"char64",
    (byte*)"bool64",
    (byte*)"bool",
    (byte*)"bool8",
    (byte*)"range",
    (byte*)"auto",
    (byte*)"label",
    (byte*)"slice",
    (byte*)"array",
    (byte*)"typeof",
    (byte*)"million",
    (byte*)"billion",
    (byte*)"thousand",
    (byte*)"$lineno",
    (byte*)"$strlineno",
    (byte*)"$filename",
    (byte*)"$modulename",
    (byte*)"$function",
    (byte*)"$date",
    (byte*)"$time",
    (byte*)"$version",
    (byte*)"$typename",
    (byte*)"$targetbits",
    (byte*)"$targetsize",
    (byte*)"$targetcode",
    (byte*)"$ctarget",
    (byte*)"$windows",
    (byte*)"$linux",
    (byte*)"nil",
    (byte*)"pi",
    (byte*)"true",
    (byte*)"false",
    (byte*)"infinity",
    (byte*)"$",
    (byte*)"and",
    (byte*)"or",
    (byte*)"xor",
    (byte*)"iand",
    (byte*)"ior",
    (byte*)"ixor",
    (byte*)"in",
    (byte*)"notin",
    (byte*)"inrev",
    (byte*)"rem",
    (byte*)"divrem",
    (byte*)"min",
    (byte*)"max",
    (byte*)"not",
    (byte*)"inot",
    (byte*)"istrue",
    (byte*)"abs",
    (byte*)"$neg",
    (byte*)"sqr",
    (byte*)"sqrt",
    (byte*)"sign",
    (byte*)"sin",
    (byte*)"cos",
    (byte*)"tan",
    (byte*)"asin",
    (byte*)"acos",
    (byte*)"atan",
    (byte*)"ln",
    (byte*)"log",
    (byte*)"exp",
    (byte*)"round",
    (byte*)"floor",
    (byte*)"ceil",
    (byte*)"fract",
    (byte*)"atan2",
    (byte*)"fmod",
    (byte*)"sliceptr",
    (byte*)"len",
    (byte*)"lwb",
    (byte*)"upb",
    (byte*)"bounds",
    (byte*)"bitwidth",
    (byte*)"bytes",
    (byte*)"minvalue",
    (byte*)"maxvalue",
    (byte*)"typestr",
    (byte*)"msb",
    (byte*)"lsb",
    (byte*)"msbit",
    (byte*)"lsbit",
    (byte*)"msw",
    (byte*)"lsw",
    (byte*)"odd",
    (byte*)"even",
    (byte*)"endif",
    (byte*)"fi",
    (byte*)"endcase",
    (byte*)"esac",
    (byte*)"enddocase",
    (byte*)"endswitch",
    (byte*)"enddoswitch",
    (byte*)"endfor",
    (byte*)"od",
    (byte*)"endproc",
    (byte*)"endfunction",
    (byte*)"endwhile",
    (byte*)"endto",
    (byte*)"enddo",
    (byte*)"endrecord",
    (byte*)"endassem",
    (byte*)"$caligned",
    (byte*)"empty",
    (byte*)"clear",
    (byte*)"copy",
    (byte*)"module",
    (byte*)"sysmodule",
    (byte*)"import",
    (byte*)"sysimport",
    (byte*)"minclude",
    (byte*)"subprog",
    (byte*)"syssubprog",
    (byte*)"altpath",
    (byte*)"importpath",
    (byte*)"linkdll",
    (byte*)"linklib",
    (byte*)"exportmodule",
    (byte*)"runexe",
    (byte*)"setvar",
    (byte*)"showvar",
    (byte*)"$devpath",
    (byte*)"$mmpath",
    (byte*)"$hdrpath",
    (byte*)"$$ctarget",
    (byte*)"$$windows",
    (byte*)"$$linux",
    (byte*)"$optim",
    (byte*)"$mainmodule",
    (byte*)"$a",
    (byte*)"$b",
    (byte*)"$c",
    (byte*)"$$dummy"
};
static i64 mm_tables$stsymbols[262] = {
    (i64)98,
    (i64)99,
    (i64)100,
    (i64)101,
    (i64)102,
    (i64)103,
    (i64)107,
    (i64)108,
    (i64)109,
    (i64)110,
    (i64)111,
    (i64)111,
    (i64)112,
    (i64)112,
    (i64)113,
    (i64)114,
    (i64)105,
    (i64)115,
    (i64)116,
    (i64)117,
    (i64)117,
    (i64)118,
    (i64)119,
    (i64)120,
    (i64)120,
    (i64)120,
    (i64)120,
    (i64)121,
    (i64)122,
    (i64)122,
    (i64)123,
    (i64)124,
    (i64)162,
    (i64)162,
    (i64)164,
    (i64)161,
    (i64)161,
    (i64)161,
    (i64)161,
    (i64)161,
    (i64)125,
    (i64)125,
    (i64)125,
    (i64)125,
    (i64)126,
    (i64)126,
    (i64)125,
    (i64)125,
    (i64)127,
    (i64)127,
    (i64)158,
    (i64)131,
    (i64)131,
    (i64)130,
    (i64)130,
    (i64)131,
    (i64)130,
    (i64)130,
    (i64)137,
    (i64)152,
    (i64)133,
    (i64)134,
    (i64)135,
    (i64)140,
    (i64)140,
    (i64)11,
    (i64)141,
    (i64)141,
    (i64)142,
    (i64)82,
    (i64)83,
    (i64)82,
    (i64)169,
    (i64)146,
    (i64)167,
    (i64)167,
    (i64)157,
    (i64)149,
    (i64)168,
    (i64)168,
    (i64)168,
    (i64)168,
    (i64)168,
    (i64)168,
    (i64)168,
    (i64)168,
    (i64)168,
    (i64)136,
    (i64)136,
    (i64)106,
    (i64)96,
    (i64)156,
    (i64)156,
    (i64)155,
    (i64)155,
    (i64)155,
    (i64)155,
    (i64)165,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)97,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)93,
    (i64)143,
    (i64)144,
    (i64)94,
    (i64)80,
    (i64)80,
    (i64)80,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)159,
    (i64)160,
    (i64)45,
    (i64)46,
    (i64)47,
    (i64)38,
    (i64)39,
    (i64)40,
    (i64)52,
    (i64)53,
    (i64)54,
    (i64)36,
    (i64)37,
    (i64)43,
    (i64)44,
    (i64)56,
    (i64)58,
    (i64)57,
    (i64)59,
    (i64)55,
    (i64)62,
    (i64)61,
    (i64)60,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)64,
    (i64)65,
    (i64)65,
    (i64)63,
    (i64)63,
    (i64)63,
    (i64)63,
    (i64)63,
    (i64)63,
    (i64)63,
    (i64)63,
    (i64)63,
    (i64)63,
    (i64)66,
    (i64)66,
    (i64)66,
    (i64)66,
    (i64)66,
    (i64)66,
    (i64)66,
    (i64)66,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)105,
    (i64)22,
    (i64)170,
    (i64)170,
    (i64)171,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)153,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)154,
    (i64)0
};
static i64 mm_tables$stsubcodes[262] = {
    (i64)94,
    (i64)0,
    (i64)94,
    (i64)0,
    (i64)107,
    (i64)109,
    (i64)107,
    (i64)108,
    (i64)113,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)1,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)1,
    (i64)0,
    (i64)0,
    (i64)103,
    (i64)103,
    (i64)104,
    (i64)105,
    (i64)0,
    (i64)0,
    (i64)1,
    (i64)109,
    (i64)110,
    (i64)0,
    (i64)1,
    (i64)0,
    (i64)0,
    (i64)2,
    (i64)3,
    (i64)1,
    (i64)0,
    (i64)114,
    (i64)115,
    (i64)116,
    (i64)117,
    (i64)118,
    (i64)119,
    (i64)114,
    (i64)115,
    (i64)120,
    (i64)121,
    (i64)52,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)1,
    (i64)1,
    (i64)2,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)1,
    (i64)0,
    (i64)2,
    (i64)0,
    (i64)0,
    (i64)1,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)29,
    (i64)29,
    (i64)30,
    (i64)30,
    (i64)31,
    (i64)31,
    (i64)32,
    (i64)33,
    (i64)34,
    (i64)68,
    (i64)76,
    (i64)0,
    (i64)0,
    (i64)1,
    (i64)3,
    (i64)2,
    (i64)3,
    (i64)1,
    (i64)4,
    (i64)0,
    (i64)0,
    (i64)3,
    (i64)2,
    (i64)5,
    (i64)0,
    (i64)14,
    (i64)15,
    (i64)16,
    (i64)3,
    (i64)14,
    (i64)15,
    (i64)16,
    (i64)3,
    (i64)4,
    (i64)5,
    (i64)4,
    (i64)5,
    (i64)4,
    (i64)5,
    (i64)17,
    (i64)17,
    (i64)18,
    (i64)19,
    (i64)2,
    (i64)17,
    (i64)18,
    (i64)19,
    (i64)2,
    (i64)12,
    (i64)1,
    (i64)6,
    (i64)6,
    (i64)13,
    (i64)9,
    (i64)21,
    (i64)24,
    (i64)11,
    (i64)0,
    (i64)0,
    (i64)2,
    (i64)3,
    (i64)1,
    (i64)66,
    (i64)67,
    (i64)69,
    (i64)68,
    (i64)70,
    (i64)71,
    (i64)72,
    (i64)73,
    (i64)74,
    (i64)75,
    (i64)76,
    (i64)77,
    (i64)78,
    (i64)79,
    (i64)80,
    (i64)81,
    (i64)82,
    (i64)84,
    (i64)85,
    (i64)83,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)13,
    (i64)14,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)30,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)36,
    (i64)37,
    (i64)38,
    (i64)39,
    (i64)40,
    (i64)41,
    (i64)42,
    (i64)43,
    (i64)44,
    (i64)45,
    (i64)46,
    (i64)47,
    (i64)48,
    (i64)50,
    (i64)52,
    (i64)104,
    (i64)88,
    (i64)89,
    (i64)90,
    (i64)91,
    (i64)93,
    (i64)94,
    (i64)95,
    (i64)96,
    (i64)97,
    (i64)1,
    (i64)2,
    (i64)3,
    (i64)4,
    (i64)5,
    (i64)6,
    (i64)7,
    (i64)8,
    (i64)98,
    (i64)98,
    (i64)107,
    (i64)107,
    (i64)108,
    (i64)123,
    (i64)124,
    (i64)111,
    (i64)114,
    (i64)130,
    (i64)131,
    (i64)115,
    (i64)112,
    (i64)114,
    (i64)133,
    (i64)167,
    (i64)1,
    (i64)0,
    (i64)0,
    (i64)0,
    (i64)1,
    (i64)4,
    (i64)2,
    (i64)5,
    (i64)7,
    (i64)3,
    (i64)6,
    (i64)8,
    (i64)9,
    (i64)10,
    (i64)11,
    (i64)12,
    (i64)14,
    (i64)15,
    (i64)16,
    (i64)1,
    (i64)2,
    (i64)3,
    (i64)4,
    (i64)5,
    (i64)6,
    (i64)7,
    (i64)8,
    (i64)9,
    (i64)10,
    (i64)11,
    (i64)0
};
static i64 mm_tables$d_typestarterset[9] = {(i64)93,(i64)15,(i64)140,(i64)133,(i64)97,(i64)94,(i64)143,(i64)145,(i64)144};
static byte mm_tables$intresultlist[8] = {(u8)13u,(u8)14u,(u8)89u,(u8)90u,(u8)88u,(u8)92u,(u8)93u,(u8)94u};
static i16 mm_tables$softconvtable[5][5] = {
    {(i16)82,(i16)82,(i16)82,(i16)83,(i16)83},
    {(i16)82,(i16)82,(i16)82,(i16)83,(i16)83},
    {(i16)82,(i16)82,(i16)82,(i16)83,(i16)83},
    {(i16)84,(i16)84,(i16)84,(i16)82,(i16)86},
    {(i16)84,(i16)84,(i16)84,(i16)87,(i16)82}
};
static byte mm_tables$intresult[105];
static byte mm_tables$endsexpr[172];
static byte mm_tables$exprendsymbols[12] = {
    (u8)14u,
    (u8)16u,
    (u8)99u,
    (u8)100u,
    (u8)101u,
    (u8)117u,
    (u8)114u,
    (u8)105u,
    (u8)5u,
    (u8)20u,
    (u8)6u,
    (u8)112u
};
static byte mm_tables$isbooltag[132];
static byte mm_tables$ismemtag[132];
static i64 mm_type$countedfields;
static i64 mm_type$inassem;
static i64 mm_type$inidata;
static i64 mm_type$deb;
static struct mm_decls$strec *  mc_genmcl$blockretname;
static struct mc_decls$mclrec *  mc_genmcl$mclpushstack;
static struct mc_decls$mclrec *  mc_genmcl$mcldefine;
static struct mc_decls$mclrec *  mc_genmcl$mce_oldmccodex;
static struct mc_decls$mclrec *  mc_genmcl$mce_nextmcl;
static i64 mc_genss$rex;
static i64 mc_genss$sizeoverride;
static i64 mc_genss$addroverride;
static i64 mc_genss$f2override;
static i64 mc_genss$f3override;
static i64 mc_genss$currseg = (i64)0;
static struct mc_decls$dbuffer *  mc_genss$currdata;
static struct mc_decls$relocrec *  mc_genss$currrelocs;
static i64 mc_genss$nrelocs;
static i64 mc_genss$instrno = (i64)2;
static struct mc_decls$mclrec *  mc_genss$currmcl;
static i64 mc_libmcl$fshowmsource = (i64)0;
static i64 mc_libmcl$loopstack[50][4];
static i64 mc_libmcl$loopindex;
static i64 mc_libmcl$multregmap[16];
static i64 mc_libmcl$nmultregs;
static struct mm_decls$unitrec *  mc_libmcl$nilunit;
static i64 mc_libmcl$mclseqno;
static u8 *  mc_decls$valtypenames[9] = {(byte*)"no_val",(byte*)"intimm_val",(byte*)"realimm_val",(byte*)"realmem_val",(byte*)"stringimm_val",(byte*)"comment_val",(byte*)"def_val",(byte*)"label_val",(byte*)"name_val"};
static u8 *  mc_decls$opndnames[5] = {(byte*)"a_none",(byte*)"a_reg",(byte*)"a_xreg",(byte*)"a_imm",(byte*)"a_mem"};
static u8 *  mc_decls$mclnames[150] = {
    (byte*)"m_procstart",
    (byte*)"m_procend",
    (byte*)"m_programend",
    (byte*)"m_comment",
    (byte*)"m_blank",
    (byte*)"m_deleted",
    (byte*)"m_labelname",
    (byte*)"m_define",
    (byte*)"m_definereg",
    (byte*)"m_evalx",
    (byte*)"m_labelx",
    (byte*)"m_nop",
    (byte*)"m_mov",
    (byte*)"m_push",
    (byte*)"m_pop",
    (byte*)"m_lea",
    (byte*)"m_cmovcc",
    (byte*)"m_movd",
    (byte*)"m_movq",
    (byte*)"m_movsx",
    (byte*)"m_movzx",
    (byte*)"m_movsxd",
    (byte*)"m_call",
    (byte*)"m_ret",
    (byte*)"m_leave",
    (byte*)"m_retn",
    (byte*)"m_jmp",
    (byte*)"m_jmpcc",
    (byte*)"m_xchg",
    (byte*)"m_add",
    (byte*)"m_sub",
    (byte*)"m_adc",
    (byte*)"m_sbb",
    (byte*)"m_imul",
    (byte*)"m_mul",
    (byte*)"m_imul2",
    (byte*)"m_imul3",
    (byte*)"m_idiv",
    (byte*)"m_div",
    (byte*)"m_andx",
    (byte*)"m_orx",
    (byte*)"m_xorx",
    (byte*)"m_test",
    (byte*)"m_cmp",
    (byte*)"m_shl",
    (byte*)"m_sar",
    (byte*)"m_shr",
    (byte*)"m_rol",
    (byte*)"m_ror",
    (byte*)"m_rcl",
    (byte*)"m_rcr",
    (byte*)"m_neg",
    (byte*)"m_notx",
    (byte*)"m_inc",
    (byte*)"m_dec",
    (byte*)"m_cbw",
    (byte*)"m_cwd",
    (byte*)"m_cdq",
    (byte*)"m_cqo",
    (byte*)"m_setcc",
    (byte*)"m_bsf",
    (byte*)"m_bsr",
    (byte*)"m_sqrtsd",
    (byte*)"m_sqrtss",
    (byte*)"m_addss",
    (byte*)"m_subss",
    (byte*)"m_mulss",
    (byte*)"m_divss",
    (byte*)"m_addsd",
    (byte*)"m_subsd",
    (byte*)"m_mulsd",
    (byte*)"m_divsd",
    (byte*)"m_comiss",
    (byte*)"m_comisd",
    (byte*)"m_xorpd",
    (byte*)"m_xorps",
    (byte*)"m_andpd",
    (byte*)"m_andps",
    (byte*)"m_pxor",
    (byte*)"m_pand",
    (byte*)"m_cvtss2si",
    (byte*)"m_cvtsd2si",
    (byte*)"m_cvttss2si",
    (byte*)"m_cvttsd2si",
    (byte*)"m_cvtsi2ss",
    (byte*)"m_cvtsi2sd",
    (byte*)"m_cvtsd2ss",
    (byte*)"m_cvtss2sd",
    (byte*)"m_movdqa",
    (byte*)"m_movdqu",
    (byte*)"m_pcmpistri",
    (byte*)"m_pcmpistrm",
    (byte*)"m_fld",
    (byte*)"m_fst",
    (byte*)"m_fstp",
    (byte*)"m_fild",
    (byte*)"m_fist",
    (byte*)"m_fistp",
    (byte*)"m_fadd",
    (byte*)"m_fsub",
    (byte*)"m_fmul",
    (byte*)"m_fdiv",
    (byte*)"m_fsqrt",
    (byte*)"m_fsin",
    (byte*)"m_fcos",
    (byte*)"m_fsincos",
    (byte*)"m_fptan",
    (byte*)"m_fpatan",
    (byte*)"m_fabs",
    (byte*)"m_fchs",
    (byte*)"m_minss",
    (byte*)"m_maxss",
    (byte*)"m_minsd",
    (byte*)"m_maxsd",
    (byte*)"m_db",
    (byte*)"m_dw",
    (byte*)"m_dd",
    (byte*)"m_dq",
    (byte*)"m_ddoffset",
    (byte*)"m_segment",
    (byte*)"m_isegment",
    (byte*)"m_zsegment",
    (byte*)"m_csegment",
    (byte*)"m_align",
    (byte*)"m_resb",
    (byte*)"m_resw",
    (byte*)"m_resd",
    (byte*)"m_resq",
    (byte*)"m_xlat",
    (byte*)"m_loopnz",
    (byte*)"m_loopz",
    (byte*)"m_loopcx",
    (byte*)"m_jecxz",
    (byte*)"m_jrcxz",
    (byte*)"m_cmpsb",
    (byte*)"m_cmpsw",
    (byte*)"m_cmpsd",
    (byte*)"m_cmpsq",
    (byte*)"m_rdtsc",
    (byte*)"m_popcnt",
    (byte*)"m_finit",
    (byte*)"m_fldz",
    (byte*)"m_fld1",
    (byte*)"m_fldpi",
    (byte*)"m_fld2t",
    (byte*)"m_fld2e",
    (byte*)"m_fldlg2",
    (byte*)"m_fldln2",
    (byte*)"m_cpuid",
    (byte*)"m_halt"
};
static byte mc_decls$mclnopnds[150] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte mc_decls$mclcodes[150] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)144u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)232u,
    (u8)195u,
    (u8)201u,
    (u8)0u,
    (u8)233u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)5u,
    (u8)2u,
    (u8)3u,
    (u8)5u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)7u,
    (u8)6u,
    (u8)4u,
    (u8)1u,
    (u8)6u,
    (u8)0u,
    (u8)7u,
    (u8)4u,
    (u8)7u,
    (u8)5u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)188u,
    (u8)189u,
    (u8)81u,
    (u8)81u,
    (u8)88u,
    (u8)92u,
    (u8)89u,
    (u8)94u,
    (u8)88u,
    (u8)92u,
    (u8)89u,
    (u8)94u,
    (u8)0u,
    (u8)0u,
    (u8)87u,
    (u8)87u,
    (u8)84u,
    (u8)84u,
    (u8)239u,
    (u8)219u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)102u,
    (u8)243u,
    (u8)99u,
    (u8)98u,
    (u8)0u,
    (u8)2u,
    (u8)3u,
    (u8)0u,
    (u8)2u,
    (u8)3u,
    (u8)193u,
    (u8)233u,
    (u8)201u,
    (u8)249u,
    (u8)250u,
    (u8)254u,
    (u8)255u,
    (u8)251u,
    (u8)242u,
    (u8)243u,
    (u8)225u,
    (u8)224u,
    (u8)93u,
    (u8)95u,
    (u8)93u,
    (u8)95u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)8u,
    (u8)215u,
    (u8)224u,
    (u8)225u,
    (u8)226u,
    (u8)227u,
    (u8)227u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)49u,
    (u8)0u,
    (u8)0u,
    (u8)238u,
    (u8)232u,
    (u8)235u,
    (u8)233u,
    (u8)234u,
    (u8)236u,
    (u8)237u,
    (u8)0u,
    (u8)244u
};
static u8 *  mc_decls$regnames[37] = {
    (byte*)"rnone",
    (byte*)"r0",
    (byte*)"r1",
    (byte*)"r2",
    (byte*)"r3",
    (byte*)"r4",
    (byte*)"r5",
    (byte*)"r6",
    (byte*)"r7",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15",
    (byte*)"r16",
    (byte*)"r17",
    (byte*)"r18",
    (byte*)"r19",
    (byte*)"xr0",
    (byte*)"xr1",
    (byte*)"xr2",
    (byte*)"xr3",
    (byte*)"xr4",
    (byte*)"xr5",
    (byte*)"xr6",
    (byte*)"xr7",
    (byte*)"xr8",
    (byte*)"xr9",
    (byte*)"xr10",
    (byte*)"xr11",
    (byte*)"xr12",
    (byte*)"xr13",
    (byte*)"xr14",
    (byte*)"xr15"
};
static byte mc_decls$regcodes[37] = {
    (u8)0u,
    (u8)0u,
    (u8)10u,
    (u8)11u,
    (u8)7u,
    (u8)3u,
    (u8)6u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)1u,
    (u8)2u,
    (u8)8u,
    (u8)9u,
    (u8)5u,
    (u8)4u,
    (u8)4u,
    (u8)7u,
    (u8)5u,
    (u8)6u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u
};
static u8 *  mc_decls$condnames[20] = {
    (byte*)"ov",
    (byte*)"nov",
    (byte*)"ltu",
    (byte*)"geu",
    (byte*)"eq",
    (byte*)"ne",
    (byte*)"leu",
    (byte*)"gtu",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"lt",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"gt",
    (byte*)"flt",
    (byte*)"fge",
    (byte*)"fle",
    (byte*)"fgt"
};
static u8 *  mc_decls$asmcondnames[20] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"be",
    (byte*)"a"
};
static i64 mc_decls$asmrevcond[20] = {
    (i64)1,
    (i64)0,
    (i64)3,
    (i64)2,
    (i64)5,
    (i64)4,
    (i64)7,
    (i64)6,
    (i64)9,
    (i64)8,
    (i64)11,
    (i64)10,
    (i64)13,
    (i64)12,
    (i64)15,
    (i64)14,
    (i64)17,
    (i64)16,
    (i64)19,
    (i64)18
};
static u8 *  mc_decls$dregnames[136] = {
    (byte*)"d0",
    (byte*)"d1",
    (byte*)"d2",
    (byte*)"d3",
    (byte*)"d4",
    (byte*)"d5",
    (byte*)"d6",
    (byte*)"d7",
    (byte*)"d8",
    (byte*)"d9",
    (byte*)"d10",
    (byte*)"d11",
    (byte*)"d12",
    (byte*)"d13",
    (byte*)"d14",
    (byte*)"d15",
    (byte*)"a0",
    (byte*)"a1",
    (byte*)"a2",
    (byte*)"a3",
    (byte*)"a4",
    (byte*)"a5",
    (byte*)"a6",
    (byte*)"a7",
    (byte*)"a8",
    (byte*)"a9",
    (byte*)"a10",
    (byte*)"a11",
    (byte*)"a12",
    (byte*)"a13",
    (byte*)"a14",
    (byte*)"a15",
    (byte*)"w0",
    (byte*)"w1",
    (byte*)"w2",
    (byte*)"w3",
    (byte*)"w4",
    (byte*)"w5",
    (byte*)"w6",
    (byte*)"w7",
    (byte*)"w8",
    (byte*)"w9",
    (byte*)"w10",
    (byte*)"w11",
    (byte*)"w12",
    (byte*)"w13",
    (byte*)"w14",
    (byte*)"w15",
    (byte*)"b0",
    (byte*)"b1",
    (byte*)"b2",
    (byte*)"b3",
    (byte*)"b4",
    (byte*)"b5",
    (byte*)"b6",
    (byte*)"b7",
    (byte*)"b8",
    (byte*)"b9",
    (byte*)"b10",
    (byte*)"b11",
    (byte*)"b12",
    (byte*)"b13",
    (byte*)"b14",
    (byte*)"b15",
    (byte*)"b16",
    (byte*)"b17",
    (byte*)"b18",
    (byte*)"b19",
    (byte*)"rax",
    (byte*)"rbx",
    (byte*)"rcx",
    (byte*)"rdx",
    (byte*)"rsi",
    (byte*)"rdi",
    (byte*)"rbp",
    (byte*)"rsp",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15",
    (byte*)"eax",
    (byte*)"ebx",
    (byte*)"ecx",
    (byte*)"edx",
    (byte*)"esi",
    (byte*)"edi",
    (byte*)"ebp",
    (byte*)"esp",
    (byte*)"r8d",
    (byte*)"r9d",
    (byte*)"r10d",
    (byte*)"r11d",
    (byte*)"r12d",
    (byte*)"r13d",
    (byte*)"r14d",
    (byte*)"r15d",
    (byte*)"ax",
    (byte*)"bx",
    (byte*)"cx",
    (byte*)"dx",
    (byte*)"si",
    (byte*)"di",
    (byte*)"bp",
    (byte*)"sp",
    (byte*)"r8w",
    (byte*)"r9w",
    (byte*)"r10w",
    (byte*)"r11w",
    (byte*)"r12w",
    (byte*)"r13w",
    (byte*)"r14w",
    (byte*)"r15w",
    (byte*)"al",
    (byte*)"bl",
    (byte*)"cl",
    (byte*)"dl",
    (byte*)"ah",
    (byte*)"bh",
    (byte*)"ch",
    (byte*)"dh",
    (byte*)"sil",
    (byte*)"dil",
    (byte*)"bpl",
    (byte*)"spl",
    (byte*)"r8b",
    (byte*)"r9b",
    (byte*)"r10b",
    (byte*)"r11b",
    (byte*)"r12b",
    (byte*)"r13b",
    (byte*)"r14b",
    (byte*)"r15b"
};
static byte mc_decls$regsizes[136] = {
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u
};
static byte mc_decls$regindices[136] = {
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)17u,
    (u8)18u,
    (u8)19u,
    (u8)20u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)17u,
    (u8)18u,
    (u8)19u,
    (u8)20u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u
};
static u8 *  mc_decls$xmmregnames[16] = {
    (byte*)"xmm0",
    (byte*)"xmm1",
    (byte*)"xmm2",
    (byte*)"xmm3",
    (byte*)"xmm4",
    (byte*)"xmm5",
    (byte*)"xmm6",
    (byte*)"xmm7",
    (byte*)"xmm8",
    (byte*)"xmm9",
    (byte*)"xmm10",
    (byte*)"xmm11",
    (byte*)"xmm12",
    (byte*)"xmm13",
    (byte*)"xmm14",
    (byte*)"xmm15"
};
static u8 *  mc_decls$fregnames[8] = {(byte*)"st0",(byte*)"st1",(byte*)"st2",(byte*)"st3",(byte*)"st4",(byte*)"st5",(byte*)"st6",(byte*)"st7"};
static u8 *  mc_decls$mregnames[8] = {(byte*)"mmx0",(byte*)"mmx1",(byte*)"mmx2",(byte*)"mmx3",(byte*)"mmx4",(byte*)"mmx5",(byte*)"mmx6",(byte*)"mmx7"};
static u8 *  mc_decls$jmpccnames[18] = {
    (byte*)"jo",
    (byte*)"jno",
    (byte*)"jb",
    (byte*)"jae",
    (byte*)"jz",
    (byte*)"jnz",
    (byte*)"jbe",
    (byte*)"ja",
    (byte*)"js",
    (byte*)"jns",
    (byte*)"jp",
    (byte*)"jnp",
    (byte*)"jl",
    (byte*)"jge",
    (byte*)"jle",
    (byte*)"jg",
    (byte*)"jc",
    (byte*)"jnc"
};
static byte mc_decls$jmpcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
static u8 *  mc_decls$setccnames[16] = {
    (byte*)"seto",
    (byte*)"setno",
    (byte*)"setb",
    (byte*)"setae",
    (byte*)"setz",
    (byte*)"setnz",
    (byte*)"setbe",
    (byte*)"seta",
    (byte*)"sets",
    (byte*)"setns",
    (byte*)"setp",
    (byte*)"setnp",
    (byte*)"setl",
    (byte*)"setge",
    (byte*)"setle",
    (byte*)"setg"
};
static byte mc_decls$setcccodes[16] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u
};
static u8 *  mc_decls$cmovccnames[16] = {
    (byte*)"cmovo",
    (byte*)"cmovno",
    (byte*)"cmovb",
    (byte*)"cmovae",
    (byte*)"cmovz",
    (byte*)"cmovnz",
    (byte*)"cmovbe",
    (byte*)"cmova",
    (byte*)"cmovs",
    (byte*)"cmovns",
    (byte*)"cmovp",
    (byte*)"cmovnp",
    (byte*)"cmovl",
    (byte*)"cmovge",
    (byte*)"cmovle",
    (byte*)"cmovg"
};
static byte mc_decls$cmovcccodes[16] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u
};
static u8 *  mc_decls$reftypenames[3] = {(byte*)"extern_ref",(byte*)"fwd_ref",(byte*)"back_ref"};
static i64 mc_decls$mlabelno;
static i64 mc_decls$mstackdepth;
static i64 mc_decls$retindex;
static u64 mc_decls$regset;
static i64 mc_decls$nregs;
static i64 mc_decls$nxregs;
static u64 mc_decls$isregvar;
static i64 mc_decls$inf_proccalls;
static i64 mc_decls$inf_proclocals;
static i64 mc_decls$inf_procxlocals;
static i64 mc_decls$inf_leafproc;
static i64 mc_decls$inf_highreg;
static i64 mc_decls$inf_highxreg;
static i64 mc_decls$inf_maxargs;
static i64 mc_decls$inf_assem;
static i64 mc_decls$inf_r10used;
static i64 mc_decls$inf_r11used;
static i64 mc_decls$inf_r13used;
static i64 mc_decls$dsaveregs[16];
static i64 mc_decls$xsaveregs[16];
static i64 mc_decls$ndsaveregs;
static i64 mc_decls$nxsaveregs;
static i64 mc_decls$dsaveoffset;
static i64 mc_decls$xsaveoffset;
static i64 mc_decls$needstackframe;
static i64 mc_decls$framebytes;
static i64 mc_decls$parambytes;
static i64 mc_decls$needshadow32;
static i64 mc_decls$dspillbytes;
static i64 mc_decls$xspillbytes;
static i64 mc_decls$alignbytes;
static i64 mc_decls$localbytes;
static i64 mc_decls$shadowbytes;
static byte mc_decls$noxorclear;
static struct mm_decls$strec *  mc_decls$procdef;
static i64 mc_decls$ncalldepth;
static struct mm_decls$strec *  mc_decls$paramdefs[32];
static struct mm_decls$strec *  mc_decls$localdefs[256];
static i64 mc_decls$nparams;
static i64 mc_decls$nlocals;
static i64 mc_decls$retmode;
static i64 mc_decls$passno;
static i64 mc_decls$sa_nargs;
static i64 mc_decls$multregs[6] = {(i64)1,(i64)2,(i64)3,(i64)11,(i64)12,(i64)13};
static i64 mc_decls$multxregs[6] = {(i64)21,(i64)22,(i64)23,(i64)24,(i64)25,(i64)26};
static i64 mc_decls$paramoffset;
static i64 mc_decls$lababs32;
static i64 mc_decls$lababs64;
static i64 mc_decls$labneg32;
static i64 mc_decls$labneg64;
static i64 mc_decls$labmask63;
static i64 mc_decls$laboffset64;
static i64 mc_decls$labzero;
static i64 mc_decls$kk0used = (i64)0;
static i64 mc_decls$stackaligned;
static struct mc_decls$mclrec *  mc_decls$mccode;
static struct mc_decls$mclrec *  mc_decls$mccodex;
static i64 mc_decls$currsegment = (i64)0;
static i64 mc_decls$currzdataalign = (i64)0;
static i64 mc_decls$curridataalign = (i64)0;
static i64 mc_decls$frameoffset;
static i64 mc_decls$isthreadedproc;
static i64 mc_decls$iscallbackproc;
static i64 mc_decls$structretoffset;
static struct mc_decls$mclrec *  mc_decls$stacksetinstr;
static i64 mc_decls$currblocksize;
static u8 *  mc_decls$allasmstr;
static i64 mc_decls$allasmstrlen;
static struct mc_decls$opndrec *  mc_decls$dstackopnd;
static struct mc_decls$opndrec *  mc_decls$distackopnd;
static struct mc_decls$opndrec *  mc_decls$dframeopnd;
static struct mc_decls$opndrec *  mc_decls$zero_opnd = 0;
static struct mc_decls$opndrec *  mc_decls$regtable[16][8];
static struct mc_decls$opndrec *  mc_decls$frameregtable[193];
static struct mc_decls$constrec *  mc_decls$cstringlist;
static struct mc_decls$constrec *  mc_decls$vstringlist;
static struct mc_decls$constrec *  mc_decls$creallist;
static struct mc_decls$constrec *  mc_decls$creal32list;
static i64 mc_decls$destlinestart;
static struct mm_decls$strec *  mc_decls$currasmproc;
static i64 mc_decls$noregvar;
static i64 mc_decls$lab_funcnametable;
static i64 mc_decls$lab_funcaddrtable;
static i64 mc_decls$lab_funcnprocs;
static i64 mc_decls$ss_zdatalen;
static struct mc_decls$dbuffer *  mc_decls$ss_zdata;
static struct mc_decls$dbuffer *  mc_decls$ss_idata;
static struct mc_decls$dbuffer *  mc_decls$ss_code;
static struct mc_decls$relocrec *  mc_decls$ss_idatarelocs;
static struct mc_decls$relocrec *  mc_decls$ss_coderelocs;
static i64 mc_decls$ss_nidatarelocs;
static i64 mc_decls$ss_ncoderelocs;
static struct mm_decls$strec *(*mc_decls$ss_symboltable)[];
static i64 mc_decls$ss_nsymbols;
static i64 mc_decls$ss_symboltablesize;
static struct mm_decls$strec *(*mc_decls$labeldeftable)[];
static i64 mc_decls$alineno;
static u8 *  mc_decls$segmentnames[5] = {(byte*)"code",(byte*)"idata",(byte*)"zdata",(byte*)"rodata",(byte*)"impdata_seg"};
static u8 *  mc_decls$loadnames[4] = {(byte*)"load_op",(byte*)"get_op",(byte*)"loadref_op",(byte*)"getref_op"};
static i64 mc_decls$nallmcl;
static struct mm_decls$strec *  mc_decls$blockdefs[50];
static i64 mc_decls$nblocktemps;
static struct mm_decls$strec *  mc_decls$blockretname;
static u8 *  mc_objdecls$relocnames[7] = {(byte*)"abs_rel",(byte*)"addr64_rel",(byte*)"addr32_rel",(byte*)"addr32nb_rel",(byte*)"rel32_rel",(byte*)"rel321_rel",(byte*)"rel8_rel"};
static struct mc_decls$dbuffer *  mc_write$dest;
static struct mm_decls$strec *  mc_write$entrypoint;
static i64 mc_writeexe$libinsttable[50];
static u8 *  mc_writeexe$libinstnames[50];
static i64 mc_writeexe$libnotable[50];
static struct mc_writeexe$basereloc *  mc_writeexe$basereloclist;
static i64 mc_writeexe$nbaserelocs;
static i64 mc_writeexe$maxrelocaddr;
static i64 mc_writeexe$blockbases[500];
static i32 mc_writeexe$blockcounts[500];
static i32 mc_writeexe$blockbytes[500];
static byte mc_writeexe$blockpadding[500];
static i64 mc_writeexe$nbaseblocks;
static i64 mc_writeexe$basetablesize;
static i64 mc_writeexe$imagebase;
static i64 mc_writeexe$imagesize;
static i64 mc_writeexe$filesize;
static i64 (*mc_writeexe$thunktable)[];
static i64 mc_writeexe$fileiatoffset;
static i64 mc_writeexe$fileiatsize;
static struct mm_decls$strec *  mc_writeexe$stentrypoint;
static struct mm_decls$strec *  mc_writeexe$stentrypoint2;
static struct mm_decls$strec *  mc_writeexe$stentrypoint3;
static struct mc_objdecls$sectionrec mc_writeexe$sectiontable[10];
static i64 mc_writeexe$nsections;
static byte *  mc_writeexe$importdir;
static struct mc_objdecls$importrec mc_writeexe$importtable[3001];
static i64 mc_writeexe$nimports;
static struct mc_objdecls$exportrec mc_writeexe$exporttable[1000];
static i64 mc_writeexe$nexports;
static u8 *  mc_writeexe$dllfilename;
static i64 mc_writeexe$isdll;
static struct mc_objdecls$dllrec mc_writeexe$dlltable[50];
static i64 mc_writeexe$ndlls;
static byte *  mc_writeexe$datastart;
static byte *  mc_writeexe$dataptr;
static u8 *  mc_writeexe$userentrypoint;
static i64 mc_writeexe$exportdirvirtaddr;
static i64 mc_writeexe$exportdirvirtsize;
static i64 mc_writeexe$exportdiroffset;
static i64 mc_writeexe$blockdirvirtaddr;
static i64 mc_writeexe$blockdirvirtsize;
static i64 mc_writeexe$blockdiroffset;
static u8 *  mx_decls$mcxdirnames[14] = {
    (byte*)"pad_dir",
    (byte*)"version_dir",
    (byte*)"code_dir",
    (byte*)"idata_dir",
    (byte*)"zdata_dir",
    (byte*)"reloc_dir",
    (byte*)"dlls_dir",
    (byte*)"libs_dir",
    (byte*)"importsymbols_dir",
    (byte*)"exportsymbols_dir",
    (byte*)"exportsegs_dir",
    (byte*)"exportoffsets_dir",
    (byte*)"entry_dir",
    (byte*)"end_dir"
};
static u8 *  mx_decls$mcxrelocnames[6] = {(byte*)"no_rel",(byte*)"locabs32",(byte*)"locabs64",(byte*)"impabs32",(byte*)"impabs64",(byte*)"imprel32"};
static u8 *  mx_decls$dllnametable[20];
static u64 mx_decls$dllinsttable[20];
static i64 mx_decls$ndlllibs;
static u8 *  mx_decls$libnametable[20];
static struct mx_decls$librec *  mx_decls$libtable[20];
static byte mx_decls$librelocated[20];
static byte mx_decls$libinitdone[20];
static i64 mx_decls$nlibs;
static u8 *  mx_decls$symbolnametable[3000];
static byte mx_decls$symboldefined[3000];
static void *  mx_decls$symboladdress[3000];
static i16 mx_decls$symbollibindex[3000];
static byte mx_decls$symboldllindex[3000];
static i64 mx_decls$nsymbols;
static i64 mx_decls$nsymimports = (i64)0;
static i64 mx_decls$nsymexports = (i64)0;
static u8 *  mx_lib$segmentnames[6] = {(byte*)"no_seg",(byte*)"code_seg",(byte*)"idata_seg",(byte*)"zdata_seg",(byte*)"rodata_seg",(byte*)"impdata_seg"};
static i64 mx_show$logdest = (i64)2;
static void *  mx_show$logdev;
static struct mlib$strbuffer mx_show$destv;
static struct mlib$strbuffer *  mx_show$dest = (struct mlib$strbuffer *)&mx_show$destv;
static void *  msysc$_fnaddresses[]= {
    &main,
    &mm_cli$do_loadmodules,
    &mm_cli$do_parse,
    &mm_cli$do_name,
    &mm_cli$do_type,
    &mm_cli$initdata,
    &mm_cli$getinputoptions,
    &mm_cli$do_option,
    &mm_cli$showcaption,
    &mm_cli$showhelp,
    &mm_cli$initassemsymbols,
    &mm_cli$do_writeexports,
    &mm_cli$getoutfilename,
    &mm_cli$fixstartprocs,
    &mm_cli$addstartproc,
    &mm_cli$stepruncount,
    &mm_cli$start,
    &mm_assem$readassemline,
    &mm_assem$readassemblock,
    &mm_assem$assembleline,
    &mm_assem$readassemopnd,
    &mm_assem$start,
    &mc_blockmcl$loadunit,
    &mc_blockmcl$evalunit,
    &mc_blockmcl$loadref,
    &mc_blockmcl$pushunit,
    &mc_blockmcl$poptoreg,
    &mc_blockmcl$poptoarg,
    &mc_blockmcl$loadarg,
    &mc_blockmcl$loadbin,
    &mc_blockmcl$loadbinto,
    &mc_blockmcl$do_const,
    &mc_blockmcl$do_name,
    &mc_blockmcl$genjumpl,
    &mc_blockmcl$do_assign,
    &mc_blockmcl$loadmem,
    &mc_blockmcl$loadmemaddr,
    &mc_blockmcl$storemem,
    &mc_blockmcl$do_bin,
    &mc_blockmcl$do_unary,
    &mc_blockmcl$do_labeldef,
    &mc_blockmcl$do_goto,
    &mc_blockmcl$do_to,
    &mc_blockmcl$docond,
    &mc_blockmcl$genjumpcond,
    &mc_blockmcl$gcomparejump,
    &mc_blockmcl$reversecond,
    &mc_blockmcl$setmultopnd,
    &mc_blockmcl$do_if,
    &mc_blockmcl$do_andl,
    &mc_blockmcl$do_orl,
    &mc_blockmcl$do_notl,
    &mc_blockmcl$do_istruel,
    &mc_blockmcl$do_ptr,
    &mc_blockmcl$do_index,
    &mc_blockmcl$mulreg,
    &mc_blockmcl$do_dot,
    &mc_blockmcl$getaddrmode,
    &mc_blockmcl$do_while,
    &mc_blockmcl$do_repeat,
    &mc_blockmcl$do_incr,
    &mc_blockmcl$do_incrstep,
    &mc_blockmcl$do_incrload,
    &mc_blockmcl$do_for,
    &mc_blockmcl$do_forall,
    &mc_blockmcl$do_print,
    &mc_blockmcl$do_callproc,
    &mc_blockmcl$do_stop,
    &mc_blockmcl$do_do,
    &mc_blockmcl$do_exit,
    &mc_blockmcl$do_swap,
    &mc_blockmcl$saverdx,
    &mc_blockmcl$restorerdx,
    &mc_blockmcl$do_divrem,
    &mc_blockmcl$fixdivopnds,
    &mc_blockmcl$do_shift,
    &mc_blockmcl$do_convert,
    &mc_blockmcl$do_clear,
    &mc_blockmcl$do_case,
    &mc_blockmcl$do_switch,
    &mc_blockmcl$do_binto,
    &mc_blockmcl$do_bintomem,
    &mc_blockmcl$do_bintoreg,
    &mc_blockmcl$do_return,
    &mc_blockmcl$do_returnmult,
    &mc_blockmcl$do_addrefoffto,
    &mc_blockmcl$domaxto_int,
    &mc_blockmcl$do_setcc,
    &mc_blockmcl$do_read,
    &mc_blockmcl$do_readln,
    &mc_blockmcl$do_syscall,
    &mc_blockmcl$do_dotindex,
    &mc_blockmcl$do_dotslice,
    &mc_blockmcl$do_typepun,
    &mc_blockmcl$do_shiftnto,
    &mc_blockmcl$do_select,
    &mc_blockmcl$do_setccchain,
    &mc_blockmcl$do_maths,
    &mc_blockmcl$do_maths2,
    &mc_blockmcl$do_callext,
    &mc_blockmcl$do_storedotindex,
    &mc_blockmcl$do_storedotslice,
    &mc_blockmcl$do_slice,
    &mc_blockmcl$do_assignms,
    &mc_blockmcl$start,
    &mm_winx64$codegen,
    &mm_winx64$runlibfile,
    &mm_winx64$writeexefile,
    &mm_winx64$writelibfile,
    &mm_winx64$writeasmfile,
    &mm_winx64$start,
    &mm_decls$start,
    &mm_diags$printoverloads,
    &mm_diags$printst,
    &mm_diags$printstrec,
    &mm_diags$printstflat,
    &mm_diags$printcode,
    &mm_diags$printunit,
    &mm_diags$printunitlist,
    &mm_diags$getprefix,
    &mm_diags$getlineinfok,
    &mm_diags$printmodelist,
    &mm_diags$showprojectinfo,
    &mm_diags$showlogfile,
    &mm_diags$showstflat,
    &mm_diags$showsttree,
    &mm_diags$showast,
    &mm_diags$printsymbol,
    &mm_diags$start,
    &mm_export$writeexports,
    &mm_export$exportstatic,
    &mm_export$exportconst,
    &mm_export$exportproc,
    &mm_export$wxstr,
    &mm_export$wxstrln,
    &mm_export$wxline,
    &mm_export$exportrecord,
    &mm_export$wxmode,
    &mm_export$start,
    &mm_lex$lexreadtoken,
    &mm_lex$lex,
    &mm_lex$lexsetup,
    &mm_lex$printstrn,
    &mm_lex$readrawstring,
    &mm_lex$lookup,
    &mm_lex$lookupsys,
    &mm_lex$gethashvaluez,
    &mm_lex$inithashtable,
    &mm_lex$printhashtable,
    &mm_lex$addreservedword,
    &mm_lex$dolexdirective,
    &mm_lex$startlex,
    &mm_lex$start,
    &mm_lex$addnamestr,
    &mm_lex$ps,
    &mm_lex$psnext,
    &mm_lex$psx,
    &mm_lex$stacksource,
    &mm_lex$unstacksource,
    &mm_lex$readarraystring,
    &mm_lex$setinttype,
    &mm_lex$readrawxname,
    &mm_lex$lxerror_s,
    &mm_lex$lxreadstring,
    &mm_lex$readdec,
    &mm_lex$readhex,
    &mm_lex$readoct,
    &mm_lex$readbin,
    &mm_lex$readreal,
    &mm_lib$newstrec,
    &mm_lib$getduplnameptr,
    &mm_lib$adddef,
    &mm_lib$createname,
    &mm_lib$createunit0,
    &mm_lib$createunit1,
    &mm_lib$createunit2,
    &mm_lib$createunit3,
    &mm_lib$insertunit,
    &mm_lib$deleteunit,
    &mm_lib$createconstunit,
    &mm_lib$createstringconstunit,
    &mm_lib$newtypename,
    &mm_lib$createusertype,
    &mm_lib$createusertypefromstr,
    &mm_lib$getrangelwbunit,
    &mm_lib$getrangeupbunit,
    &mm_lib$createarraymode,
    &mm_lib$sameunit,
    &mm_lib$createarraymodek,
    &mm_lib$nextautotype,
    &mm_lib$createslicemode,
    &mm_lib$createslicemodek,
    &mm_lib$createrefmode,
    &mm_lib$createrefprocmode,
    &mm_lib$copyttvalues,
    &mm_lib$getdottedname,
    &mm_lib$getavname,
    &mm_lib$unionstr_clear,
    &mm_lib$unionstr_append,
    &mm_lib$unionstr_concat,
    &mm_lib$unionstr_last,
    &mm_lib$unionstr_copy,
    &mm_lib$createrecordmode,
    &mm_lib$createtuplemode,
    &mm_lib$convertstring,
    &mm_lib$strexpr,
    &mm_lib$jevalx,
    &mm_lib$strmode,
    &mm_lib$strmode2,
    &mm_lib$istrmode,
    &mm_lib$addtoproclist,
    &mm_lib$addstatic,
    &mm_lib$addexpconst,
    &mm_lib$typename,
    &mm_lib$allocunitrec,
    &mm_lib$createdupldef,
    &mm_lib$createnewmoduledef,
    &mm_lib$duplunit,
    &mm_lib$checkblockreturn,
    &mm_lib$isconstunit,
    &mm_lib$getownername,
    &mm_lib$getalignment,
    &mm_lib$ispoweroftwo,
    &mm_lib$addlistunit,
    &mm_lib$storemode,
    &mm_lib$gettypebase,
    &mm_lib$writegsfile,
    &mm_lib$addtolog,
    &mm_lib$getprocretmodes,
    &mm_lib$getmemmode,
    &mm_lib$getpclmode,
    &mm_lib$getfullname,
    &mm_lib$getbasename,
    &mm_lib$start,
    &mm_libsources$findsyslib,
    &mm_libsources$start,
    &mm_modules$readprojectfile,
    &mm_modules$initheadervars,
    &mm_modules$readmoduledir,
    &mm_modules$checkwhen,
    &mm_modules$addmodule,
    &mm_modules$addsubprogram,
    &mm_modules$addfirstsubprogram,
    &mm_modules$readsubprogram,
    &mm_modules$readimport,
    &mm_modules$readinclude,
    &mm_modules$readvar,
    &mm_modules$fixpath,
    &mm_modules$dosetvar,
    &mm_modules$doshowvar,
    &mm_modules$setmixedprogram,
    &mm_modules$setmixedimport,
    &mm_modules$loadmodules,
    &mm_modules$loadmodule,
    &mm_modules$addsyslib,
    &mm_modules$addlib,
    &mm_modules$readfileline,
    &mm_modules$findnextlineheader,
    &mm_modules$loadmafile,
    &mm_modules$start,
    &mm_name$rx_typetable,
    &mm_name$rx_unit,
    &mm_name$rx_module,
    &mm_name$rx_deflist,
    &mm_name$rx_passdef,
    &mm_name$rx_unitlist,
    &mm_name$resolvetopname,
    &mm_name$resolvename,
    &mm_name$finddupl,
    &mm_name$finddupl_sub,
    &mm_name$resolvedot,
    &mm_name$fixmode,
    &mm_name$fixusertypes,
    &mm_name$addframevar,
    &mm_name$copylistunit,
    &mm_name$copyunit,
    &mm_name$replaceunit,
    &mm_name$expandmacro,
    &mm_name$duplfield,
    &mm_name$do_baseclass,
    &mm_name$start,
    &mm_parse$parsemodule,
    &mm_parse$readmoduledefs,
    &mm_parse$initparser,
    &mm_parse$skipsemi,
    &mm_parse$makeblock,
    &mm_parse$checkequals,
    &mm_parse$getcurrline,
    &mm_parse$checkbegin,
    &mm_parse$checkbeginend,
    &mm_parse$checkend,
    &mm_parse$readvardef,
    &mm_parse$readconstdef,
    &mm_parse$readlbrack,
    &mm_parse$addlistparam,
    &mm_parse$readcast,
    &mm_parse$readopc,
    &mm_parse$readsprint,
    &mm_parse$readsread,
    &mm_parse$readcompilervar,
    &mm_parse$readcastx,
    &mm_parse$checksymbol,
    &mm_parse$lexchecksymbol,
    &mm_parse$readtypespec,
    &mm_parse$readslicetype,
    &mm_parse$readslist,
    &mm_parse$readindex,
    &mm_parse$readdotsuffix,
    &mm_parse$readconstexpr,
    &mm_parse$readconstint,
    &mm_parse$readprocdef,
    &mm_parse$readprocdecl,
    &mm_parse$readparams,
    &mm_parse$readcondsuffix,
    &mm_parse$readif,
    &mm_parse$readgoto,
    &mm_parse$readunless,
    &mm_parse$readswitchcase,
    &mm_parse$readstop,
    &mm_parse$readreturn,
    &mm_parse$readdo,
    &mm_parse$readto,
    &mm_parse$readwhile,
    &mm_parse$readrepeat,
    &mm_parse$readloopcontrol,
    &mm_parse$readprint,
    &mm_parse$readread,
    &mm_parse$readfor,
    &mm_parse$readname,
    &mm_parse$readtypedef,
    &mm_parse$readrecordfields,
    &mm_parse$readtabledef,
    &mm_parse$readclassdef,
    &mm_parse$readclassbody,
    &mm_parse$readimportmodule,
    &mm_parse$readimportbody,
    &mm_parse$readequivfield,
    &mm_parse$readrefproc,
    &mm_parse$pushproc,
    &mm_parse$popproc,
    &mm_parse$makeastring,
    &mm_parse$readreturntype,
    &mm_parse$readset,
    &mm_parse$istypestarter,
    &mm_parse$readunit,
    &mm_parse$readassignment,
    &mm_parse$readorterms,
    &mm_parse$readandterms,
    &mm_parse$readcmpterms,
    &mm_parse$readinterms,
    &mm_parse$readrangeterm,
    &mm_parse$readaddterms,
    &mm_parse$readmulterms,
    &mm_parse$readpowerterms,
    &mm_parse$readterm2,
    &mm_parse$readterm,
    &mm_parse$readmacrodef,
    &mm_parse$readrecase,
    &mm_parse$adddocstring,
    &mm_parse$fixcond,
    &mm_parse$readsunit,
    &mm_parse$start,
    &mm_support$loadsourcefile,
    &mm_support$loadbundledfile,
    &mm_support$mcerror,
    &mm_support$serror_gen,
    &mm_support$showdivider,
    &mm_support$showerrorsource,
    &mm_support$stopcompiler,
    &mm_support$serror,
    &mm_support$serror_s,
    &mm_support$error_gen,
    &mm_support$rxerror,
    &mm_support$gerror,
    &mm_support$axerror,
    &mm_support$txerror,
    &mm_support$txerror_s,
    &mm_support$txerror_ss,
    &mm_support$rxerror_s,
    &mm_support$gerror_s,
    &mm_support$gerror_t,
    &mm_support$lxerror_gen,
    &mm_support$lxerror,
    &mm_support$loaderror,
    &mm_support$gs_additem,
    &mm_support$gs_copytostr,
    &mm_support$isalphanum,
    &mm_support$init_tt_tables,
    &mm_support$addspecialtypes,
    &mm_support$getsupportfile,
    &mm_support$isabspath,
    &mm_support$initbblib,
    &mm_support$getfileno,
    &mm_support$getlineno,
    &mm_support$getsourceline,
    &mm_support$getsourcestart,
    &mm_support$getsourcepos,
    &mm_support$do_writema,
    &mm_support$start,
    &mm_tables$start,
    &mm_type$tpass,
    &mm_type$tx_allprocs,
    &mm_type$tx_block,
    &mm_type$tx_typetable,
    &mm_type$setmodesize,
    &mm_type$setarraysize,
    &mm_type$setslicesize,
    &mm_type$tx_module,
    &mm_type$tx_passdef,
    &mm_type$tx_unitlist,
    &mm_type$tx_namedef,
    &mm_type$tx_namedconst,
    &mm_type$checkconstexpr,
    &mm_type$getconstint,
    &mm_type$makenewconst,
    &mm_type$tx_name,
    &mm_type$tx_bin,
    &mm_type$tx_binto,
    &mm_type$getdominantmode,
    &mm_type$tx_cmpchain,
    &mm_type$tx_callproc,
    &mm_type$tx_unary,
    &mm_type$tx_if,
    &mm_type$tx_incrto,
    &mm_type$tx_for,
    &mm_type$tx_forall,
    &mm_type$tx_index,
    &mm_type$tx_makerange,
    &mm_type$tx_ptr,
    &mm_type$setrecordsize,
    &mm_type$checkblocktype,
    &mm_type$scanrecord,
    &mm_type$roundoffset,
    &mm_type$tx_convert,
    &mm_type$tx_makelist,
    &mm_type$tx_makeslice,
    &mm_type$tx_makeset,
    &mm_type$tx_dot,
    &mm_type$resolvefield,
    &mm_type$tx_andl,
    &mm_type$convintconst,
    &mm_type$tx_sliceptr,
    &mm_type$tx_swap,
    &mm_type$tx_select,
    &mm_type$tx_case,
    &mm_type$tx_notl,
    &mm_type$tx_istruel,
    &mm_type$tx_typepun,
    &mm_type$tx_exit,
    &mm_type$tx_goto,
    &mm_type$tx_switch,
    &mm_type$tx_addroffirst,
    &mm_type$tx_return,
    &mm_type$tx_dotindex,
    &mm_type$tx_slice,
    &mm_type$twiden,
    &mm_type$tstringslice,
    &mm_type$tx_bitfield,
    &mm_type$deref,
    &mm_type$tmethodcall,
    &mm_type$do_bounds,
    &mm_type$addnotl,
    &mm_type$tevaluate,
    &mm_type$addrdotindex,
    &mm_type$tevalbinop,
    &mm_type$tevalmonop,
    &mm_type$iscondtrue,
    &mm_type$iscondfalse,
    &mm_type$fixchararray,
    &mm_type$combinestrings,
    &mm_type$tx_strinclude,
    &mm_type$coerceunit,
    &mm_type$getconversionop,
    &mm_type$applyconversion,
    &mm_type$checkmodes,
    &mm_type$comparemodes,
    &mm_type$tevalconvert,
    &mm_type$tx_assign,
    &mm_type$tx_assignmultmult,
    &mm_type$tx_assignmultscalar,
    &mm_type$tpasslv,
    &mm_type$dobinnumx,
    &mm_type$dobinnumf,
    &mm_type$dobinnumi,
    &mm_type$doin,
    &mm_type$setsimple,
    &mm_type$start,
    &mc_genmcl$codegen_mcl,
    &mc_genmcl$genprocdef,
    &mc_genmcl$dostaticvar,
    &mc_genmcl$genidata,
    &mc_genmcl$checkreturn,
    &mc_genmcl$genreturn,
    &mc_genmcl$genlocals,
    &mc_genmcl$spillparams,
    &mc_genmcl$genblocktemps,
    &mc_genmcl$docallproc,
    &mc_genmcl$genmaindef,
    &mc_genmcl$genstartdef,
    &mc_genmcl$newblocktemp,
    &mc_genmcl$setmclentry,
    &mc_genmcl$resetmclentry,
    &mc_genmcl$start,
    &mc_genss$genss,
    &mc_genss$doinstr,
    &mc_genss$genword,
    &mc_genss$gendword,
    &mc_genss$genqword,
    &mc_genss$genopnd,
    &mc_genss$addrelocitem,
    &mc_genss$getstindex,
    &mc_genss$genrel32,
    &mc_genss$getdef,
    &mc_genss$genabs32,
    &mc_genss$genabs64,
    &mc_genss$getrel32,
    &mc_genss$dofwdrefs,
    &mc_genss$genrex,
    &mc_genss$isbytesized,
    &mc_genss$isdwordsized,
    &mc_genss$do_push,
    &mc_genss$do_pop,
    &mc_genss$do_inc,
    &mc_genss$do_neg,
    &mc_genss$genamode,
    &mc_genss$setopsize,
    &mc_genss$getdispsize,
    &mc_genss$genrm,
    &mc_genss$makeam,
    &mc_genss$makemodrm,
    &mc_genss$do_arith,
    &mc_genss$do_mov,
    &mc_genss$getregcoder,
    &mc_genss$getregcodeb,
    &mc_genss$getregcodebx,
    &mc_genss$getregcoderx,
    &mc_genss$do_lea,
    &mc_genss$do_movsx,
    &mc_genss$checkhighreg,
    &mc_genss$do_exch,
    &mc_genss$do_movsxd,
    &mc_genss$do_imul2,
    &mc_genss$do_shift,
    &mc_genss$do_test,
    &mc_genss$do_loop,
    &mc_genss$do_jcxz,
    &mc_genss$do_setcc,
    &mc_genss$do_movxmm,
    &mc_genss$do_arithxmm,
    &mc_genss$do_logicxmm,
    &mc_genss$do_convertfloat,
    &mc_genss$do_fix,
    &mc_genss$do_float,
    &mc_genss$do_call,
    &mc_genss$do_jmp,
    &mc_genss$getcurrdatalen,
    &mc_genss$do_cmovcc,
    &mc_genss$do_fmem,
    &mc_genss$genrel8,
    &mc_genss$checkshortjump,
    &mc_genss$addfwdref,
    &mc_genss$switchseg,
    &mc_genss$do_movdqx,
    &mc_genss$do_popcnt,
    &mc_genss$do_bsf,
    &mc_genss$extendsymboltable,
    &mc_genss$fixregvar,
    &mc_genss$initlib,
    &mc_genss$buffercreate,
    &mc_genss$bufferexpand,
    &mc_genss$buffercheck,
    &mc_genss$bufferlength,
    &mc_genss$bufferelemptr,
    &mc_genss$addword,
    &mc_genss$adddword,
    &mc_genss$addqword,
    &mc_genss$start,
    &mc_libmcl$mclinit,
    &mc_libmcl$initmcdest,
    &mc_libmcl$genmc,
    &mc_libmcl$genmc_cond,
    &mc_libmcl$genmc_str,
    &mc_libmcl$newmclopnd,
    &mc_libmcl$duplopnd,
    &mc_libmcl$genxreg,
    &mc_libmcl$genindex,
    &mc_libmcl$getmclstr,
    &mc_libmcl$gencomment,
    &mc_libmcl$genstring,
    &mc_libmcl$gencommentstring,
    &mc_libmcl$genname,
    &mc_libmcl$writemcl,
    &mc_libmcl$strmcl,
    &mc_libmcl$asmopnd,
    &mc_libmcl$setsegment,
    &mc_libmcl$getsizeprefix,
    &mc_libmcl$needsizeprefix,
    &mc_libmcl$changeopndsize,
    &mc_libmcl$makeopndind,
    &mc_libmcl$applyoffset,
    &mc_libmcl$genint,
    &mc_libmcl$genrealmem,
    &mc_libmcl$genrealimm,
    &mc_libmcl$genlabel,
    &mc_libmcl$genlabelmem,
    &mc_libmcl$genregvar,
    &mc_libmcl$genxregvar,
    &mc_libmcl$genmem,
    &mc_libmcl$genmemaddr,
    &mc_libmcl$genreg,
    &mc_libmcl$genreg0,
    &mc_libmcl$genireg,
    &mc_libmcl$roundsizetg,
    &mc_libmcl$getregname,
    &mc_libmcl$getxregname,
    &mc_libmcl$sameoperand,
    &mc_libmcl$sameregopnd,
    &mc_libmcl$getstringindex,
    &mc_libmcl$addconst,
    &mc_libmcl$getrealindex,
    &mc_libmcl$getreal32index,
    &mc_libmcl$asmstr,
    &mc_libmcl$asmchar,
    &mc_libmcl$getdispname,
    &mc_libmcl$merror,
    &mc_libmcl$merrort,
    &mc_libmcl$genstringtable,
    &mc_libmcl$genstringimm,
    &mc_libmcl$gendb,
    &mc_libmcl$gendbstring,
    &mc_libmcl$gendq,
    &mc_libmcl$genrealtable,
    &mc_libmcl$genabsneg,
    &mc_libmcl$createfwdlabel,
    &mc_libmcl$definefwdlabel,
    &mc_libmcl$definelabel,
    &mc_libmcl$stropnd,
    &mc_libmcl$strreg,
    &mc_libmcl$checkregvar,
    &mc_libmcl$strvalue,
    &mc_libmcl$makesimpleaddr,
    &mc_libmcl$makeblockaddr,
    &mc_libmcl$clearblock,
    &mc_libmcl$copyblock,
    &mc_libmcl$genfunctable,
    &mc_libmcl$genextname,
    &mc_libmcl$domcl_assem,
    &mc_libmcl$genasmopnd,
    &mc_libmcl$getnextreg,
    &mc_libmcl$getnextxreg,
    &mc_libmcl$pushstack,
    &mc_libmcl$popstack,
    &mc_libmcl$showregset,
    &mc_libmcl$stacklooplabels,
    &mc_libmcl$findlooplabel,
    &mc_libmcl$getopndmov,
    &mc_libmcl$getregopnd,
    &mc_libmcl$getmclcond,
    &mc_libmcl$popregs,
    &mc_libmcl$getlowreg,
    &mc_libmcl$mulimm,
    &mc_libmcl$scaleindex,
    &mc_libmcl$gensysfn,
    &mc_libmcl$gensysproc,
    &mc_libmcl$getsysfnhandler,
    &mc_libmcl$setbit,
    &mc_libmcl$getbit,
    &mc_libmcl$setregbit,
    &mc_libmcl$clrregbit,
    &mc_libmcl$getregbit,
    &mc_libmcl$setxregbit,
    &mc_libmcl$clrxregbit,
    &mc_libmcl$getxregbit,
    &mc_libmcl$setopndsize,
    &mc_libmcl$getretopnd,
    &mc_libmcl$start,
    &mc_decls$start,
    &mc_objdecls$start,
    &mc_run$writememlib,
    &mc_run$roundsegment,
    &mc_run$writerelocs,
    &mc_run$addsymbols,
    &mc_run$start,
    &mc_write$writemcx,
    &mc_write$writerelocs,
    &mc_write$countsymbols,
    &mc_write$writesymbols,
    &mc_write$roundsegment,
    &mc_write$genbyte,
    &mc_write$genword32,
    &mc_write$genstring,
    &mc_write$genblock,
    &mc_write$start,
    &mc_writeexe$writeexe,
    &mc_writeexe$genexe,
    &mc_writeexe$loadlibs,
    &mc_writeexe$initsectiontable,
    &mc_writeexe$extractlibname,
    &mc_writeexe$scanst,
    &mc_writeexe$relocdata,
    &mc_writeexe$getbaserelocs,
    &mc_writeexe$writerecordx,
    &mc_writeexe$writedosstub,
    &mc_writeexe$writepesig,
    &mc_writeexe$writepadding,
    &mc_writeexe$writefileheader,
    &mc_writeexe$writeoptheader,
    &mc_writeexe$writesectionheader,
    &mc_writeexe$writesectiondata,
    &mc_writeexe$writeexporttable,
    &mc_writeexe$getexporttablesize,
    &mc_writeexe$newbasereloc,
    &mc_writeexe$scanbaserelocs,
    &mc_writeexe$writebasereloctable,
    &mc_writeexe$sortexports,
    &mc_writeexe$getsectionno,
    &mc_writeexe$getoffsets,
    &mc_writeexe$start,
    &mx_decls$start,
    &mx_lib$readlibfile,
    &mx_lib$readbyte,
    &mx_lib$readu32,
    &mx_lib$readstring,
    &mx_lib$alloclibdata,
    &mx_lib$error,
    &mx_lib$loadmemmcu,
    &mx_lib$checknew,
    &mx_lib$findlib,
    &mx_lib$mxaddlib,
    &mx_lib$fixuplib,
    &mx_lib$loaddlls,
    &mx_lib$finddllsymbol,
    &mx_lib$checksymbols,
    &mx_lib$dorelocations,
    &mx_lib$reloclib,
    &mx_lib$loadimports,
    &mx_lib$dosublib,
    &mx_lib$loadlibfile,
    &mx_lib$dosymbols,
    &mx_lib$readmxfile,
    &mx_lib$adddll,
    &mx_lib$addsymbol,
    &mx_lib$setspecialglobals,
    &mx_lib$runprogram,
    &mx_lib$calllibinit,
    &mx_lib$findsymbol,
    &mx_lib$loadmx,
    &mx_lib$loadmemmcb,
    &mx_lib$mltest,
    &mx_lib$start,
    &mx_show$initlogfile,
    &mx_show$closelogfile,
    &mx_show$showlibs,
    &mx_show$showlib,
    &mx_show$showstr,
    &mx_show$showstrln,
    &mx_show$showstrint,
    &mx_show$shownames,
    &mx_show$showrelocs,
    &mx_show$showsectiondata,
    &mx_show$showsectioncode,
    &mx_show$showglobals,
    &mx_show$start,
    &msysc$m_init,
    &msysc$m_getdotindex,
    &msysc$m_setdotindex,
    &msysc$m_getdotslice,
    &msysc$m_setdotslice,
    &msysc$m_get_nprocs,
    &msysc$m_get_nexports,
    &msysc$m_get_procname,
    &msysc$m_get_procaddr,
    &msysc$m_get_procexport,
    &msysc$pushio,
    &msysc$m_print_startfile,
    &msysc$m_print_startstr,
    &msysc$m_print_startptr,
    &msysc$m_print_startcon,
    &msysc$m_print_setfmt,
    &msysc$m_print_end,
    &msysc$m_print_ptr,
    &msysc$m_print_i64,
    &msysc$m_print_u64,
    &msysc$m_print_r64,
    &msysc$m_print_r32,
    &msysc$m_print_c8,
    &msysc$m_print_str,
    &msysc$m_print_newline,
    &msysc$m_print_nogap,
    &msysc$m_print_space,
    &msysc$printstr,
    &msysc$printstr_n,
    &msysc$printstrn_app,
    &msysc$makezstring,
    &msysc$freezstring,
    &msysc$printchar,
    &msysc$nextfmtchars,
    &msysc$strtofmt,
    &msysc$domultichar,
    &msysc$expandstr,
    &msysc$u64tostr,
    &msysc$i64tostrfmt,
    &msysc$u64tostrfmt,
    &msysc$i64mintostr,
    &msysc$strtostrfmt,
    &msysc$tostr_i64,
    &msysc$tostr_u64,
    &msysc$tostr_r64,
    &msysc$tostr_str,
    &msysc$getfmt,
    &msysc$strint,
    &msysc$getstrint,
    &msysc$strword,
    &msysc$strreal,
    &msysc$getstr,
    &msysc$initreadbuffer,
    &msysc$m_read_conline,
    &msysc$m_read_fileline,
    &msysc$m_read_strline,
    &msysc$readitem,
    &msysc$strtoint,
    &msysc$m_read_i64,
    &msysc$m_read_r64,
    &msysc$m_read_str,
    &msysc$readstr,
    &msysc$rereadln,
    &msysc$reread,
    &msysc$valint,
    &msysc$valreal,
    &msysc$iconvlcn,
    &msysc$iconvucn,
    &msysc$convlcstring,
    &msysc$convucstring,
    &msysc$m_power_i64,
    &msysc$m_intoverflow,
    &msysc$m_dotindex,
    &msysc$m_dotslice,
    &msysc$m_popdotindex,
    &msysc$m_popdotslice,
    &msysc$m_imin,
    &msysc$m_imax,
    &msysc$m_sign,
    &msysc$m_tp_i64tor64,
    &msysc$m_tp_r64toi64,
    &msysc$m_tp_reftoi64,
    &msysc$m_tp_i64toref,
    &msysc$start,
    &mlib$pcm_alloc,
    &mlib$pcm_free,
    &mlib$pcm_freeac,
    &mlib$pcm_clearmem,
    &mlib$pcm_init,
    &mlib$pcm_getac,
    &mlib$pcm_newblock,
    &mlib$pcm_round,
    &mlib$pcm_allocz,
    &mlib$pcm_copyheapstring,
    &mlib$pcm_copyheapstringn,
    &mlib$pcm_copyheapblock,
    &mlib$addtomemalloc,
    &mlib$removefrommemalloc,
    &mlib$allocmem,
    &mlib$reallocmem,
    &mlib$abortprogram,
    &mlib$getfilesize,
    &mlib$readrandom,
    &mlib$writerandom,
    &mlib$setfilepos,
    &mlib$getfilepos,
    &mlib$readfile,
    &mlib$writefile,
    &mlib$checkfile,
    &mlib$readlinen,
    &mlib$iconvlcn,
    &mlib$iconvucn,
    &mlib$convlcstring,
    &mlib$convucstring,
    &mlib$changeext,
    &mlib$extractext,
    &mlib$extractpath,
    &mlib$extractfile,
    &mlib$extractbasefile,
    &mlib$addext,
    &mlib$pcm_alloc32,
    &mlib$pcm_free32,
    &mlib$pcm_alloc64,
    &mlib$pcm_free64,
    &mlib$pcm_alloc16,
    &mlib$pcm_free16,
    &mlib$outbyte,
    &mlib$outword16,
    &mlib$outword32,
    &mlib$outword64,
    &mlib$outstring,
    &mlib$outblock,
    &mlib$myeof,
    &mlib$strbuffer_add,
    &mlib$gs_init,
    &mlib$gs_free,
    &mlib$gs_str,
    &mlib$gs_char,
    &mlib$gs_strn,
    &mlib$gs_strvar,
    &mlib$gs_strint,
    &mlib$gs_strln,
    &mlib$gs_strsp,
    &mlib$gs_line,
    &mlib$gs_getcol,
    &mlib$gs_leftstr,
    &mlib$gs_leftint,
    &mlib$gs_padto,
    &mlib$gs_println,
    &mlib$nextcmdparamnew,
    &mlib$readnextfileitem,
    &mlib$ipadstr,
    &mlib$padstr,
    &mlib$chr,
    &mlib$cmpstring,
    &mlib$cmpstringn,
    &mlib$eqstring,
    &mlib$cmpbytes,
    &mlib$eqbytes,
    &mlib$mseed,
    &mlib$mrandom,
    &mlib$mrandomp,
    &mlib$mrandomint,
    &mlib$mrandomrange,
    &mlib$mrandomreal,
    &mlib$mrandomreal1,
    &mlib$checkpackfile,
    &mlib$readline,
    &mlib$findfunction,
    &mlib$roundtoblock,
    &mlib$start,
    &mclib$start,
    &mlinux$os_init,
    &mlinux$os_execwait,
    &mlinux$os_execcmd,
    &mlinux$os_getch,
    &mlinux$os_kbhit,
    &mlinux$os_flushkeys,
    &mlinux$os_getconsolein,
    &mlinux$os_getconsoleout,
    &mlinux$os_proginstance,
    &mlinux$os_getdllinst,
    &mlinux$os_getdllprocaddr,
    &mlinux$os_initwindows,
    &mlinux$os_getchx,
    &mlinux$os_getos,
    &mlinux$os_gethostsize,
    &mlinux$os_iswindows,
    &mlinux$os_shellexec,
    &mlinux$os_sleep,
    &mlinux$os_getstdin,
    &mlinux$os_getstdout,
    &mlinux$os_gethostname,
    &mlinux$os_getmpath,
    &mlinux$os_exitprocess,
    &mlinux$os_clock,
    &mlinux$os_ticks,
    &mlinux$os_getclockspersec,
    &mlinux$os_setmesshandler,
    &mlinux$os_hpcounter,
    &mlinux$os_hpfrequency,
    &mlinux$os_filelastwritetime,
    &mlinux$os_getsystime,
    &mlinux$os_peek,
    &mlinux$os_allocexecmem,
    &mlinux$start,
    &mwindllc$os_calldllfunction,
    &mwindllc$os_pushargs,
    &mwindllc$calldll_cint,
    &mwindllc$calldll_creal,
    &mwindllc$os_dummycall,
    &mwindllc$start,
0};
static u8 *  msysc$_fnnames[]= {
    (byte*)"main",
    (byte*)"do_loadmodules",
    (byte*)"do_parse",
    (byte*)"do_name",
    (byte*)"do_type",
    (byte*)"initdata",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"showcaption",
    (byte*)"showhelp",
    (byte*)"initassemsymbols",
    (byte*)"do_writeexports",
    (byte*)"getoutfilename",
    (byte*)"fixstartprocs",
    (byte*)"addstartproc",
    (byte*)"stepruncount",
    (byte*)"start",
    (byte*)"readassemline",
    (byte*)"readassemblock",
    (byte*)"assembleline",
    (byte*)"readassemopnd",
    (byte*)"start",
    (byte*)"loadunit",
    (byte*)"evalunit",
    (byte*)"loadref",
    (byte*)"pushunit",
    (byte*)"poptoreg",
    (byte*)"poptoarg",
    (byte*)"loadarg",
    (byte*)"loadbin",
    (byte*)"loadbinto",
    (byte*)"do_const",
    (byte*)"do_name",
    (byte*)"genjumpl",
    (byte*)"do_assign",
    (byte*)"loadmem",
    (byte*)"loadmemaddr",
    (byte*)"storemem",
    (byte*)"do_bin",
    (byte*)"do_unary",
    (byte*)"do_labeldef",
    (byte*)"do_goto",
    (byte*)"do_to",
    (byte*)"docond",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"reversecond",
    (byte*)"setmultopnd",
    (byte*)"do_if",
    (byte*)"do_andl",
    (byte*)"do_orl",
    (byte*)"do_notl",
    (byte*)"do_istruel",
    (byte*)"do_ptr",
    (byte*)"do_index",
    (byte*)"mulreg",
    (byte*)"do_dot",
    (byte*)"getaddrmode",
    (byte*)"do_while",
    (byte*)"do_repeat",
    (byte*)"do_incr",
    (byte*)"do_incrstep",
    (byte*)"do_incrload",
    (byte*)"do_for",
    (byte*)"do_forall",
    (byte*)"do_print",
    (byte*)"do_callproc",
    (byte*)"do_stop",
    (byte*)"do_do",
    (byte*)"do_exit",
    (byte*)"do_swap",
    (byte*)"saverdx",
    (byte*)"restorerdx",
    (byte*)"do_divrem",
    (byte*)"fixdivopnds",
    (byte*)"do_shift",
    (byte*)"do_convert",
    (byte*)"do_clear",
    (byte*)"do_case",
    (byte*)"do_switch",
    (byte*)"do_binto",
    (byte*)"do_bintomem",
    (byte*)"do_bintoreg",
    (byte*)"do_return",
    (byte*)"do_returnmult",
    (byte*)"do_addrefoffto",
    (byte*)"domaxto_int",
    (byte*)"do_setcc",
    (byte*)"do_read",
    (byte*)"do_readln",
    (byte*)"do_syscall",
    (byte*)"do_dotindex",
    (byte*)"do_dotslice",
    (byte*)"do_typepun",
    (byte*)"do_shiftnto",
    (byte*)"do_select",
    (byte*)"do_setccchain",
    (byte*)"do_maths",
    (byte*)"do_maths2",
    (byte*)"do_callext",
    (byte*)"do_storedotindex",
    (byte*)"do_storedotslice",
    (byte*)"do_slice",
    (byte*)"do_assignms",
    (byte*)"start",
    (byte*)"codegen",
    (byte*)"runlibfile",
    (byte*)"writeexefile",
    (byte*)"writelibfile",
    (byte*)"writeasmfile",
    (byte*)"start",
    (byte*)"start",
    (byte*)"printoverloads",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"printstflat",
    (byte*)"printcode",
    (byte*)"printunit",
    (byte*)"printunitlist",
    (byte*)"getprefix",
    (byte*)"getlineinfok",
    (byte*)"printmodelist",
    (byte*)"showprojectinfo",
    (byte*)"showlogfile",
    (byte*)"showstflat",
    (byte*)"showsttree",
    (byte*)"showast",
    (byte*)"printsymbol",
    (byte*)"start",
    (byte*)"writeexports",
    (byte*)"exportstatic",
    (byte*)"exportconst",
    (byte*)"exportproc",
    (byte*)"wxstr",
    (byte*)"wxstrln",
    (byte*)"wxline",
    (byte*)"exportrecord",
    (byte*)"wxmode",
    (byte*)"start",
    (byte*)"lexreadtoken",
    (byte*)"lex",
    (byte*)"lexsetup",
    (byte*)"printstrn",
    (byte*)"readrawstring",
    (byte*)"lookup",
    (byte*)"lookupsys",
    (byte*)"gethashvaluez",
    (byte*)"inithashtable",
    (byte*)"printhashtable",
    (byte*)"addreservedword",
    (byte*)"dolexdirective",
    (byte*)"startlex",
    (byte*)"start",
    (byte*)"addnamestr",
    (byte*)"ps",
    (byte*)"psnext",
    (byte*)"psx",
    (byte*)"stacksource",
    (byte*)"unstacksource",
    (byte*)"readarraystring",
    (byte*)"setinttype",
    (byte*)"readrawxname",
    (byte*)"lxerror_s",
    (byte*)"lxreadstring",
    (byte*)"readdec",
    (byte*)"readhex",
    (byte*)"readoct",
    (byte*)"readbin",
    (byte*)"readreal",
    (byte*)"newstrec",
    (byte*)"getduplnameptr",
    (byte*)"adddef",
    (byte*)"createname",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createunit3",
    (byte*)"insertunit",
    (byte*)"deleteunit",
    (byte*)"createconstunit",
    (byte*)"createstringconstunit",
    (byte*)"newtypename",
    (byte*)"createusertype",
    (byte*)"createusertypefromstr",
    (byte*)"getrangelwbunit",
    (byte*)"getrangeupbunit",
    (byte*)"createarraymode",
    (byte*)"sameunit",
    (byte*)"createarraymodek",
    (byte*)"nextautotype",
    (byte*)"createslicemode",
    (byte*)"createslicemodek",
    (byte*)"createrefmode",
    (byte*)"createrefprocmode",
    (byte*)"copyttvalues",
    (byte*)"getdottedname",
    (byte*)"getavname",
    (byte*)"unionstr_clear",
    (byte*)"unionstr_append",
    (byte*)"unionstr_concat",
    (byte*)"unionstr_last",
    (byte*)"unionstr_copy",
    (byte*)"createrecordmode",
    (byte*)"createtuplemode",
    (byte*)"convertstring",
    (byte*)"strexpr",
    (byte*)"jevalx",
    (byte*)"strmode",
    (byte*)"strmode2",
    (byte*)"istrmode",
    (byte*)"addtoproclist",
    (byte*)"addstatic",
    (byte*)"addexpconst",
    (byte*)"typename",
    (byte*)"allocunitrec",
    (byte*)"createdupldef",
    (byte*)"createnewmoduledef",
    (byte*)"duplunit",
    (byte*)"checkblockreturn",
    (byte*)"isconstunit",
    (byte*)"getownername",
    (byte*)"getalignment",
    (byte*)"ispoweroftwo",
    (byte*)"addlistunit",
    (byte*)"storemode",
    (byte*)"gettypebase",
    (byte*)"writegsfile",
    (byte*)"addtolog",
    (byte*)"getprocretmodes",
    (byte*)"getmemmode",
    (byte*)"getpclmode",
    (byte*)"getfullname",
    (byte*)"getbasename",
    (byte*)"start",
    (byte*)"findsyslib",
    (byte*)"start",
    (byte*)"readprojectfile",
    (byte*)"initheadervars",
    (byte*)"readmoduledir",
    (byte*)"checkwhen",
    (byte*)"addmodule",
    (byte*)"addsubprogram",
    (byte*)"addfirstsubprogram",
    (byte*)"readsubprogram",
    (byte*)"readimport",
    (byte*)"readinclude",
    (byte*)"readvar",
    (byte*)"fixpath",
    (byte*)"dosetvar",
    (byte*)"doshowvar",
    (byte*)"setmixedprogram",
    (byte*)"setmixedimport",
    (byte*)"loadmodules",
    (byte*)"loadmodule",
    (byte*)"addsyslib",
    (byte*)"addlib",
    (byte*)"readfileline",
    (byte*)"findnextlineheader",
    (byte*)"loadmafile",
    (byte*)"start",
    (byte*)"rx_typetable",
    (byte*)"rx_unit",
    (byte*)"rx_module",
    (byte*)"rx_deflist",
    (byte*)"rx_passdef",
    (byte*)"rx_unitlist",
    (byte*)"resolvetopname",
    (byte*)"resolvename",
    (byte*)"finddupl",
    (byte*)"finddupl_sub",
    (byte*)"resolvedot",
    (byte*)"fixmode",
    (byte*)"fixusertypes",
    (byte*)"addframevar",
    (byte*)"copylistunit",
    (byte*)"copyunit",
    (byte*)"replaceunit",
    (byte*)"expandmacro",
    (byte*)"duplfield",
    (byte*)"do_baseclass",
    (byte*)"start",
    (byte*)"parsemodule",
    (byte*)"readmoduledefs",
    (byte*)"initparser",
    (byte*)"skipsemi",
    (byte*)"makeblock",
    (byte*)"checkequals",
    (byte*)"getcurrline",
    (byte*)"checkbegin",
    (byte*)"checkbeginend",
    (byte*)"checkend",
    (byte*)"readvardef",
    (byte*)"readconstdef",
    (byte*)"readlbrack",
    (byte*)"addlistparam",
    (byte*)"readcast",
    (byte*)"readopc",
    (byte*)"readsprint",
    (byte*)"readsread",
    (byte*)"readcompilervar",
    (byte*)"readcastx",
    (byte*)"checksymbol",
    (byte*)"lexchecksymbol",
    (byte*)"readtypespec",
    (byte*)"readslicetype",
    (byte*)"readslist",
    (byte*)"readindex",
    (byte*)"readdotsuffix",
    (byte*)"readconstexpr",
    (byte*)"readconstint",
    (byte*)"readprocdef",
    (byte*)"readprocdecl",
    (byte*)"readparams",
    (byte*)"readcondsuffix",
    (byte*)"readif",
    (byte*)"readgoto",
    (byte*)"readunless",
    (byte*)"readswitchcase",
    (byte*)"readstop",
    (byte*)"readreturn",
    (byte*)"readdo",
    (byte*)"readto",
    (byte*)"readwhile",
    (byte*)"readrepeat",
    (byte*)"readloopcontrol",
    (byte*)"readprint",
    (byte*)"readread",
    (byte*)"readfor",
    (byte*)"readname",
    (byte*)"readtypedef",
    (byte*)"readrecordfields",
    (byte*)"readtabledef",
    (byte*)"readclassdef",
    (byte*)"readclassbody",
    (byte*)"readimportmodule",
    (byte*)"readimportbody",
    (byte*)"readequivfield",
    (byte*)"readrefproc",
    (byte*)"pushproc",
    (byte*)"popproc",
    (byte*)"makeastring",
    (byte*)"readreturntype",
    (byte*)"readset",
    (byte*)"istypestarter",
    (byte*)"readunit",
    (byte*)"readassignment",
    (byte*)"readorterms",
    (byte*)"readandterms",
    (byte*)"readcmpterms",
    (byte*)"readinterms",
    (byte*)"readrangeterm",
    (byte*)"readaddterms",
    (byte*)"readmulterms",
    (byte*)"readpowerterms",
    (byte*)"readterm2",
    (byte*)"readterm",
    (byte*)"readmacrodef",
    (byte*)"readrecase",
    (byte*)"adddocstring",
    (byte*)"fixcond",
    (byte*)"readsunit",
    (byte*)"start",
    (byte*)"loadsourcefile",
    (byte*)"loadbundledfile",
    (byte*)"mcerror",
    (byte*)"serror_gen",
    (byte*)"showdivider",
    (byte*)"showerrorsource",
    (byte*)"stopcompiler",
    (byte*)"serror",
    (byte*)"serror_s",
    (byte*)"error_gen",
    (byte*)"rxerror",
    (byte*)"gerror",
    (byte*)"axerror",
    (byte*)"txerror",
    (byte*)"txerror_s",
    (byte*)"txerror_ss",
    (byte*)"rxerror_s",
    (byte*)"gerror_s",
    (byte*)"gerror_t",
    (byte*)"lxerror_gen",
    (byte*)"lxerror",
    (byte*)"loaderror",
    (byte*)"gs_additem",
    (byte*)"gs_copytostr",
    (byte*)"isalphanum",
    (byte*)"init_tt_tables",
    (byte*)"addspecialtypes",
    (byte*)"getsupportfile",
    (byte*)"isabspath",
    (byte*)"initbblib",
    (byte*)"getfileno",
    (byte*)"getlineno",
    (byte*)"getsourceline",
    (byte*)"getsourcestart",
    (byte*)"getsourcepos",
    (byte*)"do_writema",
    (byte*)"start",
    (byte*)"start",
    (byte*)"tpass",
    (byte*)"tx_allprocs",
    (byte*)"tx_block",
    (byte*)"tx_typetable",
    (byte*)"setmodesize",
    (byte*)"setarraysize",
    (byte*)"setslicesize",
    (byte*)"tx_module",
    (byte*)"tx_passdef",
    (byte*)"tx_unitlist",
    (byte*)"tx_namedef",
    (byte*)"tx_namedconst",
    (byte*)"checkconstexpr",
    (byte*)"getconstint",
    (byte*)"makenewconst",
    (byte*)"tx_name",
    (byte*)"tx_bin",
    (byte*)"tx_binto",
    (byte*)"getdominantmode",
    (byte*)"tx_cmpchain",
    (byte*)"tx_callproc",
    (byte*)"tx_unary",
    (byte*)"tx_if",
    (byte*)"tx_incrto",
    (byte*)"tx_for",
    (byte*)"tx_forall",
    (byte*)"tx_index",
    (byte*)"tx_makerange",
    (byte*)"tx_ptr",
    (byte*)"setrecordsize",
    (byte*)"checkblocktype",
    (byte*)"scanrecord",
    (byte*)"roundoffset",
    (byte*)"tx_convert",
    (byte*)"tx_makelist",
    (byte*)"tx_makeslice",
    (byte*)"tx_makeset",
    (byte*)"tx_dot",
    (byte*)"resolvefield",
    (byte*)"tx_andl",
    (byte*)"convintconst",
    (byte*)"tx_sliceptr",
    (byte*)"tx_swap",
    (byte*)"tx_select",
    (byte*)"tx_case",
    (byte*)"tx_notl",
    (byte*)"tx_istruel",
    (byte*)"tx_typepun",
    (byte*)"tx_exit",
    (byte*)"tx_goto",
    (byte*)"tx_switch",
    (byte*)"tx_addroffirst",
    (byte*)"tx_return",
    (byte*)"tx_dotindex",
    (byte*)"tx_slice",
    (byte*)"twiden",
    (byte*)"tstringslice",
    (byte*)"tx_bitfield",
    (byte*)"deref",
    (byte*)"tmethodcall",
    (byte*)"do_bounds",
    (byte*)"addnotl",
    (byte*)"tevaluate",
    (byte*)"addrdotindex",
    (byte*)"tevalbinop",
    (byte*)"tevalmonop",
    (byte*)"iscondtrue",
    (byte*)"iscondfalse",
    (byte*)"fixchararray",
    (byte*)"combinestrings",
    (byte*)"tx_strinclude",
    (byte*)"coerceunit",
    (byte*)"getconversionop",
    (byte*)"applyconversion",
    (byte*)"checkmodes",
    (byte*)"comparemodes",
    (byte*)"tevalconvert",
    (byte*)"tx_assign",
    (byte*)"tx_assignmultmult",
    (byte*)"tx_assignmultscalar",
    (byte*)"tpasslv",
    (byte*)"dobinnumx",
    (byte*)"dobinnumf",
    (byte*)"dobinnumi",
    (byte*)"doin",
    (byte*)"setsimple",
    (byte*)"start",
    (byte*)"codegen_mcl",
    (byte*)"genprocdef",
    (byte*)"dostaticvar",
    (byte*)"genidata",
    (byte*)"checkreturn",
    (byte*)"genreturn",
    (byte*)"genlocals",
    (byte*)"spillparams",
    (byte*)"genblocktemps",
    (byte*)"docallproc",
    (byte*)"genmaindef",
    (byte*)"genstartdef",
    (byte*)"newblocktemp",
    (byte*)"setmclentry",
    (byte*)"resetmclentry",
    (byte*)"start",
    (byte*)"genss",
    (byte*)"doinstr",
    (byte*)"genword",
    (byte*)"gendword",
    (byte*)"genqword",
    (byte*)"genopnd",
    (byte*)"addrelocitem",
    (byte*)"getstindex",
    (byte*)"genrel32",
    (byte*)"getdef",
    (byte*)"genabs32",
    (byte*)"genabs64",
    (byte*)"getrel32",
    (byte*)"dofwdrefs",
    (byte*)"genrex",
    (byte*)"isbytesized",
    (byte*)"isdwordsized",
    (byte*)"do_push",
    (byte*)"do_pop",
    (byte*)"do_inc",
    (byte*)"do_neg",
    (byte*)"genamode",
    (byte*)"setopsize",
    (byte*)"getdispsize",
    (byte*)"genrm",
    (byte*)"makeam",
    (byte*)"makemodrm",
    (byte*)"do_arith",
    (byte*)"do_mov",
    (byte*)"getregcoder",
    (byte*)"getregcodeb",
    (byte*)"getregcodebx",
    (byte*)"getregcoderx",
    (byte*)"do_lea",
    (byte*)"do_movsx",
    (byte*)"checkhighreg",
    (byte*)"do_exch",
    (byte*)"do_movsxd",
    (byte*)"do_imul2",
    (byte*)"do_shift",
    (byte*)"do_test",
    (byte*)"do_loop",
    (byte*)"do_jcxz",
    (byte*)"do_setcc",
    (byte*)"do_movxmm",
    (byte*)"do_arithxmm",
    (byte*)"do_logicxmm",
    (byte*)"do_convertfloat",
    (byte*)"do_fix",
    (byte*)"do_float",
    (byte*)"do_call",
    (byte*)"do_jmp",
    (byte*)"getcurrdatalen",
    (byte*)"do_cmovcc",
    (byte*)"do_fmem",
    (byte*)"genrel8",
    (byte*)"checkshortjump",
    (byte*)"addfwdref",
    (byte*)"switchseg",
    (byte*)"do_movdqx",
    (byte*)"do_popcnt",
    (byte*)"do_bsf",
    (byte*)"extendsymboltable",
    (byte*)"fixregvar",
    (byte*)"initlib",
    (byte*)"buffercreate",
    (byte*)"bufferexpand",
    (byte*)"buffercheck",
    (byte*)"bufferlength",
    (byte*)"bufferelemptr",
    (byte*)"addword",
    (byte*)"adddword",
    (byte*)"addqword",
    (byte*)"start",
    (byte*)"mclinit",
    (byte*)"initmcdest",
    (byte*)"genmc",
    (byte*)"genmc_cond",
    (byte*)"genmc_str",
    (byte*)"newmclopnd",
    (byte*)"duplopnd",
    (byte*)"genxreg",
    (byte*)"genindex",
    (byte*)"getmclstr",
    (byte*)"gencomment",
    (byte*)"genstring",
    (byte*)"gencommentstring",
    (byte*)"genname",
    (byte*)"writemcl",
    (byte*)"strmcl",
    (byte*)"asmopnd",
    (byte*)"setsegment",
    (byte*)"getsizeprefix",
    (byte*)"needsizeprefix",
    (byte*)"changeopndsize",
    (byte*)"makeopndind",
    (byte*)"applyoffset",
    (byte*)"genint",
    (byte*)"genrealmem",
    (byte*)"genrealimm",
    (byte*)"genlabel",
    (byte*)"genlabelmem",
    (byte*)"genregvar",
    (byte*)"genxregvar",
    (byte*)"genmem",
    (byte*)"genmemaddr",
    (byte*)"genreg",
    (byte*)"genreg0",
    (byte*)"genireg",
    (byte*)"roundsizetg",
    (byte*)"getregname",
    (byte*)"getxregname",
    (byte*)"sameoperand",
    (byte*)"sameregopnd",
    (byte*)"getstringindex",
    (byte*)"addconst",
    (byte*)"getrealindex",
    (byte*)"getreal32index",
    (byte*)"asmstr",
    (byte*)"asmchar",
    (byte*)"getdispname",
    (byte*)"merror",
    (byte*)"merrort",
    (byte*)"genstringtable",
    (byte*)"genstringimm",
    (byte*)"gendb",
    (byte*)"gendbstring",
    (byte*)"gendq",
    (byte*)"genrealtable",
    (byte*)"genabsneg",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"definelabel",
    (byte*)"stropnd",
    (byte*)"strreg",
    (byte*)"checkregvar",
    (byte*)"strvalue",
    (byte*)"makesimpleaddr",
    (byte*)"makeblockaddr",
    (byte*)"clearblock",
    (byte*)"copyblock",
    (byte*)"genfunctable",
    (byte*)"genextname",
    (byte*)"domcl_assem",
    (byte*)"genasmopnd",
    (byte*)"getnextreg",
    (byte*)"getnextxreg",
    (byte*)"pushstack",
    (byte*)"popstack",
    (byte*)"showregset",
    (byte*)"stacklooplabels",
    (byte*)"findlooplabel",
    (byte*)"getopndmov",
    (byte*)"getregopnd",
    (byte*)"getmclcond",
    (byte*)"popregs",
    (byte*)"getlowreg",
    (byte*)"mulimm",
    (byte*)"scaleindex",
    (byte*)"gensysfn",
    (byte*)"gensysproc",
    (byte*)"getsysfnhandler",
    (byte*)"setbit",
    (byte*)"getbit",
    (byte*)"setregbit",
    (byte*)"clrregbit",
    (byte*)"getregbit",
    (byte*)"setxregbit",
    (byte*)"clrxregbit",
    (byte*)"getxregbit",
    (byte*)"setopndsize",
    (byte*)"getretopnd",
    (byte*)"start",
    (byte*)"start",
    (byte*)"start",
    (byte*)"writememlib",
    (byte*)"roundsegment",
    (byte*)"writerelocs",
    (byte*)"addsymbols",
    (byte*)"start",
    (byte*)"writemcx",
    (byte*)"writerelocs",
    (byte*)"countsymbols",
    (byte*)"writesymbols",
    (byte*)"roundsegment",
    (byte*)"genbyte",
    (byte*)"genword32",
    (byte*)"genstring",
    (byte*)"genblock",
    (byte*)"start",
    (byte*)"writeexe",
    (byte*)"genexe",
    (byte*)"loadlibs",
    (byte*)"initsectiontable",
    (byte*)"extractlibname",
    (byte*)"scanst",
    (byte*)"relocdata",
    (byte*)"getbaserelocs",
    (byte*)"writerecordx",
    (byte*)"writedosstub",
    (byte*)"writepesig",
    (byte*)"writepadding",
    (byte*)"writefileheader",
    (byte*)"writeoptheader",
    (byte*)"writesectionheader",
    (byte*)"writesectiondata",
    (byte*)"writeexporttable",
    (byte*)"getexporttablesize",
    (byte*)"newbasereloc",
    (byte*)"scanbaserelocs",
    (byte*)"writebasereloctable",
    (byte*)"sortexports",
    (byte*)"getsectionno",
    (byte*)"getoffsets",
    (byte*)"start",
    (byte*)"start",
    (byte*)"readlibfile",
    (byte*)"readbyte",
    (byte*)"readu32",
    (byte*)"readstring",
    (byte*)"alloclibdata",
    (byte*)"error",
    (byte*)"loadmemmcu",
    (byte*)"checknew",
    (byte*)"findlib",
    (byte*)"mxaddlib",
    (byte*)"fixuplib",
    (byte*)"loaddlls",
    (byte*)"finddllsymbol",
    (byte*)"checksymbols",
    (byte*)"dorelocations",
    (byte*)"reloclib",
    (byte*)"loadimports",
    (byte*)"dosublib",
    (byte*)"loadlibfile",
    (byte*)"dosymbols",
    (byte*)"readmxfile",
    (byte*)"adddll",
    (byte*)"addsymbol",
    (byte*)"setspecialglobals",
    (byte*)"runprogram",
    (byte*)"calllibinit",
    (byte*)"findsymbol",
    (byte*)"loadmx",
    (byte*)"loadmemmcb",
    (byte*)"mltest",
    (byte*)"start",
    (byte*)"initlogfile",
    (byte*)"closelogfile",
    (byte*)"showlibs",
    (byte*)"showlib",
    (byte*)"showstr",
    (byte*)"showstrln",
    (byte*)"showstrint",
    (byte*)"shownames",
    (byte*)"showrelocs",
    (byte*)"showsectiondata",
    (byte*)"showsectioncode",
    (byte*)"showglobals",
    (byte*)"start",
    (byte*)"m_init",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_get_nprocs",
    (byte*)"m_get_nexports",
    (byte*)"m_get_procname",
    (byte*)"m_get_procaddr",
    (byte*)"m_get_procexport",
    (byte*)"pushio",
    (byte*)"m_print_startfile",
    (byte*)"m_print_startstr",
    (byte*)"m_print_startptr",
    (byte*)"m_print_startcon",
    (byte*)"m_print_setfmt",
    (byte*)"m_print_end",
    (byte*)"m_print_ptr",
    (byte*)"m_print_i64",
    (byte*)"m_print_u64",
    (byte*)"m_print_r64",
    (byte*)"m_print_r32",
    (byte*)"m_print_c8",
    (byte*)"m_print_str",
    (byte*)"m_print_newline",
    (byte*)"m_print_nogap",
    (byte*)"m_print_space",
    (byte*)"printstr",
    (byte*)"printstr_n",
    (byte*)"printstrn_app",
    (byte*)"makezstring",
    (byte*)"freezstring",
    (byte*)"printchar",
    (byte*)"nextfmtchars",
    (byte*)"strtofmt",
    (byte*)"domultichar",
    (byte*)"expandstr",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"i64mintostr",
    (byte*)"strtostrfmt",
    (byte*)"tostr_i64",
    (byte*)"tostr_u64",
    (byte*)"tostr_r64",
    (byte*)"tostr_str",
    (byte*)"getfmt",
    (byte*)"strint",
    (byte*)"getstrint",
    (byte*)"strword",
    (byte*)"strreal",
    (byte*)"getstr",
    (byte*)"initreadbuffer",
    (byte*)"m_read_conline",
    (byte*)"m_read_fileline",
    (byte*)"m_read_strline",
    (byte*)"readitem",
    (byte*)"strtoint",
    (byte*)"m_read_i64",
    (byte*)"m_read_r64",
    (byte*)"m_read_str",
    (byte*)"readstr",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"valint",
    (byte*)"valreal",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"m_power_i64",
    (byte*)"m_intoverflow",
    (byte*)"m_dotindex",
    (byte*)"m_dotslice",
    (byte*)"m_popdotindex",
    (byte*)"m_popdotslice",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"m_sign",
    (byte*)"m_tp_i64tor64",
    (byte*)"m_tp_r64toi64",
    (byte*)"m_tp_reftoi64",
    (byte*)"m_tp_i64toref",
    (byte*)"start",
    (byte*)"pcm_alloc",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"pcm_copyheapstringn",
    (byte*)"pcm_copyheapblock",
    (byte*)"addtomemalloc",
    (byte*)"removefrommemalloc",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"setfilepos",
    (byte*)"getfilepos",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"pcm_alloc64",
    (byte*)"pcm_free64",
    (byte*)"pcm_alloc16",
    (byte*)"pcm_free16",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword32",
    (byte*)"outword64",
    (byte*)"outstring",
    (byte*)"outblock",
    (byte*)"myeof",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparamnew",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"mseed",
    (byte*)"mrandom",
    (byte*)"mrandomp",
    (byte*)"mrandomint",
    (byte*)"mrandomrange",
    (byte*)"mrandomreal",
    (byte*)"mrandomreal1",
    (byte*)"checkpackfile",
    (byte*)"readline",
    (byte*)"findfunction",
    (byte*)"roundtoblock",
    (byte*)"start",
    (byte*)"start",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_flushkeys",
    (byte*)"os_getconsolein",
    (byte*)"os_getconsoleout",
    (byte*)"os_proginstance",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_gethostsize",
    (byte*)"os_iswindows",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_getmpath",
    (byte*)"os_exitprocess",
    (byte*)"os_clock",
    (byte*)"os_ticks",
    (byte*)"os_getclockspersec",
    (byte*)"os_setmesshandler",
    (byte*)"os_hpcounter",
    (byte*)"os_hpfrequency",
    (byte*)"os_filelastwritetime",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"os_allocexecmem",
    (byte*)"start",
    (byte*)"os_calldllfunction",
    (byte*)"os_pushargs",
    (byte*)"calldll_cint",
    (byte*)"calldll_creal",
    (byte*)"os_dummycall",
    (byte*)"start",
(byte*)""};
static i64 msysc$_fnnprocs=975;
static i64 msysc$_fnnexports;
static i64 msysc$fmtparam;
static i64 msysc$needgap = (i64)0;
static i64 msysc$outdev = (i64)1;
static void *  msysc$outchan = 0;
static u8 *  msysc$fmtstr = 0;
static void *  msysc$outchan_stack[10];
static i64 msysc$outdev_stack[10];
static u8 *  msysc$fmtstr_stack[10];
static byte msysc$needgap_stack[10];
static u8 *  msysc$ptr_stack[10];
static i64 msysc$niostack = (i64)0;
static u8 msysc$digits[16] = {
    (u8)(i64)48,
    (u8)(i64)49,
    (u8)(i64)50,
    (u8)(i64)51,
    (u8)(i64)52,
    (u8)(i64)53,
    (u8)(i64)54,
    (u8)(i64)55,
    (u8)(i64)56,
    (u8)(i64)57,
    (u8)(i64)65,
    (u8)(i64)66,
    (u8)(i64)67,
    (u8)(i64)68,
    (u8)(i64)69,
    (u8)(i64)70
};
static struct msysc$fmtrec msysc$defaultfmt = {
    (u8)0u,
    (i8)(i64)0,
    (u8)10u,
    (u8)(i64)0,
    (u8)' ',
    (u8)'f',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)'R',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)0u
};
static u8 *  msysc$rd_buffer;
static i64 msysc$rd_length;
static u8 *  msysc$rd_pos;
static u8 *  msysc$rd_lastpos;
static i64 msysc$termchar;
static i64 msysc$itemerror;
static i64 msysc$$cmdskip;
static i64 msysc$nsysparams;
static i64 msysc$ncmdparams;
static i64 msysc$nenvstrings;
static u8 *  msysc$sysparams[128];
static u8 *(*msysc$cmdparams)[];
static u8 *(*msysc$envstrings)[];
static u64 msysc$mask63 = (u64)9223372036854775807u;
static r64 msysc$offset64 = (double)9223372036854775800.;
static r64 msysc$offset32 = (double)9223372036854775800.;
static u64 mlib$allocupper[301];
static i64 mlib$alloccode;
static i64 mlib$allocbytes;
static i64 mlib$fdebug = (i64)0;
static i64 mlib$rfsize;
static u64 mlib$maxmemory;
static i64 mlib$maxalloccode;
static void *  mlib$allocbase;
static byte mlib$pcm_setup = (byte)(i64)0;
static i64 mlib$show = (i64)0;
static i64 mlib$memtotal = (i64)0;
static i64 mlib$smallmemtotal = (i64)0;
static i64 mlib$smallmemobjs = (i64)0;
static i64 mlib$maxmemtotal = (i64)0;
static i32 *  mlib$memalloctable[3];
static i32 mlib$memallocsize[3];
static byte *  mlib$pcheapstart;
static byte *  mlib$pcheapend;
static byte *  mlib$pcheapptr;
static byte mlib$sizeindextable[2049];
static u64 *  mlib$freelist[9];
static u8 *  mlib$pmnames[6] = {(byte*)"pm_end",(byte*)"pm_option",(byte*)"pm_sourcefile",(byte*)"pm_libfile",(byte*)"pm_colon",(byte*)"pm_extra"};
static u64 mlib$seed[2] = {(u64)2993073034246558322u,(u64)1617678968452121188u};
static i64 mlinux$init_flag = (i64)0;

/* PROCDEFS */
int main(int _nargs, char** _args, char** _envstrings) {
    msysc$m_init(_nargs, (void*)_args, (void*)_envstrings);

// call main-start() routines...
    mx_decls$start();
    msysc$start();
    mm_cli$start();

        i64 t;
    mm_cli$startclock = mlinux$os_clock();
    mm_cli$stepruncount();
    mm_cli$initdata();
    mm_cli$getinputoptions();
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"READ PROJECT",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_cli$rpclock = clock();
    mm_modules$readprojectfile(mm_cli$inputfile);
    if ((mm_decls$fverbose >= (i64)1)) {
        if ((mm_decls$passlevel == (i64)13)) {
            if ((!(!!((i64)mm_cli$msfile)) || (mm_decls$fverbose > (i64)1))) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Compiling",NULL);
                msysc$m_print_str(mm_cli$inputfile,NULL);
                msysc$m_print_str((byte*)"to memory",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_setfmt((byte*)"M6 Compiling # to #");
            msysc$m_print_str(mm_cli$inputfile,(byte*)"14jlp-");
            msysc$m_print_str(mlib$changeext(mm_decls$outfile,mm_cli$outext),NULL);
            msysc$m_print_space();
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
    }
;
    remove((byte*)"mx.log");
    mm_cli$do_loadmodules();
    mm_cli$do_parse();
    mm_cli$do_name();
    mm_cli$do_type();
    mm_support$do_writema();
    mm_cli$do_writeexports();
    if ((mm_decls$passlevel==(i64)8)) {
        mm_support$loaderror((byte*)"MCL(C)",(byte*)"",(byte*)"");
        mm_winx64$codegen();
    }
    else if ((mm_decls$passlevel==(i64)9)) {
        mm_winx64$writeasmfile(mm_decls$asmfilename);
    }
    else if ((mm_decls$passlevel==(i64)11)) {
        mm_winx64$writeexefile(mm_decls$exefilename,(i64)0);
    }
    else if ((mm_decls$passlevel==(i64)12)) {
        mm_winx64$writelibfile(mm_decls$libfilename);
    }
    else if ((mm_decls$passlevel==(i64)13)) {
        mm_winx64$runlibfile(mm_decls$libfilename);
    }
;
    if ((mm_decls$fverbose >= (i64)2)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Finished.",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if (!!(mm_decls$debugmode)) {
        mm_diags$showlogfile();
    }
;
    if (!!((i64)mm_decls$fshowtiming)) {
        mm_cli$endclock = mlinux$os_clock();
        t = (mm_cli$endclock - mm_cli$startclock);
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Time",NULL);
        msysc$m_print_i64(t,NULL);
        msysc$m_print_str((byte*)"ms",NULL);
        msysc$m_print_end();
        ;
        if (!!(t)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)",",NULL);
            msysc$m_print_i64((i64)((r64)mm_lex$lxalllines / (r64)t),NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)"K lines per second",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
    }
;
    return 0;
}

static void mm_cli$do_loadmodules(void) {
        i64 tt;
    if ((mm_decls$passlevel < (i64)2)) {
        return;
    }
;
    mm_modules$loadmodules();
    tt = (clock() - mm_cli$rpclock);
    if (!!((i64)mm_decls$fshowtiming)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"LOAD",NULL);
        msysc$m_print_str((byte*)"TT=",NULL);
        msysc$m_print_i64(tt,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    mm_support$addspecialtypes();
}

static void mm_cli$do_parse(void) {
        i64 tt;
        i64 i;
    if ((mm_decls$passlevel < (i64)3)) {
        return;
    }
;
    if (!!((i64)mm_decls$fwritedocs)) {
        mm_parse$docfile = fopen(mlib$changeext(mm_decls$outfile,(byte*)"txt"),(byte*)"w");
    }
;
    tt = clock();
    for (i=(i64)2;i<=mm_decls$nmodules;++i) {
L1 :;
        mm_parse$parsemodule(i);
L2 :;
    }
L3 :;
    ;
    mm_parse$parsemodule((i64)1);
    tt = (clock() - tt);
    if (!!((i64)mm_decls$fshowtiming)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"PARSE",NULL);
        msysc$m_print_str((byte*)"TT=",NULL);
        msysc$m_print_i64(tt,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if (!!(mm_parse$docfile)) {
        fclose(mm_parse$docfile);
    }
;
    if ((!(!!(mm_decls$debugmode)) || (mm_decls$passlevel >= (i64)4))) {
        mm_name$fixusertypes();
    }
;
    mm_cli$fixstartprocs();
    if ((!!(mm_decls$debugmode) && !!((i64)mm_decls$fshowast1))) {
        mm_diags$showast((byte*)"AST1");
    }
;
}

static void mm_cli$do_name(void) {
        i64 tt;
        i64 i;
    if ((mm_decls$passlevel < (i64)5)) {
        return;
    }
;
    mm_name$rx_typetable();
    tt = clock();
    for (i=(i64)2;i<=mm_decls$nmodules;++i) {
L4 :;
        mm_name$rx_module(i);
L5 :;
    }
L6 :;
    ;
    mm_name$rx_module((i64)1);
    tt = (clock() - tt);
    if (!!((i64)mm_decls$fshowtiming)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"NAME",NULL);
        msysc$m_print_str((byte*)"TT=",NULL);
        msysc$m_print_i64(tt,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((!!(mm_decls$debugmode) && !!((i64)mm_decls$fshowast2))) {
        mm_diags$showast((byte*)"AST2");
    }
;
}

static void mm_cli$do_type(void) {
        i64 tt;
        i64 i;
    if ((mm_decls$passlevel < (i64)6)) {
        return;
    }
;
    tt = clock();
    mm_type$tx_typetable();
    for (i=(i64)1;i<=mm_decls$nmodules;++i) {
L7 :;
        mm_type$tx_module(i);
L8 :;
    }
L9 :;
    ;
    mm_type$tx_allprocs();
    if (!!((i64)mm_decls$fshowtiming)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"TYPE",NULL);
        msysc$m_print_i64((clock() - tt),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((!!(mm_decls$debugmode) && !!((i64)mm_decls$fshowast3))) {
        mm_diags$showast((byte*)"AST3");
    }
;
}

static void mm_cli$initdata(void) {
    mlib$pcm_init();
    mm_lex$lexsetup();
    mm_cli$initassemsymbols();
    mm_support$init_tt_tables();
    mm_support$initbblib();
    mc_libmcl$nilunit = (struct mm_decls$unitrec *)malloc((u64)16u);
}

static void mm_cli$getinputoptions(void) {
        i64 paramno;
        i64 pmtype;
        i64 sw;
        i64 ncolons;
        u8 *  name;
        u8 *  value;
        u8 *  filename;
        u8 filespec[300];
    mm_decls$prodmode = (i64)1;
    paramno = (i64)1;
    ncolons = (i64)0;
    if (!!(mlib$eqstring(mlib$extractfile(mlinux$os_gethostname()),(byte*)"ms.exe"))) {
        mm_cli$msfile = (i64)1;
        mm_cli$do_option((i64)15,(byte*)"");
    }
;
    L10 :;
    while (!!((pmtype = mlib$nextcmdparamnew(&paramno,&name,&value,(byte*)"m")))) {
        if ((pmtype==(i64)1)) {
            mlib$convlcstring(name);
            for (sw=(i64)1;sw<=(i64)58;++sw) {
L13 :;
                if (!!(mlib$eqstring(name,mm_cli$optionnames[(sw)-1]))) {
                    mm_cli$do_option(sw,value);
                    goto L15 ;
                }
;
L14 :;
            }
            {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Unknown option:",NULL);
                msysc$m_print_str(name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)99);
            }
L15 :;
            ;
        }
        else if ((pmtype==(i64)2)) {
            if (!!(mm_cli$inputfile)) {
                mm_support$loaderror((byte*)"Specify one lead module only",(byte*)"",(byte*)"");
            }
;
            mlib$convlcstring(name);
            mm_cli$inputfile = mlib$pcm_copyheapstring(name);
            if ((mm_decls$passlevel == (i64)13)) {
                mm_winx64$cmdskip = ((paramno - (i64)1) + msysc$$cmdskip);
                goto L12 ;
            }
;
        }
        else if ((pmtype==(i64)3)) {
            mm_support$loaderror((byte*)"Lib files go in module headers",(byte*)"",(byte*)"");
        }
        else {
            mm_support$loaderror((byte*)"Invalid params",(byte*)"",(byte*)"");
        }
;
L11 :;
    }
L12 :;
    ;
    if ((mm_decls$prodmode==mm_decls$debugmode && mm_decls$debugmode==(i64)0)) {
        mm_decls$passlevel = (i64)11;
        mm_cli$outext = (byte*)"exe";
        mm_decls$prodmode = (i64)1;
    }
    else if ((!!(mm_decls$prodmode) && (mm_decls$passlevel == (i64)0))) {
        mm_decls$passlevel = (i64)11;
        mm_cli$outext = (byte*)"exe";
    }
    else if ((!!(mm_decls$debugmode) && (mm_decls$passlevel == (i64)0))) {
        mm_decls$passlevel = (i64)8;
        mm_cli$outext = (byte*)"asm";
    }
;
    if (((i64)mm_decls$msyslevel == (i64)-1)) {
        mm_decls$msyslevel = (!!(mm_decls$prodmode) ? (i64)2 : (i64)0);
        mm_decls$msyslevel = (!!(mm_decls$prodmode) ? (i64)2 : (i64)0);
    }
;
    if ((mm_cli$inputfile == 0)) {
        mm_cli$showcaption();
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Usage:",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((*msysc$cmdparams)[((i64)0)],NULL);
        msysc$m_print_str((byte*)"filename[.m]     # Compile project to executable",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((*msysc$cmdparams)[((i64)0)],NULL);
        msysc$m_print_str((byte*)"-help            # Other options",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit(0);
    }
    else {
        filename = mm_cli$inputfile;
        mm_decls$outfile = mlib$pcm_copyheapstring(filename);
        if (!!((i64)mm_decls$fwritema)) {
            mm_cli$outext = (byte*)"ma";
        }
;
        if (!!(mm_decls$destfilename)) {
            mm_decls$outfile = mm_decls$destfilename;
        }
        else if (!!(mm_decls$destfilepath)) {
            strcpy((u8 *)filespec,mm_decls$destfilepath);
            strcat(mlib$extractfile((u8 *)filespec),mm_decls$outfile);
            mm_decls$outfile = mlib$pcm_copyheapstring((u8 *)filespec);
        }
;
    }
;
    mm_decls$asmfilename = mm_cli$getoutfilename(mm_decls$outfile,(byte*)"asm");
    mm_decls$exefilename = mm_cli$getoutfilename(mm_decls$outfile,(byte*)"exe");
    mm_decls$libfilename = mm_cli$getoutfilename(mm_decls$outfile,(!!(mm_decls$libmode) ? (byte*)"ml" : (byte*)"mx"));
    mm_decls$objfilename = mm_cli$getoutfilename(mm_decls$outfile,(byte*)"obj");
    mm_decls$mafilename = mm_cli$getoutfilename(mm_decls$outfile,(byte*)"ma");
    strcpy(filespec,mlib$changeext(mm_decls$outfile,(byte*)""));
    strcat(filespec,(byte*)"_exp");
    mm_decls$expfilename = mm_cli$getoutfilename(filespec,(byte*)"m");
}

static void mm_cli$do_option(i64 sw,u8 *value) {
        static byte outused;
        static byte outpathused;
    switch (sw) {
    case 1:;
        {
            mm_decls$passlevel = (i64)1;
        }
        break;
    case 2:;
        {
            mm_decls$passlevel = (i64)2;
        }
        break;
    case 4:;
        {
            mm_decls$passlevel = (i64)3;
        }
        break;
    case 3:;
        {
            mm_decls$passlevel = (i64)4;
        }
        break;
    case 5:;
        {
            mm_decls$passlevel = (i64)5;
        }
        break;
    case 6:;
        {
            mm_decls$passlevel = (i64)6;
        }
        break;
    case 7:;
        {
            mm_decls$passlevel = (i64)9;
            mm_cli$outext = (byte*)"asm";
        }
        break;
    case 8:;
        {
            if ((u64)1u) {
                mm_support$loaderror((byte*)"-c not allowed",(byte*)"",(byte*)"");
            }
;
            mm_decls$passlevel = (i64)9;
            mm_cli$outext = (byte*)"c";
        }
        break;
    case 9:;
        {
            mm_decls$passlevel = (i64)8;
            mm_cli$outext = (byte*)"asm";
        }
        break;
    case 10:;
        {
            mm_decls$passlevel = (i64)10;
            mm_cli$outext = (byte*)"obj";
        }
        break;
    case 13:;
        {
            mm_decls$passlevel = (i64)11;
            mm_cli$outext = (byte*)"exe";
        }
        break;
    case 14:;
        {
            mm_decls$passlevel = (i64)12;
            mm_cli$outext = (byte*)"exe";
            mm_decls$mxstub = (i64)1;
        }
        break;
    case 11:;
        {
            mm_decls$passlevel = (i64)12;
            mm_cli$outext = (byte*)"mx";
        }
        break;
    case 12:;
        {
            mm_decls$passlevel = (i64)12;
            mm_cli$outext = (byte*)"ml";
            mm_decls$libmode = (i64)1;
        }
        break;
    case 15:;
        {
            mm_decls$passlevel = (i64)13;
            mm_cli$outext = (byte*)"mem";
        }
        break;
    case 26:;
        {
            mm_decls$fwritema = (i64)1;
            mm_cli$outext = (byte*)"ma";
        }
        break;
    case 27:;
        {
            mm_decls$fwritema = (i64)2;
            mm_cli$outext = (byte*)"ma";
        }
        break;
    case 29:;
        {
            mm_decls$fwriteexports = (i64)1;
        }
        break;
    case 28:;
        {
            mm_decls$fwritedocs = (i64)1;
        }
        break;
    case 30:;
        {
            mm_decls$libmode = (i64)1;
        }
        break;
    case 16:;
        {
            mm_decls$msyslevel = (i64)2;
        }
        break;
    case 17:;
        {
            mm_decls$msyslevel = (i64)1;
        }
        break;
    case 18:;
        {
            mm_decls$msyslevel = (i64)0;
        }
        break;
    case 19:;
        {
            mm_decls$minos = (i64)1;
        }
        break;
    case 20:;
        {
            mm_decls$fnofile = (i64)1;
        }
        break;
    case 31:;
        {
            mm_decls$foptim = (i64)2;
        }
        break;
    case 32:;
        {
            mm_decls$foptim = (i64)1;
        }
        break;
    case 33:;
        {
            mm_decls$foptim = (i64)2;
        }
        break;
    case 21:;
        {
            mm_decls$debugmode = (i64)1;
            mm_decls$prodmode = (i64)0;
        }
        break;
    case 47:;
        {
            mm_decls$fshowtiming = (i64)1;
        }
        break;
    case 48:;
        {
            mm_decls$fverbose = (i64)2;
        }
        break;
    case 49:;
        {
            mm_decls$fverbose = (i64)3;
        }
        break;
    case 50:;
        {
            mm_decls$fverbose = (i64)0;
        }
        break;
    case 51:;
    case 52:;
        {
            mm_cli$showhelp();
            exit(0);
        }
        break;
    case 53:;
        {
            mm_decls$dointlibs = (i64)0;
        }
        break;
    case 54:;
        {
            if (!!((i64)outpathused)) {
                mm_support$loaderror((byte*)"mixed out/path",(byte*)"",(byte*)"");
            }
;
            mm_decls$destfilename = mlib$pcm_copyheapstring(value);
            outused = (i64)1;
        }
        break;
    case 55:;
        {
            if (!!((i64)outused)) {
                mm_support$loaderror((byte*)"mixed out/path",(byte*)"",(byte*)"");
            }
;
            if (!(((u64)(*((value + strlen(value)) - (i64)1)) == (u64)92u || (u64)(*((value + strlen(value)) - (i64)1)) == '/'))) {
                mm_support$loaderror((byte*)"Path needs to end with \\ or /",(byte*)"",(byte*)"");
            }
;
            mm_decls$destfilepath = mlib$pcm_copyheapstring(value);
            outpathused = (i64)1;
        }
        break;
    case 56:;
        {
            mm_decls$fcheckunusedlocals = (i64)1;
        }
        break;
    case 34:;
        {
            mm_decls$fshowast1 = (i64)1;
        }
        break;
    case 35:;
        {
            mm_decls$fshowast2 = (i64)1;
        }
        break;
    case 36:;
        {
            mm_decls$fshowast3 = (i64)1;
        }
        break;
    case 37:;
        {
            mm_decls$fshowmx = (i64)1;
        }
        break;
    case 38:;
        {
            mm_decls$fshowasm = (i64)1;
        }
        break;
    case 39:;
        {
            mm_decls$fshowst = (i64)1;
        }
        break;
    case 41:;
        {
            mm_decls$fshowstflat = (i64)1;
        }
        break;
    case 42:;
        {
            mm_decls$fshowtypes = (i64)1;
        }
        break;
    case 43:;
        {
            mm_decls$fshowoverloads = (i64)1;
        }
        break;
    case 44:;
        {
            mm_decls$fshowss = (i64)1;
        }
        break;
    case 45:;
        {
            mm_decls$fshowmodules = (i64)1;
        }
        break;
    case 46:;
        {
            mm_winx64$fshortnames = (i64)1;
        }
        break;
    case 22:;
        {
            mm_decls$ccompiler = (i64)1;
        }
        break;
    case 23:;
        {
            mm_decls$ccompiler = (i64)2;
        }
        break;
    case 24:;
        {
            mm_decls$ccompiler = (i64)3;
        }
        break;
    case 25:;
        {
            mm_decls$ccompiler = (i64)4;
        }
        break;
    case 58:;
        {
            mm_decls$flinux = (i64)1;
        }
        break;
    } //SW
;
}

static void mm_cli$showcaption(void) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"M",NULL);
    msysc$m_print_str((byte*)"Compiler [M6]",NULL);
    msysc$m_print_str((byte*)"6-Nov-2022",NULL);
    msysc$m_print_str((byte*)"21:26:52",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void mm_cli$showhelp(void) {
        static u8 *  helptext = (byte*)"M Compiler Generating x64 native code - Windows Version\n\nWhole-program compiler builds entire program from the lead module\ninto a executable file.\n\n    mm main              # Create main.exe from lead module main.m\n    mm main.m            # Same (.m extension is default)\n    mm -c main           # Create single-file main.asm intermediate ASM\n\nOptions:\n\n    -exe                 # Generate .exe executable file (default)\n    -dll                 # Generate .dll library and .exp file\n    -pcl                 # Generate intermediate PCL file only\n    -asm                 # Generate intermediate ASM file only\n\n    -opt                 # Apply simple optimiser\n\n    -out:file            # Name of output file \n\n    -ma                  # Create .ma file combining source/support files\n    -docs                # Create .txt with docstrings of exported files (not finished)\n    -run                 # For -exe mode only: run resulting executable\n\n    @file                # Read options from file\n\nExample:\n\n     mm -run prog : abc def\n\nAny parameters for the new program must follow \" : \" (spaces needed).\n";
    msysc$m_print_startcon();
    msysc$m_print_str(helptext,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void mm_cli$initassemsymbols(void) {
        u8 str[32];
        i64 i;
        static u8 *  regnames[6] = {(byte*)"aframe",(byte*)"dframe",(byte*)"astack",(byte*)"dstack",(byte*)"dprog",(byte*)"dsptr"};
        static byte regnos[6] = {(u8)15u,(u8)15u,(u8)16u,(u8)16u,(u8)9u,(u8)10u};
        static byte sizes[6] = {(u8)4u,(u8)8u,(u8)4u,(u8)8u,(u8)8u,(u8)8u};
    for (i=(i64)1;i<=(i64)150;++i) {
L16 :;
        if ((i != (i64)31)) {
            mm_lex$addreservedword((mc_decls$mclnames[(i)-1] + (i64)2),(i64)92,i,(i64)0);
        }
;
L17 :;
    }
L18 :;
    ;
    for (i=(i64)1;i<=(i64)136;++i) {
L19 :;
        mm_lex$addreservedword(mc_decls$dregnames[(i)-1],(i64)84,(i64)mc_decls$regindices[(i)-1],(i64)mc_decls$regsizes[(i)-1]);
L20 :;
    }
L21 :;
    ;
    for (i=(i64)1;i<=(i64)16;++i) {
L22 :;
        mm_lex$addreservedword(mc_decls$xmmregnames[(i)-1],(i64)85,((i + (i64)21) - (i64)1),(i64)0);
L23 :;
    }
L24 :;
    ;
    for (i=(i64)1;i<=(i64)8;++i) {
L25 :;
        mm_lex$addreservedword(mc_decls$fregnames[(i)-1],(i64)86,i,(i64)0);
L26 :;
    }
L27 :;
    ;
    for (i=(i64)1;i<=(i64)8;++i) {
L28 :;
        mm_lex$addreservedword(mc_decls$mregnames[(i)-1],(i64)87,i,(i64)0);
L29 :;
    }
L30 :;
    ;
    for (i=(i64)1;i<=(i64)18;++i) {
L31 :;
        mm_lex$addreservedword(mc_decls$jmpccnames[(i)-1],(i64)88,(i64)mc_decls$jmpcccodes[(i)-1],(i64)0);
L32 :;
    }
L33 :;
    ;
    for (i=(i64)1;i<=(i64)16;++i) {
L34 :;
        mm_lex$addreservedword(mc_decls$setccnames[(i)-1],(i64)89,(i64)mc_decls$setcccodes[(i)-1],(i64)0);
L35 :;
    }
L36 :;
    ;
    for (i=(i64)1;i<=(i64)16;++i) {
L37 :;
        mm_lex$addreservedword(mc_decls$cmovccnames[(i)-1],(i64)90,(i64)mc_decls$cmovcccodes[(i)-1],(i64)0);
L38 :;
    }
L39 :;
    ;
    for (i=(i64)1;i<=(i64)5;++i) {
L40 :;
        strcpy((u8 *)str,mc_decls$segmentnames[(i)-1]);
        str[((strlen((u8 *)str) - (i64)3))-1] = (u64)0u;
        mm_lex$addreservedword(mlib$pcm_copyheapstring((u8 *)str),(i64)91,i,(i64)0);
L41 :;
    }
L42 :;
    ;
    for (i=(i64)1;i<=(i64)6;++i) {
L43 :;
        mm_lex$addreservedword(regnames[(i)-1],(i64)84,(i64)regnos[(i)-1],(i64)sizes[(i)-1]);
L44 :;
    }
L45 :;
    ;
}

static void mm_cli$do_writeexports(void) {
    if ((!(!!((i64)mm_decls$fwriteexports)) && (mm_decls$passlevel != (i64)12))) {
        return;
    }
;
    if (!(!!(mm_decls$libmode))) {
        return;
    }
;
    mm_export$writeexports(mm_decls$expfilename,mlib$extractbasefile(mm_decls$libfilename));
    if (!!((i64)mm_decls$fwriteexports)) {
        exit(0);
    }
;
}

static u8 *mm_cli$getoutfilename(u8 *file,u8 *ext) {
    return mlib$pcm_copyheapstring(mlib$changeext(file,ext));
}

static void mm_cli$fixstartprocs(void) {
        struct mm_decls$modulerec *  ms;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
        i64 i;
    for (i=(i64)1;i<=mm_decls$nmodules;++i) {
L46 :;
        ms = (struct mm_decls$modulerec *)&mm_decls$moduletable[(i)];
        if (((*ms).ststart == 0)) {
            (*ms).ststart = mm_cli$addstartproc((*ms).stmodule,(byte*)"start",(i64)2,i);
        }
;
        if (!!((*ms).modulecode)) {
            p = mm_parse$makeblock((*ms).modulecode);
            q = (*(*ms).ststart).code;
            (*p).nextunit = (*q).a;
            (*(*(*ms).ststart).code).a = p;
        }
;
        if ((((i == mm_decls$mainmoduleno) && ((*ms).stmain == 0)) && !!((*ms).modulecode))) {
            (*ms).stmain = mm_cli$addstartproc((*ms).stmodule,(byte*)"main",(i64)3,i);
        }
;
L47 :;
    }
L48 :;
    ;
}

static struct mm_decls$strec *mm_cli$addstartproc(struct mm_decls$strec *owner,u8 *name,i64 scope,i64 moduleno) {
        struct mm_decls$strec *  stproc;
    stproc = mm_lib$getduplnameptr(owner,(struct mm_decls$strec *)mm_lex$addnamestr(name),(i64)6);
    (*stproc).scope = scope;
    (*stproc).moduleno = moduleno;
    (*stproc).subprogno = (i64)mm_decls$moduletosub[(moduleno)];
    (*stproc).code = mm_parse$makeblock(0);
    mm_lib$adddef(owner,stproc);
    mm_lib$addtoproclist(stproc);
    return stproc;
}

static void mm_cli$stepruncount(void) {
        i64 count;
        void *  f;
    f = fopen((byte*)"C:/mx//bcrun.txt",(byte*)"r+");
    if (!(!!(f))) {
        return;
    }
;
    {
        msysc$m_read_fileline(f);
        ;
        count = msysc$m_read_i64((i64)0);
        ;
    }
    fseek(f,(i32)(i64)0,(i32)(i64)0);
    msysc$m_print_startfile(f);
    msysc$m_print_i64((count + (i64)1),NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    fclose(f);
}

// START
void mm_cli$start(void) {
    mm_assem$start();
    mc_blockmcl$start();
    mm_winx64$start();
    mm_decls$start();
    mm_diags$start();
    mm_export$start();
    mm_lex$start();
    mm_lib$start();
    mm_libsources$start();
    mm_modules$start();
    mm_name$start();
    mm_parse$start();
    mm_support$start();
    mm_tables$start();
    mm_type$start();
    mc_genmcl$start();
    mc_genss$start();
    mc_libmcl$start();
    mc_decls$start();
    mc_objdecls$start();
    mc_run$start();
    mc_write$start();
    mc_writeexe$start();

}

struct mm_decls$unitrec *mm_assem$readassemline(void) {
    mm_lex$lex();
    return mm_assem$assembleline((i64)1);
}

struct mm_decls$unitrec *mm_assem$readassemblock(void) {
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
        struct mm_decls$unitrec *  u;
    ulist = (ulistx = 0);
    L49 :;
    while (1) {
        mm_lex$lex();
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)68)) {
            mm_support$serror((byte*)"EOF: 'End' missing in Assembler code");
        }
        else if (($temp==(i64)105)) {
            mm_parse$checkend((i64)mm_decls$lx.symbol,(i64)167,(i64)0,(i64)0);
            mm_lex$lex();
            goto L50 ;
        }
        else if (($temp==(i64)6)) {
        }
        else {
            u = mm_assem$assembleline((i64)0);
            mm_lib$addlistunit(&ulist,&ulistx,u);
        }
        };
    }
L50 :;
    ;
    return mm_parse$makeblock(ulist);
}

static struct mm_decls$unitrec *mm_assem$assembleline(i64 oneline) {
        struct mm_decls$unitrec *  dlist;
        struct mm_decls$unitrec *  dlistx;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  pname;
        struct mm_decls$unitrec *  q;
        i64 opc;
        i64 noperands;
        struct mm_decls$strec *  stname;
    dlist = (dlistx = 0);
    if ((((i64)mm_decls$lx.symbol == (i64)81) && ((i64)mm_decls$nextlx.symbol == (i64)7 || (i64)mm_decls$nextlx.symbol == (i64)8))) {
        p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)102);
        stname = (struct mm_decls$strec *)mm_lib$getduplnameptr(mm_decls$currproc,(struct mm_decls$strec *)mm_decls$lx.symptr,(i64)17);
        (*p).def = (struct mm_decls$strec *)stname;
        mm_lib$adddef(mm_decls$currproc,(struct mm_decls$strec *)stname);
        mm_lex$lex();
        if (!!(oneline)) {
            mm_lex$lex();
        }
;
        return p;
    }
    else if (((i64)mm_decls$lx.symbol == (i64)33)) {
        mm_parse$lexchecksymbol((i64)81);
        pname = (struct mm_decls$unitrec *)mm_lib$createname((struct mm_decls$strec *)mm_decls$lx.symptr);
        (*pname).pos = (i64)mm_decls$lx.pos;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol != (i64)6)) {
            L51 :;
            do {
                mm_lib$addlistunit(&dlist,&dlistx,mm_parse$readunit());
                if (((i64)mm_decls$lx.symbol == (i64)5)) {
                    mm_lex$lex();
                }
;
L52 :;
            }
            while (!((i64)mm_decls$lx.symbol == (i64)6 || (i64)mm_decls$lx.symbol == (i64)68));
L53 :;
            ;
        }
;
        return (struct mm_decls$unitrec *)mm_lib$createunit2((i64)9,(struct mm_decls$unitrec *)pname,(struct mm_decls$unitrec *)dlist);
    }
;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)45)) {
        opc = (i64)40;
        //doop:
L54 :;
;
        p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)8);
        (*p).asmopcode = opc;
        mm_lex$lex();
    }
    else if (($temp==(i64)46)) {
        opc = (i64)41;
        goto L54 ;
;
    }
    else if (($temp==(i64)47)) {
        opc = (i64)42;
        goto L54 ;
;
    }
    else if (($temp==(i64)56)) {
        opc = (i64)53;
        goto L54 ;
;
    }
    else if (($temp==(i64)130)) {
        if (((i64)mm_decls$lx.subcode == (i64)1)) {
            opc = (i64)31;
            goto L54 ;
;
        }
;
        goto L55 ;
;
    }
    else {
        if (((i64)mm_decls$lx.symbol == (i64)81)) {
            p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)8);
                        {i64 $temp = (i64)mm_decls$lx.subcode;
if (($temp==(i64)92)) {
                (*p).asmopcode = (i64)(*mm_decls$lx.symptr).index;
            }
            else if (($temp==(i64)88)) {
                (*p).asmopcode = (i64)28;
                (*p).cond = (i64)(*mm_decls$lx.symptr).index;
            }
            else if (($temp==(i64)89)) {
                (*p).asmopcode = (i64)60;
                (*p).cond = (i64)(*mm_decls$lx.symptr).index;
            }
            else if (($temp==(i64)90)) {
                (*p).asmopcode = (i64)17;
                (*p).cond = (i64)(*mm_decls$lx.symptr).index;
            }
            else {
                mm_lex$ps((byte*)"ASM");
                mm_support$serror((byte*)"x64 op expected");
            }
            };
            mm_lex$lex();
        }
        else {
            //$else:
L55 :;
;
            mm_lex$ps((byte*)"ASM");
            mm_support$serror((byte*)"ASM???");
        }
;
    }
    };
    if (!(((i64)mm_decls$lx.symbol == (i64)6 || (i64)mm_decls$lx.symbol == (i64)68))) {
        noperands = (i64)0;
        L56 :;
        while (1) {
            q = mm_assem$readassemopnd();
            if ((++(noperands) <= (i64)3)) {
                (*p).abc[(noperands)-1] = q;
            }
            else {
                mm_support$serror((byte*)"Too many asm opnds");
            }
;
            if (((i64)mm_decls$lx.symbol != (i64)5)) {
                goto L57 ;
            }
            else {
                mm_lex$lex();
            }
;
        }
L57 :;
        ;
    }
;
    mm_parse$checksymbol((i64)6);
    return p;
}

static struct mm_decls$unitrec *mm_assem$readassemopnd(void) {
        struct mm_decls$unitrec *  p;
        i64 reg;
        i64 regix;
        i64 scale;
        i64 prefixmode;
        struct mm_decls$unitrec *  pcode;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)72) || ($temp==(i64)74)) {
        return mm_parse$readunit();
    }
    else if (($temp==(i64)81)) {
                {i64 $temp = (i64)(*mm_decls$lx.symptr).subcode;
if (($temp==(i64)84)) {
            p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)10);
            (*p).index = (i64)(*mm_decls$lx.symptr).index;
            (*p).regsize = (i64)(*mm_decls$lx.symptr).regsize;
            mm_lex$lex();
            return p;
        }
        else if (($temp==(i64)85)) {
            p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)11);
            (*p).index = (i64)(*mm_decls$lx.symptr).index;
            mm_lex$lex();
            return p;
        }
        };
        return mm_parse$readunit();
    }
    else if (($temp==(i64)31) || ($temp==(i64)32)) {
        return mm_parse$readunit();
    }
    else if (($temp==(i64)93)) {
                {i64 $temp = (i64)mm_decls$lx.subcode;
if (($temp==(i64)17) || ($temp==(i64)18) || ($temp==(i64)19) || ($temp==(i64)2)) {
        }
        else {
            mm_support$serror((byte*)"Bad prefix");
        }
        };
        prefixmode = (i64)mm_decls$lx.subcode;
        mm_parse$lexchecksymbol((i64)15);
        goto L58 ;
;
    }
    else if (($temp==(i64)15)) {
        prefixmode = (i64)0;
        //gotprefix:
L58 :;
;
        reg = (regix = (i64)0);
        pcode = 0;
        scale = (i64)1;
        mm_lex$lex();
        if ((((i64)mm_decls$lx.symbol == (i64)81) && ((i64)(*mm_decls$lx.symptr).subcode == (i64)84))) {
            reg = (i64)(*mm_decls$lx.symptr).index;
            mm_lex$lex();
        }
;
        if (((((i64)mm_decls$lx.symbol == (i64)31) && ((i64)mm_decls$nextlx.symbol == (i64)81)) && ((i64)(*mm_decls$nextlx.symptr).subcode == (i64)84))) {
            mm_lex$lex();
        }
;
        if ((((i64)mm_decls$lx.symbol == (i64)81) && ((i64)(*mm_decls$lx.symptr).subcode == (i64)84))) {
            regix = (i64)(*mm_decls$lx.symptr).index;
            mm_lex$lex();
        }
;
        if (((i64)mm_decls$lx.symbol == (i64)33)) {
            mm_parse$lexchecksymbol((i64)72);
                        {i64 $temp = (scale = mm_decls$lx.value);
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4) || ($temp==(i64)8)) {
            }
            else {
                mm_support$serror((byte*)"Bad scale");
            }
            };
            mm_lex$lex();
        }
;
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)31) || ($temp==(i64)32) || ($temp==(i64)72) || ($temp==(i64)81) || ($temp==(i64)13) || ($temp==(i64)168)) {
            pcode = mm_parse$readunit();
        }
        };
        mm_parse$checksymbol((i64)16);
        mm_lex$lex();
        p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)12,(struct mm_decls$unitrec *)pcode);
        if (((regix == (i64)0) && (scale > (i64)1))) {
            regix = reg;
            reg = (i64)0;
        }
;
        if (((pcode == 0) && ((reg + regix) == (i64)0))) {
            mm_support$serror((byte*)"Empty []");
        }
;
        (*p).reg = reg;
        (*p).regix = regix;
        (*p).scale = scale;
        (*p).prefixmode = prefixmode;
        return p;
    }
    else {
        mm_lex$ps((byte*)"BAD OPND");
        mm_support$serror((byte*)"ASM: Bad operand?");
    }
    };
    return (struct mm_decls$unitrec *)0;
}

// START
void mm_assem$start(void) {

}

struct mc_decls$opndrec *mc_blockmcl$loadunit(struct mm_decls$unitrec *p,i64 reg) {
        struct mc_decls$opndrec *  tx;
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
        struct mm_decls$unitrec *  c;
        struct mc_decls$opndrec *  ax;
        i64 regs;
        i64 oldreg;
    regs = (i64)mc_decls$regset;
    if ((p == 0)) {
        return 0;
    }
;
    mm_tables$mlineno = (i64)(*p).pos;
    tx = 0;
    a = (*p).a;
    b = (*p).b;
    c = (*p).c;
    switch ((i64)(*p).tag) {
    case 1:;
        {
            tx = mc_blockmcl$do_const(p,(i64)1,reg);
        }
        break;
    case 4:;
        {
            tx = mc_blockmcl$do_name(p,(i64)1,reg);
        }
        break;
    case 6:;
        {
            L59 :;
            while (!!(a)) {
                tx = mc_blockmcl$loadunit(a,(!!((*a).nextunit) ? (i64)0 : reg));
                if ((!!(tx) && !!((*a).nextunit))) {
                    mc_libmcl$popregs((u64)regs,0);
                }
;
L60 :;
                a = (*a).nextunit;
L62 :;
                            }
L61 :;
            ;
        }
        break;
    case 91:;
        {
            tx = mc_blockmcl$do_return(a);
        }
        break;
    case 23:;
        {
            tx = mc_blockmcl$do_returnmult(a);
            regs = (i64)mc_decls$regset;
        }
        break;
    case 26:;
        {
            tx = mc_blockmcl$do_assign(p,a,b);
        }
        break;
    case 28:;
        {
            mc_blockmcl$do_assignms(a,b);
        }
        break;
    case 93:;
        {
            mc_blockmcl$do_to(p,a,b);
        }
        break;
    case 94:;
        {
            tx = mc_blockmcl$do_if(p,a,b,c,(i64)0,reg);
        }
        break;
    case 95:;
    case 96:;
        {
            mc_blockmcl$do_for(p,a,b,c,(i64)((i64)(*p).tag == (i64)96));
        }
        break;
    case 97:;
        {
            mc_blockmcl$do_forall(p,a,b,c,(i64)0);
        }
        break;
    case 99:;
        {
            mc_blockmcl$do_while(p,a,b,c);
        }
        break;
    case 100:;
        {
            mc_blockmcl$do_repeat(p,a,b);
        }
        break;
    case 101:;
        {
            mc_blockmcl$do_goto(a);
        }
        break;
    case 102:;
        {
            mc_blockmcl$do_labeldef(p);
        }
        break;
    case 103:;
        {
            mc_blockmcl$do_exit(p,(i64)1);
        }
        break;
    case 104:;
        {
            mc_blockmcl$do_exit(p,(i64)2);
        }
        break;
    case 105:;
        {
            mc_blockmcl$do_exit(p,(i64)3);
        }
        break;
    case 106:;
        {
            mc_blockmcl$do_do(a);
        }
        break;
    case 107:;
        {
            tx = mc_blockmcl$do_case(p,a,b,c,(i64)0,(i64)0,reg);
        }
        break;
    case 108:;
        {
            mc_blockmcl$do_case(p,a,b,c,(i64)1,(i64)0,(i64)0);
        }
        break;
    case 109:;
        {
            tx = mc_blockmcl$do_switch(p,a,b,c,(i64)0,(i64)0,reg);
        }
        break;
    case 110:;
        {
            mc_blockmcl$do_switch(p,a,b,c,(i64)1,(i64)0,(i64)0);
        }
        break;
    case 111:;
        {
            mc_blockmcl$do_swap(a,b);
        }
        break;
    case 112:;
        {
            tx = mc_blockmcl$do_select(p,a,b,c,(i64)0,reg);
        }
        break;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
        {
            mc_blockmcl$do_print(p,a,b);
        }
        break;
    case 120:;
        {
            tx = mc_blockmcl$do_read(p,a);
        }
        break;
    case 121:;
        {
            mc_blockmcl$do_readln(a);
        }
        break;
    case 124:;
        {
            mc_blockmcl$do_stop(a);
        }
        break;
    case 125:;
        {
                        {i64 $temp = (i64)(*p).index;
if (($temp==(i64)0)) {
                tx = mc_blockmcl$loadunit(a,(i64)0);
            }
            else if (($temp==(i64)1)) {
                tx = mc_blockmcl$evalunit(a,(i64)0);
            }
            else if (($temp==(i64)2)) {
                tx = mc_blockmcl$loadref(a,(i64)1);
            }
            else if (($temp==(i64)3)) {
                tx = mc_blockmcl$loadref(a,(i64)0);
            }
            };
            mc_libmcl$genmc((i64)10,tx,0);
            mc_libmcl$gencomment((byte*)"",0);
            mc_libmcl$popregs((u64)regs,0);
            tx = 0;
        }
        break;
    case 14:;
        {
            tx = mc_blockmcl$do_andl(p,a,b,reg);
        }
        break;
    case 15:;
        {
            tx = mc_blockmcl$do_orl(p,a,b,reg);
        }
        break;
    case 31:;
    case 90:;
        {
            tx = mc_blockmcl$do_callproc(p,a,b,(i64)((i64)(*p).tag == (i64)31));
        }
        break;
    case 32:;
        {
            tx = mc_blockmcl$do_setcc(p,a,b,reg);
        }
        break;
    case 33:;
        {
            tx = mc_blockmcl$do_setccchain(p,a,reg);
        }
        break;
    case 34:;
        {
            tx = mc_blockmcl$do_bin(p,a,b,reg);
        }
        break;
    case 44:;
        {
            tx = mc_blockmcl$do_index(a,b,(i64)1,reg);
        }
        break;
    case 45:;
        {
            tx = mc_blockmcl$do_slice(p,a,b,reg);
        }
        break;
    case 47:;
        {
            tx = mc_blockmcl$do_dotindex(p,a,b,reg);
        }
        break;
    case 48:;
        {
            tx = mc_blockmcl$do_dotslice(p,a,b,reg);
        }
        break;
    case 46:;
        {
            tx = mc_blockmcl$do_dot(p,(i64)1,reg);
        }
        break;
    case 49:;
        {
            tx = mc_blockmcl$do_ptr(p,a,(i64)1,reg);
        }
        break;
    case 50:;
    case 51:;
        {
            if (!!(b)) {
                mm_support$gerror((byte*)"ADDROF OFFSET?",0);
            }
;
            tx = mc_blockmcl$loadref(a,reg);
        }
        break;
    case 52:;
        {
            tx = mc_blockmcl$do_convert(p,a,(i64)0);
        }
        break;
    case 55:;
        {
            tx = mc_blockmcl$do_typepun(p,a,reg);
        }
        break;
    case 53:;
        {
            tx = mc_blockmcl$loadunit(a,reg);
        }
        break;
    case 56:;
        {
            tx = mc_libmcl$genint((*p).value,(i64)8);
        }
        break;
    case 35:;
        {
            tx = mc_blockmcl$do_unary(p,a,reg);
        }
        break;
    case 16:;
        {
            tx = mc_blockmcl$do_notl(p,a,reg);
        }
        break;
    case 17:;
        {
            tx = mc_blockmcl$do_istruel(p,a,reg);
        }
        break;
    case 38:;
        {
            if (((i64)(*p).pclop == (i64)53 || (i64)(*p).pclop == (i64)54)) {
                mc_blockmcl$do_incr(p,a);
            }
            else {
                tx = mc_blockmcl$do_incrload(p,a,reg);
            }
;
        }
        break;
    case 36:;
        {
            mc_blockmcl$do_binto(p,a,b);
        }
        break;
    case 92:;
        {
            tx = mc_blockmcl$do_syscall(p,a,reg);
        }
        break;
    case 8:;
        {
            mc_libmcl$domcl_assem(p);
            if (!!((i64)(*p).mode)) {
                if (!!((i64)mm_decls$ttisreal[((i64)(*p).mode)])) {
                    tx = mc_libmcl$genxreg((i64)1,(i64)8);
                }
                else {
                    tx = mc_libmcl$genreg((i64)1,(i64)8);
                }
;
            }
;
        }
        break;
    case 66:;
        {
            tx = mc_libmcl$genint(mm_support$getlineno((u64)mm_tables$mlineno),(i64)8);
        }
        break;
    case 128:;
        {
            mc_blockmcl$do_clear(p,a);
        }
        break;
    default: {
        mm_support$gerror_s((byte*)"Loadunit: ",mm_tables$jtagnames[((i64)(*p).tag)],0);
        return 0;
    }
    } //SW
;
    if (!!((i64)(*p).resultflag)) {
        if ((tx == 0)) {
            mm_support$gerror((byte*)"1:Result expected",0);
        }
;
        if ((!!(reg) && ((i64)(*tx).reg != reg))) {
            oldreg = (i64)(*tx).reg;
            if ((((reg >= (i64)21) && (oldreg < (i64)21)) || ((reg < (i64)21) && (oldreg >= (i64)21)))) {
                mm_support$gerror((byte*)"LU/MOVE: MIXED REGS",0);
            }
;
            ax = mc_libmcl$genreg(reg,(i64)8);
            if ((reg >= (i64)21)) {
                mc_libmcl$genmc((i64)19,ax,tx);
            }
            else {
                mc_libmcl$genmc((i64)13,ax,tx);
            }
;
            tx = ax;
        }
;
        if (((i64)mm_decls$ttbasetype[((i64)(*p).mode)] != (i64)27)) {
            mc_libmcl$popregs((u64)regs,tx);
        }
;
    }
    else {
        if (!!(tx)) {
                        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)26) || ($temp==(i64)90) || ($temp==(i64)92)) {
            }
            else {
                mc_libmcl$popregs((u64)regs,0);
            }
            };
        }
        else {
            mc_libmcl$popregs((u64)regs,0);
        }
;
        return 0;
    }
;
    return tx;
}

struct mc_decls$opndrec *mc_blockmcl$evalunit(struct mm_decls$unitrec *p,i64 access) {
        struct mc_decls$opndrec *  tx;
        i64 iswrite;
        i64 regs;
        i64 doload;
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
    iswrite = (i64)0;
    a = (*p).a;
    b = (*p).b;
    if (!(!!((i64)mm_tables$ismemtag[((i64)(*p).tag)]))) {
        if (!!(iswrite)) {
            mm_support$gerror((byte*)"Evalunit: can't write",0);
        }
;
        return mc_blockmcl$loadunit(p,(i64)0);
    }
;
    regs = (i64)mc_decls$regset;
    doload = (i64)0;
    if ((((access == (i64)65) && !!((i64)(*p).memmode)) && !!((i64)mm_decls$ttisshort[((i64)(*p).memmode)]))) {
        doload = (i64)1;
    }
;
    switch ((i64)(*p).tag) {
    case 1:;
        {
            tx = mc_blockmcl$do_const(p,doload,(i64)0);
        }
        break;
    case 4:;
        {
            tx = mc_blockmcl$do_name(p,doload,(i64)0);
        }
        break;
    case 125:;
        {
            tx = mc_blockmcl$evalunit(a,(i64)0);
            mc_libmcl$genmc((i64)10,tx,0);
            mc_libmcl$popregs((u64)regs,0);
            tx = 0;
        }
        break;
    case 44:;
        {
            tx = mc_blockmcl$do_index(a,b,doload,(i64)0);
        }
        break;
    case 47:;
    case 48:;
        {
            return mc_blockmcl$loadunit(p,(i64)0);
        }
        break;
    case 46:;
        {
            tx = mc_blockmcl$do_dot(p,doload,(i64)0);
        }
        break;
    case 49:;
        {
            tx = mc_blockmcl$do_ptr(p,a,doload,(i64)0);
        }
        break;
    case 50:;
        {
            if (!!(b)) {
                mm_support$gerror((byte*)"ADDROF OFFSET?",0);
            }
;
            tx = mc_blockmcl$loadref(a,(i64)0);
        }
        break;
    default: {
        mm_support$gerror_s((byte*)"Evalunit: ",mm_tables$jtagnames[((i64)(*p).tag)],0);
        return 0;
    }
    } //SW
;
    if (!!((i64)(*p).resultflag)) {
        if ((tx == 0)) {
            mm_support$gerror((byte*)"2:Result expected",0);
        }
;
    }
    else {
        if (!!(tx)) {
            mc_libmcl$popregs((u64)regs,tx);
        }
;
        return 0;
    }
;
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$loadref(struct mm_decls$unitrec *p,i64 reg) {
        struct mc_decls$opndrec *  px;
        i64 regs;
    regs = (i64)mc_decls$regset;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)94)) {
        px = mc_blockmcl$do_if(p,(*p).a,(*p).b,(*p).c,reg,(i64)0);
    }
    else if (($temp==(i64)31)) {
        if (!!((i64)mm_decls$ttisblock[((i64)(*p).mode)])) {
            px = mc_blockmcl$loadunit(p,reg);
            mc_libmcl$popregs((u64)regs,px);
            return px;
        }
;
        goto L63 ;
;
    }
    else if (($temp==(i64)45)) {
        px = mc_blockmcl$loadunit(p,(i64)0);
    }
    else {
        if (!(!!((i64)mm_tables$ismemtag[((i64)(*p).tag)]))) {
            //error:
L63 :;
;
            mm_support$gerror_s((byte*)"Loadref? ",mm_tables$jtagnames[((i64)(*p).tag)],0);
        }
        else {
            px = mc_blockmcl$evalunit(p,(i64)87);
        }
;
    }
    };
    px = mc_blockmcl$loadmemaddr(px,reg);
    mc_libmcl$popregs((u64)regs,px);
    return px;
}

void mc_blockmcl$pushunit(struct mm_decls$unitrec *p) {
        i64 regs;
        struct mc_decls$opndrec *  ax;
    regs = (i64)mc_decls$regset;
    ax = mc_blockmcl$loadunit(p,(i64)0);
    if (!!((i64)mm_decls$ttisreal[((i64)(*p).mode)])) {
        mc_libmcl$pushstack((i64)8);
        mc_libmcl$genmc((i64)19,mc_decls$distackopnd,ax);
    }
    else {
        mc_libmcl$genmc((i64)14,ax,0);
    }
;
    ++(mc_decls$mstackdepth);
    mc_libmcl$popregs((u64)regs,0);
}

static struct mc_decls$opndrec *mc_blockmcl$poptoreg(i64 m,i64 reg) {
        struct mc_decls$opndrec *  ax;
    if (!!((i64)mm_decls$ttisreal[(m)])) {
        if ((m == (i64)5)) {
            ax = mc_libmcl$genxreg(reg,(i64)8);
            mc_libmcl$genmc((i64)19,ax,mc_decls$distackopnd);
        }
        else {
            ax = mc_libmcl$genxreg(reg,(i64)4);
            mc_libmcl$genmc((i64)18,ax,mc_libmcl$changeopndsize(mc_decls$distackopnd,(i64)4));
        }
;
        mc_libmcl$popstack((i64)8);
    }
    else {
        ax = mc_libmcl$genreg(reg,(i64)8);
        mc_libmcl$genmc((i64)15,ax,0);
    }
;
    --(mc_decls$mstackdepth);
    return ax;
}

i64 mc_blockmcl$poptoarg(i64 m,i64 argno,i64 variadic) {
        struct mc_decls$opndrec *  ax;
    if (!!((i64)mm_decls$ttisreal[(m)])) {
        ax = mc_libmcl$genxreg((argno + (i64)20),(i64)8);
        mc_libmcl$genmc(((m == (i64)5) ? (i64)19 : (i64)18),ax,mc_decls$distackopnd);
        mc_libmcl$popstack((i64)8);
        if ((argno >= variadic)) {
            mc_libmcl$genmc((i64)19,mc_libmcl$genreg(((argno + (i64)11) - (i64)1),(i64)8),mc_libmcl$genxreg(((argno + (i64)21) - (i64)1),(i64)8));
        }
;
    }
    else {
        ax = mc_libmcl$genreg((argno + (i64)10),(i64)8);
        mc_libmcl$genmc((i64)15,ax,0);
    }
;
    --(mc_decls$mstackdepth);
    return (i64)(*ax).reg;
}

void mc_blockmcl$loadarg(struct mm_decls$unitrec *p,i64 argno,i64 variadic) {
    --(argno);
    if (!!((i64)mm_decls$ttisreal[((i64)(*p).mode)])) {
        mc_blockmcl$loadunit(p,(argno + (i64)21));
        if ((!!(variadic) && ((argno + (i64)1) >= variadic))) {
            mc_libmcl$genmc((i64)19,mc_libmcl$genreg((argno + (i64)11),(i64)8),mc_libmcl$genxreg((argno + (i64)21),(i64)8));
        }
;
    }
    else {
        mc_blockmcl$loadunit(p,(argno + (i64)11));
    }
;
}

static void mc_blockmcl$loadbin(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg,i64 isrev,i64 loadb) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
    if (((!(!!(loadb)) && !!((i64)(*b).memmode)) && ((i64)mm_decls$ttcat[((i64)(*b).memmode)] == (i64)4))) {
        loadb = (i64)1;
    }
;
    if (!!((i64)(*b).simple)) {
        ax = mc_blockmcl$loadunit(a,reg);
        bx = (!!(loadb) ? mc_blockmcl$loadunit(b,(i64)0) : mc_blockmcl$evalunit(b,(i64)0));
    }
    else if ((!!((i64)(*a).simple) && !!(isrev))) {
        ax = mc_blockmcl$loadunit(b,reg);
        bx = (!!(loadb) ? mc_blockmcl$loadunit(a,(i64)0) : mc_blockmcl$evalunit(a,(i64)0));
    }
    else {
        mc_blockmcl$pushunit(a);
        bx = (!!(loadb) ? mc_blockmcl$loadunit(b,(i64)0) : mc_blockmcl$evalunit(b,(i64)0));
        ax = mc_blockmcl$poptoreg((i64)(*a).mode,(i64)0);
    }
;
    mc_blockmcl$axb = ax;
    mc_blockmcl$bxb = bx;
}

static void mc_blockmcl$loadbinto(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 loadb) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
    if (!!((i64)(*b).simple)) {
        ax = mc_blockmcl$evalunit(a,(i64)87);
        bx = (!!(loadb) ? mc_blockmcl$loadunit(b,(i64)0) : mc_blockmcl$evalunit(b,(i64)65));
    }
    else if (!!((i64)(*a).simple)) {
        bx = (!!(loadb) ? mc_blockmcl$loadunit(b,(i64)0) : mc_blockmcl$evalunit(b,(i64)65));
        ax = mc_blockmcl$evalunit(a,(i64)87);
    }
    else {
        mc_blockmcl$pushunit(b);
        ax = mc_blockmcl$evalunit(a,(i64)87);
        bx = mc_blockmcl$poptoreg((i64)(*b).mode,(i64)0);
    }
;
    mc_blockmcl$axb = ax;
    mc_blockmcl$bxb = bx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_const(struct mm_decls$unitrec *p,i64 load,i64 reg) {
        struct mc_decls$opndrec *  ax;
        i64 mode;
        struct mc_decls$opndrec *  px;
    mode = (i64)(*p).mode;
    if ((!!((i64)mm_decls$ttisinteger[(mode)]) || (mode == (i64)6))) {
        if ((!(!!(load)) && ((*p).value >= (i64)-2147483648 && (*p).value <= (i64)2147483647))) {
            return mc_libmcl$genint((*p).value,(i64)8);
        }
;
        //loadint:
L64 :;
;
        mc_libmcl$genmc((i64)13,(ax = mc_libmcl$genreg(reg,(i64)8)),mc_libmcl$genint((*p).value,(i64)8));
    }
    else if (!!((i64)mm_decls$ttisreal[(mode)])) {
        px = mc_libmcl$genrealmem((*p).xvalue,mode);
        if (!(!!(load))) {
            return px;
        }
;
        mc_libmcl$genmc(((mode == (i64)5) ? (i64)19 : (i64)18),(ax = mc_libmcl$genxreg(reg,(i64)8)),px);
        return ax;
    }
    else if (!!((i64)mm_decls$ttisref[(mode)])) {
        if (!!((i64)(*p).isastring)) {
            mc_libmcl$genmc((i64)13,(ax = mc_libmcl$genreg(reg,(i64)8)),mc_libmcl$genstring((*p).svalue,(i64)-1));
        }
        else {
            goto L64 ;
;
        }
;
    }
    else {
        mm_support$gerror((byte*)"do_const",0);
    }
;
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_name(struct mm_decls$unitrec *p,i64 load,i64 reg) {
        struct mc_decls$opndrec *  tx;
        struct mm_decls$strec *  d;
        struct mc_decls$opndrec *  px;
        i64 cat;
    d = (*p).def;
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)6) || ($temp==(i64)7)) {
        if (!!(load)) {
            mc_libmcl$genmc((i64)13,(tx = mc_libmcl$genreg(reg,(i64)8)),mc_libmcl$genmemaddr(d));
            return tx;
        }
        else {
            return mc_libmcl$genmemaddr(d);
        }
;
    }
    else if (($temp==(i64)17)) {
        if (((i64)(*d).index == (i64)0)) {
            (*d).index = ++(mc_decls$mlabelno);
        }
;
        if (!!((i64)(*p).resultflag)) {
            mc_libmcl$genmc((i64)13,(tx = mc_libmcl$genreg(reg,(i64)8)),mc_libmcl$genlabel((i64)(*d).index));
            return tx;
        }
        else {
            mc_blockmcl$genjumpl((i64)(*d).index);
        }
;
        (*p).resultflag = (i64)0;
        (*p).mode = (i64)0;
    }
    else {
        px = mc_libmcl$genmem(d);
        cat = (i64)mm_decls$ttcat[((i64)(*d).mode)];
        if (!(!!(load))) {
            return px;
        }
;
        tx = (!!((i64)mm_decls$ttisreal[((i64)(*d).mode)]) ? mc_libmcl$genxreg(reg,(i64)msysc$m_getdotslice((i64)(*px).misc,(i64)0,(i64)3)) : mc_libmcl$genreg(reg,(i64)8));
        if ((cat==(i64)1) || (cat==(i64)3)) {
            mc_libmcl$genmc(mc_libmcl$getopndmov(tx),tx,px);
        }
        else if ((cat==(i64)2)) {
            mc_libmcl$genmc(mc_libmcl$getopndmov(tx),tx,px);
        }
        else if ((cat==(i64)4)) {
            mc_libmcl$genmc((!!((i64)mm_decls$ttsigned[((i64)(*d).mode)]) ? (i64)20 : (i64)21),tx,px);
        }
        else if ((cat==(i64)5)) {
            mc_libmcl$genmc((i64)16,tx,px);
        }
;
        return tx;
    }
    };
    return (struct mc_decls$opndrec *)0;
}

static void mc_blockmcl$genjumpl(i64 lab) {
    mc_libmcl$genmc((i64)27,mc_libmcl$genlabel(lab),0);
}

static struct mc_decls$opndrec *mc_blockmcl$do_assign(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        struct mc_decls$opndrec *  tx;
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mm_decls$strec *  d;
        i64 regs;
    regs = (i64)mc_decls$regset;
    tx = 0;
    if (((i64)(*b).tag == (i64)18)) {
        if (!(!!((i64)(*p).resultflag))) {
            mm_support$gerror((byte*)"ASSIGNBLOCK",0);
            return 0;
        }
;
    }
;
    if ((((i64)(*b).tag == (i64)22) && ((i64)(*a).tag == (i64)4))) {
        ax = mc_blockmcl$loadunit((*b).a,(i64)0);
        bx = mc_blockmcl$loadunit((*b).b,(i64)0);
        d = (*a).def;
        mc_libmcl$genmc((i64)13,(px = mc_libmcl$genmem(d)),ax);
        mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(px,(i64)8,(i64)0),bx);
        mc_libmcl$popregs((u64)regs,0);
        if (!!((i64)(*p).resultflag)) {
            mc_libmcl$genmc((i64)16,(tx = mc_libmcl$genreg((i64)0,(i64)8)),mc_libmcl$genmem(d));
        }
;
        return tx;
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)47)) {
        tx = mc_blockmcl$do_storedotindex(a,b,(i64)(*p).resultflag);
        return tx;
    }
    else if (($temp==(i64)48)) {
        tx = mc_blockmcl$do_storedotslice(a,b,(i64)(*p).resultflag);
        return tx;
    }
    };
    (*a).resultflag = (i64)1;
    mc_blockmcl$loadbinto(a,b,(i64)1);
    px = mc_blockmcl$axb;
    bx = mc_blockmcl$bxb;
    tx = mc_blockmcl$storemem(px,bx,mm_lib$getmemmode(a),(i64)(*p).resultflag);
    if (!!((i64)(*p).resultflag)) {
        mc_libmcl$popregs((u64)regs,tx);
        return tx;
    }
    else {
        mc_libmcl$popregs((u64)regs,0);
        return (struct mc_decls$opndrec *)0;
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$loadmem(i64 load,struct mc_decls$opndrec *ax,i64 reg,i64 mode) {
        struct mc_decls$opndrec *  tx;
    if (!(!!(load))) {
        return ax;
    }
;
    if ((msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) == (i64)1 || msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) == (i64)2)) {
        if (((i64)(*ax).reg != reg)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"*************LOADMEM/ALREADY IN REG",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mc_libmcl$gencomment((byte*)"LOADMEM: MOVE REG NEEDED",0);
        }
;
        return ax;
    }
;
    if (!!((i64)mm_decls$ttisreal[(mode)])) {
        tx = mc_libmcl$genxreg(reg,(i64)8);
    }
    else {
        tx = mc_libmcl$genreg(reg,(i64)8);
    }
;
        {i64 $temp = (i64)mm_decls$ttcat[(mode)];
if (($temp==(i64)1)) {
        mc_libmcl$genmc((i64)13,tx,ax);
    }
    else if (($temp==(i64)3)) {
        mc_libmcl$genmc((i64)19,tx,ax);
    }
    else if (($temp==(i64)2)) {
        mc_libmcl$genmc((i64)18,tx,ax);
    }
    else if (($temp==(i64)4)) {
        mc_libmcl$genmc((!!((i64)mm_decls$ttsigned[(mode)]) ? (i64)20 : (i64)21),tx,mc_libmcl$changeopndsize(ax,(i64)mm_decls$ttsize[(mode)]));
    }
    else if (($temp==(i64)5)) {
        if (((((((i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) == (i64)4) && !!((i64)(*ax).reg)) && ((i64)(*ax).regix == (i64)0)) && ((i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)12,(i64)15) == (i64)0)) && ((i64)(*ax).offset == (i64)0))) {
            return mc_libmcl$genreg((i64)(*ax).reg,(i64)8);
        }
;
        mc_libmcl$genmc((i64)16,tx,ax);
    }
    };
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$loadmemaddr(struct mc_decls$opndrec *ax,i64 reg) {
        struct mc_decls$opndrec *  tx;
    if (((msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) == (i64)1 || msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) == (i64)2) && (reg >= (i64)1 && reg <= (i64)14))) {
        if (((i64)(*ax).reg != reg)) {
            mc_libmcl$gencomment((byte*)"LOADMEMADDR: MOVE REG NEEDED",0);
        }
;
        return ax;
    }
;
    tx = mc_libmcl$genreg(reg,(i64)8);
    mc_libmcl$genmc((((i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) == (i64)3) ? (i64)13 : (i64)16),tx,ax);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$storemem(struct mc_decls$opndrec *ax,struct mc_decls$opndrec *bx,i64 mode,i64 needres) {
        i64 regs;
    regs = (i64)mc_decls$regset;
        {i64 $temp = (i64)mm_decls$ttcat[(mode)];
if (($temp==(i64)1)) {
        mc_libmcl$genmc((i64)13,ax,bx);
    }
    else if (($temp==(i64)3)) {
        mc_libmcl$genmc((i64)19,ax,bx);
    }
    else if (($temp==(i64)2)) {
        mc_libmcl$genmc((i64)18,ax,bx);
    }
    else if (($temp==(i64)4)) {
        mc_libmcl$genmc((i64)13,ax,mc_libmcl$changeopndsize(bx,(i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)0,(i64)3)));
    }
    else if (($temp==(i64)5)) {
        mc_libmcl$copyblock(ax,bx,(i64)mm_decls$ttsize[(mode)],(i64)1);
    }
    };
    if (!(!!(needres))) {
        bx = 0;
    }
;
    mc_libmcl$popregs((u64)regs,bx);
    return bx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_bin(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg) {
        u8 str[100];
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  tx;
        i64 cat;
        i64 opc;
        i64 size;
        i64 regs;
        i64 scale;
        i64 n;
        i64 target;
        i64 rev;
    bx = 0;
    cat = (i64)mm_decls$ttcat[((i64)(*p).mode)];
    target = (i64)mm_decls$tttarget[((i64)(*a).mode)];
    regs = (i64)mc_decls$regset;
    rev = (i64)0;
    switch ((i64)(*p).pclop) {
    case 1:;
        {
            rev = (i64)1;
            if ((cat==(i64)1)) {
                opc = (i64)30;
            }
            else if ((cat==(i64)3)) {
                opc = (i64)69;
            }
            else if ((cat==(i64)2)) {
                opc = (i64)65;
            }
            else {
                goto L65 ;
;
            }
;
            //doadd:
L66 :;
;
            mc_blockmcl$loadbin(a,b,reg,rev,(i64)0);
            ax = mc_blockmcl$axb;
            bx = mc_blockmcl$bxb;
            mc_libmcl$genmc(opc,ax,bx);
        }
        break;
    case 2:;
        {
            if ((cat==(i64)1)) {
                opc = (i64)31;
            }
            else if ((cat==(i64)3)) {
                opc = (i64)70;
            }
            else if ((cat==(i64)2)) {
                opc = (i64)66;
            }
            else {
                goto L65 ;
;
            }
;
            goto L66 ;
;
        }
        break;
    case 3:;
        {
            rev = (i64)1;
            if ((cat==(i64)1)) {
                opc = (i64)36;
            }
            else if ((cat==(i64)3)) {
                opc = (i64)71;
            }
            else if ((cat==(i64)2)) {
                opc = (i64)67;
            }
            else {
                goto L65 ;
;
            }
;
            goto L66 ;
;
        }
        break;
    case 4:;
        {
            if ((cat==(i64)1)) {
                goto L67 ;
;
            }
            else if ((cat==(i64)3)) {
                opc = (i64)72;
            }
            else if ((cat==(i64)2)) {
                opc = (i64)68;
            }
            else {
                goto L65 ;
;
            }
;
            goto L66 ;
;
        }
        break;
    case 8:;
        {
            if ((cat != (i64)1)) {
                goto L65 ;
;
            }
;
            rev = (i64)1;
            opc = (i64)40;
            goto L66 ;
;
        }
        break;
    case 9:;
        {
            if ((cat != (i64)1)) {
                goto L65 ;
;
            }
;
            rev = (i64)1;
            opc = (i64)41;
            goto L66 ;
;
        }
        break;
    case 10:;
        {
            if ((cat != (i64)1)) {
                goto L65 ;
;
            }
;
            rev = (i64)1;
            opc = (i64)42;
            goto L66 ;
;
        }
        break;
    case 15:;
        {
            if ((cat==(i64)3)) {
                opc = (i64)113;
            }
            else if ((cat==(i64)2)) {
                opc = (i64)111;
            }
            else if ((cat==(i64)1)) {
                mc_blockmcl$loadbin(a,b,reg,(i64)0,(i64)1);
                ax = mc_blockmcl$axb;
                bx = mc_blockmcl$bxb;
                mc_libmcl$genmc((i64)44,ax,bx);
                mc_libmcl$genmc_cond((i64)17,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)15 : (i64)7),ax,bx);
                goto L68 ;
;
            }
;
            goto L66 ;
;
        }
        break;
    case 16:;
        {
            if ((cat==(i64)3)) {
                opc = (i64)114;
            }
            else if ((cat==(i64)2)) {
                opc = (i64)112;
            }
            else if ((cat==(i64)1)) {
                mc_blockmcl$loadbin(a,b,reg,(i64)0,(i64)1);
                ax = mc_blockmcl$axb;
                bx = mc_blockmcl$bxb;
                mc_libmcl$genmc((i64)44,ax,bx);
                mc_libmcl$genmc_cond((i64)17,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)12 : (i64)2),ax,bx);
                goto L68 ;
;
            }
;
            goto L66 ;
;
        }
        break;
    case 5:;
        {
            //doidiv:
L67 :;
;
            ax = mc_blockmcl$do_divrem(a,b,(i64)mm_decls$ttsigned[((i64)(*a).mode)],(i64)1);
        }
        break;
    case 6:;
        {
            ax = mc_blockmcl$do_divrem(a,b,(i64)mm_decls$ttsigned[((i64)(*a).mode)],(i64)0);
        }
        break;
    case 26:;
        {
            size = (i64)mm_decls$ttsize[(target)];
            if (((i64)(*b).tag == (i64)1)) {
                ax = mc_blockmcl$loadunit(a,(i64)0);
                tx = mc_libmcl$genindex((i64)(*ax).reg,(i64)0,(i64)1,((*b).value * size),(i64)0,(i64)0,0);
            }
            else {
                mc_blockmcl$loadbin(a,b,reg,(i64)0,(i64)1);
                ax = mc_blockmcl$axb;
                bx = mc_blockmcl$bxb;
                scale = mc_libmcl$scaleindex(bx,size);
                tx = mc_libmcl$genindex((i64)(*ax).reg,(i64)(*bx).reg,scale,(i64)0,(i64)0,(i64)0,0);
            }
;
            mc_libmcl$genmc((i64)16,(ax = mc_libmcl$genreg((i64)0,(i64)8)),tx);
        }
        break;
    case 27:;
        {
            size = (i64)mm_decls$ttsize[(target)];
            if (((i64)(*b).tag == (i64)1)) {
                ax = mc_blockmcl$loadunit(a,(i64)0);
                tx = mc_libmcl$genindex((i64)(*ax).reg,(i64)0,(i64)1,(-((*b).value) * size),(i64)0,(i64)0,0);
            }
            else {
                mc_blockmcl$loadbin(a,b,reg,(i64)0,(i64)1);
                ax = mc_blockmcl$axb;
                bx = mc_blockmcl$bxb;
                mc_libmcl$mulimm(bx,size);
                mc_libmcl$genmc((i64)31,ax,bx);
                mc_libmcl$popregs((u64)regs,0);
                return ax;
            }
;
            mc_libmcl$genmc((i64)16,(ax = mc_libmcl$genreg((i64)0,(i64)8)),tx);
        }
        break;
    case 28:;
        {
            size = (i64)mm_decls$ttsize[(target)];
            ax = mc_blockmcl$loadunit(a,(i64)0);
            bx = mc_blockmcl$loadunit(b,(i64)0);
            mc_libmcl$genmc((i64)31,ax,bx);
            if ((size > (i64)1)) {
                n = mm_lib$ispoweroftwo(size);
                if (!!(n)) {
                    mc_libmcl$genmc((i64)47,ax,mc_libmcl$genint(n,(i64)8));
                }
                else {
                    mm_support$gerror((byte*)"ref-ref not 2^n",0);
                }
;
            }
;
        }
        break;
    case 11:;
        {
            ax = mc_blockmcl$do_shift(a,b,(i64)45);
        }
        break;
    case 12:;
        {
            ax = mc_blockmcl$do_shift(a,b,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)46 : (i64)47));
        }
        break;
    case 51:;
        {
            if (!!((i64)mm_decls$ttsigned[((i64)(*a).mode)])) {
                ax = mc_libmcl$gensysfn((i64)35,a,b,0);
            }
            else {
                ax = mc_blockmcl$do_maths2(a,b,reg,(byte*)"pow*");
            }
;
        }
        break;
    default: {
        //error:
L65 :;
;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"Bin:#:#");
        msysc$m_print_str(mm_tables$pclnames[((i64)(*p).pclop)],NULL);
        msysc$m_print_str(mm_lib$strmode((i64)(*p).mode,(i64)1),NULL);
        msysc$m_print_end();
        ;
        mm_support$gerror(str,0);
    }
    } //SW
;
    //finish:
L68 :;
;
    mc_libmcl$popregs((u64)regs,ax);
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_unary(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg) {
        u8 str[100];
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  lx;
        i64 cat;
        i64 opc;
        i64 regs;
    bx = 0;
    cat = (i64)mm_decls$ttcat[((i64)(*p).mode)];
    regs = (i64)mc_decls$regset;
    switch ((i64)(*p).pclop) {
    case 29:;
        {
            ax = mc_blockmcl$loadunit(a,reg);
            if ((cat==(i64)1)) {
                mc_libmcl$genmc((i64)52,ax,0);
            }
            else if ((cat==(i64)3)) {
                if (!(!!(mc_decls$labneg64))) {
                    mc_decls$labneg64 = mc_libmcl$createfwdlabel();
                }
;
                mc_libmcl$genmc((i64)75,ax,mc_libmcl$genlabelmem(mc_decls$labneg64));
            }
            else if ((cat==(i64)2)) {
                if (!(!!(mc_decls$labneg32))) {
                    mc_decls$labneg32 = mc_libmcl$createfwdlabel();
                }
;
                mc_libmcl$genmc((i64)76,ax,mc_libmcl$genlabelmem(mc_decls$labneg32));
            }
            else {
                goto L69 ;
;
            }
;
        }
        break;
    case 31:;
        {
            ax = mc_blockmcl$loadunit(a,reg);
            mc_libmcl$genmc((i64)53,ax,0);
        }
        break;
    case 30:;
        {
            ax = mc_blockmcl$loadunit(a,reg);
            if ((cat==(i64)1)) {
                mc_libmcl$genmc((i64)44,ax,mc_libmcl$genint((i64)0,(i64)8));
                mc_libmcl$genmc_cond((i64)28,(i64)13,(lx = mc_libmcl$genlabel(++(mc_decls$mlabelno))),0);
                mc_libmcl$genmc((i64)52,ax,0);
                mc_libmcl$genmc((i64)11,lx,0);
            }
            else if ((cat==(i64)3)) {
                if (!(!!(mc_decls$lababs64))) {
                    mc_decls$lababs64 = mc_libmcl$createfwdlabel();
                }
;
                mc_libmcl$genmc((i64)77,ax,mc_libmcl$genlabelmem(mc_decls$lababs64));
            }
            else if ((cat==(i64)2)) {
                if (!(!!(mc_decls$lababs32))) {
                    mc_decls$lababs32 = mc_libmcl$createfwdlabel();
                }
;
                mc_libmcl$genmc((i64)78,ax,mc_libmcl$genlabelmem(mc_decls$lababs32));
            }
;
        }
        break;
    case 34:;
        {
            ax = mc_blockmcl$loadunit(a,reg);
            if ((cat==(i64)1)) {
                opc = (i64)36;
            }
            else if ((cat==(i64)3)) {
                opc = (i64)71;
            }
            else if ((cat==(i64)2)) {
                opc = (i64)67;
            }
            else {
                goto L69 ;
;
            }
;
            mc_libmcl$genmc(opc,ax,ax);
        }
        break;
    case 35:;
        {
            ax = mc_blockmcl$loadunit(a,reg);
            if ((cat==(i64)3)) {
                opc = (i64)63;
            }
            else if ((cat==(i64)2)) {
                opc = (i64)64;
            }
            else {
                goto L69 ;
;
            }
;
            mc_libmcl$genmc(opc,ax,ax);
        }
        break;
    case 36:;
    case 37:;
    case 38:;
    case 39:;
    case 40:;
    case 41:;
    case 44:;
    case 45:;
    case 47:;
    case 46:;
        {
            strcpy(str,(mm_tables$pclnames[((i64)(*p).pclop)] + (i64)1));
            strcat(str,(byte*)"*");
            //domaths:
L70 :;
;
            ax = mc_blockmcl$do_maths(a,reg,str);
        }
        break;
    case 42:;
        {
            strcpy(str,(byte*)"log*");
            goto L70 ;
;
        }
        break;
    case 43:;
        {
            strcpy(str,(byte*)"log10*");
            goto L70 ;
;
        }
        break;
    case 104:;
        {
            ax = mc_blockmcl$loadunit(a,reg);
            bx = mc_libmcl$genireg((i64)(*ax).reg,(i64)8,(i64)0);
            mc_libmcl$genmc((i64)13,ax,mc_libmcl$makeopndind(ax,(i64)0));
        }
        break;
    case 88:;
        {
            ax = mc_blockmcl$loadunit(a,reg);
            bx = mc_libmcl$genireg((i64)(*ax).reg,(i64)8,(i64)0);
            mc_libmcl$genmc((i64)13,ax,mc_libmcl$applyoffset(mc_libmcl$makeopndind(ax,(i64)0),(i64)8,(i64)0));
        }
        break;
    default: {
        //error:
L69 :;
;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"Unary:#:#");
        msysc$m_print_str(mm_tables$pclnames[((i64)(*p).pclop)],NULL);
        msysc$m_print_str(mm_lib$strmode((i64)(*p).mode,(i64)1),NULL);
        msysc$m_print_end();
        ;
        mm_support$gerror(str,0);
        goto L69 ;
;
    }
    } //SW
;
    mc_libmcl$popregs((u64)regs,ax);
    return ax;
}

static void mc_blockmcl$do_labeldef(struct mm_decls$unitrec *p) {
        struct mm_decls$strec *  d;
        u8 str[256];
    d = (*p).def;
    if (((i64)(*d).index == (i64)0)) {
        (*d).index = ++(mc_decls$mlabelno);
    }
;
    msysc$m_print_startstr(str);
    msysc$m_print_str((*d).name,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)"::",NULL);
    msysc$m_print_end();
    ;
    mc_libmcl$gencomment((u8 *)str,0);
    mc_libmcl$genmc((i64)11,mc_libmcl$genlabel((i64)(*d).index),0);
}

static void mc_blockmcl$do_goto(struct mm_decls$unitrec *a) {
        struct mc_decls$opndrec *  ax;
        struct mm_decls$strec *  d;
        i64 regs;
    if ((((i64)(*a).tag == (i64)4) && ((i64)(*(*a).def).nameid == (i64)17))) {
        d = (*a).def;
        if (((i64)(*d).index == (i64)0)) {
            (*d).index = ++(mc_decls$mlabelno);
        }
;
        mc_libmcl$genmc((i64)27,mc_libmcl$genlabel((i64)(*d).index),0);
    }
    else {
        regs = (i64)mc_decls$regset;
        ax = mc_blockmcl$loadunit(a,(i64)0);
        mc_libmcl$genmc((i64)27,ax,0);
        mc_libmcl$popregs((u64)regs,0);
    }
;
}

static void mc_blockmcl$do_to(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  cx;
        struct mm_decls$unitrec *  cvar;
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 count;
        i64 regs;
    regs = (i64)mc_decls$regset;
    cvar = (*p).c;
    (*a).mode = (i64)3;
    ax = mc_blockmcl$loadunit(a,(i64)0);
    mc_libmcl$genmc((i64)13,(cx = mc_libmcl$genmem((*cvar).def)),ax);
    mc_libmcl$popregs((u64)regs,0);
    lab_b = mc_libmcl$createfwdlabel();
    lab_c = mc_libmcl$createfwdlabel();
    lab_d = mc_libmcl$createfwdlabel();
    mc_libmcl$stacklooplabels(lab_b,lab_c,lab_d);
    if (((i64)(*a).tag != (i64)1)) {
        ax = mc_blockmcl$loadunit(cvar,(i64)0);
        mc_libmcl$genmc((i64)44,ax,mc_libmcl$genint((i64)0,(i64)8));
        mc_libmcl$genmc_cond((i64)28,(i64)14,mc_libmcl$genlabel(lab_d),0);
        mc_libmcl$popregs(mc_decls$regset,0);
    }
    else {
        count = (*a).value;
        if ((count <= (i64)0)) {
            mc_blockmcl$genjumpl(lab_d);
        }
;
    }
;
    mc_libmcl$definefwdlabel(lab_b);
    mc_libmcl$popregs((u64)regs,0);
    mc_blockmcl$loadunit(b,(i64)0);
    mc_libmcl$definefwdlabel(lab_c);
    mc_libmcl$genmc((i64)55,cx,0);
    mc_libmcl$genmc_cond((i64)28,(i64)5,mc_libmcl$genlabel(lab_b),0);
    mc_libmcl$definefwdlabel(lab_d);
    --(mc_libmcl$loopindex);
}

static void mc_blockmcl$docond(i64 opc,struct mm_decls$unitrec *p,i64 lab) {
    mc_blockmcl$genjumpcond(opc,p,lab);
}

static void mc_blockmcl$genjumpcond(i64 opc,struct mm_decls$unitrec *p,i64 lab) {
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  r;
        struct mm_decls$unitrec *  s;
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
        i64 lab2;
        i64 i;
        i64 regs;
        i64 regs2;
        i64 nolab;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  cx;
        struct mc_decls$opndrec *  lx;
    regs = (i64)mc_decls$regset;
    q = (*p).a;
    r = (*p).b;
    switch ((i64)(*p).tag) {
    case 14:;
        {
            if ((opc==(i64)0)) {
                mc_blockmcl$genjumpcond((i64)0,q,lab);
                mc_blockmcl$genjumpcond((i64)0,r,lab);
            }
            else if ((opc==(i64)1)) {
                lab2 = mc_libmcl$createfwdlabel();
                mc_blockmcl$genjumpcond((i64)0,q,lab2);
                mc_blockmcl$genjumpcond((i64)1,r,lab);
                mc_libmcl$definefwdlabel(lab2);
            }
;
        }
        break;
    case 15:;
        {
            if ((opc==(i64)0)) {
                lab2 = mc_libmcl$createfwdlabel();
                mc_blockmcl$genjumpcond((i64)1,q,lab2);
                mc_blockmcl$genjumpcond((i64)0,r,lab);
                mc_libmcl$definefwdlabel(lab2);
            }
            else if ((opc==(i64)1)) {
                mc_blockmcl$genjumpcond((i64)1,q,lab);
                mc_blockmcl$genjumpcond((i64)1,r,lab);
            }
;
        }
        break;
    case 16:;
        {
            if ((opc==(i64)0)) {
                mc_blockmcl$genjumpcond((i64)1,q,lab);
            }
            else if ((opc==(i64)1)) {
                mc_blockmcl$genjumpcond((i64)0,q,lab);
            }
;
        }
        break;
    case 17:;
        {
            ax = mc_blockmcl$loadunit(q,(i64)0);
            if (((i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) == (i64)2)) {
                mc_libmcl$genmc((((i64)(*q).mode == (i64)4) ? (i64)18 : (i64)19),(bx = mc_libmcl$genreg((i64)0,(i64)8)),ax);
                ax = bx;
            }
;
            mc_libmcl$genmc((i64)40,ax,ax);
            mc_libmcl$genmc_cond((i64)28,((opc == (i64)1) ? (i64)5 : (i64)4),mc_libmcl$genlabel(lab),0);
            mc_libmcl$popregs((u64)regs,0);
        }
        break;
    case 6:;
        {
            L71 :;
            while ((!!(q) && !!((*q).nextunit))) {
                mc_blockmcl$loadunit(q,(i64)0);
                q = (*q).nextunit;
L72 :;
            }
L73 :;
            ;
            mc_blockmcl$genjumpcond(opc,q,lab);
        }
        break;
    case 32:;
        {
            mc_blockmcl$gcomparejump(opc,(i64)(*p).pclop,q,r,lab);
        }
        break;
    case 40:;
        {
            a = (*r).a;
            b = (*r).b;
            if (!((!!((i64)(*a).simple) && !!((i64)(*b).simple)))) {
                mm_support$gerror((byte*)"inrange/complx",0);
            }
;
            ax = mc_blockmcl$loadunit(q,(i64)0);
            bx = mc_blockmcl$evalunit(a,(i64)65);
            cx = mc_blockmcl$evalunit(b,(i64)65);
            lx = mc_libmcl$genlabel(lab);
            mc_libmcl$genmc((i64)44,ax,bx);
            if ((opc == (i64)1)) {
                nolab = mc_libmcl$createfwdlabel();
                mc_libmcl$genmc_cond((i64)28,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)12 : (i64)2),mc_libmcl$genlabel(nolab),0);
                mc_libmcl$genmc((i64)44,ax,cx);
                mc_libmcl$genmc_cond((i64)28,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)14 : (i64)6),lx,0);
                mc_libmcl$definefwdlabel(nolab);
            }
            else {
                mc_libmcl$genmc_cond((i64)28,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)12 : (i64)2),lx,0);
                mc_libmcl$genmc((i64)44,ax,cx);
                mc_libmcl$genmc_cond((i64)28,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)15 : (i64)7),lx,0);
            }
;
        }
        break;
    case 41:;
        {
            s = (*r).a;
            if ((s == 0)) {
                mm_support$gerror((byte*)"empty set",0);
            }
;
            ax = mc_blockmcl$loadunit(q,(i64)0);
            regs2 = (i64)mc_decls$regset;
            lx = mc_libmcl$genlabel(lab);
            if ((opc == (i64)0)) {
                lab2 = mc_libmcl$createfwdlabel();
                L74 :;
                while (!!(s)) {
                    if (!(!!((i64)(*s).simple))) {
                        mm_support$gerror((byte*)"inset/cx2",0);
                    }
;
                    bx = mc_blockmcl$evalunit(s,(i64)65);
                    s = (*s).nextunit;
                    mc_libmcl$genmc((i64)44,ax,bx);
                    mc_libmcl$popregs((u64)regs2,0);
                    if (!!(s)) {
                        mc_libmcl$genmc_cond((i64)28,(i64)4,mc_libmcl$genlabel(lab2),0);
                    }
                    else {
                        mc_libmcl$genmc_cond((i64)28,(i64)5,lx,0);
                    }
;
L75 :;
                }
L76 :;
                ;
                mc_libmcl$definefwdlabel(lab2);
            }
            else {
                L77 :;
                while (!!(s)) {
                    bx = mc_blockmcl$evalunit(s,(i64)65);
                    s = (*s).nextunit;
                    mc_libmcl$genmc((i64)44,ax,bx);
                    mc_libmcl$genmc_cond((i64)28,(i64)4,lx,0);
L78 :;
                }
L79 :;
                ;
            }
;
        }
        break;
    case 33:;
        {
            r = (*q).nextunit;
            i = (i64)1;
            regs2 = (i64)mc_decls$regset;
            if ((opc == (i64)0)) {
                L80 :;
                while (!!(r)) {
                    ax = mc_blockmcl$loadunit(q,(i64)0);
                    bx = mc_blockmcl$evalunit(r,(i64)65);
                    mc_libmcl$genmc((i64)44,ax,bx);
                    mc_libmcl$popregs((u64)regs2,0);
                    mc_libmcl$genmc_cond((i64)28,mc_libmcl$getmclcond(mc_blockmcl$reversecond((i64)(*p).cmpgenop[(i)-1]),(i64)(*q).mode),mc_libmcl$genlabel(lab),0);
                    ++(i);
                    q = r;
L81 :;
                    r = (*r).nextunit;
L83 :;
                                    }
L82 :;
                ;
            }
            else {
                lab2 = mc_libmcl$createfwdlabel();
                L84 :;
                while (!!(r)) {
                    ax = mc_blockmcl$loadunit(q,(i64)0);
                    bx = mc_blockmcl$evalunit(r,(i64)65);
                    mc_libmcl$genmc((i64)44,ax,bx);
                    mc_libmcl$popregs((u64)regs2,0);
                    if (!!((*r).nextunit)) {
                        mc_libmcl$genmc_cond((i64)28,mc_libmcl$getmclcond(mc_blockmcl$reversecond((i64)(*p).cmpgenop[(i)-1]),(i64)(*q).mode),mc_libmcl$genlabel(lab2),0);
                    }
                    else {
                        mc_libmcl$genmc_cond((i64)28,mc_libmcl$getmclcond((i64)(*p).cmpgenop[(i)-1],(i64)(*q).mode),mc_libmcl$genlabel(lab),0);
                    }
;
                    ++(i);
                    q = r;
L85 :;
                    r = (*r).nextunit;
L87 :;
                                    }
L86 :;
                ;
                mc_libmcl$definefwdlabel(lab2);
            }
;
        }
        break;
    default: {
        if (!(((i64)(*p).mode == (i64)3 || (i64)(*p).mode == (i64)2 || (i64)(*p).mode == (i64)6))) {
            mm_support$gerror_s((byte*)"jumptrue/not i64:",mm_lib$strmode((i64)(*p).mode,(i64)1),0);
        }
;
        ax = mc_blockmcl$loadunit(p,(i64)0);
        mc_libmcl$genmc((i64)40,ax,ax);
        mc_libmcl$genmc_cond((i64)28,((opc == (i64)1) ? (i64)5 : (i64)4),mc_libmcl$genlabel(lab),0);
    }
    } //SW
;
    mc_libmcl$popregs((u64)regs,0);
}

static void mc_blockmcl$gcomparejump(i64 jumpopc,i64 cond,struct mm_decls$unitrec *lhs,struct mm_decls$unitrec *rhs,i64 lab) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        i64 regs;
        i64 rev;
        i64 opc;
    if ((jumpopc == (i64)0)) {
        cond = mc_blockmcl$reversecond(cond);
    }
;
    regs = (i64)mc_decls$regset;
    rev = ((cond == (i64)17 || cond == (i64)18) ? (i64)1 : (i64)0);
    mc_blockmcl$loadbin(lhs,rhs,(i64)0,rev,(i64)0);
    ax = mc_blockmcl$axb;
    bx = mc_blockmcl$bxb;
        {i64 $temp = (i64)mm_decls$ttcat[((i64)(*lhs).mode)];
if (($temp==(i64)3)) {
        opc = (i64)74;
    }
    else if (($temp==(i64)2)) {
        opc = (i64)73;
    }
    else {
        opc = (i64)44;
    }
    };
    mc_libmcl$genmc(opc,ax,bx);
    mc_libmcl$popregs((u64)regs,0);
    mc_libmcl$genmc_cond((i64)28,mc_libmcl$getmclcond(cond,(i64)(*lhs).mode),mc_libmcl$genlabel(lab),0);
}

i64 mc_blockmcl$reversecond(i64 pclop) {
    if ((pclop==(i64)17)) {
        pclop = (i64)18;
    }
    else if ((pclop==(i64)18)) {
        pclop = (i64)17;
    }
    else if ((pclop==(i64)19)) {
        pclop = (i64)21;
    }
    else if ((pclop==(i64)20)) {
        pclop = (i64)22;
    }
    else if ((pclop==(i64)21)) {
        pclop = (i64)19;
    }
    else if ((pclop==(i64)22)) {
        pclop = (i64)20;
    }
;
    return pclop;
}

static void mc_blockmcl$setmultopnd(struct mc_decls$opndrec *ax,struct mc_decls$opndrec *rx) {
    if ((ax == 0)) {
        return;
    }
;
    if (((i64)(*rx).reg == (i64)0)) {
        (*rx) = (*ax);
    }
    else if (((i64)(*ax).reg != (i64)(*rx).reg)) {
        mc_libmcl$genmc(mc_libmcl$getopndmov(rx),rx,ax);
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$do_if(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pcond,struct mm_decls$unitrec *plist,struct mm_decls$unitrec *pelse,i64 isref,i64 reg) {
        struct mc_decls$opndrec *  tx;
        i64 labend;
        i64 lab2;
        i64 regs;
        struct mc_decls$opndrec *  rx;
    regs = (i64)mc_decls$regset;
    labend = mc_libmcl$createfwdlabel();
    rx = mc_libmcl$newmclopnd();
    tx = 0;
    L88 :;
    while (!!(pcond)) {
        lab2 = mc_libmcl$createfwdlabel();
        mc_blockmcl$docond((i64)0,pcond,lab2);
        mc_libmcl$popregs((u64)regs,0);
        tx = (!!(isref) ? mc_blockmcl$loadref(plist,reg) : mc_blockmcl$loadunit(plist,reg));
        mc_blockmcl$setmultopnd(tx,rx);
        mc_libmcl$popregs((u64)regs,tx);
        if ((!!((*pcond).nextunit) || !!(pelse))) {
            mc_blockmcl$genjumpl(labend);
        }
;
        mc_libmcl$definefwdlabel(lab2);
L89 :;
        {
            pcond = (*pcond).nextunit;
            plist = (*plist).nextunit;
        }
L91 :;
            }
L90 :;
    ;
    if (!!(pelse)) {
        mc_libmcl$popregs((u64)regs,0);
        tx = (!!(isref) ? mc_blockmcl$loadref(pelse,reg) : mc_blockmcl$loadunit(pelse,reg));
        mc_blockmcl$setmultopnd(tx,rx);
        mc_libmcl$popregs((u64)regs,tx);
    }
;
    mc_libmcl$definefwdlabel(labend);
    return rx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_andl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg) {
        struct mc_decls$opndrec *  tx;
        i64 labfalse;
        i64 labend;
        i64 regs;
    regs = (i64)mc_decls$regset;
    labfalse = mc_libmcl$createfwdlabel();
    labend = mc_libmcl$createfwdlabel();
    mc_blockmcl$genjumpcond((i64)0,a,labfalse);
    mc_blockmcl$genjumpcond((i64)0,b,labfalse);
    tx = mc_libmcl$genreg(reg,(i64)8);
    mc_libmcl$genmc((i64)13,tx,mc_libmcl$genint((i64)1,(i64)8));
    mc_blockmcl$genjumpl(labend);
    mc_libmcl$definefwdlabel(labfalse);
    mc_libmcl$genmc((i64)13,tx,mc_libmcl$genint((i64)0,(i64)8));
    mc_libmcl$definefwdlabel(labend);
    mc_libmcl$popregs((u64)regs,tx);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_orl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg) {
        struct mc_decls$opndrec *  tx;
        i64 labtrue;
        i64 labfalse;
        i64 labend;
        i64 regs;
    regs = (i64)mc_decls$regset;
    labtrue = mc_libmcl$createfwdlabel();
    labfalse = mc_libmcl$createfwdlabel();
    labend = mc_libmcl$createfwdlabel();
    mc_blockmcl$genjumpcond((i64)1,a,labtrue);
    mc_blockmcl$genjumpcond((i64)0,b,labfalse);
    mc_libmcl$definefwdlabel(labtrue);
    tx = mc_libmcl$genreg(reg,(i64)8);
    mc_libmcl$genmc((i64)13,tx,mc_libmcl$genint((i64)1,(i64)8));
    mc_blockmcl$genjumpl(labend);
    mc_libmcl$definefwdlabel(labfalse);
    mc_libmcl$genmc((i64)13,tx,mc_libmcl$genint((i64)0,(i64)8));
    mc_libmcl$definefwdlabel(labend);
    mc_libmcl$popregs((u64)regs,tx);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_notl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg) {
        struct mc_decls$opndrec *  ax;
    if ((!(!!((i64)mm_decls$ttisinteger[((i64)(*a).mode)])) && ((i64)(*a).mode != (i64)6))) {
        mm_support$gerror((byte*)"notl/not int",0);
    }
;
    ax = mc_blockmcl$loadunit(a,reg);
    mc_libmcl$genmc((i64)42,mc_libmcl$changeopndsize(ax,(i64)1),mc_libmcl$genint((i64)1,(i64)8));
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_istruel(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
    if ((!(!!((i64)mm_decls$ttisinteger[((i64)(*a).mode)])) && ((i64)(*a).mode != (i64)6))) {
        mm_support$gerror((byte*)"istruel/not int",0);
    }
;
    ax = mc_blockmcl$loadunit(a,reg);
    mc_libmcl$genmc((i64)43,ax,ax);
    mc_libmcl$genmc_cond((i64)60,(i64)5,(bx = mc_libmcl$changeopndsize(ax,(i64)1)),0);
    mc_libmcl$genmc((i64)21,mc_libmcl$changeopndsize(ax,(i64)4),bx);
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_ptr(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 load,i64 reg) {
        struct mc_decls$opndrec *  tx;
        struct mc_decls$opndrec *  px;
        struct mm_decls$unitrec *  poffset;
        i64 regs;
        i64 memmode;
        i64 size;
        i64 scale;
        i64 neg;
        i64 amode;
    regs = (i64)mc_decls$regset;
    memmode = mm_lib$getmemmode(p);
    if ((((i64)(*a).tag == (i64)34) && ((i64)(*a).pclop == (i64)26))) {
        neg = (i64)1;
        //doaddconst:
L92 :;
;
        amode = (i64)mm_decls$tttarget[((i64)(*(*a).a).mode)];
        px = mc_blockmcl$loadunit((*a).a,(i64)0);
        poffset = (*a).b;
        size = (i64)mm_decls$ttsize[(amode)];
        if (((i64)(*poffset).tag == (i64)1)) {
            px = mc_libmcl$genindex((i64)(*px).reg,(i64)0,(i64)1,(((*poffset).value * size) * neg),size,(i64)0,0);
        }
        else {
            tx = mc_blockmcl$loadunit(poffset,(i64)0);
            scale = mc_libmcl$scaleindex(tx,size);
            px = mc_libmcl$genindex((i64)(*px).reg,(i64)(*tx).reg,scale,(i64)0,size,(i64)0,0);
        }
;
        (*px).misc = msysc$m_setdotslice((*px).misc,(i64)0,(i64)3,(u64)(i64)mm_decls$ttsize[(memmode)]);
        goto L93 ;
;
    }
    else if (((((i64)(*a).tag == (i64)34) && ((i64)(*a).pclop == (i64)27)) && ((i64)(*(*a).b).tag == (i64)1))) {
        neg = (i64)-1;
        goto L92 ;
;
    }
;
    px = mc_blockmcl$loadunit(a,((reg < (i64)21) ? reg : (i64)0));
    if (((i64)(*px).reg == (i64)15)) {
        mm_support$gerror((byte*)"PTR: LOADINIT gives [DFRAME?]",0);
    }
;
    px = mc_libmcl$genireg((i64)(*px).reg,(i64)mm_decls$ttsize[(memmode)],(i64)0);
    mc_libmcl$popregs((u64)regs,px);
    //finish:
L93 :;
;
    tx = mc_blockmcl$getaddrmode(px,0,(i64)mm_decls$ttsize[(memmode)],(i64)0);
    tx = mc_blockmcl$loadmem(load,tx,reg,memmode);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_index(struct mm_decls$unitrec *parray,struct mm_decls$unitrec *pindex,i64 load,i64 reg) {
        struct mc_decls$opndrec *  tx;
        i64 regs;
        i64 memmode;
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  ax;
    regs = (i64)mc_decls$regset;
    memmode = (i64)mm_decls$tttarget[((i64)(*parray).mode)];
    px = mc_blockmcl$evalunit(parray,(i64)0);
    if (((i64)mm_decls$ttbasetype[((i64)(*parray).mode)] == (i64)11)) {
        ax = mc_libmcl$genreg((i64)0,(i64)8);
        mc_libmcl$genmc((i64)13,ax,mc_libmcl$changeopndsize(px,(i64)8));
        px = mc_libmcl$makeopndind(ax,(i64)0);
        mc_libmcl$popregs((u64)regs,px);
    }
;
    mc_libmcl$setopndsize(px,(i64)mm_decls$ttsize[(memmode)]);
    tx = mc_blockmcl$getaddrmode(px,pindex,(i64)mm_decls$ttsize[(memmode)],(-((i64)mm_decls$ttlower[((i64)(*parray).mode)]) * (i64)mm_decls$ttsize[(memmode)]));
    tx = mc_blockmcl$loadmem(load,tx,reg,memmode);
    mc_libmcl$popregs((u64)regs,tx);
    return tx;
}

static void mc_blockmcl$mulreg(struct mc_decls$opndrec *rx,i64 x) {
        i64 n;
    if ((x > (i64)1)) {
        if (!!((n = mm_lib$ispoweroftwo(x)))) {
            mc_libmcl$genmc((i64)45,rx,mc_libmcl$genint(n,(i64)8));
        }
        else {
            mc_libmcl$genmc((i64)36,rx,mc_libmcl$genint(x,(i64)8));
        }
;
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$do_dot(struct mm_decls$unitrec *pdot,i64 load,i64 reg) {
        struct mc_decls$opndrec *  tx;
        struct mc_decls$opndrec *  px;
        i64 regs;
        i64 memmode;
    regs = (i64)mc_decls$regset;
    memmode = mm_lib$getmemmode(pdot);
    px = mc_blockmcl$evalunit((*pdot).a,(i64)0);
    mc_libmcl$setopndsize(px,(i64)mm_decls$ttsize[(memmode)]);
    if (((i64)msysc$m_getdotslice((i64)(*px).misc,(i64)8,(i64)11) != (i64)4)) {
        mm_support$gerror((byte*)"DOT: PX NOT MEM",0);
    }
;
    tx = mc_blockmcl$getaddrmode(px,0,(i64)mm_decls$ttsize[(memmode)],(i64)(*pdot).offset);
    tx = mc_blockmcl$loadmem(load,tx,reg,memmode);
    mc_libmcl$popregs((u64)regs,tx);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$getaddrmode(struct mc_decls$opndrec *ax,struct mm_decls$unitrec *pindex,i64 size,i64 offset) {
        struct mc_decls$opndrec *  ix;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  rxa;
        struct mc_decls$opndrec *  rxb;
        i64 mulfactor;
        i64 scale;
    mulfactor = (i64)1;
    scale = (i64)1;
    if (((!!(pindex) && ((i64)(*pindex).tag == (i64)34)) && ((i64)(*pindex).pclop == (i64)1 || (i64)(*pindex).pclop == (i64)2))) {
        if (((i64)(*(*pindex).b).tag == (i64)1)) {
            offset += ((((i64)(*pindex).pclop == (i64)1) ? (*(*pindex).b).value : -((*(*pindex).b).value)) * size);
            pindex = (*pindex).a;
        }
;
    }
;
    if ((!!(pindex) && ((i64)(*pindex).tag == (i64)1))) {
        offset += ((*pindex).value * size);
        pindex = 0;
    }
;
    if (!!(pindex)) {
        if ((size==(i64)1) || (size==(i64)2) || (size==(i64)4) || (size==(i64)8)) {
            scale = size;
        }
        else {
            mulfactor = size;
        }
;
    }
;
    if (!!(pindex)) {
        rxa = (rxb = 0);
        if (!(!!((i64)(*pindex).simple))) {
            if (((i64)(*ax).reg >= (i64)1 && (i64)(*ax).reg <= (i64)14)) {
                rxa = mc_libmcl$genreg((i64)(*ax).reg,(i64)8);
                mc_libmcl$genmc((i64)14,rxa,0);
            }
;
            if (!!((i64)(*ax).regix)) {
                rxb = mc_libmcl$genreg((i64)(*ax).regix,(i64)8);
                mc_libmcl$genmc((i64)14,rxb,0);
            }
;
        }
;
        ix = mc_blockmcl$loadunit(pindex,(i64)0);
        if (!!(rxb)) {
            mc_libmcl$genmc((i64)15,rxb,0);
        }
;
        if (!!(rxa)) {
            mc_libmcl$genmc((i64)15,rxa,0);
        }
;
        if (((i64)(*ax).regix == (i64)0)) {
            //addregix:
L94 :;
;
            (*ax).regix = (i64)(*ix).reg;
            if ((mulfactor != (i64)1)) {
                mc_libmcl$mulimm(ix,mulfactor);
            }
            else {
                (*ax).misc = msysc$m_setdotslice((*ax).misc,(i64)4,(i64)7,(u64)scale);
            }
;
            (*ax).offset += (i32)offset;
        }
        else {
            bx = mc_libmcl$genreg(mc_libmcl$getlowreg(ax),(i64)8);
            mc_libmcl$genmc((i64)16,bx,ax);
            ax = mc_libmcl$genireg((i64)(*bx).reg,(i64)8,(i64)0);
            goto L94 ;
;
        }
;
    }
    else {
        (*ax).offset += (i32)offset;
    }
;
    return ax;
}

static void mc_blockmcl$do_while(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pcond,struct mm_decls$unitrec *pbody,struct mm_decls$unitrec *pincr) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_incr;
    lab_b = mc_libmcl$createfwdlabel();
    lab_c = mc_libmcl$createfwdlabel();
    lab_d = mc_libmcl$createfwdlabel();
    if (!!(pincr)) {
        lab_incr = mc_libmcl$createfwdlabel();
    }
    else {
        lab_incr = lab_c;
    }
;
    mc_libmcl$stacklooplabels(lab_b,lab_c,lab_d);
    mc_blockmcl$genjumpl(lab_incr);
    mc_libmcl$definefwdlabel(lab_b);
    mc_blockmcl$loadunit(pbody,(i64)0);
    mc_libmcl$definefwdlabel(lab_c);
    if (!!(pincr)) {
        mc_blockmcl$evalunit(pincr,(i64)0);
        mc_libmcl$definefwdlabel(lab_incr);
    }
;
    mc_blockmcl$docond((i64)1,pcond,lab_b);
    mc_libmcl$definefwdlabel(lab_d);
    --(mc_libmcl$loopindex);
}

static void mc_blockmcl$do_repeat(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 lab_ab;
        i64 lab_c;
        i64 lab_d;
    lab_ab = mc_libmcl$definelabel();
    lab_c = mc_libmcl$createfwdlabel();
    lab_d = mc_libmcl$createfwdlabel();
    mc_libmcl$stacklooplabels(lab_ab,lab_c,lab_d);
    mc_blockmcl$loadunit(a,(i64)0);
    mc_libmcl$definefwdlabel(lab_c);
    if (!((((i64)(*b).tag == (i64)1) && ((*b).value == (i64)0)))) {
        mc_blockmcl$docond((i64)0,b,lab_ab);
    }
;
    mc_libmcl$definefwdlabel(lab_d);
    --(mc_libmcl$loopindex);
}

static void mc_blockmcl$do_incr(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        struct mc_decls$opndrec *  ax;
        i64 step;
    ax = mc_blockmcl$evalunit(a,(i64)87);
    if (((i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) != (i64)4)) {
        mm_support$gerror((byte*)"incr/not mem",0);
    }
;
    if (!!((i64)mm_decls$ttisref[((i64)(*a).mode)])) {
        step = (i64)mm_decls$ttsize[((i64)mm_decls$tttarget[((i64)(*a).mode)])];
    }
    else {
        step = (i64)1;
    }
;
    mc_blockmcl$do_incrstep(ax,step,(i64)((i64)(*p).pclop == (i64)53));
}

static void mc_blockmcl$do_incrstep(struct mc_decls$opndrec *ax,i64 step,i64 isincr) {
    if ((step == (i64)1)) {
        mc_libmcl$genmc((!!(isincr) ? (i64)54 : (i64)55),ax,0);
    }
    else {
        mc_libmcl$genmc((!!(isincr) ? (i64)30 : (i64)31),ax,mc_libmcl$genint(step,(i64)8));
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$do_incrload(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  px;
        i64 opc;
        i64 step;
        i64 regs;
    regs = (i64)mc_decls$regset;
    ax = mc_libmcl$genreg(reg,(i64)8);
    px = mc_blockmcl$evalunit(a,(i64)87);
    if (((i64)msysc$m_getdotslice((i64)(*px).misc,(i64)8,(i64)11) != (i64)4)) {
        mm_support$gerror((byte*)"incr/not mem",0);
    }
;
    if (!!((i64)mm_decls$ttisref[((i64)(*a).mode)])) {
        step = (i64)mm_decls$ttsize[((i64)mm_decls$tttarget[((i64)(*a).mode)])];
    }
    else {
        step = (i64)1;
    }
;
    if (((i64)mm_decls$ttcat[((i64)(*a).mode)] == (i64)1)) {
        opc = (i64)13;
    }
    else {
        opc = (!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)20 : (i64)21);
    }
;
        {i64 $temp = (i64)(*p).pclop;
if (($temp==(i64)55)) {
        mc_blockmcl$do_incrstep(px,step,(i64)1);
        mc_libmcl$genmc(opc,ax,px);
    }
    else if (($temp==(i64)56)) {
        mc_blockmcl$do_incrstep(px,step,(i64)0);
        mc_libmcl$genmc(opc,ax,px);
    }
    else if (($temp==(i64)57)) {
        mc_libmcl$genmc(opc,ax,px);
        mc_blockmcl$do_incrstep(px,step,(i64)1);
    }
    else if (($temp==(i64)58)) {
        mc_libmcl$genmc(opc,ax,px);
        mc_blockmcl$do_incrstep(px,step,(i64)0);
    }
    };
    mc_libmcl$popregs((u64)regs,ax);
    return ax;
}

static void mc_blockmcl$do_for(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *pfrom,struct mm_decls$unitrec *pbody,i64 down) {
        struct mm_decls$unitrec *  pto;
        struct mm_decls$unitrec *  pstep;
        struct mm_decls$unitrec *  pelse;
        struct mm_decls$unitrec *  px;
        struct mm_decls$unitrec *  ptoinit;
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_e;
        i64 lab_cmp;
        i64 a;
        i64 b;
        i64 step;
        i64 reg;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mm_decls$strec *  d;
    reg = (i64)mc_decls$regset;
    pto = (*pfrom).nextunit;
    pstep = (*pto).nextunit;
    pelse = (*pbody).nextunit;
    ptoinit = (*pindex).nextunit;
        {i64 $temp = (i64)(*pto).tag;
if (($temp==(i64)49)) {
        px = (*pto).a;
        if (((((i64)(*px).tag == (i64)4) && ((i64)(*(d = (*px).def)).nameid == (i64)13)) && ((i64)(*d).parammode == (i64)2))) {
            mm_support$gerror((byte*)"Possibly using &param as for-loop limit",0);
        }
;
    }
    else if (($temp==(i64)1) || ($temp==(i64)4)) {
    }
    else {
        if (((i64)(*pto).mode == (i64)3)) {
            mm_support$gerror((byte*)"FOR/BLOCKTEMP",0);
        }
        else {
            mm_support$gerror((byte*)"Complex TO",0);
        }
;
    }
    };
    lab_b = mc_libmcl$createfwdlabel();
    lab_c = mc_libmcl$createfwdlabel();
    lab_d = mc_libmcl$createfwdlabel();
    lab_cmp = mc_libmcl$createfwdlabel();
    if (!!(pelse)) {
        lab_e = mc_libmcl$createfwdlabel();
    }
    else {
        lab_e = lab_d;
    }
;
    mc_libmcl$stacklooplabels(lab_b,lab_c,lab_d);
    mc_libmcl$genmc((i64)13,mc_libmcl$genmem((*pindex).def),mc_blockmcl$loadunit(pfrom,(i64)0));
    mc_libmcl$popregs((u64)reg,0);
    if (!!(ptoinit)) {
        (*ptoinit).resultflag = (i64)0;
        mc_libmcl$gencomment((byte*)"PTOINIT:",0);
        mc_blockmcl$loadunit(ptoinit,(i64)0);
    }
;
    if ((((i64)(*pfrom).tag == (i64)1) && ((i64)(*pto).tag == (i64)1))) {
        a = (*pfrom).value;
        b = (*pto).value;
        if (((!!(down) && (a >= b)) || (!(!!(down)) && (a <= b)))) {
        }
        else {
            mc_libmcl$genmc((i64)27,mc_libmcl$genlabel(lab_e),0);
        }
;
    }
    else {
        mc_libmcl$genmc((i64)27,mc_libmcl$genlabel(lab_cmp),0);
    }
;
    mc_libmcl$definefwdlabel(lab_b);
    mc_blockmcl$loadunit(pbody,(i64)0);
    mc_libmcl$definefwdlabel(lab_c);
    if (!!(pstep)) {
        if (((i64)(*pstep).tag != (i64)1)) {
            mm_support$gerror((byte*)"for/step non-const not ready",0);
        }
;
        step = (*pstep).value;
        if ((step <= (i64)0)) {
            mm_support$gerror((byte*)"Bad for-step",0);
        }
;
    }
    else {
        step = (i64)1;
    }
;
    mc_blockmcl$do_incrstep(mc_blockmcl$evalunit(pindex,(i64)0),step,(i64)!(!!(down)));
    mc_libmcl$definefwdlabel(lab_cmp);
    ax = mc_blockmcl$loadunit(pindex,(i64)0);
    bx = mc_blockmcl$loadunit(pto,(i64)0);
    mc_libmcl$genmc((i64)44,ax,bx);
    mc_libmcl$genmc_cond((i64)28,(!!(down) ? (i64)13 : (i64)14),mc_libmcl$genlabel(lab_b),0);
    if (!!(pelse)) {
        mc_libmcl$definefwdlabel(lab_e);
        mc_blockmcl$loadunit(pelse,(i64)0);
    }
;
    mc_libmcl$definefwdlabel(lab_d);
    --(mc_libmcl$loopindex);
    mc_libmcl$popregs((u64)reg,0);
}

static void mc_blockmcl$do_forall(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *plist,struct mm_decls$unitrec *pbody,i64 down) {
        struct mm_decls$unitrec *  plocal;
        struct mm_decls$unitrec *  pfrom;
        struct mm_decls$unitrec *  pto;
        struct mm_decls$unitrec *  pelse;
        struct mm_decls$unitrec *  passign;
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_e;
        i64 lab_cmp;
        i64 a;
        i64 b;
        i64 regs;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
    regs = (i64)mc_decls$regset;
    plocal = (*pindex).nextunit;
    pfrom = (*plocal).nextunit;
    pto = (*pfrom).nextunit;
    passign = (*plist).nextunit;
    pelse = (*pbody).nextunit;
    lab_b = mc_libmcl$createfwdlabel();
    lab_c = mc_libmcl$createfwdlabel();
    lab_d = mc_libmcl$createfwdlabel();
    lab_cmp = mc_libmcl$createfwdlabel();
    if (!!(pelse)) {
        lab_e = mc_libmcl$createfwdlabel();
    }
    else {
        lab_e = lab_d;
    }
;
    mc_libmcl$stacklooplabels(lab_b,lab_c,lab_d);
    mc_libmcl$genmc((i64)13,mc_libmcl$genmem((*pindex).def),mc_blockmcl$loadunit(pfrom,(i64)0));
    mc_libmcl$popregs((u64)regs,0);
    if ((((i64)(*pfrom).tag == (i64)1) && ((i64)(*pto).tag == (i64)1))) {
        a = (*pfrom).value;
        b = (*pto).value;
        if (((!!(down) && (a >= b)) || (!(!!(down)) && (a <= b)))) {
        }
        else {
            mc_libmcl$genmc((i64)27,mc_libmcl$genlabel(lab_e),0);
        }
;
    }
    else {
        mc_libmcl$genmc((i64)27,mc_libmcl$genlabel(lab_cmp),0);
    }
;
    mc_libmcl$definefwdlabel(lab_b);
    (*passign).resultflag = (i64)0;
    mc_blockmcl$loadunit(passign,(i64)0);
    mc_blockmcl$loadunit(pbody,(i64)0);
    mc_libmcl$definefwdlabel(lab_c);
    mc_blockmcl$do_incrstep(mc_blockmcl$evalunit(pindex,(i64)0),(i64)1,(i64)!(!!(down)));
    ax = mc_blockmcl$loadunit(pindex,(i64)0);
    bx = mc_blockmcl$loadunit(pto,(i64)0);
    mc_libmcl$genmc((i64)44,ax,bx);
    mc_libmcl$genmc_cond((i64)28,(!!(down) ? (i64)13 : (i64)14),mc_libmcl$genlabel(lab_b),0);
    if (!!(pelse)) {
        mc_libmcl$definefwdlabel(lab_e);
        mc_blockmcl$loadunit(pelse,(i64)0);
    }
;
    mc_libmcl$definefwdlabel(lab_d);
    --(mc_libmcl$loopindex);
    mc_libmcl$popregs((u64)regs,0);
}

static void mc_blockmcl$do_print(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  r;
        struct mm_decls$unitrec *  fmt;
        i64 m;
        i64 fn;
        i64 needprintend;
        i64 regs;
    regs = (i64)mc_decls$regset;
    if (!!(a)) {
        needprintend = (i64)1;
        if (((i64)mm_decls$ttbasetype[((i64)(*a).mode)] != (i64)7)) {
            mm_support$gerror((byte*)"@dev no ref",0);
        }
;
                {i64 $temp = (i64)mm_decls$ttbasetype[((i64)mm_decls$tttarget[((i64)(*a).mode)])];
if (($temp==(i64)0)) {
            mc_libmcl$gensysproc((i64)2,a,0,0,(i64)0);
        }
        else if (($temp==(i64)12)) {
            mc_libmcl$gensysproc((i64)3,a,0,0,(i64)0);
        }
        else if (($temp==(i64)7)) {
            mc_libmcl$gensysproc((i64)4,a,0,0,(i64)0);
        }
        else {
            mm_support$gerror((byte*)"@dev?",0);
        }
        };
        mc_libmcl$popregs((u64)regs,0);
    }
    else {
        needprintend = (i64)1;
        mc_libmcl$gensysproc((i64)5,0,0,0,(i64)0);
    }
;
    q = b;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)116) || ($temp==(i64)117)) {
        if ((((i64)mm_decls$ttbasetype[((i64)(*q).mode)] != (i64)7) || ((i64)mm_decls$ttbasetype[((i64)mm_decls$tttarget[((i64)(*q).mode)])] != (i64)12))) {
            mm_support$gerror((byte*)"string expected",0);
        }
;
        mc_libmcl$gensysproc((i64)6,q,0,0,(i64)0);
        q = (*p).c;
    }
    };
    L95 :;
    while (!!(q)) {
                {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)87)) {
            fmt = (*q).b;
            r = (*q).a;
            m = (i64)(*r).mode;
        }
        else if (($temp==(i64)88)) {
            mc_libmcl$gensysproc((i64)7,0,0,0,(i64)0);
            q = (*q).nextunit;
            goto L96 ;
        }
        else if (($temp==(i64)89)) {
            mc_libmcl$gensysproc((i64)8,0,0,0,(i64)0);
            q = (*q).nextunit;
            goto L96 ;
        }
        else {
            fmt = 0;
            r = q;
            m = (i64)(*q).mode;
        }
        };
        switch ((i64)mm_decls$ttbasetype[(m)]) {
        case 3:;
            {
                fn = (i64)9;
                if (!(!!(fmt))) {
                    fn = (i64)10;
                }
;
            }
            break;
        case 2:;
            {
                fn = (i64)11;
            }
            break;
        case 4:;
            {
                fn = (i64)13;
            }
            break;
        case 5:;
            {
                fn = (i64)12;
            }
            break;
        case 7:;
            {
                if ((((i64)mm_decls$tttarget[(m)] == (i64)12) || (((i64)mm_decls$tttarget[(m)] == (i64)10) && ((i64)mm_decls$tttarget[((i64)mm_decls$tttarget[(m)])] == (i64)12)))) {
                    fn = (i64)14;
                    if (!(!!(fmt))) {
                        fn = (i64)15;
                    }
;
                }
                else {
                    fn = (i64)17;
                    if (!(!!(fmt))) {
                        fn = (i64)18;
                    }
;
                }
;
            }
            break;
        case 6:;
            {
                fn = (i64)20;
            }
            break;
        case 10:;
            {
                mm_support$gerror((byte*)"PRINTARRAY",0);
                q = (*q).nextunit;
            }
            break;
        case 8:;
            {
                mm_support$gerror((byte*)"PRINTRECORD",0);
            }
            break;
        case 11:;
            {
                if (((i64)mm_decls$tttarget[(m)] == (i64)12)) {
                    fn = (i64)16;
                }
                else {
                    mm_support$gerror((byte*)"PRINTSLICE",0);
                }
;
            }
            break;
        case 1:;
            {
                fn = (i64)19;
            }
            break;
        default: {
            mm_support$gerror_s((byte*)"PRINT/T=#",mm_lib$strmode(m,(i64)1),0);
        }
        } //SW
;
        if ((fn==(i64)10) || (fn==(i64)15) || (fn==(i64)18)) {
            mc_libmcl$gensysproc(fn,r,0,0,(i64)0);
        }
        else {
            mc_libmcl$gensysproc(fn,r,(!!(fmt) ? fmt : mm_lib$createconstunit((u64)0u,(i64)3)),0,(i64)0);
        }
;
        mc_libmcl$popregs((u64)regs,0);
        q = (*q).nextunit;
L96 :;
    }
L97 :;
    ;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)115) || ($temp==(i64)117)) {
        mc_libmcl$gensysproc((i64)21,0,0,0,(i64)0);
    }
    };
    if (!!(needprintend)) {
        mc_libmcl$gensysproc((i64)22,0,0,0,(i64)0);
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$do_callproc(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 isfn) {
        struct mm_decls$unitrec *  arglist[100];
        byte argcomplex[100];
        i64 nargs;
        i64 nhighargs;
        i64 nlowargs;
        i64 isptr;
        i64 nvariadics;
        i64 blockret;
        i64 highcomplex;
        i64 j;
        i64 stackbytes;
        i64 alignbytes;
        i64 oldstackdepth;
        i64 regs;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  dblock;
        struct mm_decls$unitrec *  q;
        struct mc_decls$opndrec *  cx;
        i64 i;
    isptr = (i64)0;
    ++(mc_decls$ncalldepth);
    oldstackdepth = mc_decls$mstackdepth;
    regs = (i64)mc_decls$regset;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)4)) {
        d = (*a).def;
    }
    else if (($temp==(i64)49)) {
        d = mm_decls$ttnamedef[((i64)(*a).mode)];
        isptr = (i64)1;
    }
    else {
        mm_support$gerror((byte*)"call/not ptr",0);
    }
    };
    nargs = (nhighargs = (nlowargs = (i64)0));
    stackbytes = (alignbytes = (i64)0);
    nvariadics = (i64)0;
    blockret = (i64)0;
    if (!!((i64)mm_decls$ttisblock[((i64)(*p).mode)])) {
        blockret = (i64)1;
        dblock = mc_genmcl$newblocktemp((i64)(*p).mode);
        q = (struct mm_decls$unitrec *)mm_lib$createname(dblock);
        (*q).mode = (i64)(*p).mode;
        arglist[(++(nargs))-1] = q;
    }
;
    q = b;
    L98 :;
    while (!!(q)) {
        if ((nargs >= (i64)100)) {
            mm_support$gerror((byte*)"maxargs",0);
        }
;
        arglist[(++(nargs))-1] = q;
        if ((((!!((i64)(*d).varparams) && (nargs >= (i64)(*d).varparams)) && (nargs <= (i64)4)) && (nvariadics == (i64)0))) {
            nvariadics = nargs;
        }
;
L99 :;
        q = (*q).nextunit;
L101 :;
            }
L100 :;
    ;
    nhighargs = msysc$m_imax((nargs - (i64)4),(i64)0);
    nlowargs = (nargs<(i64)4?nargs:(i64)4);
    if (!!((msysc$m_getdotindex(nhighargs,(i64)0) ^ msysc$m_getdotindex(mc_decls$mstackdepth,(i64)0)))) {
        alignbytes = (i64)8;
        mc_libmcl$pushstack((i64)8);
        ++(mc_decls$mstackdepth);
    }
;
    for (i=nargs;i>=(i64)5;--i) {
L102 :;
        mc_blockmcl$pushunit(arglist[(i)-1]);
        mc_libmcl$popregs((u64)regs,0);
L103 :;
    }
L104 :;
    ;
    highcomplex = (i64)0;
    for (i=(i64)1;i<=nlowargs;++i) {
L105 :;
        argcomplex[(i)-1] = (j = (!!((i64)(*arglist[(i)-1]).simple) ? (i64)0 : (i64)2));
        if (!!(j)) {
            highcomplex = i;
        }
;
L106 :;
    }
L107 :;
    ;
    if (!!(highcomplex)) {
        argcomplex[(highcomplex)-1] = (i64)1;
    }
;
    for (i=(i64)1;i<=nlowargs;++i) {
L108 :;
        if (!!((i64)argcomplex[(i)-1])) {
            if ((i != highcomplex)) {
                mc_blockmcl$pushunit(arglist[(i)-1]);
                mc_libmcl$popregs((u64)regs,0);
            }
;
        }
;
L109 :;
    }
L110 :;
    ;
    if (!!(highcomplex)) {
        mc_blockmcl$loadarg(arglist[(highcomplex)-1],highcomplex,nvariadics);
        mc_libmcl$popregs((u64)regs,0);
    }
;
    for (i=(i64)1;i<=nlowargs;++i) {
L111 :;
        if (((i64)argcomplex[(i)-1] == (i64)0)) {
            mc_blockmcl$loadarg(arglist[(i)-1],i,nvariadics);
            mc_libmcl$popregs((u64)regs,0);
        }
;
L112 :;
    }
L113 :;
    ;
    for (i=nlowargs;i>=(i64)1;--i) {
L114 :;
        if (((i64)argcomplex[(i)-1] == (i64)2)) {
            mc_blockmcl$poptoarg((i64)(*arglist[(i)-1]).mode,i,nvariadics);
        }
;
L115 :;
    }
L116 :;
    ;
    stackbytes = ((nhighargs * (i64)8) + alignbytes);
    if (!!(mc_decls$mstackdepth)) {
        stackbytes += (i64)32;
        mc_libmcl$pushstack((i64)32);
        mc_decls$mstackdepth += (i64)4;
    }
;
    if (!(!!(isptr))) {
        mc_libmcl$genmc((i64)23,mc_libmcl$genmemaddr(d),0);
    }
    else {
        mc_libmcl$genmc((i64)23,(cx = mc_blockmcl$loadunit((*a).a,(i64)0)),0);
    }
;
    if (!!(stackbytes)) {
        mc_libmcl$popstack(stackbytes);
    }
;
    mc_decls$mstackdepth = oldstackdepth;
    --(mc_decls$ncalldepth);
    if (!(!!(isfn))) {
        return 0;
    }
;
    mc_libmcl$popregs((u64)regs,0);
    return mc_libmcl$getretopnd((!!((i64)(*p).memmode) ? (i64)(*p).memmode : (i64)(*p).mode));
}

static void mc_blockmcl$do_stop(struct mm_decls$unitrec *a) {
        i64 regs;
    regs = (i64)mc_decls$regset;
    if (!!(a)) {
        mc_blockmcl$loadarg(a,(i64)1,(i64)0);
    }
    else {
        mc_blockmcl$loadarg((struct mm_decls$unitrec *)mm_lib$createconstunit((u64)0u,(i64)3),(i64)1,(i64)0);
    }
;
    mc_libmcl$genmc((i64)23,mc_libmcl$genextname((byte*)"exit*"),0);
    mc_libmcl$popregs((u64)regs,0);
}

static void mc_blockmcl$do_do(struct mm_decls$unitrec *a) {
        i64 lab_abc;
        i64 lab_d;
    lab_abc = mc_libmcl$definelabel();
    lab_d = mc_libmcl$createfwdlabel();
    mc_libmcl$stacklooplabels(lab_abc,lab_abc,lab_d);
    mc_blockmcl$loadunit(a,(i64)0);
    mc_blockmcl$genjumpl(lab_abc);
    mc_libmcl$definefwdlabel(lab_d);
    --(mc_libmcl$loopindex);
}

static void mc_blockmcl$do_exit(struct mm_decls$unitrec *p,i64 k) {
        i64 n;
        i64 index;
    index = (i64)(*p).index;
    if ((index == (i64)0)) {
        index = mc_libmcl$loopindex;
    }
;
    n = mc_libmcl$findlooplabel(k,index);
    if ((n == (i64)0)) {
        mm_support$gerror((byte*)"Bad exit/loop index",p);
    }
    else {
        mc_blockmcl$genjumpl(n);
    }
;
}

static void mc_blockmcl$do_swap(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  qx;
        i64 regs;
        i64 size;
    regs = (i64)mc_decls$regset;
    px = mc_blockmcl$evalunit(a,(i64)87);
    qx = mc_blockmcl$evalunit(b,(i64)87);
    ax = mc_libmcl$genreg((i64)0,(i64)8);
    bx = mc_libmcl$genreg((i64)0,(i64)8);
        {i64 $temp = (i64)mm_decls$ttcat[((i64)(*a).mode)];
if (($temp==(i64)5)) {
        mm_support$gerror((byte*)"SWAP BLOCK",0);
    }
    else if (($temp==(i64)4)) {
        size = (i64)mm_decls$ttsize[((i64)(*a).mode)];
        mc_libmcl$genmc((i64)21,ax,px);
        mc_libmcl$genmc((i64)21,bx,qx);
        mc_libmcl$genmc((i64)13,qx,mc_libmcl$changeopndsize(ax,size));
        mc_libmcl$genmc((i64)13,px,mc_libmcl$changeopndsize(bx,size));
    }
    else {
        mc_libmcl$genmc((i64)13,ax,px);
        mc_libmcl$genmc((i64)13,bx,qx);
        mc_libmcl$genmc((i64)13,qx,ax);
        mc_libmcl$genmc((i64)13,px,bx);
    }
    };
    mc_libmcl$popregs((u64)regs,0);
}

static void mc_blockmcl$saverdx(void) {
    if (!!(mc_decls$inf_r11used)) {
        mc_libmcl$genmc((i64)14,mc_libmcl$genreg((i64)12,(i64)8),0);
    }
;
}

static void mc_blockmcl$restorerdx(void) {
    if (!!(mc_decls$inf_r11used)) {
        mc_libmcl$genmc((i64)15,mc_libmcl$genreg((i64)12,(i64)8),0);
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$do_divrem(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 issigned,i64 isdiv) {
        i64 opc;
        i64 n;
        i64 shifts;
        i64 swapreg;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
    ax = mc_blockmcl$loadunit(a,(i64)0);
    if ((!!(isdiv) && ((i64)(*b).tag == (i64)1))) {
        n = (*b).value;
        if ((n==(i64)0)) {
            mc_libmcl$merror((byte*)"Divide by zero",(byte*)"");
        }
        else if ((n==(i64)1)) {
            return ax;
        }
        else {
            shifts = mm_lib$ispoweroftwo(n);
            if (!!(shifts)) {
                mc_libmcl$genmc((!!(issigned) ? (i64)46 : (i64)47),ax,mc_libmcl$genint(shifts,(i64)8));
                return ax;
            }
;
        }
;
    }
;
    bx = mc_blockmcl$loadunit(b,(i64)0);
    mc_blockmcl$saverdx();
    swapreg = mc_blockmcl$fixdivopnds(ax,bx);
    if (!!(issigned)) {
        mc_libmcl$genmc((i64)59,0,0);
        opc = (i64)38;
    }
    else {
        mc_libmcl$genmc((i64)42,mc_libmcl$genreg((i64)12,(i64)8),mc_libmcl$genreg((i64)12,(i64)8));
        opc = (i64)39;
    }
;
    mc_libmcl$genmc(opc,bx,0);
    if (!(!!(isdiv))) {
        mc_libmcl$genmc((i64)29,mc_libmcl$genreg((i64)1,(i64)8),mc_libmcl$genreg((i64)12,(i64)8));
    }
;
    mc_blockmcl$restorerdx();
    if (!!(swapreg)) {
        mc_libmcl$genmc((i64)29,mc_libmcl$genreg((i64)1,(i64)8),mc_libmcl$genreg(swapreg,(i64)8));
    }
;
    return ax;
}

static i64 mc_blockmcl$fixdivopnds(struct mc_decls$opndrec *ax,struct mc_decls$opndrec *bx) {
        struct mc_decls$opndrec *  cx;
        i64 rega;
        i64 regb;
    rega = (i64)(*ax).reg;
    regb = (i64)(*bx).reg;
    if ((rega == (i64)1)) {
        return (i64)0;
    }
;
    if ((regb == (i64)1)) {
        mc_libmcl$genmc((i64)29,ax,bx);
        return rega;
    }
;
    cx = mc_libmcl$genreg((i64)1,(i64)8);
    mc_libmcl$genmc((i64)29,cx,ax);
    if ((mc_libmcl$getregbit((i64)1) == (i64)0)) {
        return (i64)0;
    }
;
    return rega;
}

static struct mc_decls$opndrec *mc_blockmcl$do_shift(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 opc) {
        struct mc_decls$opndrec *  ax;
    ax = mc_blockmcl$loadunit(a,(i64)0);
    if (((i64)(*b).tag == (i64)1)) {
        mc_libmcl$genmc(opc,ax,mc_libmcl$genint((*b).value,(i64)8));
    }
    else {
        if (!!(mc_decls$inf_r10used)) {
            mc_libmcl$merror((byte*)"shift:cl in use",(byte*)"");
        }
;
        mc_blockmcl$loadarg(b,(i64)1,(i64)0);
        mc_libmcl$genmc(opc,ax,mc_libmcl$genreg((i64)11,(i64)1));
    }
;
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_convert(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg) {
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  cx;
        u8 str[100];
        i64 oldmode;
        i64 newmode;
        i64 regs;
        i64 lab;
        i64 lab2;
        i64 mask;
    oldmode = (i64)(*p).convmode;
    newmode = (i64)(*p).mode;
    regs = (i64)mc_decls$regset;
    ax = (bx = mc_blockmcl$loadunit(a,(i64)0));
        {i64 $temp = (i64)(*p).pclop;
if (($temp==(i64)83)) {
        bx = mc_libmcl$genxreg(reg,(i64)mm_decls$ttsize[(newmode)]);
                {i64 $temp = ((oldmode << (i64)16) | newmode);
if (($temp==(i64)196613) || ($temp==(i64)65541)) {
            mc_libmcl$genmc((i64)86,bx,ax);
        }
        else if (($temp==(i64)196612)) {
            mc_libmcl$genmc((i64)85,bx,ax);
        }
        else if (($temp==(i64)131077)) {
            lab = mc_libmcl$createfwdlabel();
            lab2 = mc_libmcl$createfwdlabel();
            mc_libmcl$genmc((i64)44,ax,mc_libmcl$genint((i64)0,(i64)8));
            mc_libmcl$genmc_cond((i64)28,(i64)12,mc_libmcl$genlabel(lab),0);
            mc_libmcl$genmc((i64)86,bx,ax);
            mc_libmcl$genmc((i64)27,mc_libmcl$genlabel(lab2),0);
            mc_libmcl$definefwdlabel(lab);
            if (!(!!(mc_decls$labmask63))) {
                mc_decls$labmask63 = ++(mc_decls$mlabelno);
                mc_decls$laboffset64 = ++(mc_decls$mlabelno);
            }
;
            mc_libmcl$genmc((i64)40,ax,mc_libmcl$genlabelmem(mc_decls$labmask63));
            mc_libmcl$genmc((i64)86,bx,ax);
            mc_libmcl$genmc((i64)69,bx,mc_libmcl$genlabelmem(mc_decls$laboffset64));
            mc_libmcl$definefwdlabel(lab2);
        }
        else {
            goto L117 ;
;
        }
        };
    }
    else if (($temp==(i64)84)) {
        bx = mc_libmcl$genreg(reg,(i64)8);
        mc_libmcl$genmc(((oldmode == (i64)5) ? (i64)84 : (i64)83),bx,ax);
    }
    else if (($temp==(i64)86)) {
        bx = mc_libmcl$changeopndsize(ax,(i64)8);
        mc_libmcl$genmc((i64)88,bx,ax);
    }
    else if (($temp==(i64)87)) {
        bx = mc_libmcl$changeopndsize(ax,(i64)4);
        mc_libmcl$genmc((i64)87,bx,ax);
    }
    else if (($temp==(i64)85)) {
                {i64 $temp = (i64)mm_decls$ttsize[(oldmode)];
if (($temp==(i64)1)) {
            mask = (i64)255;
        }
        else if (($temp==(i64)2)) {
            mask = (i64)65535;
        }
        else if (($temp==(i64)4)) {
            mask = (i64)4294967295;
        }
        };
        mc_libmcl$genmc((i64)40,ax,mc_libmcl$genint(mask,(i64)8));
        mc_libmcl$genmc((!!((i64)mm_decls$ttsigned[(oldmode)]) ? (i64)20 : (i64)21),ax,mc_libmcl$changeopndsize(ax,(i64)mm_decls$ttsize[(oldmode)]));
    }
    else if (($temp==(i64)33)) {
                {i64 $temp = (i64)mm_decls$ttcat[((i64)(*p).mode)];
if (($temp==(i64)1)) {
            mc_libmcl$genmc((i64)43,ax,ax);
            mc_libmcl$genmc_cond((i64)60,(i64)5,(cx = mc_libmcl$changeopndsize(ax,(i64)1)),0);
            mc_libmcl$genmc((i64)21,mc_libmcl$changeopndsize(ax,(i64)4),cx);
        }
        else {
            goto L117 ;
;
        }
        };
    }
    else {
        //error:
L117 :;
;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#-># (#)");
        msysc$m_print_str(mm_lib$strmode(oldmode,(i64)1),NULL);
        msysc$m_print_str(mm_lib$strmode(newmode,(i64)1),NULL);
        msysc$m_print_str(mm_tables$pclnames[((i64)(*p).pclop)],NULL);
        msysc$m_print_end();
        ;
        mm_support$gerror_s((byte*)"Convert ",str,0);
    }
    };
    mc_libmcl$popregs((u64)regs,bx);
    return bx;
}

static void mc_blockmcl$do_clear(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 regs;
        struct mc_decls$opndrec *  px;
    regs = (i64)mc_decls$regset;
    px = mc_libmcl$makeopndind(mc_blockmcl$loadref(a,(i64)0),(i64)0);
    mc_libmcl$clearblock(px,(i64)mm_decls$ttsize[((i64)(*a).mode)]);
    mc_libmcl$popregs((u64)regs,0);
}

static struct mc_decls$opndrec *mc_blockmcl$do_case(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *pwhenthen,struct mm_decls$unitrec *pelse,i64 loopsw,i64 isref,i64 reg) {
        struct mc_decls$opndrec *  tx;
        i64 labtable[256];
        struct mm_decls$unitrec *  unittable[256];
        i64 ncases;
        i64 regs;
        i64 regs2;
        struct mc_decls$opndrec *  ix;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  rx;
        i64 lab_abc;
        i64 lab_d;
        i64 labelse;
        struct mm_decls$unitrec *  w;
        struct mm_decls$unitrec *  wt;
        i64 i;
    if ((pindex == 0)) {
        mm_support$gerror((byte*)"EMPTY CASE NOT DONE",0);
    }
;
    rx = mc_libmcl$newmclopnd();
    tx = 0;
    regs = (i64)mc_decls$regset;
    if (!!(loopsw)) {
        lab_abc = mc_libmcl$definelabel();
        lab_d = mc_libmcl$createfwdlabel();
        mc_libmcl$stacklooplabels(lab_abc,lab_abc,lab_d);
    }
    else {
        lab_d = mc_libmcl$createfwdlabel();
    }
;
    ix = mc_blockmcl$loadunit(pindex,(i64)0);
    if ((mc_blockmcl$casedepth >= (i64)20)) {
        mm_support$gerror((byte*)"case nested too deeply",0);
    }
;
    mc_blockmcl$casestmt[(++(mc_blockmcl$casedepth))-1] = p;
    ncases = (i64)0;
    wt = pwhenthen;
    L118 :;
    while (!!(wt)) {
        w = (*wt).a;
        if ((ncases >= (i64)256)) {
            mm_support$gerror((byte*)"too many cases",0);
        }
;
        labtable[(++(ncases))-1] = mc_libmcl$createfwdlabel();
        unittable[(ncases)-1] = (*wt).b;
        L122 :;
        while (!!(w)) {
            regs2 = (i64)mc_decls$regset;
            bx = mc_blockmcl$evalunit(w,(i64)65);
            mc_libmcl$genmc((i64)44,ix,bx);
            mc_libmcl$popregs((u64)regs2,0);
            mc_libmcl$genmc_cond((i64)28,(i64)4,mc_libmcl$genlabel(((*w).whenlabel = labtable[(ncases)-1])),0);
L123 :;
            w = (*w).nextunit;
L125 :;
                    }
L124 :;
        ;
L119 :;
        wt = (*wt).nextunit;
L121 :;
            }
L120 :;
    ;
    mc_libmcl$popregs((u64)regs,0);
    labelse = mc_libmcl$createfwdlabel();
    mc_blockmcl$caseelse[(mc_blockmcl$casedepth)-1] = labelse;
    mc_blockmcl$genjumpl(labelse);
    for (i=(i64)1;i<=ncases;++i) {
L126 :;
        mc_libmcl$definefwdlabel(labtable[(i)-1]);
        tx = (!!(isref) ? mc_blockmcl$loadref(unittable[(i)-1],reg) : mc_blockmcl$loadunit(unittable[(i)-1],reg));
        mc_blockmcl$setmultopnd(tx,rx);
        mc_libmcl$popregs((u64)regs,0);
        if (!!(loopsw)) {
            mc_blockmcl$genjumpl(lab_abc);
        }
        else {
            mc_blockmcl$genjumpl(lab_d);
        }
;
L127 :;
    }
L128 :;
    ;
    mc_libmcl$definefwdlabel(labelse);
    if (!!(pelse)) {
        tx = (!!(isref) ? mc_blockmcl$loadref(pelse,reg) : mc_blockmcl$loadunit(pelse,reg));
        mc_blockmcl$setmultopnd(tx,rx);
    }
;
    if (!!(loopsw)) {
        mc_blockmcl$genjumpl(lab_abc);
        mc_libmcl$definefwdlabel(lab_d);
        --(mc_libmcl$loopindex);
    }
    else {
        mc_libmcl$definefwdlabel(lab_d);
    }
;
    --(mc_blockmcl$casedepth);
    mc_libmcl$popregs((u64)regs,tx);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_switch(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *pwhenthen,struct mm_decls$unitrec *pelse,i64 loopsw,i64 isref,i64 reg) {
        struct mc_decls$opndrec *  tx;
        i64 minlab;
        i64 maxlab;
        i64 n;
        i64 iscomplex;
        i64 i;
        i64 lab_a;
        i64 lab_d;
        i64 labjump;
        i64 elselab;
        i64 labstmt;
        i64 ax;
        i64 bx;
        i64 regs;
        struct mc_decls$mclrec *  labels[1001];
        struct mm_decls$unitrec *  w;
        struct mm_decls$unitrec *  wt;
        struct mc_decls$opndrec *  rx;
        struct mc_decls$opndrec *  ix;
    minlab = (i64)1000000;
    maxlab = (i64)-1000000;
    n = (i64)0;
    iscomplex = (i64)0;
    rx = mc_libmcl$newmclopnd();
    tx = 0;
    regs = (i64)mc_decls$regset;
    wt = pwhenthen;
    L129 :;
    while (!!(wt)) {
        w = (*wt).a;
        L133 :;
        while (!!(w)) {
                        {i64 $temp = (i64)(*w).tag;
if (($temp==(i64)19)) {
                ax = (*(*w).a).value;
                bx = (*(*w).b).value;
                //dorange:
L137 :;
;
                for (i=ax;i<=bx;++i) {
L138 :;
                    minlab = (i<minlab?i:minlab);
                    maxlab = (i>maxlab?i:maxlab);
L139 :;
                }
L140 :;
                ;
            }
            else if (($temp==(i64)1)) {
                ax = (bx = (*w).value);
                goto L137 ;
;
            }
            else {
                mm_support$gerror_s((byte*)"Switch when2: not const: #",(*mm_lib$strexpr((struct mm_decls$unitrec *)w)).strptr,0);
            }
            };
L134 :;
            w = (*w).nextunit;
L136 :;
                    }
L135 :;
        ;
L130 :;
        wt = (*wt).nextunit;
L132 :;
            }
L131 :;
    ;
    n = ((maxlab - minlab) + (i64)1);
    if ((n > (i64)1000)) {
        mm_support$gerror((byte*)"Switch too big",0);
    }
;
    if (!!(loopsw)) {
        lab_a = mc_libmcl$definelabel();
        lab_d = mc_libmcl$createfwdlabel();
        mc_libmcl$stacklooplabels(lab_a,lab_a,lab_d);
    }
    else {
        lab_d = mc_libmcl$createfwdlabel();
    }
;
    labjump = mc_libmcl$createfwdlabel();
    elselab = mc_libmcl$createfwdlabel();
    ix = mc_blockmcl$loadunit(pindex,(i64)0);
    if (!!(minlab)) {
        mc_libmcl$genmc((i64)31,ix,mc_libmcl$genint(minlab,(i64)8));
    }
;
    mc_libmcl$genmc((i64)44,ix,mc_libmcl$genint(((maxlab - minlab) + (i64)1),(i64)8));
    mc_libmcl$genmc_cond((i64)28,(i64)3,mc_libmcl$genlabel(elselab),0);
    mc_libmcl$genmc((i64)27,mc_libmcl$genindex((i64)0,(i64)(*ix).reg,(i64)8,(i64)0,(i64)0,labjump,0),0);
    mc_libmcl$popregs((u64)regs,0);
    mc_libmcl$definefwdlabel(labjump);
    for (i=minlab;i<=maxlab;++i) {
L141 :;
        mc_libmcl$genmc((i64)118,mc_libmcl$genlabel(elselab),0);
        labels[(i)] = (struct mc_decls$mclrec *)mc_decls$mccodex;
L142 :;
    }
L143 :;
    ;
    wt = pwhenthen;
    L144 :;
    while (!!(wt)) {
        labstmt = mc_libmcl$definelabel();
        w = (*wt).a;
        L148 :;
        while (!!(w)) {
                        {i64 $temp = (i64)(*w).tag;
if (($temp==(i64)19)) {
                ax = (*(*w).a).value;
                bx = (*(*w).b).value;
            }
            else if (($temp==(i64)1)) {
                ax = (bx = (*w).value);
            }
            };
            for (i=ax;i<=bx;++i) {
L152 :;
                (*(*labels[(i)]).a).labelno = labstmt;
L153 :;
            }
L154 :;
            ;
L149 :;
            w = (*w).nextunit;
L151 :;
                    }
L150 :;
        ;
        tx = (!!(isref) ? mc_blockmcl$loadref((*wt).b,reg) : mc_blockmcl$loadunit((*wt).b,reg));
        mc_blockmcl$setmultopnd(tx,rx);
        mc_libmcl$popregs((u64)regs,0);
        mc_blockmcl$genjumpl((!!(loopsw) ? lab_a : lab_d));
L145 :;
        wt = (*wt).nextunit;
L147 :;
            }
L146 :;
    ;
    mc_libmcl$definefwdlabel(elselab);
    if (!!(pelse)) {
        tx = (!!(isref) ? mc_blockmcl$loadref(pelse,reg) : mc_blockmcl$loadunit(pelse,reg));
        mc_blockmcl$setmultopnd(tx,rx);
    }
;
    if (!!(loopsw)) {
        mc_blockmcl$genjumpl(lab_a);
        mc_libmcl$definefwdlabel(lab_d);
        --(mc_libmcl$loopindex);
    }
    else {
        mc_libmcl$definefwdlabel(lab_d);
    }
;
    mc_libmcl$popregs((u64)regs,tx);
    return tx;
}

static void mc_blockmcl$do_binto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        u8 str[128];
        i64 cat;
        i64 target;
        i64 regs;
    cat = (i64)mm_decls$ttcat[((i64)(*a).mode)];
    target = (i64)mm_decls$tttarget[((i64)(*a).mode)];
    regs = (i64)mc_decls$regset;
        {i64 $temp = (i64)(*p).pclop;
if (($temp==(i64)59)) {
        if ((cat==(i64)1) || (cat==(i64)4)) {
            mc_blockmcl$do_bintomem(a,b,(i64)30);
        }
        else if ((cat==(i64)3)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)69);
        }
        else if ((cat==(i64)2)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)65);
        }
        else {
            goto L155 ;
;
        }
;
    }
    else if (($temp==(i64)60)) {
        if ((cat==(i64)1) || (cat==(i64)4)) {
            mc_blockmcl$do_bintomem(a,b,(i64)31);
        }
        else if ((cat==(i64)3)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)70);
        }
        else if ((cat==(i64)2)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)66);
        }
        else {
            goto L155 ;
;
        }
;
    }
    else if (($temp==(i64)61)) {
        if ((cat==(i64)1) || (cat==(i64)4)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)36);
        }
        else if ((cat==(i64)3)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)71);
        }
        else if ((cat==(i64)2)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)67);
        }
        else {
            goto L155 ;
;
        }
;
    }
    else if (($temp==(i64)62)) {
        if ((cat==(i64)1) || (cat==(i64)4)) {
            goto L156 ;
;
        }
        else if ((cat==(i64)3)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)72);
        }
        else if ((cat==(i64)2)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)68);
        }
        else {
            goto L155 ;
;
        }
;
    }
    else if (($temp==(i64)63)) {
        //doidiv:
L156 :;
;
        mm_support$gerror((byte*)"IDIVTO",0);
    }
    else if (($temp==(i64)64)) {
        mm_support$gerror((byte*)"IREMTO",0);
    }
    else if (($temp==(i64)65)) {
        mc_blockmcl$do_bintomem(a,b,(i64)40);
    }
    else if (($temp==(i64)66)) {
        mc_blockmcl$do_bintomem(a,b,(i64)41);
    }
    else if (($temp==(i64)67)) {
        mc_blockmcl$do_bintomem(a,b,(i64)42);
    }
    else if (($temp==(i64)68)) {
        mc_blockmcl$do_shiftnto(a,b,(i64)45);
    }
    else if (($temp==(i64)69)) {
        mc_blockmcl$do_shiftnto(a,b,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)46 : (i64)47));
    }
    else if (($temp==(i64)70)) {
        if ((cat==(i64)1) || (cat==(i64)4)) {
            mc_blockmcl$domaxto_int(a,b,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)14 : (i64)6));
        }
        else if ((cat==(i64)3)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)113);
        }
        else if ((cat==(i64)2)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)111);
        }
        else {
            goto L155 ;
;
        }
;
    }
    else if (($temp==(i64)71)) {
        if ((cat==(i64)1) || (cat==(i64)4)) {
            mc_blockmcl$domaxto_int(a,b,(!!((i64)mm_decls$ttsigned[((i64)(*a).mode)]) ? (i64)13 : (i64)3));
        }
        else if ((cat==(i64)3)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)114);
        }
        else if ((cat==(i64)2)) {
            mc_blockmcl$do_bintoreg(a,b,(i64)112);
        }
        else {
            goto L155 ;
;
        }
;
    }
    else if (($temp==(i64)74)) {
        mc_blockmcl$do_addrefoffto(p,a,b,(i64)1);
    }
    else if (($temp==(i64)75)) {
        mc_blockmcl$do_addrefoffto(p,a,b,(i64)0);
    }
    else {
        //error:
L155 :;
;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"Binto:#:#");
        msysc$m_print_str(mm_tables$pclnames[((i64)(*p).pclop)],NULL);
        msysc$m_print_str(mm_lib$strmode((i64)(*p).mode,(i64)1),NULL);
        msysc$m_print_end();
        ;
        mm_support$gerror(str,0);
    }
    };
    mc_libmcl$popregs(mc_decls$regset,0);
}

static void mc_blockmcl$do_bintomem(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 opc) {
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  bx;
    mc_blockmcl$loadbinto(a,b,(i64)1);
    px = mc_blockmcl$axb;
    bx = mc_blockmcl$bxb;
    if ((msysc$m_getdotslice((i64)(*bx).misc,(i64)0,(i64)3) != msysc$m_getdotslice((i64)(*px).misc,(i64)0,(i64)3))) {
        bx = mc_libmcl$changeopndsize(bx,(i64)msysc$m_getdotslice((i64)(*px).misc,(i64)0,(i64)3));
    }
;
    mc_libmcl$genmc(opc,px,bx);
}

static void mc_blockmcl$do_bintoreg(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 opc) {
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
    mc_blockmcl$loadbinto(a,b,(i64)0);
    px = mc_blockmcl$axb;
    bx = mc_blockmcl$bxb;
        {i64 $temp = (i64)mm_decls$ttcat[((i64)(*a).mode)];
if (($temp==(i64)1)) {
        ax = mc_libmcl$genreg((i64)0,(i64)8);
        mc_libmcl$genmc((i64)13,ax,px);
        mc_libmcl$genmc(opc,ax,bx);
        mc_libmcl$genmc((i64)13,px,ax);
    }
    else if (($temp==(i64)3)) {
        ax = mc_libmcl$genxreg((i64)0,(i64)8);
        mc_libmcl$genmc((i64)19,ax,px);
        mc_libmcl$genmc(opc,ax,bx);
        mc_libmcl$genmc((i64)19,px,ax);
    }
    else if (($temp==(i64)2)) {
        ax = mc_libmcl$genxreg((i64)0,(i64)8);
        mc_libmcl$genmc((i64)18,ax,px);
        mc_libmcl$genmc(opc,ax,bx);
        mc_libmcl$genmc((i64)18,px,ax);
    }
    else if (($temp==(i64)4)) {
        ax = mc_libmcl$genreg((i64)0,(i64)8);
        mm_support$gerror((byte*)"DOBINTOREG/SHORT",0);
    }
    };
}

static struct mc_decls$opndrec *mc_blockmcl$do_return(struct mm_decls$unitrec *a) {
        struct mc_decls$opndrec *  tx;
    if (!!(a)) {
        tx = mc_blockmcl$loadunit(a,(!!((i64)mm_decls$ttisreal[((i64)(*a).mode)]) ? (i64)21 : (i64)1));
    }
    else {
        tx = 0;
    }
;
    mc_blockmcl$genjumpl(mc_decls$retindex);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_returnmult(struct mm_decls$unitrec *a) {
        struct mc_decls$opndrec *  tx;
        struct mc_decls$opndrec *  ax;
        struct mm_decls$unitrec *  q;
        i64 regoffset;
        i64 regs;
    regoffset = (i64)0;
    regs = (i64)mc_decls$regset;
    q = a;
    L157 :;
    while (!!(q)) {
        if (!(!!((i64)(*q).simple))) {
            mm_support$gerror((byte*)"Retmult:complex",0);
        }
;
        regs = (i64)mc_decls$regset;
        ax = mc_blockmcl$loadunit(q,((!!((i64)mm_decls$ttisreal[((i64)(*q).mode)]) ? (i64)21 : (i64)1) + regoffset));
        mc_libmcl$popregs((u64)regs,ax);
        if ((q == a)) {
            tx = ax;
        }
;
        ++(regoffset);
L158 :;
        q = (*q).nextunit;
L160 :;
            }
L159 :;
    ;
    mc_blockmcl$genjumpl(mc_decls$retindex);
    return tx;
}

static void mc_blockmcl$do_addrefoffto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 isincr) {
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  bx;
        i64 size;
    size = (i64)mm_decls$ttsize[((i64)mm_decls$tttarget[((i64)(*a).mode)])];
    if (((i64)(*b).tag == (i64)1)) {
        px = mc_blockmcl$evalunit(a,(i64)87);
        mc_blockmcl$do_incrstep(px,(size * (*b).value),isincr);
        return;
    }
;
    mc_blockmcl$loadbinto(a,b,(i64)1);
    px = mc_blockmcl$axb;
    bx = mc_blockmcl$bxb;
    mc_blockmcl$mulreg(bx,size);
    mc_libmcl$genmc((!!(isincr) ? (i64)30 : (i64)31),px,bx);
}

static void mc_blockmcl$domaxto_int(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 cond) {
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  lx;
        i64 lab;
    mc_blockmcl$loadbinto(a,b,(i64)1);
    px = mc_blockmcl$axb;
    bx = mc_blockmcl$bxb;
    ax = mc_libmcl$genreg((i64)0,(i64)8);
    mc_libmcl$genmc((i64)13,ax,px);
    mc_libmcl$genmc((i64)44,ax,bx);
    lab = ++(mc_decls$mlabelno);
    mc_libmcl$genmc_cond((i64)28,cond,(lx = mc_libmcl$genlabel(lab)),0);
    mc_libmcl$genmc((i64)13,px,mc_libmcl$changeopndsize(bx,(i64)msysc$m_getdotslice((i64)(*px).misc,(i64)0,(i64)3)));
    mc_libmcl$genmc((i64)11,lx,0);
}

static struct mc_decls$opndrec *mc_blockmcl$do_setcc(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg) {
        i64 cond;
        i64 isfloat;
        i64 regs;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  cx;
    regs = (i64)mc_decls$regset;
    mc_blockmcl$loadbin(a,b,(i64)0,(i64)0,(i64)1);
    ax = mc_blockmcl$axb;
    bx = mc_blockmcl$bxb;
    isfloat = (i64)0;
    cond = mc_libmcl$getmclcond((i64)(*p).pclop,(i64)(*a).mode);
        {i64 $temp = (i64)mm_decls$ttcat[((i64)(*a).mode)];
if (($temp==(i64)1)) {
        mc_libmcl$genmc((i64)44,ax,bx);
    }
    else if (($temp==(i64)2)) {
        isfloat = (i64)1;
        mc_libmcl$genmc((i64)73,ax,bx);
    }
    else if (($temp==(i64)3)) {
        mc_libmcl$genmc((i64)74,ax,bx);
        isfloat = (i64)1;
    }
    else {
        mm_support$gerror_t((byte*)"setcc:",a);
    }
    };
    if (!!(isfloat)) {
        cx = mc_libmcl$genreg(reg,(i64)1);
    }
    else {
        cx = mc_libmcl$changeopndsize(ax,(i64)1);
    }
;
    mc_libmcl$genmc_cond((i64)60,cond,cx,0);
    mc_libmcl$genmc((i64)21,(ax = mc_libmcl$changeopndsize(cx,(i64)8)),cx);
    mc_libmcl$popregs((u64)regs,ax);
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_read(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        struct mc_decls$opndrec *  ax;
        i64 m;
        i64 regs;
        i64 opc;
    regs = (i64)mc_decls$regset;
    m = (i64)(*p).mode;
    if ((a == 0)) {
        a = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)0u,(i64)3);
    }
;
    if (!!((i64)mm_decls$ttisinteger[(m)])) {
        opc = (i64)23;
    }
    else if ((!!((i64)mm_decls$ttisreal[(m)]) && ((i64)mm_decls$ttsize[(m)] == (i64)8))) {
        opc = (i64)24;
    }
    else if ((m == (i64)20)) {
        opc = (i64)25;
    }
    else {
        mm_support$gerror_t((byte*)"Read:",p);
    }
;
    ax = mc_libmcl$gensysfn(opc,a,0,0);
    mc_libmcl$popregs((u64)regs,ax);
    return ax;
}

static void mc_blockmcl$do_readln(struct mm_decls$unitrec *a) {
    if (!!(a)) {
        if (((i64)mm_decls$ttbasetype[((i64)(*a).mode)] != (i64)7)) {
            mm_support$gerror((byte*)"@dev no ref",0);
        }
;
                {i64 $temp = (i64)mm_decls$ttbasetype[((i64)mm_decls$tttarget[((i64)(*a).mode)])];
if (($temp==(i64)0)) {
            mc_libmcl$gensysproc((i64)26,a,0,0,(i64)0);
        }
        else if (($temp==(i64)17) || ($temp==(i64)12)) {
            mc_libmcl$gensysproc((i64)27,a,0,0,(i64)0);
        }
        else {
            mm_support$gerror((byte*)"rd@dev?",0);
        }
        };
    }
    else {
        mc_libmcl$gensysproc((i64)28,0,0,0,(i64)0);
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$do_syscall(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg) {
        struct mc_decls$opndrec *  ax;
        i64 lab;
    if ((mc_decls$lab_funcnametable == (i64)0)) {
        mc_decls$lab_funcnametable = ++(mc_decls$mlabelno);
        mc_decls$lab_funcaddrtable = ++(mc_decls$mlabelno);
        mc_decls$lab_funcnprocs = ++(mc_decls$mlabelno);
    }
;
        {i64 $temp = (i64)(*p).fnindex;
if (($temp==(i64)29)) {
        ax = mc_libmcl$genreg(reg,(i64)8);
        mc_libmcl$genmc((i64)13,ax,mc_libmcl$genlabelmem(mc_decls$lab_funcnprocs));
    }
    else if (($temp==(i64)30)) {
        lab = mc_decls$lab_funcnametable;
        //dogetproc:
L161 :;
;
        ax = mc_blockmcl$loadunit(a,reg);
        mc_libmcl$genmc((i64)13,ax,mc_libmcl$genindex((i64)0,(i64)(*ax).reg,(i64)8,(i64)-8,(i64)0,lab,0));
    }
    else if (($temp==(i64)31)) {
        lab = mc_decls$lab_funcaddrtable;
        goto L161 ;
;
    }
    else {
        mm_support$gerror_s((byte*)"syscall:",mm_tables$sysfnnames[((i64)(*p).fnindex)-1],0);
    }
    };
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_dotindex(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        i64 regs;
        i64 i;
    regs = (i64)mc_decls$regset;
    mc_blockmcl$loadbin(a,b,reg,(i64)0,(i64)0);
    ax = mc_blockmcl$axb;
    bx = mc_blockmcl$bxb;
    if (((i64)(*b).tag != (i64)1)) {
        mm_support$gerror((byte*)"dotix i not imm",0);
    }
;
    i = (*b).value;
    if (!!(i)) {
        mc_libmcl$genmc((i64)47,ax,mc_libmcl$genint(i,(i64)8));
    }
;
    mc_libmcl$genmc((i64)40,mc_libmcl$changeopndsize(ax,(i64)4),mc_libmcl$genint((i64)1,(i64)8));
    mc_libmcl$popregs((u64)regs,ax);
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_dotslice(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  mx;
        i64 regs;
        i64 i;
        i64 j;
        u64 mask;
    regs = (i64)mc_decls$regset;
    if (!(((i64)(*(*b).a).tag==(i64)(*(*b).b).tag && (i64)(*(*b).b).tag==(i64)1))) {
        mm_support$gerror((byte*)"dotsl not const i..j",0);
    }
;
    i = (*(*b).a).value;
    j = (*(*b).b).value;
    ax = mc_blockmcl$loadunit(a,reg);
    if (!!(i)) {
        mc_libmcl$genmc((i64)47,ax,mc_libmcl$genint(i,(i64)8));
    }
;
    mask = ~(((u64)18446744073709551615u << ((j - i) + (i64)1)));
    if ((mask <= (u64)2147483647u)) {
        mc_libmcl$genmc((i64)40,ax,mc_libmcl$genint((i64)mask,(i64)8));
    }
    else {
        mc_libmcl$genmc((i64)13,(mx = mc_libmcl$genreg((i64)0,(i64)8)),mc_libmcl$genint((i64)mask,(i64)8));
        mc_libmcl$genmc((i64)40,ax,mx);
    }
;
    mc_libmcl$popregs((u64)regs,ax);
    return ax;
}

static struct mc_decls$opndrec *mc_blockmcl$do_typepun(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 reg) {
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  ix;
        i64 oldmode;
        i64 newmode;
        i64 regs;
        i64 size;
    oldmode = (i64)(*a).mode;
    newmode = (i64)(*p).convmode;
    regs = (i64)mc_decls$regset;
    ax = mc_blockmcl$loadunit(a,(i64)0);
    bx = ax;
    size = (i64)mm_decls$ttsize[(newmode)];
    if ((size != (i64)mm_decls$ttsize[(oldmode)])) {
        mm_support$gerror((byte*)"TYPEPUN SIZE?",0);
    }
;
    if ((!!((i64)mm_decls$ttisreal[(oldmode)]) && !(!!((i64)mm_decls$ttisreal[(newmode)])))) {
        bx = mc_libmcl$genreg(reg,size);
        if ((size == (i64)4)) {
            mc_libmcl$genmc((i64)18,bx,ax);
            ix = mc_libmcl$changeopndsize(bx,(i64)8);
            if (!!((i64)mm_decls$ttsigned[(newmode)])) {
                mc_libmcl$genmc((i64)20,ix,bx);
            }
;
            bx = ix;
        }
        else {
            mc_libmcl$genmc((i64)19,bx,ax);
        }
;
    }
    else if ((!(!!((i64)mm_decls$ttisreal[(oldmode)])) && !!((i64)mm_decls$ttisreal[(newmode)]))) {
        bx = mc_libmcl$genxreg(reg,size);
        mc_libmcl$genmc(((size == (i64)4) ? (i64)18 : (i64)19),bx,ax);
    }
;
    mc_libmcl$popregs((u64)regs,bx);
    return bx;
}

static void mc_blockmcl$do_shiftnto(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 opc) {
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  cx;
        i64 regs;
    regs = (i64)mc_decls$regset;
    px = mc_blockmcl$evalunit(a,(i64)87);
    if (((i64)(*b).tag == (i64)1)) {
        mc_libmcl$genmc(opc,px,mc_libmcl$genint((*b).value,(i64)8));
    }
    else {
        cx = mc_libmcl$genreg((i64)11,(i64)8);
        mc_libmcl$genmc((i64)14,cx,0);
        bx = mc_blockmcl$loadunit(b,(i64)11);
        mc_libmcl$genmc(opc,px,mc_libmcl$changeopndsize(bx,(i64)1));
        mc_libmcl$genmc((i64)15,cx,0);
    }
;
    mc_libmcl$popregs((u64)regs,0);
}

static struct mc_decls$opndrec *mc_blockmcl$do_select(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 isref,i64 reg) {
        struct mc_decls$opndrec *  tx;
        struct mc_decls$opndrec *  rx;
        struct mc_decls$opndrec *  ix;
        struct mc_decls$mclrec *  labels[256];
        i64 labend;
        i64 labjump;
        i64 n;
        i64 i;
        i64 elselab;
        i64 labstmt;
        i64 regs;
        struct mm_decls$unitrec *  q;
    rx = mc_libmcl$newmclopnd();
    tx = 0;
    regs = (i64)mc_decls$regset;
    q = b;
    n = (i64)0;
    L162 :;
    while (!!(q)) {
        if ((n >= (i64)256)) {
            mm_support$gerror((byte*)"selectx: too many labels",0);
        }
;
        ++(n);
L163 :;
        q = (*q).nextunit;
L165 :;
            }
L164 :;
    ;
    labend = mc_libmcl$createfwdlabel();
    labjump = mc_libmcl$createfwdlabel();
    elselab = mc_libmcl$createfwdlabel();
    ix = mc_blockmcl$loadunit(a,(i64)0);
    mc_libmcl$genmc((i64)55,ix,0);
    mc_libmcl$genmc((i64)44,ix,mc_libmcl$genint(n,(i64)8));
    mc_libmcl$genmc_cond((i64)28,(i64)3,mc_libmcl$genlabel(elselab),0);
    mc_libmcl$genmc((i64)27,mc_libmcl$genindex((i64)0,(i64)(*ix).reg,(i64)8,(i64)0,(i64)0,labjump,0),0);
    mc_libmcl$popregs((u64)regs,0);
    mc_libmcl$definefwdlabel(labjump);
    for (i=(i64)1;i<=n;++i) {
L166 :;
        mc_libmcl$genmc((i64)118,mc_libmcl$genlabel(elselab),0);
        labels[(i)-1] = (struct mc_decls$mclrec *)mc_decls$mccodex;
L167 :;
    }
L168 :;
    ;
    q = b;
    i = (i64)0;
    L169 :;
    while (!!(q)) {
        labstmt = mc_libmcl$definelabel();
        ++(i);
        (*(*labels[(i)-1]).a).labelno = labstmt;
        tx = (!!(isref) ? mc_blockmcl$loadref(q,reg) : mc_blockmcl$loadunit(q,reg));
        mc_blockmcl$setmultopnd(tx,rx);
        mc_libmcl$popregs((u64)regs,0);
        mc_blockmcl$genjumpl(labend);
L170 :;
        q = (*q).nextunit;
L172 :;
            }
L171 :;
    ;
    mc_libmcl$definefwdlabel(elselab);
    tx = (!!(isref) ? mc_blockmcl$loadref(c,reg) : mc_blockmcl$loadunit(c,reg));
    mc_blockmcl$setmultopnd(tx,rx);
    mc_libmcl$definefwdlabel(labend);
    mc_libmcl$popregs((u64)regs,tx);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_setccchain(struct mm_decls$unitrec *p,struct mm_decls$unitrec *q,i64 reg) {
        struct mc_decls$opndrec *  tx;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        i64 lab1;
        i64 lab2;
        i64 i;
        i64 regs;
        i64 regs2;
        struct mm_decls$unitrec *  r;
    lab1 = mc_libmcl$createfwdlabel();
    lab2 = mc_libmcl$createfwdlabel();
    r = (*q).nextunit;
    i = (i64)1;
    regs = (i64)mc_decls$regset;
    tx = mc_libmcl$genreg(reg,(i64)8);
    regs2 = regs;
    L173 :;
    while (!!(r)) {
        ax = mc_blockmcl$loadunit(q,(i64)0);
        bx = mc_blockmcl$evalunit(r,(i64)65);
        mc_libmcl$genmc((i64)44,ax,bx);
        mc_libmcl$popregs((u64)regs2,0);
        mc_libmcl$genmc_cond((i64)28,mc_libmcl$getmclcond(mc_blockmcl$reversecond((i64)(*p).cmpgenop[(i)-1]),(i64)(*q).mode),mc_libmcl$genlabel(lab1),0);
        ++(i);
        q = r;
L174 :;
        r = (*r).nextunit;
L176 :;
            }
L175 :;
    ;
    mc_libmcl$genmc((i64)13,tx,mc_libmcl$genint((i64)1,(i64)8));
    mc_libmcl$genmc((i64)27,mc_libmcl$genlabel(lab2),0);
    mc_libmcl$definefwdlabel(lab1);
    mc_libmcl$genmc((i64)13,tx,mc_libmcl$genint((i64)0,(i64)8));
    mc_libmcl$definefwdlabel(lab2);
    mc_libmcl$popregs((u64)regs,tx);
    return tx;
}

static struct mc_decls$opndrec *mc_blockmcl$do_maths(struct mm_decls$unitrec *a,i64 reg,u8 *opname) {
        i64 regs;
    regs = (i64)mc_decls$regset;
    mc_blockmcl$loadarg(a,(i64)1,(i64)0);
    mc_blockmcl$do_callext(mc_libmcl$genextname(opname));
    mc_libmcl$popregs((u64)regs,0);
    return mc_libmcl$getretopnd((i64)(*a).mode);
}

static struct mc_decls$opndrec *mc_blockmcl$do_maths2(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg,u8 *opname) {
        i64 regs;
    regs = (i64)mc_decls$regset;
    if (!!((i64)(*b).simple)) {
        mc_blockmcl$loadarg(a,(i64)1,(i64)0);
        mc_blockmcl$loadarg(b,(i64)2,(i64)0);
    }
    else if (!!((i64)(*a).simple)) {
        mc_blockmcl$loadarg(b,(i64)2,(i64)0);
        mc_blockmcl$loadarg(a,(i64)1,(i64)0);
    }
    else {
        mm_support$gerror((byte*)"maths2/complex",0);
    }
;
    mc_blockmcl$do_callext(mc_libmcl$genextname(opname));
    mc_libmcl$popregs((u64)regs,0);
    return mc_libmcl$getretopnd((i64)(*a).mode);
}

static void mc_blockmcl$do_callext(struct mc_decls$opndrec *px) {
        i64 pushedbytes;
    pushedbytes = (i64)0;
    if (!!(mc_decls$mstackdepth)) {
        pushedbytes = (!!(msysc$m_getdotindex(mc_decls$mstackdepth,(i64)0)) ? (i64)40 : (i64)32);
        mc_libmcl$pushstack(pushedbytes);
    }
;
    mc_libmcl$genmc((i64)23,px,0);
    mc_libmcl$popstack(pushedbytes);
}

static struct mc_decls$opndrec *mc_blockmcl$do_storedotindex(struct mm_decls$unitrec *a,struct mm_decls$unitrec *rhs,i64 resflag) {
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mm_decls$unitrec *  pdot;
        struct mm_decls$unitrec *  poffset;
        i64 i;
        i64 x;
        i64 regs;
    pdot = (*a).a;
    poffset = (*a).b;
    regs = (i64)mc_decls$regset;
    if (!((!!((i64)(*a).simple) && !!((i64)(*rhs).simple)))) {
        mm_support$gerror((byte*)"a.[i]:= not simple",0);
    }
;
    if (((i64)(*poffset).tag != (i64)1)) {
        mm_support$gerror((byte*)"sdotix",0);
    }
;
    i = (*poffset).value;
    ax = mc_blockmcl$loadunit(pdot,(i64)0);
    mc_libmcl$genmc((i64)40,ax,mc_libmcl$genint(~(((i64)1 << i)),(i64)8));
    if (((i64)(*rhs).tag == (i64)1)) {
        x = (*rhs).value;
        if (!!(x)) {
            mc_libmcl$genmc((i64)41,ax,mc_libmcl$genint(((i64)1 << i),(i64)8));
        }
;
    }
    else {
        bx = mc_blockmcl$loadunit(rhs,(i64)0);
        if (!!(i)) {
            mc_libmcl$genmc((i64)45,bx,mc_libmcl$genint(i,(i64)8));
        }
;
        mc_libmcl$genmc((i64)41,ax,bx);
    }
;
    px = mc_blockmcl$evalunit(pdot,(i64)87);
    mc_libmcl$genmc((i64)13,px,mc_libmcl$changeopndsize(ax,(i64)msysc$m_getdotslice((i64)(*px).misc,(i64)0,(i64)3)));
    if (!!(resflag)) {
        mc_libmcl$popregs((u64)regs,ax);
        return ax;
    }
    else {
        mc_libmcl$popregs((u64)regs,0);
        return (struct mc_decls$opndrec *)0;
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$do_storedotslice(struct mm_decls$unitrec *a,struct mm_decls$unitrec *rhs,i64 resflag) {
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
        struct mc_decls$opndrec *  mx;
        struct mm_decls$unitrec *  pdot;
        struct mm_decls$unitrec *  pslice;
        i64 i;
        i64 j;
        i64 regs;
        u64 mask;
    pdot = (*a).a;
    pslice = (*a).b;
    regs = (i64)mc_decls$regset;
    if (!((!!((i64)(*a).simple) && !!((i64)(*rhs).simple)))) {
        mm_support$gerror((byte*)"a.[i..j]:= not simple",0);
    }
;
    if (!(((i64)(*(*pslice).a).tag==(i64)(*(*pslice).b).tag && (i64)(*(*pslice).b).tag==(i64)1))) {
        mm_support$gerror((byte*)"dotsl not const i..j",0);
    }
;
    i = (*(*pslice).a).value;
    j = (*(*pslice).b).value;
    ax = mc_blockmcl$loadunit(pdot,(i64)0);
    bx = mc_blockmcl$loadunit(rhs,(i64)0);
    mask = ~((~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i));
    mc_libmcl$genmc((i64)13,(mx = mc_libmcl$genreg((i64)0,(i64)8)),mc_libmcl$genint((i64)mask,(i64)8));
    if (!!(i)) {
        mc_libmcl$genmc((i64)45,bx,mc_libmcl$genint(i,(i64)8));
    }
;
    mc_libmcl$genmc((i64)40,ax,mx);
    mc_libmcl$genmc((i64)41,ax,bx);
    px = mc_blockmcl$evalunit(pdot,(i64)87);
    mc_libmcl$genmc((i64)13,px,mc_libmcl$changeopndsize(ax,(i64)msysc$m_getdotslice((i64)(*px).misc,(i64)0,(i64)3)));
    if (!!(resflag)) {
        mc_libmcl$popregs((u64)regs,ax);
        return ax;
    }
    else {
        mc_libmcl$popregs((u64)regs,0);
        return (struct mc_decls$opndrec *)0;
    }
;
}

static struct mc_decls$opndrec *mc_blockmcl$do_slice(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 reg) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  px;
        struct mc_decls$opndrec *  bx;
        struct mm_decls$unitrec *  ra;
        struct mm_decls$unitrec *  rb;
        struct mm_decls$strec *  d;
        i64 regs;
    regs = (i64)mc_decls$regset;
    ax = 0;
    if ((b == 0)) {
        mm_support$gerror((byte*)"WHOLE SLICE",0);
    }
    else {
        ra = (*b).a;
        rb = (*b).b;
        if (((i64)(*ra).tag==(i64)(*rb).tag && (i64)(*rb).tag==(i64)1)) {
            mc_libmcl$genmc((i64)13,(bx = mc_libmcl$genreg((i64)0,(i64)8)),mc_libmcl$genint((((*rb).value - (*ra).value) + (i64)1),(i64)8));
        }
        else {
            mc_blockmcl$loadbin(rb,ra,(i64)0,(i64)0,(i64)1);
            bx = mc_blockmcl$axb;
            ax = mc_blockmcl$bxb;
            mc_libmcl$genmc((i64)31,bx,ax);
            mc_libmcl$genmc((i64)54,bx,0);
        }
;
        if (!(!!((i64)(*a).simple))) {
            mm_support$gerror((byte*)"slice/complex",0);
        }
;
        px = mc_blockmcl$do_index(a,ra,(i64)0,(i64)0);
        mc_libmcl$genmc((i64)16,(ax = mc_libmcl$genreg((i64)0,(i64)8)),px);
        d = mc_genmcl$newblocktemp((i64)(*p).mode);
        mc_libmcl$genmc((i64)13,(px = mc_libmcl$genmem(d)),ax);
        mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(px,(i64)8,(i64)0),bx);
        mc_libmcl$popregs((u64)regs,0);
        if (!!((i64)(*p).resultflag)) {
            mc_libmcl$genmc((i64)16,(ax = mc_libmcl$genreg((i64)0,(i64)8)),mc_libmcl$genmem(d));
        }
        else {
            ax = 0;
        }
;
        mc_libmcl$popregs((u64)regs,ax);
    }
;
    return ax;
}

static void mc_blockmcl$do_assignms(struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 nlhs;
        i64 nrhs;
        i64 i;
        i64 regs;
        struct mm_decls$strec *  d;
        struct mc_decls$opndrec *  px;
    regs = (i64)mc_decls$regset;
    nlhs = (i64)(*a).length;
        {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)31)) {
        mc_blockmcl$loadunit(b,(i64)0);
        if (((i64)(*(*b).a).tag != (i64)4)) {
            mm_support$gerror((byte*)"multassign from fn: not simple fn",0);
        }
;
        d = (*(*b).a).def;
        nrhs = (i64)(*d).nretvalues;
        a = (*a).a;
    }
    else {
        if (((i64)mm_decls$ttbasetype[((i64)(*b).mode)] == (i64)11)) {
            mm_support$gerror((byte*)"DECONSTR SLICE NOT READY",0);
        }
        else {
            mm_support$gerror((byte*)"(a,b):=x; var only",0);
        }
;
    }
    };
    i = (i64)0;
    L177 :;
    while (!!(a)) {
        if (!(!!((i64)(*a).simple))) {
            mm_support$gerror((byte*)"ass/ms/complex",0);
        }
;
        ++(i);
        px = mc_blockmcl$evalunit(a,(i64)87);
        mc_blockmcl$storemem(px,mc_libmcl$genreg(mc_decls$multregs[(i)-1],(i64)8),(i64)(*a).mode,(i64)0);
L178 :;
        a = (*a).nextunit;
L180 :;
            }
L179 :;
    ;
    mc_libmcl$popregs((u64)regs,0);
}

// START
void mc_blockmcl$start(void) {

}

void mm_winx64$codegen(void) {
    mc_genmcl$codegen_mcl();
}

i64 mm_winx64$runlibfile(u8 *filename) {
        struct mx_decls$librec *  plib;
    mm_winx64$codegen();
    mc_genss$genss();
    plib = (struct mx_decls$librec *)mc_run$writememlib(filename);
    mx_lib$loadmemmcu((struct mx_decls$librec *)plib);
    mx_lib$fixuplib((struct mx_decls$librec *)plib);
    if (!!((i64)mm_decls$fshowmx)) {
        mm_support$loaderror((byte*)"SHOWMX missing",(byte*)"",(byte*)"");
    }
    else {
        mx_lib$runprogram((struct mx_decls$librec *)plib,mm_winx64$cmdskip);
    }
;
    return (i64)1;
}

i64 mm_winx64$writeexefile(u8 *filename,i64 gendll) {
        i64 tt;
    tt = clock();
    mm_winx64$codegen();
    if (!!((i64)mm_decls$fshowtiming)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"CODEGEN:",NULL);
        msysc$m_print_i64((clock() - tt),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    tt = clock();
    mc_genss$genss();
    if (!!((i64)mm_decls$fshowtiming)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"GENSS:",NULL);
        msysc$m_print_i64((clock() - tt),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    tt = clock();
    mc_writeexe$initsectiontable();
    mc_writeexe$genexe(0,filename,gendll);
    mc_writeexe$writeexe(filename,gendll);
    if (!!((i64)mm_decls$fshowtiming)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"WRITEEXE:",NULL);
        msysc$m_print_i64((clock() - tt),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    return (i64)1;
}

i64 mm_winx64$writelibfile(u8 *filename) {
    mm_winx64$codegen();
    mc_genss$genss();
    mc_write$writemcx(filename);
    return (i64)1;
}

i64 mm_winx64$writeasmfile(u8 *filename) {
        struct mlib$strbuffer *  asmstr;
    mm_winx64$codegen();
    asmstr = (struct mlib$strbuffer *)mc_libmcl$getmclstr();
    mm_lib$writegsfile(filename,(struct mlib$strbuffer *)asmstr);
    mlib$gs_free((struct mlib$strbuffer *)asmstr);
    return (i64)1;
}

// START
void mm_winx64$start(void) {

}

// START
void mm_decls$start(void) {

}

void mm_diags$printoverloads(void *f) {
        struct mm_decls$overloadrec *  p;
        i64 i;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"OVERLOADS",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=(i64)131;++i) {
L181 :;
        p = (struct mm_decls$overloadrec *)mm_decls$overloadtable[(i)];
        if (!!(p)) {
            L184 :;
            while (!!(p)) {
                if (!!((i64)(*p).bmode)) {
                    msysc$m_print_startfile(f);
                    msysc$m_print_setfmt((byte*)"operator (#)(#,#)#");
                    msysc$m_print_str((mm_tables$jtagnames[(i)] + (i64)2),NULL);
                    msysc$m_print_str(mm_lib$strmode((i64)(*p).amode,(i64)1),NULL);
                    msysc$m_print_str(mm_lib$strmode((i64)(*p).bmode,(i64)1),NULL);
                    msysc$m_print_str(mm_lib$strmode((i64)(*p).rmode,(i64)1),NULL);
                    msysc$m_print_end();
                    ;
                }
                else {
                    msysc$m_print_startfile(f);
                    msysc$m_print_setfmt((byte*)"operator (#)(#)#");
                    msysc$m_print_str((mm_tables$jtagnames[(i)] + (i64)2),NULL);
                    msysc$m_print_str(mm_lib$strmode((i64)(*p).amode,(i64)1),NULL);
                    msysc$m_print_str(mm_lib$strmode((i64)(*p).rmode,(i64)1),NULL);
                    msysc$m_print_end();
                    ;
                }
;
                if (!!((*p).fncode)) {
                    msysc$m_print_startfile(f);
                    msysc$m_print_str((byte*)"=",NULL);
                    msysc$m_print_ptr((*p).fncode,NULL);
                    msysc$m_print_str((*mm_lib$strexpr((struct mm_decls$unitrec *)(*p).fncode)).strptr,NULL);
                    msysc$m_print_end();
                    ;
                }
;
                msysc$m_print_startfile(f);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                p = (struct mm_decls$overloadrec *)(*p).nextoverload;
L185 :;
            }
L186 :;
            ;
            msysc$m_print_startfile(f);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
L182 :;
    }
L183 :;
    ;
}

void mm_diags$printst(void *f,struct mm_decls$strec *p,i64 level) {
        struct mm_decls$strec *  q;
    if (((i64)(*p).symbol != (i64)81)) {
        mm_support$mcerror((byte*)"PRINTST not name");
    }
;
    mm_diags$printstrec(f,(struct mm_decls$strec *)p,level);
    q = (struct mm_decls$strec *)(*p).deflist;
    L187 :;
    while ((q != 0)) {
        mm_diags$printst(f,(struct mm_decls$strec *)q,(level + (i64)1));
        q = (struct mm_decls$strec *)(*q).nextdef;
L188 :;
    }
L189 :;
    ;
}

static void mm_diags$printstrec(void *f,struct mm_decls$strec *p,i64 level) {
        struct mm_decls$strec dd;
        struct mlib$strbuffer v;
        struct mlib$strbuffer *  d;
        i64 col;
        i64 offset;
        u8 str[256];
        i64 $av_1;
    d = (struct mlib$strbuffer *)&v;
    mlib$gs_init((struct mlib$strbuffer *)d);
    msysc$m_print_startstr(str);
    msysc$m_print_ptr(p,NULL);
    msysc$m_print_end();
    ;
    mlib$gs_str((struct mlib$strbuffer *)d,str);
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" ");
    offset = (i64)0;
    $av_1 = level;
    while ($av_1-- > 0) {
L190 :;
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"    ");
        offset += (i64)4;
L191 :;
    }
L192 :;
    ;
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)":");
    mlib$gs_leftstr((struct mlib$strbuffer *)d,(*p).name,((i64)28 - offset),(i64)45);
    mlib$gs_leftstr((struct mlib$strbuffer *)d,mm_tables$namenames[((i64)(*p).nameid)],(i64)12,(i64)46);
    col = mlib$gs_getcol((struct mlib$strbuffer *)d);
    dd = (*p);
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"[");
    if (!!(msysc$m_getdotindex((i64)(*p).flags,(i64)12))) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Imp ");
    }
    else {
        mlib$gs_str((struct mlib$strbuffer *)d,((i64)(*p).scope==1?(byte*)"Sub ":((i64)(*p).scope==2?(byte*)"Prog ":((i64)(*p).scope==3?(byte*)"Exp ":(byte*)"Mod "))));
    }
;
    if (!!(msysc$m_getdotindex((i64)dd.flags,(i64)0))) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Stat");
    }
;
    if (!!((i64)dd.fflang)) {
        mlib$gs_strsp((struct mlib$strbuffer *)d,mm_tables$fflangnames[((i64)dd.fflang)]);
    }
;
    if ((((i64)dd.nameid == (i64)13) && !!((i64)dd.parammode))) {
        mlib$gs_str((struct mlib$strbuffer *)d,mm_tables$parammodenames[((i64)dd.parammode)]);
    }
;
    if (!!((i64)dd.align)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"@@");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)dd.align);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" maxalign:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)dd.maxalign);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" ");
    }
;
    if (!!((i64)dd.optional)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Opt ");
    }
;
    if (!!((i64)dd.varparams)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Var:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)dd.varparams);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" ");
    }
;
    if (!!((i64)dd.moduleno)) {
        if (((i64)dd.nameid != (i64)2)) {
            msysc$m_print_startstr(str);
            msysc$m_print_str((byte*)"Modno#",NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64((i64)dd.moduleno,NULL);
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startstr(str);
            msysc$m_print_str((byte*)"Subno#",NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64((i64)dd.subprogno,NULL);
            msysc$m_print_end();
            ;
        }
;
        mlib$gs_str((struct mlib$strbuffer *)d,(u8 *)str);
    }
;
    if (!!(msysc$m_getdotindex((i64)dd.flags,(i64)1))) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"U ");
    }
;
    if (!!((i64)dd.isthreaded)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Threaded ");
    }
;
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"]");
    mlib$gs_padto((struct mlib$strbuffer *)d,(col + (i64)10),(i64)61);
    if (!!((*p).owner)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"(#)");
        msysc$m_print_str((*(*p).owner).name,NULL);
        msysc$m_print_end();
        ;
        mlib$gs_leftstr((struct mlib$strbuffer *)d,(u8 *)str,(i64)18,(i64)45);
    }
    else {
        mlib$gs_leftstr((struct mlib$strbuffer *)d,(byte*)"()",(i64)18,(i64)45);
    }
;
        {i64 $temp = (i64)(*p).mode;
if (($temp==(i64)0)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Void ");
    }
    else {
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).mode);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)":");
        mlib$gs_str((struct mlib$strbuffer *)d,mm_lib$strmode((i64)(*p).mode,(i64)1));
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" ");
    }
    };
        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)14) || ($temp==(i64)13)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" Offset:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).offset);
        if (((i64)(*p).mode == (i64)26)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" Bitoffset:");
            mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).bitoffset);
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)":");
            mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).bitfieldwidth);
        }
;
        sprintf((u8 *)str,(byte*)"%.*s",(i64)(*p).uflags.ulength,&(*p).uflags.codes);
        msysc$m_print_startstr(str);
        msysc$m_print_i64((i64)(*p).uflags.ulength,(byte*)"v");
        msysc$m_print_str((u8 *)&(*p).uflags.codes,(byte*)".*");
        msysc$m_print_end();
        ;
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" UFLAGS:");
        mlib$gs_str((struct mlib$strbuffer *)d,(u8 *)str);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"-");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).uflags.ulength);
        if (!!((*p).code)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"/:=");
            mlib$gs_strvar((struct mlib$strbuffer *)d,(struct mlib$strbuffer *)mm_lib$strexpr((struct mm_decls$unitrec *)(*p).code));
        }
;
        if ((((i64)(*p).nameid == (i64)13) && !!((i64)(*p).variadic))) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"...");
        }
;
    }
    else if (($temp==(i64)15)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Index:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).offset);
    }
    else if (($temp==(i64)6) || ($temp==(i64)9)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Index:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).index);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" Nret:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).nretvalues);
    }
    else if (($temp==(i64)7)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Index/PCaddr:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).index);
        if (!!((*p).truename)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" Truename:");
            mlib$gs_str((struct mlib$strbuffer *)d,(*p).truename);
        }
;
    }
    else if (($temp==(i64)11)) {
        if (!!((*p).code)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"=");
            mlib$gs_strvar((struct mlib$strbuffer *)d,(struct mlib$strbuffer *)mm_lib$strexpr((struct mm_decls$unitrec *)(*p).code));
        }
;
    }
    else if (($temp==(i64)12)) {
        if (!!((*p).code)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)":=");
            mlib$gs_strvar((struct mlib$strbuffer *)d,(struct mlib$strbuffer *)mm_lib$strexpr((struct mm_decls$unitrec *)(*p).code));
        }
;
    }
    else if (($temp==(i64)10)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Const:");
        mlib$gs_strvar((struct mlib$strbuffer *)d,(struct mlib$strbuffer *)mm_lib$strexpr((struct mm_decls$unitrec *)(*p).code));
    }
    else if (($temp==(i64)5)) {
        if (!!((i64)(*p).baseclass)) {
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Baseclass:");
            mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"<HAS BASECLASS>");
        }
;
    }
    else if (($temp==(i64)16)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"Enum:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).index);
    }
    else if (($temp==(i64)4)) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)"DLL#:");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).dllindex);
    }
    };
    if (!!(msysc$m_getdotindex((i64)(*p).flags,(i64)9))) {
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" @");
        mlib$gs_str((struct mlib$strbuffer *)d,(*(*p).equivfield).name);
        mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" +");
        mlib$gs_strint((struct mlib$strbuffer *)d,(i64)(*p).equivoffset);
    }
;
    if (!!(msysc$m_getdotindex((i64)(*p).flags,(i64)10))) {
        mlib$gs_strvar((struct mlib$strbuffer *)d,(struct mlib$strbuffer *)mm_lib$strexpr((struct mm_decls$unitrec *)(*p).equivvar));
    }
;
    mlib$gs_str((struct mlib$strbuffer *)d,(byte*)" Lineno: ???");
    mlib$gs_println((struct mlib$strbuffer *)d,f);
        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)10) || ($temp==(i64)12) || ($temp==(i64)11) || ($temp==(i64)18)) {
        if (!!((*p).code)) {
            mm_diags$printunit((struct mm_decls$unitrec *)(*p).code,(i64)0,(byte*)"*",f);
        }
;
    }
    };
}

void mm_diags$printstflat(void *f) {
        i64 i;
        struct mm_decls$strec *  p;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"GLOBAL SYMBOL TABLE:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)0;i<=(i64)65534;++i) {
L193 :;
        p = (struct mm_decls$strec *)&mm_lex$hashtable[(i)];
        if (!!((*p).name)) {
                        {i64 $temp = (i64)(*p).symbol;
if (($temp==(i64)81)) {
                msysc$m_print_startfile(f);
                msysc$m_print_i64(i,NULL);
                msysc$m_print_ptr(p,NULL);
                msysc$m_print_str((byte*)":",NULL);
                msysc$m_print_str((*p).name,NULL);
                msysc$m_print_str(mm_tables$symbolnames[((i64)(*p).symbol)-1],NULL);
                msysc$m_print_str(mm_tables$namenames[((i64)(*p).nameid)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                p = (struct mm_decls$strec *)(*p).nextdupl;
                L196 :;
                while (!!(p)) {
                    msysc$m_print_startfile(f);
                    msysc$m_print_str((byte*)"\t",NULL);
                    msysc$m_print_ptr(p,NULL);
                    msysc$m_print_str((*p).name,NULL);
                    msysc$m_print_str(mm_tables$symbolnames[((i64)(*p).symbol)-1],NULL);
                    msysc$m_print_str(mm_tables$namenames[((i64)(*p).nameid)],NULL);
                    msysc$m_print_str((byte*)"(From",NULL);
                    msysc$m_print_str((!!((*p).owner) ? (*(*p).owner).name : (byte*)"-"),NULL);
                    msysc$m_print_nogap();
                    msysc$m_print_str((byte*)")",NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    p = (struct mm_decls$strec *)(*p).nextdupl;
L197 :;
                }
L198 :;
                ;
            }
            };
        }
;
L194 :;
    }
L195 :;
    ;
}

void mm_diags$printcode(void *f,u8 *caption) {
        struct mm_decls$strec *  p;
        struct mm_decls$procrec *  pp;
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L199 :;
    while (!!(pp)) {
        p = (struct mm_decls$strec *)(*pp).def;
        msysc$m_print_startfile(f);
        msysc$m_print_str((*p).name,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)"=",NULL);
        msysc$m_print_str(((i64)(*p).scope==1?(byte*)"Sub":((i64)(*p).scope==2?(byte*)"Prog":((i64)(*p).scope==3?(byte*)"Exp":(byte*)"Mod"))),NULL);
        msysc$m_print_end();
        ;
        if (((i64)(*(*p).owner).nameid == (i64)5)) {
            msysc$m_print_startfile(f);
            msysc$m_print_str((byte*)" in record",NULL);
            msysc$m_print_str((*(*p).owner).name,NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(f);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_diags$printunit((struct mm_decls$unitrec *)(*p).code,(i64)0,(byte*)"1",f);
        msysc$m_print_startfile(f);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L200 :;
    }
L201 :;
    ;
}

void mm_diags$printunit(struct mm_decls$unitrec *p,i64 level,u8 *prefix,void *dev) {
        struct mm_decls$strec *  d;
        i64 t;
        u8 *  idname;
        i64 a;
        r32 x32;
        static i64 cmpchain = (i64)0;
        u8 opndno[16];
        i64 $av_2;
        i64 i;
    if ((p == 0)) {
        return;
    }
;
    if (!!((i64)(*p).pos)) {
        mm_diags$currlineno = mm_support$getlineno((u64)(i64)(*p).pos);
        mm_diags$currfileno = (i64)msysc$m_getdotslice((i64)(*p).pos,(i64)24,(i64)31);
    }
;
    msysc$m_print_startfile(dev);
    msysc$m_print_ptr(p,NULL);
    msysc$m_print_str((byte*)":",NULL);
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str(mm_diags$getprefix(level,prefix,(struct mm_decls$unitrec *)p),NULL);
    msysc$m_print_end();
    ;
    idname = (mm_tables$jtagnames[((i64)(*p).tag)] + (i64)1);
    msysc$m_print_startfile(dev);
    msysc$m_print_str(idname,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":",NULL);
    msysc$m_print_end();
    ;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)4)) {
        d = (struct mm_decls$strec *)(*p).def;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_str(mm_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_end();
        ;
        if (!!((*d).code)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" {",NULL);
            msysc$m_print_nogap();
            msysc$m_print_str(mm_tables$jtagnames[((i64)(*(*d).code).tag)],NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)"}",NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(mm_lib$getdottedname((struct mm_decls$strec *)d),NULL);
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((!!((i64)(*p).dottedname) ? (byte*)" {Dotted}" : (byte*)""),NULL);
        msysc$m_print_end();
        ;
        if (!!((*p).c)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" Lastcall:",NULL);
            msysc$m_print_ptr((*p).c,NULL);
            msysc$m_print_end();
            ;
        }
;
        if (!!((i64)(*p).addroffirst)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" Addroffirst.",NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" Moduleno:",NULL);
        msysc$m_print_i64((i64)(*p).moduleno,NULL);
        msysc$m_print_end();
        ;
        if (!!((i64)(*p).avcode)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" AV:",NULL);
            msysc$m_print_c8((u64)(u8)(i64)(*p).avcode,NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"P.INDEX=",NULL);
        msysc$m_print_i64((i64)(*p).index,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)102)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*(*p).def).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)1) || ($temp==(i64)129)) {
        t = (i64)(*p).mode;
        a = (*p).value;
        if ((t == (i64)20)) {
            if (((i64)(*p).slength > (i64)256)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)"\"",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)"(LONGSTR)",NULL);
                msysc$m_print_str((byte*)"\" *",NULL);
                msysc$m_print_nogap();
                msysc$m_print_i64((i64)(*p).slength,NULL);
                msysc$m_print_end();
                ;
            }
            else if (!!((i64)(*p).slength)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)"\"",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((*p).svalue,NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)"\" *",NULL);
                msysc$m_print_nogap();
                msysc$m_print_i64((i64)(*p).slength,NULL);
                msysc$m_print_end();
                ;
            }
            else {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)"\"\"",NULL);
                msysc$m_print_end();
                ;
            }
;
        }
        else {
                        {i64 $temp = (i64)mm_decls$ttbasetype[(t)];
if (($temp==(i64)3) || ($temp==(i64)16) || ($temp==(i64)15) || ($temp==(i64)14)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_i64(a,NULL);
                msysc$m_print_end();
                ;
            }
            else if (($temp==(i64)2) || ($temp==(i64)19) || ($temp==(i64)18) || ($temp==(i64)17)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_u64((u64)a,NULL);
                msysc$m_print_end();
                ;
            }
            else if (($temp==(i64)1) || ($temp==(i64)12)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str(mlib$chr(a),NULL);
                msysc$m_print_end();
                ;
            }
            else if (($temp==(i64)4)) {
                x32 = (r32)(*p).xvalue;
                msysc$m_print_startfile(dev);
                msysc$m_print_r64((r64)x32,NULL);
                msysc$m_print_end();
                ;
            }
            else if (($temp==(i64)5)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_r64((*p).xvalue,NULL);
                msysc$m_print_end();
                ;
            }
            else if (($temp==(i64)7)) {
                if (!!((*p).value)) {
                    msysc$m_print_startfile(dev);
                    msysc$m_print_str((byte*)"#",NULL);
                    msysc$m_print_nogap();
                    msysc$m_print_i64((*p).value,NULL);
                    msysc$m_print_i64((i64)(*p).slength,NULL);
                    msysc$m_print_end();
                    ;
                }
                else {
                    msysc$m_print_startfile(dev);
                    msysc$m_print_str((byte*)"NIL",NULL);
                    msysc$m_print_end();
                    ;
                }
;
            }
            else if (($temp==(i64)6)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((!!((*p).value) ? (byte*)"True" : (byte*)"False"),NULL);
                msysc$m_print_end();
                ;
            }
            else {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"TYPENAME(T)=",NULL);
                msysc$m_print_str(mm_lib$typename(t),NULL);
                msysc$m_print_str(mm_lib$typename((i64)mm_decls$ttbasetype[(t)]),NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)"<PRINTUNIT BAD CONST PROBABLY VOID",NULL);
                msysc$m_print_end();
                ;
            }
            };
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(mm_lib$typename(t),NULL);
        msysc$m_print_end();
        ;
        if (!!((i64)(*p).isastring)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" <isstr>",NULL);
            msysc$m_print_end();
            ;
        }
;
        if (!!((i64)(*p).whenlabel)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" *L",NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64((i64)(*p).whenlabel,NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    else if (($temp==(i64)7)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((*p).svalue,NULL);
        msysc$m_print_str((byte*)"Len:",NULL);
        msysc$m_print_i64((i64)(*p).slength,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)56)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str(mm_lib$typename((i64)(*p).mode),NULL);
        msysc$m_print_str(mm_lib$typename((*p).value),NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)63)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((mm_tables$bitfieldnames[((i64)(*p).bfcode)-1] + (i64)3),NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)52) || ($temp==(i64)55)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" Convmode:",NULL);
        msysc$m_print_str(mm_lib$strmode((i64)(*p).convmode,(i64)1),NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)18)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"Len:",NULL);
        msysc$m_print_i64((i64)(*p).length,NULL);
        msysc$m_print_str((byte*)" Makeax:",NULL);
        msysc$m_print_i64((i64)(*p).makearray,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)46)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"Offset:",NULL);
        msysc$m_print_i64((i64)(*p).offset,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)44) || ($temp==(i64)49)) {
    }
    else if (($temp==(i64)105) || ($temp==(i64)103) || ($temp==(i64)104)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)"#",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64((i64)(*p).index,NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)92)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((mm_tables$sysfnnames[((i64)(*p).fnindex)-1] + (i64)3),NULL);
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)8)) {
    }
    else if (($temp==(i64)10)) {
    }
    else if (($temp==(i64)11)) {
    }
    else if (($temp==(i64)12)) {
    }
    else if (($temp==(i64)20)) {
    }
    else if (($temp==(i64)33)) {
        for (i=(i64)1;i<=(i64)4;++i) {
L202 :;
            if (((i64)(*p).cmpgenop[(i)-1] == (i64)0)) {
                goto L204 ;
            }
;
            msysc$m_print_startfile(dev);
            msysc$m_print_str(mm_tables$pclnames[((i64)(*p).cmpgenop[(i)-1])],NULL);
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)" ",NULL);
            msysc$m_print_end();
            ;
L203 :;
        }
L204 :;
        ;
    }
    };
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)4) || ($temp==(i64)49) || ($temp==(i64)44) || ($temp==(i64)46) || ($temp==(i64)90) || ($temp==(i64)31) || ($temp==(i64)26)) {
        if (((i64)(*p).memmode == (i64)0)) {
        }
        else {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" WIDEN FROM:",NULL);
            msysc$m_print_str(mm_lib$strmode((i64)(*p).memmode,(i64)1),NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    };
    if (!!((i64)(*p).isconst)) {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" Is const",NULL);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startfile(dev);
        msysc$m_print_str((byte*)" Not const",NULL);
        msysc$m_print_end();
        ;
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)34) || ($temp==(i64)36) || ($temp==(i64)35) || ($temp==(i64)37) || ($temp==(i64)32) || ($temp==(i64)38) || ($temp==(i64)52) || ($temp==(i64)14) || ($temp==(i64)15) || ($temp==(i64)16) || ($temp==(i64)17)) {
        if (!!((i64)(*p).pclop)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_setfmt((byte*)" Pcl<#>");
            msysc$m_print_str(mm_tables$pclnames[((i64)(*p).pclop)],NULL);
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startfile(dev);
            msysc$m_print_setfmt((byte*)" no-op");
            msysc$m_print_end();
            ;
        }
;
    }
    };
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
        ($av_2 = (i64)mm_tables$jsubs[((i64)(*p).tag)]);
    for (i=(i64)1;i<=$av_2;++i) {
L205 :;
        strcpy(opndno,msysc$strint(i,0));
        mm_diags$printunitlist(dev,(struct mm_decls$unitrec *)(*p).abc[(i)-1],(level + (i64)1),opndno);
L206 :;
    }
L207 :;
    ;
}

static void mm_diags$printunitlist(void *dev,struct mm_decls$unitrec *p,i64 level,u8 *prefix) {
    if ((p == 0)) {
        return;
    }
;
    L208 :;
    while (!!(p)) {
        mm_diags$printunit((struct mm_decls$unitrec *)p,level,prefix,dev);
        p = (struct mm_decls$unitrec *)(*p).nextunit;
L209 :;
    }
L210 :;
    ;
}

static u8 *mm_diags$getprefix(i64 level,u8 *prefix,struct mm_decls$unitrec *p) {
        static u8 str[1024];
        u8 indentstr[1024];
        u8 modestr[16384];
        u8 *  isexpr;
        i64 $av_1;
    indentstr[((i64)1)-1] = (u64)0u;
    if ((level > (i64)10)) {
        level = (i64)10;
    }
;
    $av_1 = level;
    while ($av_1-- > 0) {
L211 :;
        strcat((u8 *)indentstr,(byte*)"- ");
L212 :;
    }
L213 :;
    ;
    isexpr = (byte*)"-";
    if (!!((i64)mm_tables$jisexpr[((i64)(*p).tag)])) {
        isexpr = (byte*)"x";
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)94) || ($temp==(i64)109) || ($temp==(i64)107) || ($temp==(i64)112)) {
        if (((i64)(*p).mode == (i64)0)) {
            isexpr = (byte*)"x";
        }
;
    }
    };
    msysc$m_print_startstr(modestr);
    msysc$m_print_setfmt((byte*)"#<#> #:#");
    msysc$m_print_str(isexpr,NULL);
    msysc$m_print_str((!!((i64)(*p).simple) ? (byte*)"S" : (byte*)"-"),NULL);
    msysc$m_print_str((!!((i64)(*p).resultflag) ? (byte*)"RES" : (byte*)"---"),NULL);
    msysc$m_print_str(mm_lib$strmode((i64)(*p).mode,(i64)1),NULL);
    msysc$m_print_end();
    ;
    modestr[((i64)256)-1] = (u64)0u;
    strcat((u8 *)modestr,(byte*)"-----------------------------");
    modestr[((i64)17)-1] = ' ';
    modestr[((i64)18)-1] = (u64)0u;
    strcpy((u8 *)str,mm_diags$getlineinfok());
    strcat((u8 *)str,(u8 *)modestr);
    strcat((u8 *)str,(u8 *)indentstr);
    strcat((u8 *)str,prefix);
    if (!!((u64)(*prefix))) {
        strcat((u8 *)str,(byte*)" ");
    }
;
    return (u8 *)str;
}

static u8 *mm_diags$getlineinfok(void) {
        static u8 str[40];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"# # ");
    msysc$m_print_i64(mm_diags$currfileno,(byte*)"Z2");
    msysc$m_print_i64(mm_diags$currlineno,(byte*)"z4");
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

void mm_diags$printmodelist(void *f) {
        i64 mbase;
        static u8 *  tab = (byte*)"\t";
        i64 $av_1;
        i64 i;
        i64 m;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"NTYPENAMES=",NULL);
    msysc$m_print_i64(mm_decls$ntypenames,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=mm_decls$ntypenames;++i) {
L214 :;
        msysc$m_print_startfile(f);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((*mm_decls$typenames[(i)].def).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L215 :;
    }
L216 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"MODELIST",NULL);
    msysc$m_print_i64(mm_decls$ntypes,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (m=(i64)0;m<=mm_decls$ntypes;++m) {
L217 :;
        msysc$m_print_startfile(f);
        msysc$m_print_i64(m,(byte*)"4");
        msysc$m_print_str(mm_lib$strmode(m,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mbase = (i64)mm_decls$ttbasetype[(m)];
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Basetype:",NULL);
        msysc$m_print_i64(mbase,NULL);
        msysc$m_print_str(mm_lib$strmode(mbase,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"ttname:",NULL);
        msysc$m_print_str(mm_decls$ttname[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"ttnamedef:",NULL);
        msysc$m_print_ptr(mm_decls$ttnamedef[(m)],NULL);
        msysc$m_print_str((!!(mm_decls$ttnamedef[(m)]) ? (*mm_decls$ttnamedef[(m)]).name : (byte*)"-"),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Target:",NULL);
        msysc$m_print_str(mm_lib$strmode((i64)mm_decls$tttarget[(m)],(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Size:",NULL);
        msysc$m_print_i64((i64)mm_decls$ttsize[(m)],NULL);
        msysc$m_print_str((byte*)"Sizeset",NULL);
        msysc$m_print_i64((i64)mm_decls$ttsizeset[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"# Bounds: #..#  Length:#");
        msysc$m_print_str(tab,NULL);
        msysc$m_print_i64((i64)mm_decls$ttlower[(m)],NULL);
        msysc$m_print_i64((((i64)mm_decls$ttlower[(m)] + (i64)mm_decls$ttlength[(m)]) - (i64)1),NULL);
        msysc$m_print_i64((i64)mm_decls$ttlength[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        if ((mbase == (i64)27)) {
            msysc$m_print_startfile(f);
            msysc$m_print_str(tab,NULL);
            msysc$m_print_str((byte*)"Mult:",NULL);
            msysc$m_print_end();
            ;
                        ($av_1 = (i64)mm_decls$ttlength[(m)]);
            for (i=(i64)1;i<=$av_1;++i) {
L220 :;
                msysc$m_print_startfile(f);
                msysc$m_print_str(mm_lib$strmode((i64)(*mm_decls$ttmult[(m)])[(i)-1],(i64)1),NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)" ",NULL);
                msysc$m_print_end();
                ;
L221 :;
            }
L222 :;
            ;
            msysc$m_print_startfile(f);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Signed:",NULL);
        msysc$m_print_i64((i64)mm_decls$ttsigned[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Isreal:",NULL);
        msysc$m_print_i64((i64)mm_decls$ttisreal[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Isinteger:",NULL);
        msysc$m_print_i64((i64)mm_decls$ttisinteger[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Isshort:",NULL);
        msysc$m_print_i64((i64)mm_decls$ttisshort[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Isref:",NULL);
        msysc$m_print_i64((i64)mm_decls$ttisref[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Isblock:",NULL);
        msysc$m_print_i64((i64)mm_decls$ttisblock[(m)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str((byte*)"Cat:",NULL);
        msysc$m_print_str(mm_tables$catnames[((i64)mm_decls$ttcat[(m)])],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startfile(f);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L218 :;
    }
L219 :;
    ;
}

void mm_diags$showprojectinfo(void *dev) {
        struct mm_decls$modulerec *  pm;
        struct mm_decls$subprogrec *  ps;
        static u8 *  tab = (byte*)"    ";
        i64 i;
        i64 j;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"Project Structure:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"---------------------------------------",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"Modules",NULL);
    msysc$m_print_i64(mm_decls$nmodules,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=mm_decls$nmodules;++i) {
L223 :;
        pm = &mm_decls$moduletable[(i)];
        if (((i > (i64)1) && ((i64)(*pm).subprogno != (i64)mm_decls$moduletable[((i - (i64)1))].subprogno))) {
            msysc$m_print_startfile(dev);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_i64(i,(byte*)"2");
        msysc$m_print_nogap();
        msysc$m_print_str((((i64)mm_decls$subprogtable[((i64)mm_decls$moduletosub[(i)])].firstmodule == i) ? (byte*)"*" : (byte*)" "),NULL);
        msysc$m_print_str((*pm).name,(byte*)"16jl");
        msysc$m_print_str((byte*)"Sys:",NULL);
        msysc$m_print_i64((i64)(*pm).issyslib,NULL);
        msysc$m_print_str((byte*)"Path:",NULL);
        msysc$m_print_str((*pm).path,NULL);
        msysc$m_print_str((byte*)"Sub:",NULL);
        msysc$m_print_str(mm_decls$subprogtable[((i64)(*pm).subprogno)].name,NULL);
        msysc$m_print_str((byte*)"Fileno:",NULL);
        msysc$m_print_i64((i64)(*pm).fileno,NULL);
        msysc$m_print_end();
        ;
        if (!!((*pm).stmacro)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str((byte*)" Alias:",NULL);
            msysc$m_print_str((*(*pm).stmacro).name,NULL);
            msysc$m_print_end();
            ;
        }
;
        if (!!((*pm).stmain)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_space();
            msysc$m_print_str((*(*pm).stmain).name,NULL);
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_str(mm_tables$scopenames[((i64)(*(*pm).stmain).scope)],NULL);
            msysc$m_print_ptr((*pm).stmain,NULL);
            msysc$m_print_end();
            ;
        }
;
        if (!!((*pm).ststart)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_space();
            msysc$m_print_str((*(*pm).ststart).name,NULL);
            msysc$m_print_str((byte*)":",NULL);
            msysc$m_print_str(mm_tables$scopenames[((i64)(*(*pm).ststart).scope)],NULL);
            msysc$m_print_ptr((*pm).ststart,NULL);
            msysc$m_print_end();
            ;
        }
;
        msysc$m_print_startfile(dev);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L224 :;
    }
L225 :;
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"Subprograms",NULL);
    msysc$m_print_i64(mm_decls$nsubprogs,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=mm_decls$nsubprogs;++i) {
L226 :;
        ps = &mm_decls$subprogtable[(i)];
        msysc$m_print_startfile(dev);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((*ps).name,NULL);
        msysc$m_print_str((byte*)"Sys:",NULL);
        msysc$m_print_i64((*ps).issyslib,NULL);
        msysc$m_print_str((byte*)"Path:",NULL);
        msysc$m_print_str((*ps).path,NULL);
        msysc$m_print_str((byte*)"Fileno:",NULL);
        msysc$m_print_i64((*ps).fileno,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        if (!!((i64)(*ps).firstmodule)) {
            msysc$m_print_startfile(dev);
            msysc$m_print_str(tab,NULL);
            msysc$m_print_str(tab,NULL);
            msysc$m_print_end();
            ;
            for (j=(i64)1;j<=mm_decls$nmodules;++j) {
L229 :;
                if (((i64)mm_decls$moduletable[(j)].subprogno == i)) {
                    msysc$m_print_startfile(dev);
                    msysc$m_print_space();
                    msysc$m_print_str(mm_decls$moduletable[(j)].name,NULL);
                    msysc$m_print_end();
                    ;
                    if (((i64)(*ps).firstmodule == j)) {
                        msysc$m_print_startfile(dev);
                        msysc$m_print_str((byte*)"*",NULL);
                        msysc$m_print_end();
                        ;
                    }
;
                }
;
L230 :;
            }
L231 :;
            ;
            msysc$m_print_startfile(dev);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
L227 :;
    }
L228 :;
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_str((byte*)"Link files",NULL);
    msysc$m_print_i64(mm_decls$nlibfiles,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L232 :;
        msysc$m_print_startfile(dev);
        msysc$m_print_str(tab,NULL);
        msysc$m_print_str(mm_decls$libfiles[(i)],(byte*)"16jl");
        msysc$m_print_str((((i64)mm_decls$libtypes[(i)] == (i64)68) ? (byte*)"DLL" : (byte*)"LIB"),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L233 :;
    }
L234 :;
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void mm_diags$showlogfile(void) {
        u8 str[256];
        void *  logdev;
        i64 size;
    if (!(!!(mm_decls$debugmode))) {
        return;
    }
;
    logdev = fopen((byte*)"mx.log",(byte*)"w");
    if (!!((i64)mm_decls$fshowmodules)) {
        mm_diags$showprojectinfo(logdev);
    }
;
    if ((!!((i64)mm_decls$fshowasm) && (mm_decls$passlevel >= (i64)8))) {
        msysc$m_print_startfile(logdev);
        msysc$m_print_str((byte*)"PROC",NULL);
        msysc$m_print_str((byte*)"ASSEMBLY",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_lib$addtolog(mm_decls$asmfilename,logdev);
    }
;
    if ((!!((i64)mm_decls$fshowpcl) && (mm_decls$passlevel >= (i64)7))) {
        msysc$m_print_startfile(logdev);
        msysc$m_print_str((byte*)"PROC PCL",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_lib$addtolog(mm_decls$pclfilename,logdev);
    }
;
    if ((!!((i64)mm_decls$fshowast3) && (mm_decls$passlevel >= (i64)6))) {
        mm_lib$addtolog((byte*)"AST3",logdev);
    }
;
    if ((!!((i64)mm_decls$fshowast2) && (mm_decls$passlevel >= (i64)5))) {
        mm_lib$addtolog((byte*)"AST2",logdev);
    }
;
    if ((!!((i64)mm_decls$fshowast1) && (mm_decls$passlevel >= (i64)3))) {
        mm_lib$addtolog((byte*)"AST1",logdev);
    }
;
    if (!!((i64)mm_decls$fshowst)) {
        mm_diags$showsttree((byte*)"SYMBOL TABLE",logdev);
    }
;
    if (!!((i64)mm_decls$fshowstflat)) {
        mm_diags$showstflat((byte*)"FLAT SYMBOL TABLE",logdev);
    }
;
    if (!!((i64)mm_decls$fshowtypes)) {
        mm_diags$printmodelist(logdev);
    }
;
    if (!!((i64)mm_decls$fshowoverloads)) {
        mm_diags$printoverloads(logdev);
    }
;
    size = mlib$getfilesize(logdev);
    fclose(logdev);
    if (!!(size)) {
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"c:\\m\\ed.bat -w ",NULL);
        msysc$m_print_str((byte*)"mx.log",NULL);
        msysc$m_print_end();
        ;
        if (!!(mlib$checkfile((byte*)"mm.m"))) {
            mlinux$os_execwait((u8 *)str,(i64)1,0);
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Diagnostic outputs written to",NULL);
            msysc$m_print_str((byte*)"mx.log",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
    }
;
}

static void mm_diags$showstflat(u8 *caption,void *f) {
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"PROC",NULL);
    msysc$m_print_str(caption,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_diags$printstflat(f);
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void mm_diags$showsttree(u8 *caption,void *f) {
        struct mm_decls$procrec *  pp;
        struct mm_decls$strec *  d;
        i64 i;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"PROC",NULL);
    msysc$m_print_str(caption,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_diags$printst(f,(struct mm_decls$strec *)mm_decls$stprogram,(i64)0);
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"Proc List:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L235 :;
    while (!!(pp)) {
        d = (*pp).def;
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"#\t#.# (#) Mod:");
        msysc$m_print_ptr(d,NULL);
        msysc$m_print_str((*(*d).owner).name,NULL);
        msysc$m_print_str((*d).name,(byte*)"20jl");
        msysc$m_print_str(mm_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_i64((i64)(*d).moduleno,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L236 :;
    }
L237 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"End\n",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"DLL Proc List:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=mm_decls$ndllproctable;++i) {
L238 :;
        d = mm_decls$dllproctable[(i)-1];
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"#\t#.# (#) Mod: # # #");
        msysc$m_print_ptr(d,NULL);
        msysc$m_print_str((*(*d).owner).name,NULL);
        msysc$m_print_str((*d).name,(byte*)"20jl");
        msysc$m_print_str(mm_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_i64((i64)(*d).moduleno,NULL);
        msysc$m_print_str(mm_decls$libfiles[((i64)(*d).dllindex)],NULL);
        msysc$m_print_i64((i64)mm_decls$libtypes[((i64)(*d).dllindex)],(byte*)"c");
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L239 :;
    }
L240 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"End\n",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void mm_diags$showast(u8 *filename) {
        void *  f;
    f = fopen(filename,(byte*)"w");
    if (!(!!(f))) {
        return;
    }
;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"PROC",NULL);
    msysc$m_print_str(filename,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_diags$printcode(f,(byte*)"");
    msysc$m_print_startfile(f);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    fclose(f);
}

void mm_diags$printsymbol(struct mm_decls$tokenrec *lp) {
        struct mm_decls$tokenrec l;
    l = (*lp);
    printf((byte*)"%-18s",mm_tables$symbolnames[((i64)l.symbol)-1]);
    switch ((i64)l.symbol) {
    case 81:;
        {
            mm_lex$printstrn((*l.symptr).name,(i64)(*l.symptr).namelen);
            if (!!((i64)l.subcode)) {
                msysc$m_print_startcon();
                msysc$m_print_setfmt((byte*)" [#]");
                msysc$m_print_str(mm_tables$symbolnames[((i64)l.subcode)-1],NULL);
                msysc$m_print_end();
                ;
            }
;
        }
        break;
    case 72:;
        {
                        {i64 $temp = (i64)l.subcode;
if (($temp==(i64)3)) {
                msysc$m_print_startcon();
                msysc$m_print_i64(l.value,NULL);
                msysc$m_print_str((byte*)"int",NULL);
                msysc$m_print_end();
                ;
            }
            else if (($temp==(i64)2)) {
                msysc$m_print_startcon();
                msysc$m_print_u64(l.uvalue,NULL);
                msysc$m_print_str((byte*)"word",NULL);
                msysc$m_print_end();
                ;
            }
            else {
                msysc$m_print_startcon();
                msysc$m_print_i64(l.value,NULL);
                msysc$m_print_end();
                ;
            }
            };
        }
        break;
    case 74:;
        {
            msysc$m_print_startcon();
            msysc$m_print_r64(l.xvalue,NULL);
            msysc$m_print_end();
            ;
        }
        break;
    case 77:;
        {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"\"",NULL);
            msysc$m_print_end();
            ;
            msysc$printstr(l.svalue);
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"\"",NULL);
            msysc$m_print_i64(strlen(l.svalue),NULL);
            msysc$m_print_end();
            ;
        }
        break;
    case 75:;
        {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"'",NULL);
            msysc$m_print_end();
            ;
            msysc$printstr(l.svalue);
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"'",NULL);
            msysc$m_print_end();
            ;
        }
        break;
    case 73:;
        {
            msysc$printstr(l.svalue);
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"L",NULL);
            msysc$m_print_end();
            ;
        }
        break;
    case 9:;
    case 25:;
    case 19:;
    case 10:;
    case 28:;
    case 45:;
    case 46:;
    case 48:;
    case 49:;
    case 31:;
    case 32:;
    case 33:;
    case 34:;
    case 35:;
    case 36:;
    case 38:;
    case 39:;
    case 40:;
    case 41:;
    case 42:;
    case 43:;
    case 44:;
    case 50:;
    case 51:;
        {
            msysc$m_print_startcon();
            msysc$m_print_str(mm_tables$symbolnames[((i64)l.symbol)-1],NULL);
            msysc$m_print_end();
            ;
        }
        break;
    default: {
        if (!!((i64)l.subcode)) {
            msysc$m_print_startcon();
            msysc$m_print_setfmt((byte*)"SUBCODE:");
            msysc$m_print_i64((i64)l.subcode,NULL);
            msysc$m_print_end();
            ;
        }
;
    }
    } //SW
;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

// START
void mm_diags$start(void) {

}

void mm_export$writeexports(u8 *outfile,u8 *modulename) {
        struct mm_decls$strec *  d;
        struct mm_decls$procrec *  pp;
        void *  f;
        i64 i;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Writing exports file to",NULL);
    msysc$m_print_str(outfile,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$gs_init((struct mlib$strbuffer *)mm_export$dest);
    mm_export$wxstr((byte*)"importlib ");
    mm_export$wxstr(modulename);
    mm_export$wxstrln((byte*)" =");
    for (i=(i64)29;i<=mm_decls$ntypes;++i) {
L241 :;
        d = (struct mm_decls$strec *)mm_decls$ttnamedef[(i)];
        if ((((i64)(*d).scope == (i64)3) && ((u64)(*(*d).name) != '$'))) {
                        {i64 $temp = (i64)mm_decls$ttbasetype[(i)];
if (($temp==(i64)8)) {
                mm_export$exportrecord((struct mm_decls$strec *)d);
            }
            else {
                mm_export$wxstr((byte*)"    type ");
                mm_export$wxstr((*d).name);
                mm_export$wxstr((byte*)" = ");
                mm_export$wxstr(mm_lib$strmode((i64)(*d).mode,(i64)0));
                mm_export$wxline();
            }
            };
        }
;
L242 :;
    }
L243 :;
    ;
    pp = (struct mm_decls$procrec *)mm_decls$staticlist;
    L244 :;
    while (!!(pp)) {
        d = (struct mm_decls$strec *)(*pp).def;
        if (((i64)(*d).scope == (i64)3)) {
            mm_export$exportstatic((struct mm_decls$strec *)d);
        }
;
L245 :;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L247 :;
            }
L246 :;
    ;
    if (!!(mm_decls$staticlist)) {
        mm_export$wxline();
    }
;
    pp = (struct mm_decls$procrec *)mm_decls$constlist;
    L248 :;
    while (!!(pp)) {
        d = (struct mm_decls$strec *)(*pp).def;
        if (((i64)(*d).scope == (i64)3)) {
            mm_export$exportconst((struct mm_decls$strec *)d);
        }
;
L249 :;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L251 :;
            }
L250 :;
    ;
    if (!!(mm_decls$constlist)) {
        mm_export$wxline();
    }
;
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L252 :;
    while (!!(pp)) {
        d = (struct mm_decls$strec *)(*pp).def;
        if (((i64)(*d).scope == (i64)3)) {
            mm_export$exportproc((struct mm_decls$strec *)d);
        }
;
L253 :;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L255 :;
            }
L254 :;
    ;
    mm_export$wxstrln((byte*)"end importlib");
    f = fopen(outfile,(byte*)"wb");
    mlib$gs_println((struct mlib$strbuffer *)mm_export$dest,f);
    fclose(f);
}

static void mm_export$exportstatic(struct mm_decls$strec *d) {
    mm_export$wxstr((byte*)"    var ");
    mm_export$wxmode((i64)(*d).mode);
    mm_export$wxstr((byte*)" ");
    mm_export$wxstr((*d).name);
    mm_export$wxline();
}

static void mm_export$exportconst(struct mm_decls$strec *d) {
    mm_export$wxstr((byte*)"    const ");
    mm_export$wxmode((i64)(*d).mode);
    mm_export$wxstr((byte*)" ");
    mm_export$wxstr((*d).name);
    mm_export$wxstr((byte*)" = ");
    mm_lib$jevalx((struct mlib$strbuffer *)mm_export$dest,(struct mm_decls$unitrec *)(*d).code);
    mm_export$wxline();
}

static void mm_export$exportproc(struct mm_decls$strec *d) {
        struct mm_decls$strec *  e;
        i64 currmode;
        i64 needcomma;
    mm_export$wxstr((byte*)"    mlang ");
    mm_export$wxstr((((i64)(*d).mode == (i64)0) ? (byte*)"proc     " : (byte*)"function "));
    mm_export$wxstr((*d).name);
    mm_export$wxstr((byte*)"(");
    e = (struct mm_decls$strec *)(*d).deflist;
    needcomma = (i64)0;
    currmode = (i64)0;
    L256 :;
    while (!!(e)) {
        if (((i64)(*e).nameid == (i64)13)) {
            if (!!(needcomma)) {
                mm_export$wxstr((byte*)",");
            }
;
            if (((i64)(*e).parammode != (i64)2)) {
                if (((i64)(*e).mode != currmode)) {
                    mm_export$wxmode((i64)(*e).mode);
                    mm_export$wxstr((byte*)" ");
                    currmode = (i64)(*e).mode;
                }
;
            }
            else {
                mm_export$wxmode((i64)mm_decls$tttarget[((i64)(*e).mode)]);
                mm_export$wxstr((byte*)" &");
                currmode = (i64)0;
            }
;
            mm_export$wxstr((*e).name);
            if (!!((*e).code)) {
                mm_export$wxstr((byte*)"=");
                if (((!!((i64)mm_decls$ttisref[((i64)(*e).mode)]) && ((i64)(*(*e).code).tag == (i64)1)) && ((*(*e).code).value == (i64)0))) {
                    mm_export$wxstr((byte*)"nil");
                }
                else {
                    mm_lib$jevalx((struct mlib$strbuffer *)mm_export$dest,(struct mm_decls$unitrec *)(*e).code);
                }
;
            }
;
            needcomma = (i64)1;
        }
;
        e = (struct mm_decls$strec *)(*e).nextdef;
L257 :;
    }
L258 :;
    ;
    mm_export$wxstr((byte*)")");
    if (!!((i64)(*d).mode)) {
        mm_export$wxstr((byte*)" => ");
        mm_export$wxmode((i64)(*d).mode);
    }
;
    mm_export$wxline();
}

static void mm_export$wxstr(u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)mm_export$dest,s);
}

static void mm_export$wxstrln(u8 *s) {
    mlib$gs_strln((struct mlib$strbuffer *)mm_export$dest,s);
}

static void mm_export$wxline(void) {
    mlib$gs_line((struct mlib$strbuffer *)mm_export$dest);
}

static void mm_export$exportrecord(struct mm_decls$strec *d) {
        struct mm_decls$strec *  e;
        u8 *  flags;
        i64 flag;
        i64 indent;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
    e = (struct mm_decls$strec *)(*d).deflist;
    mm_export$wxstr((byte*)"    record ");
    mm_export$wxstr((*d).name);
    mm_export$wxstr((byte*)" = ");
    mm_export$wxline();
    indent = (i64)2;
    L259 :;
    while (!!(e)) {
        if (((i64)(*e).nameid == (i64)14)) {
            flags = (u8 *)&(*e).uflags;
            L262 :;
                        {u64 $temp = (u64)(*flags);
if (($temp=='S')) {
                $av_1 = indent;
                while ($av_1-- > 0) {
L264 :;
                    mm_export$wxstr((byte*)"    ");
L265 :;
                }
L266 :;
                ;
                mm_export$wxstrln((byte*)"struct");
                ++(indent);
                ++(flags);
            }
            else if (($temp=='U')) {
                $av_2 = indent;
                while ($av_2-- > 0) {
L267 :;
                    mm_export$wxstr((byte*)"    ");
L268 :;
                }
L269 :;
                ;
                mm_export$wxstrln((byte*)"union");
                ++(indent);
                ++(flags);
            }
            else {
                goto L263 ;
            }
            }goto L262 ;
L263 :;
            ;
            $av_3 = indent;
            while ($av_3-- > 0) {
L270 :;
                mm_export$wxstr((byte*)"    ");
L271 :;
            }
L272 :;
            ;
            mm_export$wxmode((i64)(*e).mode);
            mm_export$wxstr((byte*)" ");
            mm_export$wxstrln((*e).name);
            L273 :;
            while (1) {
                flag = (i64)(u64)(*(flags)++);
                if ((flag==(i64)42)) {
                }
                else if ((flag==(i64)69)) {
                    --(indent);
                    $av_4 = indent;
                    while ($av_4-- > 0) {
L275 :;
                        mm_export$wxstr((byte*)"    ");
L276 :;
                    }
L277 :;
                    ;
                    mm_export$wxstrln((byte*)"end");
                }
                else {
                    goto L274 ;
                }
;
            }
L274 :;
            ;
        }
;
        e = (struct mm_decls$strec *)(*e).nextdef;
L260 :;
    }
L261 :;
    ;
    mm_export$wxstrln((byte*)"    end");
    mm_export$wxline();
}

static void mm_export$wxmode(i64 mode) {
        u8 *  name;
    if ((mode >= (i64)29)) {
        name = (*mm_decls$ttnamedef[(mode)]).name;
        if (((u64)(*name) != '$')) {
            mm_export$wxstr(name);
            return;
        }
;
    }
;
    mm_export$wxstr(mm_lib$strmode(mode,(i64)0));
}

// START
void mm_export$start(void) {

}

void mm_lex$lexreadtoken(void) {
        i64 c;
        i64 hsum;
        i64 commentseen;
        i64 length;
        u8 *  lxsvalue;
        struct mm_decls$strec *  d;
    mm_decls$nextlx.subcode = (i64)0;
    L278 :;
    switch ((mm_lex$lxstart = mm_lex$lxsptr, (i64)(u64)(*(mm_lex$lxsptr)++))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 95:;
    case 36:;
        {
            lxsvalue = (mm_lex$lxsptr - (i64)1);
            //doname:
L280 :;
;
            hsum = (i64)(u64)(*lxsvalue);
            if (((c = (i64)(u64)(*mm_lex$lxsptr)) == (i64)34)) {
                if ((hsum==(i64)70) || (hsum==(i64)102) || (hsum==(i64)82) || (hsum==(i64)114)) {
                    mm_lex$readrawstring();
                    return;
                }
                else if ((hsum==(i64)65) || (hsum==(i64)97) || (hsum==(i64)90) || (hsum==(i64)122)) {
                    mm_lex$readarraystring((i64)(u64)(*lxsvalue));
                    return;
                }
;
            }
            else if (!!((i64)mm_lex$alphamap[(c)])) {
                L281 :;
                                {i64 $temp = (i64)mm_lex$alphamap[((c = (i64)(u64)(*mm_lex$lxsptr)))];
if (($temp==(i64)1)) {
                    hsum = (((hsum << (i64)4) - hsum) + c);
                    ++(mm_lex$lxsptr);
                }
                else if (($temp==(i64)2)) {
                    (*mm_lex$lxsptr) = (u64)(c + (i64)32);
                    hsum = (((hsum << (i64)4) - hsum) + (c + (i64)32));
                    ++(mm_lex$lxsptr);
                }
                else {
                    goto L282 ;
                }
                }goto L281 ;
L282 :;
                ;
            }
            else {
                d = mm_lex$shortnames[((i64)(u64)(*lxsvalue))-97];
                if (!!(d)) {
                    mm_decls$nextlx.symptr = (struct mm_decls$strec *)d;
                    mm_decls$nextlx.symbol = (i64)(*d).symbol;
                    mm_decls$nextlx.subcode = (i64)(*d).subcode;
                    return;
                }
;
            }
;
            mm_lex$lookup(lxsvalue,(mm_lex$lxsptr - lxsvalue),((hsum << (i64)5) - hsum));
            return;
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
        {
            lxsvalue = (mm_lex$lxsptr - (i64)1);
            (*lxsvalue) += (u8)(i64)32;
            goto L280 ;
;
        }
        break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            mm_lex$lxstart = (mm_lex$lxsptr - (i64)1);
                        {u64 $temp = (u64)(*mm_lex$lxsptr);
if (($temp==')') || ($temp==(u64)13u) || ($temp==',') || ($temp==' ')) {
                mm_decls$nextlx.symbol = (i64)72;
                mm_decls$nextlx.subcode = (i64)3;
                mm_decls$nextlx.value = (i64)((u64)(*mm_lex$lxstart) - '0');
            }
            else if (($temp=='x') || ($temp=='X')) {
                                {u64 $temp = (u64)(*mm_lex$lxstart);
if (($temp=='0')) {
                    ++(mm_lex$lxsptr);
                    mm_lex$readhex();
                }
                else if (($temp=='2')) {
                    ++(mm_lex$lxsptr);
                    mm_lex$readbin();
                }
                else if (($temp=='8')) {
                    ++(mm_lex$lxsptr);
                    mm_lex$readoct();
                }
                else {
                    mm_support$lxerror((byte*)"Bad base");
                }
                };
            }
            else {
                --(mm_lex$lxsptr);
                mm_lex$readdec();
            }
            };
            return;
        }
        break;
    case 33:;
        {
            //docomment:
L283 :;
;
            L284 :;
            switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
            case 13:;
                {
                    ++(mm_lex$lxalllines);
                    ++(mm_lex$lxsptr);
                    goto L285 ;
                }
                break;
            case 10:;
                {
                    ++(mm_lex$lxalllines);
                    goto L285 ;
                }
                break;
            case 0:;
                {
                    --(mm_lex$lxsptr);
                    goto L285 ;
                }
                break;
            } //SW
goto L284 ;
L285 :;
            ;
            mm_decls$nextlx.symbol = (i64)67;
            return;
        }
        break;
    case 35:;
        {
            goto L283 ;
;
            ++(mm_lex$lxsptr);
            lxsvalue = mm_lex$lxsptr;
            L286 :;
            switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
            case 13:;
                {
                    ++(mm_lex$lxalllines);
                    ++(mm_lex$lxsptr);
                    goto L287 ;
                }
                break;
            case 10:;
                {
                    ++(mm_lex$lxalllines);
                    goto L287 ;
                }
                break;
            case 0:;
                {
                    --(mm_lex$lxsptr);
                    goto L287 ;
                }
                break;
            } //SW
goto L286 ;
L287 :;
            ;
            length = (mm_lex$lxsptr - lxsvalue);
            mm_decls$nextlx.symbol = (i64)70;
            mm_decls$nextlx.svalue = mlib$pcm_copyheapstringn(lxsvalue,length);
            return;
        }
        break;
    case 92:;
        {
            commentseen = (i64)0;
            L288 :;
            switch ((i64)(u64)(*(mm_lex$lxsptr)++)) {
            case 13:;
                {
                    ++(mm_lex$lxalllines);
                    ++(mm_lex$lxsptr);
                    goto L289 ;
                }
                break;
            case 10:;
                {
                    ++(mm_lex$lxalllines);
                    goto L289 ;
                }
                break;
            case 0:;
                {
                    mm_decls$nextlx.symbol = (i64)68;
                    --(mm_lex$lxsptr);
                    return;
                }
                break;
            case 32:;
            case 9:;
                {
                }
                break;
            case 33:;
                {
                    commentseen = (i64)1;
                }
                break;
            default: {
                if (!(!!(commentseen))) {
                    mm_support$lxerror((byte*)"\\ not followed by eol");
                }
;
            }
            } //SW
goto L288 ;
L289 :;
            ;
            L290 :;
            switch ((i64)(u64)(*(mm_lex$lxsptr)++)) {
            case 13:;
                {
                    ++(mm_lex$lxalllines);
                    ++(mm_lex$lxsptr);
                }
                break;
            case 10:;
                {
                    ++(mm_lex$lxalllines);
                }
                break;
            case 32:;
            case 9:;
                {
                }
                break;
            default: {
                --(mm_lex$lxsptr);
                goto L291 ;
            }
            } //SW
goto L290 ;
L291 :;
            ;
        }
        break;
    case 123:;
        {
            mm_decls$nextlx.symbol = (i64)17;
            return;
        }
        break;
    case 125:;
        {
            mm_decls$nextlx.symbol = (i64)18;
            return;
        }
        break;
    case 46:;
        {
            switch ((i64)(u64)(*mm_lex$lxsptr)) {
            case 46:;
                {
                    ++(mm_lex$lxsptr);
                    if (((u64)(*mm_lex$lxsptr) == '.')) {
                        ++(mm_lex$lxsptr);
                        mm_decls$nextlx.symbol = (i64)29;
                    }
                    else {
                        mm_decls$nextlx.symbol = (i64)28;
                        mm_decls$nextlx.subcode = (i64)19;
                    }
;
                    return;
                }
                break;
            case 48:;
            case 49:;
            case 50:;
            case 51:;
            case 52:;
            case 53:;
            case 54:;
            case 55:;
            case 56:;
            case 57:;
                {
                    --(mm_lex$lxsptr);
                    mm_support$lxerror((byte*)".123 not done");
                    return;
                }
                break;
            default: {
                mm_decls$nextlx.symbol = (i64)2;
                return;
            }
            } //SW
;
        }
        break;
    case 44:;
        {
            mm_decls$nextlx.symbol = (i64)5;
            return;
        }
        break;
    case 59:;
        {
            mm_decls$nextlx.symbol = (i64)6;
            return;
        }
        break;
    case 58:;
        {
            switch ((i64)(u64)(*mm_lex$lxsptr)) {
            case 61:;
                {
                    ++(mm_lex$lxsptr);
                    mm_decls$nextlx.symbol = (i64)9;
                    mm_decls$nextlx.subcode = (i64)26;
                }
                break;
            case 58:;
                {
                    ++(mm_lex$lxsptr);
                                        {u64 $temp = (u64)(*mm_lex$lxsptr);
if (($temp=='=')) {
                        ++(mm_lex$lxsptr);
                        mm_decls$nextlx.symbol = (i64)10;
                    }
                    else {
                        mm_decls$nextlx.symbol = (i64)8;
                    }
                    };
                }
                break;
            default: {
                mm_decls$nextlx.symbol = (i64)7;
            }
            } //SW
;
            return;
        }
        break;
    case 40:;
        {
            mm_decls$nextlx.symbol = (i64)13;
            return;
        }
        break;
    case 41:;
        {
            mm_decls$nextlx.symbol = (i64)14;
            return;
        }
        break;
    case 91:;
        {
            mm_decls$nextlx.symbol = (i64)15;
            return;
        }
        break;
    case 93:;
        {
            mm_decls$nextlx.symbol = (i64)16;
            return;
        }
        break;
    case 124:;
        {
            if (((u64)(*mm_lex$lxsptr) == '|')) {
                ++(mm_lex$lxsptr);
                mm_decls$nextlx.symbol = (i64)21;
            }
            else {
                mm_decls$nextlx.symbol = (i64)20;
            }
;
            return;
        }
        break;
    case 94:;
        {
            mm_decls$nextlx.symbol = (i64)19;
            return;
        }
        break;
    case 64:;
        {
            if (((u64)(*mm_lex$lxsptr) == '@')) {
                ++(mm_lex$lxsptr);
                mm_decls$nextlx.symbol = (i64)23;
            }
            else {
                mm_decls$nextlx.symbol = (i64)22;
            }
;
            return;
        }
        break;
    case 63:;
        {
            mm_decls$nextlx.symbol = (i64)24;
            return;
        }
        break;
    case 126:;
        {
            mm_decls$nextlx.symbol = (i64)27;
            return;
        }
        break;
    case 43:;
        {
            mm_decls$nextlx.symbol = (i64)31;
            if (((u64)(*mm_lex$lxsptr) == '+')) {
                ++(mm_lex$lxsptr);
                mm_decls$nextlx.symbol = (i64)71;
                mm_decls$nextlx.subcode = (i64)53;
                return;
            }
;
            return;
        }
        break;
    case 45:;
        {
            mm_decls$nextlx.symbol = (i64)32;
                        {u64 $temp = (u64)(*mm_lex$lxsptr);
if (($temp=='-')) {
                ++(mm_lex$lxsptr);
                mm_decls$nextlx.symbol = (i64)71;
                mm_decls$nextlx.subcode = (i64)54;
                return;
            }
            else if (($temp=='>')) {
                ++(mm_lex$lxsptr);
                mm_decls$nextlx.symbol = (i64)12;
                return;
            }
            };
            return;
        }
        break;
    case 42:;
        {
            if (((u64)(*mm_lex$lxsptr) == '*')) {
                ++(mm_lex$lxsptr);
                mm_decls$nextlx.symbol = (i64)50;
            }
            else {
                mm_decls$nextlx.symbol = (i64)33;
            }
;
            return;
        }
        break;
    case 47:;
        {
            mm_decls$nextlx.symbol = (i64)34;
            return;
        }
        break;
    case 37:;
        {
            mm_decls$nextlx.symbol = (i64)35;
            return;
        }
        break;
    case 61:;
        {
                        {u64 $temp = (u64)(*mm_lex$lxsptr);
if (($temp=='>')) {
                mm_decls$nextlx.symbol = (i64)11;
                ++(mm_lex$lxsptr);
            }
            else if (($temp=='=')) {
                ++(mm_lex$lxsptr);
                mm_decls$nextlx.symbol = (i64)51;
            }
            else {
                mm_decls$nextlx.symbol = (i64)48;
                mm_decls$nextlx.subcode = (i64)17;
            }
            };
            return;
        }
        break;
    case 60:;
        {
            mm_decls$nextlx.symbol = (i64)49;
            switch ((i64)(u64)(*mm_lex$lxsptr)) {
            case 61:;
                {
                    ++(mm_lex$lxsptr);
                    mm_decls$nextlx.subcode = (i64)20;
                }
                break;
            case 62:;
                {
                    ++(mm_lex$lxsptr);
                    mm_decls$nextlx.subcode = (i64)18;
                }
                break;
            case 60:;
                {
                    ++(mm_lex$lxsptr);
                    mm_decls$nextlx.symbol = (i64)41;
                }
                break;
            default: {
                mm_decls$nextlx.subcode = (i64)19;
            }
            } //SW
;
            return;
        }
        break;
    case 62:;
        {
            mm_decls$nextlx.symbol = (i64)49;
            switch ((i64)(u64)(*mm_lex$lxsptr)) {
            case 61:;
                {
                    ++(mm_lex$lxsptr);
                    mm_decls$nextlx.symbol = (i64)49;
                    mm_decls$nextlx.subcode = (i64)21;
                }
                break;
            case 62:;
                {
                    ++(mm_lex$lxsptr);
                    mm_decls$nextlx.symbol = (i64)42;
                }
                break;
            default: {
                mm_decls$nextlx.symbol = (i64)49;
                mm_decls$nextlx.subcode = (i64)22;
            }
            } //SW
;
            return;
        }
        break;
    case 38:;
        {
                        {u64 $temp = (u64)(*mm_lex$lxsptr);
if (($temp=='.')) {
                ++(mm_lex$lxsptr);
                mm_decls$nextlx.symbol = (i64)4;
                mm_decls$nextlx.subcode = (i64)0;
            }
            else {
                mm_decls$nextlx.symbol = (i64)25;
                mm_decls$nextlx.subcode = (i64)50;
            }
            };
            return;
        }
        break;
    case 39:;
        {
            mm_lex$lxreadstring((i64)39);
            return;
        }
        break;
    case 34:;
        {
            mm_lex$lxreadstring((i64)34);
            return;
        }
        break;
    case 96:;
        {
            mm_lex$readrawxname();
            return;
        }
        break;
    case 32:;
    case 9:;
        {
        }
        break;
    case 13:;
        {
            ++(mm_lex$lxsptr);
            ++(mm_lex$lxalllines);
            mm_decls$nextlx.symbol = (i64)67;
            return;
        }
        break;
    case 10:;
        {
            ++(mm_lex$lxalllines);
            mm_decls$nextlx.symbol = (i64)67;
            return;
        }
        break;
    case 0:;
        {
            if (!!(mm_lex$sourcelevel)) {
                mm_lex$unstacksource();
                return;
            }
            else {
                mm_decls$nextlx.symbol = (i64)68;
                --(mm_lex$lxsptr);
                return;
            }
;
        }
        break;
    case 239:;
        {
            mm_lex$lxsptr += (i64)2;
        }
        break;
    default: {
        mm_decls$nextlx.symbol = (i64)1;
        return;
    }
    } //SW
goto L278 ;
L279 :;
    ;
}

void mm_lex$lex(void) {
        i64 lena;
        i64 lenb;
        u8 *  p;
    mm_decls$lx = mm_decls$nextlx;
    mm_decls$lx.pos = msysc$m_setdotslice(mm_decls$lx.pos,(i64)0,(i64)23,(u64)(mm_lex$lxstart - mm_lex$lxsource));
    //reenter:
L292 :;
;
    mm_lex$lexreadtoken();
    //reenter2:
L293 :;
;
    switch ((i64)mm_decls$nextlx.symbol) {
    case 107:;
    case 123:;
    case 108:;
    case 124:;
    case 111:;
    case 114:;
    case 112:;
    case 130:;
    case 131:;
    case 136:;
    case 106:;
    case 133:;
    case 134:;
    case 135:;
    case 137:;
    case 115:;
    case 152:;
    case 162:;
    case 167:;
    case 98:;
        {
            if (((i64)mm_decls$lx.symbol == (i64)105)) {
                if (!!((i64)mm_decls$lx.subcode)) {
                    mm_support$lxerror((byte*)"end if if?");
                }
;
                mm_decls$lx.subcode = (i64)mm_decls$nextlx.symbol;
                goto L292 ;
;
            }
;
        }
        break;
    case 67:;
        {
            if (((i64)mm_decls$lx.symbol == (i64)5 || (i64)mm_decls$lx.symbol == (i64)15 || (i64)mm_decls$lx.symbol == (i64)13)) {
                goto L292 ;
;
            }
            else if (((((i64)mm_tables$symboloptypes[((i64)mm_decls$lx.symbol)-1] == (i64)1) && !(!!(mm_decls$assemmode))) && !(((i64)mm_decls$lx.symbol == (i64)44 || (i64)mm_decls$lx.symbol == (i64)43)))) {
                goto L292 ;
;
            }
;
            mm_decls$nextlx.symbol = (i64)6;
            mm_decls$nextlx.subcode = (i64)1;
        }
        break;
    case 77:;
        {
            if (((i64)mm_decls$lx.symbol == (i64)77)) {
                lena = strlen(mm_decls$lx.svalue);
                lenb = strlen(mm_decls$nextlx.svalue);
                p = (u8 *)mlib$pcm_alloc(((lena + lenb) + (i64)1));
                memcpy((void *)p,(void *)mm_decls$lx.svalue,(u64)lena);
                memcpy((void *)(p + lena),(void *)mm_decls$nextlx.svalue,(u64)lenb);
                (*((p + lena) + lenb)) = (u64)0u;
                mm_decls$lx.svalue = p;
            }
;
        }
        break;
    case 82:;
        {
            if (!(!!(mm_lex$dolexdirective((i64)mm_decls$nextlx.subcode)))) {
                goto L292 ;
;
            }
;
        }
        break;
    case 81:;
        {
                        {i64 $temp = (i64)mm_decls$nextlx.subcode;
if (($temp==(i64)80)) {
                                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)72)) {
                                        {i64 $temp = (i64)(*mm_decls$nextlx.symptr).index;
if (($temp==(i64)2)) {
                        mm_decls$lx.value *= (i64)1000000;
                    }
                    else if (($temp==(i64)3)) {
                        mm_decls$lx.value *= (i64)1000000000;
                    }
                    else if (($temp==(i64)1)) {
                        mm_decls$lx.value *= (i64)1000;
                    }
                    else if (($temp==(i64)4)) {
                        mm_decls$lx.value *= (i64)1024;
                    }
                    else if (($temp==(i64)5)) {
                        mm_decls$lx.value *= (i64)1048576;
                    }
                    else if (($temp==(i64)6)) {
                        mm_decls$lx.value *= (i64)1073741824;
                    }
                    else {
                        mm_support$lxerror((byte*)"Can't do this unit index");
                    }
                    };
                    mm_decls$lx.subcode = mm_lex$setinttype((u64)mm_decls$lx.value);
                    goto L292 ;
;
                }
                else if (($temp==(i64)74)) {
                    mm_support$lxerror((byte*)"Unit suffix after float not implem");
                }
                else {
                    mm_decls$nextlx.symbol = (i64)81;
                }
                };
            }
            else if (($temp==(i64)153)) {
                if (!(!!(mm_decls$headermode))) {
                    mm_decls$nextlx.symbol = (i64)81;
                }
                else {
                    mm_decls$nextlx.symbol = (i64)153;
                    mm_decls$nextlx.subcode = (i64)(*mm_decls$nextlx.symptr).index;
                }
;
            }
            else {
                mm_decls$nextlx.symbol = (i64)81;
            }
            };
        }
        break;
    case 69:;
        {
            mm_decls$nextlx.symbol = (i64)81;
        }
        break;
    case 52:;
        {
            if (((i64)mm_decls$lx.symbol == (i64)56)) {
                mm_decls$lx.symbol = (i64)53;
                mm_decls$lx.subcode = (i64)14;
                goto L292 ;
;
            }
;
        }
        break;
    case 48:;
        {
            if (((i64)mm_decls$lx.symbol == (i64)56)) {
                mm_decls$lx.symbol = (i64)49;
                mm_decls$lx.subcode = (i64)18;
                goto L292 ;
;
            }
;
        }
        break;
    } //SW
;
    mm_decls$nextlx.pos = ((i64)mm_decls$nextlx.pos | (mm_lex$lxfileno << (i64)24));
}

void mm_lex$lexsetup(void) {
    mm_lex$inithashtable();
}

void mm_lex$printstrn(u8 *s,i64 length) {
    if (!!(length)) {
        msysc$m_print_startcon();
        msysc$m_print_i64(length,(byte*)"v");
        msysc$m_print_str(s,(byte*)".*");
        msysc$m_print_end();
        ;
    }
;
}

static void mm_lex$readrawstring(void) {
        u8 *  dest;
        i64 c;
    mm_decls$nextlx.symbol = (i64)77;
    mm_decls$nextlx.svalue = ++(mm_lex$lxsptr);
    dest = mm_lex$lxsptr;
    L294 :;
    switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
    case 34:;
        {
            if (((u64)(*mm_lex$lxsptr) == '"')) {
                (*(dest)++) = '"';
                ++(mm_lex$lxsptr);
            }
            else {
                (*(mm_lex$lxsptr - (i64)1)) = (u64)0u;
                goto L295 ;
            }
;
        }
        break;
    case 13:;
    case 10:;
    case 0:;
        {
            mm_support$lxerror((byte*)"Raw string not terminated");
            --(mm_lex$lxsptr);
            goto L295 ;
        }
        break;
    default: {
        (*(dest)++) = (u64)c;
    }
    } //SW
goto L294 ;
L295 :;
    ;
}

static void mm_lex$lookup(u8 *name,i64 length,i64 hashindex0) {
        i64 wrapped;
        i64 n;
        struct mm_decls$strec *  d;
        i64 j;
    j = (hashindex0 & (i64)65535);
    d = mm_lex$hashtable[(j)];
    wrapped = (i64)0;
    L296 :;
    while (1) {
        if ((d == 0)) {
            goto L297 ;
        }
;
        if ((((n = (i64)(*d).namelen) == length) && (memcmp((void *)(*d).name,(void *)name,(u64)n) == (i64)0))) {
            mm_decls$nextlx.symptr = (struct mm_decls$strec *)d;
            mm_decls$nextlx.symbol = (i64)(*d).symbol;
            mm_decls$nextlx.subcode = (i64)(*d).subcode;
            return;
        }
;
        if ((++(j) >= (i64)65536)) {
            if (!!(wrapped)) {
                mlib$abortprogram((byte*)"HASHTABLE FULL");
            }
;
            wrapped = (i64)1;
            j = (i64)0;
        }
;
        d = mm_lex$hashtable[(j)];
    }
L297 :;
    ;
    d = (struct mm_decls$strec *)mlib$pcm_allocz((i64)193);
    mm_lex$hashtable[(j)] = d;
    (*d).name = mlib$pcm_copyheapstringn(name,length);
    (*d).namelen = length;
    (*d).symbol = (i64)81;
    mm_decls$nextlx.symptr = (struct mm_decls$strec *)d;
    mm_decls$nextlx.symbol = (i64)(*d).symbol;
    if (((length == (i64)1) && ((u64)(*name) >= (i64)97 && (u64)(*name) <= (i64)122))) {
        mm_lex$shortnames[((i64)(u64)(*name))-97] = d;
    }
;
}

static i64 mm_lex$lookupsys(u8 *name) {
        i64 j;
        i64 wrapped;
    j = (mm_lex$gethashvaluez(name) & (i64)65535);
    mm_decls$lx.symptr = (struct mm_decls$strec *)mm_lex$hashtable[(j)];
    wrapped = (i64)0;
    L298 :;
    while (1) {
        if ((mm_decls$lx.symptr == 0)) {
            goto L299 ;
        }
        else if (!!(mlib$eqstring((*mm_decls$lx.symptr).name,name))) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Lex dupl name:",NULL);
            msysc$m_print_str(name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            exit((i64)1);
        }
;
        if ((++(j) >= (i64)65536)) {
            if (!!(wrapped)) {
                mlib$abortprogram((byte*)"SYS:HASHTABLE FULL");
            }
;
            wrapped = (i64)1;
            j = (i64)0;
        }
;
        mm_decls$lx.symptr = (struct mm_decls$strec *)mm_lex$hashtable[(j)];
    }
L299 :;
    ;
    mm_decls$lx.symptr = (struct mm_decls$strec *)mlib$pcm_allocz((i64)193);
    mm_lex$hashtable[(j)] = (struct mm_decls$strec *)mm_decls$lx.symptr;
    (*mm_decls$lx.symptr).name = name;
    (*mm_decls$lx.symptr).namelen = strlen(name);
    (*mm_decls$lx.symptr).symbol = (i64)81;
    return (i64)0;
}

static i64 mm_lex$gethashvaluez(u8 *s) {
        i64 c;
        i64 hsum;
    if (((i64)(u64)(*s) == (i64)0)) {
        return (i64)0;
    }
;
    hsum = (i64)(u64)(*(s)++);
    L300 :;
    while (1) {
        c = (i64)(u64)(*(s)++);
        if ((c == (i64)0)) {
            goto L301 ;
        }
;
        hsum = (((hsum << (i64)4) - hsum) + c);
    }
L301 :;
    ;
    return ((hsum << (i64)5) - hsum);
}

static void mm_lex$inithashtable(void) {
        i64 i;
    memset(&mm_lex$hashtable,(i32)(i64)0,(u64)524288u);
    for (i=(i64)1;i<=(i64)262;++i) {
L302 :;
        mm_lex$lookupsys(mm_tables$stnames[(i)-1]);
        (*mm_decls$lx.symptr).symbol = mm_tables$stsymbols[(i)-1];
                {i64 $temp = mm_tables$stsymbols[(i)-1];
if (($temp==(i64)80) || ($temp==(i64)153)) {
            (*mm_decls$lx.symptr).index = mm_tables$stsubcodes[(i)-1];
            (*mm_decls$lx.symptr).subcode = mm_tables$stsymbols[(i)-1];
            (*mm_decls$lx.symptr).symbol = (i64)81;
        }
        else {
            (*mm_decls$lx.symptr).subcode = mm_tables$stsubcodes[(i)-1];
        }
        };
L303 :;
    }
L304 :;
    ;
}

void mm_lex$printhashtable(void) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Hashtable:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void mm_lex$addreservedword(u8 *name,i64 symbol,i64 subcode,i64 regsize) {
    mm_lex$lookupsys(name);
    (*mm_decls$lx.symptr).symbol = (i64)81;
    (*mm_decls$lx.symptr).subcode = symbol;
    (*mm_decls$lx.symptr).index = subcode;
    (*mm_decls$lx.symptr).regsize = regsize;
}

static i64 mm_lex$dolexdirective(i64 index) {
        u8 *  file;
        i64 fileno;
    if ((index==(i64)1)) {
        mm_lex$lexreadtoken();
        if (((i64)mm_decls$nextlx.symbol != (i64)77)) {
            mm_support$lxerror((byte*)"include: string expected");
        }
;
        file = mm_decls$nextlx.svalue;
        mlib$convlcstring(file);
        file = mlib$addext(file,(byte*)"m");
        fileno = mm_support$getsupportfile(file,(byte*)"",mm_decls$sourcefilepaths[(mm_lex$lxfileno)],(i64)0,(i64)1);
        mm_lex$lexreadtoken();
        mm_lex$stacksource(fileno,(i64)0);
        return (i64)0;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(mm_tables$sourcedirnames[(index)-1],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$lxerror((byte*)"Directive not implemented");
    }
;
    return (i64)0;
}

void mm_lex$startlex(i64 fileno) {
    mm_lex$lxsource = (mm_lex$lxsptr = mm_decls$sourcefiletext[(fileno)]);
    mm_decls$nextlx.pos = (i64)0;
    mm_lex$lxfileno = fileno;
    mm_decls$nextlx.symbol = (i64)6;
    mm_decls$nextlx.subcode = (i64)0;
}

// START
void mm_lex$start(void) {

        i64 i;
    for (i=(i64)0;i<=(i64)255;++i) {
L305 :;
        switch (i) {
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 95:;
        case 36:;
            {
                mm_lex$alphamap[(i)] = (i64)1;
            }
            break;
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
            {
                mm_lex$alphamap[(i)] = (i64)2;
            }
            break;
        } //SW
;
L306 :;
    }
L307 :;
    ;
}

struct mm_decls$strec *mm_lex$addnamestr(u8 *name) {
        struct mm_decls$tokenrec oldlx;
        struct mm_decls$strec *  symptr;
    oldlx = mm_decls$nextlx;
    mm_lex$lookup(name,strlen(name),mm_lex$gethashvaluez(name));
    symptr = (struct mm_decls$strec *)mm_decls$nextlx.symptr;
    mm_decls$nextlx = oldlx;
    return (struct mm_decls$strec *)symptr;
}

void mm_lex$ps(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"PS:",NULL);
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)": ",NULL);
    msysc$m_print_end();
    ;
    mm_diags$printsymbol(&mm_decls$lx);
}

void mm_lex$psnext(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)": ",NULL);
    msysc$m_print_end();
    ;
    mm_diags$printsymbol(&mm_decls$nextlx);
}

void mm_lex$psx(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)": ",NULL);
    msysc$m_print_end();
    ;
    mm_diags$printsymbol(&mm_decls$lx);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"\t",NULL);
    msysc$m_print_end();
    ;
    mm_diags$printsymbol(&mm_decls$nextlx);
}

void mm_lex$stacksource(i64 fileno,i64 isimport) {
    if ((mm_lex$sourcelevel >= (i64)20)) {
        mm_support$lxerror((byte*)"Include file/macro overflow");
    }
;
    ++(mm_lex$sourcelevel);
    mm_lex$lxstart_stack[(mm_lex$sourcelevel)-1] = mm_lex$lxstart;
    mm_lex$lxsource_stack[(mm_lex$sourcelevel)-1] = mm_lex$lxsource;
    mm_lex$lxsptr_stack[(mm_lex$sourcelevel)-1] = mm_lex$lxsptr;
    mm_lex$lxfileno_stack[(mm_lex$sourcelevel)-1] = mm_lex$lxfileno;
    mm_lex$lxnextlx_stack[(mm_lex$sourcelevel)-1] = mm_decls$nextlx;
    mm_lex$lximport_stack[(mm_lex$sourcelevel)-1] = mm_lex$lximport;
    mm_lex$lximport = isimport;
    mm_lex$lxsource = (mm_lex$lxsptr = mm_decls$sourcefiletext[(fileno)]);
    mm_decls$nextlx.pos = (i64)0;
    mm_lex$lxfileno = fileno;
    mm_decls$nextlx.symbol = (i64)6;
    mm_decls$nextlx.subcode = (i64)0;
}

void mm_lex$unstacksource(void) {
    if ((mm_lex$sourcelevel > (i64)0)) {
        mm_lex$lxstart = mm_lex$lxstart_stack[(mm_lex$sourcelevel)-1];
        mm_lex$lxsource = mm_lex$lxsource_stack[(mm_lex$sourcelevel)-1];
        mm_lex$lxsptr = mm_lex$lxsptr_stack[(mm_lex$sourcelevel)-1];
        mm_decls$nextlx = mm_lex$lxnextlx_stack[(mm_lex$sourcelevel)-1];
        mm_lex$lxfileno = mm_lex$lxfileno_stack[(mm_lex$sourcelevel)-1];
        mm_lex$lximport = (i64)mm_lex$lximport_stack[(mm_lex$sourcelevel)-1];
        --(mm_lex$sourcelevel);
    }
;
}

static void mm_lex$readarraystring(i64 prefix) {
    ++(mm_lex$lxsptr);
    mm_lex$lxreadstring((i64)34);
    mm_decls$nextlx.symbol = (i64)78;
    mm_decls$nextlx.subcode = toupper((i32)prefix);
    mm_lex$astringlength = strlen(mm_decls$nextlx.svalue);
}

static i64 mm_lex$setinttype(u64 a) {
    if ((a <= (u64)9223372036854775807u)) {
        return (i64)3;
    }
    else {
        return (i64)2;
    }
;
}

static void mm_lex$readrawxname(void) {
        i64 c;
        i64 hsum;
        i64 length;
    mm_decls$nextlx.svalue = mm_lex$lxsptr;
    hsum = (i64)0;
    L308 :;
    switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    case 95:;
    case 36:;
        {
            hsum = (((hsum << (i64)4) - hsum) + c);
        }
        break;
    default: {
        --(mm_lex$lxsptr);
        goto L309 ;
    }
    } //SW
goto L308 ;
L309 :;
    ;
    length = (mm_lex$lxsptr - mm_decls$nextlx.svalue);
    if ((length == (i64)0)) {
        mm_support$lxerror((byte*)"Bad ` name");
    }
;
    mm_lex$lookup(mm_decls$nextlx.svalue,length,((hsum << (i64)5) - hsum));
    mm_decls$nextlx.symbol = (i64)69;
    return;
}

static void mm_lex$lxerror_s(u8 *mess,u8 *s) {
    mm_support$lxerror(mess);
}

static void mm_lex$lxreadstring(i64 termchar) {
        u8 *  s;
        u8 *  t;
        i64 c;
        i64 d;
        i64 length;
        i64 hasescape;
        u8 str[8];
        i64 $av_1;
    if ((termchar == (i64)34)) {
        mm_decls$nextlx.symbol = (i64)77;
    }
    else {
        mm_decls$nextlx.symbol = (i64)75;
        mm_decls$nextlx.subcode = (i64)3;
    }
;
    s = mm_lex$lxsptr;
    length = (i64)0;
    hasescape = (i64)0;
    L310 :;
    switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
    case 92:;
        {
            c = (i64)(u64)(*mm_lex$lxsptr);
            if ((c >= (i64)65 && c <= (i64)90)) {
                c += (i64)32;
            }
;
            ++(mm_lex$lxsptr);
            hasescape = (i64)1;
            switch (c) {
            case 97:;
            case 98:;
            case 99:;
            case 101:;
            case 114:;
            case 102:;
            case 108:;
            case 110:;
            case 115:;
            case 116:;
            case 118:;
            case 121:;
            case 122:;
            case 48:;
            case 34:;
            case 113:;
            case 92:;
            case 39:;
                {
                    ++(length);
                }
                break;
            case 119:;
                {
                    ++(length);
                }
                break;
            case 120:;
                {
                    mm_lex$lxsptr += (i64)2;
                    ++(length);
                }
                break;
            default: {
                mm_support$lxerror((byte*)"Bad str escape");
            }
            } //SW
;
        }
        break;
    case 34:;
    case 39:;
        {
            if ((c == termchar)) {
                if (((i64)(u64)(*mm_lex$lxsptr) == c)) {
                    hasescape = (i64)1;
                    ++(mm_lex$lxsptr);
                    ++(length);
                }
                else {
                    goto L311 ;
                }
;
            }
            else {
                ++(length);
            }
;
        }
        break;
    case 13:;
    case 10:;
    case 0:;
        {
            mm_support$lxerror((byte*)"String not terminated");
        }
        break;
    default: {
        ++(length);
    }
    } //SW
goto L310 ;
L311 :;
    ;
    if ((length == (i64)0)) {
        mm_decls$nextlx.svalue = (byte*)"";
        return;
    }
    else if (!(!!(hasescape))) {
        mm_decls$nextlx.svalue = mlib$pcm_copyheapstringn(s,length);
        return;
    }
;
    mm_decls$nextlx.svalue = (t = (u8 *)mlib$pcm_alloc((length + (i64)1)));
    L312 :;
    while (1) {
        switch ((c = (i64)(u64)(*(s)++))) {
        case 92:;
            {
                c = (i64)(u64)(*s);
                if (((c >= (i64)65) && (c <= (i64)90))) {
                    c += (i64)32;
                }
;
                ++(s);
                switch (c) {
                case 97:;
                    {
                        c = (i64)7;
                    }
                    break;
                case 98:;
                    {
                        c = (i64)8;
                    }
                    break;
                case 99:;
                case 114:;
                    {
                        c = (i64)13;
                    }
                    break;
                case 101:;
                    {
                        c = (i64)26;
                    }
                    break;
                case 102:;
                    {
                        c = (i64)12;
                    }
                    break;
                case 108:;
                case 110:;
                    {
                        c = (i64)10;
                    }
                    break;
                case 115:;
                    {
                        c = (i64)27;
                    }
                    break;
                case 116:;
                    {
                        c = (i64)9;
                    }
                    break;
                case 118:;
                    {
                        c = (i64)11;
                    }
                    break;
                case 119:;
                    {
                        (*(t)++) = (u64)13u;
                        c = (i64)10;
                    }
                    break;
                case 120:;
                    {
                        c = (i64)0;
                        $av_1 = (i64)2;
                        while ($av_1-- > 0) {
L314 :;
                                                        {i64 $temp = (d = (i64)(u64)(*(s)++));
if (($temp==(i64)65) || ($temp==(i64)66) || ($temp==(i64)67) || ($temp==(i64)68) || ($temp==(i64)69) || ($temp==(i64)70)) {
                                c = ((((c * (i64)16) + d) - (i64)65) + (i64)10);
                            }
                            else if (($temp==(i64)97) || ($temp==(i64)98) || ($temp==(i64)99) || ($temp==(i64)100) || ($temp==(i64)101) || ($temp==(i64)102)) {
                                c = ((((c * (i64)16) + d) - (i64)97) + (i64)10);
                            }
                            else if (($temp==(i64)48) || ($temp==(i64)49) || ($temp==(i64)50) || ($temp==(i64)51) || ($temp==(i64)52) || ($temp==(i64)53) || ($temp==(i64)54) || ($temp==(i64)55) || ($temp==(i64)56) || ($temp==(i64)57)) {
                                c = (((c * (i64)16) + d) - (i64)48);
                            }
                            else {
                                mm_support$lxerror((byte*)"Bad \\x code");
                            }
                            };
L315 :;
                        }
L316 :;
                        ;
                    }
                    break;
                case 121:;
                    {
                        c = (i64)16;
                    }
                    break;
                case 122:;
                case 48:;
                    {
                        c = (i64)0;
                    }
                    break;
                case 34:;
                case 81:;
                    {
                        c = (i64)34;
                    }
                    break;
                case 92:;
                    {
                        c = (i64)92;
                    }
                    break;
                case 39:;
                    {
                        c = (i64)39;
                    }
                    break;
                default: {
                    str[((i64)1)-1] = (u64)c;
                    str[((i64)2)-1] = (u64)0u;
                    mm_lex$lxerror_s((byte*)"Unknown string escape: \\%s",(u8 *)str);
                }
                } //SW
;
            }
            break;
        case 34:;
        case 39:;
            {
                if ((c == termchar)) {
                    if (((i64)(u64)(*s) == c)) {
                        ++(s);
                    }
                    else {
                        goto L313 ;
                    }
;
                }
;
            }
            break;
        case 13:;
        case 10:;
        case 0:;
            {
                mm_support$lxerror((byte*)"String not terminated");
            }
            break;
        } //SW
;
        (*(t)++) = (u64)c;
    }
L313 :;
    ;
    (*t) = (u64)0u;
}

static void mm_lex$readdec(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 islong;
        i64 length;
        byte str[1024];
        u64 a;
        i64 $av_1;
    islong = (i64)0;
    pstart = mm_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L317 :;
    while (1) {
        switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                a = (u64)((((i64)a * (i64)10) + c) - (i64)48);
                (*(dest)++) = (u64)c;
            }
            break;
        case 101:;
        case 69:;
            {
                mm_lex$lxsptr = pstart;
                mm_lex$readreal();
                return;
            }
            break;
        case 46:;
            {
                if (((u64)(*mm_lex$lxsptr) != '.')) {
                    mm_lex$lxsptr = pstart;
                    mm_lex$readreal();
                    return;
                }
;
                --(mm_lex$lxsptr);
                goto L318 ;
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 108:;
        case 76:;
            {
                (*dest) = (u64)0u;
                mm_support$lxerror((byte*)"MAKEDECIMAL NOT READY");
                return;
            }
            break;
        case 98:;
        case 66:;
            {
                length = (dest - str);
                if ((length > (i64)64)) {
                    mm_support$lxerror((byte*)"bin overflow");
                }
;
                dest = (u8 *)str;
                a = (u64)0u;
                $av_1 = length;
                while ($av_1-- > 0) {
L319 :;
                    if (((u64)(*dest) >= '2')) {
                        mm_support$lxerror((byte*)"bad bin digit");
                    }
;
                    a = (u64)((((i64)a * (i64)2) + (i64)(u64)(*(dest)++)) - (i64)48);
L320 :;
                }
L321 :;
                ;
                goto L322 ;
;
            }
            break;
        default: {
            --(mm_lex$lxsptr);
            goto L318 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            mm_support$lxerror((byte*)"Numlit too long");
        }
;
    }
L318 :;
    ;
    length = (dest - str);
    if (((length > (i64)20) || ((length == (i64)20) && !!(strncmp((u8 *)str,mm_lex$u64maxstr,(u64)20u))))) {
        mm_support$lxerror((byte*)"2:MAKEDECIMAL NOT READY");
        return;
    }
;
    //finish:
L322 :;
;
    mm_decls$nextlx.symbol = (i64)72;
    mm_decls$nextlx.subcode = mm_lex$setinttype(a);
    mm_decls$nextlx.value = (i64)a;
}

static void mm_lex$readhex(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 length;
        byte str[1024];
        u64 a;
    pstart = mm_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L323 :;
    while (1) {
        switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                a = (u64)((((i64)a * (i64)16) + c) - (i64)48);
                (*(dest)++) = (u64)c;
            }
            break;
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
            {
                (*(dest)++) = (u64)c;
                a = (u64)(((((i64)a * (i64)16) + c) - (i64)65) + (i64)10);
            }
            break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
            {
                (*(dest)++) = (u64)(c - (i64)32);
                a = (u64)(((((i64)a * (i64)16) + c) - (i64)97) + (i64)10);
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 108:;
        case 76:;
            {
                (*dest) = (u64)0u;
                mm_support$lxerror((byte*)"3:MAKEDECIMAL NOT READY");
                return;
            }
            break;
        case 46:;
            {
                --(mm_lex$lxsptr);
                goto L324 ;
            }
            break;
        default: {
            --(mm_lex$lxsptr);
            goto L324 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            mm_support$lxerror((byte*)"Numlit too long");
        }
;
    }
L324 :;
    ;
    length = (dest - str);
    if ((length > (i64)16)) {
        mm_support$lxerror((byte*)"4:MAKEDECIMAL NOT READY");
        return;
    }
;
    mm_decls$nextlx.symbol = (i64)72;
    mm_decls$nextlx.subcode = mm_lex$setinttype(a);
    mm_decls$nextlx.value = (i64)a;
}

static void mm_lex$readoct(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 length;
        byte str[1024];
        u64 a;
    pstart = mm_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L325 :;
    while (1) {
        switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
            {
                a = (u64)((((i64)a * (i64)8) + c) - (i64)48);
                (*(dest)++) = (u64)c;
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 46:;
            {
                --(mm_lex$lxsptr);
                goto L326 ;
            }
            break;
        default: {
            --(mm_lex$lxsptr);
            goto L326 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            mm_support$lxerror((byte*)"Numlit too long");
        }
;
    }
L326 :;
    ;
    length = (dest - str);
    if ((length > (i64)22)) {
        mm_support$lxerror((byte*)"oct overflow");
    }
;
    mm_decls$nextlx.symbol = (i64)72;
    mm_decls$nextlx.subcode = mm_lex$setinttype(a);
    mm_decls$nextlx.value = (i64)a;
}

static void mm_lex$readbin(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 length;
        byte str[1024];
        u64 a;
    pstart = mm_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L327 :;
    while (1) {
        switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
        case 48:;
        case 49:;
            {
                a = (u64)((((i64)a * (i64)2) + c) - (i64)48);
                (*(dest)++) = (u64)c;
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 108:;
        case 76:;
            {
                (*dest) = (u64)0u;
                mm_support$lxerror((byte*)"5:MAKEDECIMAL NOT READY");
                return;
            }
            break;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                mm_support$lxerror((byte*)"bin bad digit");
            }
            break;
        case 46:;
            {
                --(mm_lex$lxsptr);
                goto L328 ;
            }
            break;
        default: {
            --(mm_lex$lxsptr);
            goto L328 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            mm_support$lxerror((byte*)"bin overflow");
        }
;
    }
L328 :;
    ;
    length = (dest - str);
    if ((length > (i64)64)) {
        mm_support$lxerror((byte*)"6:MAKEDECIMAL NOT READY");
        return;
    }
;
    mm_decls$nextlx.symbol = (i64)72;
    mm_decls$nextlx.subcode = mm_lex$setinttype(a);
    mm_decls$nextlx.value = (i64)a;
}

static void mm_lex$readreal(void) {
        i64 c;
        i64 negexpon;
        i64 dotseen;
        i64 length;
        i64 fractlen;
        i64 expon;
        i64 expseen;
        r64 x;
        u8 str[1024];
        u8 *  dest;
        u8 *  destend;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 i;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)100);
    length = (negexpon = (dotseen = (expseen = (expon = (fractlen = (i64)0)))));
    L329 :;
    while (1) {
        switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                (*(dest)++) = (u64)c;
                ++(length);
                if (!!(dotseen)) {
                    ++(fractlen);
                }
;
            }
            break;
        case 46:;
            {
                if (!!(dotseen)) {
                    --(mm_lex$lxsptr);
                    goto L330 ;
                }
;
                dotseen = (i64)1;
                (*(dest)++) = (u64)c;
            }
            break;
        case 101:;
        case 69:;
            {
                if (!!(expseen)) {
                    mm_support$lxerror((byte*)"double expon");
                }
;
                expseen = (i64)1;
                (*(dest)++) = (u64)c;
                L331 :;
                while (((u64)(*mm_lex$lxsptr) == ' ')) {
                    ++(mm_lex$lxsptr);
L332 :;
                }
L333 :;
                ;
                if (((u64)(*mm_lex$lxsptr) == '+' || (u64)(*mm_lex$lxsptr) == '-')) {
                    if (((u64)(*mm_lex$lxsptr) == '-')) {
                        negexpon = (i64)1;
                    }
;
                    (*(dest)++) = (u64)(*(mm_lex$lxsptr)++);
                }
;
                expon = (i64)0;
                L334 :;
                switch ((c = (i64)(u64)(*(mm_lex$lxsptr)++))) {
                case 48:;
                case 49:;
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                case 56:;
                case 57:;
                    {
                        expon = (((expon * (i64)10) + c) - (i64)48);
                        (*(dest)++) = (u64)c;
                        if ((dest >= destend)) {
                            mm_support$lxerror((byte*)"expon?");
                        }
;
                    }
                    break;
                case 95:;
                case 39:;
                    {
                    }
                    break;
                case 108:;
                case 76:;
                    {
                        (*dest) = (u64)0u;
                        mm_support$lxerror((byte*)"7:MAKEDECIMAL NOT READY");
                        return;
                    }
                    break;
                default: {
                    --(mm_lex$lxsptr);
                    goto L330 ;
                }
                } //SW
goto L334 ;
L335 :;
                ;
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 108:;
        case 76:;
            {
                mm_support$lxerror((byte*)"8:MAKEDECIMAL NOT READY");
                return;
            }
            break;
        default: {
            --(mm_lex$lxsptr);
            goto L330 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            mm_support$lxerror((byte*)"r64lit too long");
        }
;
    }
L330 :;
    ;
    (*dest) = (u64)0u;
    if (!!(negexpon)) {
        expon = -(expon);
    }
;
    expon -= fractlen;
    x = (double)0.;
        ($av_1 = (length + dotseen));
    for (i=(i64)1;i<=$av_1;++i) {
L336 :;
        c = (i64)(u64)str[(i)-1];
        if ((c != (i64)46)) {
            x = (((x * (double)10.) + (r64)c) - (r64)'0');
        }
;
L337 :;
    }
L338 :;
    ;
    if ((expon >= (i64)0)) {
        $av_2 = expon;
        while ($av_2-- > 0) {
L339 :;
            x *= (double)10.;
L340 :;
        }
L341 :;
        ;
    }
    else {
        $av_3 = -(expon);
        while ($av_3-- > 0) {
L342 :;
            x /= (double)10.;
L343 :;
        }
L344 :;
        ;
    }
;
    mm_decls$nextlx.xvalue = x;
    mm_decls$nextlx.symbol = (i64)74;
    mm_decls$nextlx.subcode = (i64)5;
}

struct mm_decls$strec *mm_lib$newstrec(void) {
        struct mm_decls$strec *  p;
    p = (struct mm_decls$strec *)mlib$pcm_alloc((i64)193);
    memset(&((*p)),0,193);
    ++(mm_decls$nstrecs);
    (*p).pos = (i64)mm_decls$lx.pos;
    (*p).moduleno = mm_decls$currmoduleno;
    (*p).subprogno = (i64)mm_decls$moduletosub[(mm_decls$currmoduleno)];
    return p;
}

struct mm_decls$strec *mm_lib$getduplnameptr(struct mm_decls$strec *owner,struct mm_decls$strec *symptr,i64 id) {
        struct mm_decls$strec *  p;
    p = mm_lib$newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (i64)(*symptr).namelen;
    (*p).symbol = (i64)81;
    (*p).owner = (struct mm_decls$strec *)owner;
    (*p).nameid = id;
    (*p).nextdupl = (*symptr).nextdupl;
    (*p).firstdupl = (struct mm_decls$strec *)symptr;
    (*symptr).nextdupl = (struct mm_decls$strec *)p;
    return p;
}

void mm_lib$adddef(struct mm_decls$strec *owner,struct mm_decls$strec *p) {
        struct mm_decls$strec *  q;
    if (!!((q = (struct mm_decls$strec *)(*p).nextdupl))) {
        if (((*q).owner == owner)) {
            msysc$m_print_startcon();
            msysc$m_print_str((*q).name,NULL);
            msysc$m_print_str((byte*)"in",NULL);
            msysc$m_print_str((*owner).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$serror((byte*)"Duplicate name");
        }
;
    }
;
    if (((*owner).deflist == 0)) {
        (*owner).deflist = (struct mm_decls$strec *)p;
    }
    else {
        (*(*owner).deflistx).nextdef = (struct mm_decls$strec *)p;
    }
;
    (*owner).deflistx = (struct mm_decls$strec *)p;
}

struct mm_decls$unitrec *mm_lib$createname(struct mm_decls$strec *p) {
        struct mm_decls$unitrec *  u;
    u = (struct mm_decls$unitrec *)mm_lib$allocunitrec();
    (*u).tag = (i64)4;
    (*u).def = p;
    (*u).simple = (i64)1;
    return (struct mm_decls$unitrec *)u;
}

struct mm_decls$unitrec *mm_lib$createunit0(i64 tag) {
        struct mm_decls$unitrec *  u;
    u = (struct mm_decls$unitrec *)mm_lib$allocunitrec();
    (*u).tag = tag;
    return (struct mm_decls$unitrec *)u;
}

struct mm_decls$unitrec *mm_lib$createunit1(i64 tag,struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  u;
    u = (struct mm_decls$unitrec *)mm_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = (struct mm_decls$unitrec *)p;
    return (struct mm_decls$unitrec *)u;
}

struct mm_decls$unitrec *mm_lib$createunit2(i64 tag,struct mm_decls$unitrec *p,struct mm_decls$unitrec *q) {
        struct mm_decls$unitrec *  u;
    u = (struct mm_decls$unitrec *)mm_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = (struct mm_decls$unitrec *)p;
    (*u).b = (struct mm_decls$unitrec *)q;
    return (struct mm_decls$unitrec *)u;
}

struct mm_decls$unitrec *mm_lib$createunit3(i64 tag,struct mm_decls$unitrec *p,struct mm_decls$unitrec *q,struct mm_decls$unitrec *r) {
        struct mm_decls$unitrec *  u;
    u = (struct mm_decls$unitrec *)mm_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = (struct mm_decls$unitrec *)p;
    (*u).b = (struct mm_decls$unitrec *)q;
    (*u).c = (struct mm_decls$unitrec *)r;
    return (struct mm_decls$unitrec *)u;
}

void mm_lib$insertunit(struct mm_decls$unitrec *p,i64 tag) {
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  nextunit;
        i64 mode;
    q = (struct mm_decls$unitrec *)mm_lib$allocunitrec();
    (*q) = (*p);
    mode = (i64)(*q).mode;
    nextunit = (*q).nextunit;
    (*q).nextunit = 0;
    memset(&((*p)),0,64);
    (*p).tag = tag;
    (*p).pos = (i64)(*q).pos;
    (*p).a = q;
    (*p).mode = mode;
    (*p).nextunit = nextunit;
    (*p).resultflag = (i64)(*q).resultflag;
}

void mm_lib$deleteunit(struct mm_decls$unitrec *p,struct mm_decls$unitrec *q) {
        struct mm_decls$unitrec *  r;
    r = (*p).nextunit;
    (*p) = (*q);
    (*p).nextunit = r;
}

struct mm_decls$unitrec *mm_lib$createconstunit(u64 a,i64 t) {
        struct mm_decls$unitrec *  u;
    u = (struct mm_decls$unitrec *)mm_lib$allocunitrec();
    (*u).tag = (i64)1;
    (*u).value = (i64)a;
    (*u).mode = t;
    (*u).isconst = (i64)1;
    (*u).simple = (i64)1;
    return (struct mm_decls$unitrec *)u;
}

struct mm_decls$unitrec *mm_lib$createstringconstunit(u8 *s,i64 length) {
        struct mm_decls$unitrec *  u;
    u = (struct mm_decls$unitrec *)mm_lib$allocunitrec();
    (*u).tag = (i64)1;
    (*u).svalue = s;
    (*u).mode = (i64)20;
    (*u).isastring = (i64)1;
    if ((length == (i64)-1)) {
        (*u).slength = strlen(s);
    }
    else {
        (*u).slength = length;
    }
;
    return (struct mm_decls$unitrec *)u;
}

i64 mm_lib$newtypename(struct mm_decls$strec *a,struct mm_decls$strec *b) {
    if ((mm_decls$ntypenames >= (i64)8000)) {
        mm_support$serror((byte*)"Too many type names");
    }
;
    ++(mm_decls$ntypenames);
    mm_decls$typenames[(mm_decls$ntypenames)].defa = a;
    mm_decls$typenames[(mm_decls$ntypenames)].defb = b;
    mm_decls$typenamepos[(mm_decls$ntypenames)].pos = (i64)mm_decls$lx.pos;
    return -(mm_decls$ntypenames);
}

i64 mm_lib$createusertype(struct mm_decls$strec *stname) {
    if ((mm_decls$ntypes >= (i64)6000)) {
        msysc$m_print_startcon();
        msysc$m_print_i64(mm_decls$ntypes,NULL);
        msysc$m_print_str((*stname).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$serror((byte*)"Too many types");
    }
;
    ++(mm_decls$ntypes);
    mm_decls$ttname[(mm_decls$ntypes)] = (*stname).name;
    mm_decls$ttnamedef[(mm_decls$ntypes)] = stname;
    mm_decls$ttbasetype[(mm_decls$ntypes)] = (i64)0;
    mm_decls$ttlineno[(mm_decls$ntypes)] = (i64)mm_decls$lx.pos;
    (*stname).mode = mm_decls$ntypes;
    return mm_decls$ntypes;
}

i64 mm_lib$createusertypefromstr(u8 *name) {
        struct mm_decls$strec *  stname;
    stname = mm_lib$getduplnameptr(mm_decls$stmodule,(struct mm_decls$strec *)mm_lex$addnamestr(name),(i64)5);
    return mm_lib$createusertype(stname);
}

struct mm_decls$unitrec *mm_lib$getrangelwbunit(struct mm_decls$unitrec *p) {
    if (((i64)(*p).tag == (i64)19)) {
        return (struct mm_decls$unitrec *)(*p).a;
    }
    else {
        p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)35,(struct mm_decls$unitrec *)p);
        (*p).pclop = (i64)89;
        return (struct mm_decls$unitrec *)p;
    }
;
}

struct mm_decls$unitrec *mm_lib$getrangeupbunit(struct mm_decls$unitrec *p) {
    if (((i64)(*p).tag == (i64)19)) {
        return (struct mm_decls$unitrec *)(*p).b;
    }
    else {
        p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)35,(struct mm_decls$unitrec *)p);
        (*p).pclop = (i64)90;
        return (struct mm_decls$unitrec *)p;
    }
;
}

i64 mm_lib$createarraymode(struct mm_decls$strec *owner,i64 target,struct mm_decls$unitrec *dimexpr,i64 typedefx) {
        i64 k;
        i64 m;
    if ((typedefx == (i64)0)) {
        for (k=(i64)29;k<=mm_decls$ntypes;++k) {
L345 :;
            if ((((((i64)mm_decls$ttusercat[(k)] == (i64)0) && ((i64)mm_decls$ttbasetype[(k)] == (i64)10)) && ((i64)mm_decls$tttarget[(k)] == target)) && !!(mm_lib$sameunit(dimexpr,mm_decls$ttdimexpr[(k)],owner,mm_decls$ttowner[(k)])))) {
                return k;
            }
;
L346 :;
        }
L347 :;
        ;
        m = mm_lib$createusertypefromstr(mm_lib$nextautotype());
    }
    else {
        m = typedefx;
    }
;
    mm_decls$ttbasetype[(m)] = (i64)10;
    mm_decls$ttlower[(m)] = (i64)1;
    mm_decls$ttdimexpr[(m)] = dimexpr;
    mm_lib$storemode(owner,target,&mm_decls$tttarget[(m)]);
    mm_decls$ttowner[(m)] = owner;
    mm_decls$ttcat[(m)] = (i64)5;
    mm_decls$ttisblock[(m)] = (i64)1;
    return m;
}

static i64 mm_lib$sameunit(struct mm_decls$unitrec *p,struct mm_decls$unitrec *q,struct mm_decls$strec *powner,struct mm_decls$strec *qowner) {
    if ((p == q)) {
        return (i64)1;
    }
;
    if (((p == 0) || (q == 0))) {
        return (i64)0;
    }
;
    if (((i64)(*p).tag != (i64)(*q).tag)) {
        return (i64)0;
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        return (i64)((*p).value == (*q).value);
    }
    else if (($temp==(i64)19) || ($temp==(i64)25)) {
        return (i64)(!!(mm_lib$sameunit((*p).a,(*q).a,0,0)) && !!(mm_lib$sameunit((*p).b,(*q).b,0,0)));
    }
    else if (($temp==(i64)4)) {
        if ((((*p).def == (*q).def) && (powner == qowner))) {
            return (i64)1;
        }
;
    }
    };
    return (i64)0;
}

i64 mm_lib$createarraymodek(struct mm_decls$strec *owner,i64 target,i64 lower,i64 length,i64 typedefx) {
        i64 atype;
        i64 m;
    atype = (i64)10;
    if ((typedefx == (i64)0)) {
        m = mm_lib$createusertypefromstr(mm_lib$nextautotype());
    }
    else {
        m = typedefx;
    }
;
    mm_decls$ttbasetype[(m)] = atype;
    mm_decls$ttlower[(m)] = lower;
    mm_decls$ttlength[(m)] = length;
    if ((target < (i64)0)) {
        mm_support$serror((byte*)"CREATEARRAYMODEK/TARGET NOT RESOLVED");
    }
;
    mm_decls$ttsize[(m)] = (length * (i64)mm_decls$ttsize[(target)]);
    mm_lib$storemode(owner,target,&mm_decls$tttarget[(m)]);
    mm_decls$ttowner[(m)] = owner;
    mm_decls$ttcat[(m)] = (i64)5;
    mm_decls$ttisblock[(m)] = (i64)1;
    return m;
}

u8 *mm_lib$nextautotype(void) {
        static u8 str[32];
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"$T",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(++(mm_lib$autotypeno),NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

i64 mm_lib$createslicemode(struct mm_decls$strec *owner,i64 slicetype,i64 target,struct mm_decls$unitrec *dimexpr,i64 typedefx) {
        i64 m;
    if ((typedefx == (i64)0)) {
        m = mm_lib$createusertypefromstr(mm_lib$nextautotype());
    }
    else {
        m = typedefx;
    }
;
    mm_decls$ttbasetype[(m)] = slicetype;
    if (!!(dimexpr)) {
        mm_decls$ttdimexpr[(m)] = dimexpr;
    }
    else {
        mm_decls$ttlower[(m)] = (i64)1;
    }
;
    mm_lib$storemode(owner,target,&mm_decls$tttarget[(m)]);
    mm_decls$ttowner[(m)] = owner;
    mm_decls$ttcat[(m)] = (i64)5;
    mm_decls$ttisblock[(m)] = (i64)1;
    return m;
}

i64 mm_lib$createslicemodek(struct mm_decls$strec *owner,i64 target,i64 lower,i64 typedefx) {
        i64 m;
    if ((typedefx == (i64)0)) {
        m = mm_lib$createusertypefromstr(mm_lib$nextautotype());
    }
    else {
        m = typedefx;
    }
;
    mm_decls$ttbasetype[(m)] = (i64)11;
    mm_decls$ttlower[(m)] = lower;
    mm_lib$storemode(owner,target,&mm_decls$tttarget[(m)]);
    mm_decls$ttowner[(m)] = owner;
    mm_decls$ttcat[(m)] = (i64)5;
    mm_decls$ttisblock[(m)] = (i64)1;
    return m;
}

i64 mm_lib$createrefmode(struct mm_decls$strec *owner,i64 target,i64 typedefx) {
        i64 k;
        i64 m;
    if ((typedefx == (i64)0)) {
        for (k=(i64)29;k<=mm_decls$ntypes;++k) {
L348 :;
            if (!!((i64)mm_decls$ttisref[(k)])) {
                if (((i64)mm_decls$tttarget[(k)] == target)) {
                    return k;
                }
;
            }
;
L349 :;
        }
L350 :;
        ;
        m = mm_lib$createusertypefromstr(mm_lib$nextautotype());
    }
    else {
        m = typedefx;
    }
;
    mm_lib$storemode(owner,target,&mm_decls$tttarget[(m)]);
    mm_decls$ttbasetype[(m)] = (i64)7;
    mm_decls$ttsize[(m)] = (i64)mm_decls$ttsize[((i64)7)];
    mm_decls$ttisref[(m)] = (i64)1;
    mm_decls$ttcat[(m)] = (i64)1;
    return m;
}

i64 mm_lib$createrefprocmode(struct mm_decls$strec *owner,struct mm_decls$strec *stproc,struct mm_decls$strec *paramlist,i64 kwd,i64 prettype,i64 typedefx) {
        i64 m;
        i64 mproc;
    mproc = mm_lib$createusertype(stproc);
    (*stproc).paramlist = (struct mm_decls$strec *)paramlist;
    (*stproc).mode = prettype;
    mm_decls$ttbasetype[(mproc)] = (i64)23;
    if ((typedefx == (i64)0)) {
        m = mm_lib$createusertypefromstr(mm_lib$nextautotype());
    }
    else {
        m = typedefx;
    }
;
    mm_decls$tttarget[(m)] = mproc;
    mm_decls$ttbasetype[(m)] = (i64)7;
    mm_decls$ttsize[(m)] = (i64)mm_decls$ttsize[((i64)7)];
    mm_decls$ttisref[(m)] = (i64)1;
    mm_decls$ttcat[(m)] = (i64)1;
    return m;
}

void mm_lib$copyttvalues(i64 dest,i64 source) {
    mm_decls$ttsigned[(dest)] = (i64)mm_decls$ttsigned[(source)];
    mm_decls$ttisreal[(dest)] = (i64)mm_decls$ttisreal[(source)];
    mm_decls$ttisinteger[(dest)] = (i64)mm_decls$ttisinteger[(source)];
    mm_decls$ttisshort[(dest)] = (i64)mm_decls$ttisshort[(source)];
    mm_decls$ttisref[(dest)] = (i64)mm_decls$ttisref[(source)];
    mm_decls$ttcat[(dest)] = (i64)mm_decls$ttcat[(source)];
    mm_decls$ttisblock[(dest)] = (i64)mm_decls$ttisblock[(source)];
}

u8 *mm_lib$getdottedname(struct mm_decls$strec *p) {
        static u8 str[256];
        u8 str2[256];
        struct mm_decls$strec *  owner;
    strcpy((u8 *)str,(*p).name);
    owner = (struct mm_decls$strec *)(*p).owner;
    L351 :;
    while ((!!(owner) && ((i64)(*owner).nameid != (i64)1))) {
        strcpy((u8 *)str2,(u8 *)str);
        strcpy((u8 *)str,(*owner).name);
        strcat((u8 *)str,(byte*)".");
        strcat((u8 *)str,(u8 *)str2);
        owner = (struct mm_decls$strec *)(*owner).owner;
L352 :;
    }
L353 :;
    ;
    return (u8 *)str;
}

struct mm_decls$strec *mm_lib$getavname(struct mm_decls$strec *owner,i64 id) {
        struct mm_decls$strec *  p;
        u8 str[32];
        u8 *  name;
    if (((id == (i64)12) && ((i64)(*owner).nameid != (i64)6))) {
        mm_support$serror((byte*)"Auto frame not in proc");
    }
;
    if ((id == (i64)12)) {
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"$av_",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64(++(mm_lib$nextavindex),NULL);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"$sv_",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64(++(mm_lib$nextsvindex),NULL);
        msysc$m_print_end();
        ;
    }
;
    name = mlib$pcm_copyheapstring((u8 *)str);
    mm_lex$addnamestr(name);
    p = mm_lib$getduplnameptr(owner,(struct mm_decls$strec *)mm_lex$addnamestr(name),id);
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).mode = (i64)3;
    mm_lib$adddef(owner,p);
    return p;
}

void mm_lib$unionstr_clear(struct mm_decls$uflagsrec *u) {
    (*(u64 *)u) = (u64)0u;
}

void mm_lib$unionstr_append(struct mm_decls$uflagsrec *u,i64 c) {
    if (((i64)(*u).ulength == (i64)6)) {
        mm_support$serror((byte*)"Uflags overflow/a");
    }
;
    ++((*u).ulength);
    (*u).codes[((i64)(*u).ulength)-1] = c;
}

void mm_lib$unionstr_concat(struct mm_decls$uflagsrec *u,struct mm_decls$uflagsrec *v) {
        i64 ulen;
        i64 vlen;
        i64 i;
    ulen = (i64)(*u).ulength;
    vlen = (i64)(*v).ulength;
    if (((ulen + vlen) > (i64)7)) {
        mm_support$serror((byte*)"Uflags overflow/c");
    }
;
    for (i=(i64)1;i<=vlen;++i) {
L354 :;
        (*u).codes[((i + ulen))-1] = (i64)(*v).codes[(i)-1];
L355 :;
    }
L356 :;
    ;
    (*u).ulength = (ulen + vlen);
}

i64 mm_lib$unionstr_last(struct mm_decls$uflagsrec *u) {
    if (!!((i64)(*u).ulength)) {
        return (i64)(*u).codes[((i64)(*u).ulength)-1];
    }
;
    return (i64)0;
}

void mm_lib$unionstr_copy(struct mm_decls$uflagsrec *u,struct mm_decls$uflagsrec *v) {
    memcpy(u,v,(u64)8u);
}

i64 mm_lib$createrecordmode(struct mm_decls$strec *owner,i64 typedefx) {
        i64 m;
    if ((typedefx == (i64)0)) {
        m = mm_lib$createusertype(owner);
    }
    else {
        m = typedefx;
    }
;
    mm_decls$ttbasetype[(m)] = (i64)8;
    mm_decls$ttusercat[(m)] = (i64)1;
    mm_decls$ttcat[(m)] = (i64)5;
    mm_decls$ttisblock[(m)] = (i64)1;
    return m;
}

i64 mm_lib$createtuplemode(struct mm_decls$strec *owner,i64 (*elements)[],i64 elementslen,i64 typedefx) {
        i64 m;
        i64 i;
    if ((typedefx == (i64)0)) {
        m = mm_lib$createusertype(owner);
    }
    else {
        m = typedefx;
    }
;
    mm_decls$ttbasetype[(m)] = (i64)27;
    mm_decls$ttusercat[(m)] = (i64)1;
    mm_decls$ttlength[(m)] = elementslen;
    mm_decls$ttmult[(m)] = (i32 (*)[])mlib$pcm_alloc((elementslen * (i64)4));
    for (i=(i64)1;i<=elementslen;++i) {
L357 :;
        mm_lib$storemode(owner,(*elements)[(i)-1],&(*mm_decls$ttmult[(m)])[(i)-1]);
L358 :;
    }
L359 :;
    ;
    return m;
}

i64 mm_lib$convertstring(u8 *s,u8 *t) {
        i64 c;
        u8 *  t0;
    t0 = t;
    L360 :;
    while (!!((c = (i64)(u64)(*(s)++)))) {
        switch (c) {
        case 34:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = '"';
            }
            break;
        case 10:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'n';
            }
            break;
        case 13:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'c';
            }
            break;
        case 9:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 't';
            }
            break;
        case 92:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = (u64)92u;
            }
            break;
        case 7:;
        case 8:;
        case 26:;
        case 27:;
            {
                (*(t)++) = '<';
                (*(t)++) = (u64)((c / (i64)10) + (i64)48);
                (*(t)++) = (u64)((c % (i64)10) + (i64)48);
                (*(t)++) = '>';
            }
            break;
        default: {
            (*(t)++) = (u64)c;
        }
        } //SW
;
L361 :;
    }
L362 :;
    ;
    (*t) = (u64)0u;
    return (t - t0);
}

struct mlib$strbuffer *mm_lib$strexpr(struct mm_decls$unitrec *p) {
    mlib$gs_init((struct mlib$strbuffer *)mm_lib$exprstr);
    mm_lib$jevalx((struct mlib$strbuffer *)mm_lib$exprstr,(struct mm_decls$unitrec *)p);
    return (struct mlib$strbuffer *)mm_lib$exprstr;
}

void mm_lib$jevalx(struct mlib$strbuffer *dest,struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
        u8 str[500];
    if ((p == 0)) {
        return;
    }
;
    a = (*p).a;
    b = (*p).b;
    switch ((i64)(*p).tag) {
    case 1:;
        {
                        {i64 $temp = (i64)mm_decls$ttbasetype[((i64)(*p).mode)];
if (($temp==(i64)16) || ($temp==(i64)3) || ($temp==(i64)14) || ($temp==(i64)15)) {
                msysc$getstrint((*p).value,(u8 *)str);
            }
            else if (($temp==(i64)19) || ($temp==(i64)2) || ($temp==(i64)17) || ($temp==(i64)18)) {
                strcpy((u8 *)str,msysc$strword((*p).uvalue,0));
            }
            else if (($temp==(i64)12) || ($temp==(i64)1)) {
                str[((i64)1)-1] = (u64)(*p).uvalue;
                str[((i64)0)-1] = (u64)0u;
            }
            else if (($temp==(i64)5) || ($temp==(i64)4)) {
                msysc$m_print_startstr(str);
                msysc$m_print_r64((*p).xvalue,NULL);
                msysc$m_print_end();
                ;
            }
            else if (($temp==(i64)7)) {
                if ((((i64)(*p).mode == (i64)20) && !!((i64)(*p).isastring))) {
                    if (((i64)(*p).slength > (i64)250)) {
                        strcpy((u8 *)str,(byte*)"LONGSTR)");
                    }
                    else {
                        mm_lib$convertstring((*p).svalue,(u8 *)str);
                    }
;
                    mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"\"");
                    mm_support$gs_additem((struct mlib$strbuffer *)dest,(u8 *)str);
                    mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"\"");
                    return;
                }
                else {
                    msysc$m_print_startstr(str);
                    msysc$m_print_ptr((void *)(*p).value,NULL);
                    msysc$m_print_end();
                    ;
                }
;
            }
            else {
                strcpy((u8 *)str,(byte*)"<EVAL/CONST PROBABLY VOID>");
            }
            };
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(u8 *)str);
        }
        break;
    case 4:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(*(*p).def).name);
        }
        break;
    case 34:;
    case 32:;
        {
            strcpy((u8 *)str,mm_tables$pclnames[((i64)(*p).pclop)]);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(u8 *)str);
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)b);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 35:;
    case 17:;
    case 16:;
        {
            strcpy((u8 *)str,mm_tables$pclnames[((i64)(*p).pclop)]);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(u8 *)str);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
            if (((i64)(*a).tag == (i64)56)) {
                mm_support$gs_additem((struct mlib$strbuffer *)dest,mm_lib$strmode((*a).value,(i64)1));
            }
            else {
                mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            }
;
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 31:;
    case 90:;
        {
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
            q = b;
            L363 :;
            while (!!(q)) {
                mm_lib$jevalx(dest,(struct mm_decls$unitrec *)q);
                q = (*q).nextunit;
                if (!!(q)) {
                    mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)",");
                }
;
L364 :;
            }
L365 :;
            ;
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 44:;
    case 47:;
    case 45:;
    case 48:;
        {
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            if ((((i64)(*p).tag == (i64)47) || ((i64)(*p).tag == (i64)48))) {
                mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)".");
            }
;
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"[");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)b);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"]");
        }
        break;
    case 46:;
        {
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)".");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)b);
        }
        break;
    case 18:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
            q = a;
            L366 :;
            while (!!(q)) {
                mm_lib$jevalx(dest,(struct mm_decls$unitrec *)q);
                q = (*q).nextunit;
                if (!!(q)) {
                    mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)",");
                }
;
L367 :;
            }
L368 :;
            ;
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 19:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"..");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)b);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 26:;
        {
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)":=");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)b);
        }
        break;
    case 94:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"|");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)b);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"|");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)(*p).c);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 56:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,mm_lib$strmode((i64)(*p).mode,(i64)1));
        }
        break;
    case 52:;
    case 55:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,mm_lib$strmode((i64)(*p).convmode,(i64)1));
            if (((i64)(*p).tag == (i64)55)) {
                mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"@");
            }
;
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 53:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"shorten(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 54:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"cast(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 25:;
        {
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)":");
            if (!!(b)) {
                mm_lib$jevalx(dest,(struct mm_decls$unitrec *)(*p).b);
            }
            else {
                mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"-");
            }
;
        }
        break;
    case 49:;
        {
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"^");
        }
        break;
    case 42:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)",");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)b);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)",");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)(*p).c);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 6:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"<JBLOCK>");
        }
        break;
    case 2:;
        {
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"<nullunit>");
        }
        break;
    case 50:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"&");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            if (!!(b)) {
                mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"+");
                mlib$gs_strint((struct mlib$strbuffer *)dest,(*b).value);
            }
;
        }
        break;
    case 51:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"&.");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
        }
        break;
    case 62:;
        {
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)"TYPESTR(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mm_support$gs_additem((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 66:;
    case 69:;
    case 68:;
        {
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"$");
            mlib$gs_str((struct mlib$strbuffer *)dest,(mm_tables$jtagnames[((i64)(*p).tag)] + (i64)2));
        }
        break;
    case 63:;
        {
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)".");
            mlib$gs_str((struct mlib$strbuffer *)dest,mm_tables$bitfieldnames[((i64)(*p).bitopindex)-1]);
        }
        break;
    case 87:;
        {
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)":");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)b);
        }
        break;
    case 61:;
        {
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"typeof(");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 92:;
        {
            mlib$gs_str((struct mlib$strbuffer *)dest,(mm_tables$sysfnnames[((i64)(*p).fnindex)-1] + (i64)3));
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"(");
            if (!!(a)) {
                mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
            }
;
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)")");
        }
        break;
    case 38:;
        {
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"incr ");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
        }
        break;
    case 13:;
        {
            mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)"newstrinclude ");
            mm_lib$jevalx(dest,(struct mm_decls$unitrec *)a);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str(mm_tables$jtagnames[((i64)(*p).tag)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$gerror((byte*)"CAN'T DO JEVAL",(struct mm_decls$unitrec *)p);
    }
    } //SW
;
}

u8 *mm_lib$strmode(i64 m,i64 expand) {
        static u8 str[4096];
    mm_lib$istrmode(m,expand,(u8 *)str);
    return (u8 *)str;
}

u8 *mm_lib$strmode2(i64 m,i64 expand) {
        static u8 str[4096];
    mm_lib$istrmode(m,expand,(u8 *)str);
    return (u8 *)str;
}

void mm_lib$istrmode(i64 m,i64 expand,u8 *dest) {
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  q;
        i64 needcomma;
        i64 i;
        i64 target;
        i64 mbase;
        i64 n;
        struct mlib$strbuffer sxx;
        struct mlib$strbuffer *  xx;
        u8 strdim[100];
        u8 *  prefix;
        struct mm_decls$typenamerec tn;
    xx = (struct mlib$strbuffer *)&sxx;
    if ((m < (i64)0)) {
        strcpy(dest,(byte*)"*");
        tn = mm_decls$typenames[(-(m))];
        if ((tn.defb == 0)) {
            strcat(dest,(byte*)"typeof(");
            strcat(dest,(*tn.defa).name);
            strcat(dest,(byte*)")");
        }
        else {
            if (!!(tn.defa)) {
                strcat(dest,(*tn.defa).name);
                strcat(dest,(byte*)".");
            }
;
            strcat(dest,(*tn.def).name);
        }
;
        return;
    }
;
    if (((m < (i64)29) && (m != (i64)7))) {
        strcpy(dest,mm_lib$typename(m));
        return;
    }
;
        {i64 $temp = (mbase = (i64)mm_decls$ttbasetype[(m)]);
if (($temp==(i64)7)) {
        strcpy(dest,(byte*)"ref ");
        target = (i64)mm_decls$tttarget[(m)];
        if (((target >= (i64)0) && ((i64)mm_decls$ttbasetype[(target)] == (i64)8))) {
            strcat(dest,mm_lib$typename(target));
        }
        else {
            mm_lib$istrmode((i64)mm_decls$tttarget[(m)],(i64)0,(dest + strlen(dest)));
        }
;
    }
    else if (($temp==(i64)10)) {
        if (!!(mm_decls$ttdimexpr[(m)])) {
            mm_support$gs_copytostr((struct mlib$strbuffer *)mm_lib$strexpr((struct mm_decls$unitrec *)mm_decls$ttdimexpr[(m)]),(u8 *)strdim);
            msysc$m_print_startstr(dest);
            msysc$m_print_setfmt((byte*)"@[#]");
            msysc$m_print_str(strdim,NULL);
            msysc$m_print_end();
            ;
        }
        else {
            if (!!((i64)mm_decls$ttlength[(m)])) {
                if (((i64)mm_decls$ttlower[(m)] == (i64)1)) {
                    msysc$m_print_startstr(dest);
                    msysc$m_print_setfmt((byte*)"[#]");
                    msysc$m_print_i64((((i64)mm_decls$ttlength[(m)] + (i64)mm_decls$ttlower[(m)]) - (i64)1),NULL);
                    msysc$m_print_end();
                    ;
                }
                else {
                    msysc$m_print_startstr(dest);
                    msysc$m_print_setfmt((byte*)"[#..#]");
                    msysc$m_print_i64((i64)mm_decls$ttlower[(m)],NULL);
                    msysc$m_print_i64((((i64)mm_decls$ttlength[(m)] + (i64)mm_decls$ttlower[(m)]) - (i64)1),NULL);
                    msysc$m_print_end();
                    ;
                }
;
            }
            else {
                if (((i64)mm_decls$ttlower[(m)] == (i64)1)) {
                    msysc$m_print_startstr(dest);
                    msysc$m_print_setfmt((byte*)"[]");
                    msysc$m_print_end();
                    ;
                }
                else {
                    msysc$m_print_startstr(dest);
                    msysc$m_print_setfmt((byte*)"[#:]");
                    msysc$m_print_i64((i64)mm_decls$ttlower[(m)],NULL);
                    msysc$m_print_end();
                    ;
                }
;
            }
;
        }
;
        mm_lib$istrmode((i64)mm_decls$tttarget[(m)],(i64)0,(dest + strlen(dest)));
    }
    else if (($temp==(i64)11)) {
        prefix = mm_tables$stdnames[(mbase)];
        if (!!(mm_decls$ttdimexpr[(m)])) {
            mm_support$gs_copytostr((struct mlib$strbuffer *)mm_lib$strexpr((struct mm_decls$unitrec *)mm_decls$ttdimexpr[(m)]),(u8 *)strdim);
            msysc$m_print_startstr(dest);
            msysc$m_print_setfmt((byte*)"@#[#:]");
            msysc$m_print_str(prefix,NULL);
            msysc$m_print_str(strdim,NULL);
            msysc$m_print_end();
            ;
        }
        else {
            if (((i64)mm_decls$ttlower[(m)] == (i64)1)) {
                strcpy(dest,prefix);
                strcat(dest,(byte*)"[]");
            }
            else {
                msysc$m_print_startstr(dest);
                msysc$m_print_setfmt((byte*)"#[#:]");
                msysc$m_print_str(prefix,NULL);
                msysc$m_print_i64((i64)mm_decls$ttlower[(m)],NULL);
                msysc$m_print_end();
                ;
            }
;
        }
;
        mm_lib$istrmode((i64)mm_decls$tttarget[(m)],(i64)0,(dest + strlen(dest)));
    }
    else if (($temp==(i64)8)) {
        if (!(!!(expand))) {
            strcpy(dest,mm_lib$typename(m));
            return;
        }
;
        strcpy(dest,(byte*)"");
        if ((expand != (i64)2)) {
            strcat(dest,mm_lib$typename((i64)mm_decls$ttbasetype[(m)]));
        }
;
        strcat(dest,(byte*)"(");
        d = mm_decls$ttnamedef[(m)];
        needcomma = (i64)0;
        q = (struct mm_decls$strec *)(*d).deflist;
        L369 :;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat(dest,(byte*)",");
            }
;
            needcomma = (i64)1;
            mm_lib$istrmode((i64)(*q).mode,(i64)0,(dest + strlen(dest)));
            strcat(dest,(byte*)" ");
            strcat(dest,(*q).name);
L370 :;
            q = (struct mm_decls$strec *)(*q).nextdef;
L372 :;
                    }
L371 :;
        ;
        strcat(dest,(byte*)")");
    }
    else if (($temp==(i64)0)) {
        strcpy(dest,(byte*)"void");
    }
    else if (($temp==(i64)29)) {
        strcpy(dest,mm_lib$typename(m));
    }
    else if (($temp==(i64)23)) {
        d = mm_decls$ttnamedef[(m)];
        strcpy(dest,(byte*)"proc(");
        q = (struct mm_decls$strec *)(*d).paramlist;
        needcomma = (i64)0;
        L373 :;
        while ((q != 0)) {
            if (!!(needcomma)) {
                strcat(dest,(byte*)",");
            }
;
            needcomma = (i64)1;
            mm_lib$istrmode((i64)(*q).mode,(i64)0,(dest + strlen(dest)));
            strcat(dest,(byte*)" ");
            strcat(dest,(*q).name);
            q = (struct mm_decls$strec *)(*q).nextdef;
L374 :;
        }
L375 :;
        ;
        strcat(dest,(byte*)")");
        if (((i64)(*d).mode != (i64)0)) {
            mm_lib$istrmode((i64)(*d).mode,(i64)0,(dest + strlen(dest)));
        }
;
    }
    else if (($temp==(i64)27)) {
        strcpy(dest,(byte*)"Tuple(");
        n = (i64)mm_decls$ttlength[(m)];
        for (i=(i64)1;i<=n;++i) {
L376 :;
            mm_lib$istrmode((i64)(*mm_decls$ttmult[(m)])[(i)-1],(i64)0,(dest + strlen(dest)));
            if ((i < n)) {
                strcat(dest,(byte*)",");
            }
;
L377 :;
        }
L378 :;
        ;
        strcat(dest,(byte*)")");
    }
    else if (($temp==(i64)26)) {
        strcpy(dest,(byte*)"bitfield");
    }
    else {
        if (((i64)mm_decls$ttbasetype[(m)] < (i64)29)) {
            strcpy(dest,(byte*)"Alias for:");
            mm_lib$istrmode((i64)mm_decls$tttarget[(m)],(i64)0,(dest + strlen(dest)));
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(mm_lib$typename(m),NULL);
            msysc$m_print_str(mm_lib$strmode((i64)mm_decls$ttbasetype[(m)],(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$mcerror((byte*)"NEWSTRMODE");
        }
;
    }
    };
}

void mm_lib$addtoproclist(struct mm_decls$strec *d) {
        struct mm_decls$procrec *  pp;
    pp = (struct mm_decls$procrec *)mlib$pcm_alloc((i64)16);
    if ((mm_decls$proclist == 0)) {
        mm_decls$proclist = (mm_decls$proclistx = (struct mm_decls$procrec *)pp);
    }
    else {
        (*mm_decls$proclistx).nextproc = (struct mm_decls$procrec *)pp;
        mm_decls$proclistx = (struct mm_decls$procrec *)pp;
    }
;
    (*pp).def = d;
}

void mm_lib$addstatic(struct mm_decls$strec *d) {
        struct mm_decls$procrec *  pp;
    pp = (struct mm_decls$procrec *)mlib$pcm_alloc((i64)16);
    if ((mm_decls$staticlist == 0)) {
        mm_decls$staticlist = (mm_decls$staticlistx = (struct mm_decls$procrec *)pp);
    }
    else {
        (*mm_decls$staticlistx).nextproc = (struct mm_decls$procrec *)pp;
        mm_decls$staticlistx = (struct mm_decls$procrec *)pp;
    }
;
    (*pp).def = d;
}

void mm_lib$addexpconst(struct mm_decls$strec *d) {
        struct mm_decls$procrec *  pp;
    pp = (struct mm_decls$procrec *)mlib$pcm_alloc((i64)16);
    if ((mm_decls$constlist == 0)) {
        mm_decls$constlist = (mm_decls$constlistx = (struct mm_decls$procrec *)pp);
    }
    else {
        (*mm_decls$constlistx).nextproc = (struct mm_decls$procrec *)pp;
        mm_decls$constlistx = (struct mm_decls$procrec *)pp;
    }
;
    (*pp).def = d;
}

u8 *mm_lib$typename(i64 m) {
    if ((m >= (i64)0)) {
        return mm_decls$ttname[(m)];
    }
;
    return (*mm_decls$typenames[(-(m))].def).name;
}

struct mm_decls$unitrec *mm_lib$allocunitrec(void) {
        struct mm_decls$unitrec *  p;
    ++(mm_decls$nunits);
    if (!!((mm_lib$remainingunits)--)) {
        p = (struct mm_decls$unitrec *)mm_lib$unitheapptr;
        ++(mm_lib$unitheapptr);
        (*p).pos = (i64)mm_decls$lx.pos;
        (*p).moduleno = mm_decls$currmoduleno;
        (*p).subprogno = (i64)mm_decls$moduletosub[(mm_decls$currmoduleno)];
        return (struct mm_decls$unitrec *)p;
    }
;
    p = (struct mm_decls$unitrec *)(mm_lib$unitheapptr = (struct mm_decls$unitrec *)mlib$pcm_alloc((i64)2097152));
    memset(p,(i32)(i64)0,(u64)2097152u);
    mm_lib$remainingunits = (i64)32767;
    ++(mm_lib$unitheapptr);
    (*p).pos = (i64)mm_decls$lx.pos;
    (*p).moduleno = mm_decls$currmoduleno;
    (*p).subprogno = (i64)mm_decls$moduletosub[(mm_decls$currmoduleno)];
    return (struct mm_decls$unitrec *)p;
}

struct mm_decls$strec *mm_lib$createdupldef(struct mm_decls$strec *owner,struct mm_decls$strec *symptr,i64 id) {
        struct mm_decls$strec *  p;
    p = mm_lib$newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (i64)(*symptr).namelen;
    (*p).symbol = (i64)81;
    (*p).owner = (struct mm_decls$strec *)owner;
    (*p).nameid = id;
    (*p).nextdupl = (*symptr).nextdupl;
    (*symptr).nextdupl = (struct mm_decls$strec *)p;
    if (!!(owner)) {
        if (((*owner).deflist == 0)) {
            (*owner).deflist = (struct mm_decls$strec *)((*owner).deflistx = (struct mm_decls$strec *)p);
        }
        else {
            (*(*owner).deflistx).nextdef = (struct mm_decls$strec *)p;
            (*owner).deflistx = (struct mm_decls$strec *)p;
        }
;
    }
;
    return p;
}

struct mm_decls$strec *mm_lib$createnewmoduledef(struct mm_decls$strec *owner,struct mm_decls$strec *symptr,i64 id) {
    return mm_lib$createdupldef(owner,symptr,id);
}

struct mm_decls$unitrec *mm_lib$duplunit(struct mm_decls$unitrec *p,i64 lineno) {
        struct mm_decls$unitrec *  q;
        i64 $av_1;
        i64 i;
    if ((p == 0)) {
        return 0;
    }
;
    q = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)(*p).tag);
    (*q) = (*p);
    (*q).nextunit = 0;
        ($av_1 = (i64)mm_tables$jsubs[((i64)(*q).tag)]);
    for (i=(i64)1;i<=$av_1;++i) {
L379 :;
        (*q).abc[(i)-1] = mm_lib$duplunit((*q).abc[(i)-1],(i64)0);
L380 :;
    }
L381 :;
    ;
    return q;
}

i64 mm_lib$checkblockreturn(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  e;
        struct mm_decls$unitrec *  wt;
        i64 m;
    if ((p == 0)) {
        return (i64)0;
    }
;
    m = (i64)(*p).mode;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)91)) {
        return (i64)1;
    }
    else if (($temp==(i64)124)) {
        return (i64)1;
    }
    else if (($temp==(i64)94)) {
        (*p).ifretflag = (i64)1;
        e = (*p).b;
        L382 :;
        while (!!(e)) {
            if (!(!!(mm_lib$checkblockreturn(e)))) {
                return (i64)0;
            }
;
L383 :;
            e = (*e).nextunit;
L385 :;
                    }
L384 :;
        ;
        return mm_lib$checkblockreturn((*p).c);
    }
    else if (($temp==(i64)6)) {
        e = (*p).a;
        if (!!(e)) {
            L386 :;
            while ((!!(e) && !!((*e).nextunit))) {
                e = (*e).nextunit;
L387 :;
            }
L388 :;
            ;
            return mm_lib$checkblockreturn(e);
        }
;
    }
    else if (($temp==(i64)107) || ($temp==(i64)109) || ($temp==(i64)108) || ($temp==(i64)110)) {
        (*p).ifretflag = (i64)1;
        wt = (*p).b;
        L389 :;
        while (!!(wt)) {
            if (!(!!(mm_lib$checkblockreturn((*wt).b)))) {
                return (i64)0;
            }
;
            wt = (*wt).nextunit;
L390 :;
        }
L391 :;
        ;
        return mm_lib$checkblockreturn((*p).c);
    }
    else if (($temp==(i64)8)) {
        return (i64)1;
    }
    };
    if ((!!((i64)mm_tables$jisexpr[((i64)(*p).tag)]) && (m != (i64)0))) {
        if ((u64)0u) {
            mm_lib$insertunit(p,(i64)91);
            (*p).mode = m;
        }
;
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mm_lib$isconstunit(struct mm_decls$unitrec *a) {
    return (i64)(*a).isconst;
}

void mm_lib$getownername(struct mm_decls$strec *d,u8 *dest) {
        struct mm_decls$strec *  owner;
    owner = (struct mm_decls$strec *)(*d).owner;
    if (((owner == 0) || ((i64)(*owner).nameid == (i64)1))) {
        return;
    }
;
    mm_lib$getownername(owner,dest);
    strcat(dest,(*owner).name);
    strcat(dest,(byte*)".");
}

i64 mm_lib$getalignment(i64 m) {
        i64 a;
        {i64 $temp = (i64)mm_decls$ttbasetype[(m)];
if (($temp==(i64)10)) {
        return mm_lib$getalignment((i64)mm_decls$tttarget[(m)]);
    }
    else if (($temp==(i64)8)) {
        return (i64)8;
    }
    else {
        if (!!((i64)mm_decls$ttisblock[(m)])) {
            return (i64)8;
        }
;
    }
    };
    a = (i64)mm_decls$ttsize[(m)];
    if ((a==(i64)1) || (a==(i64)2) || (a==(i64)4) || (a==(i64)8)) {
        return a;
    }
    else if ((a==(i64)0)) {
        return (i64)8;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str(mm_lib$strmode(m,(i64)1),NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$gerror((byte*)"GETALIGN SIZE NOT 1248",0);
    return (i64)0;
}

i64 mm_lib$ispoweroftwo(i64 x) {
        i64 a;
        i64 n;
        i64 $av_1;
    a = (i64)1;
    n = (i64)0;
    $av_1 = (i64)60;
    while ($av_1-- > 0) {
L392 :;
        ++(n);
        a = (a << (i64)1);
        if ((a == x)) {
            return n;
        }
;
L393 :;
    }
L394 :;
    ;
    return (i64)0;
}

void mm_lib$addlistunit(struct mm_decls$unitrec **ulist,struct mm_decls$unitrec **ulistx,struct mm_decls$unitrec *p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    }
    else {
        (*(*ulistx)).nextunit = p;
    }
;
    (*ulistx) = p;
}

i64 mm_lib$storemode(struct mm_decls$strec *owner,i64 m,i32 *pmode) {
        struct mm_decls$typenamerec *  r;
    if ((m >= (i64)0)) {
        (*pmode) = m;
        return m;
    }
;
    r = &mm_decls$typenames[(-(m))];
    if (((*r).pmode == 0)) {
        (*r).owner = owner;
        (*pmode) = m;
        (*r).pmode = pmode;
        if (((*r).pmode == 0)) {
            mm_support$serror((byte*)"PMODE=NIL");
        }
;
        return m;
    }
;
    m = mm_lib$newtypename((*r).defa,(*r).defb);
    r = &mm_decls$typenames[(-(m))];
    (*r).owner = owner;
    (*pmode) = m;
    (*r).pmode = pmode;
    return m;
}

i64 mm_lib$gettypebase(i64 m) {
    switch ((i64)mm_decls$ttbasetype[(m)]) {
    case 14:;
    case 15:;
    case 16:;
        {
            return (i64)3;
        }
        break;
    case 17:;
    case 18:;
    case 19:;
        {
            return (i64)3;
        }
        break;
    case 4:;
        {
            return (i64)5;
        }
        break;
    case 12:;
        {
            return (i64)1;
        }
        break;
    default: {
        return m;
    }
    } //SW
;
}

void mm_lib$writegsfile(u8 *filename,struct mlib$strbuffer *d) {
        void *  f;
    f = fopen(filename,(byte*)"wb");
    mlib$gs_println((struct mlib$strbuffer *)d,f);
    fclose(f);
}

void mm_lib$addtolog(u8 *filename,void *logdest) {
        void *  f;
        i64 c;
    f = fopen(filename,(byte*)"rb");
    if ((f == 0)) {
        return;
    }
;
    L395 :;
    while (1) {
        c = fgetc(f);
        if ((c == (i64)-1)) {
            goto L396 ;
        }
;
        fputc((i32)c,logdest);
    }
L396 :;
    ;
    fclose(f);
}

struct mm_decls$strec *mm_lib$getprocretmodes(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  a;
    if (((i64)(*p).tag != (i64)31)) {
        mm_support$txerror((byte*)"multass/need multfn",0);
    }
;
    a = (*p).a;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)4)) {
        return (*a).def;
    }
    else {
        return mm_decls$ttnamedef[((i64)mm_decls$tttarget[((i64)(*a).mode)])];
    }
    };
}

i64 mm_lib$getmemmode(struct mm_decls$unitrec *p) {
    if (!!((i64)(*p).memmode)) {
        return (i64)(*p).memmode;
    }
;
    return (i64)(*p).mode;
}

i64 mm_lib$getpclmode(i64 t) {
        i64 u;
    u = (i64)mm_decls$ttbasetype[(t)];
    if ((u==(i64)1)) {
        u = (i64)2;
    }
    else if ((u==(i64)12)) {
        u = (i64)17;
    }
    else if ((u==(i64)8) || (u==(i64)10)) {
        if (!(!!((i64)mm_decls$ttisblock[(t)]))) {
                        {i64 $temp = (i64)mm_decls$ttsize[(t)];
if (($temp==(i64)8)) {
                u = (i64)2;
            }
            else if (($temp==(i64)4)) {
                u = (i64)19;
            }
            else if (($temp==(i64)2)) {
                u = (i64)18;
            }
            else {
                u = (i64)17;
            }
            };
        }
;
    }
;
    return u;
}

u8 *mm_lib$getfullname(struct mm_decls$strec *d) {
        static u8 str[128];
        struct mm_decls$strec *  chain[16];
        i64 n;
        struct mm_decls$strec *  e;
        i64 i;
    n = (i64)0;
    e = d;
    if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
        return (*d).name;
    }
;
    L397 :;
    do {
        chain[(++(n))-1] = e;
        e = (struct mm_decls$strec *)(*e).owner;
L398 :;
    }
    while (!((e == 0) || ((i64)(*e).nameid == (i64)1)));
L399 :;
    ;
    strcpy(str,(*chain[(n)-1]).name);
    for (i=(n - (i64)1);i>=(i64)1;--i) {
L400 :;
        strcat(str,(byte*)".");
        strcat(str,(*chain[(i)-1]).name);
L401 :;
    }
L402 :;
    ;
    return str;
}

u8 *mm_lib$getbasename(u8 *s) {
        u8 *  t;
    t = ((s + strlen(s)) - (i64)1);
    L403 :;
    while (((t > s) && ((u64)(*(t - (i64)1)) != '.'))) {
        --(t);
L404 :;
    }
L405 :;
    ;
    return t;
}

// START
void mm_lib$start(void) {

}

i64 mm_libsources$findsyslib(u8 *filename) {
        i64 i;
    if ((u64)0u) {
        return (i64)0;
    }
;
    filename = mlib$extractfile(filename);
    for (i=(i64)1;i<=(i64)5;++i) {
L406 :;
        if (!!(mlib$eqstring(mm_libsources$syslibnames[(i)-1],filename))) {
            if (!!((i64)mm_libsources$syslibfileno[(i)-1])) {
                return (i64)mm_libsources$syslibfileno[(i)-1];
            }
;
            if ((mm_decls$nsourcefiles >= (i64)1000)) {
                mm_support$loaderror((byte*)"fsl: too many files",(byte*)"",(byte*)"");
            }
;
            ++(mm_decls$nsourcefiles);
            mm_decls$sourcefilenames[(mm_decls$nsourcefiles)] = mlib$pcm_copyheapstring(filename);
            mm_decls$sourcefiletext[(mm_decls$nsourcefiles)] = mlib$pcm_copyheapstring(mm_libsources$libtext[(i)-1]);
            if (!!((i64)mm_decls$fwritema)) {
                mm_decls$sourcefiledupl[(mm_decls$nsourcefiles)] = mlib$pcm_copyheapstring(mm_libsources$libtext[(i)-1]);
            }
;
            mm_decls$sourcefilesizes[(mm_decls$nsourcefiles)] = strlen(mm_libsources$libtext[(i)-1]);
            mm_decls$sourcefilepaths[(mm_decls$nsourcefiles)] = (byte*)"";
            mm_decls$sourcefilespecs[(mm_decls$nsourcefiles)] = (byte*)"";
            mm_decls$sourcefilesys[(mm_decls$nsourcefiles)] = (i64)1;
            mm_decls$sourcefilesupport[(mm_decls$nsourcefiles)] = (i64)0;
            mm_libsources$syslibfileno[(i)-1] = mm_decls$nsourcefiles;
            return mm_decls$nsourcefiles;
        }
;
L407 :;
    }
L408 :;
    ;
    return (i64)0;
}

// START
void mm_libsources$start(void) {

}

void mm_modules$readprojectfile(u8 *filename) {
        i64 fileno;
        i64 headerdir;
        i64 dir;
        i64 oldsyslib;
        i64 found;
        u8 *  basefile;
        u8 *  extension;
    extension = mlib$convlcstring(mlib$extractext(filename,(i64)0));
    found = mlib$checkfile(filename);
    if ((!(!!(found)) && !(!!(mlib$eqstring(extension,(byte*)"ma"))))) {
        filename = mlib$pcm_copyheapstring(mlib$changeext(filename,(byte*)"ma"));
        found = mlib$checkfile(filename);
        if (!!(found)) {
            msysc$m_print_startcon();
            msysc$m_print_setfmt((byte*)"(Building #)");
            msysc$m_print_str(filename,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            extension = (byte*)"ma";
        }
;
    }
;
    if (!(!!(found))) {
        mm_support$loaderror((byte*)"Can't find main module or project: ##",filename,(byte*)"");
    }
;
    if (!!(mlib$eqstring(extension,(byte*)"ma"))) {
        filename = mm_modules$loadmafile(filename,0);
    }
;
    fileno = mm_support$getsupportfile(filename,(byte*)"",(byte*)"",(i64)0,(i64)0);
    basefile = mlib$extractbasefile(mm_decls$sourcefilenames[(fileno)]);
    mm_modules$initheadervars();
    mm_decls$headermode = (i64)1;
    headerdir = (i64)0;
    mm_decls$moduletable[((i64)0)].name = (byte*)"PROGRAM";
    mm_decls$moduletable[((i64)0)].fileno = (i64)0;
    mm_decls$stprogram = mm_lib$createdupldef(0,(struct mm_decls$strec *)mm_lex$addnamestr((byte*)"$prog"),(i64)1);
    mm_decls$moduletable[((i64)0)].stmodule = mm_decls$stprogram;
    mm_modules$addfirstsubprogram(basefile,fileno);
    mm_lex$startlex(fileno);
    L409 :;
    while (1) {
        mm_lex$lex();
        mm_parse$skipsemi();
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)153)) {
            headerdir = (i64)1;
            dir = (i64)mm_decls$lx.subcode;
            mm_modules$dirpos = (i64)mm_decls$lx.pos;
            mm_lex$lex();
            if ((dir==(i64)1)) {
                mm_modules$readmoduledir();
                mm_modules$headervars[((i64)8)-1] = (byte*)"";
            }
            else if ((dir==(i64)4)) {
                oldsyslib = mm_modules$issyslib;
                mm_modules$issyslib = (i64)1;
                mm_modules$readmoduledir();
                mm_modules$issyslib = oldsyslib;
                mm_modules$headervars[((i64)8)-1] = (byte*)"";
            }
            else if ((dir==(i64)3)) {
                mm_modules$altpathx = (byte*)"";
                mm_modules$issyslib = (i64)0;
                mm_modules$readsubprogram();
            }
            else if ((dir==(i64)6)) {
                if (((i64)(u64)(*mm_modules$importpathx) == (i64)0)) {
                    mm_modules$importpathx = mm_modules$headervars[((i64)1)-1];
                }
;
                mm_modules$issyslib = (i64)1;
                mm_modules$readsubprogram();
            }
            else if ((dir==(i64)2)) {
                if ((((i64)mm_decls$lx.symbol == (i64)81) && !!(mlib$eqstring((*mm_decls$lx.symptr).name,(byte*)"mlib")))) {
                    goto L411 ;
;
                }
;
                mm_modules$issyslib = (i64)0;
                mm_modules$altpathx = (byte*)"";
                mm_modules$readimport();
            }
            else if ((dir==(i64)7)) {
                mm_modules$readinclude();
            }
            else if ((dir==(i64)5)) {
                //$hdr_sysimport:
L411 :;
;
                if (((i64)(u64)(*mm_modules$importpathx) == (i64)0)) {
                    mm_modules$importpathx = mm_modules$headervars[((i64)1)-1];
                }
;
                mm_modules$issyslib = (i64)1;
                mm_modules$altpathx = (byte*)"";
                mm_modules$readimport();
            }
            else if ((dir==(i64)8)) {
                mm_modules$altpathx = mm_modules$fixpath(mm_modules$readvar());
            }
            else if ((dir==(i64)9)) {
                mm_modules$importpathx = mm_modules$fixpath(mm_modules$readvar());
                mm_modules$subprogpath = (!!((u64)(*mm_modules$importpathx)) ? mm_modules$importpathx : mm_modules$headerpathx);
            }
            else if ((dir==(i64)15)) {
                mm_modules$dosetvar();
            }
            else if ((dir==(i64)16)) {
                mm_modules$doshowvar();
            }
            else if ((dir==(i64)10)) {
                mm_modules$addlib(mm_modules$readvar(),(i64)68);
            }
            else if ((dir==(i64)11)) {
                mm_modules$addlib(mm_modules$readvar(),(i64)76);
            }
            else {
                mm_support$loaderror((byte*)"Hdr directive not ready:##",mm_tables$headerdirnames[(dir)-1],(byte*)"");
            }
;
            mm_parse$checksymbol((i64)6);
        }
        else if (($temp==(i64)6)) {
        }
        else if (($temp==(i64)68)) {
            goto L410 ;
        }
        else {
            if ((!!(mm_lex$sourcelevel) && !!(mm_lex$lximport))) {
                mm_modules$setmixedimport();
                mm_lex$unstacksource();
            }
            else {
                mm_modules$setmixedprogram(basefile);
                goto L410 ;
            }
;
        }
        };
    }
L410 :;
    ;
    if ((mm_decls$nmodules == (i64)0)) {
        mm_support$loaderror((byte*)"No modules specified",(byte*)"",(byte*)"");
    }
;
    mm_modules$addsyslib();
    mm_modules$addlib((byte*)"msvcrt",(i64)68);
    mm_modules$addlib((byte*)"user32",(i64)68);
    mm_modules$addlib((byte*)"gdi32",(i64)68);
    mm_modules$addlib((byte*)"kernel32",(i64)68);
}

static void mm_modules$initheadervars(void) {
        i64 i;
    for (i=(i64)1;i<=(i64)11;++i) {
L412 :;
        mm_modules$headervars[(i)-1] = (byte*)"";
L413 :;
    }
L414 :;
    ;
    mm_modules$headervars[((i64)1)-1] = (byte*)"C:/mx/";
    mm_modules$headervars[((i64)2)-1] = mlib$pcm_copyheapstring(mlib$extractpath(msysc$sysparams[((i64)1)-1]));
    mm_modules$subprogpath = (mm_modules$headerpathx = (mm_modules$headervars[((i64)3)-1] = mlib$pcm_copyheapstring(mm_decls$sourcefilepaths[((i64)1)])));
    if (!!((i64)mm_decls$fwindows)) {
        mm_modules$headervars[((i64)5)-1] = (byte*)"1";
    }
;
    mm_modules$headervars[((i64)8)-1] = (byte*)"1";
    if ((u64)0u) {
        mm_modules$headervars[((i64)4)-1] = (byte*)"1";
    }
;
}

static void mm_modules$readmoduledir(void) {
        u8 *  modulename;
        u8 *  modulefilespec;
        struct mm_decls$strec *  stalias;
    mm_parse$checksymbol((i64)81);
    modulename = (modulefilespec = mlib$pcm_copyheapstring((*mm_decls$lx.symptr).name));
    mlib$convlcstring(modulename);
    stalias = 0;
    mm_lex$lex();
    if ((((i64)mm_decls$lx.symbol == (i64)81) && !!(mlib$eqstring((*mm_decls$lx.symptr).name,(byte*)"as")))) {
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)81)) {
            stalias = (struct mm_decls$strec *)mm_decls$lx.symptr;
            mm_lex$lex();
        }
        else {
            stalias = (struct mm_decls$strec *)mm_lex$addnamestr(mm_modules$readvar());
        }
;
    }
;
    if (!!(mm_modules$checkwhen())) {
        mm_modules$addmodule(modulename,stalias);
    }
;
}

static i64 mm_modules$checkwhen(void) {
        i64 index;
    if (((i64)mm_decls$lx.symbol != (i64)110)) {
        return (i64)1;
    }
;
    mm_lex$lex();
    mm_parse$checksymbol((i64)154);
    index = (i64)mm_decls$lx.subcode;
    mm_lex$lex();
    return mlib$eqstring(mm_modules$headervars[(index)-1],(byte*)"1");
}

static void mm_modules$addmodule(u8 *modulename,struct mm_decls$strec *stalias) {
        struct mm_decls$modulerec *  pm;
        struct mm_decls$subprogrec *  ps;
        i64 i;
    for (i=(i64)1;i<=mm_decls$nmodules;++i) {
L415 :;
        if (!!(mlib$eqstring(mm_decls$moduletable[(i)].name,modulename))) {
            mm_support$loaderror((byte*)"Duplicate module name: # (Line:#)",modulename,msysc$strint(mm_support$getlineno((u64)mm_modules$dirpos),0));
        }
;
L416 :;
    }
L417 :;
    ;
    for (i=(i64)1;i<=mm_decls$nsubprogs;++i) {
L418 :;
        if (!!(mlib$eqstring(mm_decls$subprogtable[(i)].name,modulename))) {
            mm_support$loaderror((byte*)"Clashing subprog/module name: # (Line:#)",modulename,msysc$strint(mm_support$getlineno((u64)mm_modules$dirpos),0));
        }
;
L419 :;
    }
L420 :;
    ;
    if ((mm_decls$nmodules >= (i64)200)) {
        mm_support$loaderror((byte*)"Too many modules",modulename,(byte*)"");
    }
;
    pm = (struct mm_decls$modulerec *)&mm_decls$moduletable[(++(mm_decls$nmodules))];
    (*pm).name = mlib$pcm_copyheapstring(modulename);
    (*pm).subprogno = mm_decls$nsubprogs;
    (*pm).stmodule = (mm_decls$stmodule = mm_lib$createnewmoduledef(mm_decls$stprogram,(struct mm_decls$strec *)mm_lex$addnamestr(modulename),(i64)3));
    (*pm).path = (!!((u64)(*mm_modules$altpathx)) ? mm_modules$altpathx : mm_modules$subprogpath);
    (*pm).issyslib = mm_modules$issyslib;
    (*mm_decls$stmodule).moduleno = mm_decls$nmodules;
    (*mm_decls$stmodule).subprogno = mm_decls$nsubprogs;
    mm_decls$moduletosub[(mm_decls$nmodules)] = mm_decls$nsubprogs;
    ps = (struct mm_decls$subprogrec *)&mm_decls$subprogtable[(mm_decls$nsubprogs)];
    if (((i64)(*ps).firstmodule == (i64)0)) {
        (*ps).firstmodule = mm_decls$nmodules;
    }
;
    if (!!(stalias)) {
        (*pm).stmacro = mm_lib$getduplnameptr(mm_decls$stprogram,stalias,(i64)18);
        mm_lib$adddef(mm_decls$stprogram,(*pm).stmacro);
        (*(*pm).stmacro).paramlist = 0;
        (*(*pm).stmacro).code = (struct mm_decls$unitrec *)mm_lib$createname(mm_decls$stmodule);
    }
;
}

static void mm_modules$addsubprogram(u8 *subprogname,i64 fileno) {
        struct mm_decls$subprogrec *  ps;
        i64 i;
    if ((mm_decls$nsubprogs >= (i64)30)) {
        mm_support$loaderror((byte*)"Too many subprograms",subprogname,(byte*)"");
    }
;
    for (i=(i64)1;i<=mm_decls$nsubprogs;++i) {
L421 :;
        if (!!(mlib$eqstring(mm_decls$subprogtable[(i)].name,subprogname))) {
            mm_support$loaderror((byte*)"Duplicate subprog name: # (Line:#)",subprogname,msysc$strint(mm_support$getlineno((u64)mm_modules$dirpos),0));
        }
;
L422 :;
    }
L423 :;
    ;
    ps = (struct mm_decls$subprogrec *)&mm_decls$subprogtable[(++(mm_decls$nsubprogs))];
    (*ps).name = mlib$pcm_copyheapstring(subprogname);
    mm_modules$subprogpath = ((*ps).path = (!!((u64)(*mm_modules$importpathx)) ? mm_modules$importpathx : mm_modules$subprogpath));
    mm_decls$stsubprog = mm_lib$createnewmoduledef(mm_decls$stprogram,(struct mm_decls$strec *)mm_lex$addnamestr(subprogname),(i64)2);
    (*mm_decls$stsubprog).subprogno = mm_decls$nsubprogs;
    (*ps).stsubprog = mm_decls$stsubprog;
    (*ps).fileno = fileno;
    (*ps).issyslib = mm_modules$issyslib;
}

static void mm_modules$addfirstsubprogram(u8 *progname,i64 fileno) {
        struct mm_decls$subprogrec *  ps;
    mm_decls$nsubprogs = (i64)1;
    ps = (struct mm_decls$subprogrec *)&mm_decls$subprogtable[((i64)1)];
    (*ps).name = mlib$pcm_copyheapstring(progname);
    (*ps).path = mm_modules$headerpathx;
    mm_decls$stsubprog = mm_lib$createnewmoduledef(mm_decls$stprogram,(struct mm_decls$strec *)mm_lex$addnamestr(progname),(i64)2);
    (*mm_decls$stsubprog).subprogno = (i64)1;
    (*ps).stsubprog = mm_decls$stsubprog;
    (*ps).fileno = fileno;
    mm_decls$mainmoduleno = (i64)1;
}

static void mm_modules$readsubprogram(void) {
        u8 *  subprogname;
        u8 *  subprogfilespec;
    mm_parse$checksymbol((i64)81);
    subprogname = (subprogfilespec = mlib$pcm_copyheapstring((*mm_decls$lx.symptr).name));
    mlib$convlcstring(subprogname);
    mm_lex$lex();
    if (((i64)mm_decls$lx.symbol == (i64)110)) {
        mm_lex$lex();
        mm_lex$lex();
    }
;
    mm_modules$addsubprogram(subprogname,(i64)0);
}

static void mm_modules$readimport(void) {
        u8 *  subprogname;
        u8 *  path;
        i64 fileno;
    mm_parse$checksymbol((i64)81);
    subprogname = mlib$pcm_copyheapstring((*mm_decls$lx.symptr).name);
    mlib$convlcstring(subprogname);
    mm_lex$lex();
    path = (!!((u64)(*mm_modules$importpathx)) ? mm_modules$importpathx : mm_modules$subprogpath);
    fileno = mm_support$getsupportfile(subprogname,(byte*)"m",path,(i64)0,(i64)0);
    mm_modules$addsubprogram(subprogname,fileno);
    mm_lex$stacksource(fileno,(i64)0);
}

static void mm_modules$readinclude(void) {
        u8 *  name;
        i64 fileno;
    mm_parse$checksymbol((i64)77);
    name = mlib$pcm_copyheapstring(mm_decls$lx.svalue);
    mm_lex$lex();
    fileno = mm_support$getsupportfile(name,(byte*)"m",(byte*)"",(i64)0,(i64)0);
    mm_lex$stacksource(fileno,(i64)0);
}

static u8 *mm_modules$readvar(void) {
        u8 *  s;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)77)) {
        s = mlib$pcm_copyheapstring(mm_decls$lx.svalue);
    }
    else if (($temp==(i64)154)) {
        s = mm_modules$headervars[((i64)mm_decls$lx.subcode)-1];
    }
    else if (($temp==(i64)81)) {
        s = (*mm_decls$lx.symptr).name;
    }
    else {
        mm_support$loaderror((byte*)"readvar/bad expr",(byte*)"",(byte*)"");
        s = (byte*)"?";
    }
    };
    mm_lex$lex();
    return s;
}

static u8 *mm_modules$fixpath(u8 *path) {
        u8 newpath[300];
        i64 n;
    n = strlen(path);
    if ((n == (i64)0)) {
        return path;
    }
;
    if (((u64)(*((path + n) - (i64)1)) == (u64)92u || (u64)(*((path + n) - (i64)1)) == '/')) {
        return path;
    }
;
    strcpy(newpath,path);
    strcat(newpath,(byte*)"\\");
    return mlib$pcm_copyheapstring(newpath);
}

static void mm_modules$dosetvar(void) {
        i64 index;
    mm_parse$checksymbol((i64)154);
    index = (i64)mm_decls$lx.subcode;
    mm_lex$lex();
    mm_parse$checksymbol((i64)48);
    mm_lex$lex();
    mm_modules$headervars[(index)-1] = mm_modules$readvar();
}

static void mm_modules$doshowvar(void) {
    if (((i64)mm_decls$lx.symbol == (i64)77)) {
        msysc$m_print_startcon();
        msysc$m_print_str(mm_decls$lx.svalue,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        mm_parse$checksymbol((i64)154);
        msysc$m_print_startcon();
        msysc$m_print_str((mm_tables$headervarnames[((i64)mm_decls$lx.subcode)-1] + (i64)3),NULL);
        msysc$m_print_str((byte*)"=",NULL);
        msysc$m_print_str(mm_modules$headervars[((i64)mm_decls$lx.subcode)-1],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    mm_lex$lex();
}

static void mm_modules$setmixedprogram(u8 *basefile) {
        u8 name[100];
        i64 oldns;
    msysc$m_print_startstr(name);
    msysc$m_print_str((byte*)"$",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(basefile,NULL);
    msysc$m_print_end();
    ;
    oldns = mm_decls$nsubprogs;
    mm_decls$nsubprogs = (i64)1;
    mm_modules$addmodule(name,0);
    mm_decls$nsubprogs = oldns;
    mm_decls$moduletable[(mm_decls$nmodules)].fileno = (i64)1;
    mm_decls$mainmoduleno = (mm_decls$subprogtable[((i64)1)].firstmodule = mm_decls$nmodules);
}

static void mm_modules$setmixedimport(void) {
        u8 name[100];
    msysc$m_print_startstr(name);
    msysc$m_print_str((byte*)"$",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(mm_decls$subprogtable[(mm_decls$nsubprogs)].name,NULL);
    msysc$m_print_end();
    ;
    mm_modules$addmodule(name,0);
    mm_decls$moduletable[(mm_decls$nmodules)].fileno = mm_decls$subprogtable[(mm_decls$nsubprogs)].fileno;
    mm_decls$subprogtable[(mm_decls$nsubprogs)].firstmodule = mm_decls$nmodules;
}

void mm_modules$loadmodules(void) {
        struct mm_decls$modulerec *  pm;
        i64 i;
    for (i=(i64)1;i<=mm_decls$nmodules;++i) {
L424 :;
        pm = (struct mm_decls$modulerec *)&mm_decls$moduletable[(i)];
        mm_modules$loadmodule((struct mm_decls$modulerec *)pm);
L425 :;
    }
L426 :;
    ;
}

static void mm_modules$loadmodule(struct mm_decls$modulerec *pm) {
        u8 *  path;
    if (!!((i64)(*pm).fileno)) {
        return;
    }
;
    path = (*pm).path;
    if ((((i64)(u64)(*path) == (i64)0) && !!((i64)(*pm).issyslib))) {
        path = (byte*)"c:\\mx\\";
    }
;
    (*pm).fileno = mm_support$getsupportfile((*pm).name,(byte*)"m",path,(i64)(*pm).issyslib,(i64)0);
}

static void mm_modules$addsyslib(void) {
        i64 i;
    if (((i64)mm_decls$msyslevel == (i64)0)) {
        return;
    }
;
    for (i=(i64)1;i<=mm_decls$nsubprogs;++i) {
L427 :;
        if (!!(mlib$eqstring(mm_decls$subprogtable[(i)].name,(byte*)"mlibx"))) {
            return;
        }
;
L428 :;
    }
L429 :;
    ;
    mm_modules$issyslib = (i64)1;
    mm_modules$importpathx = mm_modules$headervars[((i64)1)-1];
    mm_modules$altpathx = (byte*)"";
    if (((i64)mm_decls$msyslevel == (i64)1)) {
        mm_modules$addsubprogram((byte*)"mlibmin",(i64)0);
        mm_modules$addmodule((byte*)"mmin",0);
        return;
    }
;
    mm_modules$addsubprogram((byte*)"mlibx",(i64)0);
    if ((u64)0u) {
        mm_modules$addmodule((byte*)"msysc",0);
        mm_modules$addmodule((byte*)"mlib",0);
        mm_modules$addmodule((byte*)"mclib",0);
        if (!!((i64)mm_decls$flinux)) {
            mm_modules$addmodule((byte*)"mlinux",0);
            mm_modules$addmodule((byte*)"mwindllc",0);
        }
        else {
            mm_modules$addmodule((byte*)"mwindows",0);
            mm_modules$addmodule((byte*)"mwindllc",0);
        }
;
    }
    else {
        mm_modules$addmodule((byte*)"msys",0);
        mm_modules$addmodule((byte*)"mlib",0);
        mm_modules$addmodule((byte*)"mclib",0);
        mm_modules$addmodule((byte*)"mwindows",0);
        mm_modules$addmodule((byte*)"mwindll",0);
    }
;
}

void mm_modules$addlib(u8 *libname,i64 libtype) {
        i64 i;
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L430 :;
        if (!!(mlib$eqstring(mm_decls$libfiles[(i)],libname))) {
            return;
        }
;
L431 :;
    }
L432 :;
    ;
    if ((mm_decls$nlibfiles >= (i64)50)) {
        mm_support$loaderror((byte*)"Too many libs",(byte*)"",(byte*)"");
    }
;
    mm_decls$libfiles[(++(mm_decls$nlibfiles))] = libname;
    mm_decls$libtypes[(mm_decls$nlibfiles)] = libtype;
}

static u8 *mm_modules$readfileline(u8 *s) {
        u8 str[2048];
        u8 *  t;
        i64 n;
        i64 c;
    t = str;
    n = (i64)0;
    L433 :;
        {i64 $temp = (c = (i64)(u64)(*(s)++));
if (($temp==(i64)0)) {
        --(s);
        goto L434 ;
    }
    else if (($temp==(i64)10)) {
        goto L434 ;
    }
    else {
        if ((n < (i64)2048)) {
            (*(t)++) = (u64)c;
        }
;
    }
    }goto L433 ;
L434 :;
    ;
    (*t) = (u64)0u;
    msysc$m_read_strline(str);
    ;
    return s;
}

static u8 *mm_modules$findnextlineheader(u8 *s) {
        i64 c;
    L435 :;
        {i64 $temp = (c = (i64)(u64)(*(s)++));
if (($temp==(i64)0)) {
        return 0;
    }
    else if (($temp==(i64)10)) {
        if (((((u64)(*s) == '=') && ((u64)(*(s + (i64)1)) == '=')) && ((u64)(*(s + (i64)2)) == '='))) {
            return (s + (i64)3);
        }
;
    }
    }goto L435 ;
L436 :;
    ;
    return (u8 *)0;
}

static u8 *mm_modules$loadmafile(u8 *filespec,u8 *builtinstr) {
        u8 *  s;
        u8 *  t;
        u8 name[100];
        u8 newfilespec[300];
        i64 sys;
        i64 support;
        i64 i;
    mm_decls$freadma = (i64)1;
    if (!!(filespec)) {
        s = (u8 *)mlib$readfile(filespec);
        if ((s == 0)) {
            mm_support$loaderror((byte*)"Can't find MA file ##",filespec,(byte*)"");
        }
;
        strcpy(newfilespec,mlib$extractpath(filespec));
    }
    else {
        s = builtinstr;
        newfilespec[((i64)1)-1] = (u64)0u;
    }
;
    s = mm_modules$readfileline((s + (i64)3));
    msysc$readstr(name,(i64)110,(i64)0);
    if (!(!!(mlib$eqstring(name,(byte*)"ma")))) {
        mm_support$loaderror((byte*)"MA: bad header",(byte*)"",(byte*)"");
    }
;
    --(s);
    if (!!(mm_decls$nsourcefiles)) {
        mm_support$loaderror((byte*)"MA/table not empty",(byte*)"",(byte*)"");
    }
;
    s = mm_modules$findnextlineheader(s);
    L437 :;
    while (1) {
        if ((s == 0)) {
            mm_support$loaderror((byte*)"Unexpected EOF in MA file",(byte*)"",(byte*)"");
            goto L438 ;
        }
;
        s = mm_modules$readfileline(s);
        msysc$readstr(name,(i64)110,(i64)0);
        {
            sys = msysc$m_read_i64((i64)0);
            ;
            support = msysc$m_read_i64((i64)0);
            ;
        }
        if (!!(mlib$eqstring(name,(byte*)"end"))) {
            goto L438 ;
        }
;
        if ((mm_decls$nsourcefiles >= (i64)1000)) {
            mm_support$loaderror((byte*)"Too many files in MA",(byte*)"",(byte*)"");
        }
;
        t = mm_modules$findnextlineheader(s);
        if ((t == 0)) {
            mm_support$loaderror((byte*)"MA error",(byte*)"",(byte*)"");
        }
;
        ++(mm_decls$nsourcefiles);
        mm_decls$sourcefilenames[(mm_decls$nsourcefiles)] = (mm_decls$sourcefilespecs[(mm_decls$nsourcefiles)] = mlib$pcm_copyheapstring(name));
        mm_decls$sourcefilesizes[(mm_decls$nsourcefiles)] = ((t - s) - (i64)3);
        mm_decls$sourcefiletext[(mm_decls$nsourcefiles)] = s;
        mm_decls$sourcefilepaths[(mm_decls$nsourcefiles)] = (byte*)"";
        mm_decls$sourcefilespecs[(mm_decls$nsourcefiles)] = (byte*)"";
        mm_decls$sourcefilesys[(mm_decls$nsourcefiles)] = sys;
        mm_decls$sourcefilesupport[(mm_decls$nsourcefiles)] = support;
        s = t;
    }
L438 :;
    ;
    for (i=(i64)1;i<=mm_decls$nsourcefiles;++i) {
L439 :;
        (*(mm_decls$sourcefiletext[(i)] + mm_decls$sourcefilesizes[(i)])) = (u64)0u;
L440 :;
    }
L441 :;
    ;
    strcat(newfilespec,mm_decls$sourcefilenames[((i64)1)]);
    return mlib$pcm_copyheapstring(newfilespec);
}

// START
void mm_modules$start(void) {

}

void mm_name$rx_typetable(void) {
        struct mm_decls$strec *  d;
        i64 i;
    for (i=(i64)29;i<=mm_decls$ntypes;++i) {
L442 :;
        if (((i64)mm_decls$ttbasetype[(i)] == (i64)8)) {
            d = mm_decls$ttnamedef[(i)];
            if (!!((i64)(*d).baseclass)) {
                mm_name$do_baseclass(d);
            }
;
        }
;
L443 :;
    }
L444 :;
    ;
}

void mm_name$rx_unit(struct mm_decls$strec *owner,struct mm_decls$unitrec *p) {
        struct mm_decls$strec *  d;
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
        i64 n;
        i64 oldnoexpand;
        i64 oldnoassem;
        i64 oldtag;
        i64 useparams;
        i64 $av_1;
        i64 i;
    a = (*p).a;
    b = (*p).b;
    mm_tables$mlineno = (i64)(*p).pos;
    switch ((i64)(*p).tag) {
    case 4:;
        {
            mm_name$resolvename(owner,p);
            if (((((i64)(*p).tag == (i64)4) && ((i64)(*(*p).def).nameid == (i64)18)) && !(!!(mm_name$noexpand)))) {
                ++(mm_name$macrolevels);
                mm_name$expandmacro(p,p,0);
                mm_name$rx_unit(owner,p);
                --(mm_name$macrolevels);
            }
;
        }
        break;
    case 24:;
        {
            mm_name$rx_unit(owner,b);
        }
        break;
    case 46:;
        {
            mm_name$resolvedot(owner,p);
        }
        break;
    case 90:;
    case 31:;
        {
            oldtag = (i64)(*p).tag;
            if (((i64)(*a).tag == (i64)4)) {
                oldnoexpand = mm_name$noexpand;
                mm_name$noexpand = (i64)1;
                mm_name$rx_unit(owner,a);
                mm_name$noexpand = oldnoexpand;
            }
            else {
                mm_name$rx_unit(owner,a);
            }
;
            mm_name$rx_unitlist(owner,b);
            if (((i64)(*a).tag == (i64)4)) {
                d = (*a).def;
                                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)5)) {
                    (*p).tag = (i64)52;
                    mm_lib$storemode(owner,(i64)(*d).mode,&(*p).convmode);
                    (*p).a = b;
                    if (!!((*b).nextunit)) {
                        (*p).a = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)18,(struct mm_decls$unitrec *)b);
                        n = (i64)0;
                        L445 :;
                        while (!!(b)) {
                            ++(n);
                            b = (*b).nextunit;
L446 :;
                        }
L447 :;
                        ;
                        (*(*p).a).length = n;
                    }
;
                }
                else if (($temp==(i64)18)) {
                    ++(mm_name$macrolevels);
                    if (!!((*d).deflist)) {
                        mm_name$expandmacro(p,a,b);
                        b = 0;
                        useparams = (i64)0;
                    }
                    else {
                        mm_name$expandmacro(p,a,0);
                        useparams = (i64)1;
                    }
;
                    mm_name$rx_unit(owner,p);
                    --(mm_name$macrolevels);
                    if ((!!(useparams) && !(((i64)(*p).tag == (i64)90 || (i64)(*p).tag == (i64)31)))) {
                        mm_lib$insertunit(p,oldtag);
                        (*p).b = b;
                    }
;
                }
                else {
                    if (((i64)(*d).mode == (i64)0)) {
                        (*p).tag = (i64)90;
                    }
;
                }
                };
            }
;
        }
        break;
    case 14:;
    case 15:;
        {
            mm_name$rx_unit(owner,a);
            mm_name$rx_unit(owner,b);
            if (!(!!((i64)mm_tables$isbooltag[((i64)(*a).tag)]))) {
                mm_lib$insertunit(a,(i64)17);
                (*a).pclop = (i64)33;
            }
;
            if (!(!!((i64)mm_tables$isbooltag[((i64)(*b).tag)]))) {
                mm_lib$insertunit(b,(i64)17);
                (*b).pclop = (i64)33;
            }
;
        }
        break;
    case 17:;
        {
            //doistruel:
L448 :;
;
            mm_name$rx_unit(owner,a);
            if (!!((i64)mm_tables$isbooltag[((i64)(*a).tag)])) {
                mm_lib$deleteunit(p,a);
            }
;
            goto L449 ;
;
        }
        break;
    case 16:;
        {
            mm_name$rx_unit(owner,a);
            if (((i64)(*a).tag == (i64)16)) {
                mm_lib$deleteunit(p,a);
                (*p).tag = (i64)17;
                (*p).pclop = (i64)33;
                a = (*p).a;
                goto L448 ;
;
            }
;
            if (!(!!((i64)mm_tables$isbooltag[((i64)(*a).tag)]))) {
                mm_lib$insertunit(a,(i64)17);
                (*a).pclop = (i64)33;
                a = (*p).a;
            }
;
            goto L449 ;
;
        }
        break;
    case 9:;
        {
            mm_name$resolvename(owner,a);
            if (!(!!(mm_name$noexpand))) {
                ++(mm_name$macrolevels);
                oldnoassem = mm_name$noassem;
                mm_name$noassem = (i64)1;
                mm_name$expandmacro(p,a,b);
                mm_name$noassem = oldnoassem;
                mm_name$rx_unit(owner,p);
                --(mm_name$macrolevels);
            }
;
        }
        break;
    default: {
        //doabc:
L449 :;
;
                ($av_1 = (i64)mm_tables$jsubs[((i64)(*p).tag)]);
        for (i=(i64)1;i<=$av_1;++i) {
L450 :;
            mm_name$rx_unitlist(owner,(*p).abc[(i)-1]);
L451 :;
        }
L452 :;
        ;
    }
    } //SW
;
}

i64 mm_name$rx_module(i64 n) {
    mm_decls$currmoduleno = n;
    mm_name$rx_passdef(mm_decls$stprogram,mm_decls$moduletable[(n)].stmodule);
    return (i64)1;
}

void mm_name$rx_deflist(struct mm_decls$strec *owner,struct mm_decls$strec *p) {
        struct mm_decls$strec *  pstart;
    pstart = p;
    L453 :;
    while (!!(p)) {
        mm_name$rx_passdef(owner,p);
        p = (struct mm_decls$strec *)(*p).nextdef;
L454 :;
    }
L455 :;
    ;
}

void mm_name$rx_passdef(struct mm_decls$strec *owner,struct mm_decls$strec *p) {
        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)3) || ($temp==(i64)4)) {
        mm_name$rx_deflist(p,(struct mm_decls$strec *)(*p).deflist);
    }
    else if (($temp==(i64)6)) {
        mm_name$rx_deflist(p,(struct mm_decls$strec *)(*p).deflist);
        mm_name$currstproc = p;
        mm_name$rx_unit(p,(*p).code);
        mm_name$currstproc = 0;
    }
    else if (($temp==(i64)7)) {
        mm_name$rx_deflist(p,(struct mm_decls$strec *)(*p).deflist);
    }
    else if (($temp==(i64)10) || ($temp==(i64)11) || ($temp==(i64)12) || ($temp==(i64)13)) {
        if (!!(msysc$m_getdotindex((i64)(*p).flags,(i64)10))) {
            mm_name$rx_unit(owner,(*p).equivvar);
        }
;
        if (!!((*p).code)) {
            mm_name$rx_unit(owner,(*p).code);
        }
;
    }
    else if (($temp==(i64)5)) {
        mm_name$rx_deflist(p,(struct mm_decls$strec *)(*p).deflist);
    }
    else {
    }
    };
}

static void mm_name$rx_unitlist(struct mm_decls$strec *owner,struct mm_decls$unitrec *p) {
    L456 :;
    while (!!(p)) {
        mm_name$rx_unit(owner,p);
        p = (*p).nextunit;
L457 :;
    }
L458 :;
    ;
}

struct mm_decls$strec *mm_name$resolvetopname(struct mm_decls$strec *owner,struct mm_decls$strec *stnewname,i64 moduleno,i64 allowmod) {
        i64 extcount;
        i64 subprogno;
        struct mm_decls$strec *  p;
        struct mm_decls$strec *  q;
        struct mm_decls$strec *  powner;
        struct mm_decls$strec *  extdef;
        struct mm_decls$strec *  moddef;
        struct mm_decls$strec *  ambiglist[10];
        i64 i;
    if (((i64)(*owner).nameid == (i64)6)) {
        q = (struct mm_decls$strec *)(*owner).deflist;
        L459 :;
        while (!!(q)) {
            if (((*q).firstdupl == stnewname)) {
                return q;
            }
;
L460 :;
            q = (struct mm_decls$strec *)(*q).nextdef;
L462 :;
                    }
L461 :;
        ;
    }
;
    p = (struct mm_decls$strec *)(*stnewname).nextdupl;
    subprogno = (i64)mm_decls$moduletosub[(moduleno)];
    extcount = (i64)0;
    extdef = (moddef = 0);
    L463 :;
    while (!!(p)) {
        powner = (struct mm_decls$strec *)(*p).owner;
        switch ((i64)(*powner).nameid) {
        case 3:;
            {
                if (((i64)(*powner).moduleno == moduleno)) {
                    return p;
                }
                else if (!!((i64)(*p).scope)) {
                    if (((((i64)(*powner).subprogno == subprogno) || ((i64)(*p).scope == (i64)2)) || !!(msysc$m_getdotindex((i64)(*p).flags,(i64)12)))) {
                        ++(extcount);
                        extdef = p;
                        if ((extcount < (i64)10)) {
                            ambiglist[(extcount)-1] = extdef;
                        }
;
                    }
;
                }
;
            }
            break;
        case 5:;
            {
                if (((powner == owner) || (powner == (*owner).owner))) {
                    return p;
                }
;
            }
            break;
        case 1:;
            {
                                {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)3) || ($temp==(i64)2)) {
                    moddef = p;
                }
                else if (($temp==(i64)18)) {
                    return p;
                }
                };
            }
            break;
        } //SW
;
L464 :;
        p = (struct mm_decls$strec *)(*p).nextdupl;
L466 :;
            }
L465 :;
    ;
    if ((!!(allowmod) && !!(moddef))) {
        return moddef;
    }
;
    if (!!(extdef)) {
        if ((extcount > (i64)1)) {
            for (i=(i64)1;i<=extcount;++i) {
L467 :;
                extdef = ambiglist[(i)-1];
                msysc$m_print_startcon();
                msysc$m_print_i64(i,NULL);
                msysc$m_print_str((*(*extdef).owner).name,NULL);
                msysc$m_print_str(mm_tables$namenames[((i64)(*(*extdef).owner).nameid)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
L468 :;
            }
L469 :;
            ;
            mm_support$rxerror_s((byte*)"Ambiguous ext name: #",(*extdef).name,0);
        }
;
        return extdef;
    }
;
    return (struct mm_decls$strec *)0;
}

void mm_name$resolvename(struct mm_decls$strec *owner,struct mm_decls$unitrec *p) {
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
        i64 moduleno;
        i64 mode;
        i64 islet;
        u8 str[300];
    d = (*p).def;
    moduleno = (i64)(*p).moduleno;
    if (((i64)(*d).nameid != (i64)0)) {
        return;
    }
;
    e = mm_name$resolvetopname(owner,d,moduleno,mm_name$allowmodname);
    if (!(!!(e))) {
        islet = (i64)0;
        mode = (i64)0;
                {i64 $temp = (i64)(*p).avcode;
if (($temp==(i64)73) || ($temp==(i64)84) || ($temp==(i64)83)) {
            mode = (i64)3;
            islet = (i64)1;
        }
        else if (($temp==(i64)76) || ($temp==(i64)65)) {
            mode = (i64)22;
        }
        };
        if ((mode == (i64)0)) {
            strcpy(str,(*d).name);
            mlib$convucstring(str);
            mm_support$rxerror_s((byte*)"pcl:Undefined: #",str,p);
        }
        else {
            e = mm_name$addframevar(owner,d,moduleno,mode);
            (*e).pos = (i64)(*p).pos;
            (*e).flags = msysc$m_setdotindex((*e).flags,(i64)4,(u64)islet);
        }
;
    }
;
    (*e).flags = msysc$m_setdotindex((*e).flags,(i64)1,(u64)1u);
    (*p).def = e;
}

struct mm_decls$strec *mm_name$finddupl(struct mm_decls$strec *d,struct mm_decls$strec *pdupl) {
    if (((i64)(*pdupl).nameid != (i64)0)) {
        return pdupl;
    }
;
    pdupl = (struct mm_decls$strec *)(*pdupl).nextdupl;
    L470 :;
    while (!!(pdupl)) {
        if (((*pdupl).owner == d)) {
            return pdupl;
        }
;
        pdupl = (struct mm_decls$strec *)(*pdupl).nextdupl;
L471 :;
    }
L472 :;
    ;
    return (struct mm_decls$strec *)0;
}

struct mm_decls$strec *mm_name$finddupl_sub(struct mm_decls$strec *d,struct mm_decls$strec *pdupl) {
        i64 subprogno;
    if (((i64)(*pdupl).nameid != (i64)0)) {
        return pdupl;
    }
;
    pdupl = (struct mm_decls$strec *)(*pdupl).nextdupl;
    subprogno = (i64)(*d).subprogno;
    L473 :;
    while (!!(pdupl)) {
        if (((i64)(*(*pdupl).owner).subprogno == subprogno)) {
            return pdupl;
        }
;
        pdupl = (struct mm_decls$strec *)(*pdupl).nextdupl;
L474 :;
    }
L475 :;
    ;
    return (struct mm_decls$strec *)0;
}

static void mm_name$resolvedot(struct mm_decls$strec *owner,struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  lhs;
        struct mm_decls$unitrec *  rhs;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
        struct mm_decls$strec *  t;
        i64 m;
        i64 moduleno;
        i64 subprogno;
        i64 oldallowmod;
    moduleno = (i64)(*p).moduleno;
    subprogno = (i64)(*p).subprogno;
    lhs = (*p).a;
    rhs = (*p).b;
    e = (*rhs).def;
    oldallowmod = mm_name$allowmodname;
    mm_name$allowmodname = (i64)((i64)(*lhs).tag == (i64)4);
    mm_name$rx_unit(owner,lhs);
    mm_name$allowmodname = oldallowmod;
        {i64 $temp = (i64)(*lhs).tag;
if (($temp==(i64)4)) {
        d = (*lhs).def;
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)3) || ($temp==(i64)5) || ($temp==(i64)6) || ($temp==(i64)5)) {
            e = mm_name$finddupl(d,e);
            if (!!(e)) {
                if (((i64)(*d).nameid == (i64)3)) {
                    if (((i64)(*e).subprogno != subprogno)) {
                        if (((i64)(*e).scope < (i64)2)) {
                            mm_support$rxerror_s((byte*)"Need export to import '#'",(*e).name,0);
                        }
;
                    }
                    else if (((i64)(*e).moduleno != moduleno)) {
                        if (!(!!((i64)(*e).scope))) {
                            mm_support$rxerror_s((byte*)"Need global to import '#'",(*e).name,0);
                        }
;
                    }
;
                }
;
                //domodule:
L476 :;
;
                (*p).tag = (i64)4;
                (*p).a = ((*p).b = 0);
                (*p).def = e;
                                {i64 $temp = (i64)(*e).nameid;
if (($temp==(i64)16)) {
                }
                else if (($temp==(i64)10)) {
                }
                };
            }
            else {
                mm_support$rxerror_s((byte*)"Can't resolve .#",(*(*(*p).b).def).name,p);
            }
;
        }
        else if (($temp==(i64)12) || ($temp==(i64)11) || ($temp==(i64)13)) {
            m = (i64)(*d).mode;
                        {i64 $temp = (i64)mm_decls$ttbasetype[(m)];
if (($temp==(i64)8)) {
            }
            else if (($temp==(i64)7)) {
                L477 :;
                while (1) {
                    m = (i64)mm_decls$tttarget[(m)];
                                        {i64 $temp = (i64)mm_decls$ttbasetype[(m)];
if (($temp==(i64)8)) {
                        goto L478 ;
                    }
                    else if (($temp==(i64)7)) {
                    }
                    else {
                        mm_support$rxerror((byte*)"2:Record expected",0);
                    }
                    };
                }
L478 :;
                ;
            }
            else {
                mm_support$rxerror((byte*)"Record expected",0);
            }
            };
            t = mm_decls$ttnamedef[(m)];
            e = mm_name$finddupl(t,e);
            if (!!(e)) {
                (*(*p).b).def = e;
            }
            else {
                mm_support$rxerror_s((byte*)"Not a field: #",(*(*rhs).def).name,0);
            }
;
        }
        else if (($temp==(i64)2)) {
            e = mm_name$finddupl_sub(d,e);
            if (!!(e)) {
                if (((i64)(*e).subprogno != subprogno)) {
                    if (((i64)(*e).scope < (i64)2)) {
                        mm_support$rxerror_s((byte*)"Need export to import '#'",(*e).name,0);
                    }
;
                }
;
                goto L476 ;
;
            }
            else {
                mm_support$rxerror_s((byte*)"Can't resolve sub.#",(*(*(*p).b).def).name,p);
            }
;
        }
        };
    }
    else {
        if (!(!!((*e).nextdupl))) {
            mm_support$rxerror_s((byte*)"Not a field: #",(*e).name,0);
        }
;
    }
    };
}

static void mm_name$fixmode(struct mm_decls$typenamerec *p) {
        i32 *  pmode;
        struct mm_decls$strec *  a;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
        struct mm_decls$strec *  f;
        struct mm_decls$strec *  owner;
        i64 m;
        i64 moduleno;
    pmode = (*p).pmode;
    m = -((i64)(*pmode));
    d = (owner = (*p).owner);
    L479 :;
    while (((i64)(*d).nameid != (i64)3)) {
        d = (struct mm_decls$strec *)(*d).owner;
L480 :;
    }
L481 :;
    ;
    moduleno = (i64)(*d).moduleno;
    a = (*p).defa;
    d = (*p).defb;
    if (((a == 0) && !!(d))) {
        e = mm_name$resolvetopname(owner,d,moduleno,(i64)0);
    }
    else if (((d == 0) && !!(a))) {
        mm_support$rxerror((byte*)"Fixmode can't do typeof yet",0);
    }
    else {
        e = mm_name$resolvetopname(owner,a,moduleno,(i64)0);
        if (!!(e)) {
            f = (struct mm_decls$strec *)(*e).deflist;
            e = 0;
            L482 :;
            while (!!(f)) {
                if ((((i64)(*f).nameid == (i64)5) && ((*f).firstdupl == d))) {
                    e = f;
                    goto L484 ;
                }
;
                f = (struct mm_decls$strec *)(*f).nextdef;
L483 :;
            }
L484 :;
            ;
        }
;
    }
;
    if ((!!(e) && ((i64)(*e).nameid == (i64)5))) {
        (*pmode) = (i64)(*e).mode;
    }
    else {
        mm_support$rxerror_s((byte*)"2:Can't resolve tentative type: #",(*d).name,0);
    }
;
}

void mm_name$fixusertypes(void) {
        struct mm_decls$typenamerec *  p;
        i64 npasses;
        i64 notresolved;
        struct mm_decls$strec *  d;
        i64 i;
    npasses = (i64)0;
    L485 :;
    do {
        ++(npasses);
        notresolved = (i64)0;
        for (i=(i64)1;i<=mm_decls$ntypenames;++i) {
L488 :;
            p = (struct mm_decls$typenamerec *)&mm_decls$typenames[(i)];
            if (((i64)(*(*p).pmode) < (i64)0)) {
                mm_tables$mlineno = (i64)mm_decls$typenamepos[(i)].pos;
                mm_name$fixmode((struct mm_decls$typenamerec *)p);
                if (((i64)(*(*p).pmode) < (i64)0)) {
                    ++(notresolved);
                }
;
            }
;
L489 :;
        }
L490 :;
        ;
        if ((npasses > (i64)5)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Type phase errors - check these user types:",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            for (i=(i64)1;i<=mm_decls$ntypenames;++i) {
L491 :;
                p = (struct mm_decls$typenamerec *)&mm_decls$typenames[(i)];
                if (((i64)(*(*p).pmode) < (i64)0)) {
                    d = (*p).defb;
                    if ((d == 0)) {
                        d = (*p).defa;
                    }
;
                    msysc$m_print_startcon();
                    msysc$m_print_str((byte*)"\t",NULL);
                    msysc$m_print_str((*d).name,NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                }
;
L492 :;
            }
L493 :;
            ;
            mm_support$rxerror((byte*)"Fixtypes: too many passes (cyclic ref?)",0);
        }
;
L486 :;
    }
    while (!(notresolved == (i64)0));
L487 :;
    ;
}

static struct mm_decls$strec *mm_name$addframevar(struct mm_decls$strec *owner,struct mm_decls$strec *d,i64 moduleno,i64 mode) {
        struct mm_decls$strec *  e;
    e = mm_lib$getduplnameptr(owner,d,(i64)12);
    mm_lib$storemode(owner,mode,&(*e).mode);
    mm_lib$adddef(owner,e);
    return e;
}

static struct mm_decls$unitrec *mm_name$copylistunit(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  plist;
        struct mm_decls$unitrec *  plistx;
    plist = (plistx = 0);
    L494 :;
    while (!!(p)) {
        q = mm_name$copyunit(p);
        mm_lib$addlistunit(&plist,&plistx,q);
        p = (*p).nextunit;
L495 :;
    }
L496 :;
    ;
    return plist;
}

static struct mm_decls$unitrec *mm_name$copyunit(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  q;
        struct mm_decls$strec *  d;
        i64 $av_1;
        i64 i;
    if ((p == 0)) {
        return 0;
    }
;
    if (((i64)(*p).tag == (i64)4)) {
        d = (*p).def;
        for (i=(i64)1;i<=mm_name$nmacroparams;++i) {
L497 :;
            if ((mm_name$macroparamsgen[(i)-1] == d)) {
                return mm_name$copyunit(mm_name$macroargs[(i)-1]);
                goto L499 ;
            }
;
L498 :;
        }
L499 :;
        ;
    }
;
    q = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)(*p).tag);
    (*q) = (*p);
    (*q).nextunit = 0;
        ($av_1 = (i64)mm_tables$jsubs[((i64)(*q).tag)]);
    for (i=(i64)1;i<=$av_1;++i) {
L500 :;
        (*q).abc[(i)-1] = mm_name$copylistunit((*q).abc[(i)-1]);
L501 :;
    }
L502 :;
    ;
    return q;
}

static void mm_name$replaceunit(struct mm_decls$unitrec *p,struct mm_decls$unitrec *q) {
        struct mm_decls$unitrec *  pnext;
    pnext = (*p).nextunit;
    (*p) = (*q);
    (*p).nextunit = pnext;
}

static void mm_name$expandmacro(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  pm;
        struct mm_decls$unitrec *  pnew;
        i64 ignoreargs;
    if ((mm_name$macrolevels > (i64)10)) {
        mm_support$rxerror((byte*)"Too many macro levels (recursive macro?)",0);
    }
;
    d = (*a).def;
    pm = (struct mm_decls$strec *)(*d).paramlist;
    mm_name$nmacroparams = (i64)0;
    L503 :;
    while (!!(pm)) {
        if ((mm_name$nmacroparams >= (i64)50)) {
            mm_support$rxerror((byte*)"macro param overflow",0);
        }
;
        mm_name$macroparams[(++(mm_name$nmacroparams))-1] = pm;
        mm_name$macroparamsgen[(mm_name$nmacroparams)-1] = (struct mm_decls$strec *)(*pm).firstdupl;
        pm = (struct mm_decls$strec *)(*pm).nextparam;
L504 :;
    }
L505 :;
    ;
    mm_name$nmacroargs = (i64)0;
    L506 :;
    while (!!(b)) {
        if ((mm_name$nmacroargs >= (i64)50)) {
            mm_support$rxerror((byte*)"macro arg overflow",0);
        }
;
        mm_name$macroargs[(++(mm_name$nmacroargs))-1] = b;
        b = (*b).nextunit;
L507 :;
    }
L508 :;
    ;
    if ((mm_name$nmacroargs < mm_name$nmacroparams)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"NMACROARGS=",NULL);
        msysc$m_print_i64(mm_name$nmacroargs,NULL);
        msysc$m_print_i64(mm_name$nmacroparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$rxerror((byte*)"Too few macro args",0);
    }
;
    ignoreargs = (i64)0;
    if (((mm_name$nmacroargs > (i64)0) && (mm_name$nmacroparams == (i64)0))) {
        ignoreargs = (i64)1;
        mm_name$nmacroargs = (mm_name$nmacroparams = (i64)0);
    }
    else if ((mm_name$nmacroargs > mm_name$nmacroparams)) {
        mm_support$rxerror((byte*)"Too many macro args",0);
    }
;
    pnew = mm_name$copyunit((*d).code);
    if (!(!!(ignoreargs))) {
        mm_name$replaceunit(p,pnew);
    }
    else {
        (*p).a = pnew;
    }
;
}

static void mm_name$duplfield(struct mm_decls$strec *owner,struct mm_decls$strec *p,struct mm_decls$strec *q) {
    if (!!((*p).code)) {
        mm_support$serror((byte*)"DUPLFIELD");
    }
;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)9,msysc$m_getdotindex((i64)(*p).flags,(i64)9));
    (*q).flags = (i64)(*p).flags;
    (*q).uflags = (*p).uflags;
    mm_lib$storemode(owner,(i64)(*p).mode,&(*q).mode);
}

static void mm_name$do_baseclass(struct mm_decls$strec *p) {
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
        struct mm_decls$strec *  newd;
        struct mm_decls$strec *  dbase;
        i64 normalexit;
    dbase = mm_decls$ttnamedef[((i64)(*p).baseclass)];
    d = (struct mm_decls$strec *)(*dbase).deflist;
    L509 :;
    while (!!(d)) {
        e = (struct mm_decls$strec *)(*p).deflist;
        normalexit = (i64)1;
        L512 :;
        while (!!(e)) {
            if (!!(mlib$eqstring((*d).name,(*e).name))) {
                normalexit = (i64)0;
                goto L514 ;
            }
;
            e = (struct mm_decls$strec *)(*e).nextdef;
L513 :;
        }
L514 :;
        ;
        if (!!(normalexit)) {
                        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)6) || ($temp==(i64)20)) {
                newd = mm_lib$getduplnameptr(p,d,(i64)20);
                (*newd).equivfield = (struct mm_decls$strec *)d;
            }
            else {
                newd = mm_lib$getduplnameptr(p,d,(i64)(*d).nameid);
                mm_name$duplfield((struct mm_decls$strec *)(*p).owner,d,newd);
            }
            };
            mm_lib$adddef(p,newd);
        }
;
        d = (struct mm_decls$strec *)(*d).nextdef;
L510 :;
    }
L511 :;
    ;
}

// START
void mm_name$start(void) {

}

i64 mm_parse$parsemodule(i64 n) {
        struct mm_decls$modulerec *  pm;
        struct mm_decls$strec *  owner;
    mm_parse$initparser();
    pm = (struct mm_decls$modulerec *)&mm_decls$moduletable[(n)];
    mm_decls$currmoduleno = n;
    mm_decls$stmodule = (*pm).stmodule;
    mm_decls$currproc = mm_decls$stmodule;
    mm_decls$stsubprog = mm_decls$subprogtable[((i64)(*mm_decls$stmodule).moduleno)].stsubprog;
    mm_decls$currsubprog = mm_decls$stsubprog;
    mm_lex$startlex((i64)(*pm).fileno);
    owner = (struct mm_decls$strec *)mm_decls$stmodule;
    mm_lex$lex();
    (*pm).modulecode = mm_parse$readmoduledefs((struct mm_decls$strec *)owner);
    return (i64)1;
}

struct mm_decls$unitrec *mm_parse$readmoduledefs(struct mm_decls$strec *owner) {
        i64 globalflag;
        i64 callbackflag;
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
        struct mm_decls$unitrec *  p;
    globalflag = (i64)0;
    callbackflag = (i64)0;
    ulist = (ulistx = 0);
    L515 :;
    while (1) {
        switch ((i64)mm_decls$lx.symbol) {
        case 156:;
            {
                if (!!(globalflag)) {
                    mm_support$serror((byte*)"global global?");
                }
;
                globalflag = (i64)mm_decls$lx.subcode;
                if (((globalflag == (i64)3) && ((i64)(*mm_decls$stmodule).subprogno != (i64)1))) {
                    globalflag = (i64)2;
                }
;
                mm_lex$lex();
            }
            break;
        case 130:;
        case 131:;
            {
                mm_parse$readprocdef((struct mm_decls$strec *)owner,globalflag,callbackflag);
                callbackflag = (i64)0;
                globalflag = (i64)0;
            }
            break;
        case 93:;
        case 140:;
        case 97:;
        case 94:;
        case 15:;
        case 145:;
        case 143:;
            {
                //dovar:
L517 :;
;
                mm_parse$readvardef((struct mm_decls$strec *)owner,globalflag,(i64)0,(i64)11,(i64)0);
                globalflag = (i64)0;
            }
            break;
        case 141:;
            {
                mm_lex$lex();
                mm_parse$readvardef((struct mm_decls$strec *)owner,globalflag,(i64)0,(i64)11,(i64)141);
                globalflag = (i64)0;
            }
            break;
        case 142:;
            {
                mm_lex$lex();
                mm_parse$readvardef((struct mm_decls$strec *)owner,globalflag,(i64)0,(i64)11,(i64)142);
                globalflag = (i64)0;
            }
            break;
        case 144:;
            {
                mm_parse$lexchecksymbol((i64)15);
                goto L517 ;
;
            }
            break;
        case 136:;
            {
                mm_parse$readimportmodule((struct mm_decls$strec *)owner);
            }
            break;
        case 137:;
            {
                mm_parse$readtypedef((struct mm_decls$strec *)owner,globalflag);
                globalflag = (i64)0;
            }
            break;
        case 149:;
            {
                mm_parse$readconstdef((struct mm_decls$strec *)owner,globalflag);
                globalflag = (i64)0;
            }
            break;
        case 152:;
        case 133:;
            {
                mm_parse$readclassdef((struct mm_decls$strec *)owner,globalflag);
                globalflag = (i64)0;
            }
            break;
        case 162:;
            {
                mm_parse$readtabledef((struct mm_decls$strec *)owner,globalflag);
                globalflag = (i64)0;
            }
            break;
        case 70:;
            {
                mm_parse$adddocstring(mm_decls$lx.svalue);
                mm_lex$lex();
            }
            break;
        case 6:;
            {
                mm_lex$lex();
            }
            break;
        case 68:;
            {
                goto L516 ;
            }
            break;
        case 155:;
            {
                if (((i64)mm_decls$lx.subcode == (i64)4)) {
                    callbackflag = (i64)4;
                    mm_lex$lex();
                }
                else {
                    mm_support$serror((byte*)"fflang?");
                }
;
            }
            break;
        case 146:;
            {
                mm_parse$readmacrodef((struct mm_decls$strec *)owner,globalflag);
                globalflag = (i64)0;
            }
            break;
        case 153:;
            {
                L518 :;
                do {
                    mm_lex$lex();
L519 :;
                }
                while (!((i64)mm_decls$lx.symbol == (i64)6));
L520 :;
                ;
            }
            break;
        case 2:;
            {
                mm_support$serror((byte*)"MODULE/DOT");
            }
            break;
        case 81:;
            {
                if (!!(mm_parse$istypestarter())) {
                    goto L517 ;
;
                }
;
                goto L521 ;
;
            }
            break;
        default: {
            //doexec:
L521 :;
;
            p = mm_parse$readunit();
            mm_lib$addlistunit(&ulist,&ulistx,p);
        }
        } //SW
;
    }
L516 :;
    ;
    return ulist;
}

static void mm_parse$initparser(void) {
        u8 *  tabledataname;
    if (!(!!(mm_decls$nullunit))) {
        mm_decls$nullunit = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)2);
    }
;
    if (!(!!(mm_decls$voidvarunit))) {
        mm_decls$voidvarunit = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)3);
    }
;
    mm_parse$try_level = (i64)0;
    mm_decls$currproc = 0;
    mm_parse$varattribs = (i64)0;
    mm_parse$intabledata = (i64)0;
    mm_parse$inreadprint = (i64)0;
    mm_parse$inparamlist = (i64)0;
    mm_parse$inrecordbody = (i64)0;
    mm_parse$inimportmodule = (i64)0;
    tabledataname = (byte*)"";
    mm_parse$labelseen = (i64)0;
    mm_parse$ndollar = (i64)0;
}

void mm_parse$skipsemi(void) {
    L522 :;
    while (((i64)mm_decls$lx.symbol == (i64)6)) {
        mm_lex$lex();
L523 :;
    }
L524 :;
    ;
}

struct mm_decls$unitrec *mm_parse$makeblock(struct mm_decls$unitrec *p) {
    if ((!!(p) && ((i64)(*p).tag == (i64)6))) {
        return p;
    }
;
    return (struct mm_decls$unitrec *)mm_lib$createunit1((i64)6,(struct mm_decls$unitrec *)p);
}

static void mm_parse$checkequals(void) {
    if (((i64)mm_decls$lx.symbol != (i64)48)) {
        mm_support$serror((byte*)"\"=\" expected");
    }
;
}

static i64 mm_parse$getcurrline(void) {
    return (i64)mm_decls$lx.pos;
}

static i64 mm_parse$checkbegin(i64 fbrack) {
        i64 closesym;
    mm_parse$skipsemi();
    if ((((i64)mm_decls$lx.symbol == (i64)13) && !!(fbrack))) {
        closesym = (i64)14;
        mm_lex$lex();
    }
    else {
        closesym = (i64)105;
    }
;
    return closesym;
}

static void mm_parse$checkbeginend(i64 closesym,i64 kwd,i64 startline) {
    mm_parse$skipsemi();
    if ((closesym == (i64)14)) {
        mm_parse$checksymbol(closesym);
    }
    else {
        mm_parse$checkend(closesym,kwd,(i64)0,startline);
    }
;
    mm_lex$lex();
}

void mm_parse$checkend(i64 endsym,i64 endkwd1,i64 endkwd2,i64 startline) {
        u8 str[100];
    if ((endsym==(i64)mm_decls$lx.symbol && (i64)mm_decls$lx.symbol==(i64)14)) {
        return;
    }
;
    if (((i64)mm_decls$lx.symbol != (i64)105)) {
        strcpy((u8 *)str,(byte*)"Bad 'end' ");
        //error:
L525 :;
;
        if (!!(startline)) {
            msysc$m_print_startstr((str + strlen((u8 *)str)));
            msysc$m_print_setfmt((byte*)" (from line #)");
            msysc$m_print_i64((startline & (i64)16777215),NULL);
            msysc$m_print_end();
            ;
        }
;
        mm_support$serror((u8 *)str);
    }
;
    if (((i64)mm_decls$lx.subcode == (i64)0)) {
        return;
    }
;
    if (!(((!!(endkwd1) && (endkwd1 == (i64)mm_decls$lx.subcode)) || (!!(endkwd2) && (endkwd2 == (i64)mm_decls$lx.subcode))))) {
        strcpy((u8 *)str,(byte*)"Mismatched 'end'");
        goto L525 ;
;
    }
;
}

static struct mm_decls$unitrec *mm_parse$readvardef(struct mm_decls$strec *owner,i64 scope,i64 isstatic,i64 varid,i64 k) {
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
        struct mm_decls$unitrec *  p;
        i64 nvars;
        i64 m;
        i64 initcode;
        struct mm_decls$strec *  stname;
    ulist = (ulistx = 0);
    if (!!(mm_parse$istypestarter())) {
        m = mm_parse$readtypespec((struct mm_decls$strec *)owner,(i64)0);
    }
    else if (!!(k)) {
        m = (i64)21;
    }
    else {
        mm_support$serror((byte*)"Readvar?");
    }
;
    nvars = (i64)0;
    L526 :;
    while (((i64)mm_decls$lx.symbol == (i64)81)) {
        ++(nvars);
        stname = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)mm_decls$lx.symptr,varid);
        (*stname).scope = scope;
        (*stname).flags = msysc$m_setdotindex((*stname).flags,(i64)0,(u64)isstatic);
        (*stname).flags = msysc$m_setdotindex((*stname).flags,(i64)4,(u64)(k == (i64)142));
        if ((varid == (i64)8)) {
            (*stname).flags = msysc$m_setdotindex((*stname).flags,(i64)12,(u64)1u);
        }
;
        mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stname);
        if ((varid == (i64)11)) {
            mm_lib$addstatic((struct mm_decls$strec *)stname);
        }
;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)7)) {
            if ((m != (i64)21)) {
                mm_support$serror((byte*)"Mixed var T x:T");
            }
;
            mm_lex$lex();
            m = mm_parse$readtypespec((struct mm_decls$strec *)owner,(i64)0);
        }
;
        mm_lib$storemode((struct mm_decls$strec *)owner,m,&(*stname).mode);
        if (((i64)mm_decls$lx.symbol == (i64)9 || (i64)mm_decls$lx.symbol == (i64)48 || (i64)mm_decls$lx.symbol == (i64)10)) {
                        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)48)) {
                initcode = (i64)1;
            }
            else if (($temp==(i64)9)) {
                initcode = (i64)2;
            }
            else {
                initcode = (i64)3;
            }
            };
            if (((i64)mm_decls$lx.symbol != (i64)48)) {
                if ((varid == (i64)11)) {
                    mm_support$serror((byte*)"Non-variants can't use :=");
                    if (((i64)(*owner).nameid == (i64)6)) {
                        mm_support$serror((byte*)"Can't use := for statics inside procs");
                    }
;
                }
;
            }
            else {
                if ((varid == (i64)12)) {
                    mm_support$serror((byte*)"Need 'static' for '='");
                    mm_lib$addstatic((struct mm_decls$strec *)stname);
                }
;
            }
;
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol == (i64)170)) {
                mm_lex$lex();
                if ((varid != (i64)12)) {
                    mm_support$serror((byte*)"empty: not frame");
                }
;
                p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)128,(struct mm_decls$unitrec *)mm_lib$createname((struct mm_decls$strec *)stname));
                mm_lib$addlistunit(&ulist,&ulistx,p);
            }
            else {
                (*stname).code = mm_parse$readunit();
                (*stname).equals = initcode;
                if ((varid == (i64)12)) {
                    p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)26,(struct mm_decls$unitrec *)mm_lib$createname((struct mm_decls$strec *)stname),(struct mm_decls$unitrec *)(*stname).code);
                    (*p).initlet = (i64)1;
                    mm_lib$addlistunit(&ulist,&ulistx,p);
                }
;
            }
;
        }
        else if (((i64)mm_decls$lx.symbol == (i64)22)) {
            if ((k == (i64)142)) {
                mm_support$serror((byte*)"let@");
            }
;
            mm_lex$lex();
            (*stname).flags = msysc$m_setdotindex((*stname).flags,(i64)10,(u64)1u);
            (*stname).equivvar = mm_parse$readunit();
        }
        else if ((k == (i64)142)) {
            mm_support$serror((byte*)"let needs :=/=");
        }
;
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L528 ;
        }
;
        mm_lex$lex();
L527 :;
    }
L528 :;
    ;
    if ((nvars == (i64)0)) {
        mm_support$serror((byte*)"No vars declared");
    }
;
    return ulist;
}

static void mm_parse$readconstdef(struct mm_decls$strec *owner,i64 scope) {
        i64 nconsts;
        i64 deft;
        i64 m;
        struct mm_decls$strec *  stname;
    mm_lex$lex();
    nconsts = (i64)0;
    if (!!(mm_parse$istypestarter())) {
        deft = mm_parse$readtypespec((struct mm_decls$strec *)owner,(i64)0);
    }
    else {
        deft = (i64)21;
    }
;
    L529 :;
    while (((i64)mm_decls$lx.symbol == (i64)81)) {
        stname = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)mm_decls$lx.symptr,(i64)10);
        mm_lex$lex();
        mm_parse$checkequals();
        mm_lex$lex();
        (*stname).code = mm_parse$readconstexpr((i64)1);
        m = deft;
        mm_lib$storemode((struct mm_decls$strec *)owner,m,&(*stname).mode);
        ++(nconsts);
        (*stname).scope = scope;
        mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stname);
        if (((scope == (i64)3) && ((u64)(*(*stname).name) != '$'))) {
            mm_lib$addexpconst((struct mm_decls$strec *)stname);
        }
;
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L531 ;
        }
;
        mm_lex$lex();
L530 :;
    }
L531 :;
    ;
    if ((nconsts == (i64)0)) {
        mm_support$serror((byte*)"No consts declared");
    }
;
}

static struct mm_decls$unitrec *mm_parse$readlbrack(void) {
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  r;
        struct mm_decls$unitrec *  plower;
        i64 oldirp;
        i64 length;
        i64 usecomma;
    mm_lex$lex();
    ulist = (ulistx = 0);
    plower = 0;
    length = (i64)0;
    if (((i64)mm_decls$lx.symbol == (i64)22)) {
        mm_lex$lex();
        oldirp = mm_parse$inreadprint;
        mm_parse$inreadprint = (i64)1;
        plower = mm_parse$readunit();
        mm_parse$inreadprint = oldirp;
        mm_parse$checksymbol((i64)7);
        mm_lex$lex();
    }
    else if ((((i64)mm_decls$lx.symbol == (i64)72) && ((i64)mm_decls$nextlx.symbol == (i64)7))) {
        plower = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)mm_decls$lx.value,(i64)mm_decls$lx.subcode);
        (*plower).istrueconst = (i64)1;
        mm_lex$lex();
        mm_lex$lex();
    }
    else if ((((i64)mm_tables$symboloptypes[((i64)mm_decls$lx.symbol)-1] == (i64)1) && ((i64)mm_decls$nextlx.symbol == (i64)14))) {
        p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)57);
        (*p).opcindex = (i64)mm_decls$lx.subcode;
        mm_lex$lex();
        mm_lex$lex();
        return p;
    }
    else if ((((i64)mm_tables$symboloptypes[((i64)mm_decls$lx.symbol)-1] == (i64)1) && ((i64)mm_decls$nextlx.symbol == (i64)9))) {
        p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)57);
        (*p).pclop = (i64)mm_tables$symbolgentoops[((i64)mm_decls$lx.symbol)-1];
        mm_lex$lex();
        mm_parse$lexchecksymbol((i64)14);
        mm_lex$lex();
        return p;
    }
;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)14)) {
        mm_lex$lex();
        p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)18);
        (*p).b = plower;
        (*p).length = (i64)0;
        return p;
    }
    else {
        p = mm_parse$readunit();
    }
    };
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)14)) {
        mm_lex$lex();
        return p;
    }
    else if (($temp==(i64)5)) {
        usecomma = (i64)1;
        if (((i64)mm_decls$nextlx.symbol == (i64)14)) {
            mm_lex$lex();
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)18,(struct mm_decls$unitrec *)p);
            (*p).length = (i64)1;
            (*p).b = plower;
            return p;
        }
;
        //docomma:
L532 :;
;
        length = (i64)1;
        ulist = (ulistx = p);
        if (!!(usecomma)) {
            L533 :;
            do {
                mm_lex$lex();
                if (((i64)mm_decls$lx.symbol == (i64)14)) {
                    goto L535 ;
                }
;
                if (((i64)mm_decls$lx.symbol == (i64)5)) {
                    mm_support$serror((byte*)",, null expr not allowed");
                }
;
                mm_lib$addlistunit(&ulist,&ulistx,mm_parse$readunit());
                ++(length);
                mm_parse$skipsemi();
L534 :;
            }
            while (!((i64)mm_decls$lx.symbol != (i64)5));
L535 :;
            ;
        }
        else {
            L536 :;
            do {
                mm_parse$skipsemi();
                if (((i64)mm_decls$lx.symbol == (i64)14)) {
                    goto L538 ;
                }
;
                if (((i64)mm_decls$lx.symbol == (i64)5)) {
                    mm_support$serror((byte*)",, null expr not allowed");
                }
;
                mm_lib$addlistunit(&ulist,&ulistx,mm_parse$readunit());
                ++(length);
L537 :;
            }
            while (!((i64)mm_decls$lx.symbol != (i64)6));
L538 :;
            ;
        }
;
        mm_parse$checksymbol((i64)14);
        mm_lex$lex();
        p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)18,(struct mm_decls$unitrec *)ulist);
        (*p).length = length;
        (*p).b = plower;
        return p;
    }
    else if (($temp==(i64)20)) {
        mm_lex$lex();
        q = mm_parse$readunit();
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)20)) {
            mm_lex$lex();
            r = mm_parse$readsunit((i64)0);
            mm_parse$checksymbol((i64)14);
            mm_lex$lex();
            return (struct mm_decls$unitrec *)mm_lib$createunit3((i64)94,(struct mm_decls$unitrec *)mm_parse$fixcond(p),(struct mm_decls$unitrec *)q,(struct mm_decls$unitrec *)r);
        }
        else if (($temp==(i64)14)) {
            mm_lex$lex();
            return (struct mm_decls$unitrec *)mm_lib$createunit3((i64)94,(struct mm_decls$unitrec *)mm_parse$fixcond(p),(struct mm_decls$unitrec *)q,0);
        }
        };
        mm_lib$addlistunit(&ulist,&ulistx,q);
        mm_parse$checksymbol((i64)5);
        if (((i64)mm_decls$nextlx.symbol != (i64)20)) {
            L539 :;
            do {
                mm_lex$lex();
                mm_lib$addlistunit(&ulist,&ulistx,mm_parse$readunit());
L540 :;
            }
            while (!((i64)mm_decls$lx.symbol != (i64)5));
L541 :;
            ;
            mm_parse$checksymbol((i64)20);
        }
        else {
            mm_lex$lex();
        }
;
        mm_lex$lex();
        r = mm_parse$readunit();
        mm_parse$checksymbol((i64)14);
        mm_lex$lex();
        return (struct mm_decls$unitrec *)mm_lib$createunit3((i64)112,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)ulist,(struct mm_decls$unitrec *)r);
    }
    else if (($temp==(i64)6)) {
        if (((i64)mm_decls$lx.subcode == (i64)1)) {
            usecomma = (i64)0;
            goto L532 ;
;
        }
;
        ulist = (ulistx = p);
        L542 :;
        do {
            mm_parse$skipsemi();
            if (((i64)mm_decls$lx.symbol == (i64)14)) {
                goto L544 ;
            }
;
            mm_lib$addlistunit(&ulist,&ulistx,mm_parse$readunit());
L543 :;
        }
        while (!((i64)mm_decls$lx.symbol != (i64)6));
L544 :;
        ;
        mm_parse$checksymbol((i64)14);
        mm_lex$lex();
        return mm_parse$makeblock(ulist);
    }
    else {
        mm_support$serror((byte*)"(x ...");
    }
    };
    return (struct mm_decls$unitrec *)0;
}

static void mm_parse$addlistparam(struct mm_decls$strec **ulist,struct mm_decls$strec **ulistx,struct mm_decls$strec *p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = (struct mm_decls$strec *)p);
    }
    else {
        (*(*ulistx)).nextparam = (struct mm_decls$strec *)p;
    }
;
    (*ulistx) = (struct mm_decls$strec *)p;
}

static struct mm_decls$unitrec *mm_parse$readcast(void) {
        struct mm_decls$unitrec *  p;
        i64 opc;
        i64 t;
    t = mm_parse$readtypespec((struct mm_decls$strec *)mm_decls$currproc,(i64)0);
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)14)) {
        p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)56);
        (*p).mode = (i64)25;
        (*p).value = t;
        return p;
    }
    else if (($temp==(i64)22)) {
        opc = (i64)55;
        mm_lex$lex();
    }
    else if (($temp==(i64)2)) {
        if (((i64)mm_decls$nextlx.symbol == (i64)137)) {
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)56);
            (*p).value = t;
            (*p).mode = (i64)25;
            mm_lex$lex();
        }
        else {
            p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)56);
            (*p).value = t;
        }
;
        return p;
    }
    else {
        opc = (i64)52;
    }
    };
    mm_parse$checksymbol((i64)13);
    mm_lex$lex();
    p = mm_parse$readunit();
    mm_parse$checksymbol((i64)14);
    mm_lex$lex();
    p = (struct mm_decls$unitrec *)mm_lib$createunit1(opc,(struct mm_decls$unitrec *)p);
    mm_lib$storemode(mm_decls$currproc,t,&(*p).convmode);
    return p;
}

static struct mm_decls$unitrec *mm_parse$readopc(void) {
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  r;
        i64 tag;
        i64 opc;
        i64 firstsym;
    firstsym = (i64)mm_decls$lx.symbol;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)64)) {
        tag = (i64)35;
        opc = (i64)mm_decls$lx.subcode;
    }
    else if (($temp==(i64)65)) {
        tag = (i64)34;
        opc = (i64)mm_decls$lx.subcode;
    }
    else {
        tag = (i64)35;
        opc = (i64)mm_tables$symbolgenops[(firstsym)-1];
    }
    };
    mm_lex$lex();
    if ((firstsym==(i64)31)) {
        return mm_parse$readterm2();
    }
    else if ((firstsym==(i64)32)) {
        opc = (i64)29;
    }
    else if ((firstsym==(i64)43) || (firstsym==(i64)44) || (firstsym==(i64)65)) {
        p = mm_parse$readterm2();
        if (((i64)(*p).tag == (i64)18)) {
            if (((i64)(*p).length != (i64)2)) {
                mm_support$serror((byte*)"Needs (x,y)");
            }
;
            q = (*p).a;
            r = (*q).nextunit;
            (*q).nextunit = 0;
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)34,(struct mm_decls$unitrec *)q,(struct mm_decls$unitrec *)r);
            (*p).pclop = opc;
            return p;
        }
        else {
            mm_support$serror((byte*)"READOPC/SINGLE OPND?");
            return (struct mm_decls$unitrec *)mm_lib$createunit1(opc,(struct mm_decls$unitrec *)p);
        }
;
    }
    else {
        if (((i64)mm_tables$symboloptypes[(firstsym)-1] == (i64)1)) {
            mm_support$serror((byte*)"Can't be used as unary op");
        }
;
    }
;
    if (((i64)mm_decls$lx.symbol == (i64)9)) {
        mm_lex$lex();
        tag = (i64)37;
        if ((firstsym==(i64)32)) {
            opc = (i64)76;
        }
        else {
            opc = (i64)mm_tables$symbolgentoops[(firstsym)-1];
            if ((opc == (i64)0)) {
                mm_support$serror((byte*)"op:= not available");
            }
;
        }
;
    }
;
    p = (struct mm_decls$unitrec *)mm_lib$createunit1(tag,(struct mm_decls$unitrec *)(q = mm_parse$readterm2()));
    (*p).pclop = opc;
    if (((i64)(*q).tag == (i64)18)) {
        mm_support$serror((byte*)"Too many opnds");
    }
;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readsprint(void) {
        i64 oldinreadprint;
        i64 opc;
        i64 isfprint;
        struct mm_decls$unitrec *  pformat;
        struct mm_decls$unitrec *  pdev;
        struct mm_decls$unitrec *  printlist;
        struct mm_decls$unitrec *  printlistx;
        struct mm_decls$unitrec *  p;
    oldinreadprint = mm_parse$inreadprint;
    mm_parse$inreadprint = (i64)1;
    opc = (i64)mm_decls$lx.subcode;
    mm_parse$lexchecksymbol((i64)13);
    mm_lex$lex();
    if ((opc==(i64)119)) {
        isfprint = (i64)1;
    }
    else {
        isfprint = (i64)0;
    }
;
    printlist = (printlistx = 0);
    pformat = (pdev = 0);
    if (((i64)mm_decls$lx.symbol == (i64)22)) {
        mm_lex$lex();
        pdev = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)5)) {
            mm_lex$lex();
        }
        else {
            goto L545 ;
;
        }
;
    }
;
    if (!!(isfprint)) {
        pformat = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)5)) {
            mm_lex$lex();
        }
        else {
            goto L545 ;
;
        }
;
    }
;
    if (((i64)mm_decls$lx.symbol == (i64)14)) {
        goto L545 ;
;
    }
;
    L546 :;
    while (1) {
        if (((i64)mm_decls$lx.symbol == (i64)5)) {
            mm_lib$addlistunit(&printlist,&printlistx,(struct mm_decls$unitrec *)mm_lib$createunit0((i64)88));
        }
        else {
            p = mm_parse$readunit();
            if (((i64)mm_decls$lx.symbol == (i64)7)) {
                mm_lex$lex();
                p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)87,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readunit());
            }
;
            mm_lib$addlistunit(&printlist,&printlistx,p);
        }
;
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L547 ;
        }
;
        mm_lex$lex();
    }
L547 :;
    ;
    mm_parse$checksymbol((i64)14);
    //finish:
L545 :;
;
    mm_lex$lex();
    mm_parse$inreadprint = oldinreadprint;
    if ((((opc == (i64)114) || (opc == (i64)116)) && (printlist == 0))) {
        mm_support$serror((byte*)"No print items");
    }
;
    if (!!(isfprint)) {
        if (((i64)(*pformat).tag == (i64)2)) {
            mm_support$serror((byte*)"No fmt str");
        }
;
        return (struct mm_decls$unitrec *)mm_lib$createunit3(opc,(struct mm_decls$unitrec *)pdev,(struct mm_decls$unitrec *)pformat,(struct mm_decls$unitrec *)printlist);
    }
    else {
        return (struct mm_decls$unitrec *)mm_lib$createunit2(opc,(struct mm_decls$unitrec *)pdev,(struct mm_decls$unitrec *)printlist);
    }
;
}

static struct mm_decls$unitrec *mm_parse$readsread(void) {
        i64 oldinreadprint;
        i64 opc;
        struct mm_decls$unitrec *  pformat;
        struct mm_decls$unitrec *  pdev;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  readlist;
        struct mm_decls$unitrec *  readlistx;
    oldinreadprint = mm_parse$inreadprint;
    mm_parse$inreadprint = (i64)1;
    opc = (i64)mm_decls$lx.subcode;
    mm_parse$lexchecksymbol((i64)13);
    mm_lex$lex();
    readlist = (readlistx = 0);
    pformat = (pdev = 0);
    if (((i64)mm_decls$lx.symbol == (i64)22)) {
        if ((opc == (i64)120)) {
            mm_support$serror((byte*)"@ on read");
        }
;
        mm_lex$lex();
        pdev = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)5)) {
            mm_lex$lex();
        }
        else {
            goto L548 ;
;
        }
;
    }
;
    if (((i64)mm_decls$lx.symbol == (i64)14)) {
        goto L548 ;
;
    }
;
    L549 :;
    while (1) {
        p = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)7)) {
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)87,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readunit());
        }
;
        mm_lib$addlistunit(&readlist,&readlistx,p);
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L550 ;
        }
;
        mm_lex$lex();
    }
L550 :;
    ;
    mm_parse$checksymbol((i64)14);
    //finish:
L548 :;
;
    mm_lex$lex();
    mm_parse$inreadprint = oldinreadprint;
    if (((opc == (i64)120) && (readlist == 0))) {
        mm_support$serror((byte*)"No read items");
    }
;
    return (struct mm_decls$unitrec *)mm_lib$createunit2(opc,(struct mm_decls$unitrec *)pdev,(struct mm_decls$unitrec *)readlist);
}

static struct mm_decls$unitrec *mm_parse$readcompilervar(void) {
        u8 str[100];
        struct mlinux$rsystemtime tm;
        static u8 *  monthnames[12] = {
    (byte*)"Jan",
    (byte*)"Feb",
    (byte*)"Mar",
    (byte*)"Apr",
    (byte*)"May",
    (byte*)"Jun",
    (byte*)"Jul",
    (byte*)"Aug",
    (byte*)"Sep",
    (byte*)"Oct",
    (byte*)"Nov",
    (byte*)"Dec"
};
        struct mm_decls$unitrec *  p;
        struct mm_decls$modulerec *  currmodule;
    currmodule = (struct mm_decls$modulerec *)&mm_decls$moduletable[(mm_decls$currmoduleno)];
    switch ((i64)mm_decls$lx.subcode) {
    case 81:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)0u,(i64)7);
            mm_lex$lex();
            return p;
        }
        break;
    case 82:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)(i64)4614256656552045848,(i64)5);
            mm_lex$lex();
            return p;
        }
        break;
    case 83:;
        {
            if ((u64)0u) {
                p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)130);
                (*p).mode = (i64)5;
            }
            else {
                p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)(i64)msysc$m_tp_r64toi64(m$infinity),(i64)5);
            }
;
            mm_lex$lex();
            return p;
        }
        break;
    case 66:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)66);
            mm_lex$lex();
            return p;
        }
        break;
    case 67:;
        {
            msysc$getstrint(mm_support$getlineno((u64)(i64)mm_decls$lx.pos),(u8 *)str);
        }
        break;
    case 68:;
        {
            strcpy(str,(*mm_decls$stmodule).name);
        }
        break;
    case 69:;
        {
            strcpy(str,mm_decls$sourcefilepaths[((i64)(*currmodule).fileno)]);
        }
        break;
    case 70:;
        {
            strcpy((u8 *)str,(*mm_decls$currproc).name);
        }
        break;
    case 71:;
        {
            mlinux$os_getsystime(&tm);
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"#-#-#");
            msysc$m_print_i64((i64)tm.day,NULL);
            msysc$m_print_str(monthnames[((i64)tm.month)-1],NULL);
            msysc$m_print_i64((i64)tm.year,(byte*)"4");
            msysc$m_print_end();
            ;
        }
        break;
    case 72:;
        {
            mlinux$os_getsystime(&tm);
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"#:#:#");
            msysc$m_print_i64((i64)tm.hour,(byte*)"z2");
            msysc$m_print_i64((i64)tm.minute,(byte*)"z2");
            msysc$m_print_i64((i64)tm.second,(byte*)"z2");
            msysc$m_print_end();
            ;
        }
        break;
    case 75:;
        {
            mm_lex$lex();
            return (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)mm_decls$targetbits,(i64)3);
        }
        break;
    case 76:;
        {
            mm_lex$lex();
            return (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)mm_decls$targetsize,(i64)3);
        }
        break;
    case 77:;
        {
            strcpy((u8 *)str,(byte*)"wx64");
        }
        break;
    case 78:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)0u,(i64)3);
            mm_lex$lex();
            return p;
        }
        break;
    case 79:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)(i64)mm_decls$fwindows,(i64)3);
            mm_lex$lex();
            return p;
        }
        break;
    case 80:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)(i64)mm_decls$flinux,(i64)3);
            mm_lex$lex();
            return p;
        }
        break;
    case 73:;
        {
            strcpy((u8 *)str,(byte*)"Compiler:BX Experimental");
        }
        break;
    case 84:;
    case 85:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)((i64)mm_decls$lx.subcode == (i64)84),(i64)6);
            mm_lex$lex();
            return p;
        }
        break;
    default: {
        mm_support$serror_s((byte*)"compiler var not impl: #",mm_tables$jtagnames[((i64)mm_decls$lx.subcode)]);
    }
    } //SW
;
    mm_lex$lex();
    return (struct mm_decls$unitrec *)mm_lib$createstringconstunit(mlib$pcm_copyheapstring((u8 *)str),(i64)-1);
}

static struct mm_decls$unitrec *mm_parse$readcastx(void) {
        i64 opc;
        i64 m;
        struct mm_decls$unitrec *  p;
    mm_lex$lex();
    opc = (i64)52;
    if (((i64)mm_decls$lx.symbol == (i64)22)) {
        opc = (i64)55;
        mm_lex$lex();
    }
;
    mm_parse$checksymbol((i64)13);
    mm_lex$lex();
    m = (i64)0;
    p = mm_parse$readunit();
    if (((i64)mm_decls$lx.symbol != (i64)5)) {
        if ((opc == (i64)55)) {
            mm_support$serror((byte*)"@ type missing");
        }
;
        opc = (i64)54;
    }
    else {
        mm_lex$lex();
        m = mm_parse$readtypespec((struct mm_decls$strec *)mm_decls$currproc,(i64)0);
    }
;
    mm_parse$checksymbol((i64)14);
    mm_lex$lex();
    p = (struct mm_decls$unitrec *)mm_lib$createunit1(opc,(struct mm_decls$unitrec *)p);
    mm_lib$storemode(mm_decls$currproc,m,&(*p).convmode);
    return p;
}

void mm_parse$checksymbol(i64 symbol) {
        u8 str[100];
    if (((i64)mm_decls$lx.symbol != symbol)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"# expected, not #");
        msysc$m_print_str(mm_tables$symbolnames[(symbol)-1],NULL);
        msysc$m_print_str(mm_tables$symbolnames[((i64)mm_decls$lx.symbol)-1],NULL);
        msysc$m_print_end();
        ;
        mm_support$serror((u8 *)str);
    }
;
}

void mm_parse$lexchecksymbol(i64 symbol) {
    mm_lex$lex();
    mm_parse$checksymbol(symbol);
}

i64 mm_parse$readtypespec(struct mm_decls$strec *owner,i64 typedefx) {
        struct mm_decls$strec *  d;
        i64 t;
        i64 fflang;
        struct mm_decls$unitrec *  dim;
        struct mm_decls$unitrec *  length;
        struct mm_decls$unitrec *  dims[30];
        i64 ndims;
        i64 i;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)15)) {
        //arraybounds:
L551 :;
;
        mm_lex$lex();
        ndims = (i64)0;
        mm_parse$inreadprint = (i64)1;
        L552 :;
        while (1) {
            length = 0;
            if ((((i64)mm_decls$lx.symbol == (i64)16) || ((i64)mm_decls$lx.symbol == (i64)5))) {
                dim = 0;
            }
            else {
                dim = mm_parse$readunit();
                                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)16) || ($temp==(i64)5)) {
                }
                else if (($temp==(i64)7)) {
                    mm_lex$lex();
                    if (!((((i64)mm_decls$lx.symbol == (i64)5) || ((i64)mm_decls$lx.symbol == (i64)16)))) {
                        length = mm_parse$readunit();
                        dim = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)25,(struct mm_decls$unitrec *)dim,(struct mm_decls$unitrec *)length);
                    }
                    else {
                        dim = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)25,(struct mm_decls$unitrec *)dim);
                    }
;
                }
                };
            }
;
            if ((ndims >= (i64)30)) {
                mm_support$serror((byte*)"Too many array dims");
            }
;
            dims[(++(ndims))-1] = dim;
            if (((i64)mm_decls$lx.symbol != (i64)5)) {
                goto L553 ;
            }
;
            mm_lex$lex();
        }
L553 :;
        ;
        mm_parse$inreadprint = (i64)0;
        mm_parse$checksymbol((i64)16);
        mm_lex$lex();
        t = mm_parse$readtypespec(owner,(i64)0);
        for (i=ndims;i>=(i64)1;--i) {
L554 :;
            t = mm_lib$createarraymode((struct mm_decls$strec *)owner,t,dims[(i)-1],((i == (i64)1) ? typedefx : (i64)0));
L555 :;
        }
L556 :;
        ;
        return t;
    }
    else if (($temp==(i64)93)) {
        t = (i64)mm_decls$lx.subcode;
        mm_lex$lex();
    }
    else if (($temp==(i64)81)) {
        d = (struct mm_decls$strec *)mm_decls$lx.symptr;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)2)) {
            mm_parse$lexchecksymbol((i64)81);
            t = mm_lib$newtypename((struct mm_decls$strec *)d,(struct mm_decls$strec *)mm_decls$lx.symptr);
            mm_lex$lex();
        }
        else {
            t = mm_lib$newtypename(0,(struct mm_decls$strec *)d);
        }
;
    }
    else if (($temp==(i64)133) || ($temp==(i64)134)) {
        mm_support$serror((byte*)"Use 'record name =' syntax");
    }
    else if (($temp==(i64)135)) {
        mm_support$serror((byte*)"Top-level union not allowed");
    }
    else if (($temp==(i64)140)) {
        fflang = (i64)0;
        //retry:
L557 :;
;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)112)) {
            mm_lex$lex();
        }
;
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)130) || ($temp==(i64)131)) {
            t = mm_parse$readrefproc((struct mm_decls$strec *)owner,typedefx,fflang);
        }
        else if (($temp==(i64)155)) {
            fflang = (i64)mm_decls$lx.subcode;
            goto L557 ;
;
        }
        else {
            if (((i64)mm_decls$lx.symbol == (i64)93)) {
                                {i64 $temp = (i64)mm_decls$lx.subcode;
if (($temp==(i64)12)) {
                    t = (i64)20;
                    if (!!(typedefx)) {
                        mm_decls$tttarget[(typedefx)] = (i64)12;
                    }
;
                }
                else {
                    goto L558 ;
;
                }
                };
                mm_lex$lex();
            }
            else {
                //readtarget:
L558 :;
;
                t = mm_parse$readtypespec(owner,(i64)0);
                t = mm_lib$createrefmode((struct mm_decls$strec *)owner,t,typedefx);
            }
;
        }
        };
    }
    else if (($temp==(i64)97)) {
        mm_lex$lex();
        t = (i64)20;
        if (!!(typedefx)) {
            mm_decls$tttarget[(typedefx)] = (i64)12;
        }
;
    }
    else if (($temp==(i64)94)) {
        mm_parse$lexchecksymbol((i64)13);
        mm_parse$lexchecksymbol((i64)81);
        t = mm_lib$newtypename((struct mm_decls$strec *)mm_decls$lx.symptr,0);
        mm_parse$lexchecksymbol((i64)14);
        mm_lex$lex();
    }
    else if (($temp==(i64)143)) {
        t = mm_parse$readslicetype((struct mm_decls$strec *)owner,(i64)mm_decls$lx.subcode,typedefx);
    }
    else if (($temp==(i64)144)) {
        mm_parse$lexchecksymbol((i64)15);
        goto L551 ;
;
    }
    else {
        mm_support$serror((byte*)"Bad type starter");
    }
    };
    if (!!(typedefx)) {
        mm_decls$ttbasetype[(typedefx)] = (i64)mm_decls$ttbasetype[(t)];
    }
;
    return t;
}

static i64 mm_parse$readslicetype(struct mm_decls$strec *owner,i64 slicetype,i64 typedefx) {
        struct mm_decls$unitrec *  plower;
        i64 t;
    mm_parse$lexchecksymbol((i64)15);
    mm_lex$lex();
    if (((i64)mm_decls$lx.symbol != (i64)16)) {
        mm_parse$inreadprint = (i64)1;
        plower = mm_parse$readunit();
        mm_parse$inreadprint = (i64)0;
        mm_parse$checksymbol((i64)7);
        mm_parse$lexchecksymbol((i64)16);
    }
    else {
        plower = 0;
    }
;
    mm_lex$lex();
    t = mm_parse$readtypespec((struct mm_decls$strec *)owner,typedefx);
    return mm_lib$createslicemode((struct mm_decls$strec *)owner,slicetype,t,plower,typedefx);
}

static struct mm_decls$unitrec *mm_parse$readslist(i64 iscall,i64 donulls) {
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
        i64 oldinparamlist;
    ulist = (ulistx = 0);
    mm_parse$skipsemi();
    if (((i64)mm_decls$lx.symbol == (i64)14)) {
        return ulist;
    }
;
    oldinparamlist = mm_parse$inparamlist;
    mm_parse$inparamlist = iscall;
    L559 :;
    while (1) {
        mm_parse$skipsemi();
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)5)) {
            if (!!(donulls)) {
                mm_lib$addlistunit(&ulist,&ulistx,(struct mm_decls$unitrec *)mm_lib$createunit0((i64)2));
            }
            else {
                mm_support$serror((byte*)"null comma expr not allowed");
            }
;
            mm_lex$lex();
        }
        else if (($temp==(i64)14)) {
            if (!!(donulls)) {
                mm_lib$addlistunit(&ulist,&ulistx,mm_decls$nullunit);
            }
;
            goto L560 ;
        }
        else {
            mm_lib$addlistunit(&ulist,&ulistx,mm_parse$readunit());
            if (((i64)mm_decls$lx.symbol == (i64)5 || (i64)mm_decls$lx.symbol == (i64)6)) {
                mm_lex$lex();
                if (((i64)mm_decls$lx.symbol == (i64)14)) {
                    goto L560 ;
                }
;
            }
            else {
                mm_parse$skipsemi();
                if (((i64)mm_decls$lx.symbol == (i64)14)) {
                    goto L560 ;
                }
;
                mm_support$serror((byte*)"SLIST?");
            }
;
        }
        };
    }
L560 :;
    ;
    mm_parse$inparamlist = oldinparamlist;
    return ulist;
}

static struct mm_decls$unitrec *mm_parse$readindex(struct mm_decls$unitrec *p,i64 dot) {
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  plower;
        struct mm_decls$unitrec *  pupper;
    mm_lex$lex();
    if (!(!!(dot))) {
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)16)) {
            //fullslice:
L561 :;
;
            mm_lex$lex();
            plower = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)35,(struct mm_decls$unitrec *)mm_lib$duplunit(p,(i64)0));
            (*plower).pclop = (i64)89;
            pupper = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)35,(struct mm_decls$unitrec *)mm_lib$duplunit(p,(i64)0));
            (*pupper).pclop = (i64)90;
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)45,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_lib$createunit2((i64)19,(struct mm_decls$unitrec *)plower,(struct mm_decls$unitrec *)pupper));
            return p;
        }
        else if (($temp==(i64)28) || ($temp==(i64)7)) {
            mm_parse$lexchecksymbol((i64)16);
            goto L561 ;
;
        }
        };
    }
;
    L562 :;
    while (1) {
        if ((mm_parse$ndollar >= (i64)10)) {
            mm_support$serror((byte*)"Too many nested a[$]");
        }
;
        mm_parse$dollarstack[(++(mm_parse$ndollar))-1] = p;
        q = mm_parse$readunit();
        --(mm_parse$ndollar);
        if (((i64)(*q).tag == (i64)19)) {
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((!!(dot) ? (i64)48 : (i64)45),(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)q);
        }
        else {
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((!!(dot) ? (i64)47 : (i64)44),(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)q);
        }
;
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L563 ;
        }
;
        mm_lex$lex();
    }
L563 :;
    ;
    mm_parse$checksymbol((i64)16);
    mm_lex$lex();
    return p;
}

static struct mm_decls$unitrec *mm_parse$readdotsuffix(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  q;
    L564 :;
    while (((i64)mm_decls$lx.symbol == (i64)2)) {
        mm_lex$lex();
        switch ((i64)mm_decls$lx.symbol) {
        case 15:;
            {
                p = mm_parse$readindex(p,(i64)1);
            }
            break;
        case 81:;
            {
                p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)46,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_lib$createname((struct mm_decls$strec *)mm_decls$lx.symptr));
                mm_lex$lex();
            }
            break;
        case 63:;
            {
                //doprop:
L567 :;
;
                p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)35,(struct mm_decls$unitrec *)p);
                (*p).pclop = (i64)mm_decls$lx.subcode;
                mm_lex$lex();
            }
            break;
        case 66:;
            {
                p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)63,(struct mm_decls$unitrec *)p);
                (*p).bfcode = (i64)mm_decls$lx.subcode;
                mm_lex$lex();
            }
            break;
        case 137:;
            {
                                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)56)) {
                }
                else {
                    p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)61,(struct mm_decls$unitrec *)p);
                }
                };
                mm_lex$lex();
            }
            break;
        case 44:;
            {
                mm_decls$lx.subcode = (i64)96;
                goto L567 ;
;
            }
            break;
        case 43:;
            {
                mm_decls$lx.subcode = (i64)95;
                goto L567 ;
;
            }
            break;
        case 93:;
            {
                if ((((i64)(*p).tag == (i64)56) && ((i64)mm_decls$lx.subcode == (i64)9))) {
                    q = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)19,(struct mm_decls$unitrec *)mm_lib$createunit1((i64)35,(struct mm_decls$unitrec *)p),(struct mm_decls$unitrec *)mm_lib$createunit1((i64)35,(struct mm_decls$unitrec *)p));
                    (*(*q).a).pclop = (i64)95;
                    (*(*q).b).pclop = (i64)96;
                }
                else {
                    goto L568 ;
;
                }
;
                mm_lex$lex();
                p = q;
            }
            break;
        default: {
            //error:
L568 :;
;
            mm_support$serror((byte*)"Unknown dot suffix");
        }
        } //SW
;
L565 :;
    }
L566 :;
    ;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readconstexpr(i64 needconst) {
    return mm_parse$readunit();
}

static i64 mm_parse$readconstint(void) {
        i64 x;
    if (((i64)mm_decls$lx.symbol == (i64)72)) {
        x = mm_decls$lx.value;
        mm_lex$lex();
        return x;
    }
    else if (((i64)mm_decls$lx.symbol == (i64)32)) {
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)72)) {
            x = mm_decls$lx.value;
            mm_lex$lex();
            return -(x);
        }
;
    }
;
    mm_support$serror((byte*)"Can't do complex expr");
    return (i64)0;
}

static void mm_parse$readprocdef(struct mm_decls$strec *procowner,i64 scope,i64 fflang) {
        i64 kwd;
        i64 startline;
        i64 closesym;
        i64 shortfun;
        struct mm_decls$strec *  stproc;
        struct mm_decls$strec *  stname;
        i64 i;
    kwd = (i64)mm_decls$lx.symbol;
    shortfun = (i64)((i64)mm_decls$lx.subcode == (i64)1);
    mm_parse$nforloops = (i64)0;
    mm_decls$assemmode = (i64)1;
    stproc = (struct mm_decls$strec *)mm_parse$readprocdecl((struct mm_decls$strec *)procowner,scope,fflang);
    mm_decls$assemmode = (i64)0;
    mm_parse$checkequals();
    mm_lex$lex();
    startline = mm_parse$getcurrline();
    if (!(!!(shortfun))) {
        closesym = mm_parse$checkbegin((i64)0);
    }
;
    mm_parse$pushproc((struct mm_decls$strec *)stproc);
    mm_lib$nextavindex = (i64)0;
    if (!!(mm_parse$dretvar)) {
        stname = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)stproc,(struct mm_decls$strec *)mm_parse$dretvar,(i64)12);
        mm_lib$storemode((struct mm_decls$strec *)procowner,(i64)(*stproc).mode,&(*stname).mode);
        mm_lib$adddef((struct mm_decls$strec *)stproc,(struct mm_decls$strec *)stname);
    }
;
    mm_lib$addtoproclist((struct mm_decls$strec *)stproc);
    if (!!(shortfun)) {
        (*stproc).code = mm_parse$readunit();
        mm_parse$checksymbol((i64)6);
        mm_lex$lex();
    }
    else {
        (*stproc).code = mm_parse$readsunit((i64)0);
        mm_parse$checkbeginend(closesym,kwd,startline);
    }
;
    (*stproc).code = mm_parse$makeblock((*stproc).code);
    if (((!!(mm_decls$ndocstrings) && !!(mm_parse$docfile)) && ((i64)(*stproc).scope >= (i64)2))) {
        msysc$m_print_startfile(mm_parse$docfile);
        msysc$m_print_str((byte*)"proc",NULL);
        msysc$m_print_str((*stproc).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        for (i=(i64)1;i<=mm_decls$ndocstrings;++i) {
L569 :;
            msysc$m_print_startfile(mm_parse$docfile);
            msysc$m_print_str(mm_decls$docstrings[(i)-1],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mlib$pcm_free((void *)mm_decls$docstrings[(i)-1],strlen((mm_decls$docstrings[(i)-1] + (i64)1)));
L570 :;
        }
L571 :;
        ;
        msysc$m_print_startfile(mm_parse$docfile);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_decls$ndocstrings = (i64)0;
    }
;
    mm_parse$popproc();
}

struct mm_decls$strec *mm_parse$readprocdecl(struct mm_decls$strec *procowner,i64 scope,i64 fflang) {
        i64 kwd;
        i64 varparams;
        i64 try_level;
        i64 nparams;
        i64 nretvalues;
        i64 isthreaded;
        i64 retmodes[4];
        u8 *  metadata;
        u8 *  truename;
        struct mm_decls$strec *  pequiv;
        struct mm_decls$strec *  stproc;
        struct mm_decls$strec *  owner;
        struct mm_decls$strec *  paramlist;
        struct mm_decls$strec *  nameptr;
    kwd = (i64)mm_decls$lx.symbol;
    isthreaded = (i64)((i64)mm_decls$lx.subcode == (i64)2);
    pequiv = 0;
    metadata = (byte*)"";
    truename = 0;
    varparams = (i64)0;
    try_level = (i64)0;
    mm_lex$lex();
    if (((i64)mm_decls$lx.symbol == (i64)77)) {
        truename = mlib$pcm_copyheapstring(mm_decls$lx.svalue);
        mlib$convlcstring(mm_decls$lx.svalue);
        mm_decls$lx.symptr = (struct mm_decls$strec *)mm_lex$addnamestr(mm_decls$lx.svalue);
    }
    else {
        mm_parse$checksymbol((i64)81);
    }
;
    nameptr = (struct mm_decls$strec *)mm_decls$lx.symptr;
    stproc = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)procowner,(struct mm_decls$strec *)nameptr,(!!(mm_parse$insidedllimport) ? (i64)7 : (i64)6));
    if (!!(mm_parse$insidedllimport)) {
        scope = (i64)1;
        (*stproc).dllindex = mm_parse$insidedllimport;
    }
;
    (*stproc).isthreaded = isthreaded;
    if (!!(truename)) {
        (*stproc).truename = truename;
    }
;
    mm_lib$adddef((struct mm_decls$strec *)procowner,(struct mm_decls$strec *)stproc);
    if (((i64)(*stproc).nameid == (i64)7)) {
        (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)12,(u64)1u);
    }
;
    owner = stproc;
    mm_parse$pushproc((struct mm_decls$strec *)stproc);
    mm_lex$lex();
    paramlist = 0;
    retmodes[((i64)1)-1] = (i64)0;
    nparams = (i64)0;
    nretvalues = (i64)0;
    nretvalues = (i64)0;
    if (((i64)mm_decls$lx.symbol == (i64)13)) {
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol != (i64)14)) {
            paramlist = (struct mm_decls$strec *)mm_parse$readparams((struct mm_decls$strec *)procowner,(struct mm_decls$strec *)stproc,fflang,&varparams,&nparams);
            mm_parse$checksymbol((i64)14);
        }
;
        mm_lex$lex();
        if ((((i64)mm_decls$lx.symbol == (i64)7) || ((i64)mm_decls$lx.symbol == (i64)11))) {
            mm_lex$lex();
            nretvalues = mm_parse$readreturntype((struct mm_decls$strec *)owner,&retmodes);
        }
        else if ((!!((i64)mm_decls$typestarterset[((i64)mm_decls$lx.symbol)]) || ((i64)mm_decls$lx.symbol == (i64)81))) {
            nretvalues = mm_parse$readreturntype((struct mm_decls$strec *)owner,&retmodes);
        }
;
    }
    else if ((((i64)mm_decls$lx.symbol == (i64)7) || ((i64)mm_decls$lx.symbol == (i64)11))) {
        mm_lex$lex();
        nretvalues = mm_parse$readreturntype((struct mm_decls$strec *)owner,&retmodes);
    }
;
    mm_parse$dretvar = 0;
    if ((nretvalues == (i64)1)) {
        if (((i64)mm_decls$lx.symbol == (i64)81)) {
            mm_parse$dretvar = (struct mm_decls$strec *)mm_decls$lx.symptr;
            mm_lex$lex();
        }
;
    }
;
    if (!((!!(nretvalues) || (kwd != (i64)131)))) {
        mm_support$serror((byte*)"Function needs ret type");
    }
;
    if ((!!(nretvalues) && (kwd != (i64)131))) {
        mm_support$serror((byte*)"Proc can't return value");
    }
;
    (*stproc).paramlist = (struct mm_decls$strec *)paramlist;
    (*stproc).nretvalues = nretvalues;
    if ((nretvalues==(i64)0)) {
        (*stproc).mode = (i64)0;
    }
    else if ((nretvalues==(i64)1)) {
        mm_lib$storemode((struct mm_decls$strec *)procowner,retmodes[((i64)1)-1],&(*stproc).mode);
    }
    else {
        (*stproc).mode = mm_lib$createtuplemode((struct mm_decls$strec *)procowner,&retmodes,nretvalues,(i64)0);
    }
;
    if (((i64)mm_decls$lx.symbol == (i64)22)) {
        mm_parse$lexchecksymbol((i64)81);
        mm_support$serror((byte*)"READPROCDEF @");
        mm_lex$lex();
        (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)10,(u64)1u);
    }
;
    (*stproc).code = 0;
    if ((fflang==(i64)2) || (fflang==(i64)1)) {
    }
    else {
                {i64 $temp = (i64)(*procowner).nameid;
if (($temp==(i64)3)) {
        }
        else if (($temp==(i64)4)) {
            mm_support$serror((byte*)"Need FF specifier");
        }
        };
    }
;
    (*stproc).scope = scope;
    (*stproc).varparams = varparams;
    (*stproc).fflang = fflang;
    if ((procowner == mm_decls$stmodule)) {
        if ((((i64)(*stproc).namelen == (i64)5) && !!(mlib$eqstring((*stproc).name,(byte*)"start")))) {
            mm_decls$moduletable[((i64)(*mm_decls$stmodule).moduleno)].ststart = (struct mm_decls$strec *)stproc;
            (*stproc).scope = (i64)1;
        }
        else if (((((i64)(*stproc).namelen == (i64)4) && !!(mlib$eqstring((*stproc).name,(byte*)"main"))) && ((i64)(*mm_decls$stmodule).moduleno == mm_decls$mainmoduleno))) {
            mm_decls$moduletable[((i64)(*mm_decls$stmodule).moduleno)].stmain = (struct mm_decls$strec *)stproc;
            (*stproc).scope = (i64)3;
        }
;
    }
;
    mm_parse$popproc();
    return (struct mm_decls$strec *)stproc;
}

static struct mm_decls$strec *mm_parse$readparams(struct mm_decls$strec *procowner,struct mm_decls$strec *owner,i64 fflang,i64 *varparams,i64 *nparams) {
        struct mm_decls$strec *  stlist;
        struct mm_decls$strec *  stlistx;
        struct mm_decls$strec *  stname;
        i64 parammode;
        i64 pmode;
        i64 m;
        i64 isoptional;
        i64 types;
        u8 str[32];
    stlist = (stlistx = 0);
    pmode = (i64)0;
    (*nparams) = (i64)0;
    parammode = (i64)0;
    types = (i64)0;
    if ((fflang == (i64)0)) {
        fflang = (i64)3;
    }
;
    if ((((i64)mm_decls$lx.symbol == (i64)81) && ((i64)mm_decls$nextlx.symbol == (i64)5 || (i64)mm_decls$nextlx.symbol == (i64)14))) {
        types = (i64)1;
    }
;
    L572 :;
    while (1) {
        parammode = (i64)0;
        isoptional = (i64)0;
        if ((!!(types) || !!(mm_parse$istypestarter()))) {
            pmode = mm_parse$readtypespec((struct mm_decls$strec *)procowner,(i64)0);
            //gotmode:
L574 :;
;
            if ((((*nparams) == (i64)0) && ((i64)mm_decls$lx.symbol == (i64)5 || (i64)mm_decls$lx.symbol == (i64)14))) {
                L575 :;
                while (1) {
                    ++((*nparams));
                    str[((i64)1)-1] = '$';
                    str[((i64)2)-1] = (u64)0u;
                    strcat(str,msysc$strint((*nparams),0));
                    stname = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)mm_lex$addnamestr((u8 *)str),(i64)13);
                    mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stname);
                    mm_lib$storemode((struct mm_decls$strec *)owner,pmode,&(*stname).mode);
                    (*stname).parammode = parammode;
                    mm_parse$addlistparam((struct mm_decls$strec **)&stlist,(struct mm_decls$strec **)&stlistx,(struct mm_decls$strec *)stname);
                                        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)14)) {
                        goto L576 ;
                    }
                    };
                    mm_parse$checksymbol((i64)5);
                    mm_lex$lex();
                    if (((i64)mm_decls$lx.symbol == (i64)29)) {
                        (*varparams) = ((*nparams) + (i64)1);
                        mm_lex$lex();
                        goto L576 ;
                    }
;
                    pmode = mm_parse$readtypespec((struct mm_decls$strec *)procowner,(i64)0);
                }
L576 :;
                ;
                return (struct mm_decls$strec *)stlist;
            }
;
        }
        else if ((pmode == (i64)0)) {
            mm_support$serror((byte*)"Type expected");
        }
;
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)52)) {
            parammode = (i64)1;
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol == (i64)7)) {
                mm_lex$lex();
            }
;
        }
        else if (($temp==(i64)96) || ($temp==(i64)25)) {
            parammode = (i64)2;
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol == (i64)7)) {
                mm_lex$lex();
            }
;
        }
        else if (($temp==(i64)24)) {
            isoptional = (i64)1;
            mm_lex$lex();
        }
        else if (($temp==(i64)29)) {
            (*varparams) = (i64)1;
            mm_lex$lex();
            return (struct mm_decls$strec *)stlist;
        }
        };
        mm_parse$checksymbol((i64)81);
        ++((*nparams));
        stname = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)mm_decls$lx.symptr,(i64)13);
        mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stname);
        mm_lex$lex();
        if ((parammode == (i64)2)) {
            m = mm_lib$createrefmode((struct mm_decls$strec *)procowner,pmode,(i64)0);
        }
        else {
            m = pmode;
        }
;
        mm_lib$storemode((struct mm_decls$strec *)owner,m,&(*stname).mode);
        (*stname).parammode = parammode;
        (*stname).optional = isoptional;
        mm_parse$addlistparam((struct mm_decls$strec **)&stlist,(struct mm_decls$strec **)&stlistx,(struct mm_decls$strec *)stname);
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)9) || ($temp==(i64)48)) {
            mm_lex$lex();
            (*stname).code = mm_parse$readunit();
            (*stname).equals = (i64)1;
            (*stname).optional = (i64)1;
        }
        };
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)5)) {
            mm_lex$lex();
        }
        else if (($temp==(i64)14)) {
            goto L573 ;
        }
        else {
            mm_support$serror((byte*)"nameparams1");
        }
        };
    }
L573 :;
    ;
    return (struct mm_decls$strec *)stlist;
}

static struct mm_decls$unitrec *mm_parse$readcondsuffix(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  q;
    switch ((i64)mm_decls$lx.symbol) {
    case 110:;
        {
            mm_lex$lex();
            return (struct mm_decls$unitrec *)mm_lib$createunit2((i64)94,(struct mm_decls$unitrec *)mm_parse$fixcond(mm_parse$readunit()),(struct mm_decls$unitrec *)mm_lib$createunit1((i64)6,(struct mm_decls$unitrec *)p));
        }
        break;
    case 106:;
        {
            mm_lex$lex();
            q = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)16,(struct mm_decls$unitrec *)mm_parse$fixcond(mm_parse$readunit()));
            (*q).pclop = (i64)32;
            return (struct mm_decls$unitrec *)mm_lib$createunit2((i64)94,(struct mm_decls$unitrec *)q,(struct mm_decls$unitrec *)mm_lib$createunit1((i64)6,(struct mm_decls$unitrec *)p));
        }
        break;
    default: {
        return p;
    }
    } //SW
;
}

static struct mm_decls$unitrec *mm_parse$readif(void) {
        i64 pos1;
        i64 kwd;
        struct mm_decls$unitrec *  clist;
        struct mm_decls$unitrec *  clistx;
        struct mm_decls$unitrec *  plist;
        struct mm_decls$unitrec *  plistx;
        struct mm_decls$unitrec *  pelse;
        struct mm_decls$unitrec *  p;
    pos1 = (i64)mm_decls$lx.pos;
    kwd = (i64)mm_decls$lx.symbol;
    clist = (clistx = (plist = (plistx = (pelse = 0))));
    L577 :;
    do {
        mm_lex$lex();
        mm_lib$addlistunit(&clist,&clistx,mm_parse$fixcond(mm_parse$readsunit((i64)0)));
        mm_parse$skipsemi();
        mm_parse$checksymbol((i64)99);
        mm_lex$lex();
        mm_lib$addlistunit(&plist,&plistx,mm_parse$readsunit((i64)0));
        mm_parse$skipsemi();
L578 :;
    }
    while (!((i64)mm_decls$lx.symbol != (i64)100));
L579 :;
    ;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)101)) {
        mm_lex$lex();
        pelse = mm_parse$readsunit((i64)0);
        mm_parse$checkend((i64)105,kwd,(i64)0,(i64)0);
        mm_lex$lex();
    }
    else if (($temp==(i64)102) || ($temp==(i64)103)) {
        mm_decls$lx.symbol = kwd;
        pelse = mm_parse$makeblock(mm_parse$readswitchcase());
    }
    else {
        mm_parse$checkend((i64)105,kwd,(i64)0,(i64)0);
        mm_lex$lex();
    }
    };
    p = (struct mm_decls$unitrec *)mm_lib$createunit3((i64)94,(struct mm_decls$unitrec *)clist,(struct mm_decls$unitrec *)plist,(struct mm_decls$unitrec *)pelse);
    (*p).pos = pos1;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readgoto(i64 gototag) {
    if (((i64)mm_decls$lx.subcode == (i64)1)) {
        mm_parse$lexchecksymbol((i64)112);
    }
;
    mm_lex$lex();
    return mm_parse$readcondsuffix((struct mm_decls$unitrec *)mm_lib$createunit1(gototag,(struct mm_decls$unitrec *)mm_parse$readunit()));
}

static struct mm_decls$unitrec *mm_parse$readunless(void) {
        i64 pos;
        struct mm_decls$unitrec *  pcond;
        struct mm_decls$unitrec *  pthen;
        struct mm_decls$unitrec *  pelse;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
    pos = (i64)mm_decls$lx.pos;
    mm_lex$lex();
    pcond = mm_parse$fixcond(mm_parse$readsunit((i64)0));
    mm_parse$checksymbol((i64)99);
    mm_lex$lex();
    pthen = mm_parse$readsunit((i64)0);
    if (((i64)mm_decls$lx.symbol == (i64)101)) {
        mm_lex$lex();
        pelse = mm_parse$readsunit((i64)0);
    }
    else {
        pelse = 0;
    }
;
    mm_parse$checkend((i64)105,(i64)106,(i64)0,(i64)0);
    mm_lex$lex();
    p = (struct mm_decls$unitrec *)mm_lib$createunit3((i64)94,(struct mm_decls$unitrec *)(q = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)16,(struct mm_decls$unitrec *)pcond)),(struct mm_decls$unitrec *)pthen,(struct mm_decls$unitrec *)pelse);
    (*q).pclop = (i64)32;
    (*p).pos = pos;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readswitchcase(void) {
        i64 pos1;
        i64 kwd;
        i64 opc;
        i64 pos2;
        i64 rangeused;
        i64 nwhen;
        struct mm_decls$unitrec *  pexpr;
        struct mm_decls$unitrec *  pwhenlist;
        struct mm_decls$unitrec *  pwhenlistx;
        struct mm_decls$unitrec *  pwhen;
        struct mm_decls$unitrec *  pwhenx;
        struct mm_decls$unitrec *  pelse;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  pthen;
        struct mm_decls$unitrec *  pwhenthen;
    pos1 = (i64)mm_decls$lx.pos;
    kwd = (i64)mm_decls$lx.symbol;
    opc = (i64)mm_decls$lx.subcode;
    mm_lex$lex();
    mm_parse$skipsemi();
    if (((i64)mm_decls$lx.symbol == (i64)110)) {
        if ((kwd == (i64)123)) {
            mm_support$serror((byte*)"switch expr missing");
        }
;
        pexpr = 0;
    }
    else {
        pexpr = mm_parse$readsunit((i64)0);
    }
;
    pwhenlist = (pwhenlistx = 0);
    rangeused = (i64)0;
    nwhen = (i64)0;
    mm_parse$skipsemi();
    L580 :;
    while (((i64)mm_decls$lx.symbol == (i64)110)) {
        pos2 = (i64)mm_decls$lx.pos;
        mm_lex$lex();
        pwhen = (pwhenx = 0);
        L583 :;
        while (1) {
            p = mm_parse$readunit();
            ++(nwhen);
            (*p).pos = pos2;
            if (((i64)(*p).tag == (i64)19)) {
                rangeused = (i64)1;
            }
;
            mm_lib$addlistunit(&pwhen,&pwhenx,p);
            if (((i64)mm_decls$lx.symbol != (i64)5)) {
                goto L584 ;
            }
;
            mm_lex$lex();
        }
L584 :;
        ;
        if (((i64)mm_decls$lx.symbol != (i64)11)) {
            mm_parse$checksymbol((i64)99);
        }
;
        mm_lex$lex();
        pthen = mm_parse$readsunit((i64)0);
        pwhenthen = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)86,(struct mm_decls$unitrec *)pwhen,(struct mm_decls$unitrec *)pthen);
        (*pwhenthen).pos = pos2;
        mm_lib$addlistunit(&pwhenlist,&pwhenlistx,pwhenthen);
L581 :;
    }
L582 :;
    ;
    if (((opc == (i64)109) && !(!!(rangeused)))) {
        if ((nwhen <= (i64)8)) {
        }
;
    }
;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)101)) {
        mm_lex$lex();
        pelse = mm_parse$readsunit((i64)0);
        mm_parse$checkend((i64)105,kwd,(i64)0,(i64)0);
        mm_lex$lex();
    }
    else if (($temp==(i64)100)) {
        mm_decls$lx.symbol = kwd;
        pelse = mm_parse$makeblock(mm_parse$readif());
    }
    else if (($temp==(i64)102) || ($temp==(i64)103)) {
        mm_decls$lx.symbol = kwd;
        pelse = mm_parse$makeblock(mm_parse$readswitchcase());
    }
    else {
        pelse = 0;
        mm_parse$checkend((i64)105,kwd,(i64)0,(i64)0);
        mm_lex$lex();
    }
    };
    p = (struct mm_decls$unitrec *)mm_lib$createunit3(opc,(struct mm_decls$unitrec *)pexpr,(struct mm_decls$unitrec *)pwhenlist,(struct mm_decls$unitrec *)pelse);
    (*p).pos = pos1;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readstop(void) {
        struct mm_decls$unitrec *  p;
    mm_lex$lex();
    if (!!((i64)mm_tables$exprstarter[((i64)mm_decls$lx.symbol)-1])) {
        p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)124,(struct mm_decls$unitrec *)mm_parse$readunit());
    }
    else {
        p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)124);
    }
;
    return mm_parse$readcondsuffix(p);
}

static struct mm_decls$unitrec *mm_parse$readreturn(void) {
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
    mm_lex$lex();
    if (!!((i64)mm_tables$exprstarter[((i64)mm_decls$lx.symbol)-1])) {
        q = mm_parse$readunit();
        p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)91,(struct mm_decls$unitrec *)q);
        (*p).length = (i64)1;
    }
    else {
        p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)91);
        (*p).length = (i64)0;
    }
;
    return mm_parse$readcondsuffix(p);
}

static struct mm_decls$unitrec *mm_parse$readdo(void) {
        struct mm_decls$unitrec *  p;
        i64 pos;
    pos = (i64)mm_decls$lx.pos;
    mm_lex$lex();
    p = mm_parse$readsunit((i64)0);
    mm_parse$checkend((i64)105,(i64)114,(i64)0,(i64)0);
    mm_lex$lex();
    p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)106,(struct mm_decls$unitrec *)p);
    (*p).pos = pos;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readto(void) {
        i64 pos;
        i64 id;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  pcount;
        struct mm_decls$unitrec *  pbody;
    pos = (i64)mm_decls$lx.pos;
    mm_lex$lex();
    pcount = mm_parse$readunit();
    mm_parse$checksymbol((i64)114);
    mm_lex$lex();
    pbody = mm_parse$readsunit((i64)0);
    mm_parse$checkend((i64)105,(i64)112,(i64)114,(i64)0);
    mm_lex$lex();
    id = (i64)12;
    if (((i64)(*mm_decls$currproc).nameid != (i64)6)) {
        id = (i64)11;
    }
;
    p = (struct mm_decls$unitrec *)mm_lib$createunit3((i64)93,(struct mm_decls$unitrec *)pcount,(struct mm_decls$unitrec *)pbody,(struct mm_decls$unitrec *)mm_lib$createname(mm_lib$getavname(mm_decls$currproc,id)));
    (*p).pos = pos;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readwhile(void) {
        i64 pos;
        struct mm_decls$unitrec *  pcond;
        struct mm_decls$unitrec *  pbody;
        struct mm_decls$unitrec *  pincr;
        struct mm_decls$unitrec *  p;
    pos = (i64)mm_decls$lx.pos;
    mm_lex$lex();
    pcond = mm_parse$fixcond(mm_parse$readsunit((i64)1));
    pincr = 0;
    if (((i64)mm_decls$lx.symbol == (i64)5)) {
        mm_lex$lex();
        pincr = mm_parse$readsunit((i64)1);
    }
;
    mm_parse$checksymbol((i64)114);
    mm_lex$lex();
    pbody = mm_parse$readsunit((i64)0);
    if (((i64)mm_decls$lx.symbol == (i64)121)) {
        if (!!(pincr)) {
            mm_support$serror((byte*)"Double incr");
        }
;
        mm_lex$lex();
        pincr = mm_parse$readsunit((i64)0);
    }
;
    mm_parse$checkend((i64)105,(i64)115,(i64)114,(i64)0);
    mm_lex$lex();
    p = (struct mm_decls$unitrec *)mm_lib$createunit3((i64)99,(struct mm_decls$unitrec *)pcond,(struct mm_decls$unitrec *)pbody,(struct mm_decls$unitrec *)pincr);
    (*p).pos = pos;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readrepeat(void) {
        i64 pos;
        struct mm_decls$unitrec *  pbody;
        struct mm_decls$unitrec *  pcond;
        struct mm_decls$unitrec *  p;
    pos = (i64)mm_decls$lx.pos;
    mm_lex$lex();
    pbody = mm_parse$readsunit((i64)0);
    mm_parse$checksymbol((i64)117);
    mm_lex$lex();
    pcond = mm_parse$fixcond(mm_parse$readunit());
    p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)100,(struct mm_decls$unitrec *)pbody,(struct mm_decls$unitrec *)pcond);
    (*p).pos = pos;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readloopcontrol(void) {
        i64 opc;
        struct mm_decls$unitrec *  p;
    opc = (i64)mm_decls$lx.subcode;
    mm_lex$lex();
    if ((((i64)mm_decls$lx.symbol == (i64)81) && !!(mlib$eqstring((*mm_decls$lx.symptr).name,(byte*)"all")))) {
        mm_lex$lex();
        p = (struct mm_decls$unitrec *)mm_lib$createunit1(opc,(struct mm_decls$unitrec *)mm_lib$createconstunit((u64)0u,(i64)3));
    }
    else if (!!((i64)mm_tables$exprstarter[((i64)mm_decls$lx.symbol)-1])) {
        p = (struct mm_decls$unitrec *)mm_lib$createunit1(opc,(struct mm_decls$unitrec *)mm_parse$readconstexpr((i64)1));
    }
    else {
        p = (struct mm_decls$unitrec *)mm_lib$createunit1(opc,(struct mm_decls$unitrec *)mm_lib$createconstunit((u64)1u,(i64)3));
    }
;
    return mm_parse$readcondsuffix(p);
}

static struct mm_decls$unitrec *mm_parse$readprint(void) {
        i64 oldinreadprint;
        i64 opc;
        i64 isfprint;
        i64 fshowname;
        struct mm_decls$unitrec *  pformat;
        struct mm_decls$unitrec *  pdev;
        struct mm_decls$unitrec *  printlist;
        struct mm_decls$unitrec *  printlistx;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
        struct mlib$strbuffer *  expr;
        u8 *  s;
    oldinreadprint = mm_parse$inreadprint;
    mm_parse$inreadprint = (i64)1;
    opc = (i64)mm_decls$lx.subcode;
    if ((opc==(i64)116) || (opc==(i64)117)) {
        isfprint = (i64)1;
    }
    else {
        isfprint = (i64)0;
    }
;
    mm_lex$lex();
    printlist = (printlistx = 0);
    pformat = (pdev = 0);
    if (((i64)mm_decls$lx.symbol == (i64)22)) {
        mm_lex$lex();
        pdev = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)5)) {
            mm_lex$lex();
        }
        else {
            goto L585 ;
;
        }
;
    }
;
    if (!!(isfprint)) {
        pformat = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)5)) {
            mm_lex$lex();
        }
        else {
            goto L585 ;
;
        }
;
    }
;
    if (!(!!((i64)mm_tables$exprstarter[((i64)mm_decls$lx.symbol)-1]))) {
        goto L585 ;
;
    }
;
    L586 :;
    while (1) {
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)5)) {
            mm_lib$addlistunit(&printlist,&printlistx,(struct mm_decls$unitrec *)mm_lib$createunit0((i64)88));
        }
        else if (($temp==(i64)160)) {
            mm_lib$addlistunit(&printlist,&printlistx,(struct mm_decls$unitrec *)mm_lib$createunit0((i64)89));
            mm_lex$lex();
        }
        else {
            fshowname = (i64)0;
            if (((i64)mm_decls$lx.symbol == (i64)48)) {
                fshowname = (i64)1;
                mm_lex$lex();
            }
;
            p = mm_parse$readunit();
            if (((i64)mm_decls$lx.symbol == (i64)7)) {
                mm_lex$lex();
                p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)87,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readunit());
            }
;
            if (!!(fshowname)) {
                expr = (struct mlib$strbuffer *)mm_lib$strexpr((struct mm_decls$unitrec *)p);
                mlib$strbuffer_add((struct mlib$strbuffer *)expr,(byte*)"=",(i64)-1);
                s = (*expr).strptr;
                mlib$iconvucn((*expr).strptr,(i64)(*expr).length);
                mm_lib$addlistunit(&printlist,&printlistx,(q = (struct mm_decls$unitrec *)mm_lib$createstringconstunit(s,(i64)(*expr).length)));
            }
;
            mm_lib$addlistunit(&printlist,&printlistx,p);
        }
        };
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L587 ;
        }
;
        mm_lex$lex();
    }
L587 :;
    ;
    //finish:
L585 :;
;
    mm_parse$inreadprint = oldinreadprint;
    if (((opc == (i64)114) && (printlist == 0))) {
        mm_support$serror((byte*)"No print items");
    }
;
    if ((((opc == (i64)116) && (printlist == 0)) && (pformat == 0))) {
        mm_support$serror((byte*)"No print items");
    }
;
    if (!!(isfprint)) {
        if ((pformat == 0)) {
            mm_support$serror((byte*)"No fmt str");
        }
;
        return (struct mm_decls$unitrec *)mm_lib$createunit3(opc,(struct mm_decls$unitrec *)pdev,(struct mm_decls$unitrec *)pformat,(struct mm_decls$unitrec *)printlist);
    }
    else {
        return (struct mm_decls$unitrec *)mm_lib$createunit2(opc,(struct mm_decls$unitrec *)pdev,(struct mm_decls$unitrec *)printlist);
    }
;
}

static struct mm_decls$unitrec *mm_parse$readread(void) {
        i64 oldinreadprint;
        i64 opc;
        struct mm_decls$unitrec *  pformat;
        struct mm_decls$unitrec *  pdev;
        struct mm_decls$unitrec *  readlist;
        struct mm_decls$unitrec *  readlistx;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  pread;
    oldinreadprint = mm_parse$inreadprint;
    mm_parse$inreadprint = (i64)1;
    opc = (i64)mm_decls$lx.subcode;
    mm_lex$lex();
    readlist = (readlistx = 0);
    pformat = (pdev = 0);
    if (((i64)mm_decls$lx.symbol == (i64)22)) {
        if ((opc == (i64)120)) {
            mm_support$serror((byte*)"@ on read");
        }
;
        mm_lex$lex();
        pdev = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)5)) {
            mm_lex$lex();
        }
;
    }
;
    if ((opc == (i64)121)) {
        mm_lib$addlistunit(&readlist,&readlistx,(struct mm_decls$unitrec *)mm_lib$createunit1((i64)121,(struct mm_decls$unitrec *)pdev));
    }
;
    if (!(!!((i64)mm_tables$exprstarter[((i64)mm_decls$lx.symbol)-1]))) {
        goto L588 ;
;
    }
;
    L589 :;
    while (1) {
        p = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)7)) {
            mm_lex$lex();
            pformat = mm_parse$readunit();
        }
        else {
            pformat = 0;
        }
;
        pread = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)120,(struct mm_decls$unitrec *)pformat);
        p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)26,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)pread);
        mm_lib$addlistunit(&readlist,&readlistx,p);
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L590 ;
        }
;
        mm_lex$lex();
    }
L590 :;
    ;
    //finish:
L588 :;
;
    mm_parse$inreadprint = oldinreadprint;
    if (((opc == (i64)120) && (readlist == 0))) {
        mm_support$serror((byte*)"No read items");
    }
;
    if (!!((*readlist).nextunit)) {
        return (struct mm_decls$unitrec *)mm_lib$createunit1((i64)6,(struct mm_decls$unitrec *)readlist);
    }
    else {
        return readlist;
    }
;
}

static struct mm_decls$unitrec *mm_parse$readfor(void) {
        i64 pos;
        i64 opc;
        struct mm_decls$unitrec *  pindex;
        struct mm_decls$unitrec *  plocal;
        struct mm_decls$unitrec *  pfrom;
        struct mm_decls$unitrec *  pto;
        struct mm_decls$unitrec *  pstep;
        struct mm_decls$unitrec *  ptoinit;
        struct mm_decls$unitrec *  plist;
        struct mm_decls$unitrec *  passign;
        struct mm_decls$unitrec *  pcond;
        struct mm_decls$unitrec *  pbody;
        struct mm_decls$unitrec *  pelse;
        struct mm_decls$unitrec *  p;
        i64 i;
    pos = (i64)mm_decls$lx.pos;
    mm_lex$lex();
    plocal = 0;
    ptoinit = 0;
    pindex = mm_parse$readname();
    if ((mm_parse$nforloops >= (i64)10)) {
        mm_support$serror((byte*)"Too many for-loops");
    }
;
    for (i=(i64)1;i<=mm_parse$nforloops;++i) {
L591 :;
        if ((mm_parse$forindexvars[(i)-1] == (*pindex).def)) {
            mm_support$serror((byte*)"Re-using nested loop index");
        }
;
L592 :;
    }
L593 :;
    ;
    mm_parse$forindexvars[(++(mm_parse$nforloops))-1] = (struct mm_decls$strec *)(*pindex).def;
    if (((i64)mm_decls$lx.symbol == (i64)5)) {
        mm_lex$lex();
        plocal = mm_parse$readname();
    }
;
    opc = (i64)95;
    pstep = 0;
    pcond = 0;
    if (((i64)mm_decls$lx.symbol == (i64)52 || (i64)mm_decls$lx.symbol == (i64)54)) {
        if (((i64)mm_decls$lx.symbol == (i64)39)) {
            opc = (i64)96;
        }
;
        mm_lex$lex();
        plist = mm_parse$readunit();
        if ((((i64)(*plist).tag == (i64)35) && ((i64)(*plist).pclop == (i64)91))) {
            pfrom = (struct mm_decls$unitrec *)mm_lib$getrangelwbunit((struct mm_decls$unitrec *)(*plist).a);
            pto = (struct mm_decls$unitrec *)mm_lib$getrangeupbunit((struct mm_decls$unitrec *)(*plist).a);
        }
        else if (((i64)(*plist).tag == (i64)19)) {
            pfrom = (*plist).a;
            pto = (*plist).b;
        }
        else {
            opc = ((opc == (i64)95) ? (i64)97 : (i64)98);
            pfrom = (struct mm_decls$unitrec *)mm_lib$getrangelwbunit((struct mm_decls$unitrec *)mm_lib$duplunit(plist,(i64)0));
            pto = (struct mm_decls$unitrec *)mm_lib$getrangeupbunit((struct mm_decls$unitrec *)mm_lib$duplunit(plist,(i64)0));
        }
;
    }
    else {
        if (((i64)mm_decls$lx.symbol == (i64)9)) {
            mm_lex$lex();
            pfrom = mm_parse$readunit();
        }
        else {
            pfrom = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)1u,(i64)3);
        }
;
        mm_parse$checksymbol((i64)112);
        opc = (((i64)mm_decls$lx.subcode == (i64)1) ? (i64)96 : (i64)95);
        mm_lex$lex();
        pto = mm_parse$readunit();
        if (((i64)mm_decls$lx.symbol == (i64)113)) {
            mm_lex$lex();
            pstep = mm_parse$readconstexpr((i64)0);
            if (((i64)(*pstep).tag == (i64)1)) {
                if (((*pstep).value == (i64)1)) {
                    pstep = 0;
                }
;
            }
;
        }
;
    }
;
    if (((i64)mm_decls$lx.symbol == (i64)110)) {
        mm_lex$lex();
        pcond = mm_parse$fixcond(mm_parse$readunit());
    }
;
    mm_parse$checksymbol((i64)114);
    mm_lex$lex();
    pbody = mm_parse$readsunit((i64)0);
    pelse = 0;
    if (((i64)mm_decls$lx.symbol == (i64)101)) {
        mm_lex$lex();
        pelse = mm_parse$readsunit((i64)0);
    }
;
    mm_parse$checkend((i64)105,(i64)111,(i64)114,(i64)0);
    mm_lex$lex();
    if ((pcond != 0)) {
        pbody = mm_parse$makeblock((struct mm_decls$unitrec *)mm_lib$createunit2((i64)94,(struct mm_decls$unitrec *)pcond,(struct mm_decls$unitrec *)pbody));
    }
;
    (*pbody).nextunit = pelse;
    if ((opc==(i64)95) || (opc==(i64)96)) {
        if (!!(plocal)) {
            mm_support$serror((byte*)"for i,x?");
        }
;
        (*pindex).avcode = (i64)73;
        if (!(((i64)(*pto).tag == (i64)1 || (i64)(*pto).tag == (i64)4))) {
            plocal = (struct mm_decls$unitrec *)mm_lib$createname(mm_lib$getavname(mm_decls$currproc,(i64)12));
            (*plocal).avcode = (i64)73;
            ptoinit = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)26,(struct mm_decls$unitrec *)plocal,(struct mm_decls$unitrec *)pto);
            (*pindex).nextunit = ptoinit;
            pto = plocal;
        }
;
        (*pfrom).nextunit = pto;
        (*pto).nextunit = pstep;
        p = (struct mm_decls$unitrec *)mm_lib$createunit3(opc,(struct mm_decls$unitrec *)pindex,(struct mm_decls$unitrec *)pfrom,(struct mm_decls$unitrec *)pbody);
    }
    else {
        if ((plocal == 0)) {
            plocal = pindex;
            pindex = (struct mm_decls$unitrec *)mm_lib$createname(mm_lib$getavname(mm_decls$currproc,(i64)12));
        }
;
        (*pindex).avcode = (i64)73;
        (*plocal).avcode = (i64)76;
        (*pindex).nextunit = plocal;
        (*plocal).nextunit = pfrom;
        (*pfrom).nextunit = pto;
        passign = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)26,(struct mm_decls$unitrec *)mm_lib$duplunit(plocal,(i64)0),(struct mm_decls$unitrec *)mm_lib$createunit2((i64)44,(struct mm_decls$unitrec *)mm_lib$duplunit(plist,(i64)0),(struct mm_decls$unitrec *)mm_lib$duplunit(pindex,(i64)0)));
        (*plist).nextunit = passign;
        p = (struct mm_decls$unitrec *)mm_lib$createunit3(opc,(struct mm_decls$unitrec *)pindex,(struct mm_decls$unitrec *)plist,(struct mm_decls$unitrec *)pbody);
    }
;
    (*p).pos = pos;
    --(mm_parse$nforloops);
    return p;
}

static struct mm_decls$unitrec *mm_parse$readname(void) {
        struct mm_decls$unitrec *  p;
    p = mm_parse$readterm2();
    if (((i64)(*p).tag != (i64)4)) {
        mm_support$serror((byte*)"Name expected");
    }
;
    return p;
}

void mm_parse$readtypedef(struct mm_decls$strec *owner,i64 scope) {
        struct mm_decls$strec *  sttype;
        struct mm_decls$strec *  stname;
        i64 t;
        i64 m;
    mm_parse$lexchecksymbol((i64)81);
    stname = (struct mm_decls$strec *)mm_decls$lx.symptr;
    mm_lex$lex();
    mm_parse$checkequals();
    mm_lex$lex();
    sttype = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stname,(i64)5);
    mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)sttype);
    m = mm_lib$createusertype((struct mm_decls$strec *)sttype);
    mm_decls$ttusercat[(m)] = (i64)1;
    t = mm_parse$readtypespec((struct mm_decls$strec *)sttype,m);
    (*sttype).scope = scope;
    mm_lib$storemode((struct mm_decls$strec *)owner,t,&(*sttype).mode);
    if ((t >= (i64)0)) {
        if (!!(((i64)mm_decls$ttisinteger[(t)] + (i64)mm_decls$ttisreal[(t)]))) {
            mm_decls$tttarget[(m)] = t;
        }
        else if (!!((i64)mm_decls$ttisref[(t)])) {
        }
        else {
                        {i64 $temp = (i64)mm_decls$ttbasetype[(t)];
if (($temp==(i64)10)) {
            }
            else if (($temp==(i64)11)) {
            }
            else if (($temp==(i64)8)) {
            }
            else {
                mm_decls$tttarget[(m)] = t;
            }
            };
        }
;
    }
    else {
        mm_lib$storemode((struct mm_decls$strec *)owner,t,&mm_decls$tttarget[(m)]);
    }
;
    if ((t >= (i64)0)) {
        mm_lib$copyttvalues(m,t);
    }
    else {
        mm_decls$ttbasetype[(m)] = (i64)28;
    }
;
}

void mm_parse$readrecordfields(struct mm_decls$strec *owner,i64 m) {
        i64 nvars;
        i64 offset;
        struct mm_decls$strec *  stname;
        struct mm_decls$strec *  stbitfield;
    nvars = (i64)0;
    L594 :;
    while (((i64)mm_decls$lx.symbol == (i64)81)) {
        stname = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)mm_decls$lx.symptr,(i64)14);
        mm_lib$storemode((struct mm_decls$strec *)owner,m,&(*stname).mode);
        ++(nvars);
        if (!!((i64)mm_parse$unionpend.ulength)) {
            mm_lib$unionstr_copy((struct mm_decls$uflagsrec *)&(*stname).uflags,(struct mm_decls$uflagsrec *)&mm_parse$unionpend);
            mm_lib$unionstr_concat((struct mm_decls$uflagsrec *)&mm_parse$unionstring,(struct mm_decls$uflagsrec *)&mm_parse$unionpend);
            mm_lib$unionstr_clear(&mm_parse$unionpend);
        }
        else {
            mm_lib$unionstr_clear(&(*stname).uflags);
        }
;
        mm_parse$unionlastvar = (struct mm_decls$strec *)stname;
        mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stname);
        mm_lex$lex();
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)22)) {
            mm_lex$lex();
            (*stname).flags = msysc$m_setdotindex((*stname).flags,(i64)9,(u64)1u);
            (*stname).equivfield = (struct mm_decls$strec *)mm_parse$readequivfield((struct mm_decls$strec *)owner);
            if (((i64)mm_decls$lx.symbol == (i64)31)) {
                mm_lex$lex();
                offset = mm_parse$readconstint();
                if ((offset > (i64)255)) {
                    mm_support$serror((byte*)"Offset>255");
                }
;
                (*stname).equivoffset = offset;
            }
;
        }
        else if (($temp==(i64)23)) {
            mm_parse$lexchecksymbol((i64)72);
                        {i64 $temp = mm_decls$lx.value;
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4) || ($temp==(i64)8)) {
                (*stname).align = mm_decls$lx.value;
            }
            else if (($temp==(i64)0)) {
                (*stname).align = (i64)255;
            }
            else {
                mm_support$serror((byte*)"@@ bad align");
            }
            };
            mm_lex$lex();
        }
        else if (($temp==(i64)7)) {
            mm_parse$lexchecksymbol((i64)13);
            L597 :;
            do {
                mm_parse$lexchecksymbol((i64)81);
                stbitfield = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)mm_decls$lx.symptr,(i64)14);
                (*stbitfield).mode = (i64)26;
                mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stbitfield);
                (*stbitfield).flags = msysc$m_setdotindex((*stbitfield).flags,(i64)9,(u64)1u);
                (*stbitfield).equivfield = (struct mm_decls$strec *)stname;
                mm_parse$lexchecksymbol((i64)7);
                mm_parse$lexchecksymbol((i64)72);
                (*stbitfield).bitfieldwidth = mm_decls$lx.value;
                mm_lex$lex();
L598 :;
            }
            while (!((i64)mm_decls$lx.symbol != (i64)5));
L599 :;
            ;
            mm_parse$checksymbol((i64)14);
            mm_lex$lex();
        }
        };
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L596 ;
        }
;
        mm_lex$lex();
L595 :;
    }
L596 :;
    ;
    if ((nvars == (i64)0)) {
        mm_support$serror((byte*)"No fields declared");
    }
;
}

void mm_parse$readtabledef(struct mm_decls$strec *owner,i64 scope) {
        i64 i;
        i64 ncols;
        i64 nrows;
        i64 enums;
        i64 nextenumvalue;
        i64 firstval;
        i64 lastval;
        i64 startline;
        i64 closesym;
        i64 ltype;
        struct mm_decls$strec *  stvar;
        struct mm_decls$strec *  stenum;
        struct mm_decls$strec *  stgen;
        struct mm_decls$strec *  varnameptrs[20];
        i64 varlisttypes[20];
        struct mm_decls$unitrec *  plist[20];
        struct mm_decls$unitrec *  plistx[20];
        i64 enumvalues[500];
    enums = (i64)mm_decls$lx.subcode;
    mm_lex$lex();
    mm_parse$tabledataname = 0;
    if (((i64)mm_decls$lx.symbol == (i64)13)) {
        if (!(!!(enums))) {
            mm_support$serror((byte*)"use 'enumdata'");
        }
;
        enums = (i64)1;
        mm_lex$lex();
        mm_parse$checksymbol((i64)14);
        mm_lex$lex();
    }
;
    nextenumvalue = (i64)1;
    nrows = (i64)0;
    ncols = (i64)0;
    L600 :;
    while (((i64)mm_decls$lx.symbol != (i64)48)) {
        ltype = mm_parse$readtypespec((struct mm_decls$strec *)owner,(i64)0);
        mm_parse$checksymbol((i64)81);
        if ((++(ncols) > (i64)20)) {
            mm_support$serror((byte*)"tabledata/too many columns");
        }
;
        varnameptrs[(ncols)-1] = (struct mm_decls$strec *)mm_decls$lx.symptr;
        varlisttypes[(ncols)-1] = ltype;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)5)) {
            mm_lex$lex();
        }
        else {
            goto L602 ;
        }
;
L601 :;
    }
L602 :;
    ;
    mm_lex$lex();
    mm_parse$skipsemi();
    startline = mm_parse$getcurrline();
    closesym = mm_parse$checkbegin((i64)0);
    mm_parse$skipsemi();
    firstval = (lastval = (i64)0);
    for (i=(i64)1;i<=ncols;++i) {
L603 :;
        plist[(i)-1] = (plistx[(i)-1] = 0);
L604 :;
    }
L605 :;
    ;
    mm_parse$intabledata = (i64)1;
    L606 :;
    while (1) {
        mm_parse$skipsemi();
        if ((ncols > (i64)0)) {
            mm_parse$checksymbol((i64)13);
            mm_lex$lex();
        }
;
        if ((++(nrows) > (i64)500)) {
            mm_support$serror((byte*)"tabledata:too many rows");
        }
;
        if (!!(enums)) {
            mm_parse$checksymbol((i64)81);
            stgen = (struct mm_decls$strec *)mm_decls$lx.symptr;
            mm_parse$tabledataname = (*stgen).name;
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol == (i64)48)) {
                mm_lex$lex();
                nextenumvalue = mm_parse$readconstint();
            }
;
            enumvalues[(nrows)-1] = nextenumvalue;
            stenum = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stgen,(i64)10);
            (*stenum).mode = (i64)3;
            (*stenum).code = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)nextenumvalue,(i64)3);
            (*stenum).scope = scope;
            mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stenum);
            if ((scope == (i64)3)) {
                mm_lib$addexpconst((struct mm_decls$strec *)stenum);
            }
;
            if ((nrows == (i64)1)) {
                firstval = nextenumvalue;
            }
;
            lastval = nextenumvalue;
            ++(nextenumvalue);
            if (!!(ncols)) {
                mm_parse$checksymbol((i64)5);
                mm_lex$lex();
            }
;
        }
;
        for (i=(i64)1;i<=ncols;++i) {
L608 :;
            mm_lib$addlistunit(&plist[(i)-1],&plistx[(i)-1],mm_parse$readunit());
            if ((i == ncols)) {
                mm_parse$checksymbol((i64)14);
            }
            else {
                mm_parse$checksymbol((i64)5);
            }
;
            mm_lex$lex();
L609 :;
        }
L610 :;
        ;
        if (((i64)mm_decls$lx.symbol != (i64)5)) {
            goto L607 ;
        }
;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == closesym)) {
            goto L607 ;
        }
;
    }
L607 :;
    ;
    mm_parse$intabledata = (i64)0;
    mm_parse$skipsemi();
    mm_parse$checkbeginend(closesym,(i64)162,startline);
    if ((nrows == (i64)0)) {
        mm_support$serror((byte*)"No table data");
    }
;
    for (i=(i64)1;i<=ncols;++i) {
L611 :;
        stvar = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)varnameptrs[(i)-1],(i64)11);
        (*stvar).code = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)18,(struct mm_decls$unitrec *)plist[(i)-1]);
        (*(*stvar).code).length = nrows;
        mm_lib$storemode((struct mm_decls$strec *)owner,varlisttypes[(i)-1],&(*stvar).mode);
        (*stvar).scope = scope;
        mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stvar);
        mm_lib$addstatic((struct mm_decls$strec *)stvar);
L612 :;
    }
L613 :;
    ;
}

void mm_parse$readclassdef(struct mm_decls$strec *owner,i64 scope) {
        i64 kwd;
        i64 baseclass;
        i64 m;
        i64 startline;
        i64 closesym;
        i64 mrec;
        i64 isrecord;
        i64 align;
        struct mm_decls$strec *  nameptr;
        struct mm_decls$strec *  sttype;
    kwd = (i64)mm_decls$lx.symbol;
    isrecord = (i64)(kwd == (i64)133);
    mm_parse$lexchecksymbol((i64)81);
    nameptr = (struct mm_decls$strec *)mm_decls$lx.symptr;
    mm_lex$lex();
    baseclass = (i64)0;
    if (((i64)mm_decls$lx.symbol == (i64)13)) {
        mm_lex$lex();
        baseclass = mm_parse$readtypespec((struct mm_decls$strec *)owner,(i64)0);
        mm_parse$checksymbol((i64)14);
        mm_lex$lex();
    }
;
    mm_parse$checkequals();
    mm_lex$lex();
    align = (i64)0;
    if (((i64)mm_decls$lx.symbol == (i64)22)) {
        if (((i64)mm_decls$lx.subcode == (i64)0)) {
            mm_lex$lex();
            align = mm_parse$readconstint();
        }
        else {
            mm_lex$lex();
        }
;
        align = (i64)1;
    }
;
    sttype = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)nameptr,(i64)5);
    mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)sttype);
    m = mm_lib$createusertype((struct mm_decls$strec *)sttype);
    mrec = mm_lib$createrecordmode((struct mm_decls$strec *)owner,m);
    mm_lib$storemode((struct mm_decls$strec *)owner,mrec,&(*sttype).mode);
    mm_lib$storemode((struct mm_decls$strec *)owner,baseclass,&(*sttype).baseclass);
    (*sttype).align = align;
    closesym = mm_parse$checkbegin((i64)1);
    startline = mm_parse$getcurrline();
    mm_parse$readclassbody((struct mm_decls$strec *)sttype,kwd);
    mm_parse$checkbeginend(closesym,kwd,startline);
    (*sttype).scope = scope;
}

static void mm_parse$readclassbody(struct mm_decls$strec *owner,i64 classkwd) {
        i64 kwd;
        i64 t;
    mm_lib$unionstr_clear(&mm_parse$unionstring);
    mm_lib$unionstr_clear(&mm_parse$unionpend);
    L614 :;
    switch ((i64)mm_decls$lx.symbol) {
    case 149:;
        {
            mm_parse$readconstdef((struct mm_decls$strec *)owner,(i64)0);
        }
        break;
    case 131:;
    case 130:;
        {
            kwd = (i64)mm_decls$lx.symbol;
            if (!!(msysc$m_getdotindex((i64)(*owner).flags,(i64)12))) {
                mm_parse$readprocdecl((struct mm_decls$strec *)owner,(i64)0,(i64)0);
            }
            else {
                mm_parse$readprocdef((struct mm_decls$strec *)owner,(i64)0,(i64)0);
            }
;
        }
        break;
    case 152:;
    case 133:;
        {
            mm_parse$readclassdef((struct mm_decls$strec *)owner,(i64)0);
        }
        break;
    case 137:;
        {
            mm_parse$readtypedef((struct mm_decls$strec *)owner,(i64)0);
        }
        break;
    case 68:;
        {
            mm_support$serror((byte*)"Class eof?");
            goto L615 ;
        }
        break;
    case 6:;
        {
            mm_lex$lex();
        }
        break;
    case 162:;
        {
            mm_parse$readtabledef((struct mm_decls$strec *)owner,(i64)0);
        }
        break;
    case 146:;
        {
            mm_parse$readmacrodef((struct mm_decls$strec *)owner,(i64)0);
        }
        break;
    case 134:;
    case 135:;
        {
            mm_lib$unionstr_append((struct mm_decls$uflagsrec *)&mm_parse$unionpend,(((i64)mm_decls$lx.symbol == (i64)134) ? (i64)83 : (i64)85));
            mm_parse$unionlastvar = 0;
            mm_lex$lex();
        }
        break;
    case 105:;
    case 14:;
        {
            if (!!((i64)mm_parse$unionstring.ulength)) {
                mm_parse$checkend((i64)105,((mm_lib$unionstr_last((struct mm_decls$uflagsrec *)&mm_parse$unionstring) == (i64)83) ? (i64)134 : (i64)135),(i64)0,(i64)0);
                mm_lex$lex();
                if (((mm_parse$unionlastvar == 0) || !!((i64)mm_parse$unionpend.ulength))) {
                    mm_support$serror((byte*)"Empty union group");
                }
;
                                {i64 $temp = mm_lib$unionstr_last((struct mm_decls$uflagsrec *)&(*mm_parse$unionlastvar).uflags);
if (($temp==(i64)69) || ($temp==(i64)42)) {
                }
                else {
                    mm_lib$unionstr_append((struct mm_decls$uflagsrec *)&(*mm_parse$unionlastvar).uflags,(i64)42);
                }
                };
                mm_lib$unionstr_append((struct mm_decls$uflagsrec *)&(*mm_parse$unionlastvar).uflags,(i64)69);
                --(mm_parse$unionstring.ulength);
            }
            else {
                goto L615 ;
            }
;
        }
        break;
    case 141:;
        {
            mm_lex$lex();
            if (!!(mm_parse$istypestarter())) {
                //readmut:
L616 :;
;
                ++(mm_parse$insiderecord);
                t = mm_parse$readtypespec((struct mm_decls$strec *)owner,(i64)0);
                --(mm_parse$insiderecord);
            }
            else {
                t = (i64)21;
            }
;
            mm_parse$readrecordfields((struct mm_decls$strec *)owner,t);
        }
        break;
    case 142:;
        {
            mm_support$serror((byte*)"Let not allowed");
        }
        break;
    default: {
        if (!!(mm_parse$istypestarter())) {
            goto L616 ;
;
        }
        else {
            goto L615 ;
        }
;
    }
    } //SW
goto L614 ;
L615 :;
    ;
}

static void mm_parse$readimportmodule(struct mm_decls$strec *owner) {
        i64 isnew;
        i64 startline;
        i64 closesym;
        i64 libtype;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  stname;
    if (!!(mm_parse$insidedllimport)) {
        mm_support$serror((byte*)"nested importdll");
    }
;
    libtype = (i64)mm_decls$lx.subcode;
    mm_lex$lex();
    if (((i64)mm_decls$lx.symbol == (i64)77)) {
        stname = (struct mm_decls$strec *)mm_lex$addnamestr(mm_decls$lx.svalue);
    }
    else {
        mm_parse$checksymbol((i64)81);
        stname = (struct mm_decls$strec *)mm_decls$lx.symptr;
    }
;
    mm_lex$lex();
    if (((i64)mm_decls$lx.symbol == (i64)13)) {
        L617 :;
        do {
            mm_lex$lex();
            mm_parse$checksymbol((i64)81);
            mm_modules$addlib((*mm_decls$lx.symptr).name,libtype);
            mm_lex$lex();
L618 :;
        }
        while (!((i64)mm_decls$lx.symbol != (i64)5));
L619 :;
        ;
        mm_parse$checksymbol((i64)14);
        mm_lex$lex();
    }
;
    mm_parse$checkequals();
    mm_lex$lex();
    isnew = (i64)1;
    d = (struct mm_decls$strec *)(*stname).nextdupl;
    L620 :;
    while (!!(d)) {
        if (((i64)(*d).nameid == (i64)4)) {
            stname = d;
            isnew = (i64)0;
            goto L622 ;
        }
;
        d = (struct mm_decls$strec *)(*d).nextdupl;
L621 :;
    }
L622 :;
    ;
    if (!!(isnew)) {
        stname = (struct mm_decls$strec *)mm_lib$getduplnameptr(mm_decls$stmodule,(struct mm_decls$strec *)stname,(i64)4);
        mm_lib$adddef(mm_decls$stmodule,(struct mm_decls$strec *)stname);
        mm_modules$addlib((*stname).name,libtype);
        (*stname).dllindex = mm_decls$nlibfiles;
    }
;
    startline = mm_parse$getcurrline();
    closesym = mm_parse$checkbegin((i64)0);
    mm_parse$insidedllimport = (i64)(*stname).dllindex;
    mm_parse$readimportbody((struct mm_decls$strec *)owner);
    mm_parse$insidedllimport = (i64)0;
    mm_parse$checkbeginend(closesym,(i64)136,startline);
}

static void mm_parse$readimportbody(struct mm_decls$strec *owner) {
        i64 pos;
        i64 fflang;
        struct mm_decls$strec *  d;
    pos = (i64)mm_decls$lx.pos;
    L623 :;
    while (1) {
        mm_parse$skipsemi();
        switch ((i64)mm_decls$lx.symbol) {
        case 155:;
            {
                fflang = (i64)mm_decls$lx.subcode;
                mm_lex$lex();
                                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)130) || ($temp==(i64)131)) {
                    goto L625 ;
;
                }
                };
            }
            break;
        case 130:;
        case 131:;
            {
                fflang = (i64)0;
                //doproc:
L625 :;
;
                d = (struct mm_decls$strec *)mm_parse$readprocdecl((struct mm_decls$strec *)owner,(i64)0,fflang);
                if ((mm_decls$ndllproctable >= (i64)1000)) {
                    mm_support$serror((byte*)"Too many dll procs");
                }
;
                mm_decls$dllproctable[(++(mm_decls$ndllproctable))-1] = d;
            }
            break;
        case 137:;
            {
                mm_parse$readtypedef((struct mm_decls$strec *)owner,(i64)1);
            }
            break;
        case 149:;
            {
                mm_parse$readconstdef((struct mm_decls$strec *)owner,(i64)1);
            }
            break;
        case 152:;
        case 133:;
            {
                mm_parse$readclassdef((struct mm_decls$strec *)owner,(i64)1);
            }
            break;
        case 141:;
            {
                mm_lex$lex();
                mm_parse$readvardef((struct mm_decls$strec *)owner,(i64)1,(i64)0,(i64)8,(i64)141);
            }
            break;
        case 93:;
        case 81:;
        case 140:;
        case 97:;
        case 94:;
        case 15:;
        case 145:;
        case 143:;
            {
                mm_parse$readvardef((struct mm_decls$strec *)owner,(i64)1,(i64)0,(i64)8,(i64)0);
            }
            break;
        case 68:;
            {
                goto L624 ;
            }
            break;
        case 105:;
            {
                goto L624 ;
            }
            break;
        default: {
            mm_lex$ps((byte*)"symbol");
            mm_support$serror((byte*)"Not allowed in importmodule");
        }
        } //SW
;
    }
L624 :;
    ;
}

static struct mm_decls$strec *mm_parse$readequivfield(struct mm_decls$strec *owner) {
        struct mm_decls$strec *  p;
        struct mm_decls$strec *  d;
    mm_parse$checksymbol((i64)81);
    d = (struct mm_decls$strec *)mm_decls$lx.symptr;
    mm_lex$lex();
    p = (struct mm_decls$strec *)(*owner).deflist;
    L626 :;
    while (!!(p)) {
        if (!!(mlib$eqstring((*p).name,(*d).name))) {
            return (struct mm_decls$strec *)p;
        }
;
        p = (struct mm_decls$strec *)(*p).nextdef;
L627 :;
    }
L628 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((*d).name,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$serror((byte*)"Can't find @ field");
    return (struct mm_decls$strec *)0;
}

static i64 mm_parse$readrefproc(struct mm_decls$strec *owner,i64 typedefx,i64 fflang) {
        i64 kwd;
        i64 prettype;
        i64 m;
        i64 varparams;
        i64 nparams;
        i64 retmodes[4];
        struct mm_decls$strec *  paramlist;
        struct mm_decls$strec *  stproc;
        i64 nretvalues;
        u8 *  name;
    kwd = (i64)mm_decls$lx.symbol;
    mm_lex$lex();
    paramlist = 0;
    prettype = (i64)0;
    nretvalues = (i64)0;
    name = mm_lib$nextautotype();
    stproc = (struct mm_decls$strec *)mm_lib$getduplnameptr(mm_decls$stmodule,(struct mm_decls$strec *)mm_lex$addnamestr(name),(i64)5);
    mm_lib$adddef(mm_decls$stmodule,(struct mm_decls$strec *)stproc);
    retmodes[((i64)1)-1] = (i64)0;
    if ((kwd == (i64)131)) {
        if (((i64)mm_decls$lx.symbol == (i64)13)) {
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol != (i64)14)) {
                paramlist = (struct mm_decls$strec *)mm_parse$readparams((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stproc,(i64)0,&varparams,&nparams);
                mm_parse$checksymbol((i64)14);
            }
;
            mm_lex$lex();
            if ((((i64)mm_decls$lx.symbol == (i64)7) || ((i64)mm_decls$lx.symbol == (i64)11))) {
                mm_lex$lex();
                nretvalues = mm_parse$readreturntype((struct mm_decls$strec *)stproc,&retmodes);
            }
            else if ((!!((i64)mm_decls$typestarterset[((i64)mm_decls$lx.symbol)]) || ((i64)mm_decls$lx.symbol == (i64)81))) {
                nretvalues = mm_parse$readreturntype((struct mm_decls$strec *)stproc,&retmodes);
            }
;
        }
        else if ((((i64)mm_decls$lx.symbol == (i64)7) || ((i64)mm_decls$lx.symbol == (i64)11))) {
            mm_lex$lex();
            nretvalues = mm_parse$readreturntype((struct mm_decls$strec *)stproc,&retmodes);
        }
;
        if ((nretvalues == (i64)0)) {
            mm_support$serror((byte*)"Function needs return type");
        }
;
        if ((!!(nretvalues) && (kwd == (i64)130))) {
            mm_support$serror((byte*)"Proc can't return value");
        }
;
    }
    else {
        if (((i64)mm_decls$lx.symbol == (i64)13)) {
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol != (i64)14)) {
                paramlist = (struct mm_decls$strec *)mm_parse$readparams((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stproc,(i64)0,&varparams,&nparams);
                mm_parse$checksymbol((i64)14);
            }
;
            mm_lex$lex();
        }
;
        if (((!!((i64)mm_decls$typestarterset[((i64)mm_decls$lx.symbol)]) || ((i64)mm_decls$lx.symbol == (i64)7)) || ((i64)mm_decls$lx.symbol == (i64)11))) {
            mm_support$serror((byte*)"proc can't have ret value");
        }
;
    }
;
    m = mm_lib$createrefprocmode((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stproc,(struct mm_decls$strec *)paramlist,kwd,prettype,typedefx);
    mm_lib$storemode((struct mm_decls$strec *)owner,retmodes[((i64)1)-1],&(*stproc).mode);
    (*stproc).nretvalues = nretvalues;
    mm_decls$ttnamedef[(m)] = (struct mm_decls$strec *)stproc;
    (*stproc).fflang = fflang;
    return m;
}

static void mm_parse$pushproc(struct mm_decls$strec *p) {
    if ((mm_parse$nprocstack >= (i64)10)) {
        mm_support$serror((byte*)"Too many nested proc");
    }
;
    mm_parse$procstack[(++(mm_parse$nprocstack))-1] = (struct mm_decls$strec *)mm_decls$currproc;
    mm_decls$currproc = (struct mm_decls$strec *)p;
}

static void mm_parse$popproc(void) {
    if (!!(mm_parse$nprocstack)) {
        mm_decls$currproc = (struct mm_decls$strec *)mm_parse$procstack[((mm_parse$nprocstack)--)-1];
    }
    else {
        mm_decls$currproc = mm_decls$stmodule;
    }
;
}

static struct mm_decls$unitrec *mm_parse$makeastring(void) {
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  pconst;
        u8 *  s;
        i64 length;
        i64 $av_1;
    ulist = (ulistx = 0);
    s = mm_decls$lx.svalue;
    length = mm_lex$astringlength;
    $av_1 = mm_lex$astringlength;
    while ($av_1-- > 0) {
L629 :;
        pconst = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)(u64)(*s),(i64)3);
        mm_lib$addlistunit(&ulist,&ulistx,pconst);
        ++(s);
L630 :;
    }
L631 :;
    ;
    if (((i64)mm_decls$lx.subcode == (i64)90)) {
        pconst = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)0u,(i64)3);
        mm_lib$addlistunit(&ulist,&ulistx,pconst);
        ++(length);
    }
;
    p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)18,(struct mm_decls$unitrec *)ulist);
    (*p).length = length;
    return p;
}

static i64 mm_parse$readreturntype(struct mm_decls$strec *owner,i64 (*retmodes)[]) {
        i64 nretvalues;
    (*retmodes)[((i64)1)-1] = mm_parse$readtypespec((struct mm_decls$strec *)owner,(i64)0);
    nretvalues = (i64)1;
    L632 :;
    while (((i64)mm_decls$lx.symbol == (i64)5)) {
        if ((nretvalues >= (i64)4)) {
            mm_support$serror((byte*)"Too many return values");
        }
;
        mm_lex$lex();
        (*retmodes)[(++(nretvalues))-1] = mm_parse$readtypespec((struct mm_decls$strec *)owner,(i64)0);
L633 :;
    }
L634 :;
    ;
    return nretvalues;
}

static struct mm_decls$unitrec *mm_parse$readset(void) {
        i64 length;
        i64 nkeyvalues;
        i64 oldirp;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
    mm_lex$lex();
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)16)) {
        mm_lex$lex();
        return (struct mm_decls$unitrec *)mm_lib$createunit1((i64)20,0);
    }
    else if (($temp==(i64)7)) {
        mm_parse$lexchecksymbol((i64)16);
        mm_lex$lex();
        return (struct mm_decls$unitrec *)mm_lib$createunit1((i64)21,0);
    }
    };
    length = (i64)0;
    nkeyvalues = (i64)0;
    ulist = (ulistx = 0);
    L635 :;
    while (1) {
        oldirp = mm_parse$inreadprint;
        mm_parse$inreadprint = (i64)0;
        p = mm_parse$readunit();
        mm_parse$inreadprint = oldirp;
        if (((i64)(*p).tag == (i64)25)) {
            ++(nkeyvalues);
        }
;
        ++(length);
        mm_lib$addlistunit(&ulist,&ulistx,p);
                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)5)) {
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol == (i64)16)) {
                goto L636 ;
            }
;
        }
        else if (($temp==(i64)6)) {
            mm_parse$lexchecksymbol((i64)16);
            goto L636 ;
        }
        else if (($temp==(i64)16)) {
            goto L636 ;
        }
        else {
            mm_support$serror((byte*)"readset?");
        }
        };
        mm_parse$skipsemi();
    }
L636 :;
    ;
    mm_lex$lex();
    if (!!(nkeyvalues)) {
        if ((length > nkeyvalues)) {
            mm_support$serror((byte*)"dict: mixed elements");
        }
;
        p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)21,(struct mm_decls$unitrec *)ulist);
    }
    else {
        p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)20,(struct mm_decls$unitrec *)ulist);
    }
;
    (*p).length = length;
    return p;
}

static i64 mm_parse$istypestarter(void) {
    if (!!((i64)mm_decls$typestarterset[((i64)mm_decls$lx.symbol)])) {
        return (i64)1;
    }
;
    if (((i64)mm_decls$lx.symbol == (i64)81)) {
                {i64 $temp = (i64)mm_decls$nextlx.symbol;
if (($temp==(i64)81)) {
            return (i64)1;
        }
        else if (($temp==(i64)25)) {
            return (i64)1;
        }
        };
    }
;
    return (i64)0;
}

struct mm_decls$unitrec *mm_parse$readunit(void) {
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  pt;
        i64 pos;
    pt = 0;
    pos = (i64)mm_decls$lx.pos;
    pt = mm_parse$readterm2();
    ++(mm_decls$nreadassign);
    if (((i64)mm_tables$jisexpr[((i64)(*pt).tag)] == (i64)0)) {
        ++(mm_decls$nsimple);
        return pt;
    }
;
    if (((i64)mm_decls$lx.symbol == (i64)9)) {
        mm_lex$lex();
        p = mm_parse$readterm2();
        p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)26,(struct mm_decls$unitrec *)pt,(struct mm_decls$unitrec *)mm_parse$readassignment(p));
    }
    else {
        p = mm_parse$readassignment(pt);
        (*p).pos = pos;
    }
;
    L637 :;
    while (((i64)mm_decls$lx.symbol == (i64)12)) {
        mm_lex$lex();
        p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)31,(struct mm_decls$unitrec *)mm_parse$readassignment(0),(struct mm_decls$unitrec *)p);
L638 :;
    }
L639 :;
    ;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readassignment(struct mm_decls$unitrec *pt) {
        struct mm_decls$unitrec *  p;
        i64 pos;
        i64 opc;
        struct mm_decls$unitrec *  q;
    p = mm_parse$readorterms(pt);
    if (((opc = (i64)mm_decls$lx.symbol) == (i64)9 || (opc = (i64)mm_decls$lx.symbol) == (i64)10)) {
        pos = (i64)mm_decls$lx.pos;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)170)) {
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)128,(struct mm_decls$unitrec *)p);
            mm_lex$lex();
        }
        else {
            q = mm_parse$readassignment(0);
            if ((opc == (i64)10)) {
                q = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)30,(struct mm_decls$unitrec *)q);
            }
;
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)26,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)q);
        }
;
        (*p).pos = pos;
    }
;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readorterms(struct mm_decls$unitrec *pt) {
        struct mm_decls$unitrec *  p;
        i64 pos;
    p = mm_parse$readandterms(pt);
    L640 :;
    while (((i64)mm_decls$lx.symbol == (i64)46)) {
        pos = (i64)mm_decls$lx.pos;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)9)) {
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)36,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readassignment(0));
            (*p).pclop = (i64)73;
            (*p).pos = pos;
            goto L642 ;
        }
;
        p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)15,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readandterms(0));
        (*p).pclop = (i64)25;
        (*p).pos = pos;
L641 :;
    }
L642 :;
    ;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readandterms(struct mm_decls$unitrec *pt) {
        struct mm_decls$unitrec *  p;
        i64 pos;
    p = mm_parse$readcmpterms(pt);
    L643 :;
    while (((i64)mm_decls$lx.symbol == (i64)45)) {
        pos = (i64)mm_decls$lx.pos;
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol == (i64)9)) {
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)36,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readassignment(0));
            (*p).pclop = (i64)72;
            (*p).pos = pos;
            goto L645 ;
        }
;
        p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)14,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readcmpterms(0));
        (*p).pclop = (i64)24;
        (*p).pos = pos;
L644 :;
    }
L645 :;
    ;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readcmpterms(struct mm_decls$unitrec *pt) {
        struct mm_decls$unitrec *  p;
        i64 pos;
        i64 n;
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
        struct mm_decls$unitrec *  q;
        byte genops[4];
    p = mm_parse$readinterms(pt);
    if (!(((i64)mm_decls$lx.symbol == (i64)48 || (i64)mm_decls$lx.symbol == (i64)49))) {
        return p;
    }
;
    ulist = (ulistx = p);
    p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)33,(struct mm_decls$unitrec *)p);
    n = (i64)0;
    memset(&(genops),0,4);
    L646 :;
    switch ((i64)mm_decls$lx.symbol) {
    case 48:;
    case 49:;
        {
            ++(n);
            if ((n > (i64)4)) {
                mm_support$serror((byte*)"cmpchain: Too many items");
            }
;
            genops[(n)-1] = (i64)mm_decls$lx.subcode;
            pos = (i64)mm_decls$lx.pos;
            mm_lex$lex();
            q = mm_parse$readinterms(0);
            mm_lib$addlistunit(&ulist,&ulistx,q);
            (*q).pos = pos;
        }
        break;
    default: {
        goto L647 ;
    }
    } //SW
goto L646 ;
L647 :;
    ;
    if ((n == (i64)1)) {
        (*p).tag = (i64)32;
        q = (*p).a;
        (*p).pclop = (i64)genops[((i64)1)-1];
        (*p).b = (*q).nextunit;
        (*q).nextunit = 0;
    }
    else {
        memcpy(&(*p).cmpgenop,&genops,4);
    }
;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readinterms(struct mm_decls$unitrec *pt) {
        struct mm_decls$unitrec *  p;
        i64 pos;
        i64 opc;
    p = mm_parse$readrangeterm(pt);
    L648 :;
    switch ((i64)mm_decls$lx.symbol) {
    case 52:;
    case 53:;
        {
            opc = (i64)mm_decls$lx.subcode;
            pos = (i64)mm_decls$lx.pos;
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)34,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readrangeterm(0));
            (*p).pclop = opc;
            (*p).pos = pos;
        }
        break;
    default: {
        goto L649 ;
    }
    } //SW
goto L648 ;
L649 :;
    ;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readrangeterm(struct mm_decls$unitrec *pt) {
        struct mm_decls$unitrec *  p;
        i64 pos;
    p = mm_parse$readaddterms(pt);
    if (((i64)mm_decls$lx.symbol == (i64)28)) {
        pos = (i64)mm_decls$lx.pos;
        mm_lex$lex();
        p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)19,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readaddterms(0));
        (*p).pos = pos;
    }
;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readaddterms(struct mm_decls$unitrec *pt) {
        struct mm_decls$unitrec *  p;
        i64 pos;
        i64 sym;
        i64 genop;
    p = mm_parse$readmulterms(pt);
    L650 :;
    switch ((sym = (i64)mm_decls$lx.symbol)) {
    case 31:;
    case 32:;
    case 38:;
    case 39:;
    case 40:;
    case 43:;
    case 44:;
        {
            pos = (i64)mm_decls$lx.pos;
            genop = (i64)mm_decls$lx.subcode;
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol == (i64)9)) {
                mm_lex$lex();
                p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)36,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readassignment(0));
                (*p).pclop = (i64)mm_tables$symbolgentoops[(sym)-1];
                (*p).pos = pos;
                goto L651 ;
            }
;
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)34,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readmulterms(0));
            (*p).pclop = (i64)mm_tables$symbolgenops[(sym)-1];
            (*p).pos = pos;
        }
        break;
    default: {
        goto L651 ;
    }
    } //SW
goto L650 ;
L651 :;
    ;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readmulterms(struct mm_decls$unitrec *pt) {
        struct mm_decls$unitrec *  p;
        i64 pos;
        i64 sym;
    p = mm_parse$readpowerterms(pt);
    L652 :;
    switch ((sym = (i64)mm_decls$lx.symbol)) {
    case 33:;
    case 34:;
    case 35:;
    case 36:;
    case 41:;
    case 42:;
    case 37:;
        {
            pos = (i64)mm_decls$lx.pos;
            mm_lex$lex();
            if (((i64)mm_decls$lx.symbol == (i64)9)) {
                mm_lex$lex();
                p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)36,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readassignment(0));
                (*p).pclop = (i64)mm_tables$symbolgentoops[(sym)-1];
                (*p).pos = pos;
                goto L653 ;
            }
;
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)34,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readpowerterms(0));
            (*p).pclop = (i64)mm_tables$symbolgenops[(sym)-1];
            (*p).pos = pos;
        }
        break;
    default: {
        goto L653 ;
    }
    } //SW
goto L652 ;
L653 :;
    ;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readpowerterms(struct mm_decls$unitrec *p) {
        i64 pos;
    if ((p == 0)) {
        p = mm_parse$readterm2();
    }
;
    L654 :;
    while (((i64)mm_decls$lx.symbol == (i64)50)) {
        pos = (i64)mm_decls$lx.pos;
        mm_lex$lex();
        p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)34,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)mm_parse$readpowerterms(0));
        (*p).pclop = (i64)51;
        (*p).pos = pos;
L655 :;
    }
L656 :;
    ;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readterm2(void) {
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
        i64 opc;
        i64 oldinrp;
        i64 pos;
    pos = (i64)mm_decls$lx.pos;
    p = mm_parse$readterm();
    L657 :;
    switch ((i64)mm_decls$lx.symbol) {
    case 13:;
        {
            mm_lex$lex();
            oldinrp = mm_parse$inreadprint;
            mm_parse$inreadprint = (i64)0;
            q = mm_parse$readslist((i64)1,(i64)1);
            mm_parse$checksymbol((i64)14);
            mm_lex$lex();
            if (((i64)(*p).tag == (i64)92)) {
                (*p).a = q;
            }
            else {
                p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)31,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)q);
            }
;
            mm_parse$inreadprint = oldinrp;
            p = mm_parse$readcondsuffix(p);
        }
        break;
    case 19:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)49,(struct mm_decls$unitrec *)p);
            mm_lex$lex();
        }
        break;
    case 15:;
        {
            p = mm_parse$readindex(p,(i64)0);
        }
        break;
    case 2:;
        {
            p = mm_parse$readdotsuffix(p);
        }
        break;
    case 7:;
        {
            if (!!(mm_parse$inreadprint)) {
                goto L658 ;
            }
;
            mm_lex$lex();
            q = mm_parse$readunit();
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((!!(mm_parse$inparamlist) ? (i64)24 : (i64)25),(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)q);
        }
        break;
    case 71:;
        {
                        {i64 $temp = (i64)mm_decls$lx.subcode;
if (($temp==(i64)53)) {
                opc = (i64)57;
            }
            else if (($temp==(i64)54)) {
                opc = (i64)58;
            }
            };
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)38,(struct mm_decls$unitrec *)p);
            (*p).pclop = opc;
        }
        break;
    case 17:;
        {
            mm_support$serror((byte*)"X{...} not ready");
        }
        break;
    default: {
        goto L658 ;
    }
    } //SW
goto L657 ;
L658 :;
    ;
    (*p).pos = pos;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readterm(void) {
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  r;
        u64 a;
        i64 opc;
        i64 pos;
        i64 length;
    pos = (i64)mm_decls$lx.pos;
    switch ((i64)mm_decls$lx.symbol) {
    case 81:;
        {
            if (((i64)mm_decls$nextlx.symbol == (i64)22)) {
                p = mm_parse$readcast();
            }
            else {
                p = (struct mm_decls$unitrec *)mm_lib$createname((struct mm_decls$strec *)mm_decls$lx.symptr);
                (*p).pos = (i64)mm_decls$lx.pos;
                mm_lex$lex();
            }
;
        }
        break;
    case 72:;
    case 74:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)mm_decls$lx.value,(i64)mm_decls$lx.subcode);
            (*p).istrueconst = (i64)1;
            mm_lex$lex();
        }
        break;
    case 77:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createstringconstunit(mm_decls$lx.svalue,(i64)-1);
            mm_lex$lex();
        }
        break;
    case 78:;
        {
            p = mm_parse$makeastring();
            mm_lex$lex();
        }
        break;
    case 73:;
        {
            mm_support$serror((byte*)"DEC CONST");
        }
        break;
    case 75:;
        {
            length = strlen(mm_decls$lx.svalue);
            if ((length > (i64)8)) {
                mm_support$serror((byte*)"Char const too long");
            }
;
            a = (u64)0u;
            if (!!(length)) {
                memcpy(&a,(void *)mm_decls$lx.svalue,(u64)length);
            }
;
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit(a,(i64)1);
            (*p).istrueconst = (i64)1;
            mm_lex$lex();
        }
        break;
    case 13:;
        {
            p = mm_parse$readlbrack();
        }
        break;
    case 93:;
    case 140:;
    case 97:;
    case 94:;
        {
            p = mm_parse$readcast();
        }
        break;
    case 31:;
    case 32:;
    case 43:;
    case 44:;
    case 59:;
    case 58:;
    case 64:;
    case 61:;
    case 62:;
    case 65:;
    case 60:;
        {
            p = mm_parse$readopc();
        }
        break;
    case 56:;
        {
            if (((i64)mm_decls$nextlx.symbol == (i64)9)) {
                p = mm_parse$readopc();
            }
            else {
                mm_lex$lex();
                p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)16,(struct mm_decls$unitrec *)mm_parse$readterm2());
                (*p).pclop = (i64)32;
            }
;
        }
        break;
    case 57:;
        {
            if (((i64)mm_decls$nextlx.symbol == (i64)9)) {
                p = mm_parse$readopc();
            }
            else {
                mm_lex$lex();
                p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)17,(struct mm_decls$unitrec *)mm_parse$readterm2());
                (*p).pclop = (i64)33;
            }
;
        }
        break;
    case 15:;
        {
            p = mm_parse$readset();
        }
        break;
    case 71:;
        {
            opc = (i64)mm_decls$lx.subcode;
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)38,(struct mm_decls$unitrec *)mm_parse$readterm2());
            (*p).pclop = opc;
        }
        break;
    case 126:;
        {
            p = mm_parse$readsprint();
        }
        break;
    case 128:;
    case 129:;
        {
            p = mm_parse$readsread();
        }
        break;
    case 25:;
    case 26:;
        {
            opc = (i64)mm_decls$lx.subcode;
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1(opc,(struct mm_decls$unitrec *)mm_parse$readterm2());
            if (((i64)(*(*p).a).tag == (i64)31)) {
                if (!!((*(*p).a).b)) {
                    mm_support$serror((byte*)"Params not allowed");
                }
;
                (*p).a = (*(*p).a).a;
            }
;
        }
        break;
    case 4:;
        {
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)51,(struct mm_decls$unitrec *)mm_parse$readterm2());
        }
        break;
    case 159:;
        {
            p = mm_parse$readcompilervar();
        }
        break;
    case 166:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)(i64)mm_decls$lx.subcode,(i64)3);
            mm_lex$lex();
        }
        break;
    case 160:;
        {
            if (!!(mm_parse$intabledata)) {
                if (!(!!(mm_parse$tabledataname))) {
                    mm_support$serror((byte*)"$: no enum");
                }
;
                p = (struct mm_decls$unitrec *)mm_lib$createstringconstunit(mm_parse$tabledataname,(i64)-1);
            }
            else {
                if ((mm_parse$ndollar <= (i64)0)) {
                    mm_support$serror((byte*)"[$] No array");
                }
;
                p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)35,(struct mm_decls$unitrec *)mm_parse$dollarstack[(mm_parse$ndollar)-1]);
                (*p).pclop = (i64)90;
            }
;
            mm_lex$lex();
        }
        break;
    case 158:;
        {
            p = mm_parse$readcastx();
        }
        break;
    case 164:;
        {
            mm_parse$lexchecksymbol((i64)13);
            mm_lex$lex();
            p = mm_parse$readunit();
            mm_parse$checksymbol((i64)5);
            mm_lex$lex();
            q = mm_parse$readunit();
            if ((((i64)mm_decls$lx.symbol == (i64)14) && ((i64)(*q).tag == (i64)19))) {
                r = (*q).b;
                q = (*q).a;
            }
            else {
                mm_parse$checksymbol((i64)5);
                mm_lex$lex();
                r = mm_parse$readunit();
                mm_parse$checksymbol((i64)14);
            }
;
            mm_lex$lex();
            q = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)34,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)q);
            (*q).pclop = (i64)16;
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)34,(struct mm_decls$unitrec *)q,(struct mm_decls$unitrec *)r);
            (*p).pclop = (i64)15;
        }
        break;
    case 122:;
        {
            p = mm_parse$readgoto((i64)101);
        }
        break;
    case 98:;
        {
            p = mm_parse$readif();
        }
        break;
    case 106:;
        {
            p = mm_parse$readunless();
        }
        break;
    case 107:;
    case 108:;
    case 123:;
    case 124:;
        {
            p = mm_parse$readswitchcase();
        }
        break;
    case 109:;
        {
            p = mm_parse$readrecase();
        }
        break;
    case 111:;
        {
            p = mm_parse$readfor();
        }
        break;
    case 112:;
        {
            p = mm_parse$readto();
        }
        break;
    case 114:;
        {
            p = mm_parse$readdo();
        }
        break;
    case 115:;
        {
            p = mm_parse$readwhile();
        }
        break;
    case 116:;
        {
            p = mm_parse$readrepeat();
        }
        break;
    case 120:;
        {
            p = mm_parse$readloopcontrol();
        }
        break;
    case 118:;
        {
            p = mm_parse$readreturn();
        }
        break;
    case 119:;
        {
            p = mm_parse$readstop();
        }
        break;
    case 125:;
        {
            p = mm_parse$readprint();
        }
        break;
    case 127:;
        {
            p = mm_parse$readread();
        }
        break;
    case 165:;
        {
            mm_parse$lexchecksymbol((i64)13);
            mm_lex$lex();
            p = mm_parse$readunit();
            mm_parse$checksymbol((i64)5);
            mm_lex$lex();
            q = mm_parse$readunit();
            mm_parse$checksymbol((i64)14);
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)111,(struct mm_decls$unitrec *)p,(struct mm_decls$unitrec *)q);
        }
        break;
    case 161:;
        {
            opc = (i64)mm_decls$lx.subcode;
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)125,(struct mm_decls$unitrec *)mm_parse$readunit());
            (*p).index = opc;
        }
        break;
    case 167:;
        {
            (*mm_decls$currproc).asmused = (i64)1;
            mm_decls$assemmode = (i64)1;
            if (((i64)mm_decls$lx.subcode == (i64)0)) {
                p = mm_assem$readassemline();
            }
            else {
                p = mm_assem$readassemblock();
            }
;
            mm_decls$assemmode = (i64)0;
        }
        break;
    case 168:;
        {
            p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)92);
            (*p).fnindex = (i64)mm_decls$lx.subcode;
            mm_lex$lex();
        }
        break;
    case 83:;
        {
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)13,(struct mm_decls$unitrec *)mm_parse$readterm2());
        }
        break;
    case 169:;
        {
            if ((u64)1u) {
                mm_support$serror((byte*)"emitc?");
            }
;
            mm_lex$lex();
            mm_parse$checksymbol((i64)77);
            p = (struct mm_decls$unitrec *)mm_lib$createstringconstunit(mm_decls$lx.svalue,(i64)-1);
            (*p).tag = (i64)129;
            mm_lex$lex();
        }
        break;
    case 170:;
        {
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)128,(struct mm_decls$unitrec *)mm_parse$readterm2());
        }
        break;
    case 171:;
        {
            mm_lex$lex();
            p = (struct mm_decls$unitrec *)mm_lib$createunit1((i64)30,(struct mm_decls$unitrec *)mm_parse$readterm2());
        }
        break;
    case 17:;
        {
            mm_support$serror((byte*)"{...} not ready");
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str(mm_tables$symbolnames[((i64)mm_decls$lx.symbol)-1],NULL);
        msysc$m_print_str((byte*)"LX.SYMBOL=",NULL);
        msysc$m_print_i64((i64)mm_decls$lx.symbol,NULL);
        msysc$m_print_i64(mm_parse$istypestarter(),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$serror((byte*)"readterm?");
    }
    } //SW
;
    (*p).pos = pos;
    return p;
}

static void mm_parse$readmacrodef(struct mm_decls$strec *owner,i64 scope) {
        struct mm_decls$strec *  nameptr;
        struct mm_decls$strec *  stmacro;
        struct mm_decls$strec *  paramlist;
        struct mm_decls$strec *  paramlistx;
        struct mm_decls$strec *  stname;
    mm_parse$lexchecksymbol((i64)81);
    nameptr = (struct mm_decls$strec *)mm_decls$lx.symptr;
    stmacro = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)nameptr,(i64)18);
    mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stmacro);
    owner = (struct mm_decls$strec *)stmacro;
    mm_lex$lex();
    paramlist = (paramlistx = 0);
    if (((i64)mm_decls$lx.symbol == (i64)13)) {
        mm_lex$lex();
        if (((i64)mm_decls$lx.symbol != (i64)14)) {
            L659 :;
            while (1) {
                                {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)81)) {
                    stname = (struct mm_decls$strec *)mm_lib$getduplnameptr((struct mm_decls$strec *)owner,(struct mm_decls$strec *)mm_decls$lx.symptr,(i64)19);
                    mm_lib$adddef((struct mm_decls$strec *)owner,(struct mm_decls$strec *)stname);
                    mm_parse$addlistparam((struct mm_decls$strec **)&paramlist,(struct mm_decls$strec **)&paramlistx,(struct mm_decls$strec *)stname);
                    mm_lex$lex();
                    if (((i64)mm_decls$lx.symbol == (i64)14)) {
                        goto L660 ;
                    }
;
                    mm_parse$checksymbol((i64)5);
                    mm_lex$lex();
                }
                else {
                    mm_support$serror((byte*)"macro def params");
                }
                };
            }
L660 :;
            ;
        }
;
        mm_lex$lex();
    }
;
    (*stmacro).paramlist = (struct mm_decls$strec *)paramlist;
    (*stmacro).scope = scope;
    mm_parse$checkequals();
    mm_lex$lex();
    (*stmacro).code = mm_parse$readunit();
}

static struct mm_decls$unitrec *mm_parse$readrecase(void) {
    mm_lex$lex();
    if (((i64)mm_decls$lx.symbol == (i64)101)) {
        mm_lex$lex();
        return (struct mm_decls$unitrec *)mm_lib$createunit0((i64)113);
    }
    else {
        return (struct mm_decls$unitrec *)mm_lib$createunit1((i64)113,(struct mm_decls$unitrec *)mm_parse$readunit());
    }
;
}

static void mm_parse$adddocstring(u8 *s) {
    if ((mm_decls$ndocstrings > (i64)20)) {
        mm_support$serror((byte*)"Too many docstrings");
    }
;
    mm_decls$docstrings[(++(mm_decls$ndocstrings))-1] = mlib$pcm_copyheapstringn(s,strlen(s));
}

static struct mm_decls$unitrec *mm_parse$fixcond(struct mm_decls$unitrec *p) {
    if ((((i64)(*p).tag == (i64)6) && ((*p).a == 0))) {
        mm_support$serror((byte*)"Empty cond");
    }
;
    if (!(!!((i64)mm_tables$isbooltag[((i64)(*p).tag)]))) {
        mm_lib$insertunit(p,(i64)17);
        (*p).pclop = (i64)33;
    }
;
    return p;
}

static struct mm_decls$unitrec *mm_parse$readsunit(i64 inwhile) {
        i64 pos;
        i64 sym;
        i64 opc;
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  r;
        struct mm_decls$strec *  stname;
    pos = (i64)mm_decls$lx.pos;
    ulist = (ulistx = 0);
    L661 :;
    do {
        L664 :;
        while (((i64)mm_decls$lx.symbol == (i64)6)) {
            mm_lex$lex();
L665 :;
        }
L666 :;
        ;
        switch ((i64)mm_decls$lx.symbol) {
        case 157:;
            {
                mm_lex$lex();
                if (((i64)mm_decls$lx.symbol == (i64)142 || (i64)mm_decls$lx.symbol == (i64)141)) {
                    opc = (i64)mm_decls$lx.symbol;
                    mm_lex$lex();
                }
                else {
                    opc = (i64)0;
                }
;
                mm_parse$readvardef((struct mm_decls$strec *)mm_decls$currproc,(i64)0,(i64)1,(i64)11,opc);
            }
            break;
        case 130:;
        case 131:;
            {
                mm_parse$readprocdef((struct mm_decls$strec *)mm_decls$currproc,(i64)0,(i64)0);
            }
            break;
        case 93:;
        case 140:;
        case 97:;
        case 94:;
        case 145:;
        case 143:;
        case 15:;
            {
                if (((i64)mm_decls$nextlx.symbol == (i64)13 || (i64)mm_decls$nextlx.symbol == (i64)22 || (i64)mm_decls$nextlx.symbol == (i64)2)) {
                    goto L667 ;
;
                }
                else {
                    sym = (i64)0;
                    goto L668 ;
;
                }
;
            }
            break;
        case 144:;
            {
                mm_parse$lexchecksymbol((i64)15);
                sym = (i64)0;
                goto L668 ;
;
            }
            break;
        case 141:;
        case 142:;
            {
                sym = (i64)mm_decls$lx.symbol;
                mm_lex$lex();
                //dovar:
L668 :;
;
                q = mm_parse$readvardef((struct mm_decls$strec *)mm_decls$currproc,(i64)0,(i64)0,(i64)12,sym);
                L669 :;
                while (!!(q)) {
                    r = (*q).nextunit;
                    (*q).nextunit = 0;
                    mm_lib$addlistunit(&ulist,&ulistx,q);
                    q = r;
L670 :;
                }
L671 :;
                ;
            }
            break;
        case 137:;
            {
                mm_parse$readtypedef((struct mm_decls$strec *)mm_decls$currproc,(i64)0);
            }
            break;
        case 149:;
            {
                mm_parse$readconstdef((struct mm_decls$strec *)mm_decls$currproc,(i64)0);
            }
            break;
        case 152:;
        case 133:;
            {
                mm_parse$readclassdef((struct mm_decls$strec *)mm_decls$currproc,(i64)0);
            }
            break;
        case 70:;
            {
                mm_parse$adddocstring(mm_decls$lx.svalue);
                mm_lex$lex();
            }
            break;
        case 146:;
            {
                mm_parse$readmacrodef((struct mm_decls$strec *)mm_decls$currproc,(i64)0);
            }
            break;
        case 162:;
            {
                mm_parse$readtabledef((struct mm_decls$strec *)mm_decls$currproc,(i64)0);
            }
            break;
        case 68:;
            {
                msysc$m_print_startcon();
                msysc$m_print_str((*mm_decls$currproc).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                mm_support$serror((byte*)"Unexpected EOF in proc");
            }
            break;
        case 14:;
        case 99:;
        case 100:;
        case 101:;
        case 117:;
        case 110:;
        case 102:;
        case 103:;
        case 105:;
            {
                goto L663 ;
            }
            break;
        case 81:;
            {
                                {i64 $temp = (i64)mm_decls$nextlx.symbol;
if (($temp==(i64)8)) {
                    p = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)102);
                    stname = (struct mm_decls$strec *)mm_lib$getduplnameptr(mm_decls$currproc,(struct mm_decls$strec *)mm_decls$lx.symptr,(i64)17);
                    mm_lib$adddef(mm_decls$currproc,(struct mm_decls$strec *)stname);
                    (*p).def = (struct mm_decls$strec *)stname;
                    mm_lex$lex();
                    mm_decls$lx.symbol = (i64)6;
                    mm_lib$addlistunit(&ulist,&ulistx,p);
                }
                else if (($temp==(i64)81)) {
                    sym = (i64)141;
                    goto L668 ;
;
                    goto L667 ;
;
                }
                else {
                    goto L667 ;
;
                }
                };
            }
            break;
        case 114:;
            {
                if (!!(inwhile)) {
                    goto L663 ;
                }
;
                goto L667 ;
;
            }
            break;
        case 6:;
            {
            }
            break;
        case 121:;
            {
                goto L663 ;
            }
            break;
        default: {
            //doexec:
L667 :;
;
            p = mm_parse$readunit();
            //doexec2:
L672 :;
;
            if ((((i64)(*p).tag == (i64)4) && ((i64)mm_decls$lx.symbol == (i64)81))) {
                mm_support$serror((byte*)"Possibly var/let needed");
            }
;
            mm_lib$addlistunit(&ulist,&ulistx,p);
            if (((i64)mm_decls$lx.symbol == (i64)114)) {
                goto L663 ;
            }
;
        }
        } //SW
;
L662 :;
    }
    while (!((i64)mm_decls$lx.symbol != (i64)6));
L663 :;
    ;
        {i64 $temp = (i64)mm_decls$lx.symbol;
if (($temp==(i64)14) || ($temp==(i64)99) || ($temp==(i64)100) || ($temp==(i64)101) || ($temp==(i64)117) || ($temp==(i64)110) || ($temp==(i64)114) || ($temp==(i64)102) || ($temp==(i64)103) || ($temp==(i64)105) || ($temp==(i64)5) || ($temp==(i64)20) || ($temp==(i64)121)) {
    }
    else {
        mm_support$serror((byte*)"Readsunit: \";\" expected, or bad unit starter");
    }
    };
    if (((ulist == 0) || !!((*ulist).nextunit))) {
        return (struct mm_decls$unitrec *)mm_lib$createunit1((i64)6,(struct mm_decls$unitrec *)ulist);
    }
    else {
        return ulist;
    }
;
}

// START
void mm_parse$start(void) {

}

i64 mm_support$loadsourcefile(u8 *filespec) {
        u8 *  s;
        u8 *  basefilename;
    if ((mm_decls$nsourcefiles > (i64)1000)) {
        mm_support$loaderror((byte*)"Too many source files",(byte*)"",(byte*)"");
    }
;
    basefilename = mlib$extractfile(filespec);
    ++(mm_decls$nsourcefiles);
    mm_decls$sourcefilespecs[(mm_decls$nsourcefiles)] = mlib$pcm_copyheapstring(filespec);
    mm_decls$sourcefilepaths[(mm_decls$nsourcefiles)] = mlib$pcm_copyheapstring(mlib$extractpath(filespec));
    mm_decls$sourcefilenames[(mm_decls$nsourcefiles)] = mlib$pcm_copyheapstring(basefilename);
    s = (u8 *)mlib$readfile(filespec);
    if (!(!!(s))) {
        mm_support$loaderror((byte*)"LSF can't load ",filespec,(byte*)"");
    }
;
    mm_decls$sourcefiletext[(mm_decls$nsourcefiles)] = s;
    if (!!((i64)mm_decls$fwritema)) {
        mm_decls$sourcefiledupl[(mm_decls$nsourcefiles)] = mlib$pcm_copyheapstring(s);
    }
;
    mm_decls$sourcefilesizes[(mm_decls$nsourcefiles)] = mlib$rfsize;
    (*(s + mlib$rfsize)) = (u64)0u;
    return mm_decls$nsourcefiles;
}

static i64 mm_support$loadbundledfile(u8 *filespec,i64 issyslib,i64 support) {
        i64 fileno;
        u8 *  file;
        i64 i;
    file = mlib$extractfile(filespec);
    for (i=(i64)1;i<=mm_decls$nsourcefiles;++i) {
L673 :;
        if ((!!(mlib$eqstring(file,mm_decls$sourcefilenames[(i)])) && (support == (i64)mm_decls$sourcefilesupport[(i)]))) {
            return i;
        }
;
L674 :;
    }
L675 :;
    ;
    fileno = mm_libsources$findsyslib(file);
    if (!!(fileno)) {
        return fileno;
    }
;
    if (!(!!(issyslib))) {
        mm_support$loaderror((byte*)"Can't find bundled file: ##",filespec,(byte*)"");
    }
;
    return (i64)0;
}

void mm_support$mcerror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"MC Error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

void mm_support$serror_gen(u8 *mess) {
    mm_support$showdivider('*');
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Syntax Error:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$showerrorsource((i64)mm_decls$lx.pos,mm_decls$currproc);
    msysc$m_print_startcon();
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$stopcompiler(mm_decls$sourcefilespecs[((i64)msysc$m_getdotslice((i64)mm_decls$lx.pos,(i64)24,(i64)31))],mm_support$getlineno((u64)(i64)mm_decls$lx.pos));
}

static void mm_support$showdivider(u64 ch) {
        i64 $av_1;
    $av_1 = (i64)87;
    while ($av_1-- > 0) {
L676 :;
        msysc$m_print_startcon();
        msysc$m_print_c8(ch,NULL);
        msysc$m_print_end();
        ;
L677 :;
    }
L678 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void mm_support$showerrorsource(i64 pos,struct mm_decls$strec *stproc) {
        i64 fileno;
        i64 lineoffset;
        u8 *  errorline;
        u8 *  s;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
    fileno = mm_support$getfileno((u64)pos);
    msysc$m_print_startcon();
    msysc$m_print_setfmt((byte*)"    Line:     #");
    msysc$m_print_i64(mm_support$getlineno((u64)pos),NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if ((!!(stproc) && ((i64)(*stproc).nameid == (i64)6))) {
        msysc$m_print_startcon();
        msysc$m_print_setfmt((byte*)"    Function: #()");
        msysc$m_print_str((*stproc).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_setfmt((byte*)"    Module:   # (#)");
    msysc$m_print_str(mm_decls$sourcefilenames[(fileno)],NULL);
    msysc$m_print_str(mm_decls$sourcefilespecs[(fileno)],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$showdivider('-');
    s = (errorline = mm_support$getsourceline((u64)pos));
    lineoffset = (mm_support$getsourcepos((u64)pos) - errorline);
    $av_1 = (i64)6;
    while ($av_1-- > 0) {
L679 :;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
L680 :;
    }
L681 :;
    ;
    L682 :;
    while (!(((u64)(*s) == (i64)10 || (u64)(*s) == (i64)0))) {
        msysc$m_print_startcon();
        msysc$m_print_c8((u64)(*(s)++),NULL);
        msysc$m_print_end();
        ;
L683 :;
    }
L684 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    s = errorline;
    $av_2 = (i64)6;
    while ($av_2-- > 0) {
L685 :;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
L686 :;
    }
L687 :;
    ;
    $av_3 = lineoffset;
    while ($av_3-- > 0) {
L688 :;
        if (((i64)(u64)(*s) == (i64)9)) {
            msysc$m_print_startcon();
            msysc$m_print_c8((u64)9u,NULL);
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_c8(' ',NULL);
            msysc$m_print_end();
            ;
        }
;
        ++(s);
L689 :;
    }
L690 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"^",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$showdivider('-');
}

void mm_support$stopcompiler(u8 *filename,i64 lineno) {
        void *  f;
    f = fopen((byte*)"$error.tmp",(byte*)"w");
    msysc$m_print_startfile(f);
    msysc$m_print_str(filename,NULL);
    msysc$m_print_i64(lineno,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    fclose(f);
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

void mm_support$serror(u8 *mess) {
    mm_support$serror_gen(mess);
}

void mm_support$serror_s(u8 *mess,u8 *a) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt(mess);
    msysc$m_print_str(a,NULL);
    msysc$m_print_end();
    ;
    mm_support$serror_gen((u8 *)str);
}

void mm_support$error_gen(i64 pass,u8 *mess,struct mm_decls$unitrec *p) {
        i64 pos;
    if (!!(p)) {
        pos = (i64)(*p).pos;
    }
    else {
        pos = mm_tables$mlineno;
    }
;
    mm_support$showdivider('*');
    if ((pass==(i64)78)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"RX Name Error: ",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else if ((pass==(i64)84)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"TX Type Error: ",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else if ((pass==(i64)71)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"GX Code Gen Error: ",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else if ((pass==(i64)65)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"AX Code Gen Error: ",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    mm_support$showerrorsource(pos,mm_decls$currproc);
    msysc$m_print_startcon();
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$stopcompiler(mm_decls$sourcefilespecs[(mm_support$getfileno((u64)pos))],mm_support$getlineno((u64)pos));
}

void mm_support$rxerror(u8 *mess,struct mm_decls$unitrec *p) {
    mm_support$error_gen((i64)78,mess,p);
}

i64 mm_support$gerror(u8 *mess,struct mm_decls$unitrec *p) {
    mm_support$error_gen((i64)71,mess,p);
    return (i64)0;
}

void mm_support$axerror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"ALINENO=",NULL);
    msysc$m_print_i64(mc_decls$alineno,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$error_gen((i64)65,mess,0);
}

void mm_support$txerror(u8 *mess,struct mm_decls$unitrec *p) {
    mm_support$error_gen((i64)84,mess,p);
}

void mm_support$txerror_s(u8 *mess,u8 *a,struct mm_decls$unitrec *p) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt(mess);
    msysc$m_print_str(a,NULL);
    msysc$m_print_end();
    ;
    mm_support$error_gen((i64)84,(u8 *)str,p);
}

void mm_support$txerror_ss(u8 *mess,u8 *a,u8 *b) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt(mess);
    msysc$m_print_str(a,NULL);
    msysc$m_print_str(b,NULL);
    msysc$m_print_end();
    ;
    mm_support$error_gen((i64)84,(u8 *)str,0);
}

void mm_support$rxerror_s(u8 *mess,u8 *a,struct mm_decls$unitrec *p) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt(mess);
    msysc$m_print_str(a,NULL);
    msysc$m_print_end();
    ;
    mm_support$error_gen((i64)78,(u8 *)str,p);
}

void mm_support$gerror_s(u8 *mess,u8 *s,struct mm_decls$unitrec *p) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt(mess);
    msysc$m_print_str(s,NULL);
    msysc$m_print_end();
    ;
    mm_support$error_gen((i64)71,(u8 *)str,p);
}

void mm_support$gerror_t(u8 *mess,struct mm_decls$unitrec *p) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt(mess);
    msysc$m_print_str(mm_lib$strmode((i64)(*p).mode,(i64)1),NULL);
    msysc$m_print_end();
    ;
    mm_support$error_gen((i64)71,(u8 *)str,p);
}

void mm_support$lxerror_gen(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"On line",NULL);
    msysc$m_print_i64(mm_support$getlineno((u64)(i64)mm_decls$lx.pos),NULL);
    msysc$m_print_str((byte*)"in file",NULL);
    msysc$m_print_str(mm_decls$sourcefilespecs[((i64)msysc$m_getdotslice((i64)mm_decls$lx.pos,(i64)24,(i64)31))],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"**** Lex Error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str((byte*)"****",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$stopcompiler(mm_decls$sourcefilespecs[((i64)msysc$m_getdotslice((i64)mm_decls$lx.pos,(i64)24,(i64)31))],mm_support$getlineno((u64)(i64)mm_decls$lx.pos));
}

void mm_support$lxerror(u8 *mess) {
    mm_support$lxerror_gen(mess);
}

void mm_support$loaderror(u8 *mess,u8 *mess2,u8 *mess3) {
        u8 str[512];
    if (!!(strchr(mess,(i32)'#'))) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt(mess);
        msysc$m_print_str(mess2,NULL);
        msysc$m_print_str(mess3,NULL);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_str(mess,NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Load Error:",NULL);
    msysc$m_print_str(str,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Stopping",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

void mm_support$gs_additem(struct mlib$strbuffer *dest,u8 *s) {
        u8 *  d;
        i64 lastchar;
        i64 nextchar;
    d = (*dest).strptr;
    if (!!((i64)(*dest).length)) {
        lastchar = (i64)(u64)(*((d + (i64)(*dest).length) - (i64)1));
        nextchar = (i64)(u64)(*s);
        if ((!!(mm_support$isalphanum(lastchar)) && !!(mm_support$isalphanum(nextchar)))) {
            mlib$strbuffer_add((struct mlib$strbuffer *)dest,(byte*)" ",(i64)-1);
        }
;
    }
;
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,(i64)-1);
}

void mm_support$gs_copytostr(struct mlib$strbuffer *source,u8 *s) {
    if (!!((i64)(*source).length)) {
        memcpy((void *)s,(void *)(*source).strptr,(u64)(i64)(*source).length);
        (*(s + (i64)(*source).length)) = (u64)0u;
    }
    else {
        (*s) = (u64)0u;
    }
;
}

i64 mm_support$isalphanum(i64 c) {
    if (((((c >= (i64)65) && (c <= (i64)90)) || ((c >= (i64)97) && (c <= (i64)122))) || ((c >= (i64)48) && (c <= (i64)57)))) {
        return (i64)1;
    }
;
    return (i64)0;
}

void mm_support$init_tt_tables(void) {
        i64 i;
        i64 size;
        i64 bitsize;
    for (i=(i64)0;i<=(i64)28;++i) {
L691 :;
        mm_decls$ttname[(i)] = mm_tables$stdnames[(i)];
        mm_decls$ttbasetype[(i)] = i;
        bitsize = (i64)mm_tables$stdbits[(i)];
        switch (bitsize) {
        case 0:;
            {
                size = (i64)0;
            }
            break;
        case 1:;
        case 2:;
        case 4:;
            {
                size = (i64)1;
            }
            break;
        default: {
            size = (bitsize / (i64)8);
        }
        } //SW
;
        mm_decls$ttsize[(i)] = size;
        if ((i==(i64)14) || (i==(i64)15) || (i==(i64)16) || (i==(i64)3)) {
            mm_decls$ttsigned[(i)] = (i64)1;
            mm_decls$ttisinteger[(i)] = (i64)1;
        }
        else if ((i==(i64)17) || (i==(i64)18) || (i==(i64)19) || (i==(i64)2) || (i==(i64)12) || (i==(i64)1)) {
            mm_decls$ttisinteger[(i)] = (i64)1;
        }
        else if ((i==(i64)4) || (i==(i64)5)) {
            mm_decls$ttisreal[(i)] = (i64)1;
        }
        else if ((i==(i64)7) || (i==(i64)20)) {
            mm_decls$ttisref[(i)] = (i64)1;
        }
;
        mm_decls$ttisshort[(i)] = (i64)((i64)mm_tables$stdcat[(i)] == (i64)4);
        mm_decls$ttlower[(i)] = (i64)1;
        mm_decls$ttcat[(i)] = (i64)mm_tables$stdcat[(i)];
        mm_decls$ttisblock[(i)] = (i64)((i64)mm_tables$stdcat[(i)] == (i64)5);
L692 :;
    }
L693 :;
    ;
    mm_decls$ttbasetype[((i64)20)] = (i64)7;
    mm_decls$tttarget[((i64)20)] = (i64)12;
    mm_decls$ntypes = (i64)28;
}

void mm_support$addspecialtypes(void) {
    mm_tables$trefproc = mm_lib$createrefmode(0,(i64)23,(i64)0);
    mm_tables$treflabel = mm_lib$createrefmode(0,(i64)24,(i64)0);
}

i64 mm_support$getsupportfile(u8 *filename,u8 *ext,u8 *path,i64 issyslib,i64 issupport) {
        u8 filespec[300];
        u8 filespec2[300];
        u8 *  file;
        i64 fileno;
    file = filename;
    if ((mm_decls$fverbose == (i64)3)) {
        msysc$m_print_startcon();
        msysc$m_print_setfmt((byte*)"Get file:# (ext:#) (path:#)");
        msysc$m_print_str(filename,NULL);
        msysc$m_print_str(ext,NULL);
        msysc$m_print_str(path,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if (!!((u64)(*ext))) {
        strcpy(filespec,mlib$addext(filename,ext));
        file = (u8 *)filespec;
    }
;
    if (!!((i64)mm_decls$freadma)) {
        fileno = mm_support$loadbundledfile(file,issyslib,issupport);
        if (!!(fileno)) {
            return fileno;
        }
;
    }
;
    if ((!!(issyslib) && !!((i64)mm_decls$dointlibs))) {
        fileno = mm_libsources$findsyslib(file);
        if (((mm_decls$fverbose == (i64)3) && !!(fileno))) {
            msysc$m_print_startcon();
            msysc$m_print_setfmt((byte*)"Found in syslib: #");
            msysc$m_print_str(mm_decls$sourcefilenames[(fileno)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        if (!!(fileno)) {
            return fileno;
        }
;
    }
;
    if (!(!!(mm_support$isabspath(file)))) {
        strcpy(filespec2,path);
        strcat(filespec2,file);
        file = (u8 *)filespec2;
    }
;
    if (((mm_decls$fverbose == (i64)3) && !!(fileno))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Checkfile:",NULL);
        msysc$m_print_str(file,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if (((file == 0) || !(!!(mlib$checkfile(file))))) {
        mm_support$loaderror((byte*)"Can't find file: # #",filename,(byte*)"");
    }
;
    fileno = mm_support$loadsourcefile(file);
    if (((mm_decls$fverbose == (i64)3) && !!(fileno))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Found:",NULL);
        msysc$m_print_str(file,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    mm_decls$sourcefilesupport[(fileno)] = issupport;
    mm_decls$sourcefilesys[(fileno)] = issyslib;
    return fileno;
}

static i64 mm_support$isabspath(u8 *filespec) {
        u8 *  path;
    path = mlib$extractpath(filespec);
    if ((((u64)(*path) == (u64)92u || (u64)(*path) == '/') || (((i64)(u64)(*path) != (i64)0) && ((u64)(*(path + (i64)1)) == ':')))) {
        return (i64)1;
    }
;
    return (i64)0;
}

void mm_support$initbblib(void) {
        i64 i;
    for (i=(i64)1;i<=(i64)9;++i) {
L694 :;
        mm_decls$typestarterset[(mm_tables$d_typestarterset[(i)-1])] = (i64)1;
L695 :;
    }
L696 :;
    ;
}

i64 mm_support$getfileno(u64 pos) {
        i64 fileno;
    fileno = (i64)msysc$m_getdotslice(pos,(i64)24,(i64)31);
    if (((fileno < (i64)1) || (fileno > mm_decls$nsourcefiles))) {
        return (i64)1;
    }
;
    return fileno;
}

i64 mm_support$getlineno(u64 pos) {
        u8 *  source;
        u8 *  sline;
        u8 *  s;
        i64 lineno;
    source = mm_support$getsourcestart(pos);
    sline = mm_support$getsourceline(pos);
    s = sline;
    lineno = (i64)1;
    L697 :;
    while ((s > source)) {
        if (((i64)(u64)(*s) == (i64)10)) {
            ++(lineno);
        }
;
        --(s);
L698 :;
    }
L699 :;
    ;
    return lineno;
}

static u8 *mm_support$getsourceline(u64 pos) {
        u8 *  source;
        u8 *  s;
    source = mm_support$getsourcestart(pos);
    s = mm_support$getsourcepos(pos);
    L700 :;
    while (((s > source) && ((i64)(u64)(*s) != (i64)10))) {
        --(s);
L701 :;
    }
L702 :;
    ;
    if (((i64)(u64)(*s) == (i64)10)) {
        ++(s);
    }
;
    return s;
}

static u8 *mm_support$getsourcestart(u64 pos) {
    return mm_decls$sourcefiletext[(mm_support$getfileno(pos))];
}

static u8 *mm_support$getsourcepos(u64 pos) {
    return (mm_decls$sourcefiletext[(mm_support$getfileno(pos))] + (i64)msysc$m_getdotslice(pos,(i64)0,(i64)23));
}

void mm_support$do_writema(void) {
        u8 filename[300];
        i64 sflist[1000];
        void *  f;
        i64 offset;
        i64 nfiles;
        i64 fileno;
        i64 i;
    if (!(!!((i64)mm_decls$fwritema))) {
        return;
    }
;
    strcpy(filename,mlib$changeext(mm_decls$sourcefilespecs[((i64)1)],(byte*)"ma"));
    nfiles = (i64)0;
    for (i=(i64)1;i<=mm_decls$nsourcefiles;++i) {
L703 :;
        if ((!!((i64)mm_decls$sourcefilesys[(i)]) && ((i64)mm_decls$fwritema == (i64)1))) {
            goto L704 ;
        }
;
        sflist[(++(nfiles))-1] = i;
L704 :;
    }
L705 :;
    ;
    if ((nfiles == (i64)0)) {
        mm_support$loaderror((byte*)"MA: no files",(byte*)"",(byte*)"");
    }
;
    f = fopen(filename,(byte*)"wb");
    if (!(!!(f))) {
        mm_support$loaderror((byte*)"Can't create MA file #",filename,(byte*)"");
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Writing ",NULL);
    msysc$m_print_str(filename,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_setfmt((byte*)"=== MA # ===");
    msysc$m_print_i64(nfiles,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=nfiles;++i) {
L706 :;
        fileno = sflist[(i)-1];
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"=== # # # #/# ===");
        msysc$m_print_str(mm_decls$sourcefilenames[(fileno)],NULL);
        msysc$m_print_i64((i64)mm_decls$sourcefilesys[(fileno)],NULL);
        msysc$m_print_i64((i64)mm_decls$sourcefilesupport[(fileno)],NULL);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_i64(nfiles,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        offset = mlib$getfilepos(f);
        mlib$writerandom(f,(byte *)mm_decls$sourcefiledupl[(fileno)],offset,mm_decls$sourcefilesizes[(fileno)]);
L707 :;
    }
L708 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"=== END ===",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=nfiles;++i) {
L709 :;
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"# #");
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str(mm_decls$sourcefilenames[(sflist[(i)-1])],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L710 :;
    }
L711 :;
    ;
    fclose(f);
    exit(0);
}

// START
void mm_support$start(void) {

}

// START
void mm_tables$start(void) {

        i64 i;
    for (i=(i64)1;i<=(i64)8;++i) {
L712 :;
        mm_tables$intresult[((i64)mm_tables$intresultlist[(i)-1])] = (i64)1;
L713 :;
    }
L714 :;
    ;
    for (i=(i64)1;i<=(i64)12;++i) {
L715 :;
        mm_tables$endsexpr[((i64)mm_tables$exprendsymbols[(i)-1])-1] = (i64)1;
L716 :;
    }
L717 :;
    ;
    mm_tables$isbooltag[((i64)32)] = (i64)1;
    mm_tables$isbooltag[((i64)33)] = (i64)1;
    mm_tables$isbooltag[((i64)14)] = (i64)1;
    mm_tables$isbooltag[((i64)15)] = (i64)1;
    mm_tables$isbooltag[((i64)16)] = (i64)1;
    mm_tables$isbooltag[((i64)17)] = (i64)1;
    mm_tables$isbooltag[((i64)40)] = (i64)1;
    mm_tables$isbooltag[((i64)41)] = (i64)1;
    mm_tables$ismemtag[((i64)4)] = (i64)1;
    mm_tables$ismemtag[((i64)44)] = (i64)1;
    mm_tables$ismemtag[((i64)46)] = (i64)1;
    mm_tables$ismemtag[((i64)49)] = (i64)1;
    mm_tables$ismemtag[((i64)50)] = (i64)2;
    mm_tables$ismemtag[((i64)51)] = (i64)2;
    mm_tables$ismemtag[((i64)1)] = (i64)2;
    mm_tables$ismemtag[((i64)47)] = (i64)1;
    mm_tables$ismemtag[((i64)48)] = (i64)1;
    for (i=(i64)1;i<=(i64)15;++i) {
L718 :;
        mm_tables$complexopset[((i64)mm_tables$complexops[(i)-1])] = (i64)1;
L719 :;
    }
L720 :;
    ;
}

static void mm_type$tpass(struct mm_decls$unitrec *p,i64 t,i64 lv) {
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
        struct mm_decls$unitrec *  c;
        i64 oldmlineno;
        i64 m;
        i64 paramtype;
        i64 restype;
        i64 $av_1;
        i64 i;
    if ((p == 0)) {
        return;
    }
;
    oldmlineno = mm_tables$mlineno;
    mm_tables$mlineno = (i64)(*p).pos;
    a = (*p).a;
    b = (*p).b;
    c = (*p).c;
    (*p).resultflag = (i64)(t != (i64)0);
    switch ((i64)(*p).tag) {
    case 4:;
        {
            mm_type$tx_name(p,t,lv);
        }
        break;
    case 1:;
    case 7:;
        {
        }
        break;
    case 56:;
        {
            (*p).mode = (i64)3;
        }
        break;
    case 60:;
    case 59:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
            (*p).mode = (i64)3;
        }
        break;
    case 34:;
    case 32:;
        {
            mm_type$tx_bin(p,a,b);
        }
        break;
    case 35:;
        {
            mm_type$tx_unary(p,a);
        }
        break;
    case 36:;
        {
            mm_type$tx_binto(p,a,b);
        }
        break;
    case 37:;
        {
            mm_type$tpasslv(a,(i64)22);
            (*p).mode = (i64)0;
        }
        break;
    case 26:;
        {
            mm_type$tx_assign(p,a,b,t);
        }
        break;
    case 50:;
        {
            if (((i64)(*a).tag == (i64)49)) {
                mm_lib$deleteunit(p,a);
                mm_lib$deleteunit(p,(*p).a);
                mm_type$tpass(p,t,(i64)0);
            }
            else {
                mm_type$tpasslv(a,(i64)22);
                (*p).mode = mm_lib$createrefmode(0,(i64)(*a).mode,(i64)0);
                mm_type$setsimple(p);
            }
;
        }
        break;
    case 51:;
        {
            mm_type$tx_addroffirst(p,a,t);
        }
        break;
    case 94:;
        {
            mm_type$tx_if(p,a,b,c,t,lv);
        }
        break;
    case 44:;
        {
            mm_type$tx_index(p,a,b,t,lv);
        }
        break;
    case 49:;
        {
            mm_type$tx_ptr(p,a,t,lv);
        }
        break;
    case 90:;
    case 31:;
        {
            mm_type$tx_callproc(p,a,b,t);
        }
        break;
    case 46:;
        {
            mm_type$tx_dot(p,a,b,lv);
        }
        break;
    case 14:;
    case 15:;
        {
            mm_type$tx_andl(p,a,b);
        }
        break;
    case 16:;
        {
            mm_type$tx_notl(p,a);
        }
        break;
    case 17:;
        {
            mm_type$tx_istruel(p,a);
        }
        break;
    case 52:;
        {
            mm_type$tx_convert(p,a,(i64)1);
        }
        break;
    case 55:;
        {
            mm_type$tx_typepun(p,a);
        }
        break;
    case 38:;
        {
            mm_type$tx_incrto(p,a,t);
        }
        break;
    case 19:;
        {
            mm_type$tx_makerange(p,a,b);
        }
        break;
    case 111:;
        {
            mm_type$tx_swap(p,a,b);
        }
        break;
    case 112:;
        {
            mm_type$tx_select(p,a,b,c,t,lv);
        }
        break;
    case 109:;
    case 110:;
        {
            mm_type$tx_switch(p,a,b,c,t,lv);
        }
        break;
    case 107:;
    case 108:;
        {
            mm_type$tx_case(p,a,b,c,t,lv);
        }
        break;
    case 47:;
    case 48:;
        {
            mm_type$tx_dotindex(p,a,b,lv);
        }
        break;
    case 45:;
        {
            mm_type$tx_slice(p,a,b);
        }
        break;
    case 6:;
        {
            mm_type$tx_block(p,a,t,lv);
        }
        break;
    case 125:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
        }
        break;
    case 106:;
        {
            mm_type$tpass(a,(i64)0,(i64)0);
        }
        break;
    case 91:;
        {
            mm_type$tx_return(p,a,t);
        }
        break;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
        {
            mm_type$tx_unitlist(a,(i64)22,(i64)0);
            mm_type$fixchararray(a);
            L721 :;
            while (!!(b)) {
                if (((i64)(*b).tag == (i64)87)) {
                    mm_type$tpass((c = (*b).a),(i64)22,(i64)0);
                    mm_type$tpass((*b).b,(i64)20,(i64)0);
                }
                else {
                    mm_type$tpass((c = b),(i64)22,(i64)0);
                }
;
                mm_type$fixchararray(c);
                b = (*b).nextunit;
L722 :;
            }
L723 :;
            ;
            mm_type$tx_unitlist((*p).c,(i64)22,(i64)0);
        }
        break;
    case 95:;
    case 96:;
        {
            mm_type$tx_for(a,b,c);
        }
        break;
    case 97:;
    case 98:;
        {
            mm_type$tx_forall(a,b,c);
        }
        break;
    case 93:;
        {
            mm_type$tpass(a,(i64)3,(i64)0);
            mm_type$tpass(b,(i64)0,(i64)0);
            mm_type$tpass(c,(i64)3,(i64)0);
        }
        break;
    case 54:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
            if ((t == (i64)22)) {
                mm_support$txerror((byte*)"cast() needs type",0);
            }
;
            mm_type$coerceunit(a,t,(i64)1);
            mm_lib$deleteunit(p,a);
        }
        break;
    case 18:;
        {
            mm_type$tx_makelist(p,a,t,lv);
        }
        break;
    case 124:;
        {
            mm_type$tpass(a,(i64)3,(i64)0);
        }
        break;
    case 105:;
    case 103:;
    case 104:;
        {
            mm_type$tx_exit(p,a);
        }
        break;
    case 101:;
        {
            mm_type$tx_goto(p,a);
        }
        break;
    case 102:;
        {
        }
        break;
    case 99:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
            if (!!(mm_type$iscondtrue(a))) {
                (*p).tag = (i64)106;
                (*p).a = b;
            }
            else if (!!(mm_type$iscondfalse(a))) {
                (*p).tag = (i64)2;
            }
;
            mm_type$tpass(b,(i64)0,(i64)0);
            mm_type$tpass(c,(i64)0,(i64)0);
        }
        break;
    case 100:;
        {
            mm_type$tpass(a,(i64)0,(i64)0);
            mm_type$tpass(b,(i64)22,(i64)0);
            if ((!!(mm_type$iscondtrue(b)) || !!(mm_type$iscondfalse(b)))) {
                mm_support$txerror((byte*)"repeat/const cond",0);
            }
;
        }
        break;
    case 88:;
    case 89:;
        {
        }
        break;
    case 8:;
        {
            if ((t != (i64)0)) {
                (*p).mode = t;
            }
;
            mm_type$inassem = (i64)1;
            mm_type$tx_unitlist(a,(i64)22,(i64)0);
            mm_type$tx_unitlist(b,(i64)22,(i64)0);
            mm_type$tx_unitlist(c,(i64)22,(i64)0);
            mm_type$inassem = (i64)0;
        }
        break;
    case 10:;
    case 11:;
        {
        }
        break;
    case 12:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
        }
        break;
    case 61:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
            if (((i64)(*a).tag == (i64)56)) {
                (*p).value = (*a).value;
            }
            else {
                (*p).value = (i64)(*a).mode;
            }
;
            (*p).tag = (i64)56;
            (*p).mode = (i64)3;
        }
        break;
    case 62:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
            if (((i64)(*a).tag == (i64)56)) {
                m = (*a).value;
            }
            else {
                mm_type$tpass(a,(i64)22,(i64)0);
                m = (i64)(*a).mode;
            }
;
            (*p).tag = (i64)1;
            (*p).mode = (i64)20;
            (*p).a = 0;
            (*p).svalue = mlib$pcm_copyheapstring(mm_lib$strmode(m,(i64)0));
            (*p).slength = strlen((*p).svalue);
            (*p).isastring = (i64)1;
        }
        break;
    case 87:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
            mm_type$tpass(b,(i64)22,(i64)0);
        }
        break;
    case 121:;
        {
            mm_type$tpass(a,(i64)22,(i64)0);
        }
        break;
    case 120:;
        {
            if (!!(a)) {
                mm_type$tpass(a,(i64)1,(i64)0);
            }
;
            if ((!!((i64)mm_decls$ttisinteger[(t)]) || !!((i64)mm_decls$ttisreal[(t)]))) {
                t = mm_lib$gettypebase(t);
            }
;
            (*p).mode = t;
        }
        break;
    case 113:;
        {
            if (!!(a)) {
                mm_type$tpass(a,(i64)3,(i64)0);
                if (((i64)(*a).tag != (i64)1)) {
                    mm_support$txerror((byte*)"recase must be const",0);
                }
;
            }
;
        }
        break;
    case 66:;
        {
            (*p).mode = (i64)3;
        }
        break;
    case 69:;
    case 68:;
        {
            (*p).mode = (i64)20;
        }
        break;
    case 63:;
        {
            mm_type$tx_bitfield(p,a,lv);
        }
        break;
    case 92:;
        {
            restype = (i64)0;
            paramtype = (i64)0;
                        {i64 $temp = (i64)(*p).fnindex;
if (($temp==(i64)29)) {
                restype = (i64)3;
            }
            else if (($temp==(i64)30)) {
                paramtype = (i64)3;
                restype = (i64)20;
            }
            else if (($temp==(i64)31)) {
                paramtype = (i64)3;
                restype = (i64)7;
            }
            else if (($temp==(i64)32) || ($temp==(i64)33) || ($temp==(i64)34)) {
                restype = (i64)7;
            }
            };
            if ((paramtype != (i64)0)) {
                if ((a == 0)) {
                    mm_support$txerror((byte*)"sys: arg missing",0);
                }
;
                mm_type$tpass(a,paramtype,(i64)0);
                if (!!((*a).nextunit)) {
                    mm_support$txerror((byte*)"sys: too many args",0);
                }
;
            }
            else if (!!(a)) {
                mm_support$txerror((byte*)"sys: too many args",0);
            }
;
            (*p).mode = restype;
        }
        break;
    case 33:;
        {
            mm_type$tx_cmpchain(p,a);
        }
        break;
    case 128:;
        {
            mm_type$tpasslv(a,(i64)22);
        }
        break;
    case 53:;
        {
        }
        break;
    case 13:;
        {
            mm_type$tx_strinclude(p,a);
        }
        break;
    case 22:;
        {
            mm_type$tx_makeslice(p,a,t);
        }
        break;
    case 20:;
        {
            mm_type$tx_makeset(p,a,t);
        }
        break;
    case 129:;
        {
        }
        break;
    case 130:;
        {
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"TXUNIT: CAN'T DO:",NULL);
        msysc$m_print_str(mm_tables$jtagnames[((i64)(*p).tag)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        //doelse:
L724 :;
;
                ($av_1 = (i64)mm_tables$jsubs[((i64)(*p).tag)]);
        for (i=(i64)1;i<=$av_1;++i) {
L725 :;
            mm_type$tx_unitlist((*p).abc[(i)-1],t,(i64)0);
L726 :;
        }
L727 :;
        ;
    }
    } //SW
;
    mm_type$tevaluate(p);
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)18) || ($temp==(i64)91)) {
    }
    else {
        if ((((t != (i64)22) && (t != (i64)0)) && ((i64)(*p).mode != t))) {
            mm_type$coerceunit(p,t,(i64)0);
        }
;
    }
    };
    if ((t == (i64)0)) {
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1) || ($temp==(i64)34) || ($temp==(i64)35) || ($temp==(i64)32)) {
        }
        else if (($temp==(i64)4)) {
            if (!((!!((i64)mm_decls$ttisref[((i64)(*p).mode)]) && ((i64)mm_decls$tttarget[((i64)(*p).mode)] == (i64)24)))) {
            }
;
        }
        };
    }
;
    mm_tables$mlineno = oldmlineno;
}

void mm_type$tx_allprocs(void) {
        struct mm_decls$procrec *  pp;
        struct mm_decls$unitrec *  pcode;
        struct mm_decls$strec *  d;
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L728 :;
    while (!!(pp)) {
        mm_decls$currproc = (*pp).def;
        pcode = (*mm_decls$currproc).code;
        if (!!((i64)mm_decls$ttisshort[((i64)(*mm_decls$currproc).mode)])) {
            mm_tables$mlineno = (i64)(*mm_decls$currproc).pos;
            mm_support$txerror((byte*)"proc short ret type",0);
        }
;
        if ((u64)1u) {
            d = (struct mm_decls$strec *)(*mm_decls$currproc).deflist;
            L732 :;
            while (!!(d)) {
                if (((i64)(*d).nameid == (i64)13)) {
                    if ((!!((i64)mm_decls$ttisblock[((i64)(*d).mode)]) && ((i64)(*d).parammode != (i64)2))) {
                        (*d).parammode = (i64)2;
                        (*d).mode = mm_lib$createrefmode(0,(i64)(*d).mode,(i64)0);
                    }
;
                }
;
L733 :;
                d = (struct mm_decls$strec *)(*d).nextdef;
L735 :;
                            }
L734 :;
            ;
        }
;
L729 :;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L731 :;
            }
L730 :;
    ;
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L736 :;
    while (!!(pp)) {
        mm_decls$currproc = (*pp).def;
        pcode = (*mm_decls$currproc).code;
        mm_type$tpass(pcode,(((i64)(*mm_decls$currproc).nretvalues > (i64)1) ? (i64)27 : (i64)(*mm_decls$currproc).mode),(i64)0);
                {i64 $temp = (i64)mm_decls$ttbasetype[((i64)(*mm_decls$currproc).mode)];
if (($temp==(i64)0)) {
        }
        else if (($temp==(i64)27)) {
        }
        else {
            if (((u64)1u && ((i64)(*pcode).tag != (i64)91))) {
                mm_lib$insertunit(pcode,(i64)91);
                (*pcode).mode = (i64)(*mm_decls$currproc).mode;
                (*pcode).resultflag = (i64)1;
            }
;
        }
        };
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L737 :;
    }
L738 :;
    ;
}

static void mm_type$tx_block(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t,i64 lv) {
    L739 :;
    while ((!!(a) && !!((*a).nextunit))) {
        mm_type$tpass(a,(i64)0,(i64)0);
        a = (*a).nextunit;
L740 :;
    }
L741 :;
    ;
    if (!!(a)) {
        mm_type$tpass(a,t,lv);
        (*p).mode = ((t != (i64)0) ? (i64)(*a).mode : (i64)0);
    }
;
}

void mm_type$tx_typetable(void) {
        struct mm_decls$strec *  d;
        i64 i;
    for (i=(i64)29;i<=mm_decls$ntypes;++i) {
L742 :;
        if (((i64)mm_decls$ttbasetype[(i)] == (i64)8)) {
            mm_type$tx_passdef((d = mm_decls$ttnamedef[(i)]));
        }
;
        mm_type$setmodesize(i);
L743 :;
    }
L744 :;
    ;
}

static void mm_type$setmodesize(i64 m) {
        i64 size;
        i64 target;
    if (!!((i64)mm_decls$ttsize[(m)])) {
        return;
    }
;
    mm_tables$mlineno = (i64)mm_decls$ttlineno[(m)];
        {i64 $temp = (i64)mm_decls$ttbasetype[(m)];
if (($temp==(i64)10)) {
        mm_type$setarraysize(m);
    }
    else if (($temp==(i64)8)) {
        mm_type$setrecordsize(m);
    }
    else if (($temp==(i64)0) || ($temp==(i64)23)) {
    }
    else if (($temp==(i64)11)) {
        mm_type$setslicesize(m);
    }
    else if (($temp==(i64)21)) {
        mm_support$txerror((byte*)"SETMODESIZE/AUTO?",0);
    }
    else if (($temp==(i64)22)) {
    }
    else if (($temp==(i64)28)) {
        target = (i64)mm_decls$tttarget[(m)];
        mm_type$setmodesize(target);
        mm_decls$ttbasetype[(m)] = (i64)mm_decls$ttbasetype[(target)];
        mm_decls$ttsize[(m)] = (i64)mm_decls$ttsize[(target)];
        mm_decls$ttlower[(m)] = (i64)mm_decls$ttlower[(target)];
        mm_decls$ttlength[(m)] = (i64)mm_decls$ttlength[(target)];
        mm_decls$ttnamedef[(m)] = mm_decls$ttnamedef[(target)];
    }
    else if (($temp==(i64)27)) {
    }
    else {
        if (!!((size = (i64)mm_decls$ttsize[((i64)mm_decls$ttbasetype[(m)])]))) {
            mm_decls$ttsize[(m)] = size;
            return;
        }
;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"SIZE 0:",NULL);
        msysc$m_print_str(mm_lib$strmode(m,(i64)1),NULL);
        msysc$m_print_str((byte*)"M=",NULL);
        msysc$m_print_i64(m,NULL);
        msysc$m_print_str((byte*)"STDNAMES[TTBASETYPE[M]]=",NULL);
        msysc$m_print_str(mm_tables$stdnames[((i64)mm_decls$ttbasetype[(m)])],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Can't set mode size",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    };
}

static void mm_type$setarraysize(i64 m) {
        i64 lower;
        i64 length;
        i64 elemsize;
        i64 target;
        i64 size;
        struct mm_decls$unitrec *  pdim;
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
    if (!!((i64)mm_decls$ttsizeset[(m)])) {
        return;
    }
;
    pdim = mm_decls$ttdimexpr[(m)];
    if (!!(pdim)) {
        a = (*pdim).a;
        b = (*pdim).b;
        mm_name$rx_unit(mm_decls$ttowner[(m)],pdim);
                {i64 $temp = (i64)(*pdim).tag;
if (($temp==(i64)19)) {
            mm_type$tpass(a,(i64)22,(i64)0);
            mm_type$tpass(b,(i64)22,(i64)0);
            lower = mm_type$getconstint(a);
            length = ((mm_type$getconstint(b) - lower) + (i64)1);
        }
        else if (($temp==(i64)25)) {
            mm_type$tpass(a,(i64)22,(i64)0);
            lower = mm_type$getconstint(a);
            if (!!(b)) {
                mm_type$tpass(b,(i64)22,(i64)0);
                length = mm_type$getconstint(b);
            }
            else {
                length = (i64)0;
            }
;
        }
        else {
            mm_type$tpass(pdim,(i64)22,(i64)0);
            length = mm_type$getconstint(pdim);
            lower = (i64)1;
        }
        };
    }
    else {
        lower = (i64)1;
        length = (i64)0;
    }
;
    mm_decls$ttdimexpr[(m)] = 0;
    mm_decls$ttlower[(m)] = lower;
    mm_decls$ttlength[(m)] = length;
    target = (i64)mm_decls$tttarget[(m)];
    mm_type$setmodesize(target);
    elemsize = (i64)mm_decls$ttsize[((i64)mm_decls$tttarget[(m)])];
    mm_decls$ttsize[(m)] = (size = (length * elemsize));
    mm_decls$ttsizeset[(m)] = (i64)1;
    mm_type$checkblocktype(m);
}

static void mm_type$setslicesize(i64 m) {
        struct mm_decls$unitrec *  pdim;
    if (!!((i64)mm_decls$ttsize[(m)])) {
        return;
    }
;
    pdim = mm_decls$ttdimexpr[(m)];
    if (!!(pdim)) {
        mm_name$rx_unit(mm_decls$ttowner[(m)],pdim);
        mm_type$tpass(pdim,(i64)22,(i64)0);
        mm_decls$ttlower[(m)] = mm_type$getconstint(pdim);
        mm_decls$ttdimexpr[(m)] = 0;
    }
    else {
        mm_decls$ttlower[(m)] = (i64)1;
    }
;
    mm_type$setmodesize((i64)mm_decls$tttarget[(m)]);
    mm_decls$ttsize[(m)] = (i64)mm_decls$ttsize[((i64)11)];
}

i64 mm_type$tx_module(i64 n) {
    mm_decls$currmoduleno = n;
    mm_type$tx_passdef(mm_decls$moduletable[(n)].stmodule);
    return (i64)1;
}

void mm_type$tx_passdef(struct mm_decls$strec *p) {
        struct mm_decls$strec *  d;
        i64 oldmlineno;
        struct mm_decls$unitrec *  q;
    if (!!(msysc$m_getdotindex((i64)(*p).flags,(i64)2))) {
        return;
    }
;
    oldmlineno = mm_tables$mlineno;
    mm_tables$mlineno = (i64)(*p).pos;
    d = (struct mm_decls$strec *)(*p).deflist;
    L745 :;
    while (!!(d)) {
        mm_type$tx_passdef(d);
        d = (struct mm_decls$strec *)(*d).nextdef;
L746 :;
    }
L747 :;
    ;
    q = (*p).code;
        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)6)) {
        mm_decls$currproc = 0;
    }
    else if (($temp==(i64)10) || ($temp==(i64)16)) {
        mm_type$tx_namedconst(p);
    }
    else if (($temp==(i64)11) || ($temp==(i64)12) || ($temp==(i64)13)) {
        mm_type$tx_namedef(p);
    }
    };
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)2,(u64)1u);
    mm_tables$mlineno = oldmlineno;
}

static void mm_type$tx_unitlist(struct mm_decls$unitrec *p,i64 t,i64 lv) {
    L748 :;
    while (!!(p)) {
        mm_type$tpass(p,t,(i64)0);
        p = (*p).nextunit;
L749 :;
    }
L750 :;
    ;
}

static void mm_type$tx_namedef(struct mm_decls$strec *d) {
        i64 m;
        i64 mold;
        i64 inidataold;
        struct mm_decls$unitrec *  dcode;
        struct mm_decls$unitrec *  pequiv;
    if (!!(mm_type$deb)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"NAMEDEF1",NULL);
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    m = (i64)(*d).mode;
    mm_type$setmodesize(m);
    if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)3))) {
        mm_support$txerror((byte*)"Circular reference detected",0);
    }
;
    if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)2))) {
        return;
    }
;
    dcode = (*d).code;
    (*d).flags = msysc$m_setdotindex((*d).flags,(i64)3,(u64)1u);
    if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)10))) {
        pequiv = (*d).equivvar;
        if (((i64)(*pequiv).tag == (i64)50)) {
            mm_lib$deleteunit(pequiv,(*pequiv).a);
        }
;
        if (((i64)(*pequiv).tag != (i64)4)) {
            mm_support$txerror((byte*)"@name needed",0);
        }
;
        mm_type$tpass(pequiv,(i64)22,(i64)0);
    }
;
    if ((!!(dcode) && ((i64)(*d).nameid != (i64)12))) {
        mold = m;
        m = mm_lib$gettypebase(m);
        if (((((i64)mm_decls$ttbasetype[(m)] == (i64)11) && ((i64)(*dcode).tag == (i64)1)) && ((i64)(*dcode).mode == (i64)20))) {
            mm_type$tpass(dcode,(i64)20,(i64)0);
        }
        else {
            inidataold = mm_type$inidata;
            mm_type$inidata = (i64)1;
            mm_type$tpass(dcode,m,(i64)0);
            mm_type$inidata = inidataold;
        }
;
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)3,(u64)0u);
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)2,(u64)1u);
        if ((((i64)mm_decls$ttbasetype[(m)] == (i64)10) && ((i64)mm_decls$ttlength[(m)] == (i64)0))) {
            (*d).mode = (i64)(*dcode).mode;
        }
;
        if ((mold != m)) {
            if ((!!((i64)mm_decls$ttisinteger[(m)]) && !!((i64)mm_decls$ttisshort[(mold)]))) {
                mm_lib$insertunit((*d).code,(i64)53);
                (*(*d).code).mode = mold;
            }
            else if ((mold == (i64)4)) {
                (*(*d).code).mode = mold;
            }
;
        }
;
        if (((i64)(*d).nameid == (i64)11)) {
            mm_type$checkconstexpr((*d).code);
        }
;
    }
    else if ((((!!(dcode) && ((i64)(*d).nameid == (i64)12)) && ((i64)mm_decls$ttbasetype[(m)] == (i64)10)) && ((i64)mm_decls$ttlength[(m)] == (i64)0))) {
        mm_type$tpass(dcode,m,(i64)0);
        (*d).mode = (i64)(*dcode).mode;
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)3,(u64)0u);
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)2,(u64)1u);
    }
    else {
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)3,(u64)0u);
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)2,(u64)1u);
    }
;
}

void mm_type$tx_namedconst(struct mm_decls$strec *d) {
        i64 m;
        struct mm_decls$unitrec *  q;
    if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)3))) {
        mm_support$txerror((byte*)"Circular const reference detected",0);
    }
;
    if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)2))) {
        return;
    }
;
    q = (*d).code;
    m = (i64)(*d).mode;
    (*d).flags = msysc$m_setdotindex((*d).flags,(i64)3,(u64)1u);
    mm_type$tpass(q,((m == (i64)21) ? (i64)22 : m),(i64)0);
    (*d).flags = msysc$m_setdotindex((*d).flags,(i64)3,(u64)0u);
    mm_type$checkconstexpr(q);
    if ((m == (i64)21)) {
        (*d).mode = (i64)(*q).mode;
    }
;
    (*d).flags = msysc$m_setdotindex((*d).flags,(i64)2,(u64)1u);
}

static void mm_type$checkconstexpr(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  q;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1) || ($temp==(i64)56)) {
        return;
    }
    else if (($temp==(i64)18)) {
        q = (*p).a;
        L751 :;
        while (!!(q)) {
            mm_type$checkconstexpr(q);
            q = (*q).nextunit;
L752 :;
        }
L753 :;
        ;
    }
    else if (($temp==(i64)52)) {
        if (((i64)mm_decls$ttbasetype[((i64)(*(*p).a).mode)] == (i64)7)) {
            if (((i64)mm_decls$tttarget[((i64)(*(*p).a).mode)] == (i64)0)) {
                (*(*p).a).mode = (i64)(*p).mode;
                mm_lib$deleteunit(p,(*p).a);
            }
            else {
                goto L754 ;
;
            }
;
        }
;
        //cerror:
L754 :;
;
        if ((u64)1u) {
            goto L755 ;
;
        }
;
    }
    else if (($temp==(i64)53)) {
        mm_type$checkconstexpr((*p).a);
    }
    else if (($temp==(i64)50) || ($temp==(i64)51)) {
                {i64 $temp = (i64)(*(*p).a).tag;
if (($temp==(i64)4)) {
        }
        else {
            goto L755 ;
;
        }
        };
    }
    else if (($temp==(i64)4)) {
        if (((i64)(*(*p).def).nameid == (i64)14)) {
            return;
        }
;
        if (((i64)(*(*p).def).nameid == (i64)17)) {
            return;
        }
;
        goto L755 ;
;
    }
    else {
        //error:
L755 :;
;
        msysc$m_print_startcon();
        msysc$m_print_str(mm_tables$jtagnames[((i64)(*p).tag)],NULL);
        msysc$m_print_str(mm_lib$strmode((i64)(*p).mode,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$txerror((byte*)"Getconstexpr: not const",0);
    }
    };
}

static i64 mm_type$getconstint(struct mm_decls$unitrec *q) {
    mm_type$checkconstexpr(q);
    if ((!!((i64)mm_decls$ttisinteger[((i64)(*q).mode)]) || ((i64)(*q).tag == (i64)56))) {
        return (*q).value;
    }
    else if (!!((i64)mm_decls$ttisreal[((i64)(*q).mode)])) {
        return (i64)(*q).xvalue;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(mm_lib$strmode((i64)(*q).mode,(i64)1),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$txerror((byte*)"Getconstint: not int32/64",0);
    }
;
    return (i64)0;
}

static void mm_type$makenewconst(struct mm_decls$unitrec *p,i64 x,i64 t) {
    (*p).tag = (i64)1;
    (*p).a = ((*p).b = 0);
    (*p).value = x;
    (*p).isconst = (i64)1;
    (*p).simple = (i64)1;
    if ((t != (i64)0)) {
        (*p).mode = t;
    }
;
}

static void mm_type$tx_name(struct mm_decls$unitrec *p,i64 t,i64 lv) {
        struct mm_decls$strec *  d;
        i64 oldmlineno;
        struct mm_decls$unitrec *  pcode;
    oldmlineno = mm_tables$mlineno;
    d = (*p).def;
    mm_tables$mlineno = (i64)(*d).pos;
    switch ((i64)(*d).nameid) {
    case 10:;
    case 16:;
        {
            if (!!(lv)) {
                mm_support$txerror((byte*)"&const",0);
            }
;
            mm_type$tx_namedconst(d);
            pcode = (*d).code;
            (*p).tag = (i64)1;
            (*p).def = 0;
            (*p).a = 0;
            (*p).c = 0;
            if (((i64)(*pcode).tag == (i64)52)) {
                (*p).value = (*(*pcode).a).value;
            }
            else {
                (*p).value = (*pcode).value;
            }
;
            (*p).slength = (i64)(*pcode).slength;
            (*p).mode = (i64)(*d).mode;
            (*p).isconst = (i64)1;
            (*p).isastring = (i64)(*pcode).isastring;
        }
        break;
    case 11:;
    case 12:;
    case 13:;
        {
            if ((!!(msysc$m_getdotindex((i64)(*d).flags,(i64)4)) && !!(lv))) {
                mm_support$txerror_s((byte*)"Can't use 'let' as lvalue: ",(*d).name,0);
            }
;
            mm_type$tx_namedef(d);
            if (!(!!(mm_type$inassem))) {
                (*p).mode = (i64)(*d).mode;
                if (((i64)(*d).parammode == (i64)2)) {
                    mm_lib$insertunit(p,(i64)49);
                    (*p).mode = (i64)mm_decls$tttarget[((i64)(*d).mode)];
                }
;
                mm_type$twiden(p,lv);
            }
            else {
                (*p).mode = (i64)20;
            }
;
        }
        break;
    case 6:;
    case 7:;
        {
            (*p).mode = mm_tables$trefproc;
        }
        break;
    case 17:;
        {
            (*p).mode = mm_tables$treflabel;
        }
        break;
    case 3:;
        {
            mm_support$txerror_s((byte*)"Module name can't be used on it's own: #",(*d).name,0);
        }
        break;
    case 14:;
        {
            (*p).tag = (i64)1;
            (*p).def = 0;
            (*p).a = 0;
            (*p).c = 0;
            (*p).value = (i64)(*d).offset;
            (*p).mode = (i64)3;
            (*p).isconst = (i64)1;
        }
        break;
    case 5:;
        {
            (*p).tag = (i64)56;
            (*p).value = (i64)(*d).mode;
            (*p).mode = (i64)3;
        }
        break;
    case 8:;
        {
            if (!!((*d).code)) {
                mm_support$txerror((byte*)"Can't init dllvar",0);
            }
;
            (*p).mode = (i64)(*d).mode;
        }
        break;
    default: {
        mm_tables$mlineno = (i64)(*p).pos;
        mm_support$txerror_ss((byte*)"TNAME? # #",mm_tables$namenames[((i64)(*d).nameid)],(*d).name);
    }
    } //SW
;
    mm_tables$mlineno = oldmlineno;
}

static void mm_type$tx_bin(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 amode;
        i64 bmode;
    mm_type$tpass(a,(i64)22,(i64)0);
    mm_type$tpass(b,(i64)22,(i64)0);
    amode = (i64)(*a).mode;
    bmode = (i64)(*b).mode;
    switch ((i64)(*p).pclop) {
    case 1:;
        {
            if (!!(mm_type$dobinnumx(p,a,b))) {
                return;
            }
;
            if (!!((i64)mm_decls$ttisref[(amode)])) {
                if (((!!((i64)mm_decls$ttisref[(bmode)]) && !!((i64)(*a).isastring)) && !!((i64)(*b).isastring))) {
                    mm_type$combinestrings(p);
                    return;
                }
;
                if ((bmode >= (i64)1 && bmode <= (i64)5)) {
                    mm_type$coerceunit(b,(i64)3,(i64)0);
                    (*p).pclop = (i64)26;
                    (*p).mode = amode;
                    return;
                }
;
            }
;
        }
        break;
    case 2:;
        {
            if (!!(mm_type$dobinnumx(p,a,b))) {
                return;
            }
;
            if (!!((i64)mm_decls$ttisref[(amode)])) {
                if (!!((i64)mm_decls$ttisref[(bmode)])) {
                    if (!!(mm_type$comparemodes(amode,bmode))) {
                        (*p).pclop = (i64)28;
                        (*p).mode = (i64)3;
                        return;
                    }
                    else {
                        mm_support$txerror((byte*)"ref-ref: not compat",0);
                    }
;
                }
;
                if ((bmode >= (i64)1 && bmode <= (i64)5)) {
                    mm_type$coerceunit(b,(i64)3,(i64)0);
                    (*p).pclop = (i64)27;
                    (*p).mode = amode;
                    return;
                }
;
            }
;
        }
        break;
    case 17:;
    case 18:;
    case 19:;
    case 20:;
    case 21:;
    case 22:;
        {
            if (!!(mm_type$dobinnumx(p,a,b))) {
                (*p).mode = (i64)6;
                return;
            }
;
            (*p).mode = (i64)6;
            if ((!!((i64)mm_decls$ttisref[(amode)]) && !!((i64)mm_decls$ttisref[(bmode)]))) {
                if (!(!!(mm_type$comparemodes(amode,bmode)))) {
                    mm_support$txerror((byte*)"Cmp ref/ref not compat",0);
                }
;
                return;
            }
;
            if (((i64)(*p).pclop == (i64)17 || (i64)(*p).pclop == (i64)18)) {
                if (!!(mm_type$comparemodes(amode,bmode))) {
                    return;
                }
;
            }
;
        }
        break;
    case 3:;
        {
            if (!!(mm_type$dobinnumx(p,a,b))) {
                return;
            }
;
        }
        break;
    case 4:;
        {
            if (((amode == (i64)3 || amode == (i64)2 || amode == (i64)1) && (bmode == (i64)3 || bmode == (i64)2 || bmode == (i64)1))) {
                (*p).pclop = (i64)5;
                goto L756 ;
;
            }
;
            if (!!(mm_type$dobinnumf(p,a,b))) {
                return;
            }
;
            if (((amode >= (i64)1 && amode <= (i64)5) && (bmode >= (i64)1 && bmode <= (i64)5))) {
                (*p).mode = (i64)5;
                mm_type$coerceunit(a,(i64)5,(i64)0);
                mm_type$coerceunit(b,(i64)5,(i64)0);
                return;
            }
;
        }
        break;
    case 5:;
    case 6:;
    case 7:;
    case 8:;
    case 9:;
    case 10:;
        {
            //doidiv:
L756 :;
;
            if (!!(mm_type$dobinnumi(p,a,b))) {
                return;
            }
;
        }
        break;
    case 15:;
    case 16:;
        {
            if (!!(mm_type$dobinnumx(p,a,b))) {
                return;
            }
;
        }
        break;
    case 51:;
        {
            if (!!(mm_type$dobinnumx(p,a,b))) {
                return;
            }
;
        }
        break;
    case 52:;
    case 50:;
        {
            if (!!(mm_type$dobinnumf(p,a,b))) {
                return;
            }
;
        }
        break;
    case 11:;
    case 12:;
        {
            if ((amode == (i64)3 || amode == (i64)2 || amode == (i64)1)) {
                mm_type$coerceunit(b,(i64)3,(i64)0);
                (*p).mode = amode;
                return;
            }
;
        }
        break;
    case 13:;
    case 14:;
        {
            mm_type$doin(p,a,b);
            return;
        }
        break;
    case 24:;
    case 25:;
        {
            (*p).mode = (i64)6;
            if ((amode==bmode && bmode==(i64)6)) {
                return;
            }
;
        }
        break;
    default: {
        mm_support$txerror((byte*)"txbin?",0);
    }
    } //SW
;
    msysc$m_print_startcon();
    msysc$m_print_str(mm_tables$pclnames[((i64)(*p).pclop)],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$txerror_ss((byte*)"BIN/CAN'T RESOLVE MODES",mm_lib$strmode(amode,(i64)1),mm_lib$strmode2(bmode,(i64)1));
}

static void mm_type$tx_binto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 abase;
        i64 bbase;
        i64 amode;
        i64 bmode;
    mm_type$tpasslv(a,(i64)22);
    mm_type$tpass(b,(i64)22,(i64)0);
    amode = (i64)(*a).mode;
    bmode = (i64)(*b).mode;
    abase = (i64)mm_decls$ttbasetype[(amode)];
    bbase = (i64)mm_decls$ttbasetype[(bmode)];
    if ((((i64)(*p).pclop == (i64)62) && !!((i64)mm_decls$ttisinteger[(abase)]))) {
        (*p).pclop = (i64)63;
    }
;
    (*p).mode = (i64)0;
        {i64 $temp = (i64)(*p).pclop;
if (($temp==(i64)59)) {
        if (((abase == (i64)7) && (bbase == (i64)7))) {
            mm_support$txerror((byte*)"to:ref+ref",0);
        }
;
        if (((abase == (i64)7) && (bbase <= (i64)5))) {
            mm_type$coerceunit(b,(i64)3,(i64)0);
            (*p).pclop = (i64)74;
            return;
        }
;
    }
    else if (($temp==(i64)60)) {
        if (((abase == (i64)7) && (bbase <= (i64)5))) {
            mm_type$coerceunit(b,(i64)3,(i64)0);
            (*p).pclop = (i64)75;
            return;
        }
;
    }
    else if (($temp==(i64)68) || ($temp==(i64)69)) {
        mm_type$coerceunit(b,(i64)3,(i64)0);
        return;
    }
    };
    if (((abase >= (i64)1 && abase <= (i64)5) && (bbase >= (i64)1 && bbase <= (i64)5))) {
        mm_type$coerceunit(b,abase,(i64)0);
    }
    else if ((!!((i64)mm_decls$ttisshort[(abase)]) && (bbase >= (i64)1 && bbase <= (i64)5))) {
        mm_type$coerceunit(b,abase,(i64)0);
    }
    else {
        if (!(!!(mm_type$comparemodes(amode,bmode)))) {
            mm_support$txerror_ss((byte*)"BIN: modes not compatible: # #",mm_lib$strmode(amode,(i64)1),mm_lib$strmode(bmode,(i64)1));
        }
;
    }
;
}

static i64 mm_type$getdominantmode(i64 amode,i64 bmode) {
        i64 abase;
        i64 bbase;
    abase = (i64)mm_decls$ttbasetype[(amode)];
    bbase = (i64)mm_decls$ttbasetype[(bmode)];
    if (((abase >= (i64)1 && abase <= (i64)5) && (bbase >= (i64)1 && bbase <= (i64)5))) {
        return (abase>bbase?abase:bbase);
    }
;
    if (!(!!(mm_type$comparemodes(amode,bmode)))) {
        mm_support$txerror((byte*)"Getdom: no dominant mode",0);
    }
;
    return amode;
}

static void mm_type$tx_cmpchain(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 u;
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  r;
    q = a;
    L757 :;
    while (!!(q)) {
        mm_type$tpass(q,(i64)22,(i64)0);
        if ((q == a)) {
            u = (i64)(*q).mode;
        }
        else {
            u = mm_type$getdominantmode(u,(i64)(*q).mode);
        }
;
        q = (*q).nextunit;
L758 :;
    }
L759 :;
    ;
    q = a;
    r = (*a).nextunit;
    L760 :;
    while (!!(q)) {
        mm_type$coerceunit(q,u,(i64)0);
        q = (*q).nextunit;
L761 :;
    }
L762 :;
    ;
    (*p).mode = (i64)6;
}

static void mm_type$tx_callproc(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *pargs,i64 t) {
        struct mm_decls$unitrec *  q;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
        struct mm_decls$strec *  pm;
        struct mm_decls$strec *  paramlist[100];
        struct mm_decls$unitrec *  arglist[100];
        struct mm_decls$unitrec *  newarglist[100];
        i64 nparams;
        i64 i;
        i64 j;
        i64 k;
        i64 nargs;
        i64 m;
        i64 kwdused;
        i64 qm;
        i64 ismproc;
        u8 *  name;
        struct mm_decls$unitrec *  ulist;
        struct mm_decls$unitrec *  ulistx;
    mm_type$tpass(a,(i64)22,(i64)0);
    nargs = (nparams = (i64)0);
    ismproc = (i64)0;
    //retry:
L763 :;
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)4)) {
        d = (*a).def;
        if (((i64)(*d).nameid == (i64)6 || (i64)(*d).nameid == (i64)7)) {
            ismproc = (i64)((i64)(*d).nameid == (i64)6);
            //getparams:
L764 :;
;
            e = (struct mm_decls$strec *)(*d).deflist;
            L765 :;
            while (!!(e)) {
                if (((i64)(*e).nameid == (i64)13)) {
                    if ((nparams >= (i64)100)) {
                        mm_support$txerror((byte*)"Param overflow",0);
                    }
;
                    paramlist[(++(nparams))-1] = e;
                }
;
                e = (struct mm_decls$strec *)(*e).nextdef;
L766 :;
            }
L767 :;
            ;
        }
        else {
            L768 :;
            while (((i64)mm_decls$ttbasetype[((i64)(*a).mode)] == (i64)7)) {
                mm_lib$insertunit(a,(i64)49);
                (*a).mode = (i64)mm_decls$tttarget[((i64)(*a).mode)];
L769 :;
            }
L770 :;
            ;
            goto L771 ;
;
        }
;
    }
    else if (($temp==(i64)94) || ($temp==(i64)112)) {
        mm_support$txerror((byte*)"Can't do ifx/function",0);
    }
    else {
        //dorefproc:
L771 :;
;
        if (((i64)(*a).tag == (i64)46)) {
            mm_type$tmethodcall(p,a,pargs);
            a = (*p).a;
            pargs = (*p).b;
            goto L763 ;
;
        }
;
        if (((i64)mm_decls$ttbasetype[((i64)(*a).mode)] != (i64)23)) {
            mm_support$txerror((byte*)"Function pointer expected",0);
        }
;
        d = mm_decls$ttnamedef[((i64)(*a).mode)];
        if ((d == 0)) {
            mm_support$txerror((byte*)"Function expected",0);
        }
;
        goto L764 ;
;
    }
    };
    q = pargs;
    L772 :;
    while (!!(q)) {
        if ((nargs >= (i64)100)) {
            mm_support$txerror((byte*)"Param overflow",0);
        }
;
        arglist[(++(nargs))-1] = q;
        q = (*q).nextunit;
L773 :;
    }
L774 :;
    ;
    (*p).mode = (i64)(*d).mode;
    if ((((i64)(*p).mode == (i64)0) && ((i64)(*p).tag == (i64)31))) {
        (*p).tag = (i64)90;
    }
;
    if ((!!((i64)(*p).mode) && (t != (i64)0))) {
        mm_type$twiden(p,(i64)0);
    }
;
    if (!!((i64)(*d).varparams)) {
        for (i=(i64)1;i<=nargs;++i) {
L775 :;
            if ((i <= nparams)) {
                mm_type$tpass(arglist[(i)-1],(i64)(*paramlist[(i)-1]).mode,(i64)0);
            }
            else {
                mm_type$tpass(arglist[(i)-1],(i64)22,(i64)0);
            }
;
L776 :;
        }
L777 :;
        ;
        if ((t == (i64)0)) {
            (*p).tag = (i64)90;
        }
;
        return;
    }
;
    k = (i64)0;
    kwdused = (i64)0;
    for (i=(i64)1;i<=nparams;++i) {
L778 :;
        newarglist[(i)-1] = 0;
L779 :;
    }
L780 :;
    ;
    for (i=(i64)1;i<=nargs;++i) {
L781 :;
        q = arglist[(i)-1];
        switch ((i64)(*q).tag) {
        case 24:;
            {
                name = (*(*(*q).a).def).name;
                for (j=(i64)1;j<=nparams;++j) {
L784 :;
                    if (!!(mlib$eqstring((*paramlist[(j)-1]).name,name))) {
                        goto L786 ;
                    }
;
L785 :;
                }
                {
                    mm_support$txerror_s((byte*)"Can't find kwd param: #",name,0);
                }
L786 :;
                ;
                if (!!(newarglist[(j)-1])) {
                    mm_support$txerror_s((byte*)"Kwd: # already used or was implicit",name,0);
                }
;
                newarglist[(j)-1] = (*q).b;
                kwdused = (i64)1;
            }
            break;
        case 2:;
            {
                if (!!(kwdused)) {
                    mm_support$txerror((byte*)"Normal param follows kwd",0);
                }
;
                q = 0;
                goto L787 ;
;
            }
            break;
        default: {
            //doregparam:
L787 :;
;
            if (!!(kwdused)) {
                mm_support$txerror((byte*)"Normal param follows kwd",0);
            }
;
            if ((k >= nparams)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"K=",NULL);
                msysc$m_print_i64(k,NULL);
                msysc$m_print_str((byte*)"NPARAMS=",NULL);
                msysc$m_print_i64(nparams,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                mm_support$txerror((byte*)"Too many params supplied",0);
            }
;
            newarglist[(++(k))-1] = q;
        }
        } //SW
;
L782 :;
    }
L783 :;
    ;
    for (i=(i64)1;i<=nparams;++i) {
L788 :;
        q = newarglist[(i)-1];
        pm = paramlist[(i)-1];
        if ((q == 0)) {
            if (!(!!((i64)(*pm).optional))) {
                mm_support$txerror_s((byte*)"Param not optional: #",msysc$strint(i,0),0);
            }
;
            if (!!((*pm).code)) {
                newarglist[(i)-1] = mm_lib$duplunit((*pm).code,(i64)(*p).pos);
            }
            else {
                newarglist[(i)-1] = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)0u,(i64)3);
            }
;
        }
;
L789 :;
    }
L790 :;
    ;
    ulist = 0;
    ulistx = 0;
    for (i=(i64)1;i<=nparams;++i) {
L791 :;
        pm = paramlist[(i)-1];
        q = newarglist[(i)-1];
        if (((i64)(*pm).parammode == (i64)2)) {
            mm_type$tpass(q,(m = (i64)mm_decls$tttarget[((i64)(*pm).mode)]),(i64)1);
            qm = (i64)(*q).mode;
            if (!(!!(mm_type$comparemodes(qm,m)))) {
                mm_support$txerror_ss((byte*)"&param: type mismatch",mm_lib$strmode(qm,(i64)1),mm_lib$strmode(m,(i64)1));
            }
;
            if (!(((u64)0u && ((i64)(*q).tag == (i64)52)))) {
                mm_lib$insertunit(q,(i64)50);
                (*q).mode = (i64)(*pm).mode;
            }
            else {
                (*q).tag = (i64)50;
                (*(*q).a).mode = (i64)(*pm).mode;
            }
;
            mm_type$setsimple(q);
        }
        else {
            mm_type$tpass(q,(i64)(*pm).mode,(i64)0);
        }
;
        mm_lib$addlistunit(&ulist,&ulistx,q);
        (*q).nextunit = 0;
L792 :;
    }
L793 :;
    ;
    (*p).b = ulist;
    if ((t == (i64)0)) {
        (*p).tag = (i64)90;
    }
;
}

static void mm_type$tx_unary(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 size;
        i64 amode;
        i64 mbase;
        i64 x;
        i64 resmode;
    mm_type$tpass(a,(i64)22,(i64)0);
    amode = (i64)(*a).mode;
    resmode = amode;
    switch ((i64)(*p).pclop) {
    case 89:;
    case 90:;
    case 88:;
    case 91:;
        {
            mm_type$do_bounds(p,a);
            return;
        }
        break;
    case 94:;
    case 93:;
        {
            size = ((i64)mm_decls$ttsize[((((i64)(*a).tag == (i64)56) ? (*a).value : amode))] * (((i64)(*p).pclop == (i64)94) ? (i64)1 : (i64)8));
            mm_type$makenewconst(p,size,(i64)0);
            resmode = (i64)3;
        }
        break;
    case 95:;
    case 96:;
        {
            resmode = (i64)3;
            if (((i64)(*a).tag == (i64)56)) {
                mbase = (i64)mm_decls$ttbasetype[((*a).value)];
            }
            else {
                mbase = (i64)mm_decls$ttbasetype[(mm_lib$getmemmode(a))];
            }
;
            if (((i64)(*p).pclop == (i64)95)) {
                if ((mbase==(i64)14)) {
                    x = (i64)-128;
                }
                else if ((mbase==(i64)15)) {
                    x = (i64)-32768;
                }
                else if ((mbase==(i64)16)) {
                    x = (i64)-2147483648;
                }
                else if ((mbase==(i64)3)) {
                    x = (i64)(-9223372036854775807-1);
                }
                else if ((mbase==(i64)17) || (mbase==(i64)18) || (mbase==(i64)19) || (mbase==(i64)2) || (mbase==(i64)12) || (mbase==(i64)1)) {
                    x = (i64)0;
                }
                else {
                    mm_support$txerror_s((byte*)"Can't do minvalue on #",mm_lib$strmode(mbase,(i64)1),0);
                }
;
            }
            else {
                if ((mbase==(i64)14)) {
                    x = (i64)127;
                }
                else if ((mbase==(i64)15)) {
                    x = (i64)32767;
                }
                else if ((mbase==(i64)16)) {
                    x = (i64)2147483647;
                }
                else if ((mbase==(i64)3)) {
                    x = (i64)9223372036854775807;
                }
                else if ((mbase==(i64)17) || (mbase==(i64)12)) {
                    x = (i64)255;
                }
                else if ((mbase==(i64)18)) {
                    x = (i64)65535;
                }
                else if ((mbase==(i64)19)) {
                    x = (i64)4294967295;
                }
                else if ((mbase==(i64)2)) {
                    x = (i64)0;
                    --(x);
                    resmode = (i64)2;
                }
                else {
                    mm_support$txerror_s((byte*)"Can't do maxvalue on #",mm_lib$strmode(mbase,(i64)1),0);
                }
;
            }
;
            (*p).tag = (i64)1;
            (*p).a = 0;
            (*p).value = x;
            (*p).isconst = (i64)1;
            (*p).simple = (i64)1;
        }
        break;
    case 41:;
    case 42:;
    case 44:;
    case 35:;
    case 36:;
    case 37:;
    case 38:;
    case 39:;
    case 40:;
        {
            mm_type$coerceunit(a,(i64)5,(i64)0);
            resmode = (i64)5;
        }
        break;
    case 97:;
        {
            (*p).tag = (i64)1;
            if (((i64)(*a).tag == (i64)56)) {
                amode = (*a).value;
            }
            else {
                amode = mm_lib$getmemmode(a);
            }
;
            (*p).mode = (i64)20;
            (*p).svalue = mlib$pcm_copyheapstring(mm_lib$strmode(amode,(i64)1));
            (*p).isastring = (i64)1;
            (*p).length = strlen((*p).svalue);
            return;
        }
        break;
    case 104:;
        {
            mm_type$tx_sliceptr(p,a);
            return;
        }
        break;
    case 31:;
        {
            if (!(!!((i64)mm_decls$ttisinteger[(amode)]))) {
                mm_support$txerror((byte*)"Inot",0);
            }
;
        }
        break;
    case 29:;
    case 30:;
    case 34:;
    case 43:;
    case 46:;
    case 47:;
        {
            if ((!(!!((i64)mm_decls$ttisinteger[(amode)])) && !(!!((i64)mm_decls$ttisreal[(amode)])))) {
                mm_support$txerror((byte*)"Neg/Abs?",0);
            }
;
        }
        break;
    default: {
        mm_support$txerror((byte*)"TX:UNARY NOT CHECKED",0);
    }
    } //SW
;
    (*p).mode = resmode;
}

static void mm_type$tx_if(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pcond,struct mm_decls$unitrec *plist,struct mm_decls$unitrec *pelse,i64 t,i64 lv) {
        struct mm_decls$unitrec *  pc;
        struct mm_decls$unitrec *  pl;
        i64 u;
    pc = pcond;
    pl = plist;
    u = (i64)0;
    if ((t != (i64)22)) {
        u = t;
    }
;
    L794 :;
    while (!!(pc)) {
        mm_type$tpass(pc,(i64)22,(i64)0);
        mm_type$tpass(pl,t,lv);
        if ((t == (i64)22)) {
            if ((u == (i64)0)) {
                u = (i64)(*pl).mode;
            }
            else {
                u = mm_type$getdominantmode(u,(i64)(*pl).mode);
            }
;
        }
;
L795 :;
        {
            pc = (*pc).nextunit;
            pl = (*pl).nextunit;
        }
L797 :;
            }
L796 :;
    ;
    if (((t != (i64)0) && (pelse == 0))) {
        mm_support$txerror((byte*)"else needed",0);
    }
;
    mm_type$tpass(pelse,t,lv);
    if ((t == (i64)22)) {
        u = mm_type$getdominantmode(u,(i64)(*pelse).mode);
    }
;
    if ((t != (i64)0)) {
        pl = plist;
        L798 :;
        while (!!(pl)) {
            if ((t == (i64)22)) {
                mm_type$coerceunit(pl,u,(i64)0);
            }
;
L799 :;
            pl = (*pl).nextunit;
L801 :;
                    }
L800 :;
        ;
        if ((t == (i64)22)) {
            mm_type$coerceunit(pelse,u,(i64)0);
        }
;
        (*p).mode = u;
    }
;
    if (((*pcond).nextunit==(*plist).nextunit && (*plist).nextunit==0)) {
        if (!!(mm_type$iscondtrue(pcond))) {
            if (((u64)1u || ((i64)(*plist).tag == (i64)1))) {
                mm_lib$deleteunit(p,plist);
            }
;
        }
        else if (!!(mm_type$iscondfalse(pcond))) {
            if ((pelse == 0)) {
                pelse = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)6);
            }
;
            if (((u64)1u || ((i64)(*pelse).tag == (i64)1))) {
                mm_lib$deleteunit(p,pelse);
            }
;
        }
;
    }
;
    mm_type$setsimple(p);
}

static void mm_type$tx_incrto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t) {
    mm_type$tpasslv(a,(i64)22);
    if (!((!!((i64)mm_decls$ttisref[((i64)(*a).mode)]) || !!((i64)mm_decls$ttisinteger[((i64)(*a).mode)])))) {
        mm_support$txerror((byte*)"incr not int/ref",0);
    }
;
    if ((t != (i64)0)) {
                {i64 $temp = (i64)(*p).pclop;
if (($temp==(i64)53)) {
            (*p).pclop = (i64)55;
        }
        else if (($temp==(i64)54)) {
            (*p).pclop = (i64)56;
        }
        };
        (*p).mode = mm_lib$gettypebase((i64)(*a).mode);
    }
    else {
                {i64 $temp = (i64)(*p).pclop;
if (($temp==(i64)57)) {
            (*p).pclop = (i64)53;
        }
        else if (($temp==(i64)58)) {
            (*p).pclop = (i64)54;
        }
        };
        (*p).mode = (i64)0;
    }
;
    mm_type$twiden(p,(i64)0);
}

static void mm_type$tx_for(struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *pfrom,struct mm_decls$unitrec *pbody) {
        struct mm_decls$unitrec *  pto;
        struct mm_decls$unitrec *  pstep;
        struct mm_decls$unitrec *  passign;
        i64 u;
    pto = (*pfrom).nextunit;
    pstep = (*pto).nextunit;
    passign = (*pindex).nextunit;
    mm_type$tpass(pindex,(i64)22,(i64)0);
    if (((i64)(*pindex).tag != (i64)4)) {
        mm_support$txerror((byte*)"Loop index not a variable",0);
    }
;
    u = (i64)(*pindex).mode;
    if (!!(passign)) {
        mm_type$tpass(passign,(i64)22,(i64)0);
        if (((i64)(*(*passign).b).tag == (i64)1 || (i64)(*(*passign).b).tag == (i64)4)) {
            (*pindex).nextunit = 0;
            pto = ((*pfrom).nextunit = (*passign).b);
            (*pto).nextunit = pstep;
            (*(*(*passign).a).def).flags = msysc$m_setdotindex((*(*(*passign).a).def).flags,(i64)1,(u64)0u);
        }
;
    }
;
    mm_type$tpass(pfrom,u,(i64)0);
    mm_type$tpass(pto,u,(i64)0);
    mm_type$tpass(pstep,u,(i64)0);
    mm_type$tpass(pbody,(i64)0,(i64)0);
    mm_type$tpass((*pbody).nextunit,(i64)0,(i64)0);
}

static void mm_type$tx_forall(struct mm_decls$unitrec *pindex,struct mm_decls$unitrec *plist,struct mm_decls$unitrec *pbody) {
        struct mm_decls$unitrec *  plocal;
        struct mm_decls$unitrec *  pfrom;
        struct mm_decls$unitrec *  pto;
        struct mm_decls$unitrec *  passign;
        i64 mlist;
        i64 elemtype;
    plocal = (*pindex).nextunit;
    pfrom = (*plocal).nextunit;
    pto = (*pfrom).nextunit;
    passign = (*plist).nextunit;
    mm_type$tpass(pindex,(i64)3,(i64)0);
    mm_type$tpass(pfrom,(i64)3,(i64)0);
    mm_type$tpass(pto,(i64)3,(i64)0);
    mm_type$tpass(plist,(i64)22,(i64)0);
    mlist = (i64)(*plist).mode;
        {i64 $temp = (i64)mm_decls$ttbasetype[(mlist)];
if (($temp==(i64)10)) {
        elemtype = (i64)mm_decls$tttarget[(mlist)];
    }
    else if (($temp==(i64)11)) {
        elemtype = (i64)mm_decls$tttarget[(mlist)];
    }
    else {
        mm_support$txerror((byte*)"forall/can't iterate",0);
    }
    };
    mm_type$tpass(plocal,(i64)22,(i64)0);
    if (((i64)(*plocal).mode == (i64)22)) {
        (*plocal).mode = elemtype;
        (*(*plocal).def).mode = elemtype;
    }
;
    mm_type$tpass(passign,(i64)22,(i64)0);
    mm_type$tpass(pbody,(i64)0,(i64)0);
    mm_type$tpass((*pbody).nextunit,(i64)0,(i64)0);
}

static void mm_type$tx_index(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 t,i64 lv) {
        i64 amode;
    mm_type$tpass(a,(i64)22,lv);
    mm_type$deref(a,(i64)(t != (i64)0));
    amode = (i64)(*a).mode;
    mm_type$tpass(b,(i64)3,(i64)0);
    if (!(((i64)mm_decls$ttbasetype[(amode)] == (i64)10 || (i64)mm_decls$ttbasetype[(amode)] == (i64)11))) {
        mm_support$txerror_s((byte*)"Can't index: #",mm_lib$strmode(amode,(i64)1),0);
    }
;
    (*p).mode = (i64)mm_decls$tttarget[(amode)];
    mm_type$twiden(p,lv);
    mm_type$setsimple(p);
}

static void mm_type$tx_makerange(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 amode;
        i64 bmode;
    mm_type$tpass(a,(i64)3,(i64)0);
    mm_type$tpass(b,(i64)3,(i64)0);
    amode = (i64)(*a).mode;
    bmode = (i64)(*b).mode;
    mm_type$coerceunit(a,(i64)3,(i64)0);
    mm_type$coerceunit(b,(i64)3,(i64)0);
    mm_type$setsimple(p);
    (*p).mode = (i64)9;
}

static void mm_type$tx_ptr(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t,i64 lv) {
    mm_type$tpass(a,(i64)22,(i64)0);
        {i64 $temp = (i64)mm_decls$ttbasetype[((i64)(*a).mode)];
if (($temp==(i64)0)) {
        mm_support$txerror((byte*)"Deref Void",0);
    }
    else if (($temp==(i64)7)) {
        (*p).mode = (i64)mm_decls$tttarget[((i64)(*a).mode)];
    }
    else if (($temp==(i64)11)) {
        mm_support$txerror((byte*)"Can't deref slice",0);
    }
    else {
        mm_support$txerror((byte*)"PTR: need ref T",0);
    }
    };
    mm_type$setsimple(p);
    mm_type$twiden(p,lv);
}

static void mm_type$setrecordsize(i64 m) {
        struct mm_decls$strec *  fieldlist[208];
        i64 nfields;
        i64 size;
        i64 index;
        i64 maxalign;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
        u8 *  flags;
        i64 flag;
    if (!!((i64)mm_decls$ttsize[(m)])) {
        return;
    }
;
    d = mm_decls$ttnamedef[(m)];
    e = (struct mm_decls$strec *)(*d).deflist;
    nfields = (i64)0;
    fieldlist[(++(nfields))-1] = (struct mm_decls$strec *)'S';
    L802 :;
    while (!!(e)) {
        if (((i64)(*e).nameid == (i64)14)) {
            if ((nfields >= (i64)200)) {
                mm_support$gerror((byte*)"srs:too many fields",0);
            }
;
            mm_type$setmodesize((i64)(*e).mode);
            flags = (u8 *)&(*e).uflags;
            L805 :;
                        {u64 $temp = (u64)(*flags);
if (($temp=='S') || ($temp=='U')) {
                flag = (i64)(u64)(*flags);
                fieldlist[(++(nfields))-1] = *(struct mm_decls$strec **)&flag;
                ++(flags);
            }
            else {
                goto L806 ;
            }
            }goto L805 ;
L806 :;
            ;
            fieldlist[(++(nfields))-1] = e;
            L807 :;
            while (1) {
                flag = (i64)(u64)(*(flags)++);
                if ((flag==(i64)42)) {
                }
                else if ((flag==(i64)69)) {
                    fieldlist[(++(nfields))-1] = (struct mm_decls$strec *)'E';
                }
                else {
                    goto L808 ;
                }
;
            }
L808 :;
            ;
        }
;
        e = (struct mm_decls$strec *)(*e).nextdef;
L803 :;
    }
L804 :;
    ;
    fieldlist[(++(nfields))-1] = (struct mm_decls$strec *)'E';
    fieldlist[((nfields + (i64)1))-1] = 0;
    mm_type$countedfields = (i64)0;
    index = (i64)2;
    maxalign = (i64)1;
    mm_type$scanrecord((i64)83,(struct mm_decls$strec *(*)[])&fieldlist,&index,&size,(i64)0,(i64)(*d).align,&maxalign);
    if (!!((i64)(*d).align)) {
        size = mm_type$roundoffset(size,maxalign);
        (*d).maxalign = maxalign;
    }
    else {
        (*d).maxalign = (i64)1;
    }
;
    mm_decls$ttsize[(m)] = size;
    mm_decls$ttlength[(m)] = mm_type$countedfields;
    mm_decls$ttlower[(m)] = (i64)1;
    mm_type$checkblocktype(m);
}

static void mm_type$checkblocktype(i64 m) {
        {i64 $temp = (i64)mm_decls$ttsize[(m)];
if (($temp==(i64)1) || ($temp==(i64)2) || ($temp==(i64)4)) {
        mm_decls$ttisblock[(m)] = (i64)0;
        mm_decls$ttcat[(m)] = (i64)4;
    }
    else if (($temp==(i64)8)) {
        mm_decls$ttisblock[(m)] = (i64)0;
        mm_decls$ttcat[(m)] = (i64)1;
    }
    };
}

static void mm_type$scanrecord(i64 state,struct mm_decls$strec *(*fields)[],i64 *index,i64 *isize,i64 offset,i64 calign,i64 *maxalign) {
        struct mm_decls$strec *  e;
        struct mm_decls$strec *  f;
        struct mm_decls$strec *  ea;
        i64 size;
        i64 fieldsize;
        i64 bitoffset;
        i64 alignment;
        i64 newoffset;
    size = (i64)0;
    bitoffset = (i64)0;
    L809 :;
    while (!!((f = (*fields)[(((*index))++)-1]))) {
                {i64 $temp = (i64)f;
if (($temp==(i64)83) || ($temp==(i64)85)) {
            mm_type$scanrecord((i64)f,fields,index,&fieldsize,offset,calign,maxalign);
        }
        else if (($temp==(i64)69)) {
            if ((state == (i64)85)) {
                ++(mm_type$countedfields);
            }
;
            (*isize) = size;
            return;
        }
        else {
            if (((i64)(*f).mode == (i64)26)) {
                fieldsize = (i64)0;
                ea = (struct mm_decls$strec *)(*f).equivfield;
                (*f).offset = (i64)(*ea).offset;
                (*f).bitoffset = bitoffset;
                bitoffset += (i64)(*f).bitfieldwidth;
                if ((bitoffset > ((i64)mm_decls$ttsize[((i64)(*(*f).equivfield).mode)] * (i64)8))) {
                    mm_support$txerror((byte*)"Bit fields overflow type",0);
                }
;
            }
            else if (!!(msysc$m_getdotindex((i64)(*f).flags,(i64)9))) {
                if ((u64)0u) {
                    mm_support$gerror((byte*)"Field@",0);
                }
;
                bitoffset = (i64)0;
                e = (struct mm_decls$strec *)(*f).equivfield;
                fieldsize = (i64)0;
                (*f).offset = ((i64)(*e).offset + (i64)(*f).equivoffset);
            }
            else {
                bitoffset = (i64)0;
                if ((state == (i64)83)) {
                    ++(mm_type$countedfields);
                }
;
                fieldsize = (i64)mm_decls$ttsize[((i64)(*f).mode)];
                if (!!(calign)) {
                    alignment = mm_lib$getalignment((i64)(*f).mode);
                    if ((alignment > (*maxalign))) {
                        (*maxalign) = alignment;
                    }
;
                    newoffset = mm_type$roundoffset(offset,alignment);
                    size += (newoffset - offset);
                }
                else {
                    newoffset = offset;
                }
;
                (*f).offset = newoffset;
                offset = newoffset;
            }
;
        }
        };
        if ((state == (i64)83)) {
            offset += fieldsize;
            size += fieldsize;
        }
        else {
            size = (size>fieldsize?size:fieldsize);
        }
;
L810 :;
    }
L811 :;
    ;
}

static i64 mm_type$roundoffset(i64 offset,i64 alignment) {
        i64 mask;
    if ((alignment == (i64)1)) {
        return offset;
    }
;
    mask = (alignment - (i64)1);
    L812 :;
    while (!!((offset & mask))) {
        ++(offset);
L813 :;
    }
L814 :;
    ;
    return offset;
}

static void mm_type$tx_convert(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 hard) {
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)18)) {
        mm_type$tx_makelist(a,(*a).a,(i64)(*p).convmode,(i64)0);
    }
    else {
        mm_type$tpass(a,(i64)22,(i64)0);
        mm_type$coerceunit(a,(i64)(*p).convmode,hard);
    }
    };
    mm_lib$deleteunit(p,a);
}

static void mm_type$tx_makelist(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t,i64 lv) {
        i64 alength;
        i64 tlength;
        i64 elemtype;
        i64 newt;
        i64 isconst;
        struct mm_decls$unitrec *  q;
        struct mm_decls$strec *  e;
    alength = (i64)(*p).length;
    newt = (i64)0;
    isconst = (i64)1;
    tlength = (i64)mm_decls$ttlength[(t)];
    if (!!(tlength)) {
        if ((alength < tlength)) {
            mm_support$txerror_ss((byte*)"Too few elements",msysc$strint(alength,0),msysc$strint(tlength,0));
        }
        else if ((alength > tlength)) {
            mm_support$txerror_ss((byte*)"Too many elements",msysc$strint(alength,0),msysc$strint(tlength,0));
        }
;
    }
;
        {i64 $temp = (i64)mm_decls$ttbasetype[(t)];
if (($temp==(i64)10)) {
        elemtype = (i64)mm_decls$tttarget[(t)];
        if ((tlength == (i64)0)) {
            newt = mm_lib$createarraymodek(0,elemtype,(i64)mm_decls$ttlower[(t)],alength,(i64)0);
        }
        else {
            newt = t;
        }
;
        q = a;
        L815 :;
        while (!!(q)) {
            mm_type$tpass(q,elemtype,lv);
            if (!(((i64)(*q).tag == (i64)1))) {
                isconst = (i64)0;
            }
;
            q = (*q).nextunit;
L816 :;
        }
L817 :;
        ;
        (*p).mode = newt;
    }
    else if (($temp==(i64)8)) {
        e = (struct mm_decls$strec *)(*mm_decls$ttnamedef[(t)]).deflist;
        q = a;
        L818 :;
        while ((!!(q) && !!(e))) {
            if (((i64)(*e).nameid == (i64)14)) {
                L821 :;
                while (((i64)(*e).mode == (i64)26)) {
                    e = (struct mm_decls$strec *)(*e).nextdef;
                    if (!(!!(e))) {
                        goto L823 ;
                    }
;
L822 :;
                }
L823 :;
                ;
                mm_type$tpass(q,(i64)(*e).mode,lv);
                if (!(((i64)(*q).tag == (i64)1))) {
                    isconst = (i64)0;
                }
;
                q = (*q).nextunit;
            }
;
            e = (struct mm_decls$strec *)(*e).nextdef;
L819 :;
        }
L820 :;
        ;
        L824 :;
        while ((!!(e) && (((i64)(*e).nameid != (i64)14) || ((i64)(*e).mode == (i64)26)))) {
            e = (struct mm_decls$strec *)(*e).nextdef;
L825 :;
        }
L826 :;
        ;
        if ((!!(q) || !!(e))) {
            mm_support$txerror((byte*)"Can't initialise unions",0);
        }
;
        (*p).mode = t;
    }
    else {
        mm_support$txerror_s((byte*)"Unknown makelist type: #",mm_lib$strmode(t,(i64)1),0);
    }
    };
    (*p).isconst = isconst;
    mm_type$tpass((*p).b,(i64)3,(i64)0);
    if ((!(!!(mm_type$inidata)) && !!(isconst))) {
        e = mm_lib$getavname(mm_decls$currproc,(i64)11);
        (*e).mode = t;
        mm_lib$addstatic(e);
        q = (struct mm_decls$unitrec *)mm_lib$createunit0((i64)0);
        (*q) = (*p);
        (*e).code = q;
        (*p).tag = (i64)4;
        (*p).def = e;
    }
;
}

static void mm_type$tx_makeslice(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t) {
    if (((i64)(*p).length != (i64)2)) {
        mm_support$txerror((byte*)"slice:=[a,b]",0);
    }
;
    (*p).b = (*a).nextunit;
    (*a).nextunit = 0;
    mm_type$tpass(a,(i64)22,(i64)0);
    if (((i64)mm_decls$ttbasetype[((i64)(*a).mode)] != (i64)7)) {
        mm_support$txerror((byte*)"slice init not ref",0);
    }
;
    if (((i64)mm_decls$tttarget[((i64)(*a).mode)] != (i64)0)) {
        if (!(!!(mm_type$comparemodes((i64)(*a).mode,mm_lib$createrefmode(0,(i64)mm_decls$tttarget[(t)],(i64)0))))) {
            mm_support$txerror((byte*)"slice/ptr mismatch",0);
        }
;
    }
;
    mm_type$tpass((*p).b,(i64)3,(i64)0);
    (*p).mode = t;
    (*p).tag = (i64)22;
    (*p).resultflag = (i64)1;
    mm_type$tpass((*p).b,(i64)3,(i64)0);
}

static void mm_type$tx_makeset(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t) {
    (*p).isconst = (i64)1;
    if (((i64)mm_decls$ttbasetype[(t)] == (i64)11)) {
        mm_type$tx_makeslice(p,a,t);
        return;
    }
;
    L827 :;
    while (!!(a)) {
        mm_type$tpass(a,(i64)22,(i64)0);
        if (!(!!((i64)(*a).isconst))) {
            (*p).isconst = (i64)0;
        }
;
L828 :;
        a = (*a).nextunit;
L830 :;
            }
L829 :;
    ;
    (*p).mode = (i64)0;
}

static void mm_type$tx_dot(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 lv) {
        i64 recmode;
        i64 recbasemode;
        i64 i;
        i64 j;
        i64 newtag;
        i64 tmode;
        struct mm_decls$unitrec *  pindex;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  dequiv;
    mm_type$tpass(a,(i64)22,(i64)0);
    mm_type$setsimple(a);
    recmode = (i64)(*a).mode;
    recbasemode = (i64)mm_decls$ttbasetype[(recmode)];
    L831 :;
    while ((recbasemode == (i64)7)) {
        tmode = (i64)mm_decls$tttarget[(recmode)];
        mm_lib$insertunit(a,(i64)49);
        mm_type$setsimple(a);
        recmode = ((*a).mode = tmode);
        recbasemode = (i64)mm_decls$ttbasetype[(recmode)];
L832 :;
    }
L833 :;
    ;
    if (((i64)mm_decls$ttbasetype[(recmode)] != (i64)8)) {
        mm_support$txerror((byte*)"Bad record type",0);
    }
;
    d = (*b).def;
    if (((i64)(*d).nameid == (i64)0)) {
        d = ((*b).def = mm_type$resolvefield(d,recmode));
    }
;
    if (((i64)(*d).mode == (i64)26)) {
        i = (i64)(*d).bitoffset;
        j = ((i + (i64)(*d).bitfieldwidth) - (i64)1);
        dequiv = (struct mm_decls$strec *)(*d).equivfield;
        (*b).def = dequiv;
        (*b).mode = (i64)(*dequiv).mode;
        (*p).offset = (i64)(*d).offset;
        if ((i == j)) {
            pindex = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)i,(i64)3);
            newtag = (i64)47;
        }
        else {
            pindex = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)19,(struct mm_decls$unitrec *)mm_lib$createconstunit((u64)i,(i64)3),(struct mm_decls$unitrec *)mm_lib$createconstunit((u64)j,(i64)3));
            (*pindex).mode = (i64)9;
            (*(*pindex).a).resultflag = (i64)1;
            (*(*pindex).b).resultflag = (i64)1;
            (*pindex).simple = (i64)1;
            newtag = (i64)48;
        }
;
        (*p).mode = (i64)(*b).mode;
        mm_type$twiden(p,lv);
        mm_type$setsimple(p);
        mm_lib$insertunit(p,newtag);
        (*p).mode = (i64)2;
        (*p).b = pindex;
        (*(*p).a).resultflag = (i64)1;
        (*(*p).b).resultflag = (i64)1;
        (*p).resultflag = (i64)1;
        mm_type$setsimple(p);
        return;
    }
;
    (*b).mode = (i64)(*d).mode;
    (*p).mode = (i64)(*d).mode;
    mm_type$setsimple(p);
    (*p).offset = (i64)(*d).offset;
    mm_type$twiden(p,lv);
}

static struct mm_decls$strec *mm_type$resolvefield(struct mm_decls$strec *d,i64 m) {
        struct mm_decls$strec *  e;
        struct mm_decls$strec *  t;
        {i64 $temp = (i64)mm_decls$ttbasetype[(m)];
if (($temp==(i64)8)) {
    }
    else if (($temp==(i64)7)) {
        m = (i64)mm_decls$tttarget[(m)];
        if (((i64)mm_decls$ttbasetype[(m)] != (i64)8)) {
            mm_support$txerror((byte*)"3:record expected",0);
        }
;
    }
    else {
        mm_support$txerror((byte*)"4:record expected",0);
    }
    };
    t = mm_decls$ttnamedef[(m)];
    e = mm_name$finddupl(t,d);
    if (!(!!(e))) {
        mm_support$txerror_s((byte*)"Not a field: #",(*d).name,0);
    }
;
    return e;
}

static void mm_type$tx_andl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
    mm_type$tpass(a,(i64)6,(i64)0);
    mm_type$tpass(b,(i64)6,(i64)0);
    (*p).mode = (i64)6;
    mm_type$setsimple(p);
}

static void mm_type$convintconst(struct mm_decls$unitrec *p,i64 x) {
    (*p).tag = (i64)1;
    (*p).mode = (i64)3;
    (*p).a = ((*p).b = ((*p).c = 0));
    (*p).value = x;
    (*p).isconst = (i64)1;
}

static void mm_type$tx_sliceptr(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 m;
        i64 tmode;
    m = (i64)(*a).mode;
        {i64 $temp = (i64)mm_decls$ttbasetype[(m)];
if (($temp==(i64)11)) {
    }
    else {
        mm_support$txerror_s((byte*)"SLICEPTR #",mm_lib$strmode(m,(i64)1),0);
    }
    };
    tmode = mm_lib$createarraymodek(0,(i64)mm_decls$tttarget[(m)],(i64)mm_decls$ttlower[(m)],(i64)0,(i64)0);
    (*p).mode = mm_lib$createrefmode(0,tmode,(i64)0);
}

static void mm_type$tx_swap(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
    mm_type$tpasslv(a,(i64)22);
    mm_type$tpasslv(b,(i64)22);
    if (!(!!(mm_type$comparemodes((i64)(*a).mode,(i64)(*b).mode)))) {
        mm_support$txerror((byte*)"SWAP: type mismatch",0);
    }
;
    (*p).mode = (i64)0;
}

static void mm_type$tx_select(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 t,i64 lv) {
        i64 u;
        struct mm_decls$unitrec *  q;
    mm_type$tpass(a,(i64)3,(i64)0);
    q = b;
    L834 :;
    while (!!(q)) {
        mm_type$tpass(q,t,lv);
        if ((q == b)) {
            u = (i64)(*q).mode;
        }
        else {
            u = mm_type$getdominantmode(u,(i64)(*q).mode);
        }
;
        q = (*q).nextunit;
L835 :;
    }
L836 :;
    ;
    mm_type$tpass(c,t,lv);
    u = mm_type$getdominantmode(u,(i64)(*c).mode);
    q = b;
    L837 :;
    while (!!(q)) {
        mm_type$coerceunit(q,u,(i64)0);
        q = (*q).nextunit;
L838 :;
    }
L839 :;
    ;
    if ((t != (i64)0)) {
        (*p).mode = u;
    }
    else {
        (*p).mode = (i64)0;
    }
;
}

static void mm_type$tx_case(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 t,i64 lv) {
        i64 amode;
        i64 u;
        struct mm_decls$unitrec *  wt;
        struct mm_decls$unitrec *  w;
    if ((((i64)(*p).tag == (i64)108) && !!(lv))) {
        mm_support$gerror((byte*)"&docase",0);
    }
;
    mm_type$tpass(a,(i64)22,(i64)0);
    if ((a == 0)) {
        amode = (i64)22;
    }
    else {
        amode = (i64)(*a).mode;
    }
;
    if ((!!((i64)mm_decls$ttisinteger[(amode)]) && ((i64)mm_decls$ttsize[(amode)] < (i64)8))) {
        mm_type$coerceunit(a,(i64)3,(i64)0);
        amode = (i64)3;
    }
;
    u = (i64)0;
    wt = b;
    L840 :;
    while (!!(wt)) {
        w = (*wt).a;
        L843 :;
        while (!!(w)) {
            mm_type$tpass(w,(i64)22,(i64)0);
            if (((i64)(*w).tag == (i64)19)) {
                if (!(!!((i64)mm_decls$ttisinteger[(amode)]))) {
                    mm_support$txerror((byte*)"case: need int index",0);
                }
;
            }
            else {
                if ((amode == (i64)22)) {
                    if (!(!!((i64)mm_tables$isbooltag[((i64)(*w).tag)]))) {
                        mm_support$txerror((byte*)"CASE/BOOL?",0);
                        mm_lib$insertunit(w,(i64)17);
                    }
;
                }
                else {
                    mm_type$coerceunit(w,amode,(i64)0);
                }
;
            }
;
            w = (*w).nextunit;
L844 :;
        }
L845 :;
        ;
        mm_type$tpass((*wt).b,t,lv);
        if ((t != (i64)0)) {
            if (!!(u)) {
                u = mm_type$getdominantmode(u,(i64)(*(*wt).b).mode);
            }
            else {
                u = (i64)(*(*wt).b).mode;
            }
;
        }
;
        wt = (*wt).nextunit;
L841 :;
    }
L842 :;
    ;
    if (!!(c)) {
        mm_type$tpass(c,t,lv);
        if ((t == (i64)22)) {
            u = mm_type$getdominantmode(u,(i64)(*c).mode);
        }
;
    }
    else if ((t != (i64)0)) {
        mm_support$txerror((byte*)"case needs else",0);
    }
;
    if ((t != (i64)0)) {
        (*p).mode = u;
    }
    else {
        (*p).mode = (i64)0;
    }
;
}

static void mm_type$tx_notl(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
    mm_type$tpass(a,(i64)22,(i64)0);
    (*p).mode = (i64)6;
    mm_type$setsimple(p);
}

static void mm_type$tx_istruel(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 abase;
    mm_type$tpass(a,(i64)22,(i64)0);
    if (!!((i64)mm_tables$isbooltag[((i64)(*a).tag)])) {
        mm_lib$deleteunit(p,a);
        return;
    }
;
    abase = (i64)mm_decls$ttbasetype[((i64)(*a).mode)];
    if ((abase == (i64)7)) {
        abase = (i64)3;
    }
;
    (*p).mode = (i64)6;
    mm_type$setsimple(p);
}

static void mm_type$tx_typepun(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 smode;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)18)) {
        mm_support$txerror((byte*)"TYPEPUN/LIST",0);
    }
    else {
        mm_type$tpass(a,(i64)22,(i64)0);
        smode = mm_lib$getmemmode(a);
        if (((i64)mm_decls$ttsize[(smode)] < (i64)mm_decls$ttsize[((i64)(*p).convmode)])) {
            mm_support$txerror((byte*)"Typepun: sizes must match",0);
        }
;
        (*p).mode = mm_lib$gettypebase((i64)(*p).convmode);
    }
    };
}

static void mm_type$tx_exit(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
    if ((a == 0)) {
        return;
    }
;
    mm_type$tpass(a,(i64)3,(i64)0);
    if (((i64)(*a).tag != (i64)1)) {
        mm_support$txerror((byte*)"exit/etc not const",0);
    }
;
    (*p).index = (*a).value;
    (*p).a = 0;
}

static void mm_type$tx_goto(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 m;
    mm_type$tpass(a,(i64)22,(i64)0);
    m = (i64)(*a).mode;
    if ((((i64)mm_decls$ttbasetype[(m)] != (i64)7) || ((i64)mm_decls$ttbasetype[((i64)mm_decls$tttarget[(m)])] != (i64)24))) {
        mm_support$txerror((byte*)"goto: not label",0);
    }
;
}

static void mm_type$tx_switch(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 t,i64 lv) {
        byte valueset[2048];
        struct mm_decls$unitrec *  wt;
        struct mm_decls$unitrec *  w;
        i64 ax;
        i64 bx;
        i64 i;
        i64 u;
    if ((((i64)(*p).tag == (i64)110) && !!(lv))) {
        mm_support$gerror((byte*)"&doswitch",0);
    }
;
    mm_type$tpass(a,(i64)3,(i64)0);
    memset(&valueset,(i32)(i64)0,(u64)2048u);
    u = (i64)0;
    wt = b;
    L846 :;
    while (!!(wt)) {
        w = (*wt).a;
        L849 :;
        while (!!(w)) {
            mm_type$tpass(w,(i64)22,(i64)0);
            if (!(!!(mm_lib$isconstunit(w)))) {
                mm_support$txerror((byte*)"Switch not constant",0);
            }
;
                        {i64 $temp = (i64)mm_decls$ttbasetype[((i64)(*w).mode)];
if (($temp==(i64)9)) {
                ax = (*(*w).a).value;
                bx = (*(*w).b).value;
                //dorange:
L852 :;
;
                for (i=ax;i<=bx;++i) {
L853 :;
                    if (((i < (i64)0) || (i > (i64)2047))) {
                        mm_support$txerror((byte*)"switch: value out of range",0);
                    }
;
                    if (!!((i64)valueset[(i)])) {
                        msysc$m_print_startcon();
                        msysc$m_print_i64(i,NULL);
                        msysc$m_print_newline();
                        msysc$m_print_end();
                        ;
                        mm_support$txerror((byte*)"Duplicate switch value",0);
                    }
;
                    valueset[(i)] = (i64)1;
L854 :;
                }
L855 :;
                ;
            }
            else {
                mm_type$coerceunit(w,(i64)3,(i64)0);
                mm_type$tevaluate(w);
                if (((i64)(*w).tag != (i64)1)) {
                    mm_support$txerror((byte*)"Switch value: not const int",0);
                }
;
                ax = (bx = (*w).value);
                goto L852 ;
;
            }
            };
            w = (*w).nextunit;
L850 :;
        }
L851 :;
        ;
        mm_type$tpass((*wt).b,t,lv);
        if ((t == (i64)22)) {
            if (!!(u)) {
                u = mm_type$getdominantmode(u,(i64)(*(*wt).b).mode);
            }
            else {
                u = (i64)(*(*wt).b).mode;
            }
;
        }
;
        wt = (*wt).nextunit;
L847 :;
    }
L848 :;
    ;
    if (!!(c)) {
        mm_type$tpass(c,t,lv);
        if ((t == (i64)22)) {
            u = mm_type$getdominantmode(u,(i64)(*c).mode);
        }
;
    }
    else if ((t != (i64)0)) {
        mm_support$txerror((byte*)"switch needs else",0);
    }
;
    if ((t != (i64)0)) {
        w = (*b).a;
        L856 :;
        while (!!(w)) {
            if ((t == (i64)22)) {
                mm_type$coerceunit((*b).b,u,(i64)0);
            }
;
            (*w).mode = (i64)(*(*b).b).mode;
            w = (*w).nextunit;
L857 :;
        }
L858 :;
        ;
        if ((t == (i64)22)) {
            mm_type$coerceunit(c,u,(i64)0);
            (*p).mode = u;
        }
        else {
            (*p).mode = t;
        }
;
    }
    else {
        (*p).mode = (i64)0;
    }
;
}

static void mm_type$tx_addroffirst(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t) {
        i64 m;
    mm_type$tpass(a,(i64)22,(i64)0);
    m = (i64)(*a).mode;
    if (((i64)mm_decls$ttbasetype[(m)] != (i64)10)) {
        mm_support$txerror((byte*)"&. ref[] expected",0);
    }
;
    m = mm_lib$createrefmode(0,(i64)mm_decls$tttarget[(m)],(i64)0);
    if (((i64)(*a).tag == (i64)4)) {
        (*a).addroffirst = (i64)1;
    }
;
    (*p).mode = m;
}

static void mm_type$tx_return(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 t) {
        i64 m;
        i64 nret;
        i64 i;
        i32 (*pmult)[];
        struct mm_decls$unitrec *  q;
    m = (i64)(*mm_decls$currproc).mode;
    nret = (i64)(*mm_decls$currproc).nretvalues;
    pmult = mm_decls$ttmult[((i64)(*mm_decls$currproc).mode)];
    if ((a == 0)) {
        if (!!(nret)) {
            mm_support$txerror((byte*)"return value(s) missing",0);
        }
;
        return;
    }
    else if ((nret == (i64)0)) {
        mm_support$txerror((byte*)"Superfluous return value",0);
    }
;
    if (((i64)(*a).tag == (i64)18)) {
        (*a).tag = (i64)23;
        if (((i64)(*a).length != nret)) {
                        {i64 $temp = (i64)mm_decls$ttbasetype[(m)];
if (($temp==(i64)8) || ($temp==(i64)10)) {
                mm_support$txerror((byte*)"return constructor not supported",0);
            }
            else {
                mm_support$txerror((byte*)"Wrong number of return values",0);
            }
            };
        }
;
        q = (*a).a;
        for (i=(i64)1;i<=nret;++i) {
L859 :;
            mm_type$tpass(q,(i64)(*pmult)[(i)-1],(i64)0);
            q = (*q).nextunit;
L860 :;
        }
L861 :;
        ;
        mm_lib$deleteunit(p,a);
        (*p).resultflag = (i64)1;
        if ((t == (i64)0)) {
            (*p).mode = (i64)0;
        }
        else {
            (*p).mode = (i64)27;
        }
;
    }
    else {
        if ((nret > (i64)1)) {
            mm_support$txerror((byte*)"RETERROR?",0);
        }
;
        mm_type$tpass(a,m,(i64)0);
        if ((t == (i64)0)) {
            (*p).mode = (i64)0;
        }
        else {
            mm_lib$deleteunit(p,a);
        }
;
    }
;
    if (!!((i64)mm_decls$ttisshort[((i64)(*p).mode)])) {
        mm_support$txerror((byte*)"SHORT RET TYPE",0);
    }
;
}

static void mm_type$tx_dotindex(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 lv) {
        i64 pmode;
        struct mm_decls$unitrec *  i;
        struct mm_decls$unitrec *  j;
    mm_type$tpass(a,(i64)22,lv);
    pmode = (i64)2;
    if (!(!!((i64)mm_decls$ttisinteger[((i64)(*a).mode)]))) {
        mm_support$txerror((byte*)"a.[i]: not int/str value",0);
    }
;
    mm_type$tpass(b,(i64)22,(i64)0);
        {i64 $temp = (i64)mm_decls$ttbasetype[((i64)(*b).mode)];
if (($temp==(i64)9)) {
        i = (*b).a;
        j = (*b).b;
        if (((i64)(*i).tag==(i64)(*j).tag && (i64)(*j).tag==(i64)1)) {
            if (((*i).value > (*j).value)) {
                {struct mm_decls$unitrec *  temp = (*b).a; (*b).a = (*b).b; (*b).b = temp; };
            }
;
        }
;
    }
    else {
        mm_type$coerceunit(b,(i64)3,(i64)0);
    }
    };
    (*p).mode = pmode;
    mm_type$setsimple(p);
}

static void mm_type$tx_slice(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
    mm_type$tpass(a,(i64)22,(i64)0);
    mm_type$tpass(b,(i64)22,(i64)0);
    mm_type$setsimple(a);
    if (((i64)(*a).mode == (i64)20)) {
        (*p).mode = mm_lib$createslicemodek(mm_decls$currproc,(i64)12,(i64)1,(i64)0);
    }
    else {
        mm_type$deref(a,(i64)1);
                {i64 $temp = (i64)mm_decls$ttbasetype[((i64)(*a).mode)];
if (($temp==(i64)10)) {
            (*p).mode = mm_lib$createslicemodek(mm_decls$currproc,(i64)mm_decls$tttarget[((i64)(*a).mode)],(i64)1,(i64)0);
        }
        else if (($temp==(i64)11)) {
            (*p).mode = (i64)(*a).mode;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"STRMODE(A.MODE)=",NULL);
            msysc$m_print_str(mm_lib$strmode((i64)(*a).mode,(i64)1),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$txerror((byte*)"a[i..j]: not array",0);
        }
        };
    }
;
}

static void mm_type$twiden(struct mm_decls$unitrec *p,i64 lv) {
        i64 m;
        i64 mbase;
    mbase = (i64)mm_decls$ttbasetype[((m = (i64)(*p).mode))];
    if ((mbase == (i64)0)) {
        return;
    }
;
    if (!!(lv)) {
        return;
    }
;
    if (!(!!((i64)mm_decls$ttisshort[(mbase)]))) {
        return;
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)4) || ($temp==(i64)49) || ($temp==(i64)44) || ($temp==(i64)46)) {
        (*p).memmode = m;
        (*p).mode = mm_lib$gettypebase(m);
    }
    else if (($temp==(i64)90) || ($temp==(i64)31)) {
        (*p).memmode = m;
        (*p).mode = mm_lib$gettypebase(m);
    }
    else {
        mm_diags$printunit((struct mm_decls$unitrec *)p,(i64)0,(byte*)"*",0);
        mm_support$txerror_s((byte*)"widen? #",mm_tables$jtagnames[((i64)(*p).tag)],0);
    }
    };
}

static void mm_type$tstringslice(struct mm_decls$unitrec *p,i64 slicemode) {
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
        struct mm_decls$unitrec *  prange;
    if (((i64)mm_decls$tttarget[(slicemode)] != (i64)12)) {
        mm_support$txerror((byte*)"Not char slice",0);
    }
;
    a = p;
    mm_lib$insertunit(p,(i64)45);
    if (((i64)(*(*p).a).tag == (i64)1)) {
    }
    else {
        b = mm_lib$duplunit((*p).a,(i64)0);
        mm_lib$insertunit(b,(i64)35);
        prange = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)19,(struct mm_decls$unitrec *)mm_lib$createconstunit((u64)1u,(i64)3),(struct mm_decls$unitrec *)b);
        (*prange).mode = (i64)9;
        (*p).b = prange;
    }
;
    (*p).mode = slicemode;
}

static void mm_type$tx_bitfield(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,i64 lv) {
        i64 i;
        i64 j;
        i64 bitsize;
        i64 topbit;
        struct mm_decls$unitrec *  r;
    mm_type$tpass(a,(i64)22,lv);
    if ((!(!!((i64)mm_decls$ttisinteger[((i64)(*a).mode)])) && !(!!((i64)mm_decls$ttisref[((i64)(*a).mode)])))) {
        mm_support$txerror((byte*)"Int/ref needed",0);
    }
;
    bitsize = ((i64)mm_decls$ttsize[((i64)mm_decls$ttbasetype[((i64)(*a).mode)])] * (i64)8);
    topbit = (bitsize - (i64)1);
        {i64 $temp = (i64)(*p).bfcode;
if (($temp==(i64)2)) {
        i = (i64)0;
        j = (i64)7;
    }
    else if (($temp==(i64)1)) {
        j = topbit;
        i = (topbit - (i64)7);
    }
    else if (($temp==(i64)4)) {
        i = (j = (i64)0);
    }
    else if (($temp==(i64)7) || ($temp==(i64)8)) {
        if (!!(lv)) {
            mm_support$txerror((byte*)"Can't assign",0);
        }
;
        i = (j = (i64)0);
    }
    else if (($temp==(i64)3)) {
        i = (j = topbit);
    }
    else if (($temp==(i64)6)) {
        i = (i64)0;
        j = ((bitsize / (i64)2) - (i64)1);
    }
    else if (($temp==(i64)5)) {
        i = (bitsize / (i64)2);
        j = topbit;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_i64((i64)(*p).bfcode,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$txerror((byte*)"BITFIELD",0);
    }
    };
    if ((i == j)) {
        (*p).tag = (i64)47;
        (*p).b = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)i,(i64)3);
        (*p).resultflag = (i64)1;
        (*(*p).b).resultflag = (i64)1;
        if (((i64)(*p).bitopindex == (i64)8)) {
            (*p).mode = (i64)2;
            mm_type$addnotl(p);
        }
;
    }
    else {
        r = (struct mm_decls$unitrec *)mm_lib$createunit2((i64)19,(struct mm_decls$unitrec *)mm_lib$createconstunit((u64)i,(i64)3),(struct mm_decls$unitrec *)mm_lib$createconstunit((u64)j,(i64)3));
        (*(*r).a).resultflag = (i64)1;
        (*(*r).b).resultflag = (i64)1;
        (*r).mode = (i64)9;
        (*p).tag = (i64)48;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"HERE",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        (*p).b = r;
    }
;
    (*p).mode = (i64)2;
}

static void mm_type$deref(struct mm_decls$unitrec *a,i64 needres) {
        i64 abasemode;
        i64 tmode;
    abasemode = (i64)mm_decls$ttbasetype[((i64)(*a).mode)];
    L862 :;
    while ((abasemode == (i64)7)) {
        tmode = (i64)mm_decls$tttarget[((i64)(*a).mode)];
        mm_lib$insertunit(a,(i64)49);
        mm_type$setsimple(a);
        (*a).mode = tmode;
        abasemode = (i64)mm_decls$ttbasetype[((i64)(*a).mode)];
L863 :;
    }
L864 :;
    ;
}

static void mm_type$tmethodcall(struct mm_decls$unitrec *p,struct mm_decls$unitrec *pdot,struct mm_decls$unitrec *pargs) {
        i64 mrec;
        struct mm_decls$unitrec *  prec;
        struct mm_decls$unitrec *  pfield;
        struct mm_decls$unitrec *  pfunc;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
    prec = (*pdot).a;
    pfield = (*pdot).b;
    mrec = (i64)(*prec).mode;
    d = (*pfield).def;
    e = mm_type$resolvefield(d,mrec);
    if ((e == 0)) {
        mm_support$txerror_s((byte*)"Can't resolve method:",(*d).name,0);
    }
;
    pfunc = (struct mm_decls$unitrec *)mm_lib$createname(e);
    (*pfunc).mode = (i64)(*e).mode;
    (*prec).nextunit = pargs;
    (*p).a = pfunc;
    (*p).b = prec;
}

static void mm_type$do_bounds(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 m;
        i64 mbase;
    mm_type$deref(a,(i64)1);
    m = (i64)(*a).mode;
    if (((i64)(*a).tag == (i64)56)) {
        m = (*a).value;
    }
;
    mbase = (i64)mm_decls$ttbasetype[(m)];
    (*p).mode = (i64)3;
        {i64 $temp = (i64)(*p).pclop;
if (($temp==(i64)89)) {
        if ((mbase==(i64)10) || (mbase==(i64)11)) {
            mm_type$convintconst(p,(i64)mm_decls$ttlower[(m)]);
            return;
        }
        else {
            //error:
L865 :;
;
            mm_support$txerror_s((byte*)"lwb/upb/len?",mm_lib$strmode(m,(i64)1),0);
        }
;
    }
    else if (($temp==(i64)90)) {
        if ((mbase==(i64)10)) {
            mm_type$convintconst(p,(((i64)mm_decls$ttlower[(m)] + (i64)mm_decls$ttlength[(m)]) - (i64)1));
        }
        else if ((mbase==(i64)11)) {
            (*p).pclop = (i64)90;
        }
        else {
            goto L865 ;
;
        }
;
    }
    else if (($temp==(i64)88)) {
        if ((mbase==(i64)10)) {
            mm_type$convintconst(p,(i64)mm_decls$ttlength[(m)]);
        }
        else if ((mbase==(i64)11)) {
            (*p).pclop = (i64)88;
        }
        else {
            goto L865 ;
;
        }
;
    }
    else if (($temp==(i64)91)) {
        (*p).mode = (i64)9;
        if ((mbase==(i64)10)) {
            (*p).range_lower = (i64)mm_decls$ttlower[(m)];
            (*p).range_upper = (((*p).range_lower + (i64)mm_decls$ttlength[(m)]) - (i64)1);
            (*p).tag = (i64)1;
            (*p).a = ((*p).b = ((*p).c = 0));
            (*p).isconst = (i64)1;
            return;
        }
        else if ((mbase==(i64)11)) {
        }
        else {
            goto L865 ;
;
        }
;
    }
    };
}

static void mm_type$addnotl(struct mm_decls$unitrec *p) {
    mm_lib$insertunit(p,(i64)16);
    (*p).mode = (i64)6;
    (*p).pclop = (i64)32;
}

static void mm_type$tevaluate(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
        i64 tag;
    tag = (i64)(*p).tag;
    if (((i64)mm_tables$jisexpr[(tag)] == (i64)2)) {
        mm_type$tevalbinop(p);
        mm_type$setsimple(p);
    }
    else if (((i64)mm_tables$jisexpr[(tag)] == (i64)1)) {
        mm_type$tevalmonop(p);
        if ((((i64)(*p).tag == (i64)35) && !(!!((i64)mm_tables$complexopset[((i64)(*p).pclop)])))) {
            mm_type$setsimple(p);
        }
;
    }
    else {
        if ((tag==(i64)19)) {
            a = (*p).a;
            b = (*p).b;
            if (((i64)mm_decls$ttsize[((i64)(*a).mode)] <= (i64)8)) {
                mm_type$tevaluate(a);
                mm_type$tevaluate(b);
                if ((((i64)(*a).tag == (i64)1) && ((i64)(*b).tag == (i64)1))) {
                    (*p).isconst = ((i64)(*a).isconst & (i64)(*b).isconst);
                }
;
            }
;
        }
;
    }
;
}

static struct mm_decls$unitrec *mm_type$addrdotindex(struct mm_decls$unitrec *p,i64 *offset) {
        struct mm_decls$unitrec *  q;
        i64 axmode;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"ADDRDOTIX",NULL);
    msysc$m_print_str(mm_lib$strmode((i64)(*p).mode,(i64)1),NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)46)) {
        if (((i64)(*(*p).a).tag == (i64)4)) {
            (*offset) = (i64)(*p).offset;
            return (*p).a;
        }
        else {
            q = mm_type$addrdotindex((*p).a,offset);
            (*offset) += (i64)(*p).offset;
            return q;
        }
;
    }
    else if (($temp==(i64)44)) {
        axmode = (i64)(*(*p).a).mode;
        if (((i64)(*(*p).b).tag == (i64)1)) {
            if (((i64)(*(*p).a).tag == (i64)4)) {
                (*offset) = (((*(*p).b).value - (i64)mm_decls$ttlower[(axmode)]) * (i64)mm_decls$ttsize[((i64)mm_decls$tttarget[(axmode)])]);
                return (*p).a;
            }
            else {
                q = mm_type$addrdotindex((*p).a,offset);
                if (!!(q)) {
                    (*offset) += (((*(*p).b).value - (i64)mm_decls$ttlower[(axmode)]) * (i64)mm_decls$ttsize[((i64)mm_decls$tttarget[(axmode)])]);
                }
;
                return q;
            }
;
        }
        else {
            return 0;
        }
;
    }
    else {
        return 0;
    }
    };
}

static void mm_type$tevalbinop(struct mm_decls$unitrec *p) {
        i64 a;
        i64 b;
        i64 c;
        i64 offset;
        r64 x;
        r64 y;
        r64 z;
        struct mm_decls$unitrec *  lhs;
        struct mm_decls$unitrec *  rhs;
    lhs = (*p).a;
    rhs = (*p).b;
    if (!(((i64)(*lhs).tag==(i64)(*rhs).tag && (i64)(*rhs).tag==(i64)1))) {
        if ((((i64)(*lhs).tag == (i64)50) && ((i64)(*rhs).tag == (i64)1))) {
            if (((i64)(*(*lhs).a).tag == (i64)4)) {
                offset = ((*rhs).value * (i64)mm_decls$ttsize[((i64)mm_decls$tttarget[((i64)(*lhs).mode)])]);
                if (((*lhs).b == 0)) {
                    (*lhs).b = (struct mm_decls$unitrec *)mm_lib$createconstunit((u64)offset,(i64)3);
                }
                else {
                    (*(*lhs).b).value += offset;
                }
;
                mm_lib$deleteunit(p,lhs);
            }
;
        }
;
        return;
    }
;
    if (!!((i64)mm_decls$ttisreal[((i64)(*p).mode)])) {
        x = (*(*p).a).xvalue;
        y = (*(*p).b).xvalue;
    }
    else {
        a = (*(*p).a).value;
        b = (*(*p).b).value;
    }
;
        {i64 $temp = (i64)(*p).mode;
if (($temp==(i64)3) || ($temp==(i64)2)) {
        switch ((i64)(*p).pclop) {
        case 1:;
            {
                c = (a + b);
            }
            break;
        case 2:;
            {
                c = (a - b);
            }
            break;
        case 3:;
            {
                c = (a * b);
            }
            break;
        case 5:;
            {
                c = (a / b);
            }
            break;
        case 6:;
            {
                c = (a % b);
            }
            break;
        case 11:;
            {
                c = (a << b);
            }
            break;
        case 17:;
            {
                c = (i64)(a == b);
            }
            break;
        case 18:;
            {
                c = (i64)(a != b);
            }
            break;
        case 19:;
            {
                c = (i64)(a < b);
            }
            break;
        case 20:;
            {
                c = (i64)(a <= b);
            }
            break;
        case 21:;
            {
                c = (i64)(a >= b);
            }
            break;
        case 22:;
            {
                c = (i64)(a > b);
            }
            break;
        case 24:;
            {
                c = (i64)(!!(a) && !!(b));
            }
            break;
        case 25:;
            {
                c = (i64)(!!(a) || !!(b));
            }
            break;
        case 8:;
            {
                c = (a & b);
            }
            break;
        case 9:;
            {
                c = (a | b);
            }
            break;
        default: {
            return;
        }
        } //SW
;
    }
    else if (($temp==(i64)5) || ($temp==(i64)4)) {
        switch ((i64)(*p).pclop) {
        case 1:;
            {
                z = (x + y);
            }
            break;
        case 2:;
            {
                z = (x - y);
            }
            break;
        case 3:;
            {
                z = (x * y);
            }
            break;
        case 4:;
            {
                z = (x / y);
            }
            break;
        default: {
            return;
        }
        } //SW
;
    }
    else {
        return;
    }
    };
    if (!!((i64)mm_decls$ttisreal[((i64)(*p).mode)])) {
        mm_type$makenewconst(p,*(i64*)&z,(i64)0);
    }
    else {
        mm_type$makenewconst(p,c,(i64)0);
    }
;
}

static void mm_type$tevalmonop(struct mm_decls$unitrec *p) {
        i64 a;
        i64 c;
        r64 x;
        r64 z;
    if (((i64)(*p).tag == (i64)33)) {
        return;
    }
;
    if (!(((i64)(*(*p).a).tag == (i64)1))) {
        return;
    }
;
    a = (*(*p).a).value;
    x = (*(*p).a).xvalue;
        {i64 $temp = (i64)(*p).mode;
if (($temp==(i64)3) || ($temp==(i64)2)) {
        switch ((i64)(*p).pclop) {
        case 29:;
            {
                c = -(a);
            }
            break;
        case 33:;
            {
                c = (i64)!!(a);
                (*p).mode = (i64)6;
            }
            break;
        case 32:;
            {
                c = (i64)!(!!(a));
                (*p).mode = (i64)6;
            }
            break;
        case 31:;
            {
                c = ~(a);
            }
            break;
        case 30:;
            {
                c = m$llabs(a);
            }
            break;
        default: {
            return;
        }
        } //SW
;
    }
    else if (($temp==(i64)5) || ($temp==(i64)4)) {
        switch ((i64)(*p).pclop) {
        case 29:;
            {
                z = -(x);
            }
            break;
        case 41:;
            {
                z = atan(x);
            }
            break;
        case 35:;
            {
                z = sqrt(x);
            }
            break;
        default: {
            return;
        }
        } //SW
;
    }
    else if (($temp==(i64)6)) {
                {i64 $temp = (i64)(*p).pclop;
if (($temp==(i64)33)) {
            c = (i64)!!(a);
            (*p).mode = (i64)6;
        }
        else if (($temp==(i64)32)) {
            c = (i64)!(!!(a));
            (*p).mode = (i64)6;
        }
        };
    }
    else {
        return;
    }
    };
    if (!!((i64)mm_decls$ttisreal[((i64)(*p).mode)])) {
        mm_type$makenewconst(p,*(i64*)&z,(i64)0);
    }
    else {
        mm_type$makenewconst(p,c,(i64)0);
    }
;
}

static i64 mm_type$iscondtrue(struct mm_decls$unitrec *p) {
    return (i64)(((i64)(*p).tag == (i64)1) && ((*p).value != (i64)0));
}

static i64 mm_type$iscondfalse(struct mm_decls$unitrec *p) {
    return (i64)(((i64)(*p).tag == (i64)1) && ((*p).value == (i64)0));
}

static void mm_type$fixchararray(struct mm_decls$unitrec *a) {
    if (((!!(a) && ((i64)mm_decls$ttbasetype[((i64)(*a).mode)] == (i64)10)) && ((i64)mm_decls$tttarget[((i64)(*a).mode)] == (i64)12))) {
        mm_type$coerceunit(a,(i64)20,(i64)0);
    }
;
}

static void mm_type$combinestrings(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  b;
        i64 alen;
        i64 blen;
        i64 clen;
        u8 *  s;
    a = (*p).a;
    b = (*p).b;
    alen = (i64)(*a).length;
    blen = (i64)(*b).length;
    clen = (alen + blen);
    if ((blen == (i64)0)) {
        mm_lib$deleteunit(p,a);
        return;
    }
    else if ((alen == (i64)0)) {
        mm_lib$deleteunit(p,b);
        return;
    }
;
    s = (u8 *)mlib$pcm_alloc((clen + (i64)1));
    memcpy((void *)s,(void *)(*a).svalue,(u64)alen);
    memcpy((void *)(s + alen),(void *)(*b).svalue,(u64)blen);
    (*(s + clen)) = (u64)0u;
    mm_lib$deleteunit(p,a);
    (*p).length = clen;
    (*p).svalue = s;
}

static void mm_type$tx_strinclude(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a) {
        i64 fileno;
    mm_type$tpass(a,(i64)22,(i64)0);
    if ((((i64)(*a).tag != (i64)1) || !(!!((i64)(*a).isastring)))) {
        mm_support$txerror((byte*)"strincl/not string",0);
    }
;
    fileno = (i64)mm_decls$moduletable[((i64)(*p).moduleno)].fileno;
    fileno = mm_support$getsupportfile((*a).svalue,(byte*)"",mm_decls$sourcefilepaths[(fileno)],(i64)0,(i64)1);
    (*a).svalue = mm_decls$sourcefiletext[(fileno)];
    (*a).slength = mm_decls$sourcefilesizes[(fileno)];
    mm_lib$deleteunit(p,a);
}

static void mm_type$coerceunit(struct mm_decls$unitrec *p,i64 t,i64 hard) {
        i64 opc;
        i64 s;
    s = (i64)(*p).mode;
    if (((t == (i64)0) || (s == t))) {
        return;
    }
;
    if ((s == (i64)0)) {
        mm_support$txerror((byte*)"Void expression/return value missing",0);
    }
;
    opc = mm_type$getconversionop(s,t,hard);
    mm_type$applyconversion(p,s,t,opc);
    mm_type$setsimple(p);
}

static i64 mm_type$getconversionop(i64 s,i64 t,i64 hard) {
        i64 opc;
        i64 sbase;
        i64 tbase;
        i64 starg;
        i64 ttarg;
    sbase = (i64)mm_decls$ttbasetype[(s)];
    tbase = (i64)mm_decls$ttbasetype[(t)];
    if ((s == t)) {
        return (i64)0;
    }
;
    opc = (i64)98;
    starg = (i64)mm_decls$tttarget[(s)];
    ttarg = (i64)mm_decls$tttarget[(t)];
    if ((s == (i64)20)) {
        sbase = (i64)20;
    }
;
    if ((t == (i64)20)) {
        tbase = (i64)20;
    }
;
    switch (sbase) {
    case 1:;
    case 2:;
    case 3:;
    case 4:;
    case 5:;
        {
            switch (tbase) {
            case 1:;
            case 2:;
            case 3:;
            case 4:;
            case 5:;
                {
                    opc = (i64)mm_tables$softconvtable[(sbase)-1][(tbase)-1];
                }
                break;
            case 7:;
            case 20:;
                {
                    opc = (i64)82;
                    //checkhard:
L866 :;
;
                    if (!(!!(hard))) {
                        opc = (i64)99;
                    }
;
                }
                break;
            case 12:;
            case 13:;
            case 14:;
            case 15:;
            case 16:;
            case 17:;
            case 18:;
            case 19:;
                {
                    if (!!((i64)mm_decls$ttisinteger[(sbase)])) {
                        if (!(!!(hard))) {
                            opc = (i64)102;
                        }
                        else {
                            opc = (i64)85;
                        }
;
                    }
;
                }
                break;
            case 6:;
                {
                    opc = (i64)33;
                }
                break;
            case 25:;
                {
                    opc = (i64)82;
                }
                break;
            } //SW
;
        }
        break;
    case 6:;
        {
            if ((tbase == (i64)3 || tbase == (i64)2)) {
                opc = (i64)82;
            }
;
        }
        break;
    case 7:;
        {
            if ((tbase==(i64)3) || (tbase==(i64)2)) {
                opc = (i64)82;
                goto L866 ;
;
            }
            else if ((tbase==(i64)7)) {
                if (((starg == (i64)0) || (ttarg == (i64)0))) {
                    if (((u64)0u && (ttarg == (i64)0))) {
                        return (i64)0;
                    }
;
                    opc = (i64)82;
                }
                else {
                    //checkref:
L867 :;
;
                    opc = (i64)82;
                    if (!(!!(mm_type$comparemodes(s,t)))) {
                        goto L866 ;
;
                    }
;
                }
;
            }
            else if ((tbase==(i64)20)) {
                goto L867 ;
;
            }
            else if ((tbase==(i64)6)) {
                opc = (i64)33;
            }
;
        }
        break;
    case 20:;
        {
            if ((tbase==(i64)3) || (tbase==(i64)2)) {
                opc = (i64)82;
                goto L866 ;
;
            }
            else if ((tbase==(i64)7)) {
                if ((!!(mm_type$comparemodes(s,t)) || !!(hard))) {
                    opc = (i64)82;
                }
                else {
                    opc = (i64)99;
                }
;
            }
            else if ((tbase==(i64)6)) {
                opc = (i64)33;
            }
            else if ((tbase==(i64)11)) {
                if (!((ttarg == (i64)12 || ttarg == (i64)17))) {
                    opc = (i64)101;
                }
;
            }
;
        }
        break;
    case 10:;
        {
            if ((tbase==(i64)10)) {
                if (!!(mm_type$comparemodes(s,t))) {
                    opc = (i64)82;
                }
;
            }
            else if ((tbase==(i64)11)) {
                if (!!(mm_type$comparemodes(starg,ttarg))) {
                    opc = (i64)100;
                }
;
            }
            else if ((tbase==(i64)20)) {
                if ((starg == (i64)12 || starg == (i64)17)) {
                    opc = (i64)103;
                }
;
            }
;
        }
        break;
    case 11:;
        {
            if ((tbase==(i64)11)) {
                if (!!(mm_type$comparemodes(s,t))) {
                    opc = (i64)82;
                }
;
            }
            else if ((tbase==(i64)7)) {
                if (((ttarg == (i64)0) || !!(mm_type$comparemodes(starg,ttarg)))) {
                    opc = (i64)104;
                }
;
            }
;
        }
        break;
    case 25:;
        {
            if ((tbase <= (i64)5)) {
                opc = (i64)82;
            }
;
        }
        break;
    default: {
        return (i64)98;
    }
    } //SW
;
    return opc;
}

static void mm_type$applyconversion(struct mm_decls$unitrec *p,i64 s,i64 t,i64 opc) {
        struct mm_decls$unitrec *  q;
    if ((opc==(i64)0)) {
        return;
    }
    else if ((opc==(i64)98)) {
        mm_support$txerror_ss((byte*)"Can't do conversion: # => #",mm_lib$strmode(s,(i64)1),mm_lib$strmode2(t,(i64)1));
    }
    else if ((opc==(i64)99)) {
        mm_support$txerror_ss((byte*)"Need explicit cast: # => #",mm_lib$strmode(s,(i64)1),mm_lib$strmode2(t,(i64)1));
    }
    else if ((opc==(i64)82)) {
        if ((u64)1u) {
            (*p).mode = t;
            return;
        }
;
    }
    else if ((opc==(i64)102)) {
        if (!!(mm_type$tevalconvert(p,s,t,opc))) {
            return;
        }
;
        mm_lib$insertunit(p,(i64)53);
        (*p).mode = t;
        return;
    }
    else if ((opc==(i64)100)) {
        mm_lib$insertunit(p,(i64)45);
        (*p).mode = t;
        return;
    }
    else if ((opc==(i64)101)) {
        mm_type$tstringslice(p,t);
        return;
    }
    else if ((opc==(i64)103)) {
        mm_lib$insertunit(p,(i64)51);
        (*p).mode = (i64)20;
        return;
    }
;
    if (!!(mm_type$tevalconvert(p,s,t,opc))) {
        return;
    }
;
    if (((u64)0u && ((i64)(*p).tag == (i64)6))) {
        (*p).mode = t;
        q = (*p).a;
        L868 :;
        while (!!((*q).nextunit)) {
            q = (*q).nextunit;
L869 :;
        }
L870 :;
        ;
        p = q;
        goto L871 ;
;
    }
    else {
        //dorest:
L871 :;
;
        mm_lib$insertunit(p,(i64)52);
        (*p).pclop = opc;
        (*p).convmode = s;
        (*p).resultflag = (i64)1;
        if (!!((i64)mm_decls$ttisshort[(t)])) {
            (*p).convmode = t;
            t = mm_lib$gettypebase(t);
        }
;
        (*p).mode = t;
    }
;
}

static void mm_type$checkmodes(i64 s,i64 t) {
    if (!(!!(mm_type$comparemodes(s,t)))) {
        mm_support$txerror_ss((byte*)"Type-compare error: # <-> #",mm_lib$strmode(s,(i64)1),mm_lib$strmode2(t,(i64)1));
    }
;
}

static i64 mm_type$comparemodes(i64 s,i64 t) {
        i64 sbase;
        i64 tbase;
        i64 starg;
        i64 ttarg;
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
    if ((s == t)) {
        return (i64)1;
    }
;
    sbase = (i64)mm_decls$ttbasetype[(s)];
    tbase = (i64)mm_decls$ttbasetype[(t)];
    starg = (i64)mm_decls$tttarget[(s)];
    ttarg = (i64)mm_decls$tttarget[(t)];
    if ((sbase == tbase)) {
        if ((sbase==(i64)7)) {
            if (((starg == (i64)0) || (ttarg == (i64)0))) {
                return (i64)1;
            }
;
            return mm_type$comparemodes(starg,ttarg);
        }
        else if ((sbase==(i64)10)) {
            if (!(!!(mm_type$comparemodes(starg,ttarg)))) {
                return (i64)0;
            }
;
            if (((((i64)mm_decls$ttlength[(s)] == (i64)mm_decls$ttlength[(t)]) || ((i64)mm_decls$ttlength[(s)] == (i64)0)) || ((i64)mm_decls$ttlength[(t)] == (i64)0))) {
                return (i64)1;
            }
;
        }
        else if ((sbase==(i64)11)) {
            return mm_type$comparemodes(starg,ttarg);
        }
        else if ((sbase==(i64)23)) {
            d = mm_decls$ttnamedef[(s)];
            e = mm_decls$ttnamedef[(t)];
            if ((!!(d) && !!(e))) {
                if (!(!!(mm_type$comparemodes((i64)(*d).mode,(i64)(*e).mode)))) {
                    return (i64)0;
                }
;
                if ((((*d).paramlist == 0) && ((*e).paramlist == 0))) {
                    return (i64)1;
                }
;
            }
;
        }
;
    }
    else if ((((sbase == (i64)12) && (tbase == (i64)17)) || ((sbase == (i64)17) && (tbase == (i64)12)))) {
        return (i64)1;
    }
    else {
    }
;
    return (i64)0;
}

static i64 mm_type$tevalconvert(struct mm_decls$unitrec *p,i64 s,i64 t,i64 opc) {
        r64 x;
        r64 z;
        i64 a;
        i64 c;
        i64 sbase;
        i64 tbase;
    if (((i64)(*p).tag != (i64)1)) {
        mm_type$setsimple(p);
        return (i64)0;
    }
;
    a = (*p).value;
    x = (*p).xvalue;
        {i64 $temp = ((s << (i64)16) | t);
if (($temp==(i64)196613) || ($temp==(i64)196612)) {
        z = (r64)a;
    }
    else if (($temp==(i64)327683)) {
        c = (i64)x;
    }
    else if (($temp==(i64)327684)) {
        z = (r64)(r32)x;
    }
    else if (($temp==(i64)196625)) {
        c = (i64)(byte)a;
    }
    else if (($temp==(i64)196623)) {
        c = (i64)(i16)a;
    }
    else {
        if (((!!((i64)mm_decls$ttisinteger[(s)]) && !!((i64)mm_decls$ttisinteger[(t)])) && ((i64)mm_decls$ttsize[(s)] == (i64)mm_decls$ttsize[(t)]))) {
            c = a;
        }
        else {
            sbase = (i64)mm_decls$ttbasetype[(s)];
            tbase = (i64)mm_decls$ttbasetype[(t)];
            if ((sbase == tbase)) {
                return (i64)1;
            }
;
            return (i64)0;
        }
;
    }
    };
    if (!!((i64)mm_decls$ttisreal[(t)])) {
        mm_type$makenewconst(p,*(i64*)&z,t);
    }
    else {
        mm_type$makenewconst(p,c,t);
    }
;
    return (i64)1;
}

static void mm_type$tx_assign(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 t) {
        i64 m;
        i64 mm;
        i64 needres;
        struct mm_decls$strec *  d;
    needres = (i64)(t != (i64)0);
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)18)) {
        if (((i64)(*b).tag == (i64)18)) {
            if (!!(needres)) {
                mm_support$txerror((byte*)"Mult assign has no result",0);
            }
;
            mm_type$tx_assignmultmult(p,a,b);
        }
        else {
            mm_type$tx_assignmultscalar(p,a,b,t);
        }
;
        return;
    }
    else if (($temp==(i64)47) || ($temp==(i64)48)) {
        mm_type$tx_dotindex(a,(*a).a,(*a).b,(i64)1);
        mm_type$tpass(b,(i64)(*a).mode,(i64)0);
        (*p).mode = (i64)3;
        return;
    }
    };
    if (((((i64)(*a).tag == (i64)4) && !!(msysc$m_getdotindex((i64)(*(*a).def).flags,(i64)4))) && !!((i64)(*p).initlet))) {
        mm_type$tpass(a,(i64)22,(i64)0);
    }
    else {
        mm_type$tpasslv(a,(i64)22);
    }
;
    m = (i64)(*a).mode;
    (*a).resultflag = needres;
    if ((((i64)mm_decls$ttbasetype[(m)] == (i64)11) && ((i64)(*b).tag == (i64)20 || (i64)(*b).tag == (i64)18))) {
        mm_type$tx_makeslice(b,(*b).a,m);
        (*p).mode = m;
    }
    else if ((!!((i64)mm_decls$ttisshort[(m)]) && !!(needres))) {
        (*p).memmode = m;
        (*p).mode = mm_lib$gettypebase(m);
        mm_type$tpass(b,(i64)(*p).mode,(i64)0);
    }
    else {
        if (((i64)(*b).pclop == (i64)5 || (i64)(*b).pclop == (i64)6)) {
            mm_type$tpass(b,(i64)22,(i64)0);
        }
        else if (((i64)(*b).tag == (i64)120)) {
            mm_type$tpass(b,m,(i64)0);
        }
        else {
            mm = m;
            if (!!((i64)mm_decls$ttisshort[(m)])) {
                mm = mm_lib$gettypebase(m);
            }
;
                        {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)54)) {
                mm_type$tpass(b,mm,(i64)0);
            }
            else if (($temp==(i64)18)) {
                mm_type$tpass(b,m,(i64)0);
            }
            else {
                mm_type$tpass(b,(i64)22,(i64)0);
            }
            };
            if (((i64)mm_decls$ttbasetype[((i64)(*b).mode)] == (i64)27)) {
                d = mm_lib$getprocretmodes(b);
                mm_type$coerceunit(a,(i64)(*mm_decls$ttmult[((i64)(*d).mode)])[((i64)1)-1],(i64)0);
                (*p).mode = (i64)(*a).mode;
            }
            else {
                mm_type$coerceunit(b,mm,(i64)0);
                (*p).mode = mm;
            }
;
        }
;
    }
;
    mm_type$setsimple(p);
}

static void mm_type$tx_assignmultmult(struct mm_decls$unitrec *pp,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  lhs;
        struct mm_decls$unitrec *  rhs;
    (*pp).tag = (i64)27;
    if (((i64)(*a).length != (i64)(*b).length)) {
        mm_support$txerror((byte*)"Mult assign: count mismatch",0);
    }
;
    if (((i64)(*a).length == (i64)0)) {
        mm_support$txerror((byte*)"Invalid assignment",0);
    }
;
    rhs = (*b).a;
    lhs = (*a).a;
    p = lhs;
    L872 :;
    while (!!(p)) {
        mm_type$tpasslv(p,(i64)22);
L873 :;
        p = (*p).nextunit;
L875 :;
            }
L874 :;
    ;
    p = lhs;
    q = rhs;
    L876 :;
    while (!!(q)) {
        mm_type$tpass(q,(i64)(*p).mode,(i64)0);
L877 :;
        {
            p = (*p).nextunit;
            q = (*q).nextunit;
        }
L879 :;
            }
L878 :;
    ;
}

static void mm_type$tx_assignmultscalar(struct mm_decls$unitrec *pp,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,i64 t) {
        struct mm_decls$unitrec *  p;
        struct mm_decls$unitrec *  alist;
        i64 nretmodes;
        i64 i;
        i64 alength;
        i32 (*pmult)[];
        struct mm_decls$strec *  d;
    alist = (*a).a;
    alength = (i64)(*a).length;
    nretmodes = (i64)0;
    (*pp).tag = (i64)28;
    mm_type$tpass(b,(i64)22,(i64)0);
        {i64 $temp = (i64)mm_decls$ttbasetype[((i64)(*b).mode)];
if (($temp==(i64)27)) {
        d = mm_lib$getprocretmodes(b);
        nretmodes = (i64)(*d).nretvalues;
        if (((i64)mm_decls$ttbasetype[((i64)(*d).mode)] != (i64)27)) {
            mm_support$txerror((byte*)"Not a tuple",0);
        }
;
        if ((alength > nretmodes)) {
            mm_support$txerror((byte*)"mult ass/mult returns don't agree in number",0);
        }
;
        if ((nretmodes <= (i64)1)) {
            mm_support$txerror((byte*)"mult ass rhs needs fn yielding 2+ values",0);
        }
;
        p = alist;
        pmult = mm_decls$ttmult[((i64)(*d).mode)];
        i = (i64)1;
        L880 :;
        while (!!(p)) {
            mm_type$tpasslv(p,(i64)(*pmult)[((i)++)-1]);
L881 :;
            p = (*p).nextunit;
L883 :;
                    }
L882 :;
        ;
    }
    else if (($temp==(i64)11)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"MULT:=SLICE",NULL);
        msysc$m_print_i64((i64)(*a).length,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        if ((alength != (i64)2)) {
            mm_support$txerror((byte*)"(a,b):=slice",0);
        }
;
        mm_type$tpasslv(alist,mm_lib$createrefmode(0,(i64)mm_decls$tttarget[((i64)(*b).mode)],(i64)0));
        mm_type$tpasslv((*alist).nextunit,(i64)3);
    }
    else if (($temp==(i64)9)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"MULT:=RANGE",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)8)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"MULT:=RECORD",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        if ((((i64)(*b).tag == (i64)34) && ((i64)(*b).pclop == (i64)7))) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"MULT:=DIVREM",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            if ((alength != (i64)2)) {
                mm_support$txerror((byte*)"(a,b):=divrem",0);
            }
;
            mm_type$tpasslv(alist,(i64)3);
            mm_type$tpasslv((*alist).nextunit,(i64)3);
            (*pp).tag = (i64)29;
        }
        else {
            mm_support$txerror_s((byte*)"Can't expand to mult values:",mm_lib$strmode((i64)(*b).mode,(i64)1),0);
        }
;
    }
    };
    (*pp).mode = t;
}

static void mm_type$tpasslv(struct mm_decls$unitrec *p,i64 t) {
    mm_type$tpass(p,(i64)22,(i64)1);
    if (!((t == (i64)22 || t == (i64)0))) {
        if (!(!!(mm_type$comparemodes((i64)(*p).mode,t)))) {
            mm_support$txerror_ss((byte*)"PassLV type mismatch: #:=#",mm_lib$strmode((i64)(*p).mode,(i64)1),mm_lib$strmode2(t,(i64)1));
        }
;
    }
;
}

static i64 mm_type$dobinnumx(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 amode;
        i64 bmode;
        i64 cmode;
    amode = (i64)(*a).mode;
    bmode = (i64)(*b).mode;
    if (((amode >= (i64)1 && amode <= (i64)5) && (bmode >= (i64)1 && bmode <= (i64)5))) {
        (*p).mode = (cmode = (amode>bmode?amode:bmode));
        mm_type$coerceunit(a,cmode,(i64)0);
        mm_type$coerceunit(b,cmode,(i64)0);
        return (i64)1;
    }
;
    return (i64)0;
}

static i64 mm_type$dobinnumf(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 amode;
        i64 bmode;
        i64 cmode;
    amode = (i64)(*a).mode;
    bmode = (i64)(*b).mode;
    if (((amode == (i64)5 || amode == (i64)4) && (bmode == (i64)5 || bmode == (i64)4))) {
        (*p).mode = (cmode = (amode>bmode?amode:bmode));
        mm_type$coerceunit(a,cmode,(i64)0);
        mm_type$coerceunit(b,cmode,(i64)0);
        return (i64)1;
    }
;
    return (i64)0;
}

static i64 mm_type$dobinnumi(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 amode;
        i64 bmode;
        i64 cmode;
    amode = (i64)(*a).mode;
    bmode = (i64)(*b).mode;
    if (((amode == (i64)3 || amode == (i64)2 || amode == (i64)1) && (bmode == (i64)3 || bmode == (i64)2 || bmode == (i64)1))) {
        (*p).mode = (cmode = (amode>bmode?amode:bmode));
        mm_type$coerceunit(a,cmode,(i64)0);
        mm_type$coerceunit(b,cmode,(i64)0);
        return (i64)1;
    }
;
    return (i64)0;
}

static i64 mm_type$doin(struct mm_decls$unitrec *p,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b) {
        i64 simpleset;
        struct mm_decls$unitrec *  q;
    simpleset = (i64)1;
    if (((i64)(*b).tag == (i64)20)) {
        q = (*b).a;
        L884 :;
        while (!!(q)) {
            if (!(!!((i64)mm_decls$ttisinteger[((i64)(*q).mode)]))) {
                simpleset = (i64)0;
                goto L886 ;
            }
;
L885 :;
            q = (*q).nextunit;
L887 :;
                    }
L886 :;
        ;
    }
;
    if (((((i64)(*a).mode >= (i64)1 && (i64)(*a).mode <= (i64)5) && ((i64)(*b).tag == (i64)19 || (i64)(*b).tag == (i64)20)) && !!(simpleset))) {
        (*p).tag = (((i64)(*b).tag == (i64)19) ? (i64)40 : (i64)41);
    }
    else {
        mm_support$txerror((byte*)"doin",0);
    }
;
    (*p).mode = (i64)6;
    if (((i64)(*p).pclop == (i64)14)) {
        mm_type$addnotl(p);
    }
;
    return (i64)1;
}

static void mm_type$setsimple(struct mm_decls$unitrec *p) {
        struct mm_decls$unitrec *  a;
        i64 $av_1;
        i64 i;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)31) || ($temp==(i64)90)) {
        return;
    }
    else if (($temp==(i64)34) || ($temp==(i64)35)) {
        if (!!((i64)mm_tables$complexopset[((i64)(*p).pclop)])) {
            return;
        }
;
    }
    };
        ($av_1 = (i64)mm_tables$jsubs[((i64)(*p).tag)]);
    for (i=(i64)1;i<=$av_1;++i) {
L888 :;
        a = (*p).abc[(i)-1];
        if ((!!(a) && !(!!((i64)(*a).simple)))) {
            return;
        }
;
L889 :;
    }
L890 :;
    ;
    (*p).simple = (i64)1;
}

// START
void mm_type$start(void) {

}

i64 mc_genmcl$codegen_mcl(void) {
        struct mm_decls$procrec *  pp;
        struct mm_decls$strec *  d;
    mc_libmcl$mclinit();
    pp = (struct mm_decls$procrec *)mm_decls$staticlist;
    L891 :;
    while (!!(pp)) {
        d = (*pp).def;
        mc_genmcl$dostaticvar(d);
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L892 :;
    }
L893 :;
    ;
    mc_libmcl$gencomment((byte*)"",0);
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L894 :;
    while (!!(pp)) {
        d = (*pp).def;
        mc_genmcl$genprocdef((mm_decls$currproc = d));
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L895 :;
    }
L896 :;
    ;
    mc_libmcl$genabsneg();
    mc_libmcl$genstringtable();
    mc_libmcl$genrealtable();
    mc_libmcl$genfunctable();
    mc_libmcl$genmc((i64)3,0,0);
    if ((!!(mm_decls$debugmode) && !!((i64)mm_decls$fshowasm))) {
    }
;
    return (i64)1;
    return (i64)0;
}

static void mc_genmcl$genprocdef(struct mm_decls$strec *p) {
        struct mm_decls$modulerec *  ms;
        struct mc_decls$opndrec *  rx;
    mc_decls$procdef = p;
    mc_libmcl$setsegment((i64)67,(i64)1);
    mc_libmcl$genmc((i64)1,mc_libmcl$genmemaddr(mc_decls$procdef),0);
    mc_libmcl$genmc((i64)7,mc_libmcl$genmemaddr(mc_decls$procdef),0);
    mc_decls$regset = (u64)0u;
    mc_decls$nregs = (mc_decls$nxregs = (i64)0);
    mc_decls$mstackdepth = (mc_decls$ncalldepth = (i64)0);
    mc_decls$nblocktemps = (i64)0;
    ms = (struct mm_decls$modulerec *)&mm_decls$moduletable[((i64)(*p).moduleno)];
    if ((p == (*ms).stmain)) {
        mc_genmcl$genmaindef(p);
        return;
    }
    else if ((p == (*ms).ststart)) {
        mc_genmcl$genstartdef(p);
        return;
    }
;
    mc_genmcl$genlocals(p);
    mc_decls$retindex = mc_libmcl$createfwdlabel();
    mc_libmcl$gencomment((byte*)"------------------------",0);
    rx = mc_blockmcl$loadunit((*p).code,(i64)0);
    mc_libmcl$gencomment((byte*)"------------------------",0);
    mc_libmcl$definefwdlabel(mc_decls$retindex);
    mc_genmcl$genreturn();
    mc_genmcl$checkreturn(p);
    mc_genmcl$genblocktemps();
    mc_libmcl$genmc((i64)2,0,0);
    mc_libmcl$gencomment((byte*)"",0);
}

static void mc_genmcl$dostaticvar(struct mm_decls$strec *d) {
        i64 align;
    if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
        return;
    }
;
    if ((((i64)(*d).scope == (i64)2) && ((u64)(*(*d).name) == '$'))) {
        if (!!(mlib$eqstring((*d).name,(byte*)"$cmdskip"))) {
            (*d).scope = (i64)3;
        }
;
    }
;
    align = mm_lib$getalignment((i64)(*d).mode);
    if (((i64)msysc$m_getdotindex((i64)(*d).flags,(i64)10) == (i64)1)) {
        return;
    }
    else if (!!((*d).code)) {
        mc_libmcl$setsegment((i64)73,align);
        mc_libmcl$genmc((i64)7,mc_libmcl$genmemaddr(d),0);
        mc_genmcl$genidata((*d).code,(i64)1,(i64)65,(i64)0);
    }
    else {
        mc_libmcl$setsegment((i64)90,align);
        mc_libmcl$genmc((i64)7,mc_libmcl$genmemaddr(d),0);
        mc_libmcl$genmc((i64)125,mc_libmcl$genint((i64)mm_decls$ttsize[((i64)(*d).mode)],(i64)8),0);
    }
;
}

static void mc_genmcl$genidata(struct mm_decls$unitrec *p,i64 doterm,i64 am,i64 offset) {
        i64 t;
        i64 tbase;
        struct mm_decls$unitrec *  q;
        struct mm_decls$unitrec *  a;
        struct mm_decls$strec *  d;
    t = (i64)(*p).mode;
    mm_tables$mlineno = (i64)(*p).pos;
    tbase = (i64)mm_decls$ttbasetype[(t)];
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        if (!!((i64)mm_decls$ttisref[((i64)(*p).mode)])) {
            if (((i64)(*p).mode == (i64)20)) {
                if (!!((*p).svalue)) {
                    mc_libmcl$genmc((i64)118,mc_libmcl$genstring((*p).svalue,(i64)-1),0);
                }
                else {
                    mc_libmcl$genmc((i64)118,mc_libmcl$genint((i64)0,(i64)8),0);
                }
;
            }
            else {
                mc_libmcl$genmc((i64)118,mc_libmcl$genint((*p).value,(i64)8),0);
            }
;
        }
        else if (!!((i64)mm_decls$ttisreal[((i64)(*p).mode)])) {
                        {i64 $temp = (i64)mm_decls$ttsize[((i64)(*p).mode)];
if (($temp==(i64)4)) {
                mc_libmcl$genmc((i64)117,mc_libmcl$genrealimm((*p).xvalue,(i64)4),0);
            }
            else if (($temp==(i64)8)) {
                mc_libmcl$genmc((i64)118,mc_libmcl$genrealimm((*p).xvalue,(i64)5),0);
            }
            else {
                mm_support$gerror_s((byte*)"IDATA/REAL:",mm_lib$strmode((i64)(*p).mode,(i64)1),p);
            }
            };
        }
        else {
                        {i64 $temp = (i64)mm_decls$ttsize[((!!((i64)(*p).memmode) ? (i64)(*p).memmode : (i64)(*p).mode))];
if (($temp==(i64)1)) {
                mc_libmcl$genmc((i64)115,mc_libmcl$genint((*p).value,(i64)8),0);
            }
            else if (($temp==(i64)2)) {
                mc_libmcl$genmc((i64)116,mc_libmcl$genint((*p).value,(i64)8),0);
            }
            else if (($temp==(i64)4)) {
                mc_libmcl$genmc((i64)117,mc_libmcl$genint((*p).value,(i64)8),0);
            }
            else if (($temp==(i64)8)) {
                mc_libmcl$genmc((i64)118,mc_libmcl$genint((*p).value,(i64)8),0);
            }
            else {
                mm_support$gerror_s((byte*)"IDATA/INT:",mm_lib$strmode((i64)(*p).mode,(i64)1),p);
            }
            };
        }
;
    }
    else if (($temp==(i64)18)) {
        q = (*p).a;
        L897 :;
        while (!!(q)) {
            mc_genmcl$genidata(q,(i64)1,(i64)65,(i64)0);
            q = (*q).nextunit;
L898 :;
        }
L899 :;
        ;
    }
    else if (($temp==(i64)4)) {
        d = (*p).def;
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)11) || ($temp==(i64)6) || ($temp==(i64)7)) {
            mc_libmcl$genmc((((am == (i64)80) || ((i64)mm_decls$ttsize[((i64)(*p).mode)] == (i64)8)) ? (i64)118 : (i64)117),mc_libmcl$genmemaddr(d),0);
        }
        else if (($temp==(i64)17)) {
            if (((i64)(*d).index == (i64)0)) {
                (*d).index = ++(mc_decls$mlabelno);
            }
;
            mc_libmcl$genmc((i64)118,mc_libmcl$genlabel((i64)(*d).index),0);
        }
        else {
            mm_support$gerror((byte*)"Idata &frameXXX",0);
        }
        };
        return;
    }
    else if (($temp==(i64)52)) {
        mc_genmcl$genidata((*p).a,(i64)1,(i64)65,(i64)0);
    }
    else if (($temp==(i64)53)) {
        a = (*p).a;
                {i64 $temp = (i64)mm_decls$ttsize[((i64)(*p).mode)];
if (($temp==(i64)1)) {
            mc_libmcl$genmc((i64)115,mc_libmcl$genint((*a).value,(i64)8),0);
        }
        else if (($temp==(i64)2)) {
            mc_libmcl$genmc((i64)116,mc_libmcl$genint((*a).value,(i64)8),0);
        }
        else if (($temp==(i64)4)) {
            mc_libmcl$genmc((i64)117,mc_libmcl$genint((*a).value,(i64)8),0);
        }
        else {
            mm_support$gerror_s((byte*)"IDATA/SHORTEN:",mm_lib$strmode((i64)(*p).mode,(i64)1),p);
        }
        };
    }
    else if (($temp==(i64)50) || ($temp==(i64)51)) {
        mc_genmcl$genidata((*p).a,(i64)1,(i64)80,(!!((*p).b) ? (*(*p).b).value : (i64)0));
    }
    else {
        mm_support$gerror_s((byte*)"IDATA: ",mm_tables$jtagnames[((i64)(*p).tag)],p);
    }
    };
}

static void mc_genmcl$checkreturn(struct mm_decls$strec *p) {
    if (((i64)(*p).mode != (i64)0)) {
        if (!(!!(mm_lib$checkblockreturn((*p).code)))) {
            mm_support$gerror_s((byte*)"Function needs explicit return: ",(*p).name,0);
        }
;
    }
;
}

static void mc_genmcl$genreturn(void) {
        struct mc_decls$opndrec *  ax;
        struct mc_decls$opndrec *  bx;
    if (!!((i64)mm_decls$ttisblock[((i64)(*mc_decls$procdef).mode)])) {
        mc_libmcl$gencomment((byte*)"COPY BLOCK RETURN",0);
        mc_libmcl$genmc((i64)13,(ax = mc_libmcl$genreg((i64)0,(i64)8)),mc_libmcl$genmem(mc_genmcl$blockretname));
        mc_libmcl$genmc((i64)14,ax,0);
        bx = mc_libmcl$genreg((i64)1,(i64)8);
        mc_libmcl$copyblock(ax,bx,(i64)mm_decls$ttsize[((i64)(*mc_genmcl$blockretname).mode)],(i64)0);
        mc_libmcl$genmc((i64)15,mc_libmcl$genreg((i64)1,(i64)8),0);
    }
;
    if (!!((i64)(*mc_decls$procdef).isthreaded)) {
        mc_libmcl$genmc((i64)24,0,0);
        return;
    }
;
    mc_libmcl$popstack(mc_decls$framebytes);
    mc_libmcl$genmc((i64)15,mc_decls$dframeopnd,0);
    mc_libmcl$genmc((i64)24,0,0);
}

static void mc_genmcl$genlocals(struct mm_decls$strec *p) {
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
        struct mm_decls$strec *  b;
    d = (struct mm_decls$strec *)(*p).deflist;
    mc_decls$frameoffset = (mc_decls$paramoffset = (i64)0);
    mc_decls$nparams = (i64)0;
    mc_genmcl$mclpushstack = (struct mc_decls$mclrec *)(mc_genmcl$mcldefine = 0);
    if (!!((i64)(*p).isthreaded)) {
        e = d;
        L900 :;
        while (!!(d)) {
            if (((i64)(*d).nameid == (i64)13 || (i64)(*d).nameid == (i64)12)) {
                mm_support$gerror((byte*)"param/locals in threaded proc",0);
            }
;
L901 :;
            d = (struct mm_decls$strec *)(*d).nextdef;
L903 :;
                    }
L902 :;
        ;
        return;
    }
;
    if (!!((i64)mm_decls$ttisblock[((i64)(*p).mode)])) {
        b = mm_lib$getduplnameptr(p,(struct mm_decls$strec *)mm_lex$addnamestr((byte*)"$1x"),(i64)13);
        (*b).mode = (i64)(*p).mode;
        mc_genmcl$blockretname = b;
        mc_decls$paramdefs[(++(mc_decls$nparams))-1] = b;
        (*b).offset = (mc_decls$paramoffset + (i64)16);
        mc_libmcl$genmc((i64)8,mc_libmcl$genname(mc_libmcl$getdispname(b)),mc_libmcl$genint((i64)(*b).offset,(i64)8));
        mc_decls$paramoffset += (i64)8;
    }
;
    L904 :;
    while (!!(d)) {
        mm_tables$mlineno = (i64)(*d).pos;
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)12)) {
            if (!(!!(msysc$m_getdotindex((i64)(*d).flags,(i64)10)))) {
                if (!((((u64)(*(*d).name) == '$') && ((i64)msysc$m_getdotindex((i64)(*d).flags,(i64)1) == (i64)0)))) {
                    mc_decls$frameoffset -= mc_libmcl$roundsizetg((i64)mm_decls$ttsize[((i64)(*d).mode)]);
                    (*d).offset = mc_decls$frameoffset;
                    mc_libmcl$genmc((i64)8,mc_libmcl$genname(mc_libmcl$getdispname(d)),mc_libmcl$genint(mc_decls$frameoffset,(i64)8));
                }
;
            }
;
        }
        else if (($temp==(i64)13)) {
            mc_decls$paramdefs[(++(mc_decls$nparams))-1] = d;
            (*d).offset = (mc_decls$paramoffset + (i64)16);
            mc_libmcl$genmc((i64)8,mc_libmcl$genname(mc_libmcl$getdispname(d)),mc_libmcl$genint((i64)(*d).offset,(i64)8));
            mc_decls$paramoffset += (i64)8;
        }
        };
        d = (struct mm_decls$strec *)(*d).nextdef;
L905 :;
    }
L906 :;
    ;
    mc_genmcl$mcldefine = (struct mc_decls$mclrec *)mc_decls$mccodex;
    mc_decls$framebytes = -(mc_decls$frameoffset);
    if (!!((mc_decls$framebytes & (i64)8))) {
        mc_decls$framebytes += (i64)8;
    }
;
    mc_decls$framebytes += (i64)32;
    mc_libmcl$genmc((i64)14,mc_decls$dframeopnd,0);
    mc_libmcl$genmc((i64)13,mc_decls$dframeopnd,mc_decls$dstackopnd);
    mc_libmcl$pushstack(mc_decls$framebytes);
    mc_genmcl$mclpushstack = (struct mc_decls$mclrec *)mc_decls$mccodex;
    mc_genmcl$spillparams();
}

static void mc_genmcl$spillparams(void) {
        struct mm_decls$strec *  d;
        struct mc_decls$opndrec *  ax;
        i64 offset;
        i64 regoffset;
        i64 i;
    offset = (i64)16;
    regoffset = (i64)0;
    regoffset = (i64)0;
    for (i=(i64)1;i<=mc_decls$nparams;++i) {
L907 :;
        if ((regoffset > (i64)3)) {
            goto L909 ;
        }
;
        d = mc_decls$paramdefs[(i)-1];
        if (!(!!((i64)(*d).reg))) {
            ax = mc_libmcl$genindex((i64)15,(i64)0,(i64)1,offset,(i64)8,(i64)0,0);
                        {i64 $temp = (i64)mm_decls$ttbasetype[((i64)(*d).mode)];
if (($temp==(i64)5)) {
                mc_libmcl$genmc((i64)19,ax,mc_libmcl$genxreg((regoffset + (i64)21),(i64)8));
            }
            else if (($temp==(i64)4)) {
                mc_libmcl$genmc((i64)18,mc_libmcl$changeopndsize(ax,(i64)4),mc_libmcl$genxreg((regoffset + (i64)21),(i64)8));
            }
            else {
                mc_libmcl$genmc((i64)13,ax,mc_libmcl$genreg((regoffset + (i64)11),(i64)8));
            }
            };
        }
        else if (!!((i64)(*d).reg)) {
            mc_libmcl$merror((byte*)"PARAM SPILL/REG",(byte*)"");
        }
;
        offset += (i64)8;
        ++(regoffset);
L908 :;
    }
L909 :;
    ;
}

static void mc_genmcl$genblocktemps(void) {
    if ((mc_decls$nblocktemps == (i64)0)) {
        return;
    }
;
    mc_libmcl$gencomment((byte*)"<GENBLOCKTEMPS>",msysc$strint(mc_decls$nblocktemps,0));
}

static void mc_genmcl$docallproc(struct mm_decls$strec *d) {
    mc_libmcl$genmc((i64)23,mc_libmcl$genmemaddr(d),0);
}

static void mc_genmcl$genmaindef(struct mm_decls$strec *p) {
        struct mm_decls$strec *  d;
        u8 str[100];
        i64 i;
    mc_genmcl$genlocals(p);
    mc_decls$retindex = mc_libmcl$createfwdlabel();
    for (i=(i64)2;i<=mm_decls$nsubprogs;++i) {
L910 :;
        d = mm_decls$moduletable[((i64)mm_decls$subprogtable[(i)].firstmodule)].ststart;
        mc_genmcl$docallproc(d);
L911 :;
    }
L912 :;
    ;
    d = mm_decls$moduletable[((i64)mm_decls$subprogtable[((i64)1)].firstmodule)].ststart;
    mc_genmcl$docallproc(d);
    mc_libmcl$gencomment((byte*)"------------------------",0);
    mc_blockmcl$evalunit((*p).code,(i64)0);
    mc_libmcl$gencomment((byte*)"------------------------",0);
    mc_libmcl$definefwdlabel(mc_decls$retindex);
    mc_genmcl$genreturn();
    mc_genmcl$checkreturn(p);
    mc_genmcl$genblocktemps();
    mc_libmcl$gencomment(mc_libmcl$showregset((byte*)"REGS:"),0);
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"Stack depth:",NULL);
    msysc$m_print_i64(mc_decls$mstackdepth,NULL);
    msysc$m_print_end();
    ;
    mc_libmcl$gencomment(str,0);
    mc_libmcl$genmc((i64)2,0,0);
    mc_libmcl$gencomment((byte*)"",0);
}

static void mc_genmcl$genstartdef(struct mm_decls$strec *p) {
        struct mm_decls$strec *  d;
        i64 lead;
        i64 m;
        i64 s;
        i64 i;
    lead = (i64)0;
    m = (i64)(*p).moduleno;
    s = (i64)(*p).subprogno;
    if (((i64)mm_decls$subprogtable[(s)].firstmodule == m)) {
        lead = (i64)1;
    }
;
    mc_genmcl$genlocals(p);
    mc_decls$retindex = mc_libmcl$createfwdlabel();
    if (!!(lead)) {
        for (i=(i64)1;i<=mm_decls$nmodules;++i) {
L913 :;
            if ((((i64)mm_decls$moduletosub[(i)] == s) && (i != m))) {
                d = mm_decls$moduletable[(i)].ststart;
                mc_genmcl$docallproc(d);
            }
;
L914 :;
        }
L915 :;
        ;
    }
;
    mc_libmcl$gencomment((byte*)"------------------------",0);
    mc_blockmcl$evalunit((*p).code,(i64)0);
    mc_libmcl$gencomment((byte*)"------------------------",0);
    mc_libmcl$definefwdlabel(mc_decls$retindex);
    mc_genmcl$genreturn();
    mc_genmcl$checkreturn(p);
    mc_genmcl$genblocktemps();
    mc_libmcl$genmc((i64)2,0,0);
    mc_libmcl$gencomment((byte*)"",0);
}

struct mm_decls$strec *mc_genmcl$newblocktemp(i64 m) {
        u8 str[16];
        struct mm_decls$strec *  d;
        i64 size;
    ++(mc_decls$nblocktemps);
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"$T#");
    msysc$m_print_i64(mc_decls$nblocktemps,NULL);
    msysc$m_print_end();
    ;
    d = mm_lib$getduplnameptr(mm_decls$currproc,(struct mm_decls$strec *)mm_lex$addnamestr(str),(i64)12);
    (*d).mode = m;
    mc_genmcl$setmclentry((struct mc_decls$mclrec *)mc_genmcl$mcldefine);
    size = mlib$roundtoblock((i64)mm_decls$ttsize[((i64)(*d).mode)],(i64)16);
    mc_decls$frameoffset -= size;
    mc_decls$framebytes += size;
    (*d).offset = mc_decls$frameoffset;
    mc_libmcl$genmc((i64)8,mc_libmcl$genname(mc_libmcl$getdispname(d)),mc_libmcl$genint(mc_decls$frameoffset,(i64)8));
    mc_genmcl$mcldefine = (struct mc_decls$mclrec *)mc_genmcl$resetmclentry();
    mc_genmcl$resetmclentry();
    (*(*mc_genmcl$mclpushstack).b).value = mc_decls$framebytes;
    return d;
}

static void mc_genmcl$setmclentry(struct mc_decls$mclrec *p) {
    mc_genmcl$mce_oldmccodex = (struct mc_decls$mclrec *)mc_decls$mccodex;
    mc_decls$mccodex = (struct mc_decls$mclrec *)p;
    mc_genmcl$mce_nextmcl = (struct mc_decls$mclrec *)(*p).nextmcl;
    (*mc_genmcl$mcldefine).nextmcl = 0;
}

static struct mc_decls$mclrec *mc_genmcl$resetmclentry(void) {
        struct mc_decls$mclrec *  pnew;
    (*mc_decls$mccodex).nextmcl = (struct mc_decls$mclrec *)mc_genmcl$mce_nextmcl;
    pnew = (struct mc_decls$mclrec *)mc_decls$mccodex;
    mc_decls$mccodex = (struct mc_decls$mclrec *)mc_genmcl$mce_oldmccodex;
    return pnew;
}

// START
void mc_genmcl$start(void) {

}

void mc_genss$genss(void) {
        i64 index;
        struct mc_decls$mclrec *  m;
    mc_genss$initlib(mc_decls$mlabelno);
    mc_decls$ss_zdatalen = (i64)0;
    mc_decls$ss_zdata = (struct mc_decls$dbuffer *)mc_genss$buffercreate((i64)1024);
    mc_decls$ss_idata = (struct mc_decls$dbuffer *)mc_genss$buffercreate((i64)1024);
    mc_decls$ss_code = (struct mc_decls$dbuffer *)mc_genss$buffercreate((i64)1024);
    mc_decls$ss_idatarelocs = 0;
    mc_decls$ss_coderelocs = 0;
    mc_decls$ss_nsymbols = (i64)0;
    mc_genss$switchseg((i64)1);
    mc_decls$alineno = (i64)9999;
    mc_genss$fixregvar();
    m = (struct mc_decls$mclrec *)mc_decls$mccode;
    index = (i64)0;
    L916 :;
    while (!!(m)) {
        mc_genss$doinstr((struct mc_decls$mclrec *)m,++(index));
        m = (struct mc_decls$mclrec *)(*m).nextmcl;
L917 :;
    }
L918 :;
    ;
    mc_genss$switchseg((i64)0);
    if (!!(mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_decls$ss_zdata))) {
        mm_support$axerror((byte*)"Zdata contains code or data");
    }
;
}

static void mc_genss$doinstr(struct mc_decls$mclrec *m,i64 index) {
        struct mc_decls$opndrec *  a;
        struct mc_decls$opndrec *  b;
        struct mm_decls$strec *  d;
        i64 x;
        i64 offset;
        i64 shortjmp;
        i64 n;
        i64 $av_1;
        i64 $av_2;
    mc_genss$buffercheck((struct mc_decls$dbuffer *)mc_genss$currdata,(i64)1024);
    mc_genss$rex = (mc_genss$sizeoverride = (mc_genss$addroverride = (mc_genss$f2override = (mc_genss$f3override = (i64)0))));
    a = (*m).a;
    b = (*m).b;
    ++(mc_genss$instrno);
    mc_decls$alineno = (i64)(*m).seqno;
    mc_genss$currmcl = (struct mc_decls$mclrec *)m;
    switch ((i64)(*m).opcode) {
    case 1:;
        {
            mc_decls$currasmproc = (*(*m).a).def;
        }
        break;
    case 2:;
        {
        }
        break;
    case 8:;
        {
        }
        break;
    case 9:;
        {
        }
        break;
    case 6:;
        {
        }
        break;
    case 3:;
        {
        }
        break;
    case 7:;
        {
                        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)4u)) {
            }
            else if (($temp==(u64)6u)) {
                d = (*a).def;
                (*d).reftype = (i64)2;
                (*d).segment = mc_genss$currseg;
                (*d).offset = mc_genss$getcurrdatalen((i64)6);
                if (((i64)(*d).scope == (i64)3)) {
                    mc_genss$getstindex(d);
                }
;
                mc_genss$dofwdrefs(d);
            }
            };
        }
        break;
    case 11:;
        {
            d = (*mc_decls$labeldeftable)[((*a).labelno)-1];
            (*d).reftype = (i64)2;
            (*d).segment = mc_genss$currseg;
            (*d).offset = mc_genss$getcurrdatalen((i64)6);
            mc_genss$dofwdrefs(d);
        }
        break;
    case 23:;
        {
            mc_genss$do_call(a);
        }
        break;
    case 27:;
        {
            mc_genss$do_jmp(a,(struct mc_decls$mclrec *)m);
        }
        break;
    case 28:;
        {
            d = mc_genss$getdef(a,(i64)1);
            offset = mc_genss$getrel32(d,(mc_genss$getcurrdatalen((i64)7) + (i64)1));
            if ((offset < (i64)0)) {
                if ((offset < (i64)-126)) {
                    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
                    (*((*mc_genss$currdata).pcurr)++) = ((i64)128 + (i64)(*m).cond);
                    mc_genss$gendword((offset - (i64)4));
                }
                else {
                    (*((*mc_genss$currdata).pcurr)++) = ((i64)112 + (i64)(*m).cond);
                    (*((*mc_genss$currdata).pcurr)++) = offset;
                }
;
            }
            else {
                shortjmp = mc_genss$checkshortjump((struct mc_decls$mclrec *)m,d);
                if (!(!!(shortjmp))) {
                    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
                    (*((*mc_genss$currdata).pcurr)++) = ((i64)128 + (i64)(*m).cond);
                    mc_genss$genrel32(a);
                }
                else {
                    (*((*mc_genss$currdata).pcurr)++) = ((i64)112 + (i64)(*m).cond);
                    mc_genss$genrel8(a);
                }
;
            }
;
        }
        break;
    case 115:;
        {
            mc_genss$genopnd(a,(i64)1);
        }
        break;
    case 116:;
        {
            mc_genss$genopnd(a,(i64)2);
        }
        break;
    case 117:;
        {
            mc_genss$genopnd(a,(i64)4);
        }
        break;
    case 118:;
        {
            mc_genss$genopnd(a,(i64)8);
        }
        break;
    case 119:;
        {
            mc_genss$genrel32(a);
        }
        break;
    case 120:;
        {
            mc_genss$switchseg((*a).value);
        }
        break;
    case 123:;
        {
            mc_genss$switchseg((i64)1);
        }
        break;
    case 121:;
        {
            mc_genss$switchseg((i64)2);
        }
        break;
    case 122:;
        {
            mc_genss$switchseg((i64)3);
        }
        break;
    case 12:;
    case 150:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)mc_decls$mclcodes[((i64)(*m).opcode)-1];
        }
        break;
    case 56:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)102;
            (*((*mc_genss$currdata).pcurr)++) = (i64)152;
        }
        break;
    case 57:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)102;
            (*((*mc_genss$currdata).pcurr)++) = (i64)153;
        }
        break;
    case 58:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)153;
        }
        break;
    case 59:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)72;
            (*((*mc_genss$currdata).pcurr)++) = (i64)153;
        }
        break;
    case 24:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)195;
        }
        break;
    case 26:;
        {
            if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)3)) {
                mm_support$axerror((byte*)"retn?");
            }
;
            (*((*mc_genss$currdata).pcurr)++) = (i64)194;
            mc_genss$genword((*a).value);
        }
        break;
    case 14:;
        {
            mc_genss$do_push(a);
        }
        break;
    case 15:;
        {
            mc_genss$do_pop(a);
        }
        break;
    case 54:;
    case 55:;
        {
            mc_genss$do_inc(a,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 52:;
    case 53:;
    case 35:;
    case 34:;
    case 39:;
    case 38:;
        {
            mc_genss$do_neg(a,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 30:;
    case 31:;
    case 40:;
    case 41:;
    case 42:;
    case 32:;
    case 33:;
    case 44:;
        {
            mc_genss$do_arith(a,b,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 13:;
        {
            mc_genss$do_mov(a,b);
        }
        break;
    case 16:;
        {
            mc_genss$do_lea(a,b);
        }
        break;
    case 20:;
        {
            mc_genss$do_movsx(a,b,(i64)190);
        }
        break;
    case 21:;
        {
            mc_genss$do_movsx(a,b,(i64)182);
        }
        break;
    case 22:;
        {
            mc_genss$do_movsxd(a,b);
        }
        break;
    case 29:;
        {
            mc_genss$do_exch(a,b);
        }
        break;
    case 36:;
        {
            mc_genss$do_imul2(a,b);
        }
        break;
    case 125:;
    case 126:;
    case 127:;
    case 128:;
        {
            if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)3)) {
                n = ((*a).value * (i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
                if ((mc_genss$currseg==(i64)1)) {
                    $av_1 = n;
                    while ($av_1-- > 0) {
L919 :;
                        (*((*mc_genss$currdata).pcurr)++) = (i64)144;
L920 :;
                    }
L921 :;
                    ;
                }
                else if ((mc_genss$currseg==(i64)2)) {
                    $av_2 = n;
                    while ($av_2-- > 0) {
L922 :;
                        (*((*mc_genss$currdata).pcurr)++) = (i64)0;
L923 :;
                    }
L924 :;
                    ;
                }
                else {
                    mc_decls$ss_zdatalen += n;
                }
;
            }
            else {
                mm_support$axerror((byte*)"resb?");
            }
;
        }
        break;
    case 124:;
        {
            if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)3)) {
                x = (*a).value;
                if (((x < (i64)1) || (x > (i64)16384))) {
                    mm_support$axerror((byte*)"align2");
                }
;
                if ((mc_genss$currseg != (i64)3)) {
                    L925 :;
                    while (!!((mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_genss$currdata) % x))) {
                        (*((*mc_genss$currdata).pcurr)++) = ((mc_genss$currseg == (i64)1) ? (i64)144 : (i64)0);
L926 :;
                    }
L927 :;
                    ;
                }
                else {
                    L928 :;
                    while (!!((mc_decls$ss_zdatalen % x))) {
                        ++(mc_decls$ss_zdatalen);
L929 :;
                    }
L930 :;
                    ;
                }
;
            }
            else {
                mm_support$axerror((byte*)"align?");
            }
;
        }
        break;
    case 45:;
    case 47:;
    case 46:;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
        {
            mc_genss$do_shift(a,b,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 43:;
        {
            mc_genss$do_test(a,b);
        }
        break;
    case 132:;
    case 131:;
    case 130:;
        {
            mc_genss$do_loop(a,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 133:;
        {
            mc_genss$do_jcxz(a,(i64)4);
        }
        break;
    case 134:;
        {
            mc_genss$do_jcxz(a,(i64)8);
        }
        break;
    case 129:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)215;
        }
        break;
    case 60:;
        {
            mc_genss$do_setcc((i64)(*m).cond,a);
        }
        break;
    case 18:;
        {
            mc_genss$do_movxmm(a,b,(i64)4);
        }
        break;
    case 19:;
        {
            mc_genss$do_movxmm(a,b,(i64)8);
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 64:;
    case 111:;
    case 112:;
        {
            mc_genss$do_arithxmm(a,b,(i64)243,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 63:;
    case 113:;
    case 114:;
        {
            mc_genss$do_arithxmm(a,b,(i64)242,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 78:;
    case 76:;
        {
            mc_genss$do_logicxmm(a,b,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1],(i64)4);
        }
        break;
    case 77:;
    case 75:;
    case 80:;
    case 79:;
        {
            mc_genss$do_logicxmm(a,b,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1],(i64)8);
        }
        break;
    case 73:;
        {
            mc_genss$do_arithxmm(a,b,(i64)0,(i64)47);
        }
        break;
    case 74:;
        {
            mc_genss$do_arithxmm(a,b,(i64)102,(i64)47);
        }
        break;
    case 88:;
        {
            mc_genss$do_convertfloat(a,b,(i64)243);
        }
        break;
    case 87:;
        {
            mc_genss$do_convertfloat(a,b,(i64)242);
        }
        break;
    case 81:;
        {
            mc_genss$do_fix(a,b,(i64)243,(i64)45);
        }
        break;
    case 82:;
        {
            mc_genss$do_fix(a,b,(i64)242,(i64)45);
        }
        break;
    case 83:;
        {
            mc_genss$do_fix(a,b,(i64)243,(i64)44);
        }
        break;
    case 84:;
        {
            mc_genss$do_fix(a,b,(i64)242,(i64)44);
        }
        break;
    case 85:;
        {
            mc_genss$do_float(a,b,(i64)243);
        }
        break;
    case 86:;
        {
            mc_genss$do_float(a,b,(i64)242);
        }
        break;
    case 17:;
        {
            mc_genss$do_cmovcc((i64)(*m).cond,a,b);
        }
        break;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)217;
            (*((*mc_genss$currdata).pcurr)++) = (i64)mc_decls$mclcodes[((i64)(*m).opcode)-1];
        }
        break;
    case 93:;
    case 94:;
    case 95:;
        {
            mc_genss$do_fmem(a,(i64)1,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 96:;
    case 97:;
    case 98:;
        {
            mc_genss$do_fmem(a,(i64)0,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)222;
            (*((*mc_genss$currdata).pcurr)++) = (i64)mc_decls$mclcodes[((i64)(*m).opcode)-1];
        }
        break;
    case 135:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)166;
        }
        break;
    case 136:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)102;
            (*((*mc_genss$currdata).pcurr)++) = (i64)167;
        }
        break;
    case 137:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)167;
        }
        break;
    case 138:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)72;
            (*((*mc_genss$currdata).pcurr)++) = (i64)167;
        }
        break;
    case 139:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)15;
            (*((*mc_genss$currdata).pcurr)++) = (i64)mc_decls$mclcodes[((i64)(*m).opcode)-1];
        }
        break;
    case 89:;
    case 90:;
        {
            mc_genss$do_movdqx(a,b,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 141:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)219;
            (*((*mc_genss$currdata).pcurr)++) = (i64)227;
        }
        break;
    case 142:;
    case 143:;
    case 144:;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)217;
            (*((*mc_genss$currdata).pcurr)++) = (i64)mc_decls$mclcodes[((i64)(*m).opcode)-1];
        }
        break;
    case 140:;
        {
            mc_genss$do_popcnt(a,b);
        }
        break;
    case 61:;
    case 62:;
        {
            mc_genss$do_bsf(a,b,(i64)mc_decls$mclcodes[((i64)(*m).opcode)-1]);
        }
        break;
    case 149:;
        {
            (*((*mc_genss$currdata).pcurr)++) = (i64)15;
            (*((*mc_genss$currdata).pcurr)++) = (i64)162;
        }
        break;
    case 4:;
        {
        }
        break;
    case 5:;
        {
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"*** Can't do opcode",NULL);
        msysc$m_print_str(mc_decls$mclnames[((i64)(*m).opcode)-1],NULL);
        msysc$m_print_str((byte*)"line",NULL);
        msysc$m_print_i64(mc_decls$alineno,NULL);
        msysc$m_print_str((byte*)"M.OPCODE=",NULL);
        msysc$m_print_i64((i64)(*m).opcode,NULL);
        msysc$m_print_str((byte*)"M_HALT=",NULL);
        msysc$m_print_i64((i64)150,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$axerror((byte*)"STOPPING");
    }
    } //SW
;
}

static void mc_genss$genword(i64 x) {
    mc_genss$addword((struct mc_decls$dbuffer *)mc_genss$currdata,x);
}

static void mc_genss$gendword(i64 x) {
    mc_genss$adddword((struct mc_decls$dbuffer *)mc_genss$currdata,x);
}

static void mc_genss$genqword(i64 x) {
    mc_genss$addqword((struct mc_decls$dbuffer *)mc_genss$currdata,x);
}

static void mc_genss$genopnd(struct mc_decls$opndrec *a,i64 size) {
        u8 *  s;
        i64 length;
        r32 x32;
    if ((size == (i64)0)) {
        size = (i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
    }
;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)4u)) {
        s = (*a).svalue;
        length = strlen(s);
        if ((length > (i64)100)) {
            mc_genss$buffercheck((struct mc_decls$dbuffer *)mc_genss$currdata,msysc$m_imax((i64)1024,(length + (i64)1)));
        }
;
        L931 :;
        while (!!((u64)(*s))) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)(u64)(*(s)++);
L932 :;
        }
L933 :;
        ;
        return;
    }
    else if (($temp==(u64)8u)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"GENSS/NAME OPND",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    };
    if ((!!(mc_genss$getdef(a,(i64)0)) && (size <= (i64)2))) {
        mm_support$axerror((byte*)"8/16-BIT RELOC");
    }
;
    if ((size==(i64)1)) {
        (*((*mc_genss$currdata).pcurr)++) = (*a).value;
    }
    else if ((size==(i64)2)) {
        mc_genss$genword((*a).value);
    }
    else if ((size==(i64)4)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)1u)) {
            mc_genss$gendword((*a).value);
        }
        else if (($temp==(u64)2u)) {
            x32 = (r32)(*a).xvalue;
            mc_genss$gendword(*(i64*)&x32);
        }
        else if (($temp==(u64)3u)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"\t\tOPND/REALMEM4",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else if (($temp==(u64)4u)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"\t\tOPND/STRINGIMM4",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else if (($temp==(u64)6u) || ($temp==(u64)7u)) {
            mc_genss$genabs32(a);
        }
        else if (($temp==(u64)8u)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"\t\tOPND/NAME4",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(mc_decls$valtypenames[((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15))],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"OPND/4/VALTYPE?");
        }
        };
    }
    else if ((size==(i64)8)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)1u)) {
            mc_genss$genqword((*a).value);
        }
        else if (($temp==(u64)2u)) {
            mc_genss$genqword((i64)msysc$m_tp_r64toi64((*a).xvalue));
        }
        else if (($temp==(u64)3u)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"\t\tOPND/REALMEM8",NULL);
            msysc$m_print_i64(mc_decls$alineno,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else if (($temp==(u64)4u)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"\t\tOPND/STRINGIMM8",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else if (($temp==(u64)6u) || ($temp==(u64)7u)) {
            mc_genss$genabs64(a);
        }
        else if (($temp==(u64)8u)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"\t\tOPND/NAME8",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"HERE",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_str(mc_decls$valtypenames[((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15))],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"OPND/8/VALTYPE?");
        }
        };
    }
;
}

static void mc_genss$addrelocitem(i64 reloctype,struct mm_decls$strec *d) {
        struct mc_decls$relocrec *  r;
        i64 stindex;
        i64 adjust;
    stindex = mc_genss$getstindex(d);
    adjust = (i64)4;
    if ((reloctype == (i64)1)) {
        adjust = (i64)8;
    }
;
    r = (struct mc_decls$relocrec *)mlib$pcm_alloc((i64)32);
    (*r).nextreloc = (struct mc_decls$relocrec *)mc_genss$currrelocs;
    (*r).reloctype = reloctype;
    (*r).offset = (mc_genss$getcurrdatalen((i64)1) - adjust);
    (*r).stindex = stindex;
    ++(mc_genss$nrelocs);
    mc_genss$currrelocs = (struct mc_decls$relocrec *)r;
}

static i64 mc_genss$getstindex(struct mm_decls$strec *d) {
    if (((i64)(*d).stindex == (i64)0)) {
        if ((mc_decls$ss_nsymbols >= mc_decls$ss_symboltablesize)) {
            mc_genss$extendsymboltable();
        }
;
        (*d).stindex = ++(mc_decls$ss_nsymbols);
        (*mc_decls$ss_symboltable)[((i64)(*d).stindex)-1] = d;
        if (((i64)(*d).segment == (i64)0)) {
            if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
                (*d).segment = (i64)1;
            }
;
        }
;
    }
;
    return (i64)(*d).stindex;
}

static void mc_genss$genrel32(struct mc_decls$opndrec *a) {
        struct mm_decls$strec *  d;
    d = mc_genss$getdef(a,(i64)0);
    if ((d == 0)) {
        mc_genss$gendword((*a).value);
        return;
    }
;
        {i64 $temp = (i64)(*d).reftype;
if (($temp==(i64)2)) {
        if (((i64)(*d).segment != mc_genss$currseg)) {
            mm_support$axerror((byte*)"Rel label across segments");
        }
;
        mc_genss$gendword((((i64)(*d).offset - (mc_genss$getcurrdatalen((i64)2) + (i64)4)) + (i64)(*a).offset));
    }
    else if (($temp==(i64)1)) {
        (*d).fwdrefs = (struct mm_decls$fwdrec *)mc_genss$addfwdref((struct mm_decls$fwdrec *)(*d).fwdrefs,mc_genss$getcurrdatalen((i64)3),(i64)4,(i64)0);
        mc_genss$gendword((i64)(*a).offset);
    }
    else {
        mc_genss$gendword((i64)(*a).offset);
        mc_genss$addrelocitem((i64)4,d);
    }
    };
}

static struct mm_decls$strec *mc_genss$getdef(struct mc_decls$opndrec *a,i64 dneeded) {
        struct mm_decls$strec *  d;
    if ((msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)4 || msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)3)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)7u)) {
            return (*mc_decls$labeldeftable)[((*a).labelno)-1];
        }
        else if (($temp==(u64)6u)) {
            d = (*a).def;
            if (((i64)(*d).reftype == (i64)0)) {
                if (!(!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12)))) {
                    (*d).reftype = (i64)1;
                }
;
            }
;
            return d;
        }
        };
    }
;
    if (!!(dneeded)) {
        msysc$m_print_startcon();
        msysc$m_print_str(mc_decls$opndnames[((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11))],NULL);
        msysc$m_print_str(mc_decls$valtypenames[((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15))],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$axerror((byte*)"getdef/no def");
    }
;
    return (struct mm_decls$strec *)0;
}

static void mc_genss$genabs32(struct mc_decls$opndrec *a) {
        struct mm_decls$strec *  d;
    d = mc_genss$getdef(a,(i64)1);
        {i64 $temp = (i64)(*d).reftype;
if (($temp==(i64)2)) {
        mc_genss$gendword(((i64)(*d).offset + (i64)(*a).offset));
        mc_genss$addrelocitem((i64)2,d);
    }
    else if (($temp==(i64)1)) {
        (*d).fwdrefs = (struct mm_decls$fwdrec *)mc_genss$addfwdref((struct mm_decls$fwdrec *)(*d).fwdrefs,mc_genss$getcurrdatalen((i64)4),(i64)2,mc_genss$currseg);
        if (((i64)(*d).nameid == (i64)12 || (i64)(*d).nameid == (i64)13)) {
            mc_genss$gendword(((i64)(*d).offset + (i64)(*a).offset));
        }
        else {
            mc_genss$gendword((i64)(*a).offset);
            mc_genss$addrelocitem((i64)2,d);
        }
;
    }
    else {
        mc_genss$gendword((i64)(*a).offset);
        mc_genss$addrelocitem((i64)2,d);
    }
    };
}

static void mc_genss$genabs64(struct mc_decls$opndrec *a) {
        struct mm_decls$strec *  d;
    d = mc_genss$getdef(a,(i64)1);
        {i64 $temp = (i64)(*d).reftype;
if (($temp==(i64)2)) {
        mc_genss$genqword(((i64)(*d).offset + (i64)(*a).offset));
        mc_genss$addrelocitem((i64)1,d);
    }
    else if (($temp==(i64)1)) {
        (*d).fwdrefs = (struct mm_decls$fwdrec *)mc_genss$addfwdref((struct mm_decls$fwdrec *)(*d).fwdrefs,mc_genss$getcurrdatalen((i64)5),(i64)1,mc_genss$currseg);
        if (((i64)(*d).nameid == (i64)12 || (i64)(*d).nameid == (i64)13)) {
            mc_genss$genqword(((i64)(*d).offset + (i64)(*a).offset));
        }
        else {
            mc_genss$genqword((i64)(*a).offset);
            mc_genss$addrelocitem((i64)1,d);
        }
;
    }
    else {
        mc_genss$genqword((i64)(*a).offset);
        mc_genss$addrelocitem((i64)1,d);
    }
    };
}

static i64 mc_genss$getrel32(struct mm_decls$strec *d,i64 offset) {
    if (((i64)(*d).reftype == (i64)2)) {
        if (((i64)(*d).segment != mc_genss$currseg)) {
            mm_support$axerror((byte*)"Rel label across segments2");
        }
;
        return ((i64)(*d).offset - (offset + (i64)1));
    }
    else {
        return (i64)2147483647;
    }
;
}

static void mc_genss$dofwdrefs(struct mm_decls$strec *d) {
        struct mm_decls$fwdrec *  f;
        i64 offset;
        byte *  p8;
        i32 *  p32;
        i64 *  p64;
        struct mc_decls$dbuffer *  data;
    if (((*d).fwdrefs == 0)) {
        return;
    }
;
    f = (struct mm_decls$fwdrec *)(*d).fwdrefs;
    L934 :;
    while (!!(f)) {
        offset = (i64)(*f).offset;
                {i64 $temp = (i64)(*f).reltype;
if (($temp==(i64)4)) {
            p32 = (i32 *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_genss$currdata,offset);
            (*p32) = (((i64)(*d).offset - offset) - (i64)4);
        }
        else if (($temp==(i64)2) || ($temp==(i64)1)) {
                        {i64 $temp = (i64)(*f).seg;
if (($temp==(i64)1)) {
                data = (struct mc_decls$dbuffer *)mc_decls$ss_code;
            }
            else if (($temp==(i64)3)) {
                mm_support$axerror((byte*)"Fwd ref in zdata");
            }
            else if (($temp==(i64)2)) {
                data = (struct mc_decls$dbuffer *)mc_decls$ss_idata;
            }
            };
            p32 = (i32 *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)data,offset);
            if (((i64)(*f).reltype == (i64)2)) {
                (*p32) = ((i64)(*p32) + (i64)(*d).offset);
            }
            else {
                p64 = (i64 *)p32;
                (*p64) = ((*p64) + (i64)(*d).offset);
            }
;
        }
        else if (($temp==(i64)6)) {
            p8 = (byte *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_genss$currdata,offset);
            (*p8) = (((i64)(*d).offset - offset) - (i64)1);
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(mc_objdecls$relocnames[((i64)(*f).reltype)],NULL);
            msysc$m_print_str((*d).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"DOFWDREFS/CAN'T DO RELTYPE");
        }
        };
        f = (struct mm_decls$fwdrec *)(*f).nextfwd;
L935 :;
    }
L936 :;
    ;
}

static void mc_genss$genrex(void) {
    if (!!(mc_genss$sizeoverride)) {
        (*((*mc_genss$currdata).pcurr)++) = (i64)102;
    }
;
    if (!!(mc_genss$addroverride)) {
        (*((*mc_genss$currdata).pcurr)++) = (i64)103;
    }
;
    if (!!(mc_genss$rex)) {
        if ((mc_genss$rex < (i64)64)) {
            (*((*mc_genss$currdata).pcurr)++) = ((i64)64 + mc_genss$rex);
        }
        else {
            (*((*mc_genss$currdata).pcurr)++) = mc_genss$rex;
        }
;
    }
;
}

static i64 mc_genss$isbytesized(i64 x) {
    return (i64)((i64)-128<=x && x<=(i64)127);
}

static i64 mc_genss$isdwordsized(i64 x) {
    return (i64)((i64)-2147483648<=x && x<=(i64)2147483647);
}

static void mc_genss$do_push(struct mc_decls$opndrec *a) {
        i64 code;
        i64 am;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
        if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != (i64)8)) {
            mm_support$axerror((byte*)"pushreg not 64-bit");
        }
;
        code = (i64)mc_decls$regcodes[((i64)(*a).reg)];
        if ((code >= (i64)8)) {
            mc_genss$rex = (i64)1;
            code &= (i64)7;
        }
;
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = ((i64)80 + code);
    }
    else if (($temp==(u64)3u)) {
        if (!!(mc_genss$getdef(a,(i64)0))) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)104;
            mc_genss$genopnd(a,(i64)4);
        }
        else if (!!(mc_genss$isbytesized((*a).value))) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)106;
            (*((*mc_genss$currdata).pcurr)++) = (*a).value;
        }
        else if (!!(mc_genss$isdwordsized((*a).value))) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)104;
            mc_genss$gendword((*a).value);
        }
        else {
            mm_support$axerror((byte*)"push imm value too large");
        }
;
    }
    else if (($temp==(u64)4u)) {
        if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != (i64)8)) {
            mm_support$axerror((byte*)"push not 64-bit");
        }
;
        am = mc_genss$genrm(a,(i64)6);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)255;
        mc_genss$genamode(a,am);
    }
    else {
        mm_support$axerror((byte*)"push opnd?");
    }
    };
}

static void mc_genss$do_pop(struct mc_decls$opndrec *a) {
        i64 code;
        i64 am;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
        if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != (i64)8)) {
            mm_support$axerror((byte*)"popreg not 64-bit");
        }
;
        code = (i64)mc_decls$regcodes[((i64)(*a).reg)];
        if ((code >= (i64)8)) {
            mc_genss$rex = (i64)1;
            code &= (i64)7;
        }
;
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = ((i64)88 + code);
    }
    else if (($temp==(u64)4u)) {
        if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != (i64)8)) {
            mm_support$axerror((byte*)"pop not 64-bit");
        }
;
        am = mc_genss$genrm(a,(i64)0);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)143;
        mc_genss$genamode(a,am);
    }
    else {
        mm_support$axerror((byte*)"pop opnd?");
    }
    };
}

static void mc_genss$do_inc(struct mc_decls$opndrec *a,i64 code) {
        i64 opc;
        i64 am;
    opc = (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) ? (i64)254 : (i64)255);
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u) || ($temp==(u64)4u)) {
        am = mc_genss$genrm(a,code);
        mc_genss$checkhighreg(a);
        mc_genss$setopsize(a);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = opc;
        mc_genss$genamode(a,am);
    }
    else {
        mm_support$axerror((byte*)"inc/opnd?");
    }
    };
}

static void mc_genss$do_neg(struct mc_decls$opndrec *a,i64 code) {
        i64 opc;
        i64 am;
    opc = (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) ? (i64)246 : (i64)247);
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u) || ($temp==(u64)4u)) {
        am = mc_genss$genrm(a,code);
        mc_genss$checkhighreg(a);
        mc_genss$setopsize(a);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = opc;
        mc_genss$genamode(a,am);
    }
    else {
        mm_support$axerror((byte*)"neg/div/etc opnd?");
    }
    };
}

static void mc_genss$genamode(struct mc_decls$opndrec *a,i64 am) {
        i64 sib;
        i64 mode;
        i64 dispsize;
        i64 offset;
    sib = (am >> (i64)16);
    mode = ((am >> (i64)8) & (i64)255);
    dispsize = (am & (i64)255);
    (*((*mc_genss$currdata).pcurr)++) = mode;
    if ((sib >= (i64)0)) {
        (*((*mc_genss$currdata).pcurr)++) = sib;
    }
;
    if ((dispsize==(i64)0)) {
    }
    else if ((dispsize==(i64)1)) {
        mc_genss$getdispsize(a,&offset);
        (*((*mc_genss$currdata).pcurr)++) = offset;
    }
    else if ((dispsize==(i64)4)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)4u)) {
                        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)6u) || ($temp==(u64)7u)) {
                mc_genss$genabs32(a);
            }
            else if (($temp==(u64)0u)) {
                mc_genss$getdispsize(a,&offset);
                mc_genss$gendword(offset);
            }
            else {
                mm_support$axerror((byte*)"genam/3");
            }
            };
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(mc_decls$opndnames[((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11))],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"GENAMODE/MODE?");
        }
        };
    }
    else {
        mm_support$axerror((byte*)"genamode size 2/8");
    }
;
}

static void mc_genss$setopsize(struct mc_decls$opndrec *a) {
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)1u)) {
    }
    else if (($temp==(u64)2u)) {
        mc_genss$sizeoverride = (i64)1;
    }
    else if (($temp==(u64)8u)) {
        mc_genss$rex |= (i64)8;
    }
    else if (($temp==(u64)4u)) {
    }
    else {
        mm_support$axerror((byte*)"Operand size not set");
    }
    };
}

static i64 mc_genss$getdispsize(struct mc_decls$opndrec *a,i64 *offset) {
        struct mm_decls$strec *  d;
    d = mc_genss$getdef(a,(i64)0);
    (*offset) = (i64)(*a).offset;
    if (!!(d)) {
        if (((i64)(*d).nameid == (i64)12 || (i64)(*d).nameid == (i64)13)) {
            (*offset) += (i64)(*d).offset;
        }
        else {
            return (i64)4;
        }
;
    }
;
    if (!!((*offset))) {
        if (!!(mc_genss$isbytesized((*offset)))) {
            return (i64)1;
        }
        else {
            return (i64)4;
        }
;
    }
    else {
        return (i64)0;
    }
;
}

static i64 mc_genss$genrm(struct mc_decls$opndrec *a,i64 opc) {
        static i64 scaletable6[8] = {(i64)0,(i64)64,(i64)0,(i64)128,(i64)0,(i64)0,(i64)0,(i64)192};
        i64 mode;
        i64 rm;
        i64 scale;
        i64 dispsize;
        i64 sib;
        i64 index;
        i64 base;
        i64 reg;
        i64 regix;
        i64 code;
        i64 offset;
    mode = (rm = (i64)0);
    scale = (i64)0;
    dispsize = (i64)0;
    sib = (i64)-1;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
        code = mc_genss$getregcodeb((i64)(*a).reg);
        return (((((sib << (i64)16) + (i64)49152) + (opc << (i64)11)) + (code << (i64)8)) + dispsize);
    }
    else if (($temp==(u64)4u)) {
    }
    else if (($temp==(u64)2u)) {
        code = mc_genss$getregcodebx((i64)(*a).reg);
        return (((((sib << (i64)16) + (i64)49152) + (opc << (i64)11)) + (code << (i64)8)) + dispsize);
    }
    else {
        mm_support$axerror((byte*)"genrm not mem");
    }
    };
    reg = (i64)(*a).reg;
    regix = (i64)(*a).regix;
    if ((reg==regix && regix==(i64)0)) {
        mode = (i64)0;
        rm = (i64)4;
        scale = (i64)1;
        index = (i64)4;
        base = (i64)5;
        dispsize = (i64)4;
    }
    else if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)4,(i64)7) <= (i64)1) && (regix == (i64)0))) {
        dispsize = mc_genss$getdispsize(a,&offset);
        if (!!(dispsize)) {
            mode = ((dispsize == (i64)1) ? (i64)1 : (i64)2);
        }
;
        rm = (i64)mc_decls$regcodes[(reg)];
        if (((rm != (i64)4) && (rm != (i64)12))) {
            base = rm;
            if ((((rm == (i64)5) || (rm == (i64)13)) && (dispsize == (i64)0))) {
                mode = (i64)1;
                dispsize = (i64)1;
            }
;
            index = (i64)0;
        }
        else {
            index = (i64)4;
            base = rm;
            scale = (i64)1;
        }
;
    }
    else if ((!!(regix) && (reg == (i64)0))) {
        dispsize = (i64)4;
        mode = (i64)0;
        rm = (i64)4;
        scale = (!!(msysc$m_getdotslice((i64)(*a).misc,(i64)4,(i64)7)) ? msysc$m_getdotslice((i64)(*a).misc,(i64)4,(i64)7) : (i64)1);
        base = (i64)5;
        index = (i64)mc_decls$regcodes[(regix)];
        if ((regix == (i64)16)) {
            mm_support$axerror((byte*)"Scaled rstack?");
        }
;
    }
    else {
        dispsize = mc_genss$getdispsize(a,&offset);
        if (!!(dispsize)) {
            mode = ((dispsize == (i64)1) ? (i64)1 : (i64)2);
        }
;
        rm = (i64)4;
        scale = (!!(msysc$m_getdotslice((i64)(*a).misc,(i64)4,(i64)7)) ? msysc$m_getdotslice((i64)(*a).misc,(i64)4,(i64)7) : (i64)1);
        if ((reg == (i64)0)) {
            base = (i64)5;
        }
        else {
            if (((reg == (i64)15 || reg == (i64)8) && (dispsize == (i64)0))) {
                mode = (i64)1;
                dispsize = (i64)1;
            }
;
            base = (i64)mc_decls$regcodes[(reg)];
        }
;
        if ((regix == (i64)0)) {
            index = (i64)4;
        }
        else {
            index = (i64)mc_decls$regcodes[(regix)];
            if (!(!!(reg))) {
                dispsize = (i64)4;
            }
;
            if (((regix == (i64)16) && (scale > (i64)1))) {
                mm_support$axerror((byte*)"Can't scale rstack");
            }
;
        }
;
    }
;
    if ((index >= (i64)8)) {
        mc_genss$rex |= (i64)2;
        index &= (i64)7;
    }
;
    if ((base >= (i64)8)) {
        mc_genss$rex |= (i64)1;
        base &= (i64)7;
    }
;
    if (!!(scale)) {
        sib = ((scaletable6[(scale)-1] + (index << (i64)3)) + base);
    }
;
    rm &= (i64)7;
    return (((((sib << (i64)16) + (mode << (i64)14)) + (opc << (i64)11)) + (rm << (i64)8)) + dispsize);
}

static i64 mc_genss$makeam(i64 m,i64 s,i64 d) {
    return (((s << (i64)16) + (m << (i64)8)) + d);
}

static i64 mc_genss$makemodrm(i64 mode,i64 opc,i64 rm) {
    return (((mode << (i64)6) + (opc << (i64)3)) + rm);
}

static void mc_genss$do_arith(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 code) {
        i64 am;
        i64 regcode;
        i64 opc;
        i64 dispsize;
        i64 x;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)1u) || ($temp==(u64)4u)) {
            regcode = mc_genss$getregcoder((i64)(*a).reg);
            am = mc_genss$genrm(b,regcode);
            mc_genss$checkhighreg(a);
            mc_genss$checkhighreg(b);
            mc_genss$setopsize(a);
            opc = ((code << (i64)3) | (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) ? (i64)2 : (i64)3));
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = opc;
            mc_genss$genamode(b,am);
        }
        else if (($temp==(u64)3u)) {
            //doregimm:
L937 :;
;
            if (!!(mc_genss$getdef(b,(i64)0))) {
                if (((code < (i64)0) || (code > (i64)7))) {
                    mm_support$axerror((byte*)"non-add arith/label");
                }
;
                if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) < (i64)4)) {
                    mm_support$axerror((byte*)"add imm/size");
                }
;
                am = mc_genss$genrm(a,code);
                mc_genss$setopsize(a);
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = (i64)129;
                mc_genss$genamode(a,am);
                mc_genss$genopnd(b,(i64)4);
                return;
            }
;
            x = (*b).value;
            dispsize = (i64)1;
            if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1)) {
                opc = (i64)128;
            }
            else if (((i64)-128<=x && x<=(i64)127)) {
                opc = (i64)131;
            }
            else {
                if (!(((i64)-2147483648<=x && x<=(i64)4294967295))) {
                    mm_support$axerror((byte*)"3:exceeding word32 value");
                }
;
                opc = (i64)129;
                dispsize = (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)2) ? (i64)2 : (i64)4);
            }
;
            am = mc_genss$genrm(a,code);
            mc_genss$checkhighreg(a);
            mc_genss$setopsize(a);
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = opc;
            mc_genss$genamode(a,am);
            if ((dispsize==(i64)1)) {
                (*((*mc_genss$currdata).pcurr)++) = x;
            }
            else if ((dispsize==(i64)2)) {
                mc_genss$genword(x);
            }
            else if ((dispsize==(i64)4)) {
                mc_genss$gendword(x);
            }
;
        }
        else {
            mm_support$axerror((byte*)"ADD reg,???");
        }
        };
    }
    else if (($temp==(u64)4u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
            regcode = mc_genss$getregcoder((i64)(*b).reg);
            am = mc_genss$genrm(a,regcode);
            mc_genss$checkhighreg(b);
            mc_genss$setopsize(b);
            opc = ((code << (i64)3) | (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)1) ? (i64)0 : (i64)1));
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = opc;
            mc_genss$genamode(a,am);
        }
        else if (($temp==(u64)3u)) {
            goto L937 ;
;
        }
        else {
            mm_support$axerror((byte*)"ADD mem,???");
        }
        };
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(mc_decls$opndnames[((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11))],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$axerror((byte*)"Can't add to this opnd");
    }
    };
}

static void mc_genss$do_mov(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        i64 regcode;
        i64 am;
        i64 value;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)1u) || ($temp==(u64)4u)) {
            if (((msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)) && !!(msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)))) {
                mm_support$axerror((byte*)"1:Opnd size mismatch");
            }
;
            mc_genss$checkhighreg(a);
            mc_genss$checkhighreg(b);
            regcode = mc_genss$getregcoder((i64)(*a).reg);
            am = mc_genss$genrm(b,regcode);
            mc_genss$setopsize(a);
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) ? (i64)138 : (i64)139);
            mc_genss$genamode(b,am);
        }
        else if (($temp==(u64)3u)) {
            value = (*b).value;
            regcode = mc_genss$getregcodeb((i64)(*a).reg);
            if ((!!(mc_genss$getdef(b,(i64)0)) && ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) <= (i64)2))) {
                mm_support$axerror((byte*)"mov imm?");
            }
;
                        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)1u)) {
                mc_genss$checkhighreg(a);
                                {i64 $temp = (i64)(*a).reg;
if (($temp==(i64)6) || ($temp==(i64)4) || ($temp==(i64)15) || ($temp==(i64)16)) {
                    mc_genss$rex |= (i64)64;
                }
                };
                if (!(((i64)-128<=value && value<=(i64)255))) {
                    mm_support$axerror((byte*)"exceeding byte value");
                }
;
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = ((i64)176 + regcode);
                (*((*mc_genss$currdata).pcurr)++) = value;
            }
            else if (($temp==(u64)2u)) {
                if (!(((i64)-32768<=value && value<=(i64)65535))) {
                    mm_support$axerror((byte*)"exceeding word16 value");
                }
;
                (*((*mc_genss$currdata).pcurr)++) = (i64)102;
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = ((i64)184 + regcode);
                mc_genss$genword(value);
            }
            else if (($temp==(u64)4u)) {
                if (!!(mc_genss$getdef(b,(i64)0))) {
                    mc_genss$genrex();
                    (*((*mc_genss$currdata).pcurr)++) = ((i64)184 + regcode);
                    mc_genss$genopnd(b,(i64)4);
                }
                else {
                    if (!(((i64)-2147483648<=value && value<=(i64)(u32)(i64)4294967295))) {
                        msysc$m_print_startcon();
                        msysc$m_print_i64(value,NULL);
                        msysc$m_print_ptr((void *)value,NULL);
                        msysc$m_print_newline();
                        msysc$m_print_end();
                        ;
                        mm_support$axerror((byte*)"1:exceeding word32 value");
                    }
;
                    //doreg32:
L938 :;
;
                    mc_genss$genrex();
                    (*((*mc_genss$currdata).pcurr)++) = ((i64)184 + regcode);
                    mc_genss$gendword(value);
                }
;
            }
            else {
                if (!!(mc_genss$getdef(b,(i64)0))) {
                    mc_genss$rex |= (i64)8;
                    mc_genss$genrex();
                    (*((*mc_genss$currdata).pcurr)++) = ((i64)184 + regcode);
                    mc_genss$genopnd(b,(i64)8);
                }
                else {
                    if (((value >= (i64)0) && (value <= (i64)4294967295))) {
                        goto L938 ;
;
                    }
;
                    mc_genss$rex |= (i64)8;
                    mc_genss$genrex();
                    (*((*mc_genss$currdata).pcurr)++) = ((i64)184 + regcode);
                    mc_genss$genqword(value);
                }
;
            }
            };
        }
        else {
            mm_support$axerror((byte*)"MOV REG/??");
        }
        };
    }
    else if (($temp==(u64)4u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
            if (((msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)) && !!(msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3)))) {
                msysc$m_print_startcon();
                msysc$m_print_u64(msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3),NULL);
                msysc$m_print_u64(msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3),NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                mm_support$axerror((byte*)"2:Opnd size mismatch");
            }
;
            regcode = mc_genss$getregcoder((i64)(*b).reg);
            mc_genss$checkhighreg(b);
            am = mc_genss$genrm(a,regcode);
            mc_genss$setopsize(b);
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)1) ? (i64)136 : (i64)137);
            mc_genss$genamode(a,am);
        }
        else if (($temp==(u64)3u)) {
            value = (*b).value;
            am = mc_genss$genrm(a,(i64)0);
            if ((!!(mc_genss$getdef(b,(i64)0)) && ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) <= (i64)2))) {
                mm_support$axerror((byte*)"mov imm?");
            }
;
            if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)0)) {
                (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)1u);
            }
;
                        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)0u) || ($temp==(u64)1u)) {
                if (!(((i64)-128<=value && value<=(i64)255))) {
                    mm_support$axerror((byte*)"exceeding byte value");
                }
;
                mc_genss$setopsize(a);
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = (i64)198;
                mc_genss$genamode(a,am);
                (*((*mc_genss$currdata).pcurr)++) = value;
            }
            else if (($temp==(u64)2u)) {
                if (!(((i64)-32768<=value && value<=(i64)65535))) {
                    mm_support$axerror((byte*)"exceeding word16 value");
                }
;
                mc_genss$setopsize(a);
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = (i64)199;
                mc_genss$genamode(a,am);
                mc_genss$genword(value);
            }
            else if (($temp==(u64)4u) || ($temp==(u64)8u)) {
                if (!(!!(mc_genss$getdef(b,(i64)0)))) {
                    if (!(((i64)-2147483648<=value && value<=(i64)4294967295))) {
                        mm_support$axerror((byte*)"2:exceeding word32 value");
                    }
;
                }
;
                mc_genss$setopsize(a);
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = (i64)199;
                mc_genss$genamode(a,am);
                mc_genss$genopnd(b,(i64)4);
            }
            };
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(mc_decls$opndnames[((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11))],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            msysc$m_print_startcon();
            msysc$m_print_str(mc_decls$opndnames[((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11))],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"MOV MEM/?");
        }
        };
    }
    else {
        mm_support$axerror((byte*)"MOV ?/..");
    }
    };
}

static i64 mc_genss$getregcoder(i64 reg) {
        i64 regcode;
    regcode = (i64)mc_decls$regcodes[(reg)];
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        mc_genss$rex |= (i64)4;
    }
;
    return regcode;
}

static i64 mc_genss$getregcodeb(i64 reg) {
        i64 regcode;
    regcode = (i64)mc_decls$regcodes[(reg)];
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        mc_genss$rex |= (i64)1;
    }
;
    return regcode;
}

static i64 mc_genss$getregcodebx(i64 reg) {
        i64 regcode;
    regcode = (i64)mc_decls$regcodes[(reg)];
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        mc_genss$rex |= (i64)1;
    }
;
    return regcode;
}

static i64 mc_genss$getregcoderx(i64 reg) {
        i64 regcode;
    regcode = (i64)mc_decls$regcodes[(reg)];
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        mc_genss$rex |= (i64)4;
    }
;
    return regcode;
}

static void mc_genss$do_lea(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        i64 regcode;
        i64 am;
    if (!((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)1) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)4)))) {
        mm_support$axerror((byte*)"LEA not reg/mem");
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) < (i64)4)) {
        mm_support$axerror((byte*)"LEA size error");
    }
;
    regcode = mc_genss$getregcoder((i64)(*a).reg);
    am = mc_genss$genrm(b,regcode);
    mc_genss$setopsize(a);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)141;
    mc_genss$genamode(b,am);
}

static void mc_genss$do_movsx(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc) {
        i64 am;
        i64 regcode;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)1)) {
        mm_support$axerror((byte*)"movsx not reg");
    }
;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)8) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)4))) {
        if ((opc == (i64)190)) {
            mc_genss$do_movsxd(a,b);
        }
        else {
            a = mc_decls$regtable[((i64)(*a).reg)-1][((i64)4)-1];
            mc_genss$do_mov(a,b);
        }
;
        return;
    }
;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) || (msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) <= msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)))) {
        mm_support$axerror((byte*)"movsx size error");
    }
;
    if (((opc == (i64)182) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)4))) {
        mm_support$axerror((byte*)"movsx 4=>8 bytes?");
    }
;
        {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
    }
    else if (($temp==(u64)4u)) {
        if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)0)) {
            mm_support$axerror((byte*)"movsx need size prefix");
        }
;
        if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)8)) {
            mm_support$axerror((byte*)"movsx size 8");
        }
;
    }
    else {
        mm_support$axerror((byte*)"movsx not reg/mem");
    }
    };
    regcode = mc_genss$getregcoder((i64)(*a).reg);
    am = mc_genss$genrm(b,regcode);
    mc_genss$setopsize(a);
    mc_genss$checkhighreg(b);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
    (*((*mc_genss$currdata).pcurr)++) = (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)1) ? opc : (opc + (i64)1));
    mc_genss$genamode(b,am);
}

static void mc_genss$checkhighreg(struct mc_decls$opndrec *a) {
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)1)) {
                {i64 $temp = (i64)(*a).reg;
if (($temp==(i64)6) || ($temp==(i64)4) || ($temp==(i64)15) || ($temp==(i64)16)) {
            mc_genss$rex |= (i64)64;
        }
        };
    }
;
}

static void mc_genss$do_exch(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        i64 regcode;
        i64 am;
    if ((((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)1) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)1)) && (((i64)(*a).reg == (i64)1) || ((i64)(*b).reg == (i64)1))) && ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != (i64)1))) {
        if (((i64)(*a).reg != (i64)1)) {
            {struct mc_decls$opndrec *  temp = a; a = b; b = temp; };
        }
;
        if ((msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3))) {
            mm_support$axerror((byte*)"exch size");
        }
;
        mc_genss$setopsize(a);
        regcode = mc_genss$getregcodeb((i64)(*b).reg);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = ((i64)144 + regcode);
        return;
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)4)) {
        {struct mc_decls$opndrec *  temp = a; a = b; b = temp; };
    }
;
    if (!((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)1) && (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)1) || ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)4))))) {
        mm_support$axerror((byte*)"exch opnds");
    }
;
    if ((((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)0) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)4))) {
        (*b).misc = msysc$m_setdotslice((*b).misc,(i64)0,(i64)3,msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3));
    }
;
    if ((msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3))) {
        mm_support$axerror((byte*)"exch size");
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1)) {
        mc_genss$checkhighreg(a);
        mc_genss$checkhighreg(b);
    }
;
    regcode = mc_genss$getregcoder((i64)(*a).reg);
    am = mc_genss$genrm(b,regcode);
    mc_genss$setopsize(a);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) ? (i64)134 : (i64)135);
    mc_genss$genamode(b,am);
}

static void mc_genss$do_movsxd(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        i64 regcode;
        i64 am;
    if ((((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)4) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)0))) {
        (*b).misc = msysc$m_setdotslice((*b).misc,(i64)0,(i64)3,(u64)4u);
    }
;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != (i64)8) || ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) > (i64)4))) {
        mm_support$axerror((byte*)"movsxd size");
    }
;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)1) || (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)1) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)4)))) {
        mm_support$axerror((byte*)"movsxd opnds");
    }
;
    regcode = mc_genss$getregcoder((i64)(*a).reg);
    am = mc_genss$genrm(b,regcode);
    mc_genss$setopsize(a);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)99;
    mc_genss$genamode(b,am);
}

static void mc_genss$do_imul2(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        i64 regcode;
        i64 am;
        i64 opc;
        i64 value;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)1)) {
        mm_support$axerror((byte*)"imul2 opnds");
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)0)) {
        (*b).misc = msysc$m_setdotslice((*b).misc,(i64)0,(i64)3,msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3));
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1)) {
        mm_support$axerror((byte*)"imul2 byte");
    }
;
        {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)1u) || ($temp==(u64)4u)) {
        if ((msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3))) {
            mm_support$axerror((byte*)"imul2 size");
        }
;
        regcode = mc_genss$getregcoder((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        mc_genss$setopsize(a);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)15;
        (*((*mc_genss$currdata).pcurr)++) = (i64)175;
        mc_genss$genamode(b,am);
    }
    else if (($temp==(u64)3u)) {
        if (!!(mc_genss$getdef(b,(i64)0))) {
            mm_support$axerror((byte*)"mul/label");
        }
;
        value = (*b).value;
        regcode = mc_genss$getregcoder((i64)(*a).reg);
        regcode = mc_genss$getregcodeb((i64)(*a).reg);
        opc = (((i64)192 + (regcode << (i64)3)) + regcode);
        mc_genss$setopsize(a);
        mc_genss$genrex();
        if (((i64)-128<=value && value<=(i64)127)) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)107;
            (*((*mc_genss$currdata).pcurr)++) = opc;
            (*((*mc_genss$currdata).pcurr)++) = value;
        }
        else if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)2)) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)105;
            (*((*mc_genss$currdata).pcurr)++) = opc;
            mc_genss$genword(value);
        }
        else {
            (*((*mc_genss$currdata).pcurr)++) = (i64)105;
            (*((*mc_genss$currdata).pcurr)++) = opc;
            mc_genss$gendword(value);
        }
;
    }
    else {
        mm_support$axerror((byte*)"imul2 opnds");
    }
    };
}

static void mc_genss$do_shift(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc) {
        i64 am;
        i64 w;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)1) && ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)4))) {
        mm_support$axerror((byte*)"shift opnds1?");
    }
;
    am = mc_genss$genrm(a,opc);
    mc_genss$checkhighreg(a);
    mc_genss$setopsize(a);
    mc_genss$genrex();
    w = (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) ? (i64)0 : (i64)1);
        {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)3u)) {
        if (!!(mc_genss$getdef(b,(i64)0))) {
            mm_support$axerror((byte*)"shift/label");
        }
;
        if (((*b).value == (i64)1)) {
            (*((*mc_genss$currdata).pcurr)++) = ((i64)208 + w);
            mc_genss$genamode(a,am);
        }
        else {
            (*((*mc_genss$currdata).pcurr)++) = ((i64)192 + w);
            mc_genss$genamode(a,am);
            (*((*mc_genss$currdata).pcurr)++) = (*b).value;
        }
;
    }
    else if (($temp==(u64)1u)) {
        if ((((i64)(*b).reg != (i64)11) || ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) != (i64)1))) {
            mm_support$axerror((byte*)"cl or b10 needed");
        }
;
        (*((*mc_genss$currdata).pcurr)++) = ((i64)210 + w);
        mc_genss$genamode(a,am);
    }
    else {
        mm_support$axerror((byte*)"shift opnds2?");
    }
    };
}

static void mc_genss$do_test(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        i64 value;
        i64 opc;
        i64 am;
        i64 regcode;
    if (((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)1) && ((i64)(*a).reg == (i64)1)) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)3))) {
        value = (*b).value;
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)1u)) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)168;
            (*((*mc_genss$currdata).pcurr)++) = value;
        }
        else if (($temp==(u64)2u)) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)102;
            (*((*mc_genss$currdata).pcurr)++) = (i64)169;
            mc_genss$genword(value);
        }
        else if (($temp==(u64)4u)) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)169;
            mc_genss$gendword(value);
        }
        else {
            (*((*mc_genss$currdata).pcurr)++) = (i64)72;
            (*((*mc_genss$currdata).pcurr)++) = (i64)169;
            mc_genss$gendword(value);
        }
        };
    }
    else if (((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)1) || ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)4)) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)3))) {
        opc = (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) ? (i64)246 : (i64)247);
        value = (*b).value;
        am = mc_genss$genrm(a,(i64)0);
        mc_genss$checkhighreg(a);
        mc_genss$setopsize(a);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = opc;
        mc_genss$genamode(a,am);
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)1u)) {
            (*((*mc_genss$currdata).pcurr)++) = value;
        }
        else if (($temp==(u64)2u)) {
            mc_genss$genword(value);
        }
        else {
            mc_genss$gendword(value);
        }
        };
    }
    else if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)1) && (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)1) || ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)4)))) {
        //doregmem:
L939 :;
;
        regcode = mc_genss$getregcoder((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        mc_genss$checkhighreg(a);
        mc_genss$checkhighreg(b);
        mc_genss$setopsize(a);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1) ? (i64)132 : (i64)133);
        mc_genss$genamode(b,am);
    }
    else if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)4) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)1))) {
        {struct mc_decls$opndrec *  temp = a; a = b; b = temp; };
        goto L939 ;
;
    }
    else {
        mm_support$axerror((byte*)"test opnds");
    }
;
}

static void mc_genss$do_loop(struct mc_decls$opndrec *a,i64 opc) {
        i64 offset;
    offset = mc_genss$getrel32(mc_genss$getdef(a,(i64)1),(mc_genss$getcurrdatalen((i64)9) + (i64)1));
    if ((offset < (i64)0)) {
        if ((offset < (i64)-126)) {
            mm_support$axerror((byte*)"loop jmp out of range");
        }
;
        (*((*mc_genss$currdata).pcurr)++) = opc;
        (*((*mc_genss$currdata).pcurr)++) = offset;
    }
    else {
        mm_support$axerror((byte*)"Can't do loopxx fwd jump");
    }
;
}

static void mc_genss$do_jcxz(struct mc_decls$opndrec *a,i64 opsize) {
        i64 offset;
    offset = mc_genss$getrel32(mc_genss$getdef(a,(i64)1),(mc_genss$getcurrdatalen((i64)10) + (i64)1));
    if ((offset < (i64)0)) {
        if ((offset < (i64)-126)) {
            mm_support$axerror((byte*)"jcxz jmp out of range");
        }
;
        if ((opsize == (i64)4)) {
            (*((*mc_genss$currdata).pcurr)++) = (i64)103;
        }
;
        (*((*mc_genss$currdata).pcurr)++) = (i64)227;
        (*((*mc_genss$currdata).pcurr)++) = offset;
    }
    else {
        mm_support$axerror((byte*)"Can't do jcxz fwd jump");
    }
;
}

static void mc_genss$do_setcc(i64 cond,struct mc_decls$opndrec *a) {
        i64 am;
    if (((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)1) && ((i64)(*a).reg != (i64)4)) || ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) > (i64)1))) {
        mm_support$axerror((byte*)"setcc opnd/size");
    }
;
    am = mc_genss$genrm(a,(i64)0);
    mc_genss$checkhighreg(a);
    mc_genss$genrex();
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
    (*((*mc_genss$currdata).pcurr)++) = ((i64)144 + cond);
    mc_genss$genamode(a,am);
}

static void mc_genss$do_movxmm(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 size) {
        i64 am;
        i64 regcode;
        i64 regcode1;
        i64 regcode2;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)2u)) {
            if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != size)) {
                mm_support$axerror((byte*)"1:movdq size");
            }
;
            regcode = mc_genss$getregcoderx((i64)(*b).reg);
            am = mc_genss$genrm(a,regcode);
            mc_genss$setopsize(a);
            (*((*mc_genss$currdata).pcurr)++) = (i64)102;
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = (i64)15;
            (*((*mc_genss$currdata).pcurr)++) = (i64)126;
            mc_genss$genamode(b,am);
        }
        else {
            mm_support$axerror((byte*)"movdq reg,?");
        }
        };
    }
    else if (($temp==(u64)2u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
            if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) != size)) {
                mm_support$axerror((byte*)"3:movdq size");
            }
;
            regcode = mc_genss$getregcoderx((i64)(*a).reg);
            am = mc_genss$genrm(b,regcode);
            mc_genss$setopsize(b);
            (*((*mc_genss$currdata).pcurr)++) = (i64)102;
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = (i64)15;
            (*((*mc_genss$currdata).pcurr)++) = (i64)110;
            mc_genss$genamode(a,am);
        }
        else if (($temp==(u64)2u)) {
            regcode1 = mc_genss$getregcoderx((i64)(*a).reg);
            regcode2 = mc_genss$getregcodebx((i64)(*b).reg);
            (*((*mc_genss$currdata).pcurr)++) = (i64)243;
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = (i64)15;
            (*((*mc_genss$currdata).pcurr)++) = (i64)126;
            (*((*mc_genss$currdata).pcurr)++) = (((i64)192 + (regcode1 << (i64)3)) + regcode2);
        }
        else if (($temp==(u64)4u)) {
            if ((!!(msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) != size))) {
                mm_support$axerror((byte*)"4:movdq size");
            }
;
            regcode = mc_genss$getregcoderx((i64)(*a).reg);
            am = mc_genss$genrm(b,regcode);
            if ((size == (i64)4)) {
                (*((*mc_genss$currdata).pcurr)++) = (i64)102;
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = (i64)15;
                (*((*mc_genss$currdata).pcurr)++) = (i64)110;
            }
            else {
                (*((*mc_genss$currdata).pcurr)++) = (i64)243;
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = (i64)15;
                (*((*mc_genss$currdata).pcurr)++) = (i64)126;
            }
;
            mc_genss$genamode(b,am);
        }
        else {
            mm_support$axerror((byte*)"movdq xreg,?");
        }
        };
    }
    else if (($temp==(u64)4u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)2u)) {
            if ((!!(msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3)) && ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != size))) {
                mm_support$axerror((byte*)"5:movdq size");
            }
;
            regcode = mc_genss$getregcoderx((i64)(*b).reg);
            am = mc_genss$genrm(a,regcode);
            if ((size == (i64)4)) {
                (*((*mc_genss$currdata).pcurr)++) = (i64)102;
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = (i64)15;
                (*((*mc_genss$currdata).pcurr)++) = (i64)126;
            }
            else {
                (*((*mc_genss$currdata).pcurr)++) = (i64)102;
                mc_genss$genrex();
                (*((*mc_genss$currdata).pcurr)++) = (i64)15;
                (*((*mc_genss$currdata).pcurr)++) = (i64)214;
            }
;
            mc_genss$genamode(a,am);
        }
        else {
            mm_support$axerror((byte*)"movdq mem,?");
        }
        };
    }
    else {
        mm_support$axerror((byte*)"movdq opnds");
    }
    };
}

static void mc_genss$do_arithxmm(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 prefix,i64 opc) {
        i64 am;
        i64 regcode;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)2) || (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)2) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)4)))) {
        mm_support$axerror((byte*)"arithxmm opnds");
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)2)) {
        regcode = mc_genss$getregcoderx((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        if (!!(prefix)) {
            (*((*mc_genss$currdata).pcurr)++) = prefix;
        }
;
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)15;
        (*((*mc_genss$currdata).pcurr)++) = opc;
        mc_genss$genamode(a,am);
    }
    else {
        regcode = mc_genss$getregcoderx((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        if (!!(prefix)) {
            (*((*mc_genss$currdata).pcurr)++) = prefix;
        }
;
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)15;
        (*((*mc_genss$currdata).pcurr)++) = opc;
        mc_genss$genamode(b,am);
    }
;
}

static void mc_genss$do_logicxmm(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc,i64 size) {
        i64 am;
        i64 regcode;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)2) || (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)2) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)4)))) {
        mm_support$axerror((byte*)"logicxmm opnds");
    }
;
    if ((size == (i64)8)) {
        (*((*mc_genss$currdata).pcurr)++) = (i64)102;
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)2)) {
        regcode = mc_genss$getregcoderx((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)15;
        (*((*mc_genss$currdata).pcurr)++) = opc;
        mc_genss$genamode(b,am);
    }
    else {
        regcode = mc_genss$getregcoderx((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)15;
        (*((*mc_genss$currdata).pcurr)++) = opc;
        mc_genss$genamode(b,am);
    }
;
}

static void mc_genss$do_convertfloat(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 prefix) {
        i64 am;
        i64 regcode;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)2) || (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)2) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)4)))) {
        mm_support$axerror((byte*)"convertfloat opnds");
    }
;
    (*((*mc_genss$currdata).pcurr)++) = prefix;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)2)) {
        regcode = mc_genss$getregcoderx((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)15;
        (*((*mc_genss$currdata).pcurr)++) = (i64)90;
        mc_genss$genamode(b,am);
    }
    else {
        regcode = mc_genss$getregcoderx((i64)(*b).reg);
        am = mc_genss$genrm(a,regcode);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)15;
        (*((*mc_genss$currdata).pcurr)++) = (i64)90;
        mc_genss$genamode(b,am);
    }
;
}

static void mc_genss$do_fix(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 prefix,i64 opc) {
        i64 am;
        i64 regcode;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)1) || (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)2) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)4)))) {
        mm_support$axerror((byte*)"fix opnds");
    }
;
    (*((*mc_genss$currdata).pcurr)++) = prefix;
    if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)2)) {
        regcode = mc_genss$getregcoder((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        mc_genss$setopsize(a);
    }
    else {
        regcode = mc_genss$getregcoder((i64)(*a).reg);
        am = mc_genss$genrm(b,regcode);
        mc_genss$setopsize(a);
    }
;
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
    (*((*mc_genss$currdata).pcurr)++) = opc;
    mc_genss$genamode(b,am);
}

static void mc_genss$do_float(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 prefix) {
        i64 am;
        i64 regcode;
    if ((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)2) || (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)1) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) != (i64)4)))) {
        mm_support$axerror((byte*)"float opnds");
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)4)) {
        if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)0)) {
            (*b).misc = msysc$m_setdotslice((*b).misc,(i64)0,(i64)3,(u64)4u);
        }
;
        if ((((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) != (i64)4) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) != (i64)8))) {
            mm_support$axerror((byte*)"float size");
        }
;
    }
;
    (*((*mc_genss$currdata).pcurr)++) = prefix;
    regcode = mc_genss$getregcoderx((i64)(*a).reg);
    am = mc_genss$genrm(b,regcode);
    mc_genss$setopsize(b);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
    (*((*mc_genss$currdata).pcurr)++) = (i64)42;
    mc_genss$genamode(b,am);
}

static void mc_genss$do_call(struct mc_decls$opndrec *a) {
        i64 am;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)3u)) {
        (*((*mc_genss$currdata).pcurr)++) = (i64)232;
        mc_genss$genrel32(a);
    }
    else {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)0u)) {
            (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)8u);
        }
        else if (($temp==(u64)1u) || ($temp==(u64)2u) || ($temp==(u64)4u)) {
            mm_support$axerror((byte*)"call[]size");
        }
        };
        am = mc_genss$genrm(a,(i64)2);
        mc_genss$setopsize(a);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)255;
        mc_genss$genamode(a,am);
    }
    };
}

static void mc_genss$do_jmp(struct mc_decls$opndrec *a,struct mc_decls$mclrec *m) {
        i64 am;
        i64 offset;
        i64 shortjmp;
        struct mm_decls$strec *  d;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)3u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)7u) || ($temp==(u64)6u)) {
            d = mc_genss$getdef(a,(i64)1);
            offset = (mc_genss$getrel32(d,(mc_genss$getcurrdatalen((i64)11) + (i64)1)) + (i64)(*a).offset);
            if (((offset < (i64)0) && (offset > (i64)-126))) {
                (*((*mc_genss$currdata).pcurr)++) = (i64)235;
                (*((*mc_genss$currdata).pcurr)++) = offset;
            }
            else {
                shortjmp = (i64)0;
                if ((offset > (i64)0)) {
                    shortjmp = mc_genss$checkshortjump((struct mc_decls$mclrec *)m,d);
                }
;
                if (!(!!(shortjmp))) {
                    (*((*mc_genss$currdata).pcurr)++) = (i64)233;
                    mc_genss$genrel32(a);
                }
                else {
                    (*((*mc_genss$currdata).pcurr)++) = (i64)235;
                    mc_genss$genrel8(a);
                }
;
            }
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(mc_decls$valtypenames[((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15))],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"JMP/IMM NOT LABELNO");
        }
        };
    }
    else {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)0u)) {
            (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)8u);
        }
        else if (($temp==(u64)1u) || ($temp==(u64)2u) || ($temp==(u64)4u)) {
            mm_support$axerror((byte*)"jmp[]size");
        }
        };
        am = mc_genss$genrm(a,(i64)4);
        mc_genss$setopsize(a);
        mc_genss$genrex();
        (*((*mc_genss$currdata).pcurr)++) = (i64)255;
        mc_genss$genamode(a,am);
    }
    };
}

static i64 mc_genss$getcurrdatalen(i64 id) {
    if ((mc_genss$currseg == (i64)3)) {
        return mc_decls$ss_zdatalen;
    }
;
    return mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_genss$currdata);
}

static void mc_genss$do_cmovcc(i64 cond,struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        i64 am;
        i64 regcode;
    if (((msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)) && !!(msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)))) {
        mm_support$axerror((byte*)"3:Opnd size mismatch");
    }
;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)1)) {
        mm_support$axerror((byte*)"cmov/byte");
    }
;
    regcode = mc_genss$getregcoder((i64)(*a).reg);
    am = mc_genss$genrm(b,regcode);
    mc_genss$setopsize(a);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
    (*((*mc_genss$currdata).pcurr)++) = ((i64)64 + cond);
    mc_genss$genamode(b,am);
}

static void mc_genss$do_fmem(struct mc_decls$opndrec *a,i64 freal,i64 code) {
        i64 am;
        i64 mf;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)4)) {
        mm_support$axerror((byte*)"fmem/not mem");
    }
;
    if (!!(freal)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)4u)) {
            mf = (i64)0;
        }
        else if (($temp==(u64)8u)) {
            mf = (i64)2;
        }
        else if (($temp==(u64)16u)) {
            mf = (i64)1;
            if ((code==(i64)0)) {
                code = (i64)5;
            }
            else if ((code==(i64)3)) {
                code = (i64)7;
            }
            else {
                mm_support$axerror((byte*)"r80 not allowed");
            }
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"SIZE=",NULL);
            msysc$m_print_u64(msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3),NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"fmem size");
        }
        };
    }
    else {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3);
if (($temp==(u64)2u)) {
            mf = (i64)3;
        }
        else if (($temp==(u64)4u)) {
            mf = (i64)1;
        }
        else if (($temp==(u64)8u)) {
            mf = (i64)3;
            if ((code==(i64)0)) {
                code = (i64)5;
            }
            else if ((code==(i64)3)) {
                code = (i64)7;
            }
            else {
                mm_support$axerror((byte*)"fst i64?");
            }
;
        }
        else {
            mm_support$axerror((byte*)"fmem int size");
        }
        };
    }
;
    am = mc_genss$genrm(a,code);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = ((i64)217 + (mf << (i64)1));
    mc_genss$genamode(a,am);
}

static void mc_genss$genrel8(struct mc_decls$opndrec *a) {
        struct mm_decls$strec *  d;
    d = mc_genss$getdef(a,(i64)1);
    if (((i64)(*d).reftype == (i64)1)) {
        (*d).fwdrefs = (struct mm_decls$fwdrec *)mc_genss$addfwdref((struct mm_decls$fwdrec *)(*d).fwdrefs,mc_genss$getcurrdatalen((i64)3),(i64)6,(i64)0);
        (*((*mc_genss$currdata).pcurr)++) = (i64)0;
    }
    else {
        mm_support$axerror((byte*)"genrel8");
    }
;
}

static i64 mc_genss$checkshortjump(struct mc_decls$mclrec *m,struct mm_decls$strec *d) {
        i64 n;
    n = (i64)0;
    m = (struct mc_decls$mclrec *)(*m).nextmcl;
    L940 :;
    while ((!!(m) && (n <= (i64)8))) {
                {i64 $temp = (i64)(*m).opcode;
if (($temp==(i64)11)) {
            if (((*(*m).a).labelno == (i64)(*d).labelno)) {
                return (i64)1;
            }
;
        }
        else if (($temp==(i64)4) || ($temp==(i64)5) || ($temp==(i64)6)) {
        }
        else {
            ++(n);
        }
        };
        m = (struct mc_decls$mclrec *)(*m).nextmcl;
L941 :;
    }
L942 :;
    ;
    return (i64)0;
}

static struct mm_decls$fwdrec *mc_genss$addfwdref(struct mm_decls$fwdrec *p,i64 offset,i64 reltype,i64 seg) {
        struct mm_decls$fwdrec *  q;
    q = (struct mm_decls$fwdrec *)mlib$pcm_alloc((i64)16);
    (*q).nextfwd = (struct mm_decls$fwdrec *)p;
    (*q).offset = offset;
    (*q).reltype = reltype;
    (*q).seg = seg;
    return (struct mm_decls$fwdrec *)q;
}

static void mc_genss$switchseg(i64 newseg) {
    if ((newseg == mc_genss$currseg)) {
        return;
    }
;
    if ((mc_genss$currseg==(i64)1)) {
        mc_decls$ss_coderelocs = (struct mc_decls$relocrec *)mc_genss$currrelocs;
        mc_decls$ss_ncoderelocs = mc_genss$nrelocs;
    }
    else if ((mc_genss$currseg==(i64)2)) {
        mc_decls$ss_idatarelocs = (struct mc_decls$relocrec *)mc_genss$currrelocs;
        mc_decls$ss_nidatarelocs = mc_genss$nrelocs;
    }
;
    mc_genss$currseg = newseg;
    if ((mc_genss$currseg==(i64)1)) {
        mc_genss$currdata = (struct mc_decls$dbuffer *)mc_decls$ss_code;
        mc_genss$currrelocs = (struct mc_decls$relocrec *)mc_decls$ss_coderelocs;
        mc_genss$nrelocs = mc_decls$ss_ncoderelocs;
    }
    else if ((mc_genss$currseg==(i64)2)) {
        mc_genss$currdata = (struct mc_decls$dbuffer *)mc_decls$ss_idata;
        mc_genss$currrelocs = (struct mc_decls$relocrec *)mc_decls$ss_idatarelocs;
        mc_genss$nrelocs = mc_decls$ss_nidatarelocs;
    }
    else if ((mc_genss$currseg==(i64)3)) {
        mc_genss$currdata = (struct mc_decls$dbuffer *)mc_decls$ss_zdata;
    }
;
}

static void mc_genss$do_movdqx(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc) {
        i64 am;
        i64 regcode;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)2u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)2u)) {
            regcode = mc_genss$getregcodebx((i64)(*b).reg);
            am = mc_genss$genrm(a,regcode);
            (*((*mc_genss$currdata).pcurr)++) = opc;
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = (i64)15;
            (*((*mc_genss$currdata).pcurr)++) = (i64)111;
            mc_genss$genamode(a,am);
        }
        else if (($temp==(u64)4u)) {
            regcode = mc_genss$getregcoderx((i64)(*a).reg);
            am = mc_genss$genrm(b,regcode);
            (*((*mc_genss$currdata).pcurr)++) = opc;
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = (i64)15;
            (*((*mc_genss$currdata).pcurr)++) = (i64)111;
            mc_genss$genamode(b,am);
        }
        else {
            mm_support$axerror((byte*)"movdqx?");
        }
        };
    }
    else if (($temp==(u64)4u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)2u)) {
            regcode = mc_genss$getregcoderx((i64)(*b).reg);
            am = mc_genss$genrm(a,regcode);
            (*((*mc_genss$currdata).pcurr)++) = opc;
            mc_genss$genrex();
            (*((*mc_genss$currdata).pcurr)++) = (i64)15;
            (*((*mc_genss$currdata).pcurr)++) = (i64)127;
            mc_genss$genamode(a,am);
        }
        else {
            mm_support$axerror((byte*)"movdqx");
        }
        };
    }
    else {
        mm_support$axerror((byte*)"movdqx");
    }
    };
}

static void mc_genss$do_popcnt(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        i64 am;
        i64 regcode;
    if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)4)) {
        if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)0)) {
            (*b).misc = msysc$m_setdotslice((*b).misc,(i64)0,(i64)3,(u64)8u);
        }
;
    }
;
    (*((*mc_genss$currdata).pcurr)++) = (i64)243;
    regcode = mc_genss$getregcodebx((i64)(*a).reg);
    am = mc_genss$genrm(b,regcode);
    mc_genss$setopsize(a);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
    (*((*mc_genss$currdata).pcurr)++) = (i64)184;
    mc_genss$genamode(b,am);
}

static void mc_genss$do_bsf(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b,i64 opc) {
        i64 am;
        i64 regcode;
    if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)4)) {
        if (((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) == (i64)0)) {
            (*b).misc = msysc$m_setdotslice((*b).misc,(i64)0,(i64)3,(u64)8u);
        }
;
    }
;
    if ((msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3))) {
        mm_support$axerror((byte*)"bsf size");
    }
;
    regcode = mc_genss$getregcodebx((i64)(*a).reg);
    am = mc_genss$genrm(b,regcode);
    mc_genss$setopsize(a);
    mc_genss$genrex();
    (*((*mc_genss$currdata).pcurr)++) = (i64)15;
    (*((*mc_genss$currdata).pcurr)++) = opc;
    mc_genss$genamode(b,am);
}

static void mc_genss$extendsymboltable(void) {
        struct mm_decls$strec *(*oldsymboltable)[];
        i64 oldsymboltablesize;
        i64 i;
    oldsymboltablesize = mc_decls$ss_symboltablesize;
    oldsymboltable = (struct mm_decls$strec *(*)[])mc_decls$ss_symboltable;
    mc_decls$ss_symboltablesize *= (i64)2;
    mc_decls$ss_symboltable = (struct mm_decls$strec *(*)[])mlib$pcm_alloc(((i64)8 * mc_decls$ss_symboltablesize));
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L943 :;
        (*mc_decls$ss_symboltable)[(i)-1] = (*oldsymboltable)[(i)-1];
L944 :;
    }
L945 :;
    ;
    mlib$pcm_free(oldsymboltable,((i64)8 * oldsymboltablesize));
}

static void mc_genss$fixregvar(void) {
        struct mc_decls$mclrec *  m;
    m = (struct mc_decls$mclrec *)mc_decls$mccode;
}

void mc_genss$initlib(i64 nlabels) {
        u8 str[256];
        i64 i;
    mc_decls$ss_symboltable = (struct mm_decls$strec *(*)[])mlib$pcm_alloc((i64)262144);
    mc_decls$ss_symboltablesize = (i64)32768;
    mc_decls$ss_nsymbols = (i64)0;
    mc_decls$labeldeftable = (struct mm_decls$strec *(*)[])mlib$pcm_alloc((nlabels * (i64)8));
    for (i=(i64)1;i<=nlabels;++i) {
L946 :;
        (*mc_decls$labeldeftable)[(i)-1] = (struct mm_decls$strec *)mlib$pcm_allocz((i64)193);
        (*(*mc_decls$labeldeftable)[(i)-1]).labelno = i;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"(L#)");
        msysc$m_print_i64(i,NULL);
        msysc$m_print_end();
        ;
        (*(*mc_decls$labeldeftable)[(i)-1]).name = mlib$pcm_copyheapstring((u8 *)str);
        (*(*mc_decls$labeldeftable)[(i)-1]).reftype = (i64)1;
L947 :;
    }
L948 :;
    ;
}

struct mc_decls$dbuffer *mc_genss$buffercreate(i64 size) {
        struct mc_decls$dbuffer *  a;
    a = (struct mc_decls$dbuffer *)mlib$pcm_alloc((i64)32);
    (*a).alloc = size;
    (*a).pstart = ((*a).pcurr = (byte *)mlib$pcm_alloc((*a).alloc));
    (*a).pend = ((*a).pstart + (*a).alloc);
    return (struct mc_decls$dbuffer *)a;
}

static void mc_genss$bufferexpand(struct mc_decls$dbuffer *a) {
        i64 newalloc;
        i64 usedbytes;
        byte *  p;
    newalloc = ((*a).alloc * (i64)2);
    usedbytes = ((*a).pcurr - (*a).pstart);
    if ((usedbytes > (*a).alloc)) {
        mm_support$axerror((byte*)"dbuffer error");
        exit(0);
    }
;
    p = (byte *)mlib$pcm_alloc(newalloc);
    memcpy(p,(*a).pstart,(u64)usedbytes);
    (*a).pstart = p;
    (*a).pcurr = (p + usedbytes);
    (*a).alloc = newalloc;
    (*a).pend = (p + newalloc);
}

void mc_genss$buffercheck(struct mc_decls$dbuffer *a,i64 n) {
    L949 :;
    while ((((*a).pend - (*a).pcurr) < n)) {
        mc_genss$bufferexpand((struct mc_decls$dbuffer *)a);
L950 :;
    }
L951 :;
    ;
}

i64 mc_genss$bufferlength(struct mc_decls$dbuffer *a) {
    return ((*a).pcurr - (*a).pstart);
}

void *mc_genss$bufferelemptr(struct mc_decls$dbuffer *a,i64 offset) {
    return ((*a).pstart + offset);
}

void mc_genss$addword(struct mc_decls$dbuffer *a,i64 x) {
    (*(*a).pcurr16) = x;
    ++((*a).pcurr16);
}

void mc_genss$adddword(struct mc_decls$dbuffer *a,i64 x) {
    (*(*a).pcurr32) = x;
    ++((*a).pcurr32);
}

void mc_genss$addqword(struct mc_decls$dbuffer *a,i64 x) {
    (*(*a).pcurr64) = (u64)x;
    ++((*a).pcurr64);
}

// START
void mc_genss$start(void) {

}

void mc_libmcl$mclinit(void) {
        struct mc_decls$opndrec *  a;
        i64 r;
        i64 i;
    for (r=(i64)1;r<=(i64)16;++r) {
L952 :;
        mc_decls$regtable[(r)-1][((i64)1)-1] = mc_libmcl$genreg0(r,(i64)1);
        mc_decls$regtable[(r)-1][((i64)2)-1] = mc_libmcl$genreg0(r,(i64)2);
        mc_decls$regtable[(r)-1][((i64)4)-1] = mc_libmcl$genreg0(r,(i64)4);
        mc_decls$regtable[(r)-1][((i64)8)-1] = mc_libmcl$genreg0(r,(i64)8);
L953 :;
    }
L954 :;
    ;
    mc_decls$zero_opnd = mc_libmcl$genint((i64)0,(i64)8);
    for (i=(i64)-128;i<=(i64)64;++i) {
L955 :;
        a = mc_libmcl$newmclopnd();
        (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)4u);
        (*a).reg = (i64)15;
        (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)8u);
        (*a).offset = i;
        mc_decls$frameregtable[(i)+128] = a;
L956 :;
    }
L957 :;
    ;
    mc_decls$dframeopnd = mc_libmcl$genreg((i64)15,(i64)8);
    mc_decls$dstackopnd = mc_libmcl$genreg((i64)16,(i64)8);
    mc_decls$distackopnd = mc_libmcl$genireg((i64)16,(i64)8,(i64)0);
    mc_libmcl$initmcdest();
    mc_libmcl$setsegment((i64)67,(i64)1);
    mc_decls$lab_funcnametable = (i64)0;
    mc_decls$lab_funcaddrtable = (i64)0;
}

void mc_libmcl$initmcdest(void) {
    mc_decls$mccode = (mc_decls$mccodex = 0);
}

void mc_libmcl$genmc(i64 opcode,struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
        struct mc_decls$mclrec *  m;
        i64 labno;
    ++(mc_decls$nallmcl);
    m = (struct mc_decls$mclrec *)mlib$pcm_allocz((i64)32);
    (*m).opcode = opcode;
    (*m).seqno = ++(mc_libmcl$mclseqno);
    (*m).a = a;
    (*m).b = b;
    if ((((opcode == (i64)36) && ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) == (i64)8)) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3) < (i64)8))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"IMUL2/MIXED SIZE",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((opcode==(i64)23)) {
        ++(mc_decls$inf_proccalls);
    }
    else if ((opcode==(i64)16)) {
        if ((!!(b) && ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)12,(i64)15) == (i64)6))) {
            (*(*b).def).flags = msysc$m_setdotindex((*(*b).def).flags,(i64)6,(u64)1u);
        }
;
    }
    else if ((opcode==(i64)11)) {
        labno = (*a).labelno;
    }
;
    if (!!(mc_decls$mccode)) {
        (*mc_decls$mccodex).nextmcl = (struct mc_decls$mclrec *)m;
        mc_decls$mccodex = (struct mc_decls$mclrec *)m;
    }
    else {
        mc_decls$mccode = (mc_decls$mccodex = (struct mc_decls$mclrec *)m);
    }
;
}

void mc_libmcl$genmc_cond(i64 opcode,i64 cond,struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
    mc_libmcl$genmc(opcode,a,b);
    (*mc_decls$mccodex).cond = cond;
}

void mc_libmcl$genmc_str(i64 opcode,u8 *s) {
    mc_libmcl$genmc(opcode,mc_libmcl$genstring(s,(i64)-1),0);
}

struct mc_decls$opndrec *mc_libmcl$newmclopnd(void) {
        struct mc_decls$opndrec *  a;
    a = (struct mc_decls$opndrec *)mlib$pcm_allocz((i64)16);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$duplopnd(struct mc_decls$opndrec *a) {
        struct mc_decls$opndrec *  b;
    b = (struct mc_decls$opndrec *)mlib$pcm_alloc((i64)16);
    (*b) = (*a);
    return b;
}

struct mc_decls$opndrec *mc_libmcl$genxreg(i64 xreg,i64 size) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)2u);
    if ((xreg == (i64)0)) {
        (*a).reg = mc_libmcl$getnextxreg();
    }
    else {
        (*a).reg = xreg;
        mc_libmcl$setregbit(xreg);
    }
;
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)size);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genindex(i64 areg,i64 ireg,i64 scale,i64 offset,i64 size,i64 labno,struct mm_decls$strec *def) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)4u);
    (*a).reg = areg;
    (*a).regix = ireg;
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)4,(i64)7,(u64)scale);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)size);
    (*a).offset = offset;
    if (!!(labno)) {
        (*a).value = labno;
        (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)7u);
    }
    else if (!!(def)) {
        (*a).def = def;
        ++((*def).nrefs);
        (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)6u);
        if (((i64)(*def).nameid == (i64)12 || (i64)(*def).nameid == (i64)13)) {
            (*a).reg = (i64)15;
        }
;
    }
;
    return a;
}

struct mlib$strbuffer *mc_libmcl$getmclstr(void) {
        struct mc_decls$mclrec *  m;
        i64 i;
    mlib$gs_init((struct mlib$strbuffer *)mm_lib$dest);
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L958 :;
        if (((u64)(*mm_decls$libfiles[(i)]) != '$')) {
            mc_libmcl$asmstr((byte*)"          ");
            mc_libmcl$asmstr((((i64)mm_decls$libtypes[(i)] == (i64)68) ? (byte*)"importdll " : (byte*)"importlib "));
            mc_libmcl$asmstr(mm_decls$libfiles[(i)]);
            mlib$gs_line((struct mlib$strbuffer *)mm_lib$dest);
        }
;
L959 :;
    }
L960 :;
    ;
    m = (struct mc_decls$mclrec *)mc_decls$mccode;
    i = (i64)1;
    L961 :;
    while (!!(m)) {
        mc_libmcl$writemcl(i,(struct mc_decls$mclrec *)m);
        ++(i);
        m = (struct mc_decls$mclrec *)(*m).nextmcl;
L962 :;
    }
L963 :;
    ;
    return (struct mlib$strbuffer *)mm_lib$dest;
}

void mc_libmcl$gencomment(u8 *s,u8 *t) {
        u8 str[300];
    if (((s == 0) || ((i64)(u64)(*s) == (i64)0))) {
        mc_libmcl$genmc((i64)5,0,0);
    }
    else if (!!(t)) {
        strcpy(str,s);
        strcat(str,(byte*)" ");
        strcat(str,t);
        mc_libmcl$genmc((i64)4,mc_libmcl$gencommentstring(str,(i64)-1),0);
    }
    else {
        mc_libmcl$genmc((i64)4,mc_libmcl$gencommentstring(s,(i64)-1),0);
    }
;
}

struct mc_decls$opndrec *mc_libmcl$genstring(u8 *s,i64 length) {
    return mc_libmcl$genlabel(mc_libmcl$getstringindex(s));
}

struct mc_decls$opndrec *mc_libmcl$gencommentstring(u8 *s,i64 length) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)3u);
    if ((length < (i64)0)) {
        length = strlen(s);
    }
;
    (*a).svalue = (u8 *)mlib$pcm_alloc((length + (i64)1));
    memcpy((void *)(*a).svalue,(void *)s,(u64)length);
    (*((*a).svalue + length)) = (u64)0u;
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)4u);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)8u);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genname(u8 *s) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)3u);
    (*a).svalue = mlib$pcm_copyheapstring(s);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)8u);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)8u);
    return a;
}

static void mc_libmcl$writemcl(i64 index,struct mc_decls$mclrec *mcl) {
        {i64 $temp = (i64)(*mcl).opcode;
if (($temp==(i64)6)) {
    }
    else {
        mc_libmcl$strmcl((struct mc_decls$mclrec *)mcl);
        mlib$gs_line((struct mlib$strbuffer *)mm_lib$dest);
    }
    };
}

void mc_libmcl$strmcl(struct mc_decls$mclrec *mcl) {
        static u8 str[512];
        u8 opcname[128];
        struct mc_decls$opndrec *  a;
        struct mc_decls$opndrec *  b;
        i64 opcode;
        i64 cond;
        i64 sizepref;
        u8 *  comment;
        struct mm_decls$strec *  d;
    opcode = (i64)(*mcl).opcode;
    cond = (i64)(*mcl).cond;
    a = (*mcl).a;
    b = (*mcl).b;
    comment = 0;
    if ((opcode==(i64)1)) {
        mc_libmcl$asmstr((byte*)";Proc ");
        mc_libmcl$asmstr((*(*a).def).name);
        mc_decls$currasmproc = (*a).def;
        return;
    }
    else if ((opcode==(i64)2)) {
        mc_libmcl$asmstr((byte*)";End ");
        mc_decls$currasmproc = 0;
        return;
    }
    else if ((opcode==(i64)5)) {
        return;
    }
    else if ((opcode==(i64)4)) {
        mc_libmcl$asmchar((i64)59);
        mc_libmcl$asmstr((*a).svalue);
        goto L964 ;
;
        return;
    }
    else if ((opcode==(i64)6)) {
        mc_libmcl$asmstr((byte*)"; <deleted>");
        goto L964 ;
;
        return;
    }
    else if ((opcode==(i64)7)) {
        d = (*a).def;
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)6u)) {
            mc_libmcl$asmstr(mc_libmcl$getdispname(d));
        }
        else if (($temp==(u64)4u)) {
            mc_libmcl$asmstr((*a).svalue);
            return;
        }
        else {
            mc_libmcl$merror((byte*)"strmcl/lab",(byte*)"");
        }
        };
        mc_libmcl$asmstr((byte*)":");
        if (((i64)(*d).scope == (i64)3)) {
            mc_libmcl$asmstr((byte*)"\n");
            mc_libmcl$asmstr((*d).name);
            mc_libmcl$asmstr((byte*)"::");
        }
;
        return;
    }
    else if ((opcode==(i64)11)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"L#:");
        msysc$m_print_i64((*a).value,NULL);
        msysc$m_print_end();
        ;
        mc_libmcl$asmstr((u8 *)str);
        return;
    }
    else if ((opcode==(i64)8)) {
        mc_libmcl$asmstr((byte*)"          ");
        mc_libmcl$asmstr((*a).svalue);
        mc_libmcl$asmstr((byte*)" = ");
        mc_libmcl$asmopnd(b,(i64)0,(i64)0);
        return;
    }
    else if ((opcode==(i64)9)) {
        mc_libmcl$asmstr((byte*)"          ");
        mc_libmcl$asmstr((*a).svalue);
        mc_libmcl$asmstr((byte*)" = ");
                {u64 $temp = msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11);
if (($temp==(u64)1u)) {
            mc_libmcl$asmstr(mc_libmcl$getregname((i64)(*b).reg,(i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)));
        }
        else {
            mc_libmcl$asmstr(mc_libmcl$getxregname((i64)(*b).reg,(i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3)));
        }
        };
        return;
    }
    else if ((opcode==(i64)3)) {
        mc_libmcl$asmstr((byte*)";         programend");
        return;
    }
;
    if ((opcode==(i64)28)) {
        msysc$m_print_startstr(opcname);
        msysc$m_print_str((byte*)"j",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(mc_decls$asmcondnames[(cond)],NULL);
        msysc$m_print_end();
        ;
    }
    else if ((opcode==(i64)60)) {
        msysc$m_print_startstr(opcname);
        msysc$m_print_str((byte*)"set",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(mc_decls$asmcondnames[(cond)],NULL);
        msysc$m_print_end();
        ;
    }
    else if ((opcode==(i64)17)) {
        msysc$m_print_startstr(opcname);
        msysc$m_print_str((byte*)"cmov",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(mc_decls$asmcondnames[(cond)],NULL);
        msysc$m_print_end();
        ;
    }
    else if ((opcode==(i64)23)) {
        strcpy((u8 *)opcname,(byte*)"call");
    }
    else if ((opcode==(i64)40)) {
        strcpy((u8 *)opcname,(byte*)"and");
    }
    else if ((opcode==(i64)41)) {
        strcpy((u8 *)opcname,(byte*)"or");
    }
    else if ((opcode==(i64)42)) {
        strcpy((u8 *)opcname,(byte*)"xor");
    }
    else if ((opcode==(i64)53)) {
        strcpy((u8 *)opcname,(byte*)"not");
    }
    else {
        if ((opcode > (i64)150)) {
            strcpy((u8 *)opcname,msysc$strint(opcode,0));
        }
        else {
            strcpy((u8 *)opcname,(mc_decls$mclnames[(opcode)-1] + (i64)2));
        }
;
    }
;
    mlib$ipadstr((u8 *)opcname,(i64)10,(byte*)" ");
    if ((u64)0u) {
        if ((!!(a) && !!(b))) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"  #/#");
            msysc$m_print_u64(msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3),NULL);
            msysc$m_print_u64(msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3),NULL);
            msysc$m_print_end();
            ;
        }
        else if (!!(a)) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"  #");
            msysc$m_print_u64(msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3),NULL);
            msysc$m_print_end();
            ;
        }
        else {
            strcpy((u8 *)str,(byte*)"  ");
        }
;
    }
    else {
        strcpy((u8 *)str,(byte*)"  ");
    }
;
    mlib$ipadstr((u8 *)str,(i64)10,(byte*)" ");
    strcat((u8 *)str,(u8 *)opcname);
    mc_libmcl$asmstr((u8 *)str);
    if ((!!(a) && !!(b))) {
        sizepref = mc_libmcl$needsizeprefix(opcode,a,b);
        mc_libmcl$asmopnd(a,sizepref,(i64)0);
        mc_libmcl$asmstr((byte*)",\t");
        mc_libmcl$asmopnd(b,sizepref,(i64)0);
        mc_libmcl$asmstr((byte*)"; ");
        mc_libmcl$asmstr(msysc$strint((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3),0));
        mc_libmcl$asmstr((byte*)" ");
        mc_libmcl$asmstr(msysc$strint((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)0,(i64)3),0));
    }
    else if ((!!(a) && !!(msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11)))) {
        if ((opcode == (i64)23)) {
            mc_libmcl$asmopnd(a,(i64)0,(i64)0);
        }
        else {
            mc_libmcl$asmopnd(a,(i64)1,(i64)0);
        }
;
    }
;
    //docomments:
L964 :;
;
}

void mc_libmcl$asmopnd(struct mc_decls$opndrec *a,i64 sizeprefix,i64 debug) {
    mc_libmcl$asmstr(mc_libmcl$stropnd(a,sizeprefix,debug));
}

void mc_libmcl$setsegment(i64 seg,i64 align) {
        i64 opc;
        i64 oldalign;
    if ((seg != mc_decls$currsegment)) {
        if ((seg==(i64)73)) {
            opc = (i64)121;
        }
        else if ((seg==(i64)90)) {
            opc = (i64)122;
        }
        else if ((seg==(i64)67)) {
            opc = (i64)123;
        }
        else if ((seg==(i64)82)) {
            mc_libmcl$merror((byte*)"CAN'T DO RODATA SEG",(byte*)"");
        }
        else {
            mc_libmcl$merror((byte*)"BAD SEG CODE",(byte*)"");
        }
;
        if ((!!(mc_decls$mccodex) && ((i64)(*mc_decls$mccodex).opcode == (i64)121 || (i64)(*mc_decls$mccodex).opcode == (i64)122 || (i64)(*mc_decls$mccodex).opcode == (i64)123))) {
            (*mc_decls$mccodex).opcode = opc;
        }
        else {
            mc_libmcl$genmc(opc,0,0);
        }
;
        mc_decls$currsegment = seg;
    }
;
    if ((align > (i64)1)) {
        if (((i64)(*mc_decls$mccodex).opcode == (i64)124)) {
            oldalign = (*(*mc_decls$mccodex).a).value;
            if ((oldalign >= align)) {
                return;
            }
;
        }
;
        mc_libmcl$genmc((i64)124,mc_libmcl$genint(align,(i64)8),0);
    }
;
}

u8 *mc_libmcl$getsizeprefix(i64 size,i64 enable) {
    if (!(!!(enable))) {
        return (byte*)"";
    }
;
    if ((size==(i64)1)) {
        return (byte*)"byte ";
    }
    else if ((size==(i64)2)) {
        return (byte*)"word16 ";
    }
    else if ((size==(i64)4)) {
        return (byte*)"word32 ";
    }
    else if ((size==(i64)8)) {
        return (byte*)"word64 ";
    }
;
    return (byte*)"";
}

i64 mc_libmcl$needsizeprefix(i64 opcode,struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
    if ((opcode==(i64)20) || (opcode==(i64)21) || (opcode==(i64)85) || (opcode==(i64)86)) {
        return (i64)1;
    }
    else if ((opcode==(i64)81) || (opcode==(i64)82) || (opcode==(i64)83) || (opcode==(i64)84)) {
        return (i64)1;
    }
    else if ((opcode==(i64)45) || (opcode==(i64)47) || (opcode==(i64)46)) {
        if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)4)) {
            return (i64)1;
        }
;
        return (i64)0;
    }
;
    if ((((((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)1) || ((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) == (i64)2)) || ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)1)) || ((i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) == (i64)2))) {
        return (i64)0;
    }
;
    return (i64)1;
}

struct mc_decls$opndrec *mc_libmcl$changeopndsize(struct mc_decls$opndrec *a,i64 size) {
        struct mc_decls$opndrec *  b;
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3) != size)) {
        b = mc_libmcl$duplopnd(a);
        (*b).misc = msysc$m_setdotslice((*b).misc,(i64)0,(i64)3,(u64)size);
        return b;
    }
;
    return a;
}

struct mc_decls$opndrec *mc_libmcl$makeopndind(struct mc_decls$opndrec *a,i64 size) {
    if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11) != (i64)1)) {
        mc_libmcl$merror((byte*)"makeopndind",(byte*)"");
    }
;
    return mc_libmcl$genireg((i64)(*a).reg,size,(i64)0);
}

struct mc_decls$opndrec *mc_libmcl$applyoffset(struct mc_decls$opndrec *a,i64 offset,i64 size) {
        struct mc_decls$opndrec *  b;
    if (((offset == (i64)0) && (size == (i64)0))) {
        return a;
    }
;
    b = mc_libmcl$duplopnd(a);
    (*b).offset = ((i64)(*b).offset + offset);
    if (!!(size)) {
        (*b).misc = msysc$m_setdotslice((*b).misc,(i64)0,(i64)3,(u64)size);
    }
;
    return b;
}

struct mc_decls$opndrec *mc_libmcl$genint(i64 x,i64 size) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)3u);
    (*a).value = x;
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)1u);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)size);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genrealmem(r64 x,i64 mode) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)4u);
    if ((mode == (i64)5)) {
        (*a).value = mc_libmcl$getrealindex(x);
        (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)8u);
    }
    else {
        (*a).value = mc_libmcl$getreal32index(x);
        (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)4u);
    }
;
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)7u);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genrealimm(r64 x,i64 mode) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)3u);
    (*a).xvalue = x;
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)2u);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)(i64)mm_decls$ttsize[(mode)]);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genlabel(i64 x) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)3u);
    if ((x == (i64)0)) {
        x = ++(mc_decls$mlabelno);
    }
;
    (*a).value = x;
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)7u);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genlabelmem(i64 x) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$genlabel(x);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)4u);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genregvar(struct mm_decls$strec *d) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$genreg((i64)(*d).reg,(i64)8);
    mc_libmcl$setbit(&mc_decls$isregvar,(i64)(*d).reg,(i64)1);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genxregvar(struct mm_decls$strec *d) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$genxreg((i64)(*d).reg,(i64)8);
    mc_libmcl$setbit(&mc_decls$isregvar,(i64)(*d).reg,(i64)1);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genmem(struct mm_decls$strec *d) {
        struct mc_decls$opndrec *  a;
        i64 reg;
    if (!!((i64)(*d).reg)) {
        if (!!((i64)mm_decls$ttisreal[((i64)(*d).mode)])) {
            return mc_libmcl$genxregvar(d);
        }
        else {
            return mc_libmcl$genregvar(d);
        }
;
    }
;
    reg = (i64)0;
    if (((i64)(*d).nameid == (i64)12 || (i64)(*d).nameid == (i64)13)) {
        reg = (i64)15;
    }
;
    if ((!!(msysc$m_getdotindex((i64)(*d).flags,(i64)10)) && !!((*d).equivvar))) {
        d = (*(*d).equivvar).def;
    }
;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)4u);
    (*a).reg = reg;
    (*a).def = d;
    ++((*d).nrefs);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)6u);
    mc_libmcl$setopndsize(a,(i64)mm_decls$ttsize[((i64)(*d).mode)]);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genmemaddr(struct mm_decls$strec *d) {
        struct mc_decls$opndrec *  a;
    if ((!!(msysc$m_getdotindex((i64)(*d).flags,(i64)10)) && !!((*d).equivvar))) {
        d = (*(*d).equivvar).def;
    }
;
    (*d).flags = msysc$m_setdotindex((*d).flags,(i64)6,(u64)1u);
    ++((*d).nrefs);
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)3u);
    (*a).def = d;
    ++((*d).nrefs);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)12,(i64)15,(u64)6u);
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)8u);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genreg(i64 reg,i64 size) {
    return mc_libmcl$genreg0(reg,size);
}

struct mc_decls$opndrec *mc_libmcl$genreg0(i64 reg,i64 size) {
        struct mc_decls$opndrec *  a;
    if ((reg >= (i64)21)) {
        return mc_libmcl$genxreg(reg,size);
    }
;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)1u);
    if ((reg == (i64)0)) {
        (*a).reg = mc_libmcl$getnextreg();
    }
    else {
        (*a).reg = reg;
        mc_libmcl$setregbit(reg);
    }
;
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)0,(i64)3,(u64)size);
    return a;
}

struct mc_decls$opndrec *mc_libmcl$genireg(i64 reg,i64 size,i64 offset) {
        struct mc_decls$opndrec *  a;
    a = mc_libmcl$newmclopnd();
    (*a).misc = msysc$m_setdotslice((*a).misc,(i64)8,(i64)11,(u64)4u);
    (*a).reg = reg;
    mc_libmcl$setregbit(reg);
    mc_libmcl$setopndsize(a,size);
    (*a).offset = offset;
    return a;
}

i64 mc_libmcl$roundsizetg(i64 size) {
    L965 :;
    while (!!((size & (i64)7))) {
        ++(size);
L966 :;
    }
L967 :;
    ;
    return size;
}

u8 *mc_libmcl$getregname(i64 reg,i64 size) {
        static u8 *  prefix[17] = {
    (byte*)"B",
    (byte*)"W",
    (byte*)"",
    (byte*)"A",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"D",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"Q",
    (byte*)"N"
};
        static u8 str[32];
        u8 str2[16];
        u8 *  rs;
    if ((reg >= (i64)21)) {
        return mc_libmcl$getxregname(reg,size);
    }
;
    if ((reg==(i64)0)) {
        return (byte*)"-";
    }
    else if ((reg==(i64)15)) {
        rs = (byte*)"frame";
    }
    else if ((reg==(i64)16)) {
        rs = (byte*)"stack";
    }
    else {
        msysc$getstrint((reg - (i64)1),(u8 *)str2);
        rs = (u8 *)str2;
    }
;
    if ((size > (i64)8)) {
        size = (i64)8;
    }
;
    msysc$m_print_startstr(str);
    msysc$m_print_str(prefix[(size)-1],NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(rs,NULL);
    msysc$m_print_end();
    ;
    return (u8 *)str;
}

u8 *mc_libmcl$getxregname(i64 reg,i64 size) {
        static u8 str[32];
    if ((u64)1u) {
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"XMM",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64((reg - (i64)21),NULL);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_str(((size == (i64)8) ? (byte*)"DX" : (byte*)"SX"),NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64((reg - (i64)21),NULL);
        msysc$m_print_end();
        ;
    }
;
    return (u8 *)str;
}

i64 mc_libmcl$sameoperand(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
    return (i64)(memcmp(a,b,(u64)16u) == (i64)0);
}

i64 mc_libmcl$sameregopnd(struct mc_decls$opndrec *a,struct mc_decls$opndrec *b) {
    if (!(((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11)==(i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11) && (i64)msysc$m_getdotslice((i64)(*b).misc,(i64)8,(i64)11)==(i64)1))) {
        return (i64)0;
    }
;
    return (i64)((i64)(*a).reg == (i64)(*b).reg);
}

i64 mc_libmcl$getstringindex(u8 *s) {
    if ((s == 0)) {
        mc_decls$kk0used = ++(mc_decls$mlabelno);
        return mc_decls$kk0used;
    }
;
    if ((!!(mc_decls$cstringlist) && !!(mlib$eqstring((*mc_decls$cstringlist).svalue,s)))) {
        return (*mc_decls$cstringlist).labelno;
    }
;
    return mc_libmcl$addconst(&mc_decls$cstringlist,(i64)s);
}

i64 mc_libmcl$addconst(struct mc_decls$constrec **clist,i64 value) {
        struct mc_decls$constrec *  p;
    p = (struct mc_decls$constrec *)mlib$pcm_allocz((i64)24);
    (*p).value = value;
    (*p).labelno = ++(mc_decls$mlabelno);
    (*p).nextconst = (struct mc_decls$constrec *)(*clist);
    (*clist) = (struct mc_decls$constrec *)p;
    return mc_decls$mlabelno;
}

i64 mc_libmcl$getrealindex(r64 x) {
    return mc_libmcl$addconst(&mc_decls$creallist,*(i64*)&x);
}

i64 mc_libmcl$getreal32index(r64 x) {
    return mc_libmcl$addconst(&mc_decls$creal32list,*(i64*)&x);
}

static void mc_libmcl$asmstr(u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)mm_lib$dest,s);
}

static void mc_libmcl$asmchar(i64 c) {
    mlib$gs_char((struct mlib$strbuffer *)mm_lib$dest,c);
}

u8 *mc_libmcl$getdispname(struct mm_decls$strec *d) {
        static u8 str[256];
        u8 *  name;
    if (!!((i64)mm_winx64$fshortnames)) {
        return (*d).name;
    }
;
    name = mm_lib$getfullname(d);
    if (!!((i64)(*d).reg)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#.#");
        msysc$m_print_str((!!(msysc$m_getdotindex((i64)(*d).flags,(i64)11)) ? (byte*)"X" : (byte*)"R"),NULL);
        msysc$m_print_str(name,NULL);
        msysc$m_print_end();
        ;
        return str;
    }
;
    if ((!!((*d).truename) && !!(msysc$m_getdotindex((i64)(*d).flags,(i64)12)))) {
        strcpy(str,(byte*)"`");
        strcat(str,(*d).truename);
        strcat(str,(byte*)"*");
    }
    else if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
        strcpy(str,name);
        strcat(str,(byte*)"*");
    }
    else {
        return name;
    }
;
    return str;
}

void mc_libmcl$merror(u8 *mess,u8 *param) {
    msysc$m_print_startcon();
    msysc$m_print_setfmt((byte*)"MCL Error: # (#) on Line: # in #");
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str(param,NULL);
    msysc$m_print_i64(mm_support$getlineno((u64)mm_tables$mlineno),NULL);
    msysc$m_print_str(mm_decls$sourcefilenames[(mm_support$getfileno((u64)mm_tables$mlineno))],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mm_support$stopcompiler(mm_decls$sourcefilespecs[(mm_support$getfileno((u64)mm_tables$mlineno))],mm_support$getlineno((u64)mm_tables$mlineno));
}

void mc_libmcl$merrort(u8 *mess,i64 t) {
        u8 str[300];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"MCL Type not supported for (#)");
    msysc$m_print_str(mess,NULL);
    msysc$m_print_end();
    ;
    mc_libmcl$merror(str,mm_decls$ttname[(t)]);
}

void mc_libmcl$genstringtable(void) {
        struct mc_decls$constrec *  p;
    if (!(!!(mc_decls$cstringlist))) {
        return;
    }
;
    mc_libmcl$gencomment((byte*)"String Table",0);
    mc_libmcl$setsegment((i64)73,(i64)8);
    if (!!(mc_decls$kk0used)) {
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$kk0used),0);
        mc_libmcl$gendb((i64)0);
    }
;
    p = (struct mc_decls$constrec *)mc_decls$cstringlist;
    L968 :;
    while (!!(p)) {
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel((*p).labelno),0);
        mc_libmcl$genstringimm((*p).svalue,(i64)1);
L969 :;
        p = (struct mc_decls$constrec *)(*p).nextconst;
L971 :;
            }
L970 :;
    ;
}

void mc_libmcl$genstringimm(u8 *s,i64 doterm) {
        i64 c;
        i64 seqlen;
        i64 length;
        u8 *  seq;
        i64 $av_1;
    length = strlen(s);
    if ((length == (i64)0)) {
        mc_libmcl$gendb((i64)0);
        return;
    }
;
    seqlen = (i64)0;
    $av_1 = length;
    while ($av_1-- > 0) {
L972 :;
        c = (i64)(u64)(*(s)++);
        if ((((c < (i64)32) || (c >= (i64)127)) || (c == (i64)34))) {
            if (!!(seqlen)) {
                mc_libmcl$gendbstring(seq,seqlen);
                seqlen = (i64)0;
            }
;
            mc_libmcl$gendb(c);
        }
        else {
            if ((seqlen == (i64)0)) {
                seqlen = (i64)1;
                seq = (s - (i64)1);
            }
            else {
                ++(seqlen);
            }
;
        }
;
L973 :;
    }
L974 :;
    ;
    if (!!(seqlen)) {
        mc_libmcl$gendbstring(seq,seqlen);
    }
;
    if (!!(doterm)) {
        mc_libmcl$gendb((i64)0);
    }
;
}

static void mc_libmcl$gendb(i64 a) {
    mc_libmcl$genmc((i64)115,mc_libmcl$genint(a,(i64)8),0);
}

static void mc_libmcl$gendbstring(u8 *s,i64 length) {
    mc_libmcl$genmc((i64)115,mc_libmcl$gencommentstring(s,length),0);
}

static void mc_libmcl$gendq(i64 a) {
    mc_libmcl$genmc((i64)118,mc_libmcl$genint(a,(i64)8),0);
}

void mc_libmcl$genrealtable(void) {
        struct mc_decls$constrec *  p;
    if (!((!!(mc_decls$creallist) || !!(mc_decls$creal32list)))) {
        return;
    }
;
    mc_libmcl$gencomment((byte*)"Real Table",0);
    mc_libmcl$setsegment((i64)73,(i64)8);
    p = (struct mc_decls$constrec *)mc_decls$creallist;
    L975 :;
    while (!!(p)) {
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel((*p).labelno),0);
        if (((*p).xvalue == m$infinity)) {
            mc_libmcl$genmc((i64)118,mc_libmcl$genint((i64)(u64)msysc$m_tp_r64toi64((*p).xvalue),(i64)8),0);
        }
        else {
            mc_libmcl$genmc((i64)118,mc_libmcl$genrealimm((*p).xvalue,(i64)8),0);
        }
;
L976 :;
        p = (struct mc_decls$constrec *)(*p).nextconst;
L978 :;
            }
L977 :;
    ;
    mc_libmcl$gencomment((byte*)"Real32 Table",0);
    p = (struct mc_decls$constrec *)mc_decls$creal32list;
    L979 :;
    while (!!(p)) {
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel((*p).labelno),0);
        if (((*p).xvalue == m$infinity)) {
            mc_libmcl$genmc((i64)117,mc_libmcl$genint((i64)msysc$m_tp_r64toi64((r32)(*p).xvalue),(i64)8),0);
        }
        else {
            mc_libmcl$genmc((i64)117,mc_libmcl$genrealimm((*p).xvalue,(i64)4),0);
        }
;
L980 :;
        p = (struct mc_decls$constrec *)(*p).nextconst;
L982 :;
            }
L981 :;
    ;
}

void mc_libmcl$genabsneg(void) {
    mc_libmcl$setsegment((i64)73,(i64)16);
    if (!!(mc_decls$lababs32)) {
        mc_libmcl$gencomment((byte*)"lababs32",0);
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$lababs32),0);
        mc_libmcl$gendq((i64)9223372034707292159);
        mc_libmcl$gendq((i64)9223372034707292159);
    }
;
    if (!!(mc_decls$lababs64)) {
        mc_libmcl$gencomment((byte*)"lababs64",0);
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$lababs64),0);
        mc_libmcl$gendq((i64)9223372036854775807);
        mc_libmcl$gendq((i64)9223372036854775807);
    }
;
    if (!!(mc_decls$labneg32)) {
        mc_libmcl$gencomment((byte*)"labneg32",0);
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$labneg32),0);
        mc_libmcl$gendq((i64)-9223372034707292160);
        mc_libmcl$gendq((i64)-9223372034707292160);
    }
;
    if (!!(mc_decls$labneg64)) {
        mc_libmcl$gencomment((byte*)"labneg64",0);
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$labneg64),0);
        mc_libmcl$gendq((i64)(-9223372036854775807-1));
        mc_libmcl$gendq((i64)(-9223372036854775807-1));
    }
;
    if (!!(mc_decls$labzero)) {
        mc_libmcl$gencomment((byte*)"labzero",0);
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$labzero),0);
        mc_libmcl$gendq((i64)0);
    }
;
    if (!!(mc_decls$labmask63)) {
        mc_libmcl$gencomment((byte*)"mask63/offset64",0);
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$labmask63),0);
        mc_libmcl$gendq((i64)9223372036854775807);
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$laboffset64),0);
        mc_libmcl$gendq((i64)4890909195324358656);
    }
;
}

i64 mc_libmcl$createfwdlabel(void) {
    return ++(mc_decls$mlabelno);
}

void mc_libmcl$definefwdlabel(i64 lab) {
    mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(lab),0);
}

i64 mc_libmcl$definelabel(void) {
    mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(++(mc_decls$mlabelno)),0);
    return mc_decls$mlabelno;
}

u8 *mc_libmcl$stropnd(struct mc_decls$opndrec *a,i64 sizeprefix,i64 debug) {
        static u8 str[512];
        u8 str2[128];
        u8 *  plus;
        i64 offset;
    str[((i64)1)-1] = (u64)0u;
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11);
if (($temp==(u64)1u) || ($temp==(u64)2u)) {
        return mc_libmcl$strreg((i64)(*a).reg,(i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3));
    }
    else if (($temp==(u64)3u)) {
        strcpy(str,mc_libmcl$strvalue(a));
    }
    else if (($temp==(u64)4u)) {
                {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)1u)) {
            strcpy(str,msysc$strint((*a).value,0));
        }
        else if (($temp==(u64)2u)) {
            strcpy(str,msysc$strreal((*a).xvalue,0));
        }
        else if (($temp==(u64)3u)) {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"M#");
            msysc$m_print_r64((*a).xvalue,NULL);
            msysc$m_print_end();
            ;
        }
        };
        strcat(str,mc_libmcl$getsizeprefix((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)0,(i64)3),sizeprefix));
        strcat(str,(byte*)"[");
        plus = (byte*)"";
        if (!!((i64)(*a).reg)) {
            strcat(str,mc_libmcl$strreg((i64)(*a).reg,(i64)8));
            plus = (byte*)"+";
        }
;
        if (!!((i64)(*a).regix)) {
            strcat(str,plus);
            strcat(str,mc_libmcl$strreg((i64)(*a).regix,(i64)8));
            plus = (byte*)"+";
            if (((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)4,(i64)7) > (i64)1)) {
                strcat(str,(byte*)"*");
                strcat(str,msysc$strint((i64)msysc$m_getdotslice((i64)(*a).misc,(i64)4,(i64)7),0));
            }
;
        }
;
        if ((msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15) == (i64)6 || msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15) == (i64)7)) {
            if (((u64)(*plus) == '+')) {
                strcat(str,plus);
            }
;
            strcat(str,mc_libmcl$strvalue(a));
        }
        else if (!!((offset = (i64)(*a).offset))) {
            msysc$m_print_startstr(str2);
            msysc$m_print_i64(offset,(byte*)"+");
            msysc$m_print_end();
            ;
            strcat(str,str2);
        }
;
        strcat(str,(byte*)"]");
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"BAD OPND",NULL);
        msysc$m_print_u64(msysc$m_getdotslice((i64)(*a).misc,(i64)8,(i64)11),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        return (byte*)"<BAD OPND>";
    }
    };
    return str;
}

static u8 *mc_libmcl$strreg(i64 reg,i64 size) {
        struct mm_decls$strec *  d;
    d = mc_libmcl$checkregvar(reg,(i64)0);
    if (((size == (i64)8) && !!(d))) {
        return mc_libmcl$getdispname(d);
    }
    else {
        return mc_libmcl$getregname(reg,size);
    }
;
}

static struct mm_decls$strec *mc_libmcl$checkregvar(i64 reg,i64 isfloat) {
    return (struct mm_decls$strec *)0;
}

u8 *mc_libmcl$strvalue(struct mc_decls$opndrec *a) {
        static u8 str[512];
        u8 str2[128];
        struct mm_decls$strec *  def;
        i64 value;
        i64 offset;
    def = (*a).def;
    value = (*a).value;
    strcpy((u8 *)str,(byte*)"");
        {u64 $temp = msysc$m_getdotslice((i64)(*a).misc,(i64)12,(i64)15);
if (($temp==(u64)6u)) {
        strcat((u8 *)str,mc_libmcl$getdispname(def));
        //addoffset:
L983 :;
;
        if (!!((offset = (i64)(*a).offset))) {
            msysc$m_print_startstr(str2);
            msysc$m_print_str(((offset > (i64)0) ? (byte*)"+" : (byte*)""),NULL);
            msysc$m_print_nogap();
            msysc$m_print_i64(offset,NULL);
            msysc$m_print_end();
            ;
            strcat((u8 *)str,(u8 *)str2);
        }
;
    }
    else if (($temp==(u64)1u)) {
        strcat((u8 *)str,msysc$strint(value,0));
    }
    else if (($temp==(u64)2u)) {
        msysc$m_print_startstr(str);
        msysc$m_print_r64((*a).xvalue,(byte*)"20.20");
        msysc$m_print_end();
        ;
    }
    else if (($temp==(u64)3u)) {
        strcat((u8 *)str,(byte*)"M");
        strcat((u8 *)str,msysc$strreal((*a).xvalue,0));
    }
    else if (($temp==(u64)4u)) {
        strcat((u8 *)str,(byte*)"\"");
        strcat((u8 *)str,(*a).svalue);
        strcat((u8 *)str,(byte*)"\"");
    }
    else if (($temp==(u64)8u)) {
        strcat((u8 *)str,(*a).svalue);
    }
    else if (($temp==(u64)7u)) {
        strcat((u8 *)str,(byte*)"L");
        strcat((u8 *)str,msysc$strint((*a).labelno,0));
        goto L983 ;
;
    }
    };
    return (u8 *)str;
}

static struct mc_decls$opndrec *mc_libmcl$makesimpleaddr(struct mc_decls$opndrec *ax) {
        i64 reg;
    if (((!!((i64)(*ax).reg) && ((i64)(*ax).regix == (i64)0)) && ((i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)12,(i64)15) == (i64)0))) {
        return ax;
    }
;
    reg = mc_libmcl$getnextreg();
    mc_libmcl$genmc((i64)16,mc_libmcl$genreg(reg,(i64)8),ax);
    return mc_libmcl$genireg(reg,(i64)8,(i64)0);
}

static struct mc_decls$opndrec *mc_libmcl$makeblockaddr(struct mc_decls$opndrec *ax) {
    if (((i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11) == (i64)1)) {
        return mc_libmcl$makeopndind(ax,(i64)0);
    }
;
    return mc_libmcl$makesimpleaddr(ax);
}

void mc_libmcl$clearblock(struct mc_decls$opndrec *ax,i64 n) {
        struct mc_decls$opndrec *  rx;
        struct mc_decls$opndrec *  rcount;
        i64 nwords;
        i64 lab;
        i64 oddbytes;
        i64 offset;
        i64 workreg;
        i64 countreg;
        i64 $av_1;
        i64 i;
    ax = mc_libmcl$makeblockaddr(ax);
    oddbytes = (n % (i64)8);
    n -= oddbytes;
    nwords = (n / (i64)8);
    rx = mc_libmcl$genreg((workreg = mc_libmcl$getnextreg()),(i64)8);
    mc_libmcl$genmc((i64)42,rx,rx);
    offset = (i64)0;
    if (((i64)1<=nwords && nwords<=(i64)8)) {
        ax = mc_libmcl$changeopndsize(ax,(i64)8);
        $av_1 = nwords;
        while ($av_1-- > 0) {
L984 :;
            mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)0),rx);
            offset += (i64)8;
L985 :;
        }
L986 :;
        ;
    }
    else if ((nwords != (i64)0)) {
        if (!!((nwords & (i64)3))) {
            rcount = mc_libmcl$genreg((countreg = mc_libmcl$getnextreg()),(i64)8);
            lab = ++(mc_decls$mlabelno);
            ax = mc_libmcl$makesimpleaddr(ax);
            mc_libmcl$genmc((i64)13,rcount,mc_libmcl$genint(nwords,(i64)8));
            mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(lab),0);
            mc_libmcl$genmc((i64)13,ax,rx);
            mc_libmcl$genmc((i64)30,mc_libmcl$genreg((i64)(*ax).reg,(i64)8),mc_libmcl$genint((i64)8,(i64)8));
            mc_libmcl$genmc((i64)55,rcount,0);
            mc_libmcl$genmc_cond((i64)28,(i64)5,mc_libmcl$genlabel(lab),0);
            offset = (i64)0;
            {
                mc_libmcl$clrregbit(countreg);
                ++(mc_decls$nregs);
            }
        }
        else {
            rcount = mc_libmcl$genreg((countreg = mc_libmcl$getnextreg()),(i64)8);
            lab = ++(mc_decls$mlabelno);
            ax = mc_libmcl$makesimpleaddr(ax);
            mc_libmcl$genmc((i64)13,rcount,mc_libmcl$genint((nwords / (i64)4),(i64)8));
            mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(lab),0);
            for (i=(i64)1;i<=(i64)4;++i) {
L987 :;
                mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)0),rx);
                offset += (i64)8;
L988 :;
            }
L989 :;
            ;
            mc_libmcl$genmc((i64)30,mc_libmcl$genreg((i64)(*ax).reg,(i64)8),mc_libmcl$genint((i64)32,(i64)8));
            mc_libmcl$genmc((i64)55,rcount,0);
            mc_libmcl$genmc_cond((i64)28,(i64)5,mc_libmcl$genlabel(lab),0);
            offset = (i64)0;
            {
                mc_libmcl$clrregbit(countreg);
                ++(mc_decls$nregs);
            }
        }
;
    }
;
    if (!!(oddbytes)) {
        n = oddbytes;
        if ((n >= (i64)4)) {
            rx = mc_libmcl$changeopndsize(rx,(i64)4);
            mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)4),rx);
            n -= (i64)4;
            offset += (i64)4;
        }
;
        if ((n >= (i64)2)) {
            rx = mc_libmcl$changeopndsize(rx,(i64)2);
            mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)2),rx);
            n -= (i64)2;
            offset += (i64)2;
        }
;
        if ((n == (i64)1)) {
            rx = mc_libmcl$changeopndsize(rx,(i64)1);
            mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)1),rx);
        }
;
    }
;
    {
        mc_libmcl$clrregbit(workreg);
        ++(mc_decls$nregs);
    }
}

void mc_libmcl$copyblock(struct mc_decls$opndrec *ax,struct mc_decls$opndrec *bx,i64 n,i64 savedest) {
        struct mc_decls$opndrec *  rx;
        struct mc_decls$opndrec *  rcount;
        i64 nwords;
        i64 lab;
        i64 oddbytes;
        i64 offset;
        i64 countreg;
        i64 axreg;
        i64 regs;
        i64 $av_1;
    mc_libmcl$gencomment((byte*)"COPY BLOCK",0);
    ax = mc_libmcl$makeblockaddr(ax);
    bx = mc_libmcl$makeblockaddr(bx);
    mc_libmcl$gencomment(mc_libmcl$stropnd(ax,(i64)0,(i64)0),0);
    mc_libmcl$gencomment(mc_libmcl$stropnd(bx,(i64)0,(i64)0),0);
    regs = (i64)mc_decls$regset;
    oddbytes = (n % (i64)8);
    n -= oddbytes;
    nwords = (n / (i64)8);
    rx = mc_libmcl$genreg((i64)0,(i64)8);
    offset = (i64)0;
    if (((i64)1<=nwords && nwords<=(i64)4)) {
        ax = mc_libmcl$changeopndsize(ax,(i64)8);
        bx = mc_libmcl$changeopndsize(bx,(i64)8);
        $av_1 = nwords;
        while ($av_1-- > 0) {
L990 :;
            mc_libmcl$genmc((i64)13,rx,mc_libmcl$applyoffset(bx,offset,(i64)0));
            mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)0),rx);
            offset += (i64)8;
L991 :;
        }
L992 :;
        ;
    }
    else if ((nwords != (i64)0)) {
        rcount = mc_libmcl$genreg((countreg = mc_libmcl$getnextreg()),(i64)8);
        lab = ++(mc_decls$mlabelno);
        if (!!(savedest)) {
            axreg = (i64)(*ax).reg;
            mc_libmcl$genmc((i64)14,mc_libmcl$genreg(axreg,(i64)8),0);
        }
;
        ax = mc_libmcl$makesimpleaddr(ax);
        bx = mc_libmcl$makesimpleaddr(bx);
        (*ax).misc = msysc$m_setdotslice((*ax).misc,(i64)0,(i64)3,(*bx).misc = msysc$m_setdotslice((*bx).misc,(i64)0,(i64)3,(u64)8u));
        mc_libmcl$genmc((i64)13,rcount,mc_libmcl$genint(nwords,(i64)8));
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(lab),0);
        mc_libmcl$genmc((i64)13,rx,bx);
        mc_libmcl$genmc((i64)13,ax,rx);
        mc_libmcl$genmc((i64)30,mc_libmcl$genreg((i64)(*ax).reg,(i64)8),mc_libmcl$genint((i64)8,(i64)8));
        mc_libmcl$genmc((i64)30,mc_libmcl$genreg((i64)(*bx).reg,(i64)8),mc_libmcl$genint((i64)8,(i64)8));
        mc_libmcl$genmc((i64)55,rcount,0);
        mc_libmcl$genmc_cond((i64)28,(i64)5,mc_libmcl$genlabel(lab),0);
        if (!!(savedest)) {
            mc_libmcl$genmc((i64)15,mc_libmcl$genreg(axreg,(i64)8),0);
        }
;
        offset = (i64)0;
        {
            mc_libmcl$clrregbit(countreg);
            ++(mc_decls$nregs);
        }
    }
;
    if (!!(oddbytes)) {
        n = oddbytes;
        if ((n >= (i64)4)) {
            rx = mc_libmcl$changeopndsize(rx,(i64)4);
            mc_libmcl$genmc((i64)13,rx,mc_libmcl$applyoffset(bx,offset,(i64)4));
            mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)4),rx);
            n -= (i64)4;
            offset += (i64)4;
        }
;
        if ((n >= (i64)2)) {
            rx = mc_libmcl$changeopndsize(rx,(i64)2);
            mc_libmcl$genmc((i64)13,rx,mc_libmcl$applyoffset(bx,offset,(i64)2));
            mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)2),rx);
            n -= (i64)2;
            offset += (i64)2;
        }
;
        if ((n == (i64)1)) {
            rx = mc_libmcl$changeopndsize(rx,(i64)1);
            mc_libmcl$genmc((i64)13,rx,mc_libmcl$applyoffset(bx,offset,(i64)1));
            mc_libmcl$genmc((i64)13,mc_libmcl$applyoffset(ax,offset,(i64)1),rx);
        }
;
    }
;
    mc_libmcl$popregs((u64)regs,0);
}

void mc_libmcl$genfunctable(void) {
        u8 *  s;
        u8 *  t;
        struct mm_decls$procrec *  pp;
        i64 firststringlab;
        i64 nextlab;
        i64 nprocs;
    if ((mc_decls$lab_funcaddrtable == (i64)0)) {
        return;
    }
;
    mc_libmcl$gencomment((byte*)"Function Table",0);
    nprocs = (i64)0;
    mc_libmcl$setsegment((i64)67,(i64)16);
    mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$lab_funcaddrtable),0);
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L993 :;
    while (!!(pp)) {
        mc_libmcl$genmc((i64)118,mc_libmcl$genmemaddr((*pp).def),0);
        ++(nprocs);
L994 :;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L996 :;
            }
L995 :;
    ;
    firststringlab = (i64)0;
    mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$lab_funcnametable),0);
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L997 :;
    while (!!(pp)) {
        if ((firststringlab == (i64)0)) {
            firststringlab = (nextlab = ++(mc_decls$mlabelno));
        }
        else {
            nextlab = ++(mc_decls$mlabelno);
        }
;
        mc_libmcl$genmc((i64)118,mc_libmcl$genlabel(nextlab),0);
L998 :;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L1000 :;
            }
L999 :;
    ;
    nextlab = firststringlab;
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L1001 :;
    while (!!(pp)) {
        mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(nextlab),0);
        s = (*(*pp).def).name;
        t = s;
        L1005 :;
        while (!!((u64)(*s))) {
            if (((u64)(*s) == '.')) {
                t = (s + (i64)1);
            }
;
            ++(s);
L1006 :;
        }
L1007 :;
        ;
        mc_libmcl$genstringimm(t,(i64)1);
        ++(nextlab);
L1002 :;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L1004 :;
            }
L1003 :;
    ;
    mc_libmcl$genmc((i64)11,mc_libmcl$genlabel(mc_decls$lab_funcnprocs),0);
    mc_libmcl$genmc((i64)118,mc_libmcl$genint(nprocs,(i64)8),0);
}

struct mc_decls$opndrec *mc_libmcl$genextname(u8 *s) {
        u8 str[64];
        struct mm_decls$strec *  d;
    strcpy((u8 *)str,s);
    str[(strlen(s))-1] = (u64)0u;
    d = (struct mm_decls$strec *)mlib$pcm_allocz((i64)193);
    (*d).name = mlib$pcm_copyheapstring((u8 *)str);
    (*d).flags = msysc$m_setdotindex((*d).flags,(i64)12,(u64)1u);
    return mc_libmcl$genmemaddr(d);
}

void mc_libmcl$domcl_assem(struct mm_decls$unitrec *pcode) {
    if ((!(!!(pcode)) || ((i64)(*pcode).tag != (i64)8))) {
        return;
    }
;
    mc_decls$inf_assem = (i64)1;
    mc_libmcl$genmc((i64)(*pcode).asmopcode,mc_libmcl$genasmopnd((*pcode).a),mc_libmcl$genasmopnd((*pcode).b));
    (*mc_decls$mccodex).cond = (i64)(*pcode).cond;
        {i64 $temp = (i64)(*pcode).asmopcode;
if (($temp==(i64)91) || ($temp==(i64)92)) {
        if ((((*pcode).c == 0) || ((i64)(*(*pcode).c).tag != (i64)1))) {
            mm_support$gerror((byte*)"pcmpistr/no imm",0);
        }
;
        (*mc_decls$mccodex).c = (*(*pcode).c).value;
    }
    };
}

static struct mc_decls$opndrec *mc_libmcl$genasmopnd(struct mm_decls$unitrec *p) {
        struct mc_decls$opndrec *  ax;
        struct mm_decls$strec *  d;
        i64 offset;
        i64 labno;
        struct mm_decls$unitrec *  a;
        struct mm_decls$unitrec *  x;
        struct mm_decls$unitrec *  y;
    if ((p == 0)) {
        return 0;
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)10)) {
        ax = mc_libmcl$genreg((i64)(*p).reg,(i64)(*p).regsize);
    }
    else if (($temp==(i64)1)) {
        ax = mc_libmcl$genint((*p).value,(i64)8);
    }
    else if (($temp==(i64)12)) {
        a = (*p).a;
        d = 0;
        offset = (labno = (i64)0);
        if (!!(a)) {
                        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
                offset = (*a).value;
            }
            else if (($temp==(i64)4)) {
                d = (*a).def;
                if (((i64)(*d).nameid == (i64)17)) {
                    labno = (i64)(*d).labelno;
                    d = 0;
                }
;
            }
            else if (($temp==(i64)34)) {
                x = (*a).a;
                y = (*a).b;
                if ((((i64)(*x).tag == (i64)4) && ((i64)(*y).tag == (i64)1))) {
                    d = (*x).def;
                    if (((i64)(*d).nameid == (i64)17)) {
                        labno = (i64)(*d).labelno;
                        d = 0;
                    }
;
                }
                else {
                    goto L1008 ;
;
                }
;
                offset = (((i64)(*a).pclop == (i64)1 || (i64)(*a).pclop == (i64)26) ? (*y).value : -((*y).value));
            }
            else if (($temp==(i64)35)) {
                if (((i64)(*a).pclop != (i64)29)) {
                    mc_libmcl$merror((byte*)"assume/unary",(byte*)"");
                }
;
                if (!(((i64)(*(*a).a).tag == (i64)1))) {
                    mm_support$gerror((byte*)"-name",0);
                }
;
                offset = -((*(*a).a).value);
            }
            else if (($temp==(i64)92)) {
                mc_libmcl$merror((byte*)"ASSEM/SYSFN?",(byte*)"");
            }
            else {
                //error:
L1008 :;
;
                msysc$m_print_startcon();
                msysc$m_print_str(mm_tables$jtagnames[((i64)(*a).tag)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                mm_support$gerror((byte*)"Can't do memexpr",0);
            }
            };
        }
;
        ax = mc_libmcl$genindex((i64)(*p).reg,(i64)(*p).regix,(i64)(*p).scale,offset,(i64)mm_decls$ttsize[((i64)(*p).prefixmode)],labno,d);
    }
    else if (($temp==(i64)4)) {
        d = (*p).def;
        if (((i64)(*d).nameid == (i64)17)) {
            if (((i64)(*d).labelno == (i64)0)) {
                (*d).labelno = ++(mc_decls$mlabelno);
            }
;
            labno = (i64)(*d).labelno;
            ax = mc_libmcl$genlabel(labno);
        }
        else {
            ax = mc_libmcl$genmemaddr(d);
        }
;
    }
    else if (($temp==(i64)11)) {
        ax = mc_libmcl$genxreg((i64)(*p).reg,(i64)8);
    }
    else if (($temp==(i64)34)) {
        x = (*p).a;
        y = (*p).b;
        if ((((i64)(*x).tag == (i64)4) && ((i64)(*y).tag == (i64)1))) {
            d = (*x).def;
            offset = (((i64)(*p).pclop == (i64)1 || (i64)(*p).pclop == (i64)26) ? (*y).value : -((*y).value));
            if (((i64)(*d).nameid == (i64)17)) {
                labno = (i64)(*d).labelno;
                ax = mc_libmcl$genlabel(labno);
            }
            else {
                ax = mc_libmcl$genmemaddr(d);
            }
;
            (*ax).offset = offset;
        }
        else {
            mm_support$gerror((byte*)"ax:imm/add",0);
        }
;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(mm_tables$jtagnames[((i64)(*p).tag)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$gerror((byte*)"genasmopnd?",0);
    }
    };
    return ax;
}

i64 mc_libmcl$getnextreg(void) {
        i64 r;
    for (r=(i64)1;r<=(i64)10;++r) {
L1009 :;
        if ((mc_libmcl$getregbit(r) == (i64)0)) {
            mc_libmcl$setregbit(r);
            mc_decls$inf_highreg=(mc_decls$inf_highreg>r?mc_decls$inf_highreg:r);
;
            ++(mc_decls$nregs);
            return r;
        }
;
L1010 :;
    }
L1011 :;
    ;
    mc_libmcl$merror((byte*)"GNR: no more regs",(byte*)"");
    return (i64)0;
}

i64 mc_libmcl$getnextxreg(void) {
        i64 r;
    for (r=(i64)25;r<=(i64)36;++r) {
L1012 :;
        if ((mc_libmcl$getregbit(r) == (i64)0)) {
            mc_libmcl$setregbit(r);
            mc_decls$inf_highxreg=(mc_decls$inf_highxreg>r?mc_decls$inf_highxreg:r);
;
            ++(mc_decls$nxregs);
            return r;
        }
;
L1013 :;
    }
L1014 :;
    ;
    mc_libmcl$merror((byte*)"GNXR: no more regs",(byte*)"");
    return (i64)0;
}

void mc_libmcl$pushstack(i64 n) {
    if (!!(n)) {
        mc_libmcl$genmc((i64)31,mc_decls$dstackopnd,mc_libmcl$genint(n,(i64)8));
    }
;
}

void mc_libmcl$popstack(i64 n) {
    if (!!(n)) {
        mc_libmcl$genmc((i64)30,mc_decls$dstackopnd,mc_libmcl$genint(n,(i64)8));
    }
;
}

u8 *mc_libmcl$showregset(u8 *caption) {
        static u8 str[300];
        i64 i;
    msysc$m_print_startstr(str);
    msysc$m_print_str(caption,(byte*)"8JL");
    msysc$m_print_space();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=(i64)36;++i) {
L1015 :;
        if (((i == (i64)15 || i == (i64)16) || (i >= (i64)17 && i <= (i64)20))) {
            goto L1016 ;
        }
;
        strcat(str,msysc$strint(mc_libmcl$getregbit(i),0));
        strcat(str,(byte*)" ");
        if ((i == (i64)3 || i == (i64)10 || i == (i64)14 || i == (i64)24 || i == (i64)26)) {
            strcat(str,(byte*)" ");
            if ((i == (i64)14)) {
                strcat(str,(byte*)"// ");
            }
;
        }
;
L1016 :;
    }
L1017 :;
    ;
    return str;
}

void mc_libmcl$stacklooplabels(i64 a,i64 b,i64 c) {
    ++(mc_libmcl$loopindex);
    if ((mc_libmcl$loopindex > (i64)50)) {
        mm_support$gerror((byte*)"Too many nested loops",0);
    }
;
    mc_libmcl$loopstack[(mc_libmcl$loopindex)-1][((i64)1)-1] = a;
    mc_libmcl$loopstack[(mc_libmcl$loopindex)-1][((i64)2)-1] = b;
    mc_libmcl$loopstack[(mc_libmcl$loopindex)-1][((i64)3)-1] = c;
}

i64 mc_libmcl$findlooplabel(i64 k,i64 n) {
        i64 i;
    i = (mc_libmcl$loopindex - (n - (i64)1));
    if (((i < (i64)1) || (i > mc_libmcl$loopindex))) {
        mm_support$gerror((byte*)"Bad loop index",0);
    }
;
    return mc_libmcl$loopstack[(i)-1][(k)-1];
}

i64 mc_libmcl$getopndmov(struct mc_decls$opndrec *ax) {
        {u64 $temp = msysc$m_getdotslice((i64)(*ax).misc,(i64)8,(i64)11);
if (($temp==(u64)2u)) {
        if (((i64)msysc$m_getdotslice((i64)(*ax).misc,(i64)0,(i64)3) == (i64)4)) {
            return (i64)18;
        }
        else {
            return (i64)19;
        }
;
    }
    else if (($temp==(u64)1u)) {
        return (i64)13;
    }
    else {
        return mm_support$gerror((byte*)"getopndmov?",0);
    }
    };
}

struct mc_decls$opndrec *mc_libmcl$getregopnd(struct mm_decls$unitrec *a) {
    if (!!((i64)mm_decls$ttisreal[((i64)(*a).mode)])) {
        return mc_libmcl$genxreg(mc_libmcl$getnextxreg(),(i64)8);
    }
    else {
        return mc_libmcl$genreg(mc_libmcl$getnextreg(),(i64)8);
    }
;
}

i64 mc_libmcl$getmclcond(i64 cond,i64 mode) {
        static byte scondcodes[6] = {(u8)4u,(u8)5u,(u8)12u,(u8)14u,(u8)13u,(u8)15u};
        static byte ucondcodes[6] = {(u8)4u,(u8)5u,(u8)2u,(u8)6u,(u8)3u,(u8)7u};
    if (!!((i64)mm_decls$ttsigned[(mode)])) {
        return (i64)scondcodes[((cond - (i64)17))];
    }
    else {
        return (i64)ucondcodes[((cond - (i64)17))];
    }
;
}

void mc_libmcl$popregs(u64 regs,struct mc_decls$opndrec *ax) {
    mc_decls$regset = regs;
    if (!!(ax)) {
        if (!!((i64)(*ax).reg)) {
            mc_libmcl$setregbit((i64)(*ax).reg);
        }
;
        if (!!((i64)(*ax).regix)) {
            mc_libmcl$setregbit((i64)(*ax).regix);
        }
;
    }
;
}

i64 mc_libmcl$getlowreg(struct mc_decls$opndrec *ax) {
        i64 reg;
    reg = (i64)0;
    if ((!!((i64)(*ax).reg) && ((i64)(*ax).reg != (i64)15))) {
        reg = (i64)(*ax).reg;
    }
;
    if ((!!((i64)(*ax).regix) && ((i64)(*ax).regix != (i64)15))) {
        if (!!(reg)) {
            reg = msysc$m_imin(reg,(i64)(*ax).regix);
        }
        else {
            reg = (i64)(*ax).regix;
        }
;
    }
;
    if (!!(reg)) {
        return reg;
    }
;
    return mc_libmcl$getnextreg();
}

void mc_libmcl$mulimm(struct mc_decls$opndrec *ax,i64 n) {
        i64 shifts;
        i64 m;
    if ((n==(i64)0)) {
        mc_libmcl$genmc((i64)42,ax,ax);
        return;
    }
    else if ((n==(i64)1)) {
        return;
    }
    else if ((n==(i64)-1)) {
        mc_libmcl$genmc((i64)52,ax,0);
        return;
    }
;
    shifts = (i64)0;
    m = n;
    L1018 :;
    while (!(msysc$m_getdotindex(m,(i64)0))) {
        m >>= (i64)1;
        ++(shifts);
L1019 :;
    }
L1020 :;
    ;
    if (!!(shifts)) {
        mc_libmcl$genmc((i64)45,ax,mc_libmcl$genint(shifts,(i64)8));
    }
;
    if ((m==(i64)1)) {
        return;
    }
    else if ((m==(i64)3) || (m==(i64)5) || (m==(i64)9)) {
        mc_libmcl$genmc((i64)16,ax,mc_libmcl$genindex((i64)(*ax).reg,(i64)(*ax).reg,(m - (i64)1),(i64)0,(i64)0,(i64)0,0));
    }
    else {
        if (!!(shifts)) {
            (*mc_decls$mccodex).opcode = (i64)36;
            (*mc_decls$mccodex).b = mc_libmcl$genint(n,(i64)8);
        }
        else {
            mc_libmcl$genmc((i64)36,ax,mc_libmcl$genint(n,(i64)8));
        }
;
    }
;
}

i64 mc_libmcl$scaleindex(struct mc_decls$opndrec *ax,i64 scale) {
    if ((scale == (i64)1 || scale == (i64)2 || scale == (i64)4 || scale == (i64)8)) {
        return scale;
    }
;
    mc_libmcl$mulimm(ax,scale);
    return (i64)1;
}

struct mc_decls$opndrec *mc_libmcl$gensysfn(i64 fnindex,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c) {
    return mc_libmcl$gensysproc(fnindex,a,b,c,(i64)1);
}

struct mc_decls$opndrec *mc_libmcl$gensysproc(i64 fnindex,struct mm_decls$unitrec *a,struct mm_decls$unitrec *b,struct mm_decls$unitrec *c,i64 asfunc) {
        struct mm_decls$unitrec *  arglist[32];
        byte argcomplex[32];
        i64 nargs;
        i64 highcomplex;
        i64 j;
        i64 stackbytes;
        i64 oldstackdepth;
        struct mm_decls$strec *  d;
        i64 i;
    ++(mc_decls$ncalldepth);
    oldstackdepth = mc_decls$mstackdepth;
    arglist[((i64)1)-1] = a;
    arglist[((i64)2)-1] = b;
    arglist[((i64)3)-1] = c;
    nargs = (i64)0;
    for (i=(i64)1;i<=(i64)3;++i) {
L1021 :;
        if (!!(arglist[(i)-1])) {
            ++(nargs);
        }
;
L1022 :;
    }
L1023 :;
    ;
    stackbytes = (i64)0;
    if (!!(msysc$m_getdotindex(mc_decls$mstackdepth,(i64)0))) {
        stackbytes = (i64)8;
        mc_libmcl$pushstack((i64)8);
        ++(mc_decls$mstackdepth);
    }
;
    highcomplex = (i64)0;
    for (i=(i64)1;i<=nargs;++i) {
L1024 :;
        argcomplex[(i)-1] = (j = (!!((i64)(*arglist[(i)-1]).simple) ? (i64)0 : (i64)2));
        if (!!(j)) {
            highcomplex = i;
        }
;
L1025 :;
    }
L1026 :;
    ;
    if (!!(highcomplex)) {
        argcomplex[(highcomplex)-1] = (i64)1;
    }
;
    for (i=(i64)1;i<=nargs;++i) {
L1027 :;
        if (!!((i64)argcomplex[(i)-1])) {
            if ((i != highcomplex)) {
                mc_blockmcl$pushunit(arglist[(i)-1]);
            }
;
        }
;
L1028 :;
    }
L1029 :;
    ;
    if (!!(highcomplex)) {
        mc_blockmcl$loadarg(arglist[(highcomplex)-1],highcomplex,(i64)0);
    }
;
    for (i=(i64)1;i<=nargs;++i) {
L1030 :;
        if (((i64)argcomplex[(i)-1] == (i64)0)) {
            mc_blockmcl$loadarg(arglist[(i)-1],i,(i64)0);
        }
;
L1031 :;
    }
L1032 :;
    ;
    for (i=nargs;i>=(i64)1;--i) {
L1033 :;
        if (((i64)argcomplex[(i)-1] == (i64)2)) {
            mc_blockmcl$poptoarg((i64)(*arglist[(i)-1]).mode,i,(i64)0);
        }
;
L1034 :;
    }
L1035 :;
    ;
    if (!!(mc_decls$mstackdepth)) {
        stackbytes += (i64)32;
        mc_libmcl$pushstack((i64)32);
        mc_decls$mstackdepth += (i64)4;
    }
;
    d = mc_libmcl$getsysfnhandler(fnindex);
    if (!!(d)) {
        mc_libmcl$genmc((i64)23,mc_libmcl$genmemaddr(d),0);
    }
    else {
        mc_libmcl$genmc((i64)23,mc_libmcl$genname((mm_tables$sysfnnames[(fnindex)-1] + (i64)3)),0);
    }
;
    if (!!(stackbytes)) {
        mc_libmcl$popstack(stackbytes);
    }
;
    mc_decls$mstackdepth = oldstackdepth;
    --(mc_decls$ncalldepth);
    if (!(!!(asfunc))) {
        return 0;
    }
;
    return mc_libmcl$genreg((i64)1,(i64)8);
}

struct mm_decls$strec *mc_libmcl$getsysfnhandler(i64 fn) {
        struct mm_decls$strec *  p;
        u8 str[300];
        i64 report;
        struct mm_decls$procrec *  pp;
    if (!!(mm_tables$sysfnhandlers[(fn)-1])) {
        return mm_tables$sysfnhandlers[(fn)-1];
    }
;
    strcpy(str,(byte*)"m$");
    strcat(str,(mm_tables$sysfnnames[(fn)-1] + (i64)3));
    pp = (struct mm_decls$procrec *)mm_decls$proclist;
    L1036 :;
    while (!!(pp)) {
        if (!!(mlib$eqstring((*(*pp).def).name,str))) {
            mm_tables$sysfnhandlers[(fn)-1] = (*pp).def;
            return (*pp).def;
        }
;
L1037 :;
        pp = (struct mm_decls$procrec *)(*pp).nextproc;
L1039 :;
            }
L1038 :;
    ;
    report = (i64)(mm_decls$passlevel > (i64)9);
    if (!!(report)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Sysfn not found:",NULL);
        msysc$m_print_str(str,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((fn != (i64)36)) {
        p = mc_libmcl$getsysfnhandler((i64)36);
        if (((p == 0) && !!(report))) {
            mm_support$gerror((byte*)"No m$unimpl",0);
        }
;
        return p;
    }
;
    return (struct mm_decls$strec *)0;
}

static void mc_libmcl$setbit(u64 *a,i64 n,i64 x) {
    if (!!(x)) {
        (*a) |= (u64)((i64)1 << n);
    }
    else {
        (*a) &= (u64)~(((i64)1 << n));
    }
;
}

static i64 mc_libmcl$getbit(u64 a,i64 n) {
    return ((i64)(a >> n) & (i64)1);
}

void mc_libmcl$setregbit(i64 n) {
    mc_decls$regset |= (u64)((i64)1 << n);
}

void mc_libmcl$clrregbit(i64 n) {
    mc_decls$regset &= (u64)~(((i64)1 << n));
}

i64 mc_libmcl$getregbit(i64 n) {
    return ((i64)(mc_decls$regset >> n) & (i64)1);
}

void mc_libmcl$setxregbit(i64 n) {
    mc_decls$regset |= (u64)((i64)1 << (n + (i64)32));
}

void mc_libmcl$clrxregbit(i64 n) {
    mc_decls$regset &= (u64)~(((i64)1 << (n + (i64)32)));
}

i64 mc_libmcl$getxregbit(i64 n) {
    return ((i64)(mc_decls$regset >> (n + (i64)32)) & (i64)1);
}

void mc_libmcl$setopndsize(struct mc_decls$opndrec *ax,i64 size) {
    if ((size==(i64)1) || (size==(i64)2) || (size==(i64)4) || (size==(i64)8)) {
        (*ax).misc = msysc$m_setdotslice((*ax).misc,(i64)0,(i64)3,(u64)size);
    }
    else if ((size==(i64)0)) {
        (*ax).misc = msysc$m_setdotslice((*ax).misc,(i64)0,(i64)3,(u64)8u);
    }
    else {
        (*ax).misc = msysc$m_setdotslice((*ax).misc,(i64)0,(i64)3,(u64)0u);
    }
;
}

struct mc_decls$opndrec *mc_libmcl$getretopnd(i64 mode) {
        struct mc_decls$opndrec *  ax;
        i64 reg;
        i64 m;
        i32 (*pmult)[];
        struct mc_decls$opndrec *  axmult[10];
        i64 i;
    if (!!((i64)mm_decls$ttisreal[(mode)])) {
        if (!!(mc_libmcl$getregbit((i64)21))) {
            mm_support$gerror((byte*)"ret:xr0 in use",0);
        }
;
        return mc_libmcl$genxreg((i64)21,(i64)mm_decls$ttsize[(mode)]);
    }
    else if (((i64)mm_decls$ttbasetype[(mode)] == (i64)27)) {
        mc_libmcl$nmultregs = (i64)mm_decls$ttlength[(mode)];
        pmult = mm_decls$ttmult[(mode)];
        for (i=(i64)1;i<=mc_libmcl$nmultregs;++i) {
L1040 :;
            m = (i64)(*pmult)[(i)-1];
            if (!!((i64)mm_decls$ttisreal[(m)])) {
                reg = (((i64)21 + i) - (i64)1);
            }
            else {
                reg = (((i64)1 + i) - (i64)1);
            }
;
            if (!!(mc_libmcl$getregbit((i64)21))) {
                mm_support$gerror((byte*)"retmult:reg in use",0);
            }
;
            axmult[(i)-1] = mc_libmcl$genreg(reg,(i64)mm_decls$ttsize[(mode)]);
            mc_decls$multregs[(i)-1] = reg;
L1041 :;
        }
L1042 :;
        ;
        return axmult[((i64)1)-1];
    }
    else {
        if (!!(mc_libmcl$getregbit((i64)1))) {
            mc_libmcl$gencomment((byte*)"RET/R0 IN USE",0);
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"RET/R0 IN USE",NULL);
            msysc$m_print_str((*mm_decls$currproc).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        ax = mc_libmcl$genreg((i64)1,(i64)8);
        if (((i64)mm_decls$ttcat[(mode)] == (i64)4)) {
            mc_libmcl$genmc((!!((i64)mm_decls$ttsigned[(mode)]) ? (i64)20 : (i64)21),ax,mc_libmcl$genreg((i64)1,(i64)mm_decls$ttsize[(mode)]));
        }
;
        return mc_libmcl$genreg((i64)1,(i64)8);
    }
;
}

// START
void mc_libmcl$start(void) {

}

// START
void mc_decls$start(void) {

}

// START
void mc_objdecls$start(void) {

}

struct mx_decls$librec *mc_run$writememlib(u8 *filename) {
        struct mx_decls$librec *  plib;
        i64 k;
        struct mx_decls$librec lib;
        i64 ndlls;
        i64 nlibs;
        i64 i;
    memset(&(lib),0,216);
    mc_decls$ss_zdatalen = mlib$roundtoblock(mc_decls$ss_zdatalen,(i64)8);
    mc_run$roundsegment((struct mc_decls$dbuffer *)mc_decls$ss_code,(i64)8,(i64)144);
    mc_run$roundsegment((struct mc_decls$dbuffer *)mc_decls$ss_idata,(i64)8,(i64)0);
    lib.version = (byte*)"0.1234";
    lib.filespec = filename;
    lib.libname = mlib$pcm_copyheapstring(mlib$extractbasefile(filename));
    lib.libno = (i64)1;
    mc_write$countsymbols();
    mc_run$writerelocs((struct mx_decls$librec *)&lib);
    lib.zdatasize = mc_decls$ss_zdatalen;
    lib.codesize = mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_decls$ss_code);
    lib.idatasize = mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_decls$ss_idata);
    lib.codeptr = (byte *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_decls$ss_code,(i64)0);
    lib.idataptr = (byte *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_decls$ss_idata,(i64)0);
    ndlls = (i64)0;
    nlibs = (i64)0;
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L1043 :;
        if (((u64)(*mm_decls$libfiles[(i)]) != '$')) {
            if (((i64)mm_decls$libtypes[(i)] == (i64)68)) {
                ++(ndlls);
            }
            else {
                ++(nlibs);
            }
;
        }
;
L1044 :;
    }
L1045 :;
    ;
    lib.ndlllibs = ndlls;
    lib.nlibs = nlibs;
    lib.dllnames = (u8 *(*)[])mlib$pcm_alloc(((i64)8 * ndlls));
    lib.libnames = (u8 *(*)[])mlib$pcm_alloc(((i64)8 * nlibs));
    k = (i64)0;
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L1046 :;
        if ((((u64)(*mm_decls$libfiles[(i)]) != '$') && ((i64)mm_decls$libtypes[(i)] == (i64)68))) {
            (*lib.dllnames)[(++(k))-1] = mm_decls$libfiles[(i)];
        }
;
L1047 :;
    }
L1048 :;
    ;
    k = (i64)0;
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L1049 :;
        if ((((u64)(*mm_decls$libfiles[(i)]) != '$') && ((i64)mm_decls$libtypes[(i)] == (i64)76))) {
            (*lib.libnames)[(++(k))-1] = mm_decls$libfiles[(i)];
        }
;
L1050 :;
    }
L1051 :;
    ;
    mc_run$addsymbols((struct mx_decls$librec *)&lib);
    plib = (struct mx_decls$librec *)mlib$pcm_alloc((i64)216);
    memcpy(plib,&lib,(u64)216u);
    return plib;
}

static void mc_run$roundsegment(struct mc_decls$dbuffer *p,i64 align,i64 value) {
        i64 length;
        i64 newlength;
        i64 $av_1;
    length = mc_genss$bufferlength((struct mc_decls$dbuffer *)p);
    newlength = mlib$roundtoblock(length,align);
    mc_genss$buffercheck((struct mc_decls$dbuffer *)p,align);
    $av_1 = (newlength - length);
    while ($av_1-- > 0) {
L1052 :;
        (*((*p).pcurr)++) = value;
L1053 :;
    }
L1054 :;
    ;
}

static void mc_run$writerelocs(struct mx_decls$librec *lib) {
        struct mc_decls$relocrec *  oldr;
        struct mx_decls$mcxreloc newr;
        i64 k;
        struct mm_decls$strec *  d;
        u64 *  baseptr64;
        i64 i;
    (*lib).nrelocs = (mc_decls$ss_nidatarelocs + mc_decls$ss_ncoderelocs);
    (*lib).reloctable = (struct mx_decls$mcxreloc (*)[])mlib$pcm_alloc(((*lib).nrelocs * (i64)8));
    k = (i64)0;
    for (i=(i64)1;i<=(i64)2;++i) {
L1055 :;
        oldr = (struct mc_decls$relocrec *)((i == (i64)1) ? mc_decls$ss_idatarelocs : mc_decls$ss_coderelocs);
        L1058 :;
        while (!!(oldr)) {
            memset(&(newr),0,8);
            newr.offset = (*oldr).offset;
            newr.segment = ((i == (i64)1) ? (i64)2 : (i64)1);
            d = (*mc_decls$ss_symboltable)[((*oldr).stindex)-1];
                        {i64 $temp = (*oldr).reloctype;
if (($temp==(i64)4)) {
                if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
                    newr.stindex = (i64)(*d).impindex;
                    newr.reloctype = (i64)5;
                }
                else {
                    mm_support$axerror((byte*)"rel32/rel not imported");
                }
;
            }
            else if (($temp==(i64)2) || ($temp==(i64)1)) {
                if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
                    newr.reloctype = (((*oldr).reloctype == (i64)2) ? (i64)3 : (i64)4);
                    newr.stindex = (i64)(*d).impindex;
                }
                else {
                    if (((*oldr).reloctype == (i64)2)) {
                        newr.reloctype = (i64)1;
                    }
                    else {
                        newr.reloctype = (i64)2;
                    }
;
                    newr.targetsegment = (i64)(*d).segment;
                }
;
            }
            else {
                mm_support$axerror((byte*)"reloc?");
            }
            };
            (*(*lib).reloctable)[(++(k))-1] = newr;
L1059 :;
            oldr = (struct mc_decls$relocrec *)(*oldr).nextreloc;
L1061 :;
                    }
L1060 :;
        ;
L1056 :;
    }
L1057 :;
    ;
}

static void mc_run$addsymbols(struct mx_decls$librec *lib) {
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  stentry;
        u64 epoffset;
        i64 k;
        i64 i;
    stentry = 0;
    epoffset = (u64)18446744073709551615u;
    (*lib).nimports = mx_decls$nsymimports;
    (*lib).nexports = mx_decls$nsymexports;
    (*lib).importnames = (u8 *(*)[])mlib$pcm_alloc((mx_decls$nsymimports * (i64)8));
    (*lib).exports = (u8 *(*)[])mlib$pcm_alloc((mx_decls$nsymexports * (i64)8));
    (*lib).exportsegs = (byte (*)[])mlib$pcm_alloc(mx_decls$nsymexports);
    (*lib).exportoffsets = (u64 (*)[])mlib$pcm_alloc((mx_decls$nsymexports * (i64)8));
    k = (i64)0;
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L1062 :;
        if (!!((i64)(*(*mc_decls$ss_symboltable)[(i)-1]).impindex)) {
            d = (*mc_decls$ss_symboltable)[(i)-1];
            (*(*lib).importnames)[(++(k))-1] = (!!((*d).truename) ? (*d).truename : (*d).name);
        }
;
L1063 :;
    }
L1064 :;
    ;
    k = (i64)0;
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L1065 :;
        d = (*mc_decls$ss_symboltable)[(i)-1];
        if (!!((i64)(*d).expindex)) {
            if (!!(mlib$eqstring((*d).name,(byte*)"main"))) {
                stentry = d;
            }
;
            (*(*lib).exports)[(++(k))-1] = (*d).name;
            (*(*lib).exportsegs)[(k)-1] = (i64)(*d).segment;
            (*(*lib).exportoffsets)[(k)-1] = (u64)(i64)(*d).offset;
        }
;
L1066 :;
    }
L1067 :;
    ;
    if (!!(stentry)) {
        (*lib).entryoffset = (u64)(i64)(*stentry).offset;
    }
    else {
        (*lib).entryoffset = (u64)18446744073709551615u;
    }
;
}

// START
void mc_run$start(void) {

}

void mc_write$writemcx(u8 *filename) {
        i64 n;
        i64 ndlls;
        i64 nlibs;
        i64 i;
    mc_decls$ss_zdatalen = mlib$roundtoblock(mc_decls$ss_zdatalen,(i64)8);
    mc_write$roundsegment((struct mc_decls$dbuffer *)mc_decls$ss_code,(i64)8,(i64)144);
    mc_write$roundsegment((struct mc_decls$dbuffer *)mc_decls$ss_idata,(i64)8,(i64)0);
    mc_write$dest = (struct mc_decls$dbuffer *)mc_genss$buffercreate((i64)1024);
    mc_write$genword32((i64)441992013);
    mc_write$genbyte((i64)1);
    mc_write$genstring((byte*)"0.1234");
    mc_write$countsymbols();
    mc_write$writerelocs();
    mc_write$genbyte((i64)4);
    mc_write$genword32(mc_decls$ss_zdatalen);
    mc_write$genbyte((i64)2);
    mc_write$genword32((n = mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_decls$ss_code)));
    mc_write$genblock(mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_decls$ss_code,(i64)0),n);
    mc_write$genbyte((i64)3);
    mc_write$genword32((n = mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_decls$ss_idata)));
    mc_write$genblock(mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_decls$ss_idata,(i64)0),n);
    ndlls = (i64)0;
    nlibs = (i64)0;
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L1068 :;
        if (((u64)(*mm_decls$libfiles[(i)]) != '$')) {
            if (((i64)mm_decls$libtypes[(i)] == (i64)68)) {
                ++(ndlls);
            }
            else {
                ++(nlibs);
            }
;
        }
;
L1069 :;
    }
L1070 :;
    ;
    mc_write$genbyte((i64)6);
    mc_write$genword32(ndlls);
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L1071 :;
        if ((((u64)(*mm_decls$libfiles[(i)]) != '$') && ((i64)mm_decls$libtypes[(i)] == (i64)68))) {
            mc_write$genstring(mm_decls$libfiles[(i)]);
        }
;
L1072 :;
    }
L1073 :;
    ;
    mc_write$genbyte((i64)7);
    mc_write$genword32(nlibs);
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L1074 :;
        if ((((u64)(*mm_decls$libfiles[(i)]) != '$') && ((i64)mm_decls$libtypes[(i)] == (i64)76))) {
            mc_write$genstring(mm_decls$libfiles[(i)]);
        }
;
L1075 :;
    }
L1076 :;
    ;
    mc_write$writesymbols();
    mc_write$genbyte((i64)13);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"WRITE MX FILE",NULL);
    msysc$m_print_str(filename,NULL);
    msysc$m_print_str((byte*)"DEST.PSTART=",NULL);
    msysc$m_print_ptr((*mc_write$dest).pstart,NULL);
    msysc$m_print_i64(((*mc_write$dest).pcurr - (*mc_write$dest).pstart),NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$writefile(filename,(*mc_write$dest).pstart,((*mc_write$dest).pcurr - (*mc_write$dest).pstart));
}

void mc_write$writerelocs(void) {
        struct mc_decls$relocrec *  oldr;
        struct mx_decls$mcxreloc newr;
        i64 n;
        i64 count;
        struct mm_decls$strec *  d;
        u64 *  baseptr64;
        i64 i;
    mc_write$genbyte((i64)5);
    mc_write$genword32((n = (mc_decls$ss_nidatarelocs + mc_decls$ss_ncoderelocs)));
    count = (i64)0;
    for (i=(i64)1;i<=(i64)2;++i) {
L1077 :;
        oldr = (struct mc_decls$relocrec *)((i == (i64)1) ? mc_decls$ss_idatarelocs : mc_decls$ss_coderelocs);
        L1080 :;
        while (!!(oldr)) {
            ++(count);
            memset(&(newr),0,8);
            newr.offset = (*oldr).offset;
            newr.segment = ((i == (i64)1) ? (i64)2 : (i64)1);
            d = (*mc_decls$ss_symboltable)[((*oldr).stindex)-1];
                        {i64 $temp = (*oldr).reloctype;
if (($temp==(i64)4)) {
                if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
                    newr.stindex = (i64)(*d).impindex;
                    newr.reloctype = (i64)5;
                }
                else {
                    mm_support$axerror((byte*)"rel32/rel not imported");
                }
;
            }
            else if (($temp==(i64)2) || ($temp==(i64)1)) {
                if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
                    newr.reloctype = (((*oldr).reloctype == (i64)2) ? (i64)3 : (i64)4);
                    newr.stindex = (i64)(*d).impindex;
                }
                else {
                    if (((*oldr).reloctype == (i64)2)) {
                        newr.reloctype = (i64)1;
                    }
                    else {
                        newr.reloctype = (i64)2;
                    }
;
                    newr.targetsegment = (i64)(*d).segment;
                }
;
            }
            else {
                mm_support$axerror((byte*)"reloc?");
            }
            };
            mc_write$genblock(&newr,(i64)8);
L1081 :;
            oldr = (struct mc_decls$relocrec *)(*oldr).nextreloc;
L1083 :;
                    }
L1082 :;
        ;
L1078 :;
    }
L1079 :;
    ;
}

void mc_write$countsymbols(void) {
        struct mm_decls$strec *  d;
        i64 i;
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L1084 :;
        d = (*mc_decls$ss_symboltable)[(i)-1];
        if (((i64)(*d).scope == (i64)3)) {
            (*d).expindex = ++(mx_decls$nsymexports);
        }
;
        if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
            (*d).impindex = ++(mx_decls$nsymimports);
        }
;
L1085 :;
    }
L1086 :;
    ;
}

static void mc_write$writesymbols(void) {
        struct mm_decls$strec *  d;
        i64 i;
    mc_write$genbyte((i64)8);
    mc_write$genword32(mx_decls$nsymimports);
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L1087 :;
        if (!!((i64)(*(*mc_decls$ss_symboltable)[(i)-1]).impindex)) {
            d = (*mc_decls$ss_symboltable)[(i)-1];
            mc_write$genstring((!!((*d).truename) ? (*d).truename : (*d).name));
        }
;
L1088 :;
    }
L1089 :;
    ;
    mc_write$genbyte((i64)9);
    mc_write$genword32(mx_decls$nsymexports);
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L1090 :;
        d = (*mc_decls$ss_symboltable)[(i)-1];
        if (!!((i64)(*d).expindex)) {
            if (!!(mlib$eqstring((*d).name,(byte*)"main"))) {
                mc_write$entrypoint = d;
            }
;
            mc_write$genstring((*d).name);
        }
;
L1091 :;
    }
L1092 :;
    ;
    mc_write$genbyte((i64)10);
    mc_write$genword32(mx_decls$nsymexports);
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L1093 :;
        d = (*mc_decls$ss_symboltable)[(i)-1];
        if (!!((i64)(*d).expindex)) {
            mc_write$genbyte((i64)(*d).segment);
        }
;
L1094 :;
    }
L1095 :;
    ;
    mc_write$genbyte((i64)11);
    mc_write$genword32(mx_decls$nsymexports);
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L1096 :;
        d = (*mc_decls$ss_symboltable)[(i)-1];
        if (!!((i64)(*d).expindex)) {
            mc_write$genword32((i64)(*d).offset);
        }
;
L1097 :;
    }
L1098 :;
    ;
    mc_write$genbyte((i64)12);
    if (!!(mc_write$entrypoint)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"ENTRYPT",NULL);
        msysc$m_print_i64((i64)(*mc_write$entrypoint).offset,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mc_write$genword32((i64)(*mc_write$entrypoint).offset);
    }
    else {
        mc_write$genword32((i64)4294967295);
    }
;
}

static void mc_write$roundsegment(struct mc_decls$dbuffer *p,i64 align,i64 value) {
        i64 length;
        i64 newlength;
        i64 $av_1;
    length = mc_genss$bufferlength((struct mc_decls$dbuffer *)p);
    newlength = mlib$roundtoblock(length,align);
    mc_genss$buffercheck((struct mc_decls$dbuffer *)p,align);
    $av_1 = (newlength - length);
    while ($av_1-- > 0) {
L1099 :;
        (*((*p).pcurr)++) = value;
L1100 :;
    }
L1101 :;
    ;
}

static void mc_write$genbyte(i64 x) {
    mc_genss$buffercheck((struct mc_decls$dbuffer *)mc_write$dest,(i64)1);
    (*((*mc_write$dest).pcurr)++) = x;
}

static void mc_write$genword32(i64 x) {
    mc_genss$buffercheck((struct mc_decls$dbuffer *)mc_write$dest,(i64)4);
    (*((*mc_write$dest).pcurr32)++) = x;
}

static void mc_write$genstring(u8 *s) {
    mc_write$genblock((void *)s,(strlen(s) + (i64)1));
}

static void mc_write$genblock(void *p,i64 length) {
    mc_genss$buffercheck((struct mc_decls$dbuffer *)mc_write$dest,length);
    memcpy((*mc_write$dest).pcurr,p,(u64)length);
    (*mc_write$dest).pcurr += length;
}

// START
void mc_write$start(void) {

}

void mc_writeexe$writeexe(u8 *outfile,i64 dodll) {
        i64 i;
    mc_writeexe$dllfilename = mlib$extractfile(outfile);
    mc_writeexe$isdll = dodll;
    mc_writeexe$datastart = (mc_writeexe$dataptr = (byte *)mlib$pcm_allocz(mc_writeexe$filesize));
    mc_writeexe$writedosstub();
    mc_writeexe$writepesig();
    mc_writeexe$writefileheader();
    mc_writeexe$writeoptheader();
    for (i=(i64)1;i<=mc_writeexe$nsections;++i) {
L1102 :;
        mc_writeexe$writesectionheader((struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[(i)-1]);
L1103 :;
    }
L1104 :;
    ;
    mc_writeexe$writepadding(mc_writeexe$sectiontable[((i64)1)-1].rawoffset);
    for (i=(i64)1;i<=mc_writeexe$nsections;++i) {
L1105 :;
        mc_writeexe$writesectiondata((struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[(i)-1]);
L1106 :;
    }
L1107 :;
    ;
    if ((mlib$writefile(outfile,mc_writeexe$datastart,(mc_writeexe$dataptr - mc_writeexe$datastart)) == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Error writing exe file (possibly still running)",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
;
}

void mc_writeexe$genexe(u8 *entrypoint,u8 *outfile,i64 dodll) {
    mc_writeexe$dllfilename = mlib$extractfile(outfile);
    mc_writeexe$isdll = dodll;
    mc_writeexe$imagebase = (!!(mc_writeexe$isdll) ? (i64)268435456 : (i64)4194304);
    mc_writeexe$userentrypoint = entrypoint;
    mc_writeexe$loadlibs();
    mc_writeexe$scanst();
    mc_writeexe$getoffsets();
    mc_writeexe$relocdata(&mc_writeexe$sectiontable[((i64)1)-1]);
    mc_writeexe$relocdata(&mc_writeexe$sectiontable[((i64)2)-1]);
}

static void mc_writeexe$loadlibs(void) {
        i64 i;
        i64 hinst;
        u8 filename[300];
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L1108 :;
        if (((u64)(*mm_decls$libfiles[(i)]) != '$')) {
            if (((i64)mm_decls$libtypes[(i)] == (i64)76)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"LIBFILES[I]=",NULL);
                msysc$m_print_str(mm_decls$libfiles[(i)],NULL);
                msysc$m_print_i64((i64)mm_decls$libtypes[(i)],(byte*)"c");
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                mm_support$axerror((byte*)"Can't use LIB files with EXE");
            }
;
            strcpy((u8 *)filename,mm_decls$libfiles[(i)]);
            hinst = (i64)mlinux$os_getdllinst((u8 *)filename);
            if ((hinst == (i64)0)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"File:",NULL);
                msysc$m_print_str(filename,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                mm_support$axerror((byte*)"Can't load search lib");
            }
;
            mc_writeexe$libinsttable[(i)-1] = hinst;
            mc_writeexe$libinstnames[(i)-1] = mlib$pcm_copyheapstring((u8 *)filename);
        }
;
L1109 :;
    }
L1110 :;
    ;
}

void mc_writeexe$initsectiontable(void) {
    mc_writeexe$sectiontable[((i64)1)-1].name = (byte*)".text";
    mc_writeexe$sectiontable[((i64)1)-1].segtype = (i64)1;
    mc_writeexe$sectiontable[((i64)1)-1].data = (struct mc_decls$dbuffer *)mc_decls$ss_code;
    mc_writeexe$sectiontable[((i64)1)-1].virtsize = mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_decls$ss_code);
    if ((mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_decls$ss_idata) == (i64)0)) {
        mc_genss$addqword((struct mc_decls$dbuffer *)mc_decls$ss_idata,(i64)0);
    }
;
    mc_writeexe$sectiontable[((i64)2)-1].name = (byte*)".data";
    mc_writeexe$sectiontable[((i64)2)-1].segtype = (i64)2;
    mc_writeexe$sectiontable[((i64)2)-1].data = (struct mc_decls$dbuffer *)mc_decls$ss_idata;
    mc_writeexe$sectiontable[((i64)2)-1].virtsize = mc_genss$bufferlength((struct mc_decls$dbuffer *)mc_decls$ss_idata);
    mc_writeexe$sectiontable[((i64)2)-1].rawsize = mlib$roundtoblock(mc_writeexe$sectiontable[((i64)2)-1].virtsize,(i64)512);
    mc_writeexe$sectiontable[((i64)2)-1].nrelocs = mc_decls$ss_nidatarelocs;
    mc_writeexe$sectiontable[((i64)2)-1].relocs = (struct mc_decls$relocrec *)mc_decls$ss_idatarelocs;
    if ((mc_decls$ss_zdatalen == (i64)0)) {
        mc_decls$ss_zdatalen = (i64)16;
    }
;
    mc_writeexe$sectiontable[((i64)3)-1].name = (byte*)".bss";
    mc_writeexe$sectiontable[((i64)3)-1].segtype = (i64)3;
    mc_writeexe$sectiontable[((i64)3)-1].virtsize = mc_decls$ss_zdatalen;
    mc_writeexe$sectiontable[((i64)1)-1].rawsize = mlib$roundtoblock(mc_writeexe$sectiontable[((i64)1)-1].virtsize,(i64)512);
    mc_writeexe$sectiontable[((i64)1)-1].nrelocs = mc_decls$ss_ncoderelocs;
    mc_writeexe$sectiontable[((i64)1)-1].relocs = (struct mc_decls$relocrec *)mc_decls$ss_coderelocs;
    mc_writeexe$sectiontable[((i64)4)-1].name = (byte*)".idata";
    mc_writeexe$sectiontable[((i64)4)-1].segtype = (i64)5;
    mc_writeexe$sectiontable[((i64)4)-1].virtsize = (i64)0;
    mc_writeexe$sectiontable[((i64)4)-1].rawsize = (i64)0;
    mc_writeexe$nsections = (i64)4;
}

static u8 *mc_writeexe$extractlibname(u8 *name,i64 *libno,i64 moduleno) {
        u8 *  s;
        u8 *  name2;
        u8 str[256];
        i64 i;
        i64 n;
    name2 = 0;
    //reenter:
L1111 :;
;
    s = name;
    (*libno) = (i64)0;
    L1112 :;
    while (!!((u64)(*s))) {
        if (((u64)(*s) == '.')) {
            memcpy(str,(void *)name,(u64)(s - name));
            str[(((s - name) + (i64)1))-1] = (u64)0u;
            strcat((u8 *)str,(byte*)".dll");
            for (i=(i64)1;i<=mc_writeexe$ndlls;++i) {
L1115 :;
                if (!!(mlib$eqstring((u8 *)str,mc_writeexe$dlltable[(i)-1].name))) {
                    (*libno) = i;
                    ++(mc_writeexe$dlltable[((*libno))-1].nprocs);
                    return (!!(name2) ? name2 : (s + (i64)1));
                }
;
L1116 :;
            }
L1117 :;
            ;
            if ((mc_writeexe$ndlls >= (i64)50)) {
                mm_support$axerror((byte*)"Too many libs");
            }
;
            (*libno) = ++(mc_writeexe$ndlls);
            mc_writeexe$dlltable[((*libno))-1].name = mlib$pcm_copyheapstring((u8 *)str);
            mc_writeexe$dlltable[((*libno))-1].nprocs = (i64)1;
            return (!!(name2) ? name2 : (s + (i64)1));
        }
;
        ++(s);
L1113 :;
    }
L1114 :;
    ;
    for (i=(i64)1;i<=mm_decls$nlibfiles;++i) {
L1118 :;
        if (!!(mc_writeexe$libinsttable[(i)-1])) {
            if (!!(mlinux$os_getdllprocaddr(mc_writeexe$libinsttable[(i)-1],name))) {
                n = i;
                goto L1120 ;
            }
;
        }
;
L1119 :;
    }
    {
        msysc$m_print_startcon();
        msysc$m_print_str(name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mm_support$axerror((byte*)"Can't find external function");
    }
L1120 :;
    ;
    if (!!(((*libno) = mc_writeexe$libnotable[(n)-1]))) {
        ++(mc_writeexe$dlltable[((*libno))-1].nprocs);
        return name;
    }
;
    strcpy((u8 *)str,mm_decls$libfiles[(n)]);
    strcat((u8 *)str,(byte*)".dll");
    if ((mc_writeexe$ndlls >= (i64)50)) {
        mm_support$axerror((byte*)"2:Too many libs");
    }
;
    (*libno) = ++(mc_writeexe$ndlls);
    mc_writeexe$dlltable[((*libno))-1].name = mlib$pcm_copyheapstring((u8 *)str);
    mc_writeexe$dlltable[((*libno))-1].nprocs = (i64)1;
    mc_writeexe$libnotable[(n)-1] = (*libno);
    return name;
}

static void mc_writeexe$scanst(void) {
        i64 i;
        i64 libno;
        struct mm_decls$strec *  d;
        u8 *  name;
        u8 *  dname;
        u8 *  basename;
    for (i=(i64)1;i<=mc_decls$ss_nsymbols;++i) {
L1121 :;
        d = (*mc_decls$ss_symboltable)[(i)-1];
        dname = (!!((*d).truename) ? (*d).truename : (*d).name);
        if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
            if ((mc_writeexe$nimports >= (i64)3000)) {
                mm_support$axerror((byte*)"genexe: Too many imports");
            }
;
            ++(mc_writeexe$nimports);
            name = mc_writeexe$extractlibname(dname,&libno,(i64)1);
            mc_writeexe$importtable[(mc_writeexe$nimports)].libno = libno;
            mc_writeexe$importtable[(mc_writeexe$nimports)].name = name;
            mc_writeexe$importtable[(mc_writeexe$nimports)].def = d;
            (*d).importindex = mc_writeexe$nimports;
        }
        else if (((i64)(*d).scope == (i64)3)) {
            basename = mm_lib$getbasename(dname);
            if (!!(mc_writeexe$userentrypoint)) {
                if (!!(mlib$eqstring(basename,mc_writeexe$userentrypoint))) {
                    mc_writeexe$stentrypoint = d;
                }
;
            }
            else {
                if ((!!(mlib$eqstring(basename,(byte*)"main")) && !(!!(mc_writeexe$isdll)))) {
                    mc_writeexe$stentrypoint = d;
                }
;
            }
;
            if ((mc_writeexe$nexports >= (i64)1000)) {
                mm_support$axerror((byte*)"gendll: Too many exports");
            }
;
            ++(mc_writeexe$nexports);
            mc_writeexe$exporttable[(mc_writeexe$nexports)-1].def = d;
            mc_writeexe$exporttable[(mc_writeexe$nexports)-1].name = mm_lib$getbasename(dname);
        }
;
L1122 :;
    }
L1123 :;
    ;
}

static void mc_writeexe$relocdata(struct mc_objdecls$sectionrec *s) {
        struct mc_objdecls$sectionrec *  u;
        struct mc_decls$relocrec *  r;
        byte *  p;
        u32 *  p32;
        u64 *  p64;
        struct mm_decls$strec *  d;
        i64 index;
        i64 thunkoffset;
    p = (byte *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)(*s).data,(i64)0);
    r = (struct mc_decls$relocrec *)(*s).relocs;
    L1124 :;
    while (!!(r)) {
        d = (*mc_decls$ss_symboltable)[((*r).stindex)-1];
        index = (i64)(*d).importindex;
        thunkoffset = mc_writeexe$importtable[(index)].thunkoffset;
                {i64 $temp = (*r).reloctype;
if (($temp==(i64)4)) {
            if (!(!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12)))) {
                mm_support$axerror((byte*)"rel32/not imported");
            }
;
            (*(u32 *)(p + (*r).offset)) = ((thunkoffset - (*r).offset) - (i64)4);
        }
        else if (($temp==(i64)2) || ($temp==(i64)1)) {
            if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
                (*(u32 *)(p + (*r).offset)) = ((mc_writeexe$imagebase + thunkoffset) + mc_writeexe$sectiontable[((i64)1)-1].virtoffset);
            }
            else {
                u = 0;
                                {i64 $temp = (i64)(*d).segment;
if (($temp==(i64)3)) {
                    u = (struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[((i64)3)-1];
                }
                else if (($temp==(i64)2)) {
                    u = (struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[((i64)2)-1];
                }
                else if (($temp==(i64)1)) {
                    u = (struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[((i64)1)-1];
                }
                else {
                    msysc$m_print_startcon();
                    msysc$m_print_str((*d).name,NULL);
                    msysc$m_print_i64((i64)(*d).segment,NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    mm_support$axerror((byte*)"RELOCDATA/SEG?");
                }
                };
                p32 = (u32 *)(p + (*r).offset);
                if (((*r).reloctype == (i64)2)) {
                    (*p32) = (((i64)(*p32) + (*u).virtoffset) + mc_writeexe$imagebase);
                }
                else {
                    p64 = (u64 *)p32;
                    (*p64) = (u64)(((i64)(*p64) + (*u).virtoffset) + mc_writeexe$imagebase);
                }
;
            }
;
        }
        else {
            msysc$m_print_startcon();
            msysc$m_print_str(mc_objdecls$relocnames[((*r).reloctype)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"Can't do this rel type");
        }
        };
        r = (struct mc_decls$relocrec *)(*r).nextreloc;
L1125 :;
    }
L1126 :;
    ;
}

static void mc_writeexe$getbaserelocs(struct mc_objdecls$sectionrec *s) {
        struct mc_objdecls$sectionrec *  u;
        struct mc_decls$relocrec *  r;
        byte *  p;
        struct mm_decls$strec *  d;
    p = (byte *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)(*s).data,(i64)0);
    r = (struct mc_decls$relocrec *)(*s).relocs;
    L1127 :;
    while (!!(r)) {
        d = (*mc_decls$ss_symboltable)[((*r).stindex)-1];
                {i64 $temp = (*r).reloctype;
if (($temp==(i64)2) || ($temp==(i64)1)) {
            if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)12))) {
            }
            else {
                                {i64 $temp = (i64)(*d).segment;
if (($temp==(i64)3)) {
                    u = (struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[((i64)3)-1];
                }
                else if (($temp==(i64)2)) {
                    u = (struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[((i64)2)-1];
                }
                else if (($temp==(i64)1)) {
                    u = (struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[((i64)1)-1];
                }
                };
                mc_writeexe$newbasereloc(((*u).virtoffset + (*r).offset),(*r).reloctype);
            }
;
        }
        };
        r = (struct mc_decls$relocrec *)(*r).nextreloc;
L1128 :;
    }
L1129 :;
    ;
}

static void mc_writeexe$writerecordx(void *r,i64 length) {
    memcpy(mc_writeexe$dataptr,r,(u64)length);
    mc_writeexe$dataptr += length;
}

static void mc_writeexe$writedosstub(void) {
        static byte stubdata[128] = {
    (u8)77u,
    (u8)90u,
    (u8)144u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)255u,
    (u8)255u,
    (u8)0u,
    (u8)0u,
    (u8)184u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)128u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)14u,
    (u8)31u,
    (u8)186u,
    (u8)14u,
    (u8)0u,
    (u8)180u,
    (u8)9u,
    (u8)205u,
    (u8)33u,
    (u8)184u,
    (u8)1u,
    (u8)76u,
    (u8)205u,
    (u8)33u,
    (u8)84u,
    (u8)104u,
    (u8)105u,
    (u8)115u,
    (u8)32u,
    (u8)112u,
    (u8)114u,
    (u8)111u,
    (u8)103u,
    (u8)114u,
    (u8)97u,
    (u8)109u,
    (u8)32u,
    (u8)99u,
    (u8)97u,
    (u8)110u,
    (u8)110u,
    (u8)111u,
    (u8)116u,
    (u8)32u,
    (u8)98u,
    (u8)101u,
    (u8)32u,
    (u8)114u,
    (u8)117u,
    (u8)110u,
    (u8)32u,
    (u8)105u,
    (u8)110u,
    (u8)32u,
    (u8)68u,
    (u8)79u,
    (u8)83u,
    (u8)32u,
    (u8)109u,
    (u8)111u,
    (u8)100u,
    (u8)101u,
    (u8)46u,
    (u8)13u,
    (u8)13u,
    (u8)10u,
    (u8)36u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
    mc_writeexe$writerecordx(&stubdata,(i64)128);
}

static void mc_writeexe$writepesig(void) {
    (*(mc_writeexe$dataptr)++) = (i64)80;
    (*(mc_writeexe$dataptr)++) = (i64)69;
    (*(mc_writeexe$dataptr)++) = (i64)0;
    (*(mc_writeexe$dataptr)++) = (i64)0;
}

static void mc_writeexe$writepadding(i64 offset) {
    mc_writeexe$dataptr = (mc_writeexe$datastart + offset);
}

static void mc_writeexe$writefileheader(void) {
        struct mc_objdecls$imagefileheader header;
    memset(&(header),0,20);
    header.machine = (i64)34404;
    header.nsections = mc_writeexe$nsections;
    header.optheadersize = (i64)240;
    header.characteristics = (i64)559;
    if (!!(mc_writeexe$isdll)) {
        header.characteristics = (i64)8750;
    }
;
    mc_writeexe$writerecordx(&header,(i64)20);
}

static void mc_writeexe$writeoptheader(void) {
        struct mc_objdecls$optionalheader header;
    memset(&(header),0,240);
    header.magic = (i64)523;
    header.majorlv = (i64)1;
    header.minorlv = (i64)0;
    header.codesize = mc_writeexe$sectiontable[((i64)1)-1].rawsize;
    header.idatasize = (mc_writeexe$sectiontable[((i64)2)-1].rawsize + mc_writeexe$sectiontable[((i64)4)-1].rawsize);
    header.zdatasize = mlib$roundtoblock(mc_writeexe$sectiontable[((i64)3)-1].virtsize,(i64)512);
    if ((mc_writeexe$stentrypoint == 0)) {
        mc_writeexe$stentrypoint = mc_writeexe$stentrypoint2;
    }
;
    if ((mc_writeexe$stentrypoint == 0)) {
        if (!!(mc_writeexe$userentrypoint)) {
            msysc$m_print_startcon();
            msysc$m_print_str(mc_writeexe$userentrypoint,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            mm_support$axerror((byte*)"User entry point not found");
        }
        else {
            if (!(!!(mc_writeexe$isdll))) {
                mm_support$axerror((byte*)"Entry point not found: main");
            }
;
        }
;
    }
    else {
        header.entrypoint = (mc_writeexe$sectiontable[((i64)1)-1].virtoffset + (i64)(*mc_writeexe$stentrypoint).offset);
    }
;
    header.codebase = (i64)4096;
    header.imagebase = (u64)mc_writeexe$imagebase;
    header.sectionalignment = (i64)4096;
    header.filealignment = (i64)512;
    header.majorosv = (i64)4;
    header.minorosv = (i64)0;
    header.majorssv = (i64)5;
    header.minorssv = (i64)2;
    header.imagesize = mc_writeexe$imagesize;
    header.headerssize = mc_writeexe$sectiontable[((i64)1)-1].rawoffset;
    header.subsystem = (i64)3;
    header.stackreserve = (u64)4194304u;
    header.stackcommit = (u64)2097152u;
    header.heapreserve = (u64)1048576u;
    header.heapcommit = (u64)4096u;
    header.rvadims = (i64)16;
    header.importtable.virtualaddr = mc_writeexe$sectiontable[((i64)4)-1].virtoffset;
    header.importtable.size = ((mc_writeexe$sectiontable[((i64)4)-1].virtsize - mc_writeexe$exportdirvirtsize) - mc_writeexe$blockdirvirtsize);
    if (!!(mc_writeexe$isdll)) {
        header.dllcharacteristics = (i64)64;
        header.exporttable.virtualaddr = mc_writeexe$exportdirvirtaddr;
        header.exporttable.size = mc_writeexe$exportdirvirtsize;
        header.basereloctable.virtualaddr = mc_writeexe$blockdirvirtaddr;
        header.basereloctable.size = mc_writeexe$blockdirvirtsize;
    }
;
    header.iat.virtualaddr = mc_writeexe$fileiatoffset;
    header.iat.size = mc_writeexe$fileiatsize;
    mc_writeexe$writerecordx(&header,(i64)240);
}

static void mc_writeexe$writesectionheader(struct mc_objdecls$sectionrec *s) {
        struct mc_objdecls$imagesectionheader sheader;
        i64 aa;
    memset(&(sheader),0,40);
    strcpy((u8 *)&sheader.name[((i64)1)-1],(*s).name);
    sheader.virtual_size = (*s).virtsize;
    sheader.virtual_address = (*s).virtoffset;
    sheader.rawdata_offset = (*s).rawoffset;
    sheader.rawdata_size = (*s).rawsize;
        {i64 $temp = (*s).segtype;
if (($temp==(i64)3)) {
        aa = (i64)3226468480;
        sheader.characteristics = aa;
    }
    else if (($temp==(i64)2)) {
        aa = (i64)3226468416;
        sheader.characteristics = aa;
    }
    else if (($temp==(i64)1)) {
        aa = (i64)1615855648;
        sheader.characteristics = aa;
    }
    else if (($temp==(i64)5)) {
        aa = (i64)3224371264;
        sheader.characteristics = aa;
    }
    };
    mc_writeexe$writerecordx(&sheader,(i64)40);
}

static void mc_writeexe$writesectiondata(struct mc_objdecls$sectionrec *s) {
        {i64 $temp = (*s).segtype;
if (($temp==(i64)5)) {
        mc_writeexe$writerecordx((*s).bytedata,(*s).virtsize);
        if (((*s).rawsize > (*s).virtsize)) {
            mc_writeexe$dataptr += ((*s).rawsize - (*s).virtsize);
        }
;
    }
    else if (($temp==(i64)3)) {
    }
    else {
        mc_writeexe$writerecordx(mc_genss$bufferelemptr((struct mc_decls$dbuffer *)(*s).data,(i64)0),(*s).rawsize);
    }
    };
}

static void mc_writeexe$writeexporttable(byte *pstart) {
        i64 sortindex[2000];
        struct mc_objdecls$exportdirrec *  phdr;
        u32 *  paddrtable;
        u32 *  pnametable;
        u16 *  pordtable;
        u8 *  pdllname;
        u8 *  pnames;
        i64 addrtableoffset;
        i64 nametableoffset;
        i64 ordtableoffset;
        i64 dllnameoffset;
        i64 namesoffset;
        i64 virtoffset;
        i64 sectionno;
        struct mm_decls$strec *  d;
        u8 *  basename;
        i64 i;
    phdr = (struct mc_objdecls$exportdirrec *)pstart;
    (*phdr).timedatestamp = (i64)1602876664;
    (*phdr).ordinalbase = (i64)1;
    (*phdr).naddrtable = mc_writeexe$nexports;
    (*phdr).nnamepointers = mc_writeexe$nexports;
    addrtableoffset = (i64)40;
    nametableoffset = (addrtableoffset + (mc_writeexe$nexports * (i64)4));
    ordtableoffset = (nametableoffset + (mc_writeexe$nexports * (i64)4));
    dllnameoffset = (ordtableoffset + (mc_writeexe$nexports * (i64)2));
    namesoffset = ((dllnameoffset + strlen(mc_writeexe$dllfilename)) + (i64)1);
    virtoffset = (mc_writeexe$sectiontable[((i64)4)-1].virtoffset + mc_writeexe$exportdiroffset);
    paddrtable = (u32 *)(pstart + addrtableoffset);
    pnametable = (u32 *)(pstart + nametableoffset);
    pordtable = (u16 *)(pstart + ordtableoffset);
    pdllname = (u8 *)(pstart + dllnameoffset);
    pnames = (u8 *)(pstart + namesoffset);
    (*phdr).namerva = (dllnameoffset + virtoffset);
    (*phdr).expaddressrva = (addrtableoffset + virtoffset);
    (*phdr).namepointerrva = (nametableoffset + virtoffset);
    (*phdr).ordtablerva = (ordtableoffset + virtoffset);
    strcpy(pdllname,mc_writeexe$dllfilename);
    if ((mc_writeexe$nexports > (i64)2000)) {
        mm_support$axerror((byte*)"Too many exports - can't sort");
    }
;
    mc_writeexe$sortexports(&sortindex);
    for (i=(i64)1;i<=mc_writeexe$nexports;++i) {
L1130 :;
        d = mc_writeexe$exporttable[(sortindex[(i)-1])-1].def;
        basename = mc_writeexe$exporttable[(sortindex[(i)-1])-1].name;
        sectionno = mc_writeexe$getsectionno((i64)(*d).segment);
        strcpy(pnames,basename);
        (*pnametable) = (namesoffset + virtoffset);
        ++(pnametable);
        namesoffset += (strlen(basename) + (i64)1);
        pnames += (strlen(basename) + (i64)1);
        (*paddrtable) = ((i64)(*d).offset + mc_writeexe$sectiontable[(sectionno)-1].virtoffset);
        ++(paddrtable);
        (*pordtable) = (i - (i64)1);
        ++(pordtable);
L1131 :;
    }
L1132 :;
    ;
}

static i64 mc_writeexe$getexporttablesize(void) {
        i64 size;
        i64 i;
    size = (i64)40;
    size += (mc_writeexe$nexports * (i64)4);
    size += (mc_writeexe$nexports * (i64)4);
    size += (mc_writeexe$nexports * (i64)2);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"DLLFILENAME=",NULL);
    msysc$m_print_str(mc_writeexe$dllfilename,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    size += (strlen(mc_writeexe$dllfilename) + (i64)1);
    for (i=(i64)1;i<=mc_writeexe$nexports;++i) {
L1133 :;
        size += (strlen((*mc_writeexe$exporttable[(i)-1].def).name) + (i64)1);
L1134 :;
    }
L1135 :;
    ;
    return size;
}

static void mc_writeexe$newbasereloc(i64 addr,i64 reltype) {
        struct mc_writeexe$basereloc *  p;
    p = (struct mc_writeexe$basereloc *)mlib$pcm_allocz((i64)16);
    (*p).address = addr;
    (*p).reloctype = reltype;
    (*p).nextitem = (struct mc_writeexe$basereloc *)mc_writeexe$basereloclist;
    mc_writeexe$basereloclist = (struct mc_writeexe$basereloc *)p;
    ++(mc_writeexe$nbaserelocs);
    mc_writeexe$maxrelocaddr=(mc_writeexe$maxrelocaddr>addr?mc_writeexe$maxrelocaddr:addr);
;
}

static void mc_writeexe$scanbaserelocs(void) {
        i64 baseaddr;
        i64 addr;
        i64 nextblock;
        struct mc_writeexe$basereloc *  p;
        i64 i;
    baseaddr = (i64)4096;
    mc_writeexe$nbaseblocks = (i64)0;
    L1136 :;
    do {
        nextblock = (baseaddr + (i64)4096);
        if ((mc_writeexe$nbaseblocks >= (i64)500)) {
            mm_support$axerror((byte*)"Too many blocks");
        }
;
        ++(mc_writeexe$nbaseblocks);
        mc_writeexe$blockbases[(mc_writeexe$nbaseblocks)-1] = baseaddr;
        mc_writeexe$blockcounts[(mc_writeexe$nbaseblocks)-1] = (i64)0;
        p = (struct mc_writeexe$basereloc *)mc_writeexe$basereloclist;
        L1139 :;
        while (!!(p)) {
            addr = (i64)(*p).address;
            if (((addr >= baseaddr) && (addr < nextblock))) {
                ++(mc_writeexe$blockcounts[(mc_writeexe$nbaseblocks)-1]);
            }
;
            p = (struct mc_writeexe$basereloc *)(*p).nextitem;
L1140 :;
        }
L1141 :;
        ;
        baseaddr = nextblock;
L1137 :;
    }
    while (!(baseaddr > mc_writeexe$maxrelocaddr));
L1138 :;
    ;
    for (i=(i64)1;i<=mc_writeexe$nbaseblocks;++i) {
L1142 :;
        if (!!((i64)mc_writeexe$blockcounts[(i)-1])) {
            if (!!(msysc$m_getdotindex((i64)mc_writeexe$blockcounts[(i)-1],(i64)0))) {
                ++(mc_writeexe$blockcounts[(i)-1]);
                ++(mc_writeexe$blockpadding[(i)-1]);
            }
;
            mc_writeexe$blockbytes[(i)-1] = (((i64)mc_writeexe$blockcounts[(i)-1] * (i64)2) + (i64)8);
            mc_writeexe$basetablesize += (i64)mc_writeexe$blockbytes[(i)-1];
        }
;
L1143 :;
    }
L1144 :;
    ;
}

static void mc_writeexe$writebasereloctable(byte *pstart) {
        u32 *  p32;
        u16 *  p16;
        i64 baseaddr;
        i64 addr;
        i64 nextblock;
        struct mc_writeexe$basereloc *  q;
        i64 i;
    p32 = (u32 *)pstart;
    for (i=(i64)1;i<=mc_writeexe$nbaseblocks;++i) {
L1145 :;
        if (!!((i64)mc_writeexe$blockcounts[(i)-1])) {
            (*p32) = mc_writeexe$blockbases[(i)-1];
            ++(p32);
            (*p32) = (i64)mc_writeexe$blockbytes[(i)-1];
            ++(p32);
            p16 = (u16 *)p32;
            q = (struct mc_writeexe$basereloc *)mc_writeexe$basereloclist;
            baseaddr = mc_writeexe$blockbases[(i)-1];
            nextblock = (baseaddr + (i64)4096);
            L1148 :;
            while (!!(q)) {
                addr = (i64)(*q).address;
                if (((addr >= baseaddr) && (addr < nextblock))) {
                    (*p16) = ((addr - baseaddr) + ((((i64)(*q).reloctype == (i64)2) ? (i64)3 : (i64)10) << (i64)12));
                    ++(p16);
                }
;
                q = (struct mc_writeexe$basereloc *)(*q).nextitem;
L1149 :;
            }
L1150 :;
            ;
            if (!!((i64)mc_writeexe$blockpadding[(i)-1])) {
                (*(p16)++) = (i64)0;
            }
;
            p32 = (u32 *)p16;
        }
;
L1146 :;
    }
L1147 :;
    ;
}

static void mc_writeexe$sortexports(i64 (*sortindex)[]) {
        struct mm_decls$strec *  d;
        struct mm_decls$strec *  e;
        i64 swapped;
        i64 $av_1;
        i64 i;
    for (i=(i64)1;i<=mc_writeexe$nexports;++i) {
L1151 :;
        (*sortindex)[(i)-1] = i;
L1152 :;
    }
L1153 :;
    ;
    L1154 :;
    do {
        swapped = (i64)0;
                ($av_1 = (mc_writeexe$nexports - (i64)1));
        for (i=(i64)1;i<=$av_1;++i) {
L1157 :;
            d = mc_writeexe$exporttable[((*sortindex)[(i)-1])-1].def;
            e = mc_writeexe$exporttable[((*sortindex)[((i + (i64)1))-1])-1].def;
            if ((strcmp(mm_lib$getbasename((*d).name),mm_lib$getbasename((*e).name)) > (i64)0)) {
                swapped = (i64)1;
                {i64 temp = (*sortindex)[(i)-1]; (*sortindex)[(i)-1] = (*sortindex)[((i + (i64)1))-1]; (*sortindex)[((i + (i64)1))-1] = temp; };
            }
;
L1158 :;
        }
L1159 :;
        ;
L1155 :;
    }
    while (!!(!!(swapped)));
L1156 :;
    ;
}

static i64 mc_writeexe$getsectionno(i64 segment) {
    if ((segment==(i64)3)) {
        return (i64)3;
    }
    else if ((segment==(i64)2)) {
        return (i64)2;
    }
    else if ((segment==(i64)1)) {
        return (i64)1;
    }
    else {
        mm_support$axerror((byte*)"GSN");
        return (i64)0;
    }
;
}

static void mc_writeexe$getoffsets(void) {
        i64 fileoffset;
        i64 imageoffset;
        i64 i;
        i64 diroffset;
        i64 impdirno;
        i64 hinttableoffset;
        i64 j;
        i64 codesize;
        i64 length;
        i64 thunkoffset;
        i64 offset;
        i64 dirstartoffset;
        byte *  pcode;
        byte *  pimpdir;
        struct mc_objdecls$importdirrec *  pdir;
        i64 *  paddr;
        i64 *  pname;
        i64 iatoffset;
        byte *  phint;
        u32 *  pextra;
        i64 xxx;
        i64 $av_1;
        byte *  thunkptr;
        byte *  codebase;
        i64 thunkaddr;
    fileoffset = (i64)392;
    fileoffset += ((i64)40 * mc_writeexe$nsections);
    fileoffset = mlib$roundtoblock(fileoffset,(i64)512);
    imageoffset = (i64)4096;
    codesize = mc_writeexe$sectiontable[((i64)1)-1].virtsize;
    pcode = (byte *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_decls$ss_code,codesize);
    L1160 :;
    while (!!((codesize & (i64)7))) {
        (*(pcode)++) = (i64)144;
        ++(codesize);
L1161 :;
    }
L1162 :;
    ;
    thunkoffset = codesize;
    codesize += (mc_writeexe$nimports * (i64)8);
    mc_writeexe$sectiontable[((i64)1)-1].virtsize = codesize;
    mc_writeexe$sectiontable[((i64)1)-1].rawsize = mlib$roundtoblock(codesize,(i64)512);
    mc_genss$buffercheck((struct mc_decls$dbuffer *)mc_decls$ss_code,((codesize - thunkoffset) + (i64)16));
    for (i=(i64)1;i<=mc_writeexe$nsections;++i) {
L1163 :;
        if ((mc_writeexe$sectiontable[(i)-1].segtype != (i64)3)) {
            mc_writeexe$sectiontable[(i)-1].rawoffset = fileoffset;
        }
;
        if ((mc_writeexe$sectiontable[(i)-1].segtype != (i64)3)) {
            fileoffset = mlib$roundtoblock((fileoffset + mc_writeexe$sectiontable[(i)-1].virtsize),(i64)512);
        }
;
        mc_writeexe$sectiontable[(i)-1].virtoffset = imageoffset;
        if ((mc_writeexe$sectiontable[(i)-1].segtype == (i64)5)) {
            diroffset = imageoffset;
            impdirno = i;
        }
;
        imageoffset = mlib$roundtoblock((imageoffset + mc_writeexe$sectiontable[(i)-1].virtsize),(i64)4096);
L1164 :;
    }
L1165 :;
    ;
    if (!!(mc_writeexe$isdll)) {
        mc_writeexe$getbaserelocs((struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[((i64)1)-1]);
        mc_writeexe$getbaserelocs((struct mc_objdecls$sectionrec *)&mc_writeexe$sectiontable[((i64)2)-1]);
    }
;
    diroffset += ((mc_writeexe$ndlls + (i64)1) * (i64)20);
    for (i=(i64)1;i<=mc_writeexe$ndlls;++i) {
L1166 :;
        mc_writeexe$dlltable[(i)-1].nametableoffset = diroffset;
        diroffset += ((mc_writeexe$dlltable[(i)-1].nprocs + (i64)1) * (i64)8);
L1167 :;
    }
L1168 :;
    ;
    mc_writeexe$fileiatoffset = diroffset;
    for (i=(i64)1;i<=mc_writeexe$ndlls;++i) {
L1169 :;
        mc_writeexe$dlltable[(i)-1].addrtableoffset = diroffset;
        diroffset += ((mc_writeexe$dlltable[(i)-1].nprocs + (i64)1) * (i64)8);
L1170 :;
    }
L1171 :;
    ;
    mc_writeexe$fileiatsize = (diroffset - mc_writeexe$fileiatoffset);
    hinttableoffset = diroffset;
    for (i=(i64)1;i<=mc_writeexe$nimports;++i) {
L1172 :;
        length = (strlen(mc_writeexe$importtable[(i)].name) + (i64)3);
        if (!!((length & (i64)1))) {
            ++(length);
        }
;
        mc_writeexe$importtable[(i)].hintnameoffset = diroffset;
        diroffset += length;
L1173 :;
    }
L1174 :;
    ;
    diroffset = mlib$roundtoblock(diroffset,(i64)4);
    for (i=(i64)1;i<=mc_writeexe$ndlls;++i) {
L1175 :;
        length = (strlen(mc_writeexe$dlltable[(i)-1].name) + (i64)1);
        if (!!((length & (i64)1))) {
            ++(length);
        }
;
        mc_writeexe$dlltable[(i)-1].dllextraoffset = diroffset;
        diroffset += (mc_writeexe$dlltable[(i)-1].nprocs * (i64)4);
        mc_writeexe$dlltable[(i)-1].dllnameoffset = diroffset;
        diroffset += length;
L1176 :;
    }
L1177 :;
    ;
    dirstartoffset = mc_writeexe$sectiontable[(impdirno)-1].virtoffset;
    if (!!(mc_writeexe$isdll)) {
        mc_writeexe$exportdirvirtaddr = diroffset;
        mc_writeexe$exportdiroffset = (diroffset - dirstartoffset);
        mc_writeexe$exportdirvirtsize = mc_writeexe$getexporttablesize();
        diroffset += mc_writeexe$exportdirvirtsize;
        mc_writeexe$scanbaserelocs();
        mc_writeexe$blockdirvirtaddr = diroffset;
        mc_writeexe$blockdiroffset = (diroffset - dirstartoffset);
        mc_writeexe$blockdirvirtsize = mc_writeexe$basetablesize;
        diroffset += mc_writeexe$blockdirvirtsize;
    }
;
    offset = (diroffset - dirstartoffset);
    mc_writeexe$sectiontable[(impdirno)-1].virtsize = offset;
    mc_writeexe$sectiontable[(impdirno)-1].rawsize = mlib$roundtoblock(offset,(i64)512);
    mc_writeexe$filesize = mlib$roundtoblock((fileoffset + offset),(i64)512);
    mc_writeexe$imagesize = mlib$roundtoblock((imageoffset + (diroffset - dirstartoffset)),(i64)4096);
    pimpdir = (mc_writeexe$sectiontable[(impdirno)-1].bytedata = (byte *)mlib$pcm_allocz(offset));
    pdir = (struct mc_objdecls$importdirrec *)pimpdir;
    for (i=(i64)1;i<=mc_writeexe$ndlls;++i) {
L1178 :;
        (*pdir).implookuprva = mc_writeexe$dlltable[(i)-1].nametableoffset;
        (*pdir).impaddressrva = mc_writeexe$dlltable[(i)-1].addrtableoffset;
        (*pdir).namerva = mc_writeexe$dlltable[(i)-1].dllnameoffset;
        ++(pdir);
        iatoffset = mc_writeexe$dlltable[(i)-1].addrtableoffset;
        paddr = (i64 *)((pimpdir + iatoffset) - dirstartoffset);
        pname = (i64 *)((pimpdir + mc_writeexe$dlltable[(i)-1].nametableoffset) - dirstartoffset);
        for (j=(i64)1;j<=mc_writeexe$nimports;++j) {
L1181 :;
            if ((mc_writeexe$importtable[(j)].libno == i)) {
                (*pname) = ((*paddr) = mc_writeexe$importtable[(j)].hintnameoffset);
                mc_writeexe$importtable[(j)].iatoffset = iatoffset;
                iatoffset += (i64)8;
                ++(pname);
                ++(paddr);
            }
;
L1182 :;
        }
L1183 :;
        ;
L1179 :;
    }
L1180 :;
    ;
    for (i=(i64)1;i<=mc_writeexe$nimports;++i) {
L1184 :;
        phint = ((pimpdir + mc_writeexe$importtable[(i)].hintnameoffset) - dirstartoffset);
        phint += (i64)2;
        strcpy((u8 *)phint,mc_writeexe$importtable[(i)].name);
L1185 :;
    }
L1186 :;
    ;
    xxx = dirstartoffset;
    for (i=(i64)1;i<=mc_writeexe$ndlls;++i) {
L1187 :;
        pextra = (u32 *)((pimpdir + mc_writeexe$dlltable[(i)-1].dllextraoffset) - dirstartoffset);
                ($av_1 = mc_writeexe$dlltable[(i)-1].nprocs);
        for (j=(i64)1;j<=$av_1;++j) {
L1190 :;
            (*pextra) = xxx;
            ++(pextra);
L1191 :;
        }
L1192 :;
        ;
        xxx += (i64)20;
        phint = ((pimpdir + mc_writeexe$dlltable[(i)-1].dllnameoffset) - dirstartoffset);
        strcpy((u8 *)phint,mc_writeexe$dlltable[(i)-1].name);
L1188 :;
    }
L1189 :;
    ;
    if (!!(mc_writeexe$isdll)) {
        mc_writeexe$writeexporttable((pimpdir + mc_writeexe$exportdiroffset));
        mc_writeexe$writebasereloctable((pimpdir + mc_writeexe$blockdiroffset));
    }
;
    thunkptr = (byte *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_decls$ss_code,thunkoffset);
    codebase = (byte *)mc_genss$bufferelemptr((struct mc_decls$dbuffer *)mc_decls$ss_code,(i64)0);
    for (i=(i64)1;i<=mc_writeexe$nimports;++i) {
L1193 :;
        mc_writeexe$importtable[(i)].thunkoffset = (thunkptr - codebase);
        (*(thunkptr)++) = (i64)255;
        (*(thunkptr)++) = (i64)37;
        thunkaddr = (mc_writeexe$importtable[(i)].iatoffset - ((mc_writeexe$sectiontable[((i64)1)-1].virtoffset + mc_writeexe$importtable[(i)].thunkoffset) + (i64)6));
        (*(i32 *)thunkptr) = thunkaddr;
        thunkptr += (i64)4;
        (*(thunkptr)++) = (i64)144;
        (*(thunkptr)++) = (i64)144;
L1194 :;
    }
L1195 :;
    ;
}

// START
void mc_writeexe$start(void) {

}

// START
void mx_decls$start(void) {
    mx_lib$start();
    mx_show$start();

}

struct mx_decls$librec *mx_lib$readlibfile(u8 *filespec,byte *p) {
        struct mx_decls$librec *  plib;
        struct mx_decls$librec lib;
        u64 sig;
        i64 dir;
        i64 n;
        i64 i;
    memset(&(lib),0,216);
    sig = mx_lib$readu32(&p);
    if ((sig != (u64)441992013u)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Bad sig - not MCX file",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
;
    lib.filespec = mlib$pcm_copyheapstring(filespec);
    lib.libname = mlib$pcm_copyheapstring(mlib$extractbasefile(filespec));
    L1196 :;
    switch ((dir = mx_lib$readbyte(&p))) {
    case 1:;
        {
            lib.version = mx_lib$readstring(&p);
        }
        break;
    case 4:;
        {
            lib.zdatasize = (i64)mx_lib$readu32(&p);
        }
        break;
    case 3:;
        {
            lib.idatasize = (n = (i64)mx_lib$readu32(&p));
            lib.idataptr = (byte *)mlib$pcm_alloc(n);
            memcpy(lib.idataptr,p,(u64)n);
            p += n;
        }
        break;
    case 2:;
        {
            lib.codesize = (n = (i64)mx_lib$readu32(&p));
            lib.codeptr = p;
            p += n;
        }
        break;
    case 6:;
        {
            lib.ndlllibs = (n = (i64)mx_lib$readu32(&p));
            lib.dllnames = (u8 *(*)[])mlib$pcm_alloc(((i64)8 * n));
            for (i=(i64)1;i<=n;++i) {
L1198 :;
                (*lib.dllnames)[(i)-1] = mx_lib$readstring(&p);
L1199 :;
            }
L1200 :;
            ;
        }
        break;
    case 7:;
        {
            lib.nlibs = (n = (i64)mx_lib$readu32(&p));
            lib.libnames = (u8 *(*)[])mlib$pcm_alloc(((i64)8 * n));
            for (i=(i64)1;i<=n;++i) {
L1201 :;
                (*lib.libnames)[(i)-1] = mx_lib$readstring(&p);
L1202 :;
            }
L1203 :;
            ;
        }
        break;
    case 8:;
        {
            lib.nimports = (n = (i64)mx_lib$readu32(&p));
            lib.importnames = (u8 *(*)[])mlib$pcm_alloc(((i64)8 * n));
            for (i=(i64)1;i<=n;++i) {
L1204 :;
                (*lib.importnames)[(i)-1] = mx_lib$readstring(&p);
L1205 :;
            }
L1206 :;
            ;
        }
        break;
    case 9:;
        {
            lib.nexports = (n = (i64)mx_lib$readu32(&p));
            lib.exports = (u8 *(*)[])mlib$pcm_alloc(((i64)8 * n));
            for (i=(i64)1;i<=n;++i) {
L1207 :;
                (*lib.exports)[(i)-1] = mx_lib$readstring(&p);
L1208 :;
            }
L1209 :;
            ;
        }
        break;
    case 10:;
        {
            n = (i64)mx_lib$readu32(&p);
            lib.exportsegs = (byte (*)[])mlib$pcm_alloc(n);
            for (i=(i64)1;i<=n;++i) {
L1210 :;
                (*lib.exportsegs)[(i)-1] = mx_lib$readbyte(&p);
L1211 :;
            }
L1212 :;
            ;
        }
        break;
    case 11:;
        {
            n = (i64)mx_lib$readu32(&p);
            lib.exportoffsets = (u64 (*)[])mlib$pcm_alloc(((i64)8 * n));
            for (i=(i64)1;i<=n;++i) {
L1213 :;
                (*lib.exportoffsets)[(i)-1] = mx_lib$readu32(&p);
L1214 :;
            }
L1215 :;
            ;
        }
        break;
    case 5:;
        {
            lib.nrelocs = (n = (i64)mx_lib$readu32(&p));
            n = (lib.nrelocs * (i64)8);
            lib.reloctable = (struct mx_decls$mcxreloc (*)[])mlib$pcm_alloc(n);
            memcpy(lib.reloctable,p,(u64)n);
            p += n;
        }
        break;
    case 12:;
        {
            lib.entryoffset = mx_lib$readu32(&p);
        }
        break;
    case 13:;
        {
            goto L1197 ;
        }
        break;
    case 0:;
        {
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Unknown directive:",NULL);
        msysc$m_print_str(mx_decls$mcxdirnames[(dir)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit(0);
    }
    } //SW
goto L1196 ;
L1197 :;
    ;
    plib = (struct mx_decls$librec *)mlib$pcm_alloc((i64)216);
    memcpy(plib,&lib,(u64)216u);
    return plib;
}

static i64 mx_lib$readbyte(byte **p) {
    return (i64)(*((*p))++);
}

static u64 mx_lib$readu32(byte **p) {
        u64 x;
    x = (u64)(i64)(*(u32 *)(*p));
    (*p) += (i64)4;
    return x;
}

static u8 *mx_lib$readstring(byte **p) {
        u8 *  s;
    s = mlib$pcm_copyheapstring((u8 *)(*p));
    L1216 :;
    while (!!((i64)(*++((*p))))) {
L1217 :;
    }
L1218 :;
    ;
    ++((*p));
    return s;
}

void mx_lib$alloclibdata(struct mx_decls$librec *lib) {
        i64 tablesize;
        i64 n;
        byte *  p;
    (*lib).zdataptr = (byte *)mlib$pcm_allocz((*lib).zdatasize);
    tablesize = ((*lib).nimports * (i64)16);
    n = (*lib).codesize;
    p = mlinux$os_allocexecmem((n + tablesize));
    if ((p == 0)) {
        mx_lib$error((byte*)"Can't alloc code memory",(byte*)"");
    }
;
    memcpy(p,(*lib).codeptr,(u64)n);
    memset((p + n),(i32)(i64)0,(u64)tablesize);
    (*lib).codeptr = p;
    (*lib).codexsize = tablesize;
    (*lib).exportaddr = (u64 (*)[])mlib$pcm_alloc(((i64)8 * (*lib).nexports));
    (*lib).importxreftable = (i16 (*)[])mlib$pcm_alloc(((i64)2 * (*lib).nimports));
    if (((i64)(*lib).entryoffset != (i64)4294967295)) {
        (*lib).entryaddr = ((*lib).codeptr + (i64)(*lib).entryoffset);
    }
;
}

void mx_lib$error(u8 *mess,u8 *param) {
    if (!!((u64)(*param))) {
        msysc$m_print_startcon();
        msysc$m_print_setfmt(mess);
        msysc$m_print_str(param,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(mess,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Aborting",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

void mx_lib$loadmemmcu(struct mx_decls$librec *lib) {
        i64 newlib;
        u8 *  name;
    name = (*lib).libname;
    mx_lib$checknew(name,(*lib).filespec);
    newlib = mx_lib$mxaddlib(name);
    mx_decls$libtable[(newlib)-1] = (struct mx_decls$librec *)lib;
    mx_lib$loadimports((struct mx_decls$librec *)lib);
}

void mx_lib$checknew(u8 *name,u8 *filename) {
    if (!!(mx_lib$findlib(name))) {
        mx_lib$error((byte*)"Lib already exists:",filename);
    }
;
}

i64 mx_lib$findlib(u8 *name) {
        i64 i;
    for (i=(i64)1;i<=mx_decls$nlibs;++i) {
L1219 :;
        if (!!(mlib$eqstring(name,mx_decls$libnametable[(i)-1]))) {
            return i;
        }
;
L1220 :;
    }
L1221 :;
    ;
    return (i64)0;
}

i64 mx_lib$mxaddlib(u8 *name) {
    if ((mx_decls$nlibs >= (i64)20)) {
        mx_lib$error((byte*)"Too many libs",(byte*)"");
    }
;
    mx_decls$libnametable[(++(mx_decls$nlibs))-1] = name;
    return mx_decls$nlibs;
}

void mx_lib$fixuplib(struct mx_decls$librec *lib) {
    mx_lib$loaddlls();
    mx_lib$checksymbols();
    mx_lib$dorelocations();
}

static void mx_lib$loaddlls(void) {
        u64 inst;
        i64 i;
    for (i=(i64)1;i<=mx_decls$ndlllibs;++i) {
L1222 :;
        if (!(!!(mx_decls$dllinsttable[(i)-1]))) {
            inst = mlinux$os_getdllinst(mx_decls$dllnametable[(i)-1]);
            if (((i64)inst == (i64)0)) {
                mx_lib$error((byte*)"Can't find DLL: #",mx_decls$dllnametable[(i)-1]);
            }
;
            mx_decls$dllinsttable[(i)-1] = inst;
        }
;
L1223 :;
    }
L1224 :;
    ;
}

static void *mx_lib$finddllsymbol(u8 *name,i64 *dllindex) {
        void *  p;
        i64 i;
    (*dllindex) = (i64)0;
    for (i=(i64)1;i<=mx_decls$ndlllibs;++i) {
L1225 :;
        p = mlinux$os_getdllprocaddr((i64)mx_decls$dllinsttable[(i)-1],name);
        if (!!(p)) {
            (*dllindex) = i;
            return p;
        }
;
L1226 :;
    }
L1227 :;
    ;
    return 0;
}

static void mx_lib$checksymbols(void) {
        i64 dllindex;
        i64 undef;
        void *  p;
        i64 i;
    undef = (i64)0;
    for (i=(i64)1;i<=mx_decls$nsymbols;++i) {
L1228 :;
        if (!(!!((i64)mx_decls$symboldefined[(i)-1]))) {
            p = mx_lib$finddllsymbol(mx_decls$symbolnametable[(i)-1],&dllindex);
            if (!!(p)) {
                mx_decls$symboladdress[(i)-1] = p;
                mx_decls$symboldllindex[(i)-1] = dllindex;
                mx_decls$symboldefined[(i)-1] = (i64)1;
            }
            else {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Undef",NULL);
                msysc$m_print_str(mx_decls$symbolnametable[(i)-1],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                ++(undef);
            }
;
        }
;
L1229 :;
    }
L1230 :;
    ;
    if (!!(undef)) {
    }
;
}

static void mx_lib$dorelocations(void) {
        i64 i;
    for (i=(i64)1;i<=mx_decls$nlibs;++i) {
L1231 :;
        if (!(!!((i64)mx_decls$librelocated[(i)-1]))) {
            mx_lib$reloclib((struct mx_decls$librec *)mx_decls$libtable[(i)-1]);
        }
;
L1232 :;
    }
L1233 :;
    ;
}

static void mx_lib$reloclib(struct mx_decls$librec *lib) {
        i64 index;
        i64 targetoffset;
        u8 *  name;
        byte *  p;
        byte *  q;
        u64 *  qaddr;
        struct mx_decls$mcxreloc r;
        i64 $av_1;
        i64 $av_2;
        i64 i;
    p = ((*lib).codeptr + (*lib).codesize);
    qaddr = (u64 *)(p + ((*lib).nimports * (i64)8));
        ($av_1 = (*lib).nimports);
    for (i=(i64)1;i<=$av_1;++i) {
L1234 :;
        name = (*(*lib).importnames)[(i)-1];
        (*(p)++) = (i64)72;
        (*(p)++) = (i64)255;
        (*(p)++) = (i64)36;
        (*(p)++) = (i64)37;
        (*(u32 *)p) = (i64)qaddr;
        p += (i64)4;
        index = (i64)(*(*lib).importxreftable)[(i)-1];
        (*(qaddr)++) = (u64)mx_decls$symboladdress[(index)-1];
L1235 :;
    }
L1236 :;
    ;
        ($av_2 = (*lib).nrelocs);
    for (i=(i64)1;i<=$av_2;++i) {
L1237 :;
        r = (*(*lib).reloctable)[(i)-1];
                {i64 $temp = (i64)r.segment;
if (($temp==(i64)1)) {
            p = ((*lib).codeptr + (i64)r.offset);
        }
        else if (($temp==(i64)2)) {
            p = ((*lib).idataptr + (i64)r.offset);
        }
        else if (($temp==(i64)3)) {
            p = ((*lib).zdataptr + (i64)r.offset);
        }
        };
                {i64 $temp = (i64)r.reloctype;
if (($temp==(i64)1)) {
            targetoffset = (i64)(*(u32 *)p);
                        {i64 $temp = (i64)r.targetsegment;
if (($temp==(i64)1)) {
                (*(u32 *)p) = (i64)((*lib).codeptr + targetoffset);
            }
            else if (($temp==(i64)2)) {
                (*(u32 *)p) = (i64)((*lib).idataptr + targetoffset);
            }
            else if (($temp==(i64)3)) {
                (*(u32 *)p) = (i64)((*lib).zdataptr + targetoffset);
            }
            };
        }
        else if (($temp==(i64)2)) {
            targetoffset = (i64)(*(u32 *)p);
                        {i64 $temp = (i64)r.targetsegment;
if (($temp==(i64)1)) {
                (*(u64 *)p) = (u64)((*lib).codeptr + targetoffset);
            }
            else if (($temp==(i64)2)) {
                (*(u64 *)p) = (u64)((*lib).idataptr + targetoffset);
            }
            else if (($temp==(i64)3)) {
                (*(u64 *)p) = (u64)((*lib).zdataptr + targetoffset);
            }
            };
        }
        else if (($temp==(i64)4)) {
            index = (i64)(*(*lib).importxreftable)[((i64)r.stindex)-1];
            (*(u64 *)p) += (u64)mx_decls$symboladdress[(index)-1];
        }
        else if (($temp==(i64)3)) {
            index = (i64)(*(*lib).importxreftable)[((i64)r.stindex)-1];
            (*(u32 *)p) += (u32)(u64)mx_decls$symboladdress[(index)-1];
        }
        else if (($temp==(i64)5)) {
            if (((i64)r.segment != (i64)1)) {
                mx_lib$error((byte*)"imprel32?",(byte*)"");
            }
;
            index = (i64)r.stindex;
            q = (((*lib).codeptr + (*lib).codesize) + ((index - (i64)1) * (i64)8));
            (*(u32 *)p) = (q - (p + (i64)4));
        }
        };
L1238 :;
    }
L1239 :;
    ;
    mx_decls$librelocated[((*lib).libno)-1] = (i64)1;
}

void mx_lib$loadimports(struct mx_decls$librec *plib) {
        i64 $av_1;
        i64 i;
        ($av_1 = (*plib).nlibs);
    for (i=(i64)1;i<=$av_1;++i) {
L1240 :;
        mx_lib$dosublib((*(*plib).libnames)[(i)-1]);
L1241 :;
    }
L1242 :;
    ;
    mx_lib$alloclibdata((struct mx_decls$librec *)plib);
    mx_lib$dosymbols((struct mx_decls$librec *)plib);
}

static void mx_lib$dosublib(u8 *name) {
        struct mx_decls$librec *  qlib;
        i64 n;
    n = mx_lib$findlib(name);
    if (!(!!(n))) {
        n = mx_lib$mxaddlib(name);
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Loading sublib",NULL);
        msysc$m_print_str(name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qlib = (struct mx_decls$librec *)mx_lib$loadlibfile(mlib$addext(name,(byte*)"ml"),n);
        mx_lib$loadimports((struct mx_decls$librec *)qlib);
    }
;
}

struct mx_decls$librec *mx_lib$loadlibfile(u8 *filename,i64 libno) {
        struct mx_decls$librec *  plib;
        byte *  p;
    p = mx_lib$readmxfile(filename);
    if ((p == 0)) {
        mx_lib$error((byte*)"Can't find #",filename);
    }
;
    plib = (struct mx_decls$librec *)mx_lib$readlibfile(filename,p);
    (*plib).libno = libno;
    return (struct mx_decls$librec *)(mx_decls$libtable[(libno)-1] = (struct mx_decls$librec *)plib);
}

static void mx_lib$dosymbols(struct mx_decls$librec *lib) {
        i64 ix;
        byte *  baseaddr;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 i;
        ($av_1 = (*lib).ndlllibs);
    for (i=(i64)1;i<=$av_1;++i) {
L1243 :;
        mx_lib$adddll((*(*lib).dllnames)[(i)-1]);
L1244 :;
    }
L1245 :;
    ;
        ($av_2 = (*lib).nimports);
    for (i=(i64)1;i<=$av_2;++i) {
L1246 :;
        ix = mx_lib$addsymbol((*(*lib).importnames)[(i)-1]);
        (*(*lib).importxreftable)[(i)-1] = ix;
L1247 :;
    }
L1248 :;
    ;
        ($av_3 = (*lib).nexports);
    for (i=(i64)1;i<=$av_3;++i) {
L1249 :;
        ix = mx_lib$addsymbol((*(*lib).exports)[(i)-1]);
        if (!!((i64)mx_decls$symboldefined[(ix)-1])) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Dupl symbol:",NULL);
            msysc$m_print_str((*(*lib).exports)[(i)-1],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            goto L1250 ;
        }
;
        mx_decls$symboldefined[(ix)-1] = (i64)1;
                {i64 $temp = (i64)(*(*lib).exportsegs)[(i)-1];
if (($temp==(i64)1)) {
            baseaddr = (*lib).codeptr;
        }
        else if (($temp==(i64)2)) {
            baseaddr = (*lib).idataptr;
        }
        else if (($temp==(i64)3)) {
            baseaddr = (*lib).zdataptr;
        }
        else {
            baseaddr = 0;
        }
        };
        mx_decls$symboladdress[(ix)-1] = (baseaddr + (i64)(*(*lib).exportoffsets)[(i)-1]);
        mx_decls$symbollibindex[(ix)-1] = (*lib).libno;
L1250 :;
    }
L1251 :;
    ;
}

static byte *mx_lib$readmxfile(u8 *filename) {
        byte *  p;
    p = mlib$readfile(filename);
    if ((p == 0)) {
        return 0;
    }
;
    (*(p + mlib$rfsize)) = (i64)13;
    return p;
}

static void mx_lib$adddll(u8 *name) {
        i64 i;
    for (i=(i64)1;i<=mx_decls$ndlllibs;++i) {
L1252 :;
        if (!!(mlib$eqstring(name,mx_decls$dllnametable[(i)-1]))) {
            return;
        }
;
L1253 :;
    }
L1254 :;
    ;
    if ((mx_decls$ndlllibs >= (i64)20)) {
        mx_lib$error((byte*)"Too many DLLs",(byte*)"");
    }
;
    mx_decls$dllnametable[(++(mx_decls$ndlllibs))-1] = name;
}

static i64 mx_lib$addsymbol(u8 *name) {
        i64 i;
    for (i=(i64)1;i<=mx_decls$nsymbols;++i) {
L1255 :;
        if (!!(mlib$eqstring(name,mx_decls$symbolnametable[(i)-1]))) {
            return i;
        }
;
L1256 :;
    }
L1257 :;
    ;
    if ((mx_decls$nsymbols >= (i64)3000)) {
        mx_lib$error((byte*)"Too many Imports",(byte*)"");
    }
;
    mx_decls$symbolnametable[(++(mx_decls$nsymbols))-1] = name;
    return mx_decls$nsymbols;
}

static void mx_lib$setspecialglobals(i64 cmdskip) {
        i64 i;
    for (i=(i64)1;i<=mx_decls$nsymbols;++i) {
L1258 :;
        if (((u64)(*mx_decls$symbolnametable[(i)-1]) == '$')) {
            if (!!(mlib$eqstring(mx_decls$symbolnametable[(i)-1],(byte*)"$cmdskip"))) {
                (*(byte *)mx_decls$symboladdress[(i)-1]) = cmdskip;
            }
;
        }
;
L1259 :;
    }
L1260 :;
    ;
}

void mx_lib$runprogram(struct mx_decls$librec *lib,i64 cmdskip) {
        void (*fnptr)(void);
        i64 libno;
        i64 i;
    libno = (*lib).libno;
    for (i=(i64)1;i<=mx_decls$nlibs;++i) {
L1261 :;
        if (((i != libno) && !(!!((i64)mx_decls$libinitdone[(i)-1])))) {
            mx_lib$calllibinit((struct mx_decls$librec *)mx_decls$libtable[(i)-1]);
        }
;
L1262 :;
    }
L1263 :;
    ;
    if (((*lib).entryaddr == 0)) {
        mx_lib$error((byte*)"No entry point found",(byte*)"");
    }
;
    mx_lib$setspecialglobals(cmdskip);
    fnptr = (void (*)(void))(*lib).entryaddr;
    ((*fnptr))();
    mx_decls$libinitdone[(libno)-1] = (i64)1;
}

void mx_lib$calllibinit(struct mx_decls$librec *lib) {
        void (*fnptr)(void);
        i64 libno;
    libno = (*lib).libno;
    if (!!((*lib).entryaddr)) {
        fnptr = (void (*)(void))(*lib).entryaddr;
        ((*fnptr))();
    }
;
    mx_decls$libinitdone[((*lib).libno)-1] = (i64)1;
}

void *mx_lib$findsymbol(u8 *name) {
        i64 i;
    for (i=(i64)1;i<=mx_decls$nsymbols;++i) {
L1264 :;
        if (!!(mlib$eqstring(mx_decls$symbolnametable[(i)-1],name))) {
            return mx_decls$symboladdress[(i)-1];
        }
;
L1265 :;
    }
L1266 :;
    ;
    return 0;
}

struct mx_decls$librec *mx_lib$loadmx(u8 *filename) {
        struct mx_decls$librec *  plib;
        i64 newlib;
        u8 *  name;
    name = mlib$pcm_copyheapstring(mlib$convlcstring(mlib$extractbasefile(filename)));
    mx_lib$checknew(name,filename);
    newlib = mx_lib$mxaddlib(name);
    plib = (struct mx_decls$librec *)mx_lib$loadlibfile(filename,newlib);
    mx_lib$loadimports((struct mx_decls$librec *)plib);
    return plib;
}

struct mx_decls$librec *mx_lib$loadmemmcb(u8 *filename,byte *p) {
        struct mx_decls$librec *  plib;
        i64 newlib;
        u8 *  name;
    name = mlib$pcm_copyheapstring(mlib$convlcstring(mlib$extractbasefile(filename)));
    mx_lib$checknew(name,filename);
    newlib = mx_lib$mxaddlib(name);
    plib = (struct mx_decls$librec *)mx_lib$readlibfile(filename,p);
    (*plib).libno = newlib;
    mx_decls$libtable[(newlib)-1] = (struct mx_decls$librec *)plib;
    mx_lib$loadimports((struct mx_decls$librec *)plib);
    return plib;
}

void mx_lib$mltest(void) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"MLTEST CALLED",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

// START
void mx_lib$start(void) {

}

void mx_show$initlogfile(void) {
    if ((mx_show$logdest==(i64)2)) {
        remove((byte*)"rx.log");
        mx_show$logdev = fopen((byte*)"rx.log",(byte*)"w");
    }
    else if ((mx_show$logdest==(i64)0) || (mx_show$logdest==(i64)1)) {
        mx_show$logdev = 0;
    }
;
}

void mx_show$closelogfile(void) {
        u8 str[512];
    if ((mx_show$logdest == (i64)2)) {
        fclose(mx_show$logdev);
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"\\m\\ed.bat",NULL);
        msysc$m_print_str((byte*)"rx.log",NULL);
        msysc$m_print_end();
        ;
        mlinux$os_execwait((u8 *)str,(i64)1,0);
    }
;
}

void mx_show$showlibs(void) {
        i64 i;
    mx_show$showglobals(mx_show$logdev);
    for (i=(i64)1;i<=mx_decls$nlibs;++i) {
L1267 :;
        mx_show$showlib((struct mx_decls$librec *)mx_decls$libtable[(i)-1],mx_show$logdev);
L1268 :;
    }
L1269 :;
    ;
}

void mx_show$showlib(struct mx_decls$librec *lib,void *logdev) {
        u8 str[300];
        i64 n;
        u8 *(*names)[];
        i64 i;
    mlib$gs_init((struct mlib$strbuffer *)mx_show$dest);
    mx_show$showstrln((byte*)"-------------------------");
    mx_show$showstr((byte*)"LIBFILE: ");
    mx_show$showstr((*lib).libname);
    mx_show$showstr((byte*)" ");
    mx_show$showstrln((*lib).filespec);
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"Version:",NULL);
    msysc$m_print_str((*lib).version,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    mx_show$showstrln((byte*)"");
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Zdata size: # #");
    msysc$m_print_i64((*lib).zdatasize,NULL);
    msysc$m_print_ptr((*lib).zdataptr,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Idata size: # #");
    msysc$m_print_i64((*lib).idatasize,NULL);
    msysc$m_print_ptr((*lib).idataptr,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    mx_show$showsectiondata((*lib).idataptr,(*lib).idatasize);
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Code size: # # Extra:#");
    msysc$m_print_i64((*lib).codesize,NULL);
    msysc$m_print_ptr((*lib).codeptr,NULL);
    msysc$m_print_i64((*lib).codexsize,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    mx_show$showsectioncode((*lib).codeptr,(*lib).codesize,(*lib).codexsize);
    mx_show$showrelocs((struct mx_decls$librec *)lib);
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"DLL Libs #");
    msysc$m_print_i64((n = (*lib).ndlllibs),NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    mx_show$shownames((*lib).dllnames,n);
    mx_show$showstrln((byte*)"");
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Libs #");
    msysc$m_print_i64((n = (*lib).nlibs),NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    mx_show$shownames((*lib).libnames,n);
    mx_show$showstrln((byte*)"");
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Imports #");
    msysc$m_print_i64((n = (*lib).nimports),NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    names = (*lib).importnames;
    for (i=(i64)1;i<=n;++i) {
L1270 :;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"   #: #");
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((*names)[(i)-1],(byte*)"20jl");
        msysc$m_print_end();
        ;
        mx_show$showstrln(str);
L1271 :;
    }
L1272 :;
    ;
    mx_show$showstrln((byte*)"");
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Exports #");
    msysc$m_print_i64((n = (*lib).nexports),NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    names = (*lib).exports;
    mx_show$showstrln((byte*)"     Name                 Seg      Offset");
    mx_show$showstrln((byte*)"--------------------------------------------");
    for (i=(i64)1;i<=n;++i) {
L1273 :;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#: # # #");
        msysc$m_print_i64(i,(byte*)"3");
        msysc$m_print_str((*names)[(i)-1],(byte*)"20jl");
        msysc$m_print_str(mx_lib$segmentnames[((i64)(*(*lib).exportsegs)[(i)-1])],(byte*)"8jl");
        msysc$m_print_u64((*(*lib).exportoffsets)[(i)-1],(byte*)"8zh");
        msysc$m_print_end();
        ;
        mx_show$showstrln(str);
L1274 :;
    }
L1275 :;
    ;
    mx_show$showstrln((byte*)"");
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Entry point offset:  #");
    msysc$m_print_u64((*lib).entryoffset,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Entry point address: #");
    msysc$m_print_ptr((*lib).entryaddr,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    mx_show$showstrln((byte*)"");
    //finish:
L1276 :;
;
    mlib$gs_println((struct mlib$strbuffer *)mx_show$dest,logdev);
}

static void mx_show$showstr(u8 *str) {
    mlib$gs_str((struct mlib$strbuffer *)mx_show$dest,str);
}

static void mx_show$showstrln(u8 *str) {
    mlib$gs_strln((struct mlib$strbuffer *)mx_show$dest,str);
}

static void mx_show$showstrint(i64 a) {
    mlib$gs_strint((struct mlib$strbuffer *)mx_show$dest,a);
}

static void mx_show$shownames(u8 *(*names)[],i64 n) {
        u8 str[300];
        i64 i;
    for (i=(i64)1;i<=n;++i) {
L1277 :;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"   #: #");
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str((*names)[(i)-1],NULL);
        msysc$m_print_end();
        ;
        mx_show$showstrln(str);
L1278 :;
    }
L1279 :;
    ;
}

static void mx_show$showrelocs(struct mx_decls$librec *lib) {
        u8 str[300];
        struct mx_decls$mcxreloc r;
        i64 n;
        i64 m;
        u64 targetoffset;
        struct mx_show$showrelocs$dummy ubase;
        i64 i;
    n = (*lib).nrelocs;
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Relocs #");
    msysc$m_print_i64((n = (*lib).nrelocs),NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    mx_show$showstrln((byte*)"     Type       Seg      Offset    Symbol/Target+Offset");
    mx_show$showstrln((byte*)"---------------------------------------------------------");
    for (i=(i64)1;i<=n;++i) {
L1280 :;
        r = (*(*lib).reloctable)[(i)-1];
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#: # # ##");
        msysc$m_print_i64(i,(byte*)"3");
        msysc$m_print_str(mx_decls$mcxrelocnames[((i64)r.reloctype)],(byte*)"10jl");
        msysc$m_print_str(mx_lib$segmentnames[((i64)r.segment)],(byte*)"8jl");
        msysc$m_print_i64((i64)r.offset,(byte*)"8zh");
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)"  ",NULL);
        msysc$m_print_end();
        ;
        m = strlen(str);
                {i64 $temp = (i64)r.reloctype;
if (($temp==(i64)1) || ($temp==(i64)2)) {
                        {i64 $temp = (i64)r.segment;
if (($temp==(i64)1)) {
                ubase.baseptr64 = (u64 *)((*lib).codeptr + (i64)r.offset);
            }
            else if (($temp==(i64)2)) {
                ubase.baseptr64 = (u64 *)((*lib).idataptr + (i64)r.offset);
            }
            };
            if (((i64)r.reloctype == (i64)1)) {
                targetoffset = (u64)(i64)(*ubase.baseptr32);
            }
            else {
                targetoffset = (*ubase.baseptr64);
            }
;
            msysc$m_print_startstr((str + m));
            msysc$m_print_str(mx_lib$segmentnames[((i64)r.targetsegment)],(byte*)"6jlt:");
            msysc$m_print_nogap();
            msysc$m_print_u64(targetoffset,(byte*)"8zh");
            msysc$m_print_end();
            ;
        }
        else {
            msysc$m_print_startstr((str + m));
            msysc$m_print_str((*(*lib).importnames)[((i64)r.stindex)-1],NULL);
            msysc$m_print_end();
            ;
        }
        };
        mx_show$showstrln(str);
L1281 :;
    }
L1282 :;
    ;
    mx_show$showstrln((byte*)"");
}

static void mx_show$showsectiondata(byte *p,i64 length) {
        i64 i;
        i64 k;
        i64 bb;
        u8 str[128];
        u8 str2[128];
        byte *  baseaddr;
        i64 $av_1;
    mx_show$showstr((byte*)"proc Section ");
    mx_show$showstr((byte*)"Idata:");
    mx_show$showstr((byte*)" Size:");
    mx_show$showstrint(length);
    mlib$gs_line((struct mlib$strbuffer *)mx_show$dest);
    mlib$gs_line((struct mlib$strbuffer *)mx_show$dest);
    k = (i64)0;
    str[((i64)1)-1] = (u64)0u;
    baseaddr = 0;
    msysc$m_print_startstr(str2);
    msysc$m_print_ptr(baseaddr,(byte*)"Z8H");
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)": ",NULL);
    msysc$m_print_end();
    ;
    mx_show$showstr((u8 *)str2);
    for (i=(i64)1;i<=length;++i) {
L1283 :;
        bb = (i64)(*(p)++);
        msysc$m_print_startstr(str2);
        msysc$m_print_i64(bb,(byte*)"z2H");
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
        mx_show$showstr((u8 *)str2);
        if (((i64)32<=bb && bb<=(i64)127)) {
            str2[((i64)1)-1] = (u64)bb;
            str2[((i64)2)-1] = (u64)0u;
            strcat((u8 *)str,(u8 *)str2);
        }
        else {
            strcat((u8 *)str,(byte*)".");
        }
;
        if (((++(k) == (i64)16) || (i == length))) {
            if ((k < (i64)16)) {
                $av_1 = ((i64)16 - k);
                while ($av_1-- > 0) {
L1286 :;
                    mx_show$showstr((byte*)"   ");
                    strcat((u8 *)str,(byte*)" ");
L1287 :;
                }
L1288 :;
                ;
            }
;
            mx_show$showstr((byte*)"\t[");
            mx_show$showstr((u8 *)str);
            mx_show$showstrln((byte*)"]");
            k = (i64)0;
            str[((i64)1)-1] = (u64)0u;
            baseaddr += (i64)16;
            msysc$m_print_startstr(str2);
            msysc$m_print_ptr(baseaddr,(byte*)"z8h");
            msysc$m_print_nogap();
            msysc$m_print_str((byte*)": ",NULL);
            msysc$m_print_end();
            ;
            mx_show$showstr((u8 *)str2);
        }
;
L1284 :;
    }
L1285 :;
    ;
    if ((k == (i64)0)) {
        mlib$gs_line((struct mlib$strbuffer *)mx_show$dest);
    }
;
    mlib$gs_line((struct mlib$strbuffer *)mx_show$dest);
    if (!!(k)) {
        mlib$gs_line((struct mlib$strbuffer *)mx_show$dest);
    }
;
}

static void mx_show$showsectioncode(byte *p,i64 length,i64 extra) {
        byte *  codeptr;
        byte *  codeend;
        byte *  codeendx;
        byte *  codestart;
        i64 offset;
        u8 *  s;
        u8 str[16];
        byte *  baseaddr;
    mx_show$showstrln((byte*)"proc Section Code");
    codestart = (codeptr = p);
    codeend = (codeptr + length);
    codeendx = (codeend + extra);
    baseaddr = 0;
    L1289 :;
    while ((codeptr < codeendx)) {
        if ((codeptr == codeend)) {
            mx_show$showstrln((byte*)"");
        }
;
        offset = (codeptr - codestart);
        s = 0;
        if ((s == 0)) {
            goto L1291 ;
        }
;
        msysc$m_print_startstr(str);
        msysc$m_print_i64(offset,(byte*)"4");
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)" ",NULL);
        msysc$m_print_end();
        ;
        mx_show$showstr((u8 *)str);
        mx_show$showstrln(s);
L1290 :;
    }
L1291 :;
    ;
    mlib$gs_line((struct mlib$strbuffer *)mx_show$dest);
}

void mx_show$showglobals(void *logdev) {
        u8 str[300];
        u8 name[300];
        i64 i;
    mlib$gs_init((struct mlib$strbuffer *)mx_show$dest);
    mx_show$showstrln((byte*)"Global Tables\n");
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"DLLs:",NULL);
    msysc$m_print_i64(mx_decls$ndlllibs,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    for (i=(i64)1;i<=mx_decls$ndlllibs;++i) {
L1292 :;
        msysc$m_print_startstr(str);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)":",NULL);
        msysc$m_print_str(mx_decls$dllnametable[(i)-1],(byte*)"16jl");
        msysc$m_print_u64(mx_decls$dllinsttable[(i)-1],(byte*)"h");
        msysc$m_print_end();
        ;
        mx_show$showstrln(str);
L1293 :;
    }
L1294 :;
    ;
    mx_show$showstrln((byte*)"");
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"LIBs:",NULL);
    msysc$m_print_i64(mx_decls$nlibs,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    for (i=(i64)1;i<=mx_decls$nlibs;++i) {
L1295 :;
        msysc$m_print_startstr(str);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_nogap();
        msysc$m_print_str((byte*)":",NULL);
        msysc$m_print_str(mx_decls$libnametable[(i)-1],(byte*)"20jl");
        msysc$m_print_str((!!((i64)mx_decls$librelocated[(i)-1]) ? (byte*)"Relocated" : (byte*)"-"),NULL);
        msysc$m_print_end();
        ;
        mx_show$showstrln(str);
L1296 :;
    }
L1297 :;
    ;
    mx_show$showstrln((byte*)"");
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"Global Symbols:",NULL);
    msysc$m_print_i64(mx_decls$nsymbols,NULL);
    msysc$m_print_end();
    ;
    mx_show$showstrln(str);
    mx_show$showstrln((byte*)"     Name              Def Address       Lib        Dll");
    mx_show$showstrln((byte*)"-----------------------------------------------------------");
    for (i=(i64)1;i<=mx_decls$nsymbols;++i) {
L1298 :;
        strcpy(name,mx_decls$symbolnametable[(i)-1]);
        if ((strlen(name) > (i64)17)) {
            strcat(name,(byte*)"\n                      ");
        }
;
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#: # # #  # #");
        msysc$m_print_i64(i,(byte*)"3");
        msysc$m_print_str(name,(byte*)"17jl");
        msysc$m_print_str((!!((i64)mx_decls$symboldefined[(i)-1]) ? (byte*)"Y" : (byte*)"-"),(byte*)"3JL");
        msysc$m_print_ptr(mx_decls$symboladdress[(i)-1],(byte*)"Z12H");
        msysc$m_print_str((!!((i64)mx_decls$symbollibindex[(i)-1]) ? mx_decls$libnametable[((i64)mx_decls$symbollibindex[(i)-1])-1] : (byte*)"-"),(byte*)"10jl");
        msysc$m_print_str((!!((i64)mx_decls$symboldllindex[(i)-1]) ? mx_decls$dllnametable[((i64)mx_decls$symboldllindex[(i)-1])-1] : (byte*)"-"),(byte*)"10jl");
        msysc$m_print_end();
        ;
        mx_show$showstrln(str);
L1299 :;
    }
L1300 :;
    ;
    mx_show$showstrln((byte*)"");
    mlib$gs_println((struct mlib$strbuffer *)mx_show$dest,logdev);
}

// START
void mx_show$start(void) {

}

void msysc$m_init(i64 nargs,u8 *(*args)[],u8 *(*envstrings)[]) {
        i64 j;
        i64 i;
    msysc$nsysparams = nargs;
    if ((msysc$nsysparams > (i64)128)) {
        printf((byte*)"Too many params\n");
        exit((i64)1);
    }
;
    for (i=(i64)1;i<=nargs;++i) {
L1301 :;
        msysc$sysparams[(i)-1] = (*args)[(i)-1];
L1302 :;
    }
L1303 :;
    ;
    msysc$ncmdparams = (msysc$nsysparams - (msysc$$cmdskip + (i64)1));
    msysc$cmdparams = (u8 *(*)[])&msysc$sysparams[((msysc$$cmdskip + (i64)1))-1];
    j = (i64)1;
    msysc$nenvstrings = (i64)0;
    L1304 :;
    while (!!((*envstrings)[(j)-1])) {
        ++(msysc$nenvstrings);
        ++(j);
L1305 :;
    }
L1306 :;
    ;
}

i64 msysc$m_getdotindex(u64 a,i64 i) {
    return (((i64)a & ((i64)1 << i)) >> i);
}

u64 msysc$m_setdotindex(u64 a,i64 i,i64 x) {
    return (u64)(((i64)a & ~(((i64)1 << i))) | (i64)((u64)x << i));
}

i64 msysc$m_getdotslice(u64 a,i64 i,i64 j) {
    if ((i >= j)) {
        return (i64)((a >> j) & ~(((u64)18446744073709551615u << ((i - j) + (i64)1))));
    }
    else {
        return (i64)((a >> i) & ~(((u64)18446744073709551615u << ((j - i) + (i64)1))));
    }
;
}

u64 msysc$m_setdotslice(u64 a,i64 i,i64 j,u64 x) {
        u64 mask64;
    if ((i > j)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"SETDOTSLICE?",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)52);
    }
;
    mask64 = (~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i);
    return ((a & ~(mask64)) | (x << i));
}

i64 msysc$m_get_nprocs(void) {
    return msysc$_fnnprocs;
}

i64 msysc$m_get_nexports(void) {
    return msysc$_fnnexports;
}

u8 *msysc$m_get_procname(i64 n) {
    return msysc$_fnnames[(n)-1];
}

void *msysc$m_get_procaddr(i64 n) {
    return msysc$_fnaddresses[(n)-1];
}

void *msysc$m_get_procexport(i64 n) {
    return 0;
}

static void msysc$pushio(void) {
    if ((msysc$niostack >= (i64)10)) {
        printf((byte*)"Too many io levels\n");
        exit((i64)53);
    }
;
    ++(msysc$niostack);
    msysc$outchan_stack[(msysc$niostack)-1] = msysc$outchan;
    msysc$outdev_stack[(msysc$niostack)-1] = msysc$outdev;
    msysc$fmtstr_stack[(msysc$niostack)-1] = msysc$fmtstr;
    msysc$needgap_stack[(msysc$niostack)-1] = msysc$needgap;
    msysc$needgap = (i64)0;
    msysc$fmtstr = 0;
    msysc$outchan = 0;
}

void msysc$m_print_startfile(void *dev) {
    msysc$pushio();
    msysc$outchan = dev;
    if (!!(dev)) {
        msysc$outdev = (i64)2;
    }
    else {
        msysc$outdev = (i64)1;
    }
;
}

void msysc$m_print_startstr(u8 *s) {
        u8 **  p;
    msysc$pushio();
    msysc$ptr_stack[(msysc$niostack)-1] = s;
    p = &msysc$ptr_stack[(msysc$niostack)-1];
    msysc$outchan = p;
    msysc$outdev = (i64)3;
}

void msysc$m_print_startptr(u8 **p) {
    msysc$pushio();
    msysc$outchan = p;
    msysc$outdev = (i64)3;
}

void msysc$m_print_startcon(void) {
    msysc$pushio();
    msysc$outdev = (i64)1;
}

void msysc$m_print_setfmt(u8 *format) {
    msysc$fmtstr = format;
}

void msysc$m_print_end(void) {
    msysc$needgap = (i64)0;
    msysc$nextfmtchars((i64)1);
    if ((msysc$niostack == (i64)0)) {
        return;
    }
;
    msysc$outchan = msysc$outchan_stack[(msysc$niostack)-1];
    msysc$outdev = msysc$outdev_stack[(msysc$niostack)-1];
    msysc$fmtstr = msysc$fmtstr_stack[(msysc$niostack)-1];
    msysc$needgap = (i64)msysc$needgap_stack[(msysc$niostack)-1];
    --(msysc$niostack);
}

void msysc$m_print_ptr(void *a,u8 *fmtstyle) {
    msysc$nextfmtchars((i64)0);
    msysc$printstr(msysc$strword((u64)a,(byte*)"z8h"));
    msysc$needgap = (i64)1;
}

void msysc$m_print_i64(i64 a,u8 *fmtstyle) {
        u8 s[40];
        struct msysc$fmtrec fmt;
        i64 n;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        if ((a >= (i64)0)) {
            n = msysc$u64tostr((u64)a,(u8 *)s,(u64)10u,(i64)0);
        }
        else {
            s[((i64)1)-1] = '-';
            n = (msysc$u64tostr((u64)-(a),(u8 *)&s[((i64)2)-1],(u64)10u,(i64)0) + (i64)1);
        }
;
        msysc$printstr_n((u8 *)s,n);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        if (((u64)fmt.param == 'V')) {
            msysc$fmtparam = a;
            msysc$needgap = (i64)0;
        }
        else {
            msysc$tostr_i64(a,(struct msysc$fmtrec *)&fmt);
        }
;
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_u64(u64 a,u8 *fmtstyle) {
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysc$printstr(msysc$strword(a,0));
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_u64(a,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_r64(r64 x,u8 *fmtstyle) {
        u8 s[360];
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        sprintf((u8 *)s,(byte*)"%f",x);
        msysc$printstr((u8 *)s);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_r64(x,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_r32(r32 x,u8 *fmtstyle) {
    msysc$m_print_r64((r64)x,fmtstyle);
}

void msysc$m_print_c8(i64 a,u8 *fmtstyle) {
        u8 s[40];
    msysc$nextfmtchars((i64)0);
    s[((i64)1)-1] = (u64)a;
    s[((i64)2)-1] = (u64)0u;
    msysc$printstr((u8 *)s);
    msysc$needgap = (i64)1;
}

void msysc$m_print_str(u8 *s,u8 *fmtstyle) {
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysc$printstr(s);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_str(s,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_newline(void) {
    msysc$needgap = (i64)0;
    msysc$nextfmtchars((i64)1);
    msysc$printstr((byte*)"\r\n");
}

void msysc$m_print_nogap(void) {
    msysc$needgap = (i64)0;
}

void msysc$m_print_space(void) {
    msysc$needgap = (i64)0;
    msysc$printstr((byte*)" ");
}

void msysc$printstr(u8 *s) {
        u8 **  p;
    if ((msysc$outdev==(i64)1)) {
        printf((byte*)"%s",s);
    }
    else if ((msysc$outdev==(i64)2)) {
        fprintf(msysc$outchan,(byte*)"%s",s);
    }
    else if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        strcpy((*p),s);
        (*p) += strlen(s);
    }
;
}

void msysc$printstr_n(u8 *s,i64 n) {
        u8 str[256];
        u8 **  p;
    if ((n==(i64)-1)) {
        n = strlen(s);
    }
    else if ((n==(i64)0)) {
        return;
    }
;
    if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        memcpy((void *)(*p),(void *)s,(u64)n);
        (*p) += n;
        (*(*p)) = (u64)0u;
    }
    else if ((msysc$outdev==(i64)2)) {
        s = msysc$makezstring(s,n,(u8 *)str);
        fprintf(msysc$outchan,(byte*)"%s",s);
        msysc$freezstring(s,n);
    }
    else if ((msysc$outdev==(i64)1)) {
        s = msysc$makezstring(s,n,(u8 *)str);
        printf((byte*)"%s",s);
        msysc$freezstring(s,n);
    }
;
}

void msysc$printstrn_app(u8 *s,i64 length,void *f) {
    if (!!(length)) {
        if ((f == 0)) {
            printf((u8*)"%.*s",(i32)length,s);;
        }
        else {
            fprintf(f,(u8*)"%.*s",(i32)length,s);;
        }
;
    }
;
}

static u8 *msysc$makezstring(u8 *s,i64 n,u8 *local) {
        u8 *  t;
    if ((n < (i64)256)) {
        memcpy((void *)local,(void *)s,(u64)n);
        (*(local + n)) = (u64)0u;
        return local;
    }
    else {
        t = (u8 *)mlib$pcm_alloc((n + (i64)1));
        memcpy((void *)t,(void *)s,(u64)n);
        (*(t + n)) = (u64)0u;
        return t;
    }
;
}

static void msysc$freezstring(u8 *t,i64 n) {
    if ((n >= (i64)256)) {
        mlib$pcm_free((void *)t,(n + (i64)1));
    }
;
}

static void msysc$printchar(i64 ch) {
        u8 **  p;
    if ((msysc$outdev==(i64)1)) {
        printf((u8*)"%c",(int)ch);
    }
    else if ((msysc$outdev==(i64)2)) {
        fprintf(msysc$outchan,(u8*)"%c",(int)ch);
    }
    else if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        (*(*p)) = (u64)ch;
        (*p) += (i64)1;
        (*(*p)) = (u64)0u;
    }
;
}

void msysc$nextfmtchars(i64 lastx) {
        u8 c;
        u8 *  pstart;
        i64 n;
    if (!(!!(msysc$fmtstr))) {
        if (!!(msysc$needgap)) {
            msysc$printchar((i64)32);
        }
;
        msysc$needgap = (i64)0;
        return;
    }
;
    pstart = msysc$fmtstr;
    n = (i64)0;
    L1307 :;
    while (1) {
        c = (u64)(*msysc$fmtstr);
        switch ((i64)(u64)c) {
        case 35:;
            {
                if (!!(lastx)) {
                    goto L1309 ;
;
                }
;
                ++(msysc$fmtstr);
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                }
;
                return;
            }
            break;
        case 0:;
            {
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                }
                else if (!(!!(lastx))) {
                    msysc$printstr_n((byte*)"|",(i64)1);
                }
;
                return;
            }
            break;
        case 126:;
            {
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                    n = (i64)0;
                }
;
                ++(msysc$fmtstr);
                c = (u64)(*msysc$fmtstr);
                if (!!((u64)c)) {
                    ++(msysc$fmtstr);
                    msysc$printchar((i64)(u64)c);
                }
;
                pstart = msysc$fmtstr;
            }
            break;
        default: {
            //skip:
L1309 :;
;
            ++(n);
            ++(msysc$fmtstr);
        }
        } //SW
;
    }
L1308 :;
    ;
}

void msysc$strtofmt(u8 *s,i64 slen,struct msysc$fmtrec *fmt) {
        u8 c;
        byte wset;
        i64 n;
        u8 str[100];
    (*fmt) = msysc$defaultfmt;
    if ((s == 0)) {
        return;
    }
;
    if ((slen == (i64)-1)) {
        slen = strlen(s);
    }
;
    memcpy(str,(void *)s,(u64)slen);
    str[(slen)] = (u64)0u;
    s = (u8 *)str;
    wset = (i64)0;
    L1310 :;
    while (!!((u64)(*s))) {
        c = (u64)(*s);
        ++(s);
        switch ((i64)(u64)c) {
        case 66:;
        case 98:;
            {
                (*fmt).base = (i64)2;
            }
            break;
        case 72:;
        case 104:;
            {
                (*fmt).base = (i64)16;
            }
            break;
        case 79:;
        case 111:;
            {
                (*fmt).base = (i64)8;
            }
            break;
        case 88:;
        case 120:;
            {
                c = (u64)(*s);
                if (!!((u64)c)) {
                    switch ((i64)(u64)c) {
                    case 48:;
                    case 49:;
                    case 50:;
                    case 51:;
                    case 52:;
                    case 53:;
                    case 54:;
                    case 55:;
                    case 56:;
                    case 57:;
                        {
                            c = ((u64)c - '0');
                        }
                        break;
                    case 65:;
                    case 66:;
                    case 67:;
                    case 68:;
                    case 69:;
                    case 70:;
                        {
                            c = (u64)((i64)((u64)c - 'A') + (i64)10);
                        }
                        break;
                    case 97:;
                    case 98:;
                    case 99:;
                    case 100:;
                    case 101:;
                    case 102:;
                        {
                            c = (u64)((i64)((u64)c - 'a') + (i64)10);
                        }
                        break;
                    default: {
                        c = (u64)10u;
                    }
                    } //SW
;
                    (*fmt).base = (i64)(u64)c;
                    ++(s);
                }
;
            }
            break;
        case 81:;
        case 113:;
            {
                (*fmt).quotechar = '"';
            }
            break;
        case 126:;
            {
                (*fmt).quotechar = '~';
            }
            break;
        case 74:;
        case 106:;
            {
                (*fmt).justify = (u64)toupper((i32)(u64)(*s));
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 65:;
            {
                (*fmt).lettercase = 'A';
            }
            break;
        case 97:;
            {
                (*fmt).lettercase = 'a';
            }
            break;
        case 90:;
        case 122:;
            {
                (*fmt).padchar = '0';
            }
            break;
        case 83:;
        case 115:;
            {
                (*fmt).sepchar = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 80:;
        case 112:;
            {
                (*fmt).padchar = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 84:;
        case 116:;
            {
                (*fmt).suffix = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 87:;
        case 119:;
            {
                (*fmt).usigned = 'W';
            }
            break;
        case 69:;
        case 101:;
            {
                (*fmt).realfmt = 'e';
            }
            break;
        case 70:;
        case 102:;
            {
                (*fmt).realfmt = 'f';
            }
            break;
        case 71:;
        case 103:;
            {
                (*fmt).realfmt = 'g';
            }
            break;
        case 46:;
            {
                wset = (i64)1;
            }
            break;
        case 44:;
        case 95:;
            {
                (*fmt).sepchar = (u64)c;
            }
            break;
        case 43:;
            {
                (*fmt).plus = '+';
            }
            break;
        case 68:;
        case 100:;
            {
                (*fmt).charmode = 'D';
            }
            break;
        case 67:;
        case 99:;
            {
                (*fmt).charmode = 'C';
            }
            break;
        case 77:;
        case 109:;
            {
                (*fmt).heapmode = 'M';
            }
            break;
        case 86:;
        case 118:;
            {
                (*fmt).param = 'V';
            }
            break;
        case 42:;
            {
                n = msysc$fmtparam;
                goto L1313 ;
;
            }
            break;
        default: {
            if ((((u64)c >= '0') && ((u64)c <= '9'))) {
                n = (i64)((u64)c - '0');
                L1314 :;
                while (1) {
                    c = (u64)(*s);
                    if (((i64)(u64)(*s) == (i64)0)) {
                        goto L1315 ;
                    }
;
                    if ((((u64)c >= '0') && ((u64)c <= '9'))) {
                        ++(s);
                        n = (((n * (i64)10) + (i64)(u64)c) - (i64)48);
                    }
                    else {
                        goto L1315 ;
                    }
;
                }
L1315 :;
                ;
                //gotwidth:
L1313 :;
;
                if (!(!!((i64)wset))) {
                    (*fmt).minwidth = n;
                    wset = (i64)1;
                }
                else {
                    (*fmt).precision = n;
                }
;
            }
;
        }
        } //SW
;
L1311 :;
    }
L1312 :;
    ;
}

static i64 msysc$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt) {
        u8 str[20];
        u8 *  q;
        i64 nchars;
        i64 $av_1;
    q = (u8 *)str;
    nchars = n;
    $av_1 = n;
    while ($av_1-- > 0) {
L1316 :;
        if (((i64)(u64)(*p) == (i64)0)) {
            goto L1318 ;
        }
;
        (*q) = (u64)(*p);
        ++(q);
        ++(p);
L1317 :;
    }
L1318 :;
    ;
    (*q) = (u64)0u;
    return msysc$expandstr((u8 *)str,dest,strlen((u8 *)str),(struct msysc$fmtrec *)fmt);
}

static i64 msysc$expandstr(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt) {
        i64 i;
        i64 w;
        i64 m;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
        i64 $av_5;
    w = (i64)(*fmt).minwidth;
    if (((w == (i64)0) || (w <= n))) {
        strncpy(t,s,(u64)n);
        (*(t + n)) = (u64)0u;
        return n;
    }
;
    if (((u64)(*fmt).justify == 'L')) {
        strncpy(t,s,(u64)n);
        t += n;
                ($av_1 = (w - n));
        for (i=(i64)1;i<=$av_1;++i) {
L1319 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1320 :;
        }
L1321 :;
        ;
        (*t) = (u64)0u;
    }
    else if (((u64)(*fmt).justify == 'R')) {
        if (((((u64)(*fmt).padchar == '0') && !!((i64)(*fmt).base)) && (((u64)(*s) == '-') || ((u64)(*s) == '+')))) {
            (*t) = (u64)(*s);
            ++(t);
            $av_2 = (w - n);
            while ($av_2-- > 0) {
L1322 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L1323 :;
            }
L1324 :;
            ;
            strncpy(t,(s + (i64)1),(u64)(n - (i64)1));
            (*((t + n) - (i64)1)) = (u64)0u;
        }
        else {
            $av_3 = (w - n);
            while ($av_3-- > 0) {
L1325 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L1326 :;
            }
L1327 :;
            ;
            strncpy(t,s,(u64)n);
            (*(t + n)) = (u64)0u;
        }
;
    }
    else {
        m = (((w - n) + (i64)1) / (i64)2);
        $av_4 = m;
        while ($av_4-- > 0) {
L1328 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1329 :;
        }
L1330 :;
        ;
        strncpy(t,s,(u64)n);
        t += n;
        $av_5 = ((w - n) - m);
        while ($av_5-- > 0) {
L1331 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1332 :;
        }
L1333 :;
        ;
        (*t) = (u64)0u;
    }
;
    return w;
}

static i64 msysc$u64tostr(u64 aa,u8 *s,u64 base,i64 sep) {
        u8 t[360];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
        u8 *  s0;
    i = (i64)0;
    k = (i64)0;
    g = (((i64)base == (i64)10) ? (i64)3 : (i64)4);
    L1334 :;
    do {
        t[(++(i))] = (u64)msysc$digits[((i64)(aa % base))];
        aa = (aa / base);
        ++(k);
        if (((!!(sep) && ((i64)aa != (i64)0)) && (k == g))) {
            t[(++(i))] = (u64)sep;
            k = (i64)0;
        }
;
L1335 :;
    }
    while (!((i64)aa == (i64)0));
L1336 :;
    ;
    j = i;
    s0 = s;
    L1337 :;
    while (!!(i)) {
        (*s) = (u64)t[((i)--)];
        ++(s);
L1338 :;
    }
L1339 :;
    ;
    (*s) = (u64)0u;
    return j;
}

static i64 msysc$i64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        i64 usigned;
        static u64 mindint = (u64)9223372036854775808u;
    usigned = (i64)0;
    if (!!((u64)(*fmt).usigned)) {
        usigned = (i64)1;
    }
;
    if (((aa == (i64)mindint) && !(!!(usigned)))) {
        str[((i64)0)] = '-';
        n = (msysc$i64mintostr((u8 *)&str[((i64)1)],(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
    }
    else {
        if (((!(!!(usigned)) && (aa < (i64)0)) || !!((u64)(*fmt).plus))) {
            if ((aa < (i64)0)) {
                aa = -(aa);
                str[((i64)0)] = '-';
            }
            else {
                str[((i64)0)] = '+';
            }
;
            n = (msysc$u64tostr((u64)aa,(u8 *)&str[((i64)1)],(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
        }
        else {
            n = msysc$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
        }
;
    }
;
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if (((((i64)(*fmt).base > (i64)10) || !!((u64)(*fmt).suffix)) && ((u64)(*fmt).lettercase == 'a'))) {
        msysc$convlcstring((u8 *)str);
    }
;
    return msysc$expandstr((u8 *)str,s,n,(struct msysc$fmtrec *)fmt);
}

static i64 msysc$u64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
    n = msysc$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if ((((i64)(*fmt).base > (i64)10) || (!!((u64)(*fmt).suffix) && ((u64)(*fmt).lettercase == 'a')))) {
        msysc$convlcstring((u8 *)str);
    }
;
    return msysc$expandstr((u8 *)str,s,n,(struct msysc$fmtrec *)fmt);
}

static i64 msysc$i64mintostr(u8 *s,i64 base,i64 sep) {
        u8 t[360];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
    switch (base) {
    case 10:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"9223372036854775808");
            j = (i64)3;
        }
        break;
    case 16:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"8000000000000000");
            j = (i64)1;
        }
        break;
    case 2:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"1000000000000000000000000000000000000000000000000000000000000000");
            j = (i64)7;
        }
        break;
    default: {
        strcpy((u8 *)&t[((i64)0)],(byte*)"<mindint>");
    }
    } //SW
;
    i = strlen((u8 *)&t[((i64)0)]);
    s += i;
    if (!!(sep)) {
        s += j;
    }
;
    (*s) = (u64)0u;
    k = (i64)0;
    g = ((base == (i64)10) ? (i64)3 : (i64)4);
    L1340 :;
    while (!!(i)) {
        --(s);
        (*s) = (u64)t[(((i)-- - (i64)1))];
        if (((!!(sep) && !!(i)) && (++(k) == g))) {
            --(s);
            (*s) = (u64)sep;
            k = (i64)0;
        }
;
L1341 :;
    }
L1342 :;
    ;
    return strlen(s);
}

static i64 msysc$strtostrfmt(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt) {
        u8 *  u;
        u8 *  v;
        u8 str[256];
        i64 w;
        i64 nheap;
    nheap = (i64)0;
    if ((!!((u64)(*fmt).quotechar) || !!((u64)(*fmt).lettercase))) {
        if ((n < (i64)256)) {
            u = (u8 *)str;
        }
        else {
            nheap = (n + (i64)3);
            u = (u8 *)mlib$pcm_alloc(nheap);
        }
;
        if (!!((u64)(*fmt).quotechar)) {
            v = u;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            if (!!(n)) {
                strcpy(v,s);
                v += n;
            }
;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            (*v) = (u64)0u;
            n += (i64)2;
        }
        else {
            memcpy((void *)u,(void *)s,(u64)n);
        }
;
        switch ((i64)(u64)(*fmt).lettercase) {
        case 97:;
            {
                msysc$convlcstring(u);
            }
            break;
        case 65:;
            {
                msysc$convucstring(u);
            }
            break;
        } //SW
;
        s = u;
    }
;
    w = (i64)(*fmt).minwidth;
    if ((w > n)) {
        n = msysc$expandstr(s,t,n,(struct msysc$fmtrec *)fmt);
    }
    else {
        memcpy((void *)t,(void *)s,(u64)n);
    }
;
    if (!!(nheap)) {
        mlib$pcm_free((void *)u,nheap);
    }
;
    return n;
}

static void msysc$tostr_i64(i64 a,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp==(u64)0u)) {
        n = msysc$i64tostrfmt(a,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='D') || ($temp=='d')) {
        n = msysc$domultichar((u8 *)&a,(i64)8,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else {
        msysc$printchar(a);
        return;
    }
    };
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_u64(u64 a,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp=='D') || ($temp=='d')) {
        n = msysc$domultichar((u8 *)&a,(i64)8,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='C') || ($temp=='c')) {
        msysc$printchar((i64)a);
        return;
    }
    else {
        n = msysc$u64tostrfmt((i64)a,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    };
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_r64(r64 x,struct msysc$fmtrec *fmt) {
        u8 str[360];
        u8 str2[360];
        u8 cfmt[10];
        i64 n;
    cfmt[((i64)0)] = '%';
    if (!!((i64)(*fmt).precision)) {
        cfmt[((i64)1)] = '.';
        cfmt[((i64)2)] = '*';
        cfmt[((i64)3)] = (u64)(*fmt).realfmt;
        cfmt[((i64)4)] = (u64)0u;
        sprintf((u8 *)str,(u8 *)cfmt,(i64)(*fmt).precision,x);
    }
    else {
        cfmt[((i64)1)] = (u64)(*fmt).realfmt;
        cfmt[((i64)2)] = (u64)0u;
        sprintf((u8 *)str,(u8 *)cfmt,x);
    }
;
    n = strlen((u8 *)str);
    if ((n < (i64)(*fmt).minwidth)) {
        n = msysc$expandstr((u8 *)str,(u8 *)str2,n,(struct msysc$fmtrec *)fmt);
        strcpy((u8 *)str,(u8 *)str2);
    }
;
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_str(u8 *s,struct msysc$fmtrec *fmt) {
        i64 oldlen;
        i64 newlen;
        i64 n;
        u8 *  t;
    oldlen = strlen(s);
    newlen = oldlen;
    if (((!!((u64)(*fmt).quotechar) || ((i64)(*fmt).minwidth > newlen)) || !!((u64)(*fmt).lettercase))) {
        if (!!((u64)(*fmt).quotechar)) {
            newlen += (i64)2;
        }
;
        if (((i64)(*fmt).minwidth > newlen)) {
            newlen = (i64)(*fmt).minwidth;
        }
;
        t = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        n = msysc$strtostrfmt(s,t,oldlen,(struct msysc$fmtrec *)fmt);
        msysc$printstr_n(t,n);
        mlib$pcm_free((void *)t,(newlen + (i64)1));
    }
    else {
        msysc$printstr_n(s,oldlen);
    }
;
}

static struct msysc$fmtrec *msysc$getfmt(u8 *fmtstyle) {
        static struct msysc$fmtrec fmt;
    if (!!(fmtstyle)) {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        return (struct msysc$fmtrec *)&fmt;
    }
    else {
        return (struct msysc$fmtrec *)&msysc$defaultfmt;
    }
;
}

u8 *msysc$strint(i64 a,u8 *fmtstyle) {
        static u8 str[100];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_i64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

void msysc$getstrint(i64 a,u8 *dest) {
    msysc$m_print_startstr(dest);
    msysc$tostr_i64(a,(struct msysc$fmtrec *)msysc$getfmt(0));
    msysc$m_print_end();
}

u8 *msysc$strword(u64 a,u8 *fmtstyle) {
        static u8 str[100];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_u64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

u8 *msysc$strreal(r64 a,u8 *fmtstyle) {
        static u8 str[320];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_r64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

static u8 *msysc$getstr(u8 *s,struct msysc$fmtrec *fmt) {
    if (!!((u64)(*fmt).heapmode)) {
        return mlib$pcm_copyheapstring(s);
    }
    else {
        return s;
    }
;
}

static void msysc$initreadbuffer(void) {
    if (!!(msysc$rd_buffer)) {
        return;
    }
;
    msysc$rd_buffer = (u8 *)mlib$pcm_alloc((i64)16384);
    (*msysc$rd_buffer) = (u64)0u;
    msysc$rd_pos = (msysc$rd_lastpos = msysc$rd_buffer);
}

void msysc$m_read_conline(void) {
    msysc$initreadbuffer();
    msysc$rd_length = strlen(msysc$rd_buffer);
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

void msysc$m_read_fileline(void *f) {
    msysc$initreadbuffer();
    msysc$rd_length = strlen(msysc$rd_buffer);
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

void msysc$m_read_strline(u8 *s) {
        i64 n;
    msysc$initreadbuffer();
    n = strlen(s);
    if ((n < (i64)16384)) {
        strcpy(msysc$rd_buffer,s);
    }
    else {
        memcpy((void *)msysc$rd_buffer,(void *)s,(u64)16383u);
        (*((msysc$rd_buffer + (i64)16384) - (i64)1)) = (u64)0u;
    }
;
    msysc$rd_length = n;
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

static u8 *msysc$readitem(i64 *itemlength) {
        u8 *  p;
        u8 *  s;
        u8 *  itemstr;
        u8 quotechar;
        u8 c;
    if (!(!!(msysc$rd_buffer))) {
        msysc$initreadbuffer();
    }
;
    s = msysc$rd_pos;
    L1343 :;
    while ((((u64)(*s) == ' ') || ((i64)(u64)(*s) == (i64)9))) {
        ++(s);
L1344 :;
    }
L1345 :;
    ;
    itemstr = s;
    msysc$rd_lastpos = (msysc$rd_pos = s);
    if (((i64)(u64)(*s) == (i64)0)) {
        msysc$termchar = (i64)0;
        (*itemlength) = (i64)0;
        return s;
    }
;
    quotechar = (u64)0u;
    if (((u64)(*s) == '"')) {
        quotechar = '"';
        ++(s);
    }
    else if (((u64)(*s) == (u64)39u)) {
        quotechar = (u64)39u;
        ++(s);
    }
;
    p = (itemstr = s);
    L1346 :;
    while (!!((u64)(*s))) {
        c = (u64)(*(s)++);
        switch ((i64)(u64)c) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
            {
                if ((!!((u64)quotechar) || (p == s))) {
                    goto L1349 ;
;
                }
;
                msysc$termchar = (i64)(u64)c;
                goto L1348 ;
            }
            break;
        default: {
            //normalchar:
L1349 :;
;
            if (((u64)c == (u64)quotechar)) {
                if (((u64)(*s) == (u64)quotechar)) {
                    (*p) = (u64)c;
                    ++(s);
                    ++(p);
                }
                else {
                    msysc$termchar = (i64)(u64)(*s);
                    if (((msysc$termchar == (i64)44) || (msysc$termchar == (i64)61))) {
                        ++(s);
                        msysc$termchar = (i64)(u64)(*s);
                    }
;
                    goto L1348 ;
                }
;
            }
            else {
                (*p) = (u64)c;
                ++(p);
            }
;
        }
        } //SW
;
L1347 :;
    }
L1348 :;
    ;
    if (((i64)(u64)(*s) == (i64)0)) {
        msysc$termchar = (i64)0;
    }
;
    (*itemlength) = (p - itemstr);
    msysc$rd_pos = s;
    return itemstr;
}

i64 msysc$strtoint(u8 *s,i64 length,i64 base) {
        byte signd;
        u64 aa;
        u8 c;
        u8 d;
    msysc$itemerror = (i64)0;
    if ((length == (i64)-1)) {
        length = strlen(s);
    }
;
    signd = (i64)0;
    if ((!!(length) && ((u64)(*s) == '-'))) {
        signd = (i64)1;
        ++(s);
        --(length);
    }
    else if ((!!(length) && ((u64)(*s) == '+'))) {
        ++(s);
        --(length);
    }
;
    aa = (u64)0u;
    L1350 :;
    while (!!(length)) {
        c = (u64)(*(s)++);
        --(length);
        switch ((i64)(u64)c) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
            {
                d = (u64)((i64)((u64)c - 'A') + (i64)10);
            }
            break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
            {
                d = (u64)((i64)((u64)c - 'a') + (i64)10);
            }
            break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                d = ((u64)c - '0');
            }
            break;
        case 95:;
        case 39:;
            {
                goto L1351 ;
            }
            break;
        default: {
            msysc$itemerror = (i64)1;
            goto L1352 ;
        }
        } //SW
;
        if (((i64)(u64)d >= base)) {
            msysc$itemerror = (i64)1;
            goto L1352 ;
        }
;
        aa = (u64)(((i64)aa * base) + (i64)(u64)d);
L1351 :;
    }
L1352 :;
    ;
    if (!!((i64)signd)) {
        return (i64)-(aa);
    }
    else {
        return (i64)aa;
    }
;
}

i64 msysc$m_read_i64(i64 fmt) {
        u8 *  s;
        i64 length;
    if ((fmt==(i64)67) || (fmt==(i64)99)) {
        msysc$rd_lastpos = msysc$rd_pos;
        if (!!((u64)(*msysc$rd_pos))) {
            return (i64)(u64)(*(msysc$rd_pos)++);
        }
        else {
            return (i64)0;
        }
;
    }
    else if ((fmt==(i64)84) || (fmt==(i64)116)) {
        return msysc$termchar;
    }
    else if ((fmt==(i64)69) || (fmt==(i64)101)) {
        return msysc$itemerror;
    }
;
    s = msysc$readitem(&length);
    if ((fmt==(i64)0) || (fmt==(i64)73) || (fmt==(i64)105)) {
        return msysc$strtoint(s,length,(i64)10);
    }
    else if ((fmt==(i64)66) || (fmt==(i64)98)) {
        return msysc$strtoint(s,length,(i64)2);
    }
    else if ((fmt==(i64)72) || (fmt==(i64)104)) {
        return msysc$strtoint(s,length,(i64)16);
    }
;
    return (i64)0;
}

r64 msysc$m_read_r64(i64 fmt) {
        u8 str[512];
        u8 *  s;
        i64 length;
        i32 numlength;
        r64 x;
    s = msysc$readitem(&length);
    if (((length == (i64)0) || (length >= (i64)512))) {
        return (double)0.;
    }
;
    memcpy(str,(void *)s,(u64)length);
    str[((length + (i64)1))-1] = (u64)0u;
    msysc$itemerror = (i64)0;
    if (((sscanf((u8 *)str,(byte*)"%lf%n",&x,&numlength) == (i64)0) || ((i64)numlength != length))) {
        x = (double)0.;
        msysc$itemerror = (i64)1;
    }
;
    return x;
}

void msysc$m_read_str(u8 *dest,i64 destlen,i64 fmt) {
        u8 *  s;
        i64 length;
    msysc$itemerror = (i64)0;
    if (((fmt == (i64)76) || (fmt == (i64)108))) {
        s = msysc$rd_pos;
        length = ((msysc$rd_buffer + msysc$rd_length) - msysc$rd_pos);
    }
    else {
        s = msysc$readitem(&length);
        if (((fmt == (i64)78) || (fmt == (i64)110))) {
            msysc$iconvlcn(s,length);
        }
;
    }
;
    if ((destlen > (i64)0)) {
        if ((length >= destlen)) {
            length = (destlen - (i64)1);
            msysc$itemerror = (i64)1;
        }
;
    }
;
    memcpy((void *)dest,(void *)s,(u64)length);
    (*(dest + length)) = (u64)0u;
}

void msysc$readstr(u8 *dest,i64 fmt,i64 destlen) {
    msysc$m_read_str(dest,destlen,fmt);
}

void msysc$rereadln(void) {
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = msysc$rd_pos;
}

void msysc$reread(void) {
    msysc$rd_pos = msysc$rd_lastpos;
}

i64 msysc$valint(u8 *s,i64 fmt) {
        u8 *  old_pos;
        u8 *  old_lastpos;
        i64 aa;
    msysc$initreadbuffer();
    old_pos = msysc$rd_pos;
    old_lastpos = msysc$rd_lastpos;
    msysc$rd_pos = s;
    aa = msysc$m_read_i64(fmt);
    msysc$rd_pos = old_pos;
    msysc$rd_lastpos = old_lastpos;
    return aa;
}

r64 msysc$valreal(u8 *s) {
        u8 *  old_pos;
        u8 *  old_lastpos;
        r64 x;
    msysc$initreadbuffer();
    old_pos = msysc$rd_pos;
    old_lastpos = msysc$rd_lastpos;
    msysc$rd_pos = s;
    x = msysc$m_read_r64((i64)0);
    msysc$rd_pos = old_pos;
    msysc$rd_lastpos = old_lastpos;
    return x;
}

static void msysc$iconvlcn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1353 :;
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1354 :;
    }
L1355 :;
    ;
}

static void msysc$iconvucn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1356 :;
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1357 :;
    }
L1358 :;
    ;
}

static void msysc$convlcstring(u8 *s) {
    L1359 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1360 :;
    }
L1361 :;
    ;
}

static void msysc$convucstring(u8 *s) {
    L1362 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1363 :;
    }
L1364 :;
    ;
}

i64 msysc$m_power_i64(i64 n,i64 a) {
    if ((n < (i64)0)) {
        return (i64)0;
    }
    else if ((n == (i64)0)) {
        return (i64)1;
    }
    else if ((n == (i64)1)) {
        return a;
    }
    else if (((n & (i64)1) == (i64)0)) {
        return msysc$m_power_i64((n / (i64)2),(a*a));
    }
    else {
        return (msysc$m_power_i64(((n - (i64)1) / (i64)2),(a*a)) * a);
    }
;
}

void msysc$m_intoverflow(void) {
    mlib$abortprogram((byte*)"Integer overflow detected");
}

void msysc$m_dotindex(u64 i,u64 a) {
    mlib$abortprogram((byte*)"DOT INDEX");
}

void msysc$m_dotslice(u64 j,u64 i,u64 a) {
    mlib$abortprogram((byte*)"DOT SLICE");
}

void msysc$m_popdotindex(u64 i,u64 *p,u64 x) {
    mlib$abortprogram((byte*)"POP DOT INDEX");
}

void msysc$m_popdotslice(u64 j,u64 i,u64 *p,u64 x) {
    mlib$abortprogram((byte*)"POP DOT SLICE");
}

i64 msysc$m_imin(i64 a,i64 b) {
    return (a<b?a:b);
}

i64 msysc$m_imax(i64 a,i64 b) {
    return (a>b?a:b);
}

r64 msysc$m_sign(r64 x) {
    if ((x > (double)0.)) {
        return (double)1.;
    }
    else if ((x < (double)0.)) {
        return (double)-1.;
    }
    else {
        return (double)0.;
    }
;
}

r64 msysc$m_tp_i64tor64(i64 a) {
        r64 x;
    memcpy(&x,&a,(u64)8u);
    return x;
}

i64 msysc$m_tp_r64toi64(r64 x) {
        i64 a;
    memcpy(&a,&x,(u64)8u);
    return a;
}

i64 msysc$m_tp_reftoi64(void *p) {
        i64 a;
    memcpy(&a,&p,(u64)8u);
    return a;
}

void *msysc$m_tp_i64toref(i64 a) {
        void *  p;
    memcpy(&p,&a,(u64)8u);
    return p;
}

// START
void msysc$start(void) {
    mlib$start();
    mclib$start();
    mlinux$start();
    mwindllc$start();

}

void *mlib$pcm_alloc(i64 n) {
        byte *  p;
    if (!(!!((i64)mlib$pcm_setup))) {
        mlib$pcm_init();
    }
;
    if ((n > (i64)2048)) {
        mlib$alloccode = mlib$pcm_getac(n);
        mlib$allocbytes = (i64)mlib$allocupper[(mlib$alloccode)];
        p = (byte *)mlib$allocmem(mlib$allocbytes);
        if (!(!!(p))) {
            mlib$abortprogram((byte*)"pcm_alloc failure");
        }
;
        if ((u64)0u) {
            mlib$addtomemalloc((i32 *)p,mlib$allocbytes);
        }
;
        return p;
    }
;
    mlib$alloccode = (i64)mlib$sizeindextable[(n)];
    mlib$allocbytes = (i64)mlib$allocupper[(mlib$alloccode)];
    mlib$smallmemtotal += mlib$allocbytes;
    if (!!((p = (byte *)mlib$freelist[(mlib$alloccode)]))) {
        if ((u64)0u) {
            mlib$addtomemalloc((i32 *)p,mlib$allocbytes);
        }
;
        mlib$freelist[(mlib$alloccode)] = (u64 *)(i64)(*mlib$freelist[(mlib$alloccode)]);
        return p;
    }
;
    p = mlib$pcheapptr;
    mlib$pcheapptr += mlib$allocbytes;
    if ((mlib$pcheapptr >= mlib$pcheapend)) {
        p = (byte *)mlib$pcm_newblock(mlib$allocbytes);
        return p;
    }
;
    if ((u64)0u) {
        mlib$addtomemalloc((i32 *)p,mlib$allocbytes);
    }
;
    return p;
}

void mlib$pcm_free(void *p,i64 n) {
        i64 acode;
    if ((n == (i64)0)) {
        return;
    }
;
    if ((n > (i64)2048)) {
        if ((u64)0u) {
            mlib$removefrommemalloc((i32 *)p,n);
        }
;
        mlib$maxmemtotal -= n;
        free(p);
        return;
    }
;
    if (!!(p)) {
        acode = (i64)mlib$sizeindextable[(n)];
        mlib$smallmemtotal -= (i64)mlib$allocupper[(acode)];
        if ((u64)0u) {
            mlib$removefrommemalloc((i32 *)p,(i64)mlib$allocupper[(acode)]);
        }
;
        (*(u64 *)p) = (u64)(i64)mlib$freelist[(acode)];
        mlib$freelist[(acode)] = (u64 *)p;
    }
;
}

void mlib$pcm_freeac(void *p,i64 alloc) {
    mlib$pcm_free(p,(i64)mlib$allocupper[(alloc)]);
}

void mlib$pcm_clearmem(void *p,i64 n) {
    memset(p,(i32)(i64)0,(u64)n);
}

void mlib$pcm_init(void) {
        i64 j;
        i64 k;
        i64 size;
        i64 i;
    mlib$alloccode = (i64)0;
    if (!!((i64)mlib$pcm_setup)) {
        return;
    }
;
    mlib$pcm_newblock((i64)0);
    for (i=(i64)1;i<=(i64)2048;++i) {
L1365 :;
        j = (i64)1;
        k = (i64)16;
        L1368 :;
        while ((i > k)) {
            k = (k << (i64)1);
            ++(j);
L1369 :;
        }
L1370 :;
        ;
        mlib$sizeindextable[(i)] = j;
L1366 :;
    }
L1367 :;
    ;
    mlib$allocupper[((i64)1)] = (u64)16u;
    size = (i64)16;
    for (i=(i64)2;i<=(i64)27;++i) {
L1371 :;
        size *= (i64)2;
        mlib$allocupper[(i)] = (u64)size;
        if ((size >= (i64)33554432)) {
            k = i;
            goto L1373 ;
        }
;
L1372 :;
    }
L1373 :;
    ;
    for (i=(k + (i64)1);i<=(i64)300;++i) {
L1374 :;
        size += (i64)33554432;
        if ((size < (i64)8589934592)) {
            mlib$allocupper[(i)] = (u64)size;
            mlib$maxmemory = (u64)size;
        }
        else {
            mlib$maxalloccode = (i - (i64)1);
            goto L1376 ;
        }
;
L1375 :;
    }
L1376 :;
    ;
    mlib$pcm_setup = (i64)1;
}

i64 mlib$pcm_getac(i64 size) {
    if ((size <= (i64)2048)) {
        return (i64)mlib$sizeindextable[(size)];
    }
;
    size = ((size + (i64)255) >> (i64)8);
    if ((size <= (i64)2048)) {
        return ((i64)mlib$sizeindextable[(size)] + (i64)8);
    }
;
    size = ((size + (i64)63) >> (i64)6);
    if ((size <= (i64)2048)) {
        return ((i64)mlib$sizeindextable[(size)] + (i64)14);
    }
;
    size = ((((size - (i64)2048) + (i64)2047) / (i64)2048) + (i64)22);
    return size;
}

void *mlib$pcm_newblock(i64 itemsize) {
        static i64 totalheapsize;
        byte *  p;
    totalheapsize += (i64)2097152;
    mlib$alloccode = (i64)0;
    p = (byte *)mlib$allocmem((i64)2097152);
    if ((p == 0)) {
        mlib$abortprogram((byte*)"Can't alloc pc heap");
    }
;
    mlib$pcheapptr = p;
    mlib$pcheapend = (p + (i64)2097152);
    if ((mlib$pcheapstart == 0)) {
        mlib$pcheapstart = p;
    }
;
    mlib$pcheapptr += itemsize;
    return (u32 *)p;
}

i64 mlib$pcm_round(i64 n) {
        static i32 allocbytes[9] = {(i32)(i64)0,(i32)(i64)16,(i32)(i64)32,(i32)(i64)64,(i32)(i64)128,(i32)(i64)256,(i32)(i64)512,(i32)(i64)1024,(i32)(i64)2048};
    if ((n > (i64)2048)) {
        return n;
    }
    else {
        return (i64)allocbytes[((i64)mlib$sizeindextable[(n)])];
    }
;
}

void *mlib$pcm_allocz(i64 n) {
        void *  p;
    p = mlib$pcm_alloc(n);
    memset(p,(i32)(i64)0,(u64)n);
    return p;
}

u8 *mlib$pcm_copyheapstring(u8 *s) {
        u8 *  q;
        i64 n;
    if ((s == 0)) {
        return 0;
    }
;
    n = (strlen(s) + (i64)1);
    q = (u8 *)mlib$pcm_alloc(n);
    memcpy((void *)q,(void *)s,(u64)n);
    return q;
}

u8 *mlib$pcm_copyheapstringn(u8 *s,i64 n) {
        u8 *  q;
    if ((s == 0)) {
        return 0;
    }
;
    q = (u8 *)mlib$pcm_alloc((n + (i64)1));
    memcpy((void *)q,(void *)s,(u64)n);
    (*(q + n)) = (u64)0u;
    return q;
}

u8 *mlib$pcm_copyheapblock(u8 *s,i64 length) {
        u8 *  q;
    if ((length == (i64)0)) {
        return 0;
    }
;
    q = (u8 *)mlib$pcm_alloc(length);
    memcpy((void *)q,(void *)s,(u64)length);
    return q;
}

static void mlib$addtomemalloc(i32 *ptr,i64 size) {
        i64 allocated;
        i64 code;
        i64 i;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"***************ADD TO ALLOC:",NULL);
    msysc$m_print_ptr(ptr,NULL);
    msysc$m_print_i64(size,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=(i64)2;++i) {
L1377 :;
        if ((mlib$memalloctable[(i)-1] == ptr)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"ALLOC ERROR:",NULL);
            msysc$m_print_ptr(ptr,NULL);
            msysc$m_print_str((byte*)"ALREADY ALLOCATED\n\n\n",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            exit((i64)2);
        }
;
        if ((mlib$memalloctable[(i)-1] == 0)) {
            mlib$memalloctable[(i)-1] = ptr;
            code = mlib$pcm_getac(size);
            allocated = (i64)mlib$allocupper[(code)];
            mlib$memallocsize[(i)-1] = allocated;
            return;
        }
;
L1378 :;
    }
L1379 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"MEMALLOCTABLE FULL\n\n\n\n",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlinux$os_getch();
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)3);
}

static void mlib$removefrommemalloc(i32 *ptr,i64 size) {
        i64 allocated;
        i64 code;
        i64 i;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"------------------************REMOVE FROM ALLOC:",NULL);
    msysc$m_print_ptr(ptr,NULL);
    msysc$m_print_i64(size,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    code = mlib$pcm_getac(size);
    allocated = (i64)mlib$allocupper[(code)];
    for (i=(i64)1;i<=(i64)2;++i) {
L1380 :;
        if ((mlib$memalloctable[(i)-1] == ptr)) {
            if (((i64)mlib$memallocsize[(i)-1] != allocated)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"REMOVE:FOUND",NULL);
                msysc$m_print_ptr(ptr,NULL);
                msysc$m_print_str((byte*)"IN MEMALLOCTABLE, ROUNDED FREESIZE=",NULL);
                msysc$m_print_i64(allocated,NULL);
                msysc$m_print_str((byte*)", BUT STORED AS BLOCK SIZE:",NULL);
                msysc$m_print_i64((i64)mlib$memallocsize[(i)-1],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                mlib$abortprogram((byte*)"MEMSIZE");
            }
;
            mlib$memalloctable[(i)-1] = 0;
            return;
        }
;
L1381 :;
    }
L1382 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"CAN'T FIND",NULL);
    msysc$m_print_ptr(ptr,NULL);
    msysc$m_print_str((byte*)"IN MEMALLOCTABLE",NULL);
    msysc$m_print_i64(size,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlinux$os_getch();
    mlib$abortprogram((byte*)"MEM");
    exit((i64)4);
}

void *mlib$allocmem(i64 n) {
        void *  p;
    p = malloc((u64)n);
    if (!!(p)) {
        return p;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_i64(mlib$memtotal,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$abortprogram((byte*)"Alloc mem failure");
    return 0;
}

void *mlib$reallocmem(void *p,i64 n) {
    p = realloc(p,(u64)n);
    if (!!(p)) {
        return p;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$abortprogram((byte*)"Realloc mem failure");
    return 0;
}

void mlib$abortprogram(u8 *s) {
    msysc$m_print_startcon();
    msysc$m_print_str(s,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"ABORTING: Press key...",NULL);
    msysc$m_print_end();
    ;
    exit((i64)5);
}

i64 mlib$getfilesize(void *handlex) {
        u32 p;
        u32 size;
    p = ftell(handlex);
    fseek(handlex,(i32)(i64)0,(i32)(i64)2);
    size = ftell(handlex);
    fseek(handlex,(i32)(i64)p,(i32)(i64)0);
    return (i64)size;
}

void mlib$readrandom(void *handlex,byte *mem,i64 offset,i64 size) {
        i64 a;
    fseek(handlex,(i32)offset,(i32)(i64)0);
    a = (i64)fread(mem,(u64)1u,(u64)size,handlex);
}

i64 mlib$writerandom(void *handlex,byte *mem,i64 offset,i64 size) {
    fseek(handlex,(i32)offset,(i32)(i64)0);
    return (i64)fwrite(mem,(u64)1u,(u64)size,handlex);
}

i64 mlib$setfilepos(void *file,i64 offset) {
    return fseek(file,(i32)offset,(i32)(i64)0);
}

i64 mlib$getfilepos(void *file) {
    return ftell(file);
}

byte *mlib$readfile(u8 *filename) {
        void *  f;
        i64 size;
        byte *  m;
        byte *  p;
    f = fopen(filename,(byte*)"rb");
    if ((f == 0)) {
        return 0;
    }
;
    mlib$rfsize = (size = mlib$getfilesize(f));
    m = (byte *)malloc((u64)(size + (i64)2));
    if ((m == 0)) {
        return 0;
    }
;
    mlib$readrandom(f,m,(i64)0,size);
    p = (m + size);
    (*(u16 *)p) = (i64)0;
    fclose(f);
    return m;
}

i64 mlib$writefile(u8 *filename,byte *data,i64 size) {
        void *  f;
        i64 n;
    f = fopen(filename,(byte*)"wb");
    if ((f == 0)) {
        return (i64)0;
    }
;
    n = mlib$writerandom(f,data,(i64)0,size);
    fclose(f);
    return n;
}

i64 mlib$checkfile(u8 *file) {
        void *  f;
    if (!!((f = fopen(file,(byte*)"rb")))) {
        fclose(f);
        return (i64)1;
    }
;
    return (i64)0;
}

void mlib$readlinen(void *handlex,u8 *buffer,i64 size) {
        i64 ch;
        u8 *  p;
        i64 n;
        byte crseen;
    if ((handlex == 0)) {
        handlex = mlinux$os_getstdin();
    }
;
    if ((handlex == 0)) {
        n = (i64)0;
        p = buffer;
        L1383 :;
        while (1) {
            ch = getchar();
            if ((((ch == (i64)13) || (ch == (i64)10)) || (ch == (i64)-1))) {
                (*p) = (u64)0u;
                return;
            }
;
            (*(p)++) = (u64)ch;
            ++(n);
            if ((n >= (size - (i64)2))) {
                (*p) = (u64)0u;
                return;
            }
;
        }
L1384 :;
        ;
    }
;
    (*buffer) = (u64)0u;
    if ((fgets(buffer,(size - (i64)2),handlex) == 0)) {
        return;
    }
;
    n = strlen(buffer);
    if ((n == (i64)0)) {
        return;
    }
;
    p = ((buffer + n) - (i64)1);
    crseen = (i64)0;
    L1385 :;
    while (((p >= buffer) && (((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10)))) {
        if ((((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10))) {
            crseen = (i64)1;
        }
;
        (*(p)--) = (u64)0u;
L1386 :;
    }
L1387 :;
    ;
    if ((!(!!((i64)crseen)) && ((n + (i64)4) > size))) {
        msysc$m_print_startcon();
        msysc$m_print_i64(size,NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mlib$abortprogram((byte*)"line too long");
    }
;
}

void mlib$iconvlcn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1388 :;
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1389 :;
    }
L1390 :;
    ;
}

void mlib$iconvucn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1391 :;
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1392 :;
    }
L1393 :;
    ;
}

u8 *mlib$convlcstring(u8 *s) {
        u8 *  s0;
    s0 = s;
    L1394 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1395 :;
    }
L1396 :;
    ;
    return s0;
}

u8 *mlib$convucstring(u8 *s) {
        u8 *  s0;
    s0 = s;
    L1397 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1398 :;
    }
L1399 :;
    ;
    return s0;
}

u8 *mlib$changeext(u8 *s,u8 *newext) {
        static u8 newfile[260];
        u8 newext2[32];
        u8 *  sext;
        i64 n;
    strcpy((u8 *)&newfile[((i64)1)-1],s);
        {u64 $temp = (u64)(*newext);
if (($temp==(u64)0u)) {
        newext2[((i64)1)-1] = (u64)0u;
        newext2[((i64)2)-1] = (u64)0u;
    }
    else if (($temp=='.')) {
        strcpy((u8 *)&newext2[((i64)1)-1],newext);
    }
    else {
        strcpy((u8 *)&newext2[((i64)1)-1],(byte*)".");
        strcat((u8 *)&newext2[((i64)1)-1],newext);
    }
    };
    sext = mlib$extractext(s,(i64)1);
        {u64 $temp = (u64)(*sext);
if (($temp==(u64)0u)) {
        strcat((u8 *)&newfile[((i64)1)-1],(u8 *)&newext2[((i64)1)-1]);
    }
    else if (($temp=='.')) {
        strcat((u8 *)&newfile[((i64)1)-1],(u8 *)&newext2[((i64)2)-1]);
    }
    else {
        n = ((sext - s) - (i64)2);
        strcpy((u8 *)((&newfile[((i64)1)-1] + n) + (i64)1),(u8 *)&newext2[((i64)1)-1]);
    }
    };
    return (u8 *)&newfile[((i64)1)-1];
}

u8 *mlib$extractext(u8 *s,i64 period) {
        u8 *  t;
        u8 *  u;
    t = mlib$extractfile(s);
    if (((i64)(u64)(*t) == (i64)0)) {
        return (byte*)"";
    }
;
    u = ((t + strlen(t)) - (i64)1);
    L1400 :;
    while ((u >= t)) {
        if (((u64)(*u) == '.')) {
            if (((i64)(u64)(*(u + (i64)1)) == (i64)0)) {
                return (!!(period) ? (byte*)"." : (byte*)"");
            }
;
            return (u + (i64)1);
        }
;
        --(u);
L1401 :;
    }
L1402 :;
    ;
    return (byte*)"";
}

u8 *mlib$extractpath(u8 *s) {
        static u8 str[260];
        u8 *  t;
        i64 n;
    t = ((s + strlen(s)) - (i64)1);
    L1403 :;
    while ((t >= s)) {
        switch ((i64)(u64)(*t)) {
        case 92:;
        case 47:;
        case 58:;
            {
                n = ((t - s) + (i64)1);
                memcpy(str,(void *)s,(u64)n);
                str[(n)] = (u64)0u;
                return (u8 *)str;
            }
            break;
        } //SW
;
        --(t);
L1404 :;
    }
L1405 :;
    ;
    return (byte*)"";
}

u8 *mlib$extractfile(u8 *s) {
        u8 *  t;
    t = mlib$extractpath(s);
    if (((i64)(u64)(*t) == (i64)0)) {
        return s;
    }
;
    return (s + strlen(t));
}

u8 *mlib$extractbasefile(u8 *s) {
        static u8 str[100];
        u8 *  f;
        u8 *  e;
        i64 n;
        i64 flen;
    f = mlib$extractfile(s);
    flen = strlen(f);
    if ((flen == (i64)0)) {
        return (byte*)"";
    }
;
    e = mlib$extractext(f,(i64)0);
    if (!!((u64)(*e))) {
        n = ((flen - strlen(e)) - (i64)1);
        memcpy(&str,(void *)f,(u64)n);
        str[(n)] = (u64)0u;
        return (u8 *)str;
    }
;
    if (((u64)(*((f + flen) - (i64)1)) == '.')) {
        memcpy(&str,(void *)f,(u64)(flen - (i64)1));
        str[((flen - (i64)1))] = (u64)0u;
        return (u8 *)str;
    }
;
    return f;
}

u8 *mlib$addext(u8 *s,u8 *newext) {
        u8 *  sext;
    sext = mlib$extractext(s,(i64)1);
    if (((i64)(u64)(*sext) == (i64)0)) {
        return mlib$changeext(s,newext);
    }
;
    return s;
}

void *mlib$pcm_alloc32(void) {
        byte *  p;
    mlib$allocbytes = (i64)32;
    mlib$smallmemtotal += (i64)32;
    if (!!((p = (byte *)mlib$freelist[((i64)2)]))) {
        mlib$freelist[((i64)2)] = (u64 *)(i64)(*mlib$freelist[((i64)2)]);
        return p;
    }
;
    return mlib$pcm_alloc((i64)32);
}

void mlib$pcm_free32(void *p) {
    mlib$smallmemtotal -= (i64)32;
    if ((u64)0u) {
        mlib$removefrommemalloc((i32 *)p,(i64)32);
    }
;
    (*(u64 *)p) = (u64)(i64)mlib$freelist[((i64)2)];
    mlib$freelist[((i64)2)] = (u64 *)p;
}

void *mlib$pcm_alloc64(void) {
        byte *  p;
    mlib$allocbytes = (i64)64;
    mlib$smallmemtotal += (i64)64;
    if (!!((p = (byte *)mlib$freelist[((i64)3)]))) {
        mlib$freelist[((i64)3)] = (u64 *)(i64)(*mlib$freelist[((i64)3)]);
        return p;
    }
;
    return mlib$pcm_alloc((i64)64);
}

void mlib$pcm_free64(void *p) {
    mlib$smallmemtotal -= (i64)64;
    if ((u64)0u) {
        mlib$removefrommemalloc((i32 *)p,(i64)64);
    }
;
    (*(u64 *)p) = (u64)(i64)mlib$freelist[((i64)3)];
    mlib$freelist[((i64)3)] = (u64 *)p;
}

void *mlib$pcm_alloc16(void) {
        byte *  p;
    mlib$allocbytes = (i64)16;
    mlib$smallmemtotal += (i64)16;
    if (!!((p = (byte *)mlib$freelist[((i64)1)]))) {
        mlib$freelist[((i64)1)] = (u64 *)(i64)(*mlib$freelist[((i64)1)]);
        return p;
    }
;
    return mlib$pcm_alloc((i64)16);
}

void mlib$pcm_free16(void *p) {
    mlib$smallmemtotal -= (i64)16;
    if ((u64)0u) {
        mlib$removefrommemalloc((i32 *)p,(i64)32);
    }
;
    (*(u64 *)p) = (u64)(i64)mlib$freelist[((i64)1)];
    mlib$freelist[((i64)1)] = (u64 *)p;
}

void mlib$outbyte(void *f,i64 x) {
    fwrite(&x,(u64)1u,(u64)1u,f);
}

void mlib$outword16(void *f,u64 x) {
    fwrite(&x,(u64)2u,(u64)1u,f);
}

void mlib$outword32(void *f,u64 x) {
    fwrite(&x,(u64)4u,(u64)1u,f);
}

void mlib$outword64(void *f,u64 x) {
    fwrite(&x,(u64)8u,(u64)1u,f);
}

void mlib$outstring(void *f,u8 *s) {
    fwrite((void *)s,(u64)(strlen(s) + (i64)1),(u64)1u,f);
}

void mlib$outblock(void *f,void *p,i64 n) {
    fwrite(p,(u64)n,(u64)1u,f);
}

i64 mlib$myeof(void *f) {
        i64 c;
    c = fgetc(f);
    if ((c == (i64)-1)) {
        return (i64)1;
    }
;
    ungetc((i32)c,f);
    return (i64)0;
}

void mlib$strbuffer_add(struct mlib$strbuffer *dest,u8 *s,i64 n) {
        i64 newlen;
        i64 oldlen;
        u8 *  newptr;
    if ((n == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=0",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((n == (i64)-1)) {
        n = strlen(s);
    }
;
    oldlen = (i64)(*dest).length;
    if ((oldlen == (i64)0)) {
        (*dest).strptr = (u8 *)mlib$pcm_alloc((n + (i64)1));
        (*dest).allocated = mlib$allocbytes;
        (*dest).length = n;
        memcpy((void *)(*dest).strptr,(void *)s,(u64)n);
        (*((*dest).strptr + n)) = (u64)0u;
        return;
    }
;
    newlen = (oldlen + n);
    if (((newlen + (i64)1) > (i64)(*dest).allocated)) {
        newptr = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        memcpy((void *)newptr,(void *)(*dest).strptr,(u64)oldlen);
        (*dest).strptr = newptr;
        (*dest).allocated = mlib$allocbytes;
    }
;
    memcpy((void *)((*dest).strptr + oldlen),(void *)s,(u64)n);
    (*((*dest).strptr + newlen)) = (u64)0u;
    (*dest).length = newlen;
}

void mlib$gs_init(struct mlib$strbuffer *dest) {
    mlib$pcm_clearmem(dest,(i64)16);
}

void mlib$gs_free(struct mlib$strbuffer *dest) {
    if (!!((i64)(*dest).allocated)) {
        mlib$pcm_free((void *)(*dest).strptr,(i64)(*dest).allocated);
    }
;
}

void mlib$gs_str(struct mlib$strbuffer *dest,u8 *s) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,(i64)-1);
}

void mlib$gs_char(struct mlib$strbuffer *dest,i64 c) {
        u8 s[16];
    s[((i64)1)-1] = (u64)c;
    s[((i64)2)-1] = (u64)0u;
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(u8 *)s,(i64)1);
}

void mlib$gs_strn(struct mlib$strbuffer *dest,u8 *s,i64 length) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,length);
}

void mlib$gs_strvar(struct mlib$strbuffer *dest,struct mlib$strbuffer *s) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(*s).strptr,(i64)-1);
}

void mlib$gs_strint(struct mlib$strbuffer *dest,i64 a) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,msysc$strint(a,0),(i64)-1);
}

void mlib$gs_strln(struct mlib$strbuffer *dest,u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)dest,s);
    mlib$gs_line((struct mlib$strbuffer *)dest);
}

void mlib$gs_strsp(struct mlib$strbuffer *dest,u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)dest,s);
    mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)" ");
}

void mlib$gs_line(struct mlib$strbuffer *dest) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(byte*)"\r\n",(i64)-1);
}

i64 mlib$gs_getcol(struct mlib$strbuffer *dest) {
    return (i64)(*dest).length;
}

void mlib$gs_leftstr(struct mlib$strbuffer *dest,u8 *s,i64 w,i64 padch) {
        i64 col;
        i64 i;
        i64 n;
        i64 slen;
        u8 str[2560];
    col = (i64)(*dest).length;
    strcpy((u8 *)str,s);
    slen = strlen(s);
    n = (w - slen);
    if ((n > (i64)0)) {
        for (i=(i64)1;i<=n;++i) {
L1406 :;
            str[((slen + i))-1] = (u64)padch;
L1407 :;
        }
L1408 :;
        ;
        str[(((slen + n) + (i64)1))-1] = (u64)0u;
    }
;
    mlib$gs_str((struct mlib$strbuffer *)dest,(u8 *)str);
}

void mlib$gs_leftint(struct mlib$strbuffer *dest,i64 a,i64 w,i64 padch) {
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,msysc$strint(a,0),w,padch);
}

void mlib$gs_padto(struct mlib$strbuffer *dest,i64 col,i64 ch) {
        i64 n;
        u8 str[2560];
        i64 i;
    n = (col - (i64)(*dest).length);
    if ((n <= (i64)0)) {
        return;
    }
;
    for (i=(i64)1;i<=n;++i) {
L1409 :;
        str[(i)-1] = (u64)ch;
L1410 :;
    }
L1411 :;
    ;
    str[((n + (i64)1))-1] = (u64)0u;
    mlib$gs_str((struct mlib$strbuffer *)dest,(u8 *)str);
}

void mlib$gs_println(struct mlib$strbuffer *dest,void *f) {
    if (((i64)(*dest).length == (i64)0)) {
        return;
    }
;
    (*((*dest).strptr + (i64)(*dest).length)) = (u64)0u;
    if ((f == 0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((*dest).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startfile(f);
        msysc$m_print_str((*dest).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

i64 mlib$nextcmdparamnew(i64 *paramno,u8 **name,u8 **value,u8 *defext) {
        static i64 infile = (i64)0;
        static u8 *  filestart = 0;
        static u8 *  fileptr = 0;
        static byte colonseen = (byte)(i64)0;
        u8 *  q;
        u8 *  item;
        u8 *  fileext;
        i64 length;
        static u8 str[300];
    //reenter:
L1412 :;
;
    (*value) = 0;
    (*name) = 0;
    if (!!(infile)) {
        if ((mlib$readnextfileitem(&fileptr,&item) == (i64)0)) {
            free((void *)filestart);
            infile = (i64)0;
            goto L1412 ;
;
        }
;
    }
    else {
        if (((*paramno) > msysc$ncmdparams)) {
            return (i64)0;
        }
;
        item = (*msysc$cmdparams)[((*paramno))];
        ++((*paramno));
        length = strlen(item);
        if (((u64)(*item) == '@')) {
            infile = (i64)1;
            goto L1412 ;
;
        }
;
        if (((u64)(*item) == ':')) {
            colonseen = (i64)1;
            return (i64)4;
        }
;
    }
;
    (*value) = 0;
    if (((u64)(*item) == '-')) {
        (*name) = (item + (!!((i64)colonseen) ? (i64)0 : (i64)1));
        q = strchr(item,(i32)':');
        if (!(!!(q))) {
            q = strchr(item,(i32)'=');
        }
;
        if (!!(q)) {
            (*value) = (q + (i64)1);
            (*q) = (u64)0u;
        }
;
        return (!!((i64)colonseen) ? (i64)5 : (i64)1);
    }
;
    fileext = mlib$extractext(item,(i64)0);
    (*name) = item;
    if (((i64)(u64)(*fileext) == (i64)0)) {
        strcpy((u8 *)str,(*name));
        if ((!!(defext) && !(!!((i64)colonseen)))) {
            (*name) = mlib$addext((u8 *)str,defext);
        }
;
    }
    else if ((!!(mlib$eqstring(fileext,(byte*)"dll")) || !!(mlib$eqstring(fileext,(byte*)"mcx")))) {
        return (!!((i64)colonseen) ? (i64)5 : (i64)3);
    }
;
    if (!!((i64)colonseen)) {
        return (i64)5;
    }
    else {
        return (i64)2;
    }
;
}

static i64 mlib$readnextfileitem(u8 **fileptr,u8 **item) {
        u8 *  p;
        u8 *  pstart;
        u8 *  pend;
        i64 n;
        static u8 str[256];
    p = (*fileptr);
    //reenter:
L1413 :;
;
    L1414 :;
    while (1) {
                {u64 $temp = (u64)(*p);
if (($temp==' ') || ($temp==(u64)9u) || ($temp==(u64)13u) || ($temp==(u64)10u)) {
            ++(p);
        }
        else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
            return (i64)0;
        }
        else {
            goto L1415 ;
        }
        };
    }
L1415 :;
    ;
        {u64 $temp = (u64)(*p);
if (($temp=='!') || ($temp=='#')) {
        ++(p);
        L1416 :;
                {u64 $temp = (u64)(*(p)++);
if (($temp==(u64)10u)) {
            goto L1413 ;
;
        }
        else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
            (*fileptr) = (p - (i64)1);
            return (i64)0;
        }
        else {
        }
        }goto L1416 ;
L1417 :;
        ;
    }
    };
        {u64 $temp = (u64)(*p);
if (($temp=='"')) {
        pstart = ++(p);
        L1418 :;
        while (1) {
                        {u64 $temp = (u64)(*p);
if (($temp==(u64)0u) || ($temp==(u64)26u)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Unexpected EOF in @file",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)8);
            }
            else if (($temp=='"')) {
                pend = (p)++;
                if (((u64)(*p) == ',')) {
                    ++(p);
                }
;
                goto L1419 ;
            }
            };
            ++(p);
        }
L1419 :;
        ;
    }
    else {
        pstart = p;
        L1420 :;
        while (1) {
                        {u64 $temp = (u64)(*p);
if (($temp==(u64)0u) || ($temp==(u64)26u)) {
                pend = p;
                goto L1421 ;
            }
            else if (($temp==' ') || ($temp==(u64)9u) || ($temp==',') || ($temp==(u64)13u) || ($temp==(u64)10u)) {
                pend = (p)++;
                goto L1421 ;
            }
            };
            ++(p);
        }
L1421 :;
        ;
    }
    };
    n = (pend - pstart);
    if ((n >= (i64)256)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"@file item too long",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)9);
    }
;
    memcpy(str,(void *)pstart,(u64)n);
    str[((n + (i64)1))-1] = (u64)0u;
    (*item) = (u8 *)str;
    (*fileptr) = p;
    return (i64)1;
}

void mlib$ipadstr(u8 *s,i64 width,u8 *padchar) {
        i64 n;
        i64 $av_1;
    n = strlen(s);
    $av_1 = (width - n);
    while ($av_1-- > 0) {
L1422 :;
        strcat(s,padchar);
L1423 :;
    }
L1424 :;
    ;
}

u8 *mlib$padstr(u8 *s,i64 width,u8 *padchar) {
        static u8 str[256];
    strcpy((u8 *)str,s);
    mlib$ipadstr((u8 *)str,width,padchar);
    return (u8 *)str;
}

u8 *mlib$chr(i64 c) {
        static u8 str[8];
    str[((i64)1)-1] = (u64)c;
    str[((i64)2)-1] = (u64)0u;
    return (u8 *)str;
}

i64 mlib$cmpstring(u8 *s,u8 *t) {
        i64 res;
    if (((res = strcmp(s,t)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$cmpstringn(u8 *s,u8 *t,i64 n) {
        i64 res;
    if (((res = strncmp(s,t,(u64)n)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$eqstring(u8 *s,u8 *t) {
    return (i64)(strcmp(s,t) == (i64)0);
}

i64 mlib$cmpbytes(void *p,void *q,i64 n) {
        i64 res;
    if (((res = memcmp(p,q,(u64)n)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$eqbytes(void *p,void *q,i64 n) {
    return (i64)(memcmp(p,q,(u64)n) == (i64)0);
}

void mlib$mseed(u64 a,u64 b) {
    mlib$seed[((i64)1)-1] = a;
    if (!!(b)) {
        mlib$seed[((i64)2)-1] = b;
    }
    else {
        mlib$seed[((i64)2)-1] ^= a;
    }
;
}

u64 mlib$mrandom(void) {
        i64 x;
        i64 y;
    x = (i64)mlib$seed[((i64)1)-1];
    y = (i64)mlib$seed[((i64)2)-1];
    mlib$seed[((i64)1)-1] = (u64)y;
    x ^= (x << (i64)23);
    mlib$seed[((i64)2)-1] = (u64)(((x ^ y) ^ (x >> (i64)17)) ^ (y >> (i64)26));
    return (u64)((i64)mlib$seed[((i64)2)-1] + y);
}

i64 mlib$mrandomp(void) {
    return ((i64)mlib$mrandom() & (i64)9223372036854775807);
}

i64 mlib$mrandomint(i64 n) {
    return (mlib$mrandomp() % n);
}

i64 mlib$mrandomrange(i64 a,i64 b) {
        i64 span;
    span = ((b - a) + (i64)1);
    if ((span <= (i64)0)) {
        return (i64)0;
    }
;
    return ((mlib$mrandomp() % span) + a);
}

r64 mlib$mrandomreal(void) {
        r64 x;
    L1425 :;
    do {
        x = ((r64)mlib$mrandomp() / (double)9223372036854775800.);
L1426 :;
    }
    while (!(x != (double)1.));
L1427 :;
    ;
    return x;
}

r64 mlib$mrandomreal1(void) {
    return (r64)(mlib$mrandomp() / (i64)9223372036854775807);
}

byte *mlib$checkpackfile(void) {
        i64 a;
        i64 offset;
        u8 exefile[300];
        byte *  packexeptr;
        i64 packexesize;
        u8 *  packfilename;
        i64 packfilesize;
        byte *  packfileptr;
    strcpy((u8 *)&exefile[((i64)1)-1],mlinux$os_gethostname());
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Attempting to open",NULL);
    msysc$m_print_ptr(&exefile,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    packexeptr = mlib$readfile((u8 *)&exefile[((i64)1)-1]);
    if (!(!!(packexeptr))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Can't open",NULL);
        msysc$m_print_ptr(&exefile,NULL);
        msysc$m_print_ptr(&packexeptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit(0);
    }
;
    packexesize = mlib$rfsize;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"File read OK. Size",NULL);
    msysc$m_print_i64(packexesize,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    a = (i64)(*(i32 *)(packexeptr + (packexesize - (i64)4)));
    if ((a != (i64)1262568272)) {
        free(packexeptr);
        packfileptr = 0;
        return 0;
    }
;
    offset = (i64)(*(i32 *)(packexeptr + (packexesize - (i64)8)));
    packfilename = (u8 *)(packexeptr + offset);
    offset += (strlen(packfilename) + (i64)1);
    packfilesize = (i64)(*(i32 *)(packexeptr + offset));
    packfileptr = ((packexeptr + offset) + (i64)4);
    return packfileptr;
}

u8 *mlib$readline(void) {
    msysc$m_read_conline();
    ;
    return msysc$rd_buffer;
}

void *mlib$findfunction(u8 *name) {
        i64 $av_1;
        i64 i;
        ($av_1 = msysc$m_get_nprocs());
    for (i=(i64)1;i<=$av_1;++i) {
L1428 :;
        if (!!(mlib$eqstring(msysc$m_get_procname(i),name))) {
            return msysc$m_get_procaddr(i);
        }
;
L1429 :;
    }
L1430 :;
    ;
    return 0;
}

i64 mlib$roundtoblock(i64 n,i64 align) {
    if (((n & (align - (i64)1)) == (i64)0)) {
        return n;
    }
;
    return (n + (align - (n & (align - (i64)1))));
}

// START
void mlib$start(void) {

}

// START
void mclib$start(void) {

}

void mlinux$os_init(void) {
    mlinux$init_flag = (i64)1;
}

i64 mlinux$os_execwait(u8 *cmdline,i64 newconsole,u8 *workdir) {
    return system(cmdline);
}

i64 mlinux$os_execcmd(u8 *cmdline,i64 newconsole) {
    return system(cmdline);
}

i64 mlinux$os_getch(void) {
        struct mlinux$termios old;
        struct mlinux$termios new;
        u8 ch;
    tcgetattr((i32)(i64)0,&old);
    new = old;
    new.c_lflag &= (i32)(i64)-3;
    new.c_lflag &= (i32)(i64)-9;
    tcsetattr((i32)(i64)0,(i32)(i64)0,(struct mlinux$termios *)&new);
    ch = (u64)getchar();
    tcsetattr((i32)(i64)0,(i32)(i64)0,(struct mlinux$termios *)&old);
    return (i64)(u64)ch;
}

i64 mlinux$os_kbhit(void) {
    mlib$abortprogram((byte*)"kbhit");
    return (i64)0;
}

void mlinux$os_flushkeys(void) {
    mlib$abortprogram((byte*)"flushkeys");
}

void *mlinux$os_getconsolein(void) {
    return 0;
}

void *mlinux$os_getconsoleout(void) {
    return 0;
}

void *mlinux$os_proginstance(void) {
    mlib$abortprogram((byte*)"PROGINST");
    return 0;
}

u64 mlinux$os_getdllinst(u8 *name) {
        void *  h;
    h = dlopen(name,(i32)(i64)1);
    if ((h == 0)) {
        if ((strcmp(name,(byte*)"msvcrt") == (i64)0)) {
            h = dlopen((byte*)"libc.so.6",(i32)(i64)1);
        }
;
    }
;
    return (u64)h;
}

void *mlinux$os_getdllprocaddr(i64 hlib,u8 *name) {
        void *  fnaddr;
    if ((hlib == (i64)0)) {
        return 0;
    }
;
    fnaddr = dlsym((void *)hlib,name);
    return fnaddr;
}

void mlinux$os_initwindows(void) {
}

i64 mlinux$os_getchx(void) {
    mlib$abortprogram((byte*)"getchx");
    return (i64)0;
}

u8 *mlinux$os_getos(void) {
    if (((i64)64 == (i64)32)) {
        return (byte*)"L32";
    }
    else {
        return (byte*)"L64";
    }
;
}

i64 mlinux$os_gethostsize(void) {
    return (i64)64;
}

i64 mlinux$os_iswindows(void) {
    return (i64)0;
}

i64 mlinux$os_shellexec(u8 *opc,u8 *file) {
    mlib$abortprogram((byte*)"SHELL EXEC");
    return (i64)0;
}

void mlinux$os_sleep(i64 a) {
    sleep((u32)a);
}

void *mlinux$os_getstdin(void) {
    return 0;
}

void *mlinux$os_getstdout(void) {
    return 0;
}

u8 *mlinux$os_gethostname(void) {
    return (byte*)"";
}

u8 *mlinux$os_getmpath(void) {
    return (byte*)"";
}

void mlinux$os_exitprocess(i64 x) {
    exit(0);
}

i64 mlinux$os_clock(void) {
    if (!!(mlinux$os_iswindows())) {
        return clock();
    }
    else {
        return (clock() / (i64)1000);
    }
;
}

i64 mlinux$os_ticks(void) {
    return clock();
}

i64 mlinux$os_getclockspersec(void) {
    if (!!(mlinux$os_iswindows())) {
        return (i64)1000;
    }
    else {
        return (i64)1000000;
    }
;
}

void mlinux$os_setmesshandler(void *addr) {
    mlib$abortprogram((byte*)"SETMESSHANDLER");
}

i64 mlinux$os_hpcounter(void) {
    return (i64)1;
}

i64 mlinux$os_hpfrequency(void) {
    return (i64)1;
}

i64 mlinux$os_filelastwritetime(u8 *filename) {
    return (i64)0;
}

void mlinux$os_getsystime(struct mlinux$rsystemtime *tm) {
    memset(tm,(i32)(i64)0,(u64)36u);
    (*tm).month = (i64)1;
}

void mlinux$os_peek(void) {
}

byte *mlinux$os_allocexecmem(i64 n) {
    mlib$abortprogram((byte*)"No allocexec");
    return (byte *)0;
}

// START
void mlinux$start(void) {

}

u64 mwindllc$os_calldllfunction(void (*fnaddr)(void),i64 retcode,i64 nargs,i64 (*args)[],byte (*argcodes)[]) {
    if ((retcode == (i64)73)) {
        return (u64)mwindllc$calldll_cint((void (*)(void))fnaddr,args,nargs);
    }
    else {
        return (u64)mwindllc$calldll_creal((void (*)(void))fnaddr,args,nargs);
    }
;
}

u64 mwindllc$os_pushargs(u64 (*args)[],i64 nargs,i64 nextra,void (*fnaddr)(void),i64 isfloat) {
    return mwindllc$os_calldllfunction((void (*)(void))fnaddr,(!!(isfloat) ? (i64)0 : (i64)73),nargs,(i64 (*)[])args,0);
}

static i64 mwindllc$calldll_cint(void (*fnaddr)(void),i64 (*params)[],i64 nparams) {
    switch (nparams) {
    case 0:;
        {
            return ((*(i64 (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            return ((*(i64 (*)(i64))fnaddr))((*params)[((i64)1)-1]);
        }
        break;
    case 2:;
        {
            return ((*(i64 (*)(i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1]);
        }
        break;
    case 3:;
        {
            return ((*(i64 (*)(i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1]);
        }
        break;
    case 4:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1]);
        }
        break;
    case 5:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1]);
        }
        break;
    case 6:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1]);
        }
        break;
    case 9:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1]);
        }
        break;
    case 10:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1]);
        }
        break;
    case 11:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1]);
        }
        break;
    case 12:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1],(*params)[((i64)12)-1]);
        }
        break;
    case 14:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1],(*params)[((i64)12)-1],(*params)[((i64)13)-1],(*params)[((i64)14)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"calldll/c/int unsupported # of params",NULL);
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
    } //SW
;
    return (i64)0;
}

static i64 mwindllc$calldll_creal(void (*fnaddr)(void),i64 (*params)[],i64 nparams) {
        r64 x;
    switch (nparams) {
    case 0:;
        {
            return (i64)((*(r64 (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            mwindllc$os_dummycall((r64)(*params)[((i64)1)-1],(r64)(*params)[((i64)2)-1],(r64)(*params)[((i64)3)-1],(r64)(*params)[((i64)4)-1]);
            x = ((*(r64 (*)(i64))fnaddr))((*params)[((i64)1)-1]);
        }
        break;
    case 2:;
        {
            x = ((*(r64 (*)(i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"calldll/c/real too many params",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
    } //SW
;
    return *(i64*)&x;
}

void mwindllc$os_dummycall(r64 a,r64 b,r64 c,r64 d) {
}

// START
void mwindllc$start(void) {

}


/* ********** End of C Code ********** */

